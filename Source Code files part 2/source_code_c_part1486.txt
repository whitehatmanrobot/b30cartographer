R STDMETHODCALLTYPE IAALoader_GetFirstStyleName_Proxy( 
    IAALoader __RPC_FAR * This);


void __RPC_STUB IAALoader_GetFirstStyleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetNextPersonalityInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);


void __RPC_STUB IAALoader_GetNextPersonalityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetNextPersonalityName_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszPrevPersonalityName);


void __RPC_STUB IAALoader_GetNextPersonalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetNextStyleInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);


void __RPC_STUB IAALoader_GetNextStyleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetNextStyleName_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszPrevStyleName);


void __RPC_STUB IAALoader_GetNextStyleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_LoadPersonality_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ IAAEngine __RPC_FAR *pEngine,
    /* [in] */ LPGUID pguid,
    /* [in] */ LPCTSTR pszFileName,
    /* [in] */ LPCTSTR pszPersonalityName,
    /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);


void __RPC_STUB IAALoader_LoadPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_LoadStyle_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ IAAEngine __RPC_FAR *pEngine,
    /* [in] */ LPGUID pguid,
    /* [in] */ LPCTSTR pszFileName,
    /* [in] */ LPCTSTR pszStyleName,
    /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);


void __RPC_STUB IAALoader_LoadStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_SetSearchDirectory_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [in] */ LPCTSTR pszDirectoryName,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAALoader_SetSearchDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAALoader_INTERFACE_DEFINED__ */


#ifndef __IAAMIDISink_INTERFACE_DEFINED__
#define __IAAMIDISink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDISink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDISink,0xBCE4CC44,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDISink : public IUnknown
    {
    public:
        virtual IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE GetMIDISink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockInstrument( 
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
            /* [in] */ VARIANT_BOOL fWait,
            /* [retval][out] */ HANDLE __RPC_FAR *phInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayMIDIEvent( 
            /* [in] */ DWORD dwMIDIEvent,
            /* [in] */ DWORD dwTimeInMils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySysExEvent( 
            /* [in] */ DWORD dwSysExLength,
            /* [in] */ BYTE __RPC_FAR *pSysExData,
            /* [in] */ DWORD dwTimeInMils) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInstrument( 
            /* [in] */ HANDLE hInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMIDISink( 
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockInstrument( 
            /* [in] */ HANDLE hInstrument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDISinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDISink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDISink __RPC_FAR * This);
        
        IAAMIDISink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetMIDISink )( 
            IAAMIDISink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
            /* [in] */ VARIANT_BOOL fWait,
            /* [retval][out] */ HANDLE __RPC_FAR *phInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlayMIDIEvent )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ DWORD dwMIDIEvent,
            /* [in] */ DWORD dwTimeInMils);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySysExEvent )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ DWORD dwSysExLength,
            /* [in] */ BYTE __RPC_FAR *pSysExData,
            /* [in] */ DWORD dwTimeInMils);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ HANDLE hInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMIDISink )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockInstrument )( 
            IAAMIDISink __RPC_FAR * This,
            /* [in] */ HANDLE hInstrument);
        
        END_INTERFACE
    } IAAMIDISinkVtbl;

    interface IAAMIDISink
    {
        CONST_VTBL struct IAAMIDISinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDISink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDISink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDISink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDISink_GetMIDISink(This)	\
    (This)->lpVtbl -> GetMIDISink(This)

#define IAAMIDISink_LockInstrument(This,pInstrument,fWait,phInstrument)	\
    (This)->lpVtbl -> LockInstrument(This,pInstrument,fWait,phInstrument)

#define IAAMIDISink_PlayMIDIEvent(This,dwMIDIEvent,dwTimeInMils)	\
    (This)->lpVtbl -> PlayMIDIEvent(This,dwMIDIEvent,dwTimeInMils)

#define IAAMIDISink_PlaySysExEvent(This,dwSysExLength,pSysExData,dwTimeInMils)	\
    (This)->lpVtbl -> PlaySysExEvent(This,dwSysExLength,pSysExData,dwTimeInMils)

#define IAAMIDISink_QueryInstrument(This,hInstrument)	\
    (This)->lpVtbl -> QueryInstrument(This,hInstrument)

#define IAAMIDISink_SetMIDISink(This,pMIDISink)	\
    (This)->lpVtbl -> SetMIDISink(This,pMIDISink)

#define IAAMIDISink_UnlockInstrument(This,hInstrument)	\
    (This)->lpVtbl -> UnlockInstrument(This,hInstrument)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE IAAMIDISink_GetMIDISink_Proxy( 
    IAAMIDISink __RPC_FAR * This);


void __RPC_STUB IAAMIDISink_GetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_LockInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument,
    /* [in] */ VARIANT_BOOL fWait,
    /* [retval][out] */ HANDLE __RPC_FAR *phInstrument);


void __RPC_STUB IAAMIDISink_LockInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_PlayMIDIEvent_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ DWORD dwMIDIEvent,
    /* [in] */ DWORD dwTimeInMils);


void __RPC_STUB IAAMIDISink_PlayMIDIEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_PlaySysExEvent_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ DWORD dwSysExLength,
    /* [in] */ BYTE __RPC_FAR *pSysExData,
    /* [in] */ DWORD dwTimeInMils);


void __RPC_STUB IAAMIDISink_PlaySysExEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_QueryInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ HANDLE hInstrument);


void __RPC_STUB IAAMIDISink_QueryInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_SetMIDISink_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);


void __RPC_STUB IAAMIDISink_SetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDISink_UnlockInstrument_Proxy( 
    IAAMIDISink __RPC_FAR * This,
    /* [in] */ HANDLE hInstrument);


void __RPC_STUB IAAMIDISink_UnlockInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDISink_INTERFACE_DEFINED__ */


#ifndef __IAAMotif_INTERFACE_DEFINED__
#define __IAAMotif_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMotif
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMotif,0xBCE4CC4b,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMotif : public IUnknown
    {
    public:
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetBand( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMotifVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMotif __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMotif __RPC_FAR * This);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAMotif __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetBand )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAMotif __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAAMotif __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAMotif __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAAMotif __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBand )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAAMotif __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAAMotifVtbl;

    interface IAAMotif
    {
        CONST_VTBL struct IAAMotifVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMotif_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMotif_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMotif_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMotif_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAMotif_GetBand(This)	\
    (This)->lpVtbl -> GetBand(This)

#define IAAMotif_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAMotif_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAMotif_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAAMotif_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAMotif_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAAMotif_Play(This,flags,dwTime)	\
    (This)->lpVtbl -> Play(This,flags,dwTime)

#define IAAMotif_SetBand(This,pBand)	\
    (This)->lpVtbl -> SetBand(This,pBand)

#define IAAMotif_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAAMotif_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAMotif_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAMotif_Clone_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAMotif_GetBand_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetBeatsPerMeasure_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetClicksPerBeat_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAMotif_GetLength_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAMotif_GetName_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAMotif_IsPlaying_Proxy( 
    IAAMotif __RPC_FAR * This);


void __RPC_STUB IAAMotif_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_Play_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAAMotif_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetBand_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAMotif_SetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetLength_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAAMotif_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_SetName_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAMotif_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMotif_Stop_Proxy( 
    IAAMotif __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAMotif_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMotif_INTERFACE_DEFINED__ */


#ifndef __IAANotifySink_INTERFACE_DEFINED__
#define __IAANotifySink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAANotifySink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAANotifySink,0xBCE4CC45,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAANotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEmbellishment( 
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGroove( 
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMetronome( 
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMotifEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMotifStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMusicStopped( 
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNextSection( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionChanged( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSectionStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSongEnded( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSongStarted( 
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUserEvent( 
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAANotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAANotifySink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAANotifySink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEmbellishment )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnGroove )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMetronome )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMusicStopped )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNextSection )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionChanged )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongEnded )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongStarted )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUserEvent )( 
            IAANotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        END_INTERFACE
    } IAANotifySinkVtbl;

    interface IAANotifySink
    {
        CONST_VTBL struct IAANotifySinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAANotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAANotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAANotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAANotifySink_OnEmbellishment(This,dwTime,lEmbellishment,fFlags)	\
    (This)->lpVtbl -> OnEmbellishment(This,dwTime,lEmbellishment,fFlags)

#define IAANotifySink_OnGroove(This,dwTime,lGroove,fFlags)	\
    (This)->lpVtbl -> OnGroove(This,dwTime,lGroove,fFlags)

#define IAANotifySink_OnMetronome(This,dwTime,wMeasure,wBeat)	\
    (This)->lpVtbl -> OnMetronome(This,dwTime,wMeasure,wBeat)

#define IAANotifySink_OnMotifEnded(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifEnded(This,dwTime,pMotif,fFlags)

#define IAANotifySink_OnMotifStarted(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifStarted(This,dwTime,pMotif,fFlags)

#define IAANotifySink_OnMusicStopped(This,dwTime)	\
    (This)->lpVtbl -> OnMusicStopped(This,dwTime)

#define IAANotifySink_OnNextSection(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnNextSection(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)

#define IAANotifySink_OnSectionChanged(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionChanged(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSectionStarted(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionStarted(This,dwTime,pSection,fFlags)

#define IAANotifySink_OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)

#define IAANotifySink_OnSongStarted(This,dwTime,pSong,fFlags)	\
    (This)->lpVtbl -> OnSongStarted(This,dwTime,pSong,fFlags)

#define IAANotifySink_OnUserEvent(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> OnUserEvent(This,dwTime,dwParam1,dwParam2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAANotifySink_OnEmbellishment_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ AACommands lEmbellishment,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnEmbellishment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnGroove_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ AACommands lGroove,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnGroove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMetronome_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ WORD wMeasure,
    /* [in] */ WORD wBeat);


void __RPC_STUB IAANotifySink_OnMetronome_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMotifEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnMotifEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMotifStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnMotifStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnMusicStopped_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAANotifySink_OnMusicStopped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnNextSection_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnNextSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags,
    /* [in] */ DWORD dwEndTime);


void __RPC_STUB IAANotifySink_OnSectionEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionChanged_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSectionChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSectionStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSectionStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSongEnded_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags fFlags,
    /* [in] */ DWORD dwEndTime);


void __RPC_STUB IAANotifySink_OnSongEnded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnSongStarted_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAANotifySink_OnSongStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAANotifySink_OnUserEvent_Proxy( 
    IAANotifySink __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IAANotifySink_OnUserEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAANotifySink_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIExportNotifySink_INTERFACE_DEFINED__
#define __IAAMIDIExportNotifySink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIExportNotifySink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIExportNotifySink,0xBCE4CC5f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIExportNotifySink : public IAANotifySink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnExport( 
            /* [in] */ WORD wPercentComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIExportNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIExportNotifySink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIExportNotifySink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEmbellishment )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lEmbellishment,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnGroove )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ AACommands lGroove,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMetronome )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ WORD wMeasure,
            /* [in] */ WORD wBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMotifStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnMusicStopped )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnNextSection )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionChanged )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSectionStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongEnded )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags,
            /* [in] */ DWORD dwEndTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSongStarted )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnUserEvent )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnExport )( 
            IAAMIDIExportNotifySink __RPC_FAR * This,
            /* [in] */ WORD wPercentComplete);
        
        END_INTERFACE
    } IAAMIDIExportNotifySinkVtbl;

    interface IAAMIDIExportNotifySink
    {
        CONST_VTBL struct IAAMIDIExportNotifySinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIExportNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIExportNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIExportNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIExportNotifySink_OnEmbellishment(This,dwTime,lEmbellishment,fFlags)	\
    (This)->lpVtbl -> OnEmbellishment(This,dwTime,lEmbellishment,fFlags)

#define IAAMIDIExportNotifySink_OnGroove(This,dwTime,lGroove,fFlags)	\
    (This)->lpVtbl -> OnGroove(This,dwTime,lGroove,fFlags)

#define IAAMIDIExportNotifySink_OnMetronome(This,dwTime,wMeasure,wBeat)	\
    (This)->lpVtbl -> OnMetronome(This,dwTime,wMeasure,wBeat)

#define IAAMIDIExportNotifySink_OnMotifEnded(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifEnded(This,dwTime,pMotif,fFlags)

#define IAAMIDIExportNotifySink_OnMotifStarted(This,dwTime,pMotif,fFlags)	\
    (This)->lpVtbl -> OnMotifStarted(This,dwTime,pMotif,fFlags)

#define IAAMIDIExportNotifySink_OnMusicStopped(This,dwTime)	\
    (This)->lpVtbl -> OnMusicStopped(This,dwTime)

#define IAAMIDIExportNotifySink_OnNextSection(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnNextSection(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSectionEnded(This,dwTime,pSection,fFlags,dwEndTime)

#define IAAMIDIExportNotifySink_OnSectionChanged(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionChanged(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSectionStarted(This,dwTime,pSection,fFlags)	\
    (This)->lpVtbl -> OnSectionStarted(This,dwTime,pSection,fFlags)

#define IAAMIDIExportNotifySink_OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)	\
    (This)->lpVtbl -> OnSongEnded(This,dwTime,pSong,fFlags,dwEndTime)

#define IAAMIDIExportNotifySink_OnSongStarted(This,dwTime,pSong,fFlags)	\
    (This)->lpVtbl -> OnSongStarted(This,dwTime,pSong,fFlags)

#define IAAMIDIExportNotifySink_OnUserEvent(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> OnUserEvent(This,dwTime,dwParam1,dwParam2)


#define IAAMIDIExportNotifySink_OnExport(This,wPercentComplete)	\
    (This)->lpVtbl -> OnExport(This,wPercentComplete)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIExportNotifySink_OnExport_Proxy( 
    IAAMIDIExportNotifySink __RPC_FAR * This,
    /* [in] */ WORD wPercentComplete);


void __RPC_STUB IAAMIDIExportNotifySink_OnExport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIExportNotifySink_INTERFACE_DEFINED__ */


#ifndef __IAAPattern_INTERFACE_DEFINED__
#define __IAAPattern_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAPattern
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAPattern,0xBCE4CC50,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAPattern : public IUnknown
    {
    public:
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAPattern __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAPattern __RPC_FAR * This);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAPattern __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAAPattern __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAPattern __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAPattern __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        END_INTERFACE
    } IAAPatternVtbl;

    interface IAAPattern
    {
        CONST_VTBL struct IAAPatternVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAPattern_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAPattern_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAPattern_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAPattern_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAPattern_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAPattern_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAPattern_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAAPattern_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAPattern_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAAPattern_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAPattern_Clone_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetBeatsPerMeasure_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetClicksPerBeat_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAPattern_GetLength_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAPattern_GetName_Proxy( 
    IAAPattern __RPC_FAR * This);


void __RPC_STUB IAAPattern_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPattern_SetLength_Proxy( 
    IAAPattern __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAAPattern_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPattern_SetName_Proxy( 
    IAAPattern __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAPattern_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAPattern_INTERFACE_DEFINED__ */


#ifndef __IAAPersonality_INTERFACE_DEFINED__
#define __IAAPersonality_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAPersonality
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAPersonality,0xBCE4CC4d,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAPersonality : public IUnknown
    {
    public:
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetScale( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScale( 
            /* [in] */ DWORD dwScale) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAPersonalityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAPersonality __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAPersonality __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAPersonality __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetScale )( 
            IAAPersonality __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAPersonality __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScale )( 
            IAAPersonality __RPC_FAR * This,
            /* [in] */ DWORD dwScale);
        
        END_INTERFACE
    } IAAPersonalityVtbl;

    interface IAAPersonality
    {
        CONST_VTBL struct IAAPersonalityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAPersonality_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAPersonality_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAPersonality_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAPersonality_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAPersonality_GetScale(This)	\
    (This)->lpVtbl -> GetScale(This)

#define IAAPersonality_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAPersonality_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAPersonality_SetScale(This,dwScale)	\
    (This)->lpVtbl -> SetScale(This,dwScale)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAPersonality_Clone_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAPersonality_GetScale_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_GetScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAPersonality_GetName_Proxy( 
    IAAPersonality __RPC_FAR * This);


void __RPC_STUB IAAPersonality_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPersonality_SetName_Proxy( 
    IAAPersonality __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAPersonality_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAPersonality_SetScale_Proxy( 
    IAAPersonality __RPC_FAR * This,
    /* [in] */ DWORD dwScale);


void __RPC_STUB IAAPersonality_SetScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAPersonality_INTERFACE_DEFINED__ */


#ifndef __IAARealTime_INTERFACE_DEFINED__
#define __IAARealTime_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAARealTime
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAARealTime,0xBCE4CC42,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAARealTime : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FlushEventsAfterTime( 
            /* [in] */ DWORD dwTime) = 0;
        
        virtual IReferenceClock __RPC_FAR *STDMETHODCALLTYPE GetClock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMeters( 
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetMusicTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetMutes( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPPQN( void) = 0;
        
        virtual IReferenceClock __RPC_FAR *STDMETHODCALLTYPE GetPremixClock( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetPremixTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelVolume( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE GetSendOutputEarly( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetTimerRes( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetMusicTime( 
            /* [in] */ DWORD dwMusicTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClock( 
            /* [in] */ IReferenceClock __RPC_FAR *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMutes( 
            /* [in] */ WORD wMutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPremixClock( 
            /* [in] */ IReferenceClock __RPC_FAR *pClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelTempo( 
            /* [in] */ WORD wRelTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelVolume( 
            /* [in] */ WORD wRelVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSendOutputEarly( 
            /* [in] */ VARIANT_BOOL fEarly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTempo( 
            /* [in] */ DWORD dwTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimerRes( 
            /* [in] */ WORD wTimerRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAARealTimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAARealTime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushEventsAfterTime )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwTime);
        
        IReferenceClock __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetClock )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMeters )( 
            IAARealTime __RPC_FAR * This,
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetMusicTime )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetMutes )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPPQN )( 
            IAARealTime __RPC_FAR * This);
        
        IReferenceClock __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetPremixClock )( 
            IAARealTime __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetPremixTime )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelTempo )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelVolume )( 
            IAARealTime __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *GetSendOutputEarly )( 
            IAARealTime __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAARealTime __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimerRes )( 
            IAARealTime __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetMusicTime )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwMusicTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClock )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ IReferenceClock __RPC_FAR *pClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMutes )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wMutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPremixClock )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ IReferenceClock __RPC_FAR *pClock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelTempo )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wRelTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelVolume )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wRelVolume);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSendOutputEarly )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEarly);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTempo )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ DWORD dwTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimerRes )( 
            IAARealTime __RPC_FAR * This,
            /* [in] */ WORD wTimerRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IAARealTime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAARealTime __RPC_FAR * This);
        
        END_INTERFACE
    } IAARealTimeVtbl;

    interface IAARealTime
    {
        CONST_VTBL struct IAARealTimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAARealTime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAARealTime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAARealTime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAARealTime_FlushEventsAfterTime(This,dwTime)	\
    (This)->lpVtbl -> FlushEventsAfterTime(This,dwTime)

#define IAARealTime_GetClock(This)	\
    (This)->lpVtbl -> GetClock(This)

#define IAARealTime_GetMeters(This,pMeters)	\
    (This)->lpVtbl -> GetMeters(This,pMeters)

#define IAARealTime_GetMusicTime(This)	\
    (This)->lpVtbl -> GetMusicTime(This)

#define IAARealTime_GetMutes(This)	\
    (This)->lpVtbl -> GetMutes(This)

#define IAARealTime_GetPPQN(This)	\
    (This)->lpVtbl -> GetPPQN(This)

#define IAARealTime_GetPremixClock(This)	\
    (This)->lpVtbl -> GetPremixClock(This)

#define IAARealTime_GetPremixTime(This)	\
    (This)->lpVtbl -> GetPremixTime(This)

#define IAARealTime_GetRelTempo(This)	\
    (This)->lpVtbl -> GetRelTempo(This)

#define IAARealTime_GetRelVolume(This)	\
    (This)->lpVtbl -> GetRelVolume(This)

#define IAARealTime_GetSendOutputEarly(This)	\
    (This)->lpVtbl -> GetSendOutputEarly(This)

#define IAARealTime_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAARealTime_GetTimerRes(This)	\
    (This)->lpVtbl -> GetTimerRes(This)

#define IAARealTime_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAARealTime_ResetMusicTime(This,dwMusicTime)	\
    (This)->lpVtbl -> ResetMusicTime(This,dwMusicTime)

#define IAARealTime_SetClock(This,pClock)	\
    (This)->lpVtbl -> SetClock(This,pClock)

#define IAARealTime_SetMutes(This,wMutes)	\
    (This)->lpVtbl -> SetMutes(This,wMutes)

#define IAARealTime_SetPremixClock(This,pClock)	\
    (This)->lpVtbl -> SetPremixClock(This,pClock)

#define IAARealTime_SetRelTempo(This,wRelTempo)	\
    (This)->lpVtbl -> SetRelTempo(This,wRelTempo)

#define IAARealTime_SetRelVolume(This,wRelVolume)	\
    (This)->lpVtbl -> SetRelVolume(This,wRelVolume)

#define IAARealTime_SetSendOutputEarly(This,fEarly)	\
    (This)->lpVtbl -> SetSendOutputEarly(This,fEarly)

#define IAARealTime_SetTempo(This,dwTempo)	\
    (This)->lpVtbl -> SetTempo(This,dwTempo)

#define IAARealTime_SetTimerRes(This,wTimerRes)	\
    (This)->lpVtbl -> SetTimerRes(This,wTimerRes)

#define IAARealTime_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IAARealTime_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAARealTime_FlushEventsAfterTime_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAARealTime_FlushEventsAfterTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IReferenceClock __RPC_FAR *STDMETHODCALLTYPE IAARealTime_GetClock_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_GetMeters_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [out][in] */ AAMETERS __RPC_FAR *pMeters);


void __RPC_STUB IAARealTime_GetMeters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetMusicTime_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetMutes_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetPPQN_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPPQN_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IReferenceClock __RPC_FAR *STDMETHODCALLTYPE IAARealTime_GetPremixClock_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPremixClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetPremixTime_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetPremixTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetRelTempo_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetRelVolume_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAARealTime_GetSendOutputEarly_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetSendOutputEarly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAARealTime_GetTempo_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAARealTime_GetTimerRes_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_GetTimerRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAARealTime_IsPlaying_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_ResetMusicTime_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwMusicTime);


void __RPC_STUB IAARealTime_ResetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetClock_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ IReferenceClock __RPC_FAR *pClock);


void __RPC_STUB IAARealTime_SetClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetMutes_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wMutes);


void __RPC_STUB IAARealTime_SetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetPremixClock_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ IReferenceClock __RPC_FAR *pClock);


void __RPC_STUB IAARealTime_SetPremixClock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetRelTempo_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wRelTempo);


void __RPC_STUB IAARealTime_SetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetRelVolume_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wRelVolume);


void __RPC_STUB IAARealTime_SetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetSendOutputEarly_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEarly);


void __RPC_STUB IAARealTime_SetSendOutputEarly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetTempo_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ DWORD dwTempo);


void __RPC_STUB IAARealTime_SetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_SetTimerRes_Proxy( 
    IAARealTime __RPC_FAR * This,
    /* [in] */ WORD wTimerRes);


void __RPC_STUB IAARealTime_SetTimerRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_Start_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAARealTime_Stop_Proxy( 
    IAARealTime __RPC_FAR * This);


void __RPC_STUB IAARealTime_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAARealTime_INTERFACE_DEFINED__ */


#ifndef __IAASection_INTERFACE_DEFINED__
#define __IAASection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASection
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASection,0xBCE4CC49,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASection : public IUnknown
    {
    public:
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetBand( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetCurrentMeasure( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetKey( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetLengthInMils( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetPersonality( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRepeats( void) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE GetStyle( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetUserData( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBand( 
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromQueue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAsMIDI( 
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ WORD nKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD wLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRepeats( 
            /* [in] */ WORD wRepeats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStyle( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTempo( 
            /* [in] */ DWORD lTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserData( 
            /* [in] */ DWORD lUserData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBand( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASection __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAASection __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetBand )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentMeasure )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetLengthInMils )( 
            IAASection __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAASection __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetPersonality )( 
            IAASection __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRepeats )( 
            IAASection __RPC_FAR * This);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetStyle )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAASection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetUserData )( 
            IAASection __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBand )( 
            IAASection __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAASection __RPC_FAR * This,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveFromQueue )( 
            IAASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAsMIDI )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBand )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD nKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD wLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAASection __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPersonality )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRepeats )( 
            IAASection __RPC_FAR * This,
            /* [in] */ WORD wRepeats);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )( 
            IAASection __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTempo )( 
            IAASection __RPC_FAR * This,
            /* [in] */ DWORD lTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserData )( 
            IAASection __RPC_FAR * This,
            /* [in] */ DWORD lUserData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAASection __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBand )( 
            IAASection __RPC_FAR * This);
        
        END_INTERFACE
    } IAASectionVtbl;

    interface IAASection
    {
        CONST_VTBL struct IAASectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASection_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAASection_GetBand(This)	\
    (This)->lpVtbl -> GetBand(This)

#define IAASection_GetCurrentMeasure(This)	\
    (This)->lpVtbl -> GetCurrentMeasure(This)

#define IAASection_GetKey(This)	\
    (This)->lpVtbl -> GetKey(This)

#define IAASection_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAASection_GetLengthInMils(This)	\
    (This)->lpVtbl -> GetLengthInMils(This)

#define IAASection_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAASection_GetPersonality(This)	\
    (This)->lpVtbl -> GetPersonality(This)

#define IAASection_GetRepeats(This)	\
    (This)->lpVtbl -> GetRepeats(This)

#define IAASection_GetStyle(This)	\
    (This)->lpVtbl -> GetStyle(This)

#define IAASection_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAASection_GetUserData(This)	\
    (This)->lpVtbl -> GetUserData(This)

#define IAASection_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAASection_LockBand(This,fWait)	\
    (This)->lpVtbl -> LockBand(This,fWait)

#define IAASection_Play(This,flags,dwStartTime)	\
    (This)->lpVtbl -> Play(This,flags,dwStartTime)

#define IAASection_RemoveFromQueue(This)	\
    (This)->lpVtbl -> RemoveFromQueue(This)

#define IAASection_SaveAsMIDI(This,pStream)	\
    (This)->lpVtbl -> SaveAsMIDI(This,pStream)

#define IAASection_SetBand(This,pBand)	\
    (This)->lpVtbl -> SetBand(This,pBand)

#define IAASection_SetKey(This,nKey)	\
    (This)->lpVtbl -> SetKey(This,nKey)

#define IAASection_SetLength(This,wLength)	\
    (This)->lpVtbl -> SetLength(This,wLength)

#define IAASection_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAASection_SetPersonality(This,pPersonality)	\
    (This)->lpVtbl -> SetPersonality(This,pPersonality)

#define IAASection_SetRepeats(This,wRepeats)	\
    (This)->lpVtbl -> SetRepeats(This,wRepeats)

#define IAASection_SetStyle(This,pStyle)	\
    (This)->lpVtbl -> SetStyle(This,pStyle)

#define IAASection_SetTempo(This,lTempo)	\
    (This)->lpVtbl -> SetTempo(This,lTempo)

#define IAASection_SetUserData(This,lUserData)	\
    (This)->lpVtbl -> SetUserData(This,lUserData)

#define IAASection_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#define IAASection_UnlockBand(This)	\
    (This)->lpVtbl -> UnlockBand(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAASection __RPC_FAR *STDMETHODCALLTYPE IAASection_Clone_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAASection_GetBand_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetCurrentMeasure_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetCurrentMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetKey_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetLength_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetLengthInMils_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetLengthInMils_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASection_GetName_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAASection_GetPersonality_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASection_GetRepeats_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetRepeats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAASection_GetStyle_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetTempo_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASection_GetUserData_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAASection_IsPlaying_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_LockBand_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAASection_LockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_Play_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAASection_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_RemoveFromQueue_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_RemoveFromQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SaveAsMIDI_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAASection_SaveAsMIDI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetBand_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAASection_SetBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetKey_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD nKey);


void __RPC_STUB IAASection_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetLength_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD wLength);


void __RPC_STUB IAASection_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetName_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAASection_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetPersonality_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAASection_SetPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetRepeats_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ WORD wRepeats);


void __RPC_STUB IAASection_SetRepeats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetStyle_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle);


void __RPC_STUB IAASection_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetTempo_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ DWORD lTempo);


void __RPC_STUB IAASection_SetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_SetUserData_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ DWORD lUserData);


void __RPC_STUB IAASection_SetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_Stop_Proxy( 
    IAASection __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASection_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection_UnlockBand_Proxy( 
    IAASection __RPC_FAR * This);


void __RPC_STUB IAASection_UnlockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASection_INTERFACE_DEFINED__ */


#ifndef __IAASection2_INTERFACE_DEFINED__
#define __IAASection2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASection2
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASection2,0xBCE4CC60,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASection2 : public IUnknown
    {
    public:
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE ClonePart( 
            /* [in] */ WORD wStartMeasure,
            /* [in] */ WORD wEndMeasure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFailedLoadInfo( 
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASection2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASection2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASection2 __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *ClonePart )( 
            IAASection2 __RPC_FAR * This,
            /* [in] */ WORD wStartMeasure,
            /* [in] */ WORD wEndMeasure);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFailedLoadInfo )( 
            IAASection2 __RPC_FAR * This,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
            /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName);
        
        END_INTERFACE
    } IAASection2Vtbl;

    interface IAASection2
    {
        CONST_VTBL struct IAASection2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASection2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASection2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASection2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASection2_ClonePart(This,wStartMeasure,wEndMeasure)	\
    (This)->lpVtbl -> ClonePart(This,wStartMeasure,wEndMeasure)

#define IAASection2_GetFailedLoadInfo(This,pfDidStyleLoad,ppszStyleName,pfDidPersonalityLoad,ppszPersonalityName)	\
    (This)->lpVtbl -> GetFailedLoadInfo(This,pfDidStyleLoad,ppszStyleName,pfDidPersonalityLoad,ppszPersonalityName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAASection __RPC_FAR *STDMETHODCALLTYPE IAASection2_ClonePart_Proxy( 
    IAASection2 __RPC_FAR * This,
    /* [in] */ WORD wStartMeasure,
    /* [in] */ WORD wEndMeasure);


void __RPC_STUB IAASection2_ClonePart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASection2_GetFailedLoadInfo_Proxy( 
    IAASection2 __RPC_FAR * This,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidStyleLoad,
    /* [out] */ LPCSTR __RPC_FAR *ppszStyleName,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pfDidPersonalityLoad,
    /* [out] */ LPCSTR __RPC_FAR *ppszPersonalityName);


void __RPC_STUB IAASection2_GetFailedLoadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASection2_INTERFACE_DEFINED__ */


#ifndef __IAASong_INTERFACE_DEFINED__
#define __IAASong_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAASong
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAASong,0xBCE4CC4a,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAASong : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppendSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual IAASong __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetAuthor( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetFirstSection( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetLengthInMils( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetNextSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSection( 
            /* [in] */ IAASection __RPC_FAR *pPrevSection,
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSection( 
            /* [in] */ IAASection __RPC_FAR *pSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAsMIDI( 
            /* [in] */ IStream __RPC_FAR *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthor( 
            /* [in] */ LPCTSTR pszAuthor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAASongVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAASong __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAASong __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAASong __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        IAASong __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAASong __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetAuthor )( 
            IAASong __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstSection )( 
            IAASong __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAASong __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetLengthInMils )( 
            IAASong __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAASong __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pPrevSection,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAASong __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IAASong __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseSection )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAsMIDI )( 
            IAASong __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuthor )( 
            IAASong __RPC_FAR * This,
            /* [in] */ LPCTSTR pszAuthor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAASong __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAASong __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAASongVtbl;

    interface IAASong
    {
        CONST_VTBL struct IAASongVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAASong_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAASong_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAASong_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAASong_AppendSection(This,pSection)	\
    (This)->lpVtbl -> AppendSection(This,pSection)

#define IAASong_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAASong_GetAuthor(This)	\
    (This)->lpVtbl -> GetAuthor(This)

#define IAASong_GetFirstSection(This)	\
    (This)->lpVtbl -> GetFirstSection(This)

#define IAASong_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAASong_GetLengthInMils(This)	\
    (This)->lpVtbl -> GetLengthInMils(This)

#define IAASong_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAASong_GetNextSection(This,pSection)	\
    (This)->lpVtbl -> GetNextSection(This,pSection)

#define IAASong_InsertSection(This,pPrevSection,pSection)	\
    (This)->lpVtbl -> InsertSection(This,pPrevSection,pSection)

#define IAASong_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAASong_Play(This,flags)	\
    (This)->lpVtbl -> Play(This,flags)

#define IAASong_ReleaseSection(This,pSection)	\
    (This)->lpVtbl -> ReleaseSection(This,pSection)

#define IAASong_SaveAsMIDI(This,pStream)	\
    (This)->lpVtbl -> SaveAsMIDI(This,pStream)

#define IAASong_SetAuthor(This,pszAuthor)	\
    (This)->lpVtbl -> SetAuthor(This,pszAuthor)

#define IAASong_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAASong_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAASong_AppendSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_AppendSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASong __RPC_FAR *STDMETHODCALLTYPE IAASong_Clone_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASong_GetAuthor_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetAuthor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAASong_GetFirstSection_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetFirstSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAASong_GetLength_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAASong_GetLengthInMils_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetLengthInMils_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAASong_GetName_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAASong_GetNextSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_GetNextSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_InsertSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pPrevSection,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_InsertSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAASong_IsPlaying_Proxy( 
    IAASong __RPC_FAR * This);


void __RPC_STUB IAASong_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_Play_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASong_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_ReleaseSection_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection);


void __RPC_STUB IAASong_ReleaseSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SaveAsMIDI_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream);


void __RPC_STUB IAASong_SaveAsMIDI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SetAuthor_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ LPCTSTR pszAuthor);


void __RPC_STUB IAASong_SetAuthor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_SetName_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAASong_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAASong_Stop_Proxy( 
    IAASong __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAASong_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAASong_INTERFACE_DEFINED__ */


#ifndef __IAAStyle_INTERFACE_DEFINED__
#define __IAAStyle_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAStyle
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAStyle,0xBCE4CC4c,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAStyle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE FindBand( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE FindMotif( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE FindPattern( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonality( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetBeatsPerMeasure( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetCategory( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetClicksPerBeat( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetDefaultBand( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetDefaultPersonality( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetDefaultTempo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbellishmentLength( 
            /* [in] */ AACommands lEmbellishment,
            /* [out] */ WORD __RPC_FAR *pwNumMeasures,
            /* [out] */ DWORD __RPC_FAR *pdwActualLength) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetFirstBand( void) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE GetFirstMotif( void) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE GetFirstPattern( void) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetFirstPersonality( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE GetNextBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual IAAMotif __RPC_FAR *STDMETHODCALLTYPE GetNextMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual IAAPattern __RPC_FAR *STDMETHODCALLTYPE GetNextPattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE GetNextPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTimeSignature( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBand( 
            /* [in] */ IAABand __RPC_FAR *pBand,
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockBandByName( 
            /* [in] */ LPCTSTR pszBandName,
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePattern( 
            /* [in] */ IAAPattern __RPC_FAR *pPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBeatsPerMeasure( 
            /* [in] */ WORD wBeatsPerMeasure) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [in] */ LPCTSTR pszCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClicksPerBeat( 
            /* [in] */ WORD wClicksPerBeat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultPersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTempo( 
            /* [in] */ DWORD lTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeSignature( 
            /* [in] */ DWORD lTimeSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBand( 
            /* [in] */ IAABand __RPC_FAR *pBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockBandByName( 
            /* [in] */ LPCTSTR pszBandName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAStyleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAStyle __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetBeatsPerMeasure )( 
            IAAStyle __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetCategory )( 
            IAAStyle __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetClicksPerBeat )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetDefaultBand )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetDefaultPersonality )( 
            IAAStyle __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTempo )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbellishmentLength )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ AACommands lEmbellishment,
            /* [out] */ WORD __RPC_FAR *pwNumMeasures,
            /* [out] */ DWORD __RPC_FAR *pdwActualLength);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstBand )( 
            IAAStyle __RPC_FAR * This);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstMotif )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstPattern )( 
            IAAStyle __RPC_FAR * This);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonality )( 
            IAAStyle __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAAStyle __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        IAAMotif __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        IAAPattern __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextPattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimeSignature )( 
            IAAStyle __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockBandByName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszBandName,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseMotif )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePattern )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPattern __RPC_FAR *pPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBeatsPerMeasure )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ WORD wBeatsPerMeasure);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCategory )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszCategory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClicksPerBeat )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ WORD wClicksPerBeat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultPersonality )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTempo )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ DWORD lTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimeSignature )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ DWORD lTimeSig);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBand )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ IAABand __RPC_FAR *pBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockBandByName )( 
            IAAStyle __RPC_FAR * This,
            /* [in] */ LPCTSTR pszBandName);
        
        END_INTERFACE
    } IAAStyleVtbl;

    interface IAAStyle
    {
        CONST_VTBL struct IAAStyleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAStyle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAStyle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAStyle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAStyle_AddBand(This,pBand)	\
    (This)->lpVtbl -> AddBand(This,pBand)

#define IAAStyle_AddMotif(This,pMotif)	\
    (This)->lpVtbl -> AddMotif(This,pMotif)

#define IAAStyle_AddPattern(This,pPattern)	\
    (This)->lpVtbl -> AddPattern(This,pPattern)

#define IAAStyle_AddPersonality(This,pPersonality)	\
    (This)->lpVtbl -> AddPersonality(This,pPersonality)

#define IAAStyle_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAAStyle_FindBand(This,pszName)	\
    (This)->lpVtbl -> FindBand(This,pszName)

#define IAAStyle_FindMotif(This,pszName)	\
    (This)->lpVtbl -> FindMotif(This,pszName)

#define IAAStyle_FindPattern(This,pszName)	\
    (This)->lpVtbl -> FindPattern(This,pszName)

#define IAAStyle_FindPersonality(This,pszName)	\
    (This)->lpVtbl -> FindPersonality(This,pszName)

#define IAAStyle_GetBeatsPerMeasure(This)	\
    (This)->lpVtbl -> GetBeatsPerMeasure(This)

#define IAAStyle_GetCategory(This)	\
    (This)->lpVtbl -> GetCategory(This)

#define IAAStyle_GetClicksPerBeat(This)	\
    (This)->lpVtbl -> GetClicksPerBeat(This)

#define IAAStyle_GetDefaultBand(This)	\
    (This)->lpVtbl -> GetDefaultBand(This)

#define IAAStyle_GetDefaultPersonality(This)	\
    (This)->lpVtbl -> GetDefaultPersonality(This)

#define IAAStyle_GetDefaultTempo(This)	\
    (This)->lpVtbl -> GetDefaultTempo(This)

#define IAAStyle_GetEmbellishmentLength(This,lEmbellishment,pwNumMeasures,pdwActualLength)	\
    (This)->lpVtbl -> GetEmbellishmentLength(This,lEmbellishment,pwNumMeasures,pdwActualLength)

#define IAAStyle_GetFirstBand(This)	\
    (This)->lpVtbl -> GetFirstBand(This)

#define IAAStyle_GetFirstMotif(This)	\
    (This)->lpVtbl -> GetFirstMotif(This)

#define IAAStyle_GetFirstPattern(This)	\
    (This)->lpVtbl -> GetFirstPattern(This)

#define IAAStyle_GetFirstPersonality(This)	\
    (This)->lpVtbl -> GetFirstPersonality(This)

#define IAAStyle_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAAStyle_GetNextBand(This,pBand)	\
    (This)->lpVtbl -> GetNextBand(This,pBand)

#define IAAStyle_GetNextMotif(This,pMotif)	\
    (This)->lpVtbl -> GetNextMotif(This,pMotif)

#define IAAStyle_GetNextPattern(This,pPattern)	\
    (This)->lpVtbl -> GetNextPattern(This,pPattern)

#define IAAStyle_GetNextPersonality(This,pPersonality)	\
    (This)->lpVtbl -> GetNextPersonality(This,pPersonality)

#define IAAStyle_GetTimeSignature(This)	\
    (This)->lpVtbl -> GetTimeSignature(This)

#define IAAStyle_LockBand(This,pBand,fWait)	\
    (This)->lpVtbl -> LockBand(This,pBand,fWait)

#define IAAStyle_LockBandByName(This,pszBandName,fWait)	\
    (This)->lpVtbl -> LockBandByName(This,pszBandName,fWait)

#define IAAStyle_ReleaseBand(This,pBand)	\
    (This)->lpVtbl -> ReleaseBand(This,pBand)

#define IAAStyle_ReleaseMotif(This,pMotif)	\
    (This)->lpVtbl -> ReleaseMotif(This,pMotif)

#define IAAStyle_ReleasePattern(This,pPattern)	\
    (This)->lpVtbl -> ReleasePattern(This,pPattern)

#define IAAStyle_ReleasePersonality(This,pPersonality)	\
    (This)->lpVtbl -> ReleasePersonality(This,pPersonality)

#define IAAStyle_SetBeatsPerMeasure(This,wBeatsPerMeasure)	\
    (This)->lpVtbl -> SetBeatsPerMeasure(This,wBeatsPerMeasure)

#define IAAStyle_SetCategory(This,pszCategory)	\
    (This)->lpVtbl -> SetCategory(This,pszCategory)

#define IAAStyle_SetClicksPerBeat(This,wClicksPerBeat)	\
    (This)->lpVtbl -> SetClicksPerBeat(This,wClicksPerBeat)

#define IAAStyle_SetDefaultBand(This,pBand)	\
    (This)->lpVtbl -> SetDefaultBand(This,pBand)

#define IAAStyle_SetDefaultPersonality(This,pPersonality)	\
    (This)->lpVtbl -> SetDefaultPersonality(This,pPersonality)

#define IAAStyle_SetDefaultTempo(This,lTempo)	\
    (This)->lpVtbl -> SetDefaultTempo(This,lTempo)

#define IAAStyle_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAAStyle_SetTimeSignature(This,lTimeSig)	\
    (This)->lpVtbl -> SetTimeSignature(This,lTimeSig)

#define IAAStyle_UnlockBand(This,pBand)	\
    (This)->lpVtbl -> UnlockBand(This,pBand)

#define IAAStyle_UnlockBandByName(This,pszBandName)	\
    (This)->lpVtbl -> UnlockBandByName(This,pszBandName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAStyle_AddBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_AddBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_AddMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_AddPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_AddPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_AddPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAStyle_Clone_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_FindPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_FindPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAStyle_GetBeatsPerMeasure_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAStyle_GetCategory_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAStyle_GetClicksPerBeat_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetDefaultBand_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetDefaultPersonality_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAStyle_GetDefaultTempo_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetDefaultTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_GetEmbellishmentLength_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ AACommands lEmbellishment,
    /* [out] */ WORD __RPC_FAR *pwNumMeasures,
    /* [out] */ DWORD __RPC_FAR *pdwActualLength);


void __RPC_STUB IAAStyle_GetEmbellishmentLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstBand_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstMotif_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstPattern_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetFirstPersonality_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetFirstPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAAStyle_GetName_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAABand __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_GetNextBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMotif __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_GetNextMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPattern __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextPattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_GetNextPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAStyle_GetNextPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_GetNextPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAStyle_GetTimeSignature_Proxy( 
    IAAStyle __RPC_FAR * This);


void __RPC_STUB IAAStyle_GetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_LockBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAAStyle_LockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_LockBandByName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszBandName,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAAStyle_LockBandByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleaseBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_ReleaseBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleaseMotif_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif);


void __RPC_STUB IAAStyle_ReleaseMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleasePattern_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPattern __RPC_FAR *pPattern);


void __RPC_STUB IAAStyle_ReleasePattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_ReleasePersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_ReleasePersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetBeatsPerMeasure_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ WORD wBeatsPerMeasure);


void __RPC_STUB IAAStyle_SetBeatsPerMeasure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetCategory_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszCategory);


void __RPC_STUB IAAStyle_SetCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetClicksPerBeat_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ WORD wClicksPerBeat);


void __RPC_STUB IAAStyle_SetClicksPerBeat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_SetDefaultBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultPersonality_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAStyle_SetDefaultPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetDefaultTempo_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ DWORD lTempo);


void __RPC_STUB IAAStyle_SetDefaultTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAStyle_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_SetTimeSignature_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ DWORD lTimeSig);


void __RPC_STUB IAAStyle_SetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_UnlockBand_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ IAABand __RPC_FAR *pBand);


void __RPC_STUB IAAStyle_UnlockBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAStyle_UnlockBandByName_Proxy( 
    IAAStyle __RPC_FAR * This,
    /* [in] */ LPCTSTR pszBandName);


void __RPC_STUB IAAStyle_UnlockBandByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAStyle_INTERFACE_DEFINED__ */


#ifndef __IAATemplate_INTERFACE_DEFINED__
#define __IAATemplate_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAATemplate
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAATemplate,0xBCE4CC4f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAATemplate : public IUnknown
    {
    public:
        virtual IAATemplate __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetLength( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ WORD nLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAATemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAATemplate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAATemplate __RPC_FAR * This);
        
        IAATemplate __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAATemplate __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetLength )( 
            IAATemplate __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAATemplate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLength )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ WORD nLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAATemplate __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        END_INTERFACE
    } IAATemplateVtbl;

    interface IAATemplate
    {
        CONST_VTBL struct IAATemplateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAATemplate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAATemplate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAATemplate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAATemplate_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAATemplate_GetLength(This)	\
    (This)->lpVtbl -> GetLength(This)

#define IAATemplate_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAATemplate_SetLength(This,nLength)	\
    (This)->lpVtbl -> SetLength(This,nLength)

#define IAATemplate_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAATemplate __RPC_FAR *STDMETHODCALLTYPE IAATemplate_Clone_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAATemplate_GetLength_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAATemplate_GetName_Proxy( 
    IAATemplate __RPC_FAR * This);


void __RPC_STUB IAATemplate_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAATemplate_SetLength_Proxy( 
    IAATemplate __RPC_FAR * This,
    /* [in] */ WORD nLength);


void __RPC_STUB IAATemplate_SetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAATemplate_SetName_Proxy( 
    IAATemplate __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAATemplate_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAATemplate_INTERFACE_DEFINED__ */


#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReferenceClock
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IReferenceClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseTime( 
            /* [in] */ ReferenceTime baseTime,
            /* [in] */ ReferenceTime streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
            /* [in] */ ReferenceTime startTime,
            /* [in] */ ReferenceTime periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwAdviseCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertRealTime( 
            /* [in] */ TIME realTime,
            /* [out] */ ReferenceTime __RPC_FAR *pRefTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ ReferenceTime __RPC_FAR *pTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReferenceClock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReferenceClock __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ ReferenceTime baseTime,
            /* [in] */ ReferenceTime streamTime,
            /* [in] */ HEVENT hEvent,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdvisePeriodic )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ ReferenceTime startTime,
            /* [in] */ ReferenceTime periodTime,
            /* [in] */ HSEMAPHORE hSemaphore,
            /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertRealTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [in] */ TIME realTime,
            /* [out] */ ReferenceTime __RPC_FAR *pRefTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTime )( 
            IReferenceClock __RPC_FAR * This,
            /* [out] */ ReferenceTime __RPC_FAR *pTime);
        
        END_INTERFACE
    } IReferenceClockVtbl;

    interface IReferenceClock
    {
        CONST_VTBL struct IReferenceClockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceClock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceClock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceClock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceClock_AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdviseTime(This,baseTime,streamTime,hEvent,pdwAdviseCookie)

#define IReferenceClock_AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)	\
    (This)->lpVtbl -> AdvisePeriodic(This,startTime,periodTime,hSemaphore,pdwAdviseCookie)

#define IReferenceClock_Unadvise(This,dwAdviseCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwAdviseCookie)

#define IReferenceClock_ConvertRealTime(This,realTime,pRefTime)	\
    (This)->lpVtbl -> ConvertRealTime(This,realTime,pRefTime)

#define IReferenceClock_GetTime(This,pTime)	\
    (This)->lpVtbl -> GetTime(This,pTime)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReferenceClock_AdviseTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ ReferenceTime baseTime,
    /* [in] */ ReferenceTime streamTime,
    /* [in] */ HEVENT hEvent,
    /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdviseTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_AdvisePeriodic_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ ReferenceTime startTime,
    /* [in] */ ReferenceTime periodTime,
    /* [in] */ HSEMAPHORE hSemaphore,
    /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);


void __RPC_STUB IReferenceClock_AdvisePeriodic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_Unadvise_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseCookie);


void __RPC_STUB IReferenceClock_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_ConvertRealTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [in] */ TIME realTime,
    /* [out] */ ReferenceTime __RPC_FAR *pRefTime);


void __RPC_STUB IReferenceClock_ConvertRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceClock_GetTime_Proxy( 
    IReferenceClock __RPC_FAR * This,
    /* [out] */ ReferenceTime __RPC_FAR *pTime);


void __RPC_STUB IReferenceClock_GetTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceClock_INTERFACE_DEFINED__ */


#ifndef __IAAEngine_INTERFACE_DEFINED__
#define __IAAEngine_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAEngine
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAEngine,0xBCE4CC41,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocBand( 
            /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocMotif( 
            /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocPattern( 
            /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocPersonality( 
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocSection( 
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocSong( 
            /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocStyle( 
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocTemplate( 
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoTransition( 
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeSection( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ IAATemplate __RPC_FAR *pTemplate,
            /* [in] */ WORD wActivity,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeSectionFromShape( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [in] */ WORD wActivity,
            /* [in] */ AACommands command,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShape( 
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposeTransition( 
            /* [in] */ IAASection __RPC_FAR *pFromSection,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ WORD wMeasureNum,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonality( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual IAAPersonality __RPC_FAR *STDMETHODCALLTYPE FindPersonalityByName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE FindStyle( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual IAAStyle __RPC_FAR *STDMETHODCALLTYPE FindStyleByName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushSectionQueue( void) = 0;
        
        virtual IAASection __RPC_FAR *STDMETHODCALLTYPE GetCurrentSection( void) = 0;
        
        virtual IAAEventSink __RPC_FAR *STDMETHODCALLTYPE GetEventSink( void) = 0;
        
        virtual IAALoader __RPC_FAR *STDMETHODCALLTYPE GetLoader( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMeters( 
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters) = 0;
        
        virtual AAFlags STDMETHODCALLTYPE GetMetronomeFlags( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetMusicTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetMutes( void) = 0;
        
        virtual IAANotifySink __RPC_FAR *STDMETHODCALLTYPE GetNotifySink( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPPQN( void) = 0;
        
        virtual IAARealTime __RPC_FAR *STDMETHODCALLTYPE GetRealTime( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelTempo( void) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetRelVolume( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTempo( void) = 0;
        
        virtual DWORD STDMETHODCALLTYPE GetTimeSignature( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsPlaying( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayMotif( 
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySection( 
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaySong( 
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueUserMsg( 
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllPersonalities( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllStyles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasePersonality( 
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseStyle( 
            /* [in] */ IAAStyle __RPC_FAR *pStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLoader( 
            /* [in] */ IAALoader __RPC_FAR *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMutes( 
            /* [in] */ WORD wMutes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotifySink( 
            /* [in] */ IAANotifySink __RPC_FAR *pNotifySink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrepareTime( 
            /* [in] */ WORD wPrepareTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRealTime( 
            /* [in] */ IAARealTime __RPC_FAR *pRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelTempo( 
            /* [in] */ WORD wRelTempo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRelVolume( 
            /* [in] */ WORD wRelVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMetronomeFlags( 
            /* [in] */ AAFlags fFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStyleCacheSize( 
            /* [in] */ WORD wNumStyles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ AAFlags flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAEngine __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocBand )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocMotif )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocPattern )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocPersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocSection )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocSong )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocTemplate )( 
            IAAEngine __RPC_FAR * This,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AutoTransition )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeSection )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ IAATemplate __RPC_FAR *pTemplate,
            /* [in] */ WORD wActivity,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeSectionFromShape )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [in] */ WORD wActivity,
            /* [in] */ AACommands command,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeTemplateFromShape )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wNumMeasures,
            /* [in] */ AAShape shape,
            /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComposeTransition )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pFromSection,
            /* [in] */ IAASection __RPC_FAR *pToSection,
            /* [in] */ WORD wMeasureNum,
            /* [in] */ AACommands command,
            /* [in] */ AAFlags flags,
            /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        IAAPersonality __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindPersonalityByName )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        IAAStyle __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *FindStyleByName )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushSectionQueue )( 
            IAAEngine __RPC_FAR * This);
        
        IAASection __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetCurrentSection )( 
            IAAEngine __RPC_FAR * This);
        
        IAAEventSink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetEventSink )( 
            IAAEngine __RPC_FAR * This);
        
        IAALoader __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetLoader )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMeters )( 
            IAAEngine __RPC_FAR * This,
            /* [out][in] */ AAMETERS __RPC_FAR *pMeters);
        
        AAFlags ( STDMETHODCALLTYPE __RPC_FAR *GetMetronomeFlags )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetMusicTime )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetMutes )( 
            IAAEngine __RPC_FAR * This);
        
        IAANotifySink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetNotifySink )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPPQN )( 
            IAAEngine __RPC_FAR * This);
        
        IAARealTime __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetRealTime )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelTempo )( 
            IAAEngine __RPC_FAR * This);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetRelVolume )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTempo )( 
            IAAEngine __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *GetTimeSignature )( 
            IAAEngine __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsPlaying )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlayMotif )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAMotif __RPC_FAR *pMotif,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySection )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASection __RPC_FAR *pSection,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PlaySong )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAASong __RPC_FAR *pSong,
            /* [in] */ AAFlags flags,
            /* [in] */ DWORD dwStartTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueueUserMsg )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ DWORD dwTime,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseAllPersonalities )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseAllStyles )( 
            IAAEngine __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleasePersonality )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAPersonality __RPC_FAR *pPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseStyle )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAStyle __RPC_FAR *pStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventSink )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLoader )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAALoader __RPC_FAR *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMutes )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wMutes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAANotifySink __RPC_FAR *pNotifySink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPrepareTime )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wPrepareTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRealTime )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ IAARealTime __RPC_FAR *pRealTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelTempo )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wRelTempo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRelVolume )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wRelVolume);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMetronomeFlags )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ AAFlags fFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyleCacheSize )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ WORD wNumStyles);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IAAEngine __RPC_FAR * This,
            /* [in] */ AAFlags flags);
        
        END_INTERFACE
    } IAAEngineVtbl;

    interface IAAEngine
    {
        CONST_VTBL struct IAAEngineVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAEngine_AllocBand(This,ppBand)	\
    (This)->lpVtbl -> AllocBand(This,ppBand)

#define IAAEngine_AllocMotif(This,ppMotif)	\
    (This)->lpVtbl -> AllocMotif(This,ppMotif)

#define IAAEngine_AllocPattern(This,ppPattern)	\
    (This)->lpVtbl -> AllocPattern(This,ppPattern)

#define IAAEngine_AllocPersonality(This,ppPersonality)	\
    (This)->lpVtbl -> AllocPersonality(This,ppPersonality)

#define IAAEngine_AllocSection(This,ppSection)	\
    (This)->lpVtbl -> AllocSection(This,ppSection)

#define IAAEngine_AllocSong(This,ppSong)	\
    (This)->lpVtbl -> AllocSong(This,ppSong)

#define IAAEngine_AllocStyle(This,ppStyle)	\
    (This)->lpVtbl -> AllocStyle(This,ppStyle)

#define IAAEngine_AllocTemplate(This,ppTemplate)	\
    (This)->lpVtbl -> AllocTemplate(This,ppTemplate)

#define IAAEngine_AutoTransition(This,pToSection,command,flags)	\
    (This)->lpVtbl -> AutoTransition(This,pToSection,command,flags)

#define IAAEngine_ComposeSection(This,pStyle,pTemplate,wActivity,pPersonality,ppSection)	\
    (This)->lpVtbl -> ComposeSection(This,pStyle,pTemplate,wActivity,pPersonality,ppSection)

#define IAAEngine_ComposeSectionFromShape(This,pStyle,wNumMeasures,shape,wActivity,command,pPersonality,ppSection)	\
    (This)->lpVtbl -> ComposeSectionFromShape(This,pStyle,wNumMeasures,shape,wActivity,command,pPersonality,ppSection)

#define IAAEngine_ComposeTemplateFromShape(This,wNumMeasures,shape,pTemplate)	\
    (This)->lpVtbl -> ComposeTemplateFromShape(This,wNumMeasures,shape,pTemplate)

#define IAAEngine_ComposeTransition(This,pFromSection,pToSection,wMeasureNum,command,flags,ppSection)	\
    (This)->lpVtbl -> ComposeTransition(This,pFromSection,pToSection,wMeasureNum,command,flags,ppSection)

#define IAAEngine_FindPersonality(This,guid)	\
    (This)->lpVtbl -> FindPersonality(This,guid)

#define IAAEngine_FindPersonalityByName(This,pszName)	\
    (This)->lpVtbl -> FindPersonalityByName(This,pszName)

#define IAAEngine_FindStyle(This,guid)	\
    (This)->lpVtbl -> FindStyle(This,guid)

#define IAAEngine_FindStyleByName(This,pszName)	\
    (This)->lpVtbl -> FindStyleByName(This,pszName)

#define IAAEngine_FlushSectionQueue(This)	\
    (This)->lpVtbl -> FlushSectionQueue(This)

#define IAAEngine_GetCurrentSection(This)	\
    (This)->lpVtbl -> GetCurrentSection(This)

#define IAAEngine_GetEventSink(This)	\
    (This)->lpVtbl -> GetEventSink(This)

#define IAAEngine_GetLoader(This)	\
    (This)->lpVtbl -> GetLoader(This)

#define IAAEngine_GetMeters(This,pMeters)	\
    (This)->lpVtbl -> GetMeters(This,pMeters)

#define IAAEngine_GetMetronomeFlags(This)	\
    (This)->lpVtbl -> GetMetronomeFlags(This)

#define IAAEngine_GetMusicTime(This)	\
    (This)->lpVtbl -> GetMusicTime(This)

#define IAAEngine_GetMutes(This)	\
    (This)->lpVtbl -> GetMutes(This)

#define IAAEngine_GetNotifySink(This)	\
    (This)->lpVtbl -> GetNotifySink(This)

#define IAAEngine_GetPPQN(This)	\
    (This)->lpVtbl -> GetPPQN(This)

#define IAAEngine_GetRealTime(This)	\
    (This)->lpVtbl -> GetRealTime(This)

#define IAAEngine_GetRelTempo(This)	\
    (This)->lpVtbl -> GetRelTempo(This)

#define IAAEngine_GetRelVolume(This)	\
    (This)->lpVtbl -> GetRelVolume(This)

#define IAAEngine_GetTempo(This)	\
    (This)->lpVtbl -> GetTempo(This)

#define IAAEngine_GetTimeSignature(This)	\
    (This)->lpVtbl -> GetTimeSignature(This)

#define IAAEngine_IsPlaying(This)	\
    (This)->lpVtbl -> IsPlaying(This)

#define IAAEngine_PlayMotif(This,pMotif,flags,dwTime)	\
    (This)->lpVtbl -> PlayMotif(This,pMotif,flags,dwTime)

#define IAAEngine_PlaySection(This,pSection,flags,dwStartTime)	\
    (This)->lpVtbl -> PlaySection(This,pSection,flags,dwStartTime)

#define IAAEngine_PlaySong(This,pSong,flags,dwStartTime)	\
    (This)->lpVtbl -> PlaySong(This,pSong,flags,dwStartTime)

#define IAAEngine_QueueUserMsg(This,dwTime,dwParam1,dwParam2)	\
    (This)->lpVtbl -> QueueUserMsg(This,dwTime,dwParam1,dwParam2)

#define IAAEngine_ReleaseAllPersonalities(This)	\
    (This)->lpVtbl -> ReleaseAllPersonalities(This)

#define IAAEngine_ReleaseAllStyles(This)	\
    (This)->lpVtbl -> ReleaseAllStyles(This)

#define IAAEngine_ReleasePersonality(This,pPersonality)	\
    (This)->lpVtbl -> ReleasePersonality(This,pPersonality)

#define IAAEngine_ReleaseStyle(This,pStyle)	\
    (This)->lpVtbl -> ReleaseStyle(This,pStyle)

#define IAAEngine_SetEventSink(This,pEventSink)	\
    (This)->lpVtbl -> SetEventSink(This,pEventSink)

#define IAAEngine_SetLoader(This,pLoader)	\
    (This)->lpVtbl -> SetLoader(This,pLoader)

#define IAAEngine_SetMutes(This,wMutes)	\
    (This)->lpVtbl -> SetMutes(This,wMutes)

#define IAAEngine_SetNotifySink(This,pNotifySink)	\
    (This)->lpVtbl -> SetNotifySink(This,pNotifySink)

#define IAAEngine_SetPrepareTime(This,wPrepareTime)	\
    (This)->lpVtbl -> SetPrepareTime(This,wPrepareTime)

#define IAAEngine_SetRealTime(This,pRealTime)	\
    (This)->lpVtbl -> SetRealTime(This,pRealTime)

#define IAAEngine_SetRelTempo(This,wRelTempo)	\
    (This)->lpVtbl -> SetRelTempo(This,wRelTempo)

#define IAAEngine_SetRelVolume(This,wRelVolume)	\
    (This)->lpVtbl -> SetRelVolume(This,wRelVolume)

#define IAAEngine_SetMetronomeFlags(This,fFlags)	\
    (This)->lpVtbl -> SetMetronomeFlags(This,fFlags)

#define IAAEngine_SetStyleCacheSize(This,wNumStyles)	\
    (This)->lpVtbl -> SetStyleCacheSize(This,wNumStyles)

#define IAAEngine_Stop(This,flags)	\
    (This)->lpVtbl -> Stop(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAEngine_AllocBand_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAABand __RPC_FAR *__RPC_FAR *ppBand);


void __RPC_STUB IAAEngine_AllocBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocMotif_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAMotif __RPC_FAR *__RPC_FAR *ppMotif);


void __RPC_STUB IAAEngine_AllocMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocPattern_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAPattern __RPC_FAR *__RPC_FAR *ppPattern);


void __RPC_STUB IAAEngine_AllocPattern_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocPersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);


void __RPC_STUB IAAEngine_AllocPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocSection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_AllocSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocSong_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAASong __RPC_FAR *__RPC_FAR *ppSong);


void __RPC_STUB IAAEngine_AllocSong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);


void __RPC_STUB IAAEngine_AllocStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AllocTemplate_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *ppTemplate);


void __RPC_STUB IAAEngine_AllocTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_AutoTransition_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pToSection,
    /* [in] */ AACommands command,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAEngine_AutoTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeSection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle,
    /* [in] */ IAATemplate __RPC_FAR *pTemplate,
    /* [in] */ WORD wActivity,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeSectionFromShape_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle,
    /* [in] */ WORD wNumMeasures,
    /* [in] */ AAShape shape,
    /* [in] */ WORD wActivity,
    /* [in] */ AACommands command,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeSectionFromShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeTemplateFromShape_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wNumMeasures,
    /* [in] */ AAShape shape,
    /* [retval][out] */ IAATemplate __RPC_FAR *__RPC_FAR *pTemplate);


void __RPC_STUB IAAEngine_ComposeTemplateFromShape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ComposeTransition_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pFromSection,
    /* [in] */ IAASection __RPC_FAR *pToSection,
    /* [in] */ WORD wMeasureNum,
    /* [in] */ AACommands command,
    /* [in] */ AAFlags flags,
    /* [retval][out] */ IAASection __RPC_FAR *__RPC_FAR *ppSection);


void __RPC_STUB IAAEngine_ComposeTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindPersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB IAAEngine_FindPersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAPersonality __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindPersonalityByName_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAEngine_FindPersonalityByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB IAAEngine_FindStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAStyle __RPC_FAR *STDMETHODCALLTYPE IAAEngine_FindStyleByName_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAAEngine_FindStyleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_FlushSectionQueue_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_FlushSectionQueue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAASection __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetCurrentSection_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetCurrentSection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAEventSink __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetEventSink_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAALoader __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetLoader_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetLoader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_GetMeters_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [out][in] */ AAMETERS __RPC_FAR *pMeters);


void __RPC_STUB IAAEngine_GetMeters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


AAFlags STDMETHODCALLTYPE IAAEngine_GetMetronomeFlags_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMetronomeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetMusicTime_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMusicTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetMutes_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAANotifySink __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetNotifySink_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetPPQN_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetPPQN_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAARealTime __RPC_FAR *STDMETHODCALLTYPE IAAEngine_GetRealTime_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetRelTempo_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAAEngine_GetRelVolume_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetTempo_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IAAEngine_GetTimeSignature_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_GetTimeSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAEngine_IsPlaying_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_IsPlaying_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlayMotif_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAMotif __RPC_FAR *pMotif,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwTime);


void __RPC_STUB IAAEngine_PlayMotif_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlaySection_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASection __RPC_FAR *pSection,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAAEngine_PlaySection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_PlaySong_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAASong __RPC_FAR *pSong,
    /* [in] */ AAFlags flags,
    /* [in] */ DWORD dwStartTime);


void __RPC_STUB IAAEngine_PlaySong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_QueueUserMsg_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ DWORD dwTime,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IAAEngine_QueueUserMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseAllPersonalities_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_ReleaseAllPersonalities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseAllStyles_Proxy( 
    IAAEngine __RPC_FAR * This);


void __RPC_STUB IAAEngine_ReleaseAllStyles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleasePersonality_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAPersonality __RPC_FAR *pPersonality);


void __RPC_STUB IAAEngine_ReleasePersonality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_ReleaseStyle_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAStyle __RPC_FAR *pStyle);


void __RPC_STUB IAAEngine_ReleaseStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetEventSink_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAAEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IAAEngine_SetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetLoader_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAALoader __RPC_FAR *pLoader);


void __RPC_STUB IAAEngine_SetLoader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetMutes_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wMutes);


void __RPC_STUB IAAEngine_SetMutes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetNotifySink_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAANotifySink __RPC_FAR *pNotifySink);


void __RPC_STUB IAAEngine_SetNotifySink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetPrepareTime_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wPrepareTime);


void __RPC_STUB IAAEngine_SetPrepareTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRealTime_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ IAARealTime __RPC_FAR *pRealTime);


void __RPC_STUB IAAEngine_SetRealTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRelTempo_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wRelTempo);


void __RPC_STUB IAAEngine_SetRelTempo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetRelVolume_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wRelVolume);


void __RPC_STUB IAAEngine_SetRelVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetMetronomeFlags_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ AAFlags fFlags);


void __RPC_STUB IAAEngine_SetMetronomeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_SetStyleCacheSize_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ WORD wNumStyles);


void __RPC_STUB IAAEngine_SetStyleCacheSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEngine_Stop_Proxy( 
    IAAEngine __RPC_FAR * This,
    /* [in] */ AAFlags flags);


void __RPC_STUB IAAEngine_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAEngine_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIIn_INTERFACE_DEFINED__
#define __IAAMIDIIn_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIIn
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIIn,0xBCE4CC46,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIIn : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE GetMIDISink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMIDISink( 
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDevice( 
            /* [in] */ WORD wDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIInVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIIn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAAMIDIIn __RPC_FAR * This);
        
        IAAMIDISink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetMIDISink )( 
            IAAMIDIIn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMIDISink )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDevice )( 
            IAAMIDIIn __RPC_FAR * This,
            /* [in] */ WORD wDeviceID);
        
        END_INTERFACE
    } IAAMIDIInVtbl;

    interface IAAMIDIIn
    {
        CONST_VTBL struct IAAMIDIInVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIIn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIIn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIIn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIIn_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IAAMIDIIn_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IAAMIDIIn_GetMIDISink(This)	\
    (This)->lpVtbl -> GetMIDISink(This)

#define IAAMIDIIn_SetMIDISink(This,pMIDISink)	\
    (This)->lpVtbl -> SetMIDISink(This,pMIDISink)

#define IAAMIDIIn_SetDevice(This,wDeviceID)	\
    (This)->lpVtbl -> SetDevice(This,wDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIIn_Activate_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_Deactivate_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


IAAMIDISink __RPC_FAR *STDMETHODCALLTYPE IAAMIDIIn_GetMIDISink_Proxy( 
    IAAMIDIIn __RPC_FAR * This);


void __RPC_STUB IAAMIDIIn_GetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_SetMIDISink_Proxy( 
    IAAMIDIIn __RPC_FAR * This,
    /* [in] */ IAAMIDISink __RPC_FAR *pMIDISink);


void __RPC_STUB IAAMIDIIn_SetMIDISink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIIn_SetDevice_Proxy( 
    IAAMIDIIn __RPC_FAR * This,
    /* [in] */ WORD wDeviceID);


void __RPC_STUB IAAMIDIIn_SetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIIn_INTERFACE_DEFINED__ */


#ifndef __IAAMIDIOut_INTERFACE_DEFINED__
#define __IAAMIDIOut_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAMIDIOut
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAMIDIOut,0xBCE4CC47,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAMIDIOut : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual VARIANT_BOOL STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDevice( 
            /* [in] */ WORD wDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAMIDIOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAMIDIOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAMIDIOut __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAAMIDIOut __RPC_FAR * This);
        
        VARIANT_BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            IAAMIDIOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDevice )( 
            IAAMIDIOut __RPC_FAR * This,
            /* [in] */ WORD wDeviceID);
        
        END_INTERFACE
    } IAAMIDIOutVtbl;

    interface IAAMIDIOut
    {
        CONST_VTBL struct IAAMIDIOutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAMIDIOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAMIDIOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAMIDIOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAMIDIOut_Activate(This)	\
    (This)->lpVtbl -> Activate(This)

#define IAAMIDIOut_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IAAMIDIOut_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define IAAMIDIOut_SetDevice(This,wDeviceID)	\
    (This)->lpVtbl -> SetDevice(This,wDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAAMIDIOut_Activate_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIOut_Deactivate_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


VARIANT_BOOL STDMETHODCALLTYPE IAAMIDIOut_IsActive_Proxy( 
    IAAMIDIOut __RPC_FAR * This);


void __RPC_STUB IAAMIDIOut_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAMIDIOut_SetDevice_Proxy( 
    IAAMIDIOut __RPC_FAR * This,
    /* [in] */ WORD wDeviceID);


void __RPC_STUB IAAMIDIOut_SetDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAMIDIOut_INTERFACE_DEFINED__ */


#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAEngine,0xBCE4CC51,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAEngine;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAARealTime,0xBCE4CC52,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAARealTime;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAMIDIOut,0xBCE4CC53,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAMIDIOut;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAASection,0xBCE4CC55,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAASection;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAASong,0xBCE4CC56,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAASong;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAMotif,0xBCE4CC57,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAMotif;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAStyle,0xBCE4CC58,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAStyle;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAPersonality,0xBCE4CC59,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAPersonality;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAABand,0xBCE4CC5a,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAABand;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAATemplate,0xBCE4CC5b,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAATemplate;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAAPattern,0xBCE4CC5c,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAAPattern;
#endif

#ifdef __cplusplus
DEFINE_GUID(CLSID_CAALoader,0xBCE4CC5e,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

class CAALoader;
#endif
#endif /* __AudioActive_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\types\idl\primtype.h ===
interface IDABoolean;
    interface IDACamera;
    interface IDAColor;
    interface IDAGeometry;
    interface IDAImage;
    interface IDAMatte;
    interface IDAMicrophone;
    interface IDAMontage;
    interface IDANumber;
    interface IDAPath2;
    interface IDAPoint2;
    interface IDAPoint3;
    interface IDASound;
    interface IDAString;
    interface IDATransform2;
    interface IDATransform3;
    interface IDAVector2;
    interface IDAVector3;
    interface IDAFontStyle;
    interface IDALineStyle;
    interface IDAEndStyle;
    interface IDAJoinStyle;
    interface IDADashStyle;
    interface IDABbox2;
    interface IDABbox3;
    interface IDAPair;
    interface IDAEvent;
    interface IDAArray;
    interface IDATuple;
    interface IDAUserData;

    // ====================================
    // IDABoolean interface definition
    // ====================================

    [
        uuid(C46C1BC0-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Boolean Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABoolean : IDABehavior
    {
        HRESULT Extract ([out, retval] VARIANT_BOOL * ret_0) ;

    }

    // ====================================
    // IDACamera interface definition
    // ====================================

    [
        uuid(C46C1BE1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Camera Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDACamera : IDABehavior
    {
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT Depth ([in] double depth_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthAnim ([in] IDANumber * depth_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthResolution ([in] double resolution_0, [out, retval] IDACamera * * ret_1) ;
        HRESULT DepthResolutionAnim ([in] IDANumber * resolution_0, [out, retval] IDACamera * * ret_1) ;

    }

    // ====================================
    // IDAColor interface definition
    // ====================================

    [
        uuid(C46C1BC5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Color Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAColor : IDABehavior
    {
        [propget] HRESULT Red ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Green ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Blue ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Hue ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Saturation ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Lightness ([out, retval] IDANumber * * ret_0) ;

    }

    // ====================================
    // IDAGeometry interface definition
    // ====================================

    [
        uuid(C46C1BDF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Geometry Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAGeometry : IDABehavior
    {
        HRESULT RenderSound ([in] IDAMicrophone * mic_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Pickable ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT PickableOccluded ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT Undetectable ([out, retval] IDAGeometry * * ret_0) ;
        HRESULT EmissiveColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT DiffuseColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularColor ([in] IDAColor * col_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularExponent ([in] double power_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT SpecularExponentAnim ([in] IDANumber * power_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Texture ([in] IDAImage * texture_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Opacity ([in] double level_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT OpacityAnim ([in] IDANumber * level_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAGeometry * * ret_1) ;
        [propget] HRESULT BoundingBox ([out, retval] IDABbox3 * * ret_0) ;
        HRESULT Render ([in] IDACamera * cam_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT LightColor ([in] IDAColor * color_0, [out, retval] IDAGeometry * * ret_1) ;
        HRESULT LightAttenuationAnim ([in] IDANumber * constant_0, [in] IDANumber * linear_1, [in] IDANumber * quadratic_2, [out, retval] IDAGeometry * * ret_3) ;
        HRESULT LightAttenuation ([in] double constant_0, [in] double linear_1, [in] double quadratic_2, [out, retval] IDAGeometry * * ret_3) ;

    }

    // ====================================
    // IDAImage interface definition
    // ====================================

    [
        uuid(C46C1BD3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Image Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAImage : IDABehavior
    {
        HRESULT Pickable ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT PickableOccluded ([out, retval] IDAPickableResult * * ret_0) ;
        HRESULT ApplyBitmapEffect ([in] IUnknown * effectToApply_0, [in] IDAEvent * firesWhenChanged_1, [out, retval] IDAImage * * ret_2) ;
        [propget] HRESULT BoundingBox ([out, retval] IDABbox2 * * ret_0) ;
        HRESULT Crop ([in] IDAPoint2 * min_0, [in] IDAPoint2 * max_1, [out, retval] IDAImage * * ret_2) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT OpacityAnim ([in] IDANumber * opacity_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Opacity ([in] double opacity_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Undetectable ([out, retval] IDAImage * * ret_0) ;
        HRESULT Tile ([out, retval] IDAImage * * ret_0) ;
        HRESULT Clip ([in] IDAMatte * m_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT MapToUnitSquare ([out, retval] IDAImage * * ret_0) ;
        HRESULT ClipPolygonImageEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [out, retval] IDAImage * * ret_1) ;
        HRESULT ClipPolygonImage ([in] VARIANT points_0, [out, retval] IDAImage * * ret_1) ;

    }

    // ====================================
    // IDAMatte interface definition
    // ====================================

    [
        uuid(C46C1BD1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Matte Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMatte : IDABehavior
    {
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAMatte * * ret_1) ;

    }

    // ====================================
    // IDAMicrophone interface definition
    // ====================================

    [
        uuid(C46C1BE5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Microphone Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMicrophone : IDABehavior
    {
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAMicrophone * * ret_1) ;

    }

    // ====================================
    // IDAMontage interface definition
    // ====================================

    [
        uuid(C46C1BD5-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Montage Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAMontage : IDABehavior
    {
        HRESULT Render ([out, retval] IDAImage * * ret_0) ;

    }

    // ====================================
    // IDANumber interface definition
    // ====================================

    [
        uuid(9CDE7340-3C20-11d0-A330-00AA00B92C03),
        helpstring("DirectAnimation Number Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDANumber : IDABehavior
    {
        HRESULT Extract ([out, retval] double * ret_0) ;
        HRESULT AnimateProperty ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDANumber * * ret_4) ;
        HRESULT ToStringAnim ([in] IDANumber * precision_0, [out, retval] IDAString * * ret_1) ;
        HRESULT ToString ([in] double precision_0, [out, retval] IDAString * * ret_1) ;

    }

    // ====================================
    // IDAPath2 interface definition
    // ====================================

    [
        uuid(C46C1BCF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Path2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPath2 : IDABehavior
    {
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAPath2 * * ret_1) ;
        HRESULT BoundingBox ([in] IDALineStyle * style_0, [out, retval] IDABbox2 * * ret_1) ;
        HRESULT Fill ([in] IDALineStyle * border_0, [in] IDAImage * fill_1, [out, retval] IDAImage * * ret_2) ;
        HRESULT Draw ([in] IDALineStyle * border_0, [out, retval] IDAImage * * ret_1) ;
        HRESULT Close ([out, retval] IDAPath2 * * ret_0) ;

    }

    // ====================================
    // IDAPoint2 interface definition
    // ====================================

    [
        uuid(C46C1BC7-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Point2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPoint2 : IDABehavior
    {
        HRESULT AnimateControlPosition ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAPoint2 * * ret_4) ;
        HRESULT AnimateControlPositionPixel ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAPoint2 * * ret_4) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAPoint2 * * ret_1) ;

    }

    // ====================================
    // IDAPoint3 interface definition
    // ====================================

    [
        uuid(C46C1BD7-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Point3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPoint3 : IDABehavior
    {
        HRESULT Project ([in] IDACamera * cam_0, [out, retval] IDAPoint2 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Z ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordXYAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordYZAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAPoint3 * * ret_1) ;

    }

    // ====================================
    // IDASound interface definition
    // ====================================

    [
        uuid(C46C1BE3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Sound Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDASound : IDABehavior
    {
        HRESULT PhaseAnim ([in] IDANumber * phaseAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Phase ([in] double phaseAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT RateAnim ([in] IDANumber * pitchShift_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Rate ([in] double pitchShift_0, [out, retval] IDASound * * ret_1) ;
        HRESULT PanAnim ([in] IDANumber * panAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Pan ([in] double panAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT GainAnim ([in] IDANumber * gainAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Gain ([in] double gainAmt_0, [out, retval] IDASound * * ret_1) ;
        HRESULT Loop ([out, retval] IDASound * * ret_0) ;

    }

    // ====================================
    // IDAString interface definition
    // ====================================

    [
        uuid(C46C1BC3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation String Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAString : IDABehavior
    {
        HRESULT Extract ([out, retval] BSTR * ret_0) ;
        HRESULT AnimateProperty ([in] BSTR propertyPath_0, [in] BSTR scriptingLanguage_1, [in] VARIANT_BOOL invokeAsMethod_2, [in] double minUpdateInterval_3, [out, retval] IDAString * * ret_4) ;

    }

    // ====================================
    // IDATransform2 interface definition
    // ====================================

    [
        uuid(C46C1BCB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Transform2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATransform2 : IDABehavior
    {
        HRESULT Inverse ([out, retval] IDATransform2 * * ret_0) ;
        [propget] HRESULT IsSingular ([out, retval] IDABoolean * * ret_0) ;

    }

    // ====================================
    // IDATransform3 interface definition
    // ====================================

    [
        uuid(C46C1BDB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Transform3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATransform3 : IDABehavior
    {
        HRESULT Inverse ([out, retval] IDATransform3 * * ret_0) ;
        [propget] HRESULT IsSingular ([out, retval] IDABoolean * * ret_0) ;
        HRESULT ParallelTransform2 ([out, retval] IDATransform2 * * ret_0) ;

    }

    // ====================================
    // IDAVector2 interface definition
    // ====================================

    [
        uuid(C46C1BC9-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Vector2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAVector2 : IDABehavior
    {
        [propget] HRESULT Length ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT LengthSquared ([out, retval] IDANumber * * ret_0) ;
        HRESULT Normalize ([out, retval] IDAVector2 * * ret_0) ;
        HRESULT MulAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT Mul ([in] double scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT DivAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        HRESULT Div ([in] double scalar_0, [out, retval] IDAVector2 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT PolarCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform2 * xf_0, [out, retval] IDAVector2 * * ret_1) ;

    }

    // ====================================
    // IDAVector3 interface definition
    // ====================================

    [
        uuid(C46C1BD9-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Vector3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAVector3 : IDABehavior
    {
        [propget] HRESULT Length ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT LengthSquared ([out, retval] IDANumber * * ret_0) ;
        HRESULT Normalize ([out, retval] IDAVector3 * * ret_0) ;
        HRESULT MulAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT Mul ([in] double scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT DivAnim ([in] IDANumber * scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        HRESULT Div ([in] double scalar_0, [out, retval] IDAVector3 * * ret_1) ;
        [propget] HRESULT X ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Y ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT Z ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordXYAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordYZAngle ([out, retval] IDANumber * * ret_0) ;
        [propget] HRESULT SphericalCoordLength ([out, retval] IDANumber * * ret_0) ;
        HRESULT Transform ([in] IDATransform3 * xf_0, [out, retval] IDAVector3 * * ret_1) ;

    }

    // ====================================
    // IDAFontStyle interface definition
    // ====================================

    [
        uuid(25B0F91D-D23D-11d0-9B85-00C04FC2F51D),
        helpstring("DirectAnimation FontStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAFontStyle : IDABehavior
    {
        HRESULT Bold ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Italic ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Underline ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT Strikethrough ([out, retval] IDAFontStyle * * ret_0) ;
        HRESULT AntiAliasing ([in] double aaStyle_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Color ([in] IDAColor * col_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT FamilyAnim ([in] IDAString * face_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Family ([in] BSTR face_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT SizeAnim ([in] IDANumber * size_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Size ([in] double size_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT Weight ([in] double weight_0, [out, retval] IDAFontStyle * * ret_1) ;
        HRESULT WeightAnim ([in] IDANumber * weight_0, [out, retval] IDAFontStyle * * ret_1) ;

    }

    // ====================================
    // IDALineStyle interface definition
    // ====================================

    [
        uuid(C46C1BF1-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation LineStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDALineStyle : IDABehavior
    {
        HRESULT End ([in] IDAEndStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Join ([in] IDAJoinStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Dash ([in] IDADashStyle * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT WidthAnim ([in] IDANumber * sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT width ([in] double sty_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT AntiAliasing ([in] double aaStyle_0, [out, retval] IDALineStyle * * ret_1) ;
        HRESULT Detail ([out, retval] IDALineStyle * * ret_0) ;
        HRESULT Color ([in] IDAColor * clr_0, [out, retval] IDALineStyle * * ret_1) ;

    }

    // ====================================
    // IDAEndStyle interface definition
    // ====================================

    [
        uuid(C46C1BEB-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation EndStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAEndStyle : IDABehavior
    {

    }

    // ====================================
    // IDAJoinStyle interface definition
    // ====================================

    [
        uuid(C46C1BED-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation JoinStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAJoinStyle : IDABehavior
    {

    }

    // ====================================
    // IDADashStyle interface definition
    // ====================================

    [
        uuid(C46C1BEF-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation DashStyle Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDADashStyle : IDABehavior
    {

    }

    // ====================================
    // IDABbox2 interface definition
    // ====================================

    [
        uuid(C46C1BCD-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Bbox2 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABbox2 : IDABehavior
    {
        [propget] HRESULT Min ([out, retval] IDAPoint2 * * ret_0) ;
        [propget] HRESULT Max ([out, retval] IDAPoint2 * * ret_0) ;

    }

    // ====================================
    // IDABbox3 interface definition
    // ====================================

    [
        uuid(C46C1BDD-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Bbox3 Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDABbox3 : IDABehavior
    {
        [propget] HRESULT Min ([out, retval] IDAPoint3 * * ret_0) ;
        [propget] HRESULT Max ([out, retval] IDAPoint3 * * ret_0) ;

    }

    // ====================================
    // IDAPair interface definition
    // ====================================

    [
        uuid(C46C1BF3-3C52-11d0-9200-848C1D000000),
        helpstring("DirectAnimation Pair Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAPair : IDABehavior
    {
        [propget] HRESULT First ([out, retval] IDABehavior * * ret_0) ;
        [propget] HRESULT Second ([out, retval] IDABehavior * * ret_0) ;

    }

    // ====================================
    // IDAEvent interface definition
    // ====================================

    [
        uuid(50B4791E-4731-11d0-8912-00C04FC2A0CA),
        helpstring("DirectAnimation Event Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAEvent : IDABehavior
    {
        HRESULT Notify ([in] IDAUntilNotifier * notifier_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT Snapshot ([in] IDABehavior * b_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT AttachData ([in] IDABehavior * data_0, [out, retval] IDAEvent * * ret_1) ;
        HRESULT ScriptCallback ([in] BSTR scriptlet_0, [in] BSTR language_1, [out, retval] IDAEvent * * ret_2) ;

    }

    // ====================================
    // IDAArray interface definition
    // ====================================

    [
        uuid(D17506C2-6B26-11d0-8914-00C04FC2A0CA),
        helpstring("DirectAnimation Array Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAArray : IDABehavior
    {
        HRESULT NthAnim ([in] IDANumber * index_0, [out, retval] IDABehavior * * ret_1) ;
        HRESULT Length ([out, retval] IDANumber * * ret_0) ;

    }

    // ====================================
    // IDATuple interface definition
    // ====================================

    [
        uuid(5DFB2650-9668-11d0-B17B-00C04FC2A0CA),
        helpstring("DirectAnimation Tuple Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDATuple : IDABehavior
    {
        HRESULT Nth ([in] long index_0, [out, retval] IDABehavior * * ret_1) ;
        [propget] HRESULT Length ([out, retval] long * ret_0) ;

    }

    // ====================================
    // IDAUserData interface definition
    // ====================================

    [
        uuid(AF868305-AB0B-11d0-876A-00C04FC29D46),
        helpstring("DirectAnimation Userdata Behavior"),
        local,
        object,
        pointer_default(unique),
        oleautomation,
        hidden,
        dual
    ]
    interface IDAUserData : IDABehavior
    {
        [propget] HRESULT Data ([out, retval] IUnknown * * ret_0) ;

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\icecap\icapexp.h ===
/*****************************************************************************/
/*                                                                           */
/*    ICAPEXP.H -- Exports from ICAP.DLL				     */
/*									     */
/*    Copyright (C) 1995 by Microsoft Corp.				     */
/*    All rights reserved						     */
/*									     */
/*****************************************************************************/

#ifndef __ICAPEXP_H__
#define __ICAPEXP_H__

#ifndef PROFILE
#define PROFILE 1		// define this as zero to macro-out the API
#endif

#if PROFILE

#ifdef __cplusplus
extern "C"
{
#endif

int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling

int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling

#ifdef __cplusplus
}
#endif

#else // NOT PROFILE

#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0

#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0

#endif // NOT PROFILE

#endif  // __ICAPEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java15\include\javadbg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Wed Sep 25 22:22:04 1996
 */
/* Compiler settings for javadbg.idl:
    Oi, W4, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __javadbg_h__
#define __javadbg_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumLINEINFO_FWD_DEFINED__
#define __IEnumLINEINFO_FWD_DEFINED__
typedef interface IEnumLINEINFO IEnumLINEINFO;
#endif 	/* __IEnumLINEINFO_FWD_DEFINED__ */


#ifndef __IJavaEnumLINEINFO_FWD_DEFINED__
#define __IJavaEnumLINEINFO_FWD_DEFINED__
typedef interface IJavaEnumLINEINFO IJavaEnumLINEINFO;
#endif 	/* __IJavaEnumLINEINFO_FWD_DEFINED__ */


#ifndef __IRemoteField_FWD_DEFINED__
#define __IRemoteField_FWD_DEFINED__
typedef interface IRemoteField IRemoteField;
#endif 	/* __IRemoteField_FWD_DEFINED__ */


#ifndef __IEnumRemoteField_FWD_DEFINED__
#define __IEnumRemoteField_FWD_DEFINED__
typedef interface IEnumRemoteField IEnumRemoteField;
#endif 	/* __IEnumRemoteField_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteField_FWD_DEFINED__
#define __IJavaEnumRemoteField_FWD_DEFINED__
typedef interface IJavaEnumRemoteField IJavaEnumRemoteField;
#endif 	/* __IJavaEnumRemoteField_FWD_DEFINED__ */


#ifndef __IRemoteDataField_FWD_DEFINED__
#define __IRemoteDataField_FWD_DEFINED__
typedef interface IRemoteDataField IRemoteDataField;
#endif 	/* __IRemoteDataField_FWD_DEFINED__ */


#ifndef __IRemoteArrayField_FWD_DEFINED__
#define __IRemoteArrayField_FWD_DEFINED__
typedef interface IRemoteArrayField IRemoteArrayField;
#endif 	/* __IRemoteArrayField_FWD_DEFINED__ */


#ifndef __IRemoteContainerField_FWD_DEFINED__
#define __IRemoteContainerField_FWD_DEFINED__
typedef interface IRemoteContainerField IRemoteContainerField;
#endif 	/* __IRemoteContainerField_FWD_DEFINED__ */


#ifndef __IRemoteMethodField_FWD_DEFINED__
#define __IRemoteMethodField_FWD_DEFINED__
typedef interface IRemoteMethodField IRemoteMethodField;
#endif 	/* __IRemoteMethodField_FWD_DEFINED__ */


#ifndef __IRemoteClassField_FWD_DEFINED__
#define __IRemoteClassField_FWD_DEFINED__
typedef interface IRemoteClassField IRemoteClassField;
#endif 	/* __IRemoteClassField_FWD_DEFINED__ */


#ifndef __IRemoteObject_FWD_DEFINED__
#define __IRemoteObject_FWD_DEFINED__
typedef interface IRemoteObject IRemoteObject;
#endif 	/* __IRemoteObject_FWD_DEFINED__ */


#ifndef __IEnumRemoteObject_FWD_DEFINED__
#define __IEnumRemoteObject_FWD_DEFINED__
typedef interface IEnumRemoteObject IEnumRemoteObject;
#endif 	/* __IEnumRemoteObject_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteObject_FWD_DEFINED__
#define __IJavaEnumRemoteObject_FWD_DEFINED__
typedef interface IJavaEnumRemoteObject IJavaEnumRemoteObject;
#endif 	/* __IJavaEnumRemoteObject_FWD_DEFINED__ */


#ifndef __IEnumRemoteValue_FWD_DEFINED__
#define __IEnumRemoteValue_FWD_DEFINED__
typedef interface IEnumRemoteValue IEnumRemoteValue;
#endif 	/* __IEnumRemoteValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteBooleanValue_FWD_DEFINED__
#define __IEnumRemoteBooleanValue_FWD_DEFINED__
typedef interface IEnumRemoteBooleanValue IEnumRemoteBooleanValue;
#endif 	/* __IEnumRemoteBooleanValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteBooleanValue_FWD_DEFINED__
#define __IJavaEnumRemoteBooleanValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteBooleanValue IJavaEnumRemoteBooleanValue;
#endif 	/* __IJavaEnumRemoteBooleanValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteByteValue_FWD_DEFINED__
#define __IEnumRemoteByteValue_FWD_DEFINED__
typedef interface IEnumRemoteByteValue IEnumRemoteByteValue;
#endif 	/* __IEnumRemoteByteValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteByteValue_FWD_DEFINED__
#define __IJavaEnumRemoteByteValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteByteValue IJavaEnumRemoteByteValue;
#endif 	/* __IJavaEnumRemoteByteValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteCharValue_FWD_DEFINED__
#define __IEnumRemoteCharValue_FWD_DEFINED__
typedef interface IEnumRemoteCharValue IEnumRemoteCharValue;
#endif 	/* __IEnumRemoteCharValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteCharValue_FWD_DEFINED__
#define __IJavaEnumRemoteCharValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteCharValue IJavaEnumRemoteCharValue;
#endif 	/* __IJavaEnumRemoteCharValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteDoubleValue_FWD_DEFINED__
#define __IEnumRemoteDoubleValue_FWD_DEFINED__
typedef interface IEnumRemoteDoubleValue IEnumRemoteDoubleValue;
#endif 	/* __IEnumRemoteDoubleValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteDoubleValue_FWD_DEFINED__
#define __IJavaEnumRemoteDoubleValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteDoubleValue IJavaEnumRemoteDoubleValue;
#endif 	/* __IJavaEnumRemoteDoubleValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteFloatValue_FWD_DEFINED__
#define __IEnumRemoteFloatValue_FWD_DEFINED__
typedef interface IEnumRemoteFloatValue IEnumRemoteFloatValue;
#endif 	/* __IEnumRemoteFloatValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteFloatValue_FWD_DEFINED__
#define __IJavaEnumRemoteFloatValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteFloatValue IJavaEnumRemoteFloatValue;
#endif 	/* __IJavaEnumRemoteFloatValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteIntValue_FWD_DEFINED__
#define __IEnumRemoteIntValue_FWD_DEFINED__
typedef interface IEnumRemoteIntValue IEnumRemoteIntValue;
#endif 	/* __IEnumRemoteIntValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteIntValue_FWD_DEFINED__
#define __IJavaEnumRemoteIntValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteIntValue IJavaEnumRemoteIntValue;
#endif 	/* __IJavaEnumRemoteIntValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteLongValue_FWD_DEFINED__
#define __IEnumRemoteLongValue_FWD_DEFINED__
typedef interface IEnumRemoteLongValue IEnumRemoteLongValue;
#endif 	/* __IEnumRemoteLongValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteLongValue_FWD_DEFINED__
#define __IJavaEnumRemoteLongValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteLongValue IJavaEnumRemoteLongValue;
#endif 	/* __IJavaEnumRemoteLongValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteShortValue_FWD_DEFINED__
#define __IEnumRemoteShortValue_FWD_DEFINED__
typedef interface IEnumRemoteShortValue IEnumRemoteShortValue;
#endif 	/* __IEnumRemoteShortValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteShortValue_FWD_DEFINED__
#define __IJavaEnumRemoteShortValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteShortValue IJavaEnumRemoteShortValue;
#endif 	/* __IJavaEnumRemoteShortValue_FWD_DEFINED__ */


#ifndef __IRemoteArrayObject_FWD_DEFINED__
#define __IRemoteArrayObject_FWD_DEFINED__
typedef interface IRemoteArrayObject IRemoteArrayObject;
#endif 	/* __IRemoteArrayObject_FWD_DEFINED__ */


#ifndef __IRemoteBooleanObject_FWD_DEFINED__
#define __IRemoteBooleanObject_FWD_DEFINED__
typedef interface IRemoteBooleanObject IRemoteBooleanObject;
#endif 	/* __IRemoteBooleanObject_FWD_DEFINED__ */


#ifndef __IRemoteByteObject_FWD_DEFINED__
#define __IRemoteByteObject_FWD_DEFINED__
typedef interface IRemoteByteObject IRemoteByteObject;
#endif 	/* __IRemoteByteObject_FWD_DEFINED__ */


#ifndef __IRemoteCharObject_FWD_DEFINED__
#define __IRemoteCharObject_FWD_DEFINED__
typedef interface IRemoteCharObject IRemoteCharObject;
#endif 	/* __IRemoteCharObject_FWD_DEFINED__ */


#ifndef __IRemoteContainerObject_FWD_DEFINED__
#define __IRemoteContainerObject_FWD_DEFINED__
typedef interface IRemoteContainerObject IRemoteContainerObject;
#endif 	/* __IRemoteContainerObject_FWD_DEFINED__ */


#ifndef __IRemoteClassObject_FWD_DEFINED__
#define __IRemoteClassObject_FWD_DEFINED__
typedef interface IRemoteClassObject IRemoteClassObject;
#endif 	/* __IRemoteClassObject_FWD_DEFINED__ */


#ifndef __IRemoteDoubleObject_FWD_DEFINED__
#define __IRemoteDoubleObject_FWD_DEFINED__
typedef interface IRemoteDoubleObject IRemoteDoubleObject;
#endif 	/* __IRemoteDoubleObject_FWD_DEFINED__ */


#ifndef __IRemoteFloatObject_FWD_DEFINED__
#define __IRemoteFloatObject_FWD_DEFINED__
typedef interface IRemoteFloatObject IRemoteFloatObject;
#endif 	/* __IRemoteFloatObject_FWD_DEFINED__ */


#ifndef __IRemoteIntObject_FWD_DEFINED__
#define __IRemoteIntObject_FWD_DEFINED__
typedef interface IRemoteIntObject IRemoteIntObject;
#endif 	/* __IRemoteIntObject_FWD_DEFINED__ */


#ifndef __IRemoteLongObject_FWD_DEFINED__
#define __IRemoteLongObject_FWD_DEFINED__
typedef interface IRemoteLongObject IRemoteLongObject;
#endif 	/* __IRemoteLongObject_FWD_DEFINED__ */


#ifndef __IRemoteShortObject_FWD_DEFINED__
#define __IRemoteShortObject_FWD_DEFINED__
typedef interface IRemoteShortObject IRemoteShortObject;
#endif 	/* __IRemoteShortObject_FWD_DEFINED__ */


#ifndef __IRemoteStackFrame_FWD_DEFINED__
#define __IRemoteStackFrame_FWD_DEFINED__
typedef interface IRemoteStackFrame IRemoteStackFrame;
#endif 	/* __IRemoteStackFrame_FWD_DEFINED__ */


#ifndef __IRemoteThreadGroup_FWD_DEFINED__
#define __IRemoteThreadGroup_FWD_DEFINED__
typedef interface IRemoteThreadGroup IRemoteThreadGroup;
#endif 	/* __IRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IEnumRemoteThreadGroup_FWD_DEFINED__
#define __IEnumRemoteThreadGroup_FWD_DEFINED__
typedef interface IEnumRemoteThreadGroup IEnumRemoteThreadGroup;
#endif 	/* __IEnumRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteThreadGroup_FWD_DEFINED__
#define __IJavaEnumRemoteThreadGroup_FWD_DEFINED__
typedef interface IJavaEnumRemoteThreadGroup IJavaEnumRemoteThreadGroup;
#endif 	/* __IJavaEnumRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IRemoteThread_FWD_DEFINED__
#define __IRemoteThread_FWD_DEFINED__
typedef interface IRemoteThread IRemoteThread;
#endif 	/* __IRemoteThread_FWD_DEFINED__ */


#ifndef __IEnumRemoteThread_FWD_DEFINED__
#define __IEnumRemoteThread_FWD_DEFINED__
typedef interface IEnumRemoteThread IEnumRemoteThread;
#endif 	/* __IEnumRemoteThread_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteThread_FWD_DEFINED__
#define __IJavaEnumRemoteThread_FWD_DEFINED__
typedef interface IJavaEnumRemoteThread IJavaEnumRemoteThread;
#endif 	/* __IJavaEnumRemoteThread_FWD_DEFINED__ */


#ifndef __IRemoteProcessCallback_FWD_DEFINED__
#define __IRemoteProcessCallback_FWD_DEFINED__
typedef interface IRemoteProcessCallback IRemoteProcessCallback;
#endif 	/* __IRemoteProcessCallback_FWD_DEFINED__ */


#ifndef __IRemoteProcess_FWD_DEFINED__
#define __IRemoteProcess_FWD_DEFINED__
typedef interface IRemoteProcess IRemoteProcess;
#endif 	/* __IRemoteProcess_FWD_DEFINED__ */


#ifndef __IEnumRemoteProcess_FWD_DEFINED__
#define __IEnumRemoteProcess_FWD_DEFINED__
typedef interface IEnumRemoteProcess IEnumRemoteProcess;
#endif 	/* __IEnumRemoteProcess_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteProcess_FWD_DEFINED__
#define __IJavaEnumRemoteProcess_FWD_DEFINED__
typedef interface IJavaEnumRemoteProcess IJavaEnumRemoteProcess;
#endif 	/* __IJavaEnumRemoteProcess_FWD_DEFINED__ */


#ifndef __IRemoteDebugManagerCallback_FWD_DEFINED__
#define __IRemoteDebugManagerCallback_FWD_DEFINED__
typedef interface IRemoteDebugManagerCallback IRemoteDebugManagerCallback;
#endif 	/* __IRemoteDebugManagerCallback_FWD_DEFINED__ */


#ifndef __IRemoteDebugManager_FWD_DEFINED__
#define __IRemoteDebugManager_FWD_DEFINED__
typedef interface IRemoteDebugManager IRemoteDebugManager;
#endif 	/* __IRemoteDebugManager_FWD_DEFINED__ */


#ifndef __IJavaDebugManager_FWD_DEFINED__
#define __IJavaDebugManager_FWD_DEFINED__
typedef interface IJavaDebugManager IJavaDebugManager;
#endif 	/* __IJavaDebugManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */ 


























































// error codes
//
// errors returned by IRemoteContainer::GetFieldObject
static const int E_FIELDOUTOFSCOPE       = MAKE_HRESULT(1, FACILITY_ITF, 0x01);
static const int E_FIELDNOTINOBJECT      = MAKE_HRESULT(1, FACILITY_ITF, 0x02);
static const int E_NOFIELDS              = MAKE_HRESULT(1, FACILITY_ITF, 0x03);
static const int E_NULLOBJECTREF         = MAKE_HRESULT(1, FACILITY_ITF, 0x04);
// errors returned by IRemoteProcess::FindClass
static const int E_CLASSNOTFOUND         = MAKE_HRESULT(1, FACILITY_ITF, 0x10);
static const int E_BADMETHOD             = MAKE_HRESULT(1, FACILITY_ITF, 0x20);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumLINEINFO_INTERFACE_DEFINED__
#define __IEnumLINEINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumLINEINFO
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumLINEINFO __RPC_FAR *LPENUMLINEINFO;

typedef struct  tagLINEINFO
    {
    USHORT offPC;
    USHORT iLine;
    }	LINEINFO;

typedef struct tagLINEINFO __RPC_FAR *LPLINEINFO;


EXTERN_C const IID IID_IEnumLINEINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumLINEINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumLINEINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumLINEINFOVtbl;

    interface IEnumLINEINFO
    {
        CONST_VTBL struct IEnumLINEINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumLINEINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumLINEINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumLINEINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumLINEINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumLINEINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumLINEINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumLINEINFO_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumLINEINFO_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Next_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPLINEINFO rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumLINEINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Skip_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumLINEINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Reset_Proxy( 
    IEnumLINEINFO __RPC_FAR * This);


void __RPC_STUB IEnumLINEINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Clone_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumLINEINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_GetCount_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumLINEINFO_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumLINEINFO_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumLINEINFO_INTERFACE_DEFINED__
#define __IJavaEnumLINEINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumLINEINFO
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumLINEINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumLINEINFO : public IEnumLINEINFO
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ LINEINFO __RPC_FAR *pli) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumLINEINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ LINEINFO __RPC_FAR *pli);
        
        END_INTERFACE
    } IJavaEnumLINEINFOVtbl;

    interface IJavaEnumLINEINFO
    {
        CONST_VTBL struct IJavaEnumLINEINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumLINEINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumLINEINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumLINEINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumLINEINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumLINEINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumLINEINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumLINEINFO_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumLINEINFO_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumLINEINFO_GetNext(This,pli)	\
    (This)->lpVtbl -> GetNext(This,pli)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumLINEINFO_GetNext_Proxy( 
    IJavaEnumLINEINFO __RPC_FAR * This,
    /* [out] */ LINEINFO __RPC_FAR *pli);


void __RPC_STUB IJavaEnumLINEINFO_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumLINEINFO_INTERFACE_DEFINED__ */


#ifndef __IRemoteField_INTERFACE_DEFINED__
#define __IRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteField __RPC_FAR *LPREMOTEFIELD;


enum __MIDL_IRemoteField_0001
    {	FIELD_KIND_DATA_OBJECT	= 0x1,
	FIELD_KIND_DATA_PRIMITIVE	= 0x2,
	FIELD_KIND_ARRAY	= 0x4,
	FIELD_KIND_CLASS	= 0x8,
	FIELD_KIND_METHOD	= 0x10,
	FIELD_KIND_LOCAL	= 0x1000,
	FIELD_KIND_PARAM	= 0x2000,
	FIELD_KIND_THIS	= 0x4000
    };
typedef ULONG FIELDKIND;


enum __MIDL_IRemoteField_0002
    {	FIELD_ACC_PUBLIC	= 0x1,
	FIELD_ACC_PRIVATE	= 0x2,
	FIELD_ACC_PROTECTED	= 0x4,
	FIELD_ACC_STATIC	= 0x8,
	FIELD_ACC_FINAL	= 0x10,
	FIELD_ACC_SYNCHRONIZED	= 0x20,
	FIELD_ACC_VOLATILE	= 0x40,
	FIELD_ACC_TRANSIENT	= 0x80,
	FIELD_ACC_NATIVE	= 0x100,
	FIELD_ACC_INTERFACE	= 0x200,
	FIELD_ACC_ABSTRACT	= 0x400
    };
typedef ULONG FIELDMODIFIERS;


EXTERN_C const IID IID_IRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteField : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKind( 
            /* [out] */ FIELDKIND __RPC_FAR *pfk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModifiers( 
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        END_INTERFACE
    } IRemoteFieldVtbl;

    interface IRemoteField
    {
        CONST_VTBL struct IRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteField_GetName_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteField_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetKind_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ FIELDKIND __RPC_FAR *pfk);


void __RPC_STUB IRemoteField_GetKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetType_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);


void __RPC_STUB IRemoteField_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetContainer_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB IRemoteField_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetModifiers_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);


void __RPC_STUB IRemoteField_GetModifiers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteField_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteField_INTERFACE_DEFINED__
#define __IEnumRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteField __RPC_FAR *LPENUMREMOTEFIELD;


EXTERN_C const IID IID_IEnumRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteField : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteFieldVtbl;

    interface IEnumRemoteField
    {
        CONST_VTBL struct IEnumRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteField_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteField_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteField_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteField_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteField_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteField_Next_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteField_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Skip_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteField_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Reset_Proxy( 
    IEnumRemoteField __RPC_FAR * This);


void __RPC_STUB IEnumRemoteField_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Clone_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteField_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_GetCount_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteField_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteField_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteField_INTERFACE_DEFINED__
#define __IJavaEnumRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteField : public IEnumRemoteField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf);
        
        END_INTERFACE
    } IJavaEnumRemoteFieldVtbl;

    interface IJavaEnumRemoteField
    {
        CONST_VTBL struct IJavaEnumRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteField_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteField_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteField_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteField_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteField_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteField_GetNext(This,ppirf)	\
    (This)->lpVtbl -> GetNext(This,ppirf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteField_GetNext_Proxy( 
    IJavaEnumRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf);


void __RPC_STUB IJavaEnumRemoteField_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteField_INTERFACE_DEFINED__ */


#ifndef __IRemoteDataField_INTERFACE_DEFINED__
#define __IRemoteDataField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDataField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDataField __RPC_FAR *LPREMOTEDATAFIELD;


EXTERN_C const IID IID_IRemoteDataField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDataField : public IRemoteField
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDataFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDataField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDataField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDataField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        END_INTERFACE
    } IRemoteDataFieldVtbl;

    interface IRemoteDataField
    {
        CONST_VTBL struct IRemoteDataFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDataField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDataField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDataField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDataField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteDataField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteDataField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteDataField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteDataField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDataField_INTERFACE_DEFINED__ */


#ifndef __IRemoteArrayField_INTERFACE_DEFINED__
#define __IRemoteArrayField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteArrayField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteArrayField __RPC_FAR *LPREMOTEARRAYFIELD;


EXTERN_C const IID IID_IRemoteArrayField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteArrayField : public IRemoteDataField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcElements) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteArrayFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteArrayField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteArrayField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcElements);
        
        END_INTERFACE
    } IRemoteArrayFieldVtbl;

    interface IRemoteArrayField
    {
        CONST_VTBL struct IRemoteArrayFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteArrayField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteArrayField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteArrayField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteArrayField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteArrayField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteArrayField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteArrayField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteArrayField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)



#define IRemoteArrayField_GetSize(This,pcElements)	\
    (This)->lpVtbl -> GetSize(This,pcElements)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteArrayField_GetSize_Proxy( 
    IRemoteArrayField __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcElements);


void __RPC_STUB IRemoteArrayField_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteArrayField_INTERFACE_DEFINED__ */


#ifndef __IRemoteContainerField_INTERFACE_DEFINED__
#define __IRemoteContainerField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteContainerField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteContainerField __RPC_FAR *LPREMOTECONTAINERFIELD;


EXTERN_C const IID IID_IRemoteContainerField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteContainerField : public IRemoteField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFields( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteContainerFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteContainerField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteContainerField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        END_INTERFACE
    } IRemoteContainerFieldVtbl;

    interface IRemoteContainerField
    {
        CONST_VTBL struct IRemoteContainerFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteContainerField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteContainerField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteContainerField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteContainerField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteContainerField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteContainerField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteContainerField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteContainerField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteContainerField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteContainerField_GetFields_Proxy( 
    IRemoteContainerField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
    /* [in] */ FIELDKIND ulKind,
    /* [in] */ FIELDMODIFIERS ulModifiers,
    /* [unique][in] */ LPCOLESTR lpcszName);


void __RPC_STUB IRemoteContainerField_GetFields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteContainerField_INTERFACE_DEFINED__ */


#ifndef __IRemoteMethodField_INTERFACE_DEFINED__
#define __IRemoteMethodField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteMethodField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteMethodField __RPC_FAR *LPREMOTEMETHODFIELD;


EXTERN_C const IID IID_IRemoteMethodField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteMethodField : public IRemoteContainerField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBreakpoint( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearBreakpoint( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineInfo( 
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBytes( 
            /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ ULONG __RPC_FAR *poffStart,
            /* [out] */ ULONG __RPC_FAR *pcbScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexedField( 
            /* [in] */ ULONG slot,
            /* [in] */ ULONG offPC,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteMethodFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteMethodField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteMethodField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineInfo )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBytes )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScope )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ ULONG __RPC_FAR *poffStart,
            /* [out] */ ULONG __RPC_FAR *pcbScope);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexedField )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG slot,
            /* [in] */ ULONG offPC,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField);
        
        END_INTERFACE
    } IRemoteMethodFieldVtbl;

    interface IRemoteMethodField
    {
        CONST_VTBL struct IRemoteMethodFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteMethodField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteMethodField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteMethodField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteMethodField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteMethodField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteMethodField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteMethodField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteMethodField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteMethodField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)


#define IRemoteMethodField_SetBreakpoint(This,offPC)	\
    (This)->lpVtbl -> SetBreakpoint(This,offPC)

#define IRemoteMethodField_ClearBreakpoint(This,offPC)	\
    (This)->lpVtbl -> ClearBreakpoint(This,offPC)

#define IRemoteMethodField_GetLineInfo(This,ppEnum)	\
    (This)->lpVtbl -> GetLineInfo(This,ppEnum)

#define IRemoteMethodField_GetBytes(This,ppLockBytes)	\
    (This)->lpVtbl -> GetBytes(This,ppLockBytes)

#define IRemoteMethodField_GetScope(This,pField,poffStart,pcbScope)	\
    (This)->lpVtbl -> GetScope(This,pField,poffStart,pcbScope)

#define IRemoteMethodField_GetIndexedField(This,slot,offPC,ppField)	\
    (This)->lpVtbl -> GetIndexedField(This,slot,offPC,ppField)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteMethodField_SetBreakpoint_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteMethodField_SetBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_ClearBreakpoint_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteMethodField_ClearBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetLineInfo_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteMethodField_GetLineInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetBytes_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes);


void __RPC_STUB IRemoteMethodField_GetBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetScope_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [unique][in] */ IRemoteField __RPC_FAR *pField,
    /* [out] */ ULONG __RPC_FAR *poffStart,
    /* [out] */ ULONG __RPC_FAR *pcbScope);


void __RPC_STUB IRemoteMethodField_GetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetIndexedField_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG slot,
    /* [in] */ ULONG offPC,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField);


void __RPC_STUB IRemoteMethodField_GetIndexedField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteMethodField_INTERFACE_DEFINED__ */


#ifndef __IRemoteClassField_INTERFACE_DEFINED__
#define __IRemoteClassField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteClassField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteClassField __RPC_FAR *LPREMOTECLASSFIELD;


enum __MIDL_IRemoteClassField_0001
    {	CP_CONSTANT_UTF8	= 1,
	CP_CONSTANT_UNICODE	= 2,
	CP_CONSTANT_INTEGER	= 3,
	CP_CONSTANT_FLOAT	= 4,
	CP_CONSTANT_LONG	= 5,
	CP_CONSTANT_DOUBLE	= 6,
	CP_CONSTANT_CLASS	= 7,
	CP_CONSTANT_STRING	= 8,
	CP_CONSTANT_FIELDREF	= 9,
	CP_CONSTANT_METHODREF	= 10,
	CP_CONSTANT_INTERFACEMETHODREF	= 11,
	CP_CONSTANT_NAMEANDTYPE	= 12
    };

EXTERN_C const IID IID_IRemoteClassField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteClassField : public IRemoteContainerField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceFileName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuperclass( 
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaces( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConstantPoolItem( 
            /* [in] */ ULONG indexCP,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
            /* [out] */ ULONG __RPC_FAR *plength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteClassFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteClassField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteClassField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteClassField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceFileName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperclass )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaces )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConstantPoolItem )( 
            IRemoteClassField __RPC_FAR * This,
            /* [in] */ ULONG indexCP,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
            /* [out] */ ULONG __RPC_FAR *plength);
        
        END_INTERFACE
    } IRemoteClassFieldVtbl;

    interface IRemoteClassField
    {
        CONST_VTBL struct IRemoteClassFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteClassField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteClassField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteClassField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteClassField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteClassField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteClassField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteClassField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteClassField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteClassField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)


#define IRemoteClassField_GetFileName(This,ppszFileName)	\
    (This)->lpVtbl -> GetFileName(This,ppszFileName)

#define IRemoteClassField_GetSourceFileName(This,ppszSourceFileName)	\
    (This)->lpVtbl -> GetSourceFileName(This,ppszSourceFileName)

#define IRemoteClassField_GetSuperclass(This,ppSuperclass)	\
    (This)->lpVtbl -> GetSuperclass(This,ppSuperclass)

#define IRemoteClassField_GetInterfaces(This,ppEnum)	\
    (This)->lpVtbl -> GetInterfaces(This,ppEnum)

#define IRemoteClassField_GetConstantPoolItem(This,indexCP,ppCPBytes,plength)	\
    (This)->lpVtbl -> GetConstantPoolItem(This,indexCP,ppCPBytes,plength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteClassField_GetFileName_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);


void __RPC_STUB IRemoteClassField_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetSourceFileName_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName);


void __RPC_STUB IRemoteClassField_GetSourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetSuperclass_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass);


void __RPC_STUB IRemoteClassField_GetSuperclass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetInterfaces_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteClassField_GetInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetConstantPoolItem_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [in] */ ULONG indexCP,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
    /* [out] */ ULONG __RPC_FAR *plength);


void __RPC_STUB IRemoteClassField_GetConstantPoolItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteClassField_INTERFACE_DEFINED__ */


#ifndef __IRemoteObject_INTERFACE_DEFINED__
#define __IRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteObject __RPC_FAR *LPREMOTEOBJECT;

typedef BYTE JAVA_BOOLEAN;

typedef signed char JAVA_BYTE;

typedef USHORT JAVA_CHAR;

typedef double JAVA_DOUBLE;

typedef float JAVA_FLOAT;

typedef LONG JAVA_INT;

typedef LONGLONG JAVA_LONG;

typedef SHORT JAVA_SHORT;

typedef LPOLESTR JAVA_STRING;


EXTERN_C const IID IID_IRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBreakpoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearBreakpoint( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteObject __RPC_FAR * This);
        
        END_INTERFACE
    } IRemoteObjectVtbl;

    interface IRemoteObject
    {
        CONST_VTBL struct IRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteObject_GetType_Proxy( 
    IRemoteObject __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);


void __RPC_STUB IRemoteObject_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteObject_SetBreakpoint_Proxy( 
    IRemoteObject __RPC_FAR * This);


void __RPC_STUB IRemoteObject_SetBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteObject_ClearBreakpoint_Proxy( 
    IRemoteObject __RPC_FAR * This);


void __RPC_STUB IRemoteObject_ClearBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteObject_INTERFACE_DEFINED__
#define __IEnumRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteObject __RPC_FAR *LPENUMREMOTEOBJECT;


EXTERN_C const IID IID_IEnumRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteObjectVtbl;

    interface IEnumRemoteObject
    {
        CONST_VTBL struct IEnumRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteObject_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteObject_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Next_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Skip_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Reset_Proxy( 
    IEnumRemoteObject __RPC_FAR * This);


void __RPC_STUB IEnumRemoteObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Clone_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_GetCount_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteObject_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteObject_INTERFACE_DEFINED__
#define __IJavaEnumRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteObject : public IEnumRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro);
        
        END_INTERFACE
    } IJavaEnumRemoteObjectVtbl;

    interface IJavaEnumRemoteObject
    {
        CONST_VTBL struct IJavaEnumRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteObject_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteObject_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteObject_GetNext(This,ppiro)	\
    (This)->lpVtbl -> GetNext(This,ppiro)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteObject_GetNext_Proxy( 
    IJavaEnumRemoteObject __RPC_FAR * This,
    /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro);


void __RPC_STUB IJavaEnumRemoteObject_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteValue_INTERFACE_DEFINED__
#define __IEnumRemoteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteValue __RPC_FAR *LPENUMREMOTEVALUE;


EXTERN_C const IID IID_IEnumRemoteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteValueVtbl;

    interface IEnumRemoteValue
    {
        CONST_VTBL struct IEnumRemoteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Skip_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteValue_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Reset_Proxy( 
    IEnumRemoteValue __RPC_FAR * This);


void __RPC_STUB IEnumRemoteValue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Clone_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteValue_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_GetCount_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteValue_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteBooleanValue_INTERFACE_DEFINED__
#define __IEnumRemoteBooleanValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteBooleanValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteBooleanValue __RPC_FAR *LPENUMREMOTEBOOLEANVALUE;


EXTERN_C const IID IID_IEnumRemoteBooleanValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteBooleanValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteBooleanValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteBooleanValueVtbl;

    interface IEnumRemoteBooleanValue
    {
        CONST_VTBL struct IEnumRemoteBooleanValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteBooleanValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteBooleanValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteBooleanValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteBooleanValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteBooleanValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteBooleanValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteBooleanValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteBooleanValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteBooleanValue_Next_Proxy( 
    IEnumRemoteBooleanValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteBooleanValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteBooleanValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteBooleanValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteBooleanValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteBooleanValue : public IEnumRemoteBooleanValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteBooleanValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb);
        
        END_INTERFACE
    } IJavaEnumRemoteBooleanValueVtbl;

    interface IJavaEnumRemoteBooleanValue
    {
        CONST_VTBL struct IJavaEnumRemoteBooleanValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteBooleanValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteBooleanValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteBooleanValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteBooleanValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteBooleanValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteBooleanValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteBooleanValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteBooleanValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteBooleanValue_GetNext(This,pjb)	\
    (This)->lpVtbl -> GetNext(This,pjb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteBooleanValue_GetNext_Proxy( 
    IJavaEnumRemoteBooleanValue __RPC_FAR * This,
    /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb);


void __RPC_STUB IJavaEnumRemoteBooleanValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteByteValue_INTERFACE_DEFINED__
#define __IEnumRemoteByteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteByteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteByteValue __RPC_FAR *LPENUMREMOTEBYTEVALUE;


EXTERN_C const IID IID_IEnumRemoteByteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteByteValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteByteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteByteValueVtbl;

    interface IEnumRemoteByteValue
    {
        CONST_VTBL struct IEnumRemoteByteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteByteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteByteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteByteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteByteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteByteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteByteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteByteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteByteValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteByteValue_Next_Proxy( 
    IEnumRemoteByteValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteByteValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteByteValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteByteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteByteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteByteValue : public IEnumRemoteByteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteByteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte);
        
        END_INTERFACE
    } IJavaEnumRemoteByteValueVtbl;

    interface IJavaEnumRemoteByteValue
    {
        CONST_VTBL struct IJavaEnumRemoteByteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteByteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteByteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteByteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteByteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteByteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteByteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteByteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteByteValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteByteValue_GetNext(This,pjbyte)	\
    (This)->lpVtbl -> GetNext(This,pjbyte)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteByteValue_GetNext_Proxy( 
    IJavaEnumRemoteByteValue __RPC_FAR * This,
    /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte);


void __RPC_STUB IJavaEnumRemoteByteValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteCharValue_INTERFACE_DEFINED__
#define __IEnumRemoteCharValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteCharValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteCharValue __RPC_FAR *LPENUMREMOTECHARVALUE;


EXTERN_C const IID IID_IEnumRemoteCharValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteCharValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteCharValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteCharValueVtbl;

    interface IEnumRemoteCharValue
    {
        CONST_VTBL struct IEnumRemoteCharValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteCharValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteCharValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteCharValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteCharValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteCharValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteCharValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteCharValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteCharValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteCharValue_Next_Proxy( 
    IEnumRemoteCharValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteCharValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteCharValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteCharValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteCharValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteCharValue : public IEnumRemoteCharValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_CHAR __RPC_FAR *pjch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteCharValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ JAVA_CHAR __RPC_FAR *pjch);
        
        END_INTERFACE
    } IJavaEnumRemoteCharValueVtbl;

    interface IJavaEnumRemoteCharValue
    {
        CONST_VTBL struct IJavaEnumRemoteCharValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteCharValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteCharValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteCharValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteCharValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteCharValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteCharValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteCharValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteCharValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteCharValue_GetNext(This,pjch)	\
    (This)->lpVtbl -> GetNext(This,pjch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteCharValue_GetNext_Proxy( 
    IJavaEnumRemoteCharValue __RPC_FAR * This,
    /* [out] */ JAVA_CHAR __RPC_FAR *pjch);


void __RPC_STUB IJavaEnumRemoteCharValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDoubleValue_INTERFACE_DEFINED__
#define __IEnumRemoteDoubleValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteDoubleValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteDoubleValue __RPC_FAR *LPENUMREMOTEDOUBLEVALUE;


EXTERN_C const IID IID_IEnumRemoteDoubleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteDoubleValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteDoubleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteDoubleValueVtbl;

    interface IEnumRemoteDoubleValue
    {
        CONST_VTBL struct IEnumRemoteDoubleValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDoubleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteDoubleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteDoubleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteDoubleValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteDoubleValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteDoubleValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteDoubleValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteDoubleValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteDoubleValue_Next_Proxy( 
    IEnumRemoteDoubleValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteDoubleValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteDoubleValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteDoubleValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteDoubleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteDoubleValue : public IEnumRemoteDoubleValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteDoubleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl);
        
        END_INTERFACE
    } IJavaEnumRemoteDoubleValueVtbl;

    interface IJavaEnumRemoteDoubleValue
    {
        CONST_VTBL struct IJavaEnumRemoteDoubleValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteDoubleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteDoubleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteDoubleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteDoubleValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteDoubleValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteDoubleValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteDoubleValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteDoubleValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteDoubleValue_GetNext(This,pjdbl)	\
    (This)->lpVtbl -> GetNext(This,pjdbl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteDoubleValue_GetNext_Proxy( 
    IJavaEnumRemoteDoubleValue __RPC_FAR * This,
    /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl);


void __RPC_STUB IJavaEnumRemoteDoubleValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteFloatValue_INTERFACE_DEFINED__
#define __IEnumRemoteFloatValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteFloatValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteFloatValue __RPC_FAR *LPENUMREMOTEFLOATVALUE;


EXTERN_C const IID IID_IEnumRemoteFloatValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteFloatValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteFloatValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteFloatValueVtbl;

    interface IEnumRemoteFloatValue
    {
        CONST_VTBL struct IEnumRemoteFloatValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteFloatValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteFloatValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteFloatValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteFloatValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteFloatValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteFloatValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteFloatValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteFloatValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteFloatValue_Next_Proxy( 
    IEnumRemoteFloatValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteFloatValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteFloatValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteFloatValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteFloatValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteFloatValue : public IEnumRemoteFloatValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteFloatValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt);
        
        END_INTERFACE
    } IJavaEnumRemoteFloatValueVtbl;

    interface IJavaEnumRemoteFloatValue
    {
        CONST_VTBL struct IJavaEnumRemoteFloatValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteFloatValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteFloatValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteFloatValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteFloatValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteFloatValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteFloatValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteFloatValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteFloatValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteFloatValue_GetNext(This,pjflt)	\
    (This)->lpVtbl -> GetNext(This,pjflt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteFloatValue_GetNext_Proxy( 
    IJavaEnumRemoteFloatValue __RPC_FAR * This,
    /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt);


void __RPC_STUB IJavaEnumRemoteFloatValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteIntValue_INTERFACE_DEFINED__
#define __IEnumRemoteIntValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteIntValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteIntValue __RPC_FAR *LPENUMREMOTEINTVALUE;


EXTERN_C const IID IID_IEnumRemoteIntValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteIntValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteIntValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteIntValueVtbl;

    interface IEnumRemoteIntValue
    {
        CONST_VTBL struct IEnumRemoteIntValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteIntValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteIntValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteIntValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteIntValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteIntValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteIntValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteIntValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteIntValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteIntValue_Next_Proxy( 
    IEnumRemoteIntValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteIntValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteIntValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteIntValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteIntValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteIntValue : public IEnumRemoteIntValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_INT __RPC_FAR *pjn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteIntValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ JAVA_INT __RPC_FAR *pjn);
        
        END_INTERFACE
    } IJavaEnumRemoteIntValueVtbl;

    interface IJavaEnumRemoteIntValue
    {
        CONST_VTBL struct IJavaEnumRemoteIntValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteIntValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteIntValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteIntValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteIntValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteIntValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteIntValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteIntValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteIntValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteIntValue_GetNext(This,pjn)	\
    (This)->lpVtbl -> GetNext(This,pjn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteIntValue_GetNext_Proxy( 
    IJavaEnumRemoteIntValue __RPC_FAR * This,
    /* [out] */ JAVA_INT __RPC_FAR *pjn);


void __RPC_STUB IJavaEnumRemoteIntValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteLongValue_INTERFACE_DEFINED__
#define __IEnumRemoteLongValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteLongValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteLongValue __RPC_FAR *LPENUMREMOTELONGVALUE;


EXTERN_C const IID IID_IEnumRemoteLongValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteLongValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteLongValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteLongValueVtbl;

    interface IEnumRemoteLongValue
    {
        CONST_VTBL struct IEnumRemoteLongValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteLongValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteLongValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteLongValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteLongValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteLongValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteLongValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteLongValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteLongValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteLongValue_Next_Proxy( 
    IEnumRemoteLongValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteLongValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteLongValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteLongValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteLongValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteLongValue : public IEnumRemoteLongValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_LONG __RPC_FAR *pjl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteLongValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ JAVA_LONG __RPC_FAR *pjl);
        
        END_INTERFACE
    } IJavaEnumRemoteLongValueVtbl;

    interface IJavaEnumRemoteLongValue
    {
        CONST_VTBL struct IJavaEnumRemoteLongValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteLongValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteLongValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteLongValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteLongValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteLongValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteLongValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteLongValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteLongValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteLongValue_GetNext(This,pjl)	\
    (This)->lpVtbl -> GetNext(This,pjl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteLongValue_GetNext_Proxy( 
    IJavaEnumRemoteLongValue __RPC_FAR * This,
    /* [out] */ JAVA_LONG __RPC_FAR *pjl);


void __RPC_STUB IJavaEnumRemoteLongValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteShortValue_INTERFACE_DEFINED__
#define __IEnumRemoteShortValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteShortValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteShortValue __RPC_FAR *LPENUMREMOTESHORTVALUE;


EXTERN_C const IID IID_IEnumRemoteShortValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteShortValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteShortValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteShortValueVtbl;

    interface IEnumRemoteShortValue
    {
        CONST_VTBL struct IEnumRemoteShortValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteShortValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteShortValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteShortValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteShortValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteShortValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteShortValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteShortValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteShortValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteShortValue_Next_Proxy( 
    IEnumRemoteShortValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteShortValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteShortValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteShortValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteShortValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteShortValue : public IEnumRemoteShortValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_SHORT __RPC_FAR *pjsh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteShortValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ JAVA_SHORT __RPC_FAR *pjsh);
        
        END_INTERFACE
    } IJavaEnumRemoteShortValueVtbl;

    interface IJavaEnumRemoteShortValue
    {
        CONST_VTBL struct IJavaEnumRemoteShortValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteShortValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteShortValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteShortValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteShortValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteShortValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteShortValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteShortValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteShortValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteShortValue_GetNext(This,pjsh)	\
    (This)->lpVtbl -> GetNext(This,pjsh)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteShortValue_GetNext_Proxy( 
    IJavaEnumRemoteShortValue __RPC_FAR * This,
    /* [out] */ JAVA_SHORT __RPC_FAR *pjsh);


void __RPC_STUB IJavaEnumRemoteShortValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__ */


#ifndef __IRemoteArrayObject_INTERFACE_DEFINED__
#define __IRemoteArrayObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteArrayObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteArrayObject __RPC_FAR *LPREMOTEARRAYOBJECT;


EXTERN_C const IID IID_IRemoteArrayObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteArrayObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElementObjects( 
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementValues( 
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteArrayObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElementObjects )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElementValues )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteArrayObjectVtbl;

    interface IRemoteArrayObject
    {
        CONST_VTBL struct IRemoteArrayObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteArrayObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteArrayObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteArrayObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteArrayObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteArrayObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteArrayObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteArrayObject_GetElementObjects(This,ppEnum)	\
    (This)->lpVtbl -> GetElementObjects(This,ppEnum)

#define IRemoteArrayObject_GetSize(This,pcElements)	\
    (This)->lpVtbl -> GetSize(This,pcElements)

#define IRemoteArrayObject_GetElementValues(This,ppEnum)	\
    (This)->lpVtbl -> GetElementValues(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetElementObjects_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteArrayObject_GetElementObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetSize_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcElements);


void __RPC_STUB IRemoteArrayObject_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetElementValues_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteArrayObject_GetElementValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteArrayObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteBooleanObject_INTERFACE_DEFINED__
#define __IRemoteBooleanObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteBooleanObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteBooleanObject __RPC_FAR *LPREMOTEBOOLEANOBJECT;


EXTERN_C const IID IID_IRemoteBooleanObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteBooleanObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_BOOLEAN value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteBooleanObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [in] */ JAVA_BOOLEAN value);
        
        END_INTERFACE
    } IRemoteBooleanObjectVtbl;

    interface IRemoteBooleanObject
    {
        CONST_VTBL struct IRemoteBooleanObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteBooleanObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteBooleanObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteBooleanObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteBooleanObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteBooleanObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteBooleanObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteBooleanObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteBooleanObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteBooleanObject_GetValue_Proxy( 
    IRemoteBooleanObject __RPC_FAR * This,
    /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue);


void __RPC_STUB IRemoteBooleanObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteBooleanObject_SetValue_Proxy( 
    IRemoteBooleanObject __RPC_FAR * This,
    /* [in] */ JAVA_BOOLEAN value);


void __RPC_STUB IRemoteBooleanObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteBooleanObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteByteObject_INTERFACE_DEFINED__
#define __IRemoteByteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteByteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteByteObject __RPC_FAR *LPREMOTEBYTEOBJECT;


EXTERN_C const IID IID_IRemoteByteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteByteObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_BYTE __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_BYTE value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteByteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteByteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [out] */ JAVA_BYTE __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [in] */ JAVA_BYTE value);
        
        END_INTERFACE
    } IRemoteByteObjectVtbl;

    interface IRemoteByteObject
    {
        CONST_VTBL struct IRemoteByteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteByteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteByteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteByteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteByteObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteByteObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteByteObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteByteObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteByteObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteByteObject_GetValue_Proxy( 
    IRemoteByteObject __RPC_FAR * This,
    /* [out] */ JAVA_BYTE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteByteObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteByteObject_SetValue_Proxy( 
    IRemoteByteObject __RPC_FAR * This,
    /* [in] */ JAVA_BYTE value);


void __RPC_STUB IRemoteByteObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteByteObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteCharObject_INTERFACE_DEFINED__
#define __IRemoteCharObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteCharObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteCharObject __RPC_FAR *LPREMOTECHAROBJECT;


EXTERN_C const IID IID_IRemoteCharObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteCharObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_CHAR __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_CHAR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteCharObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteCharObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [out] */ JAVA_CHAR __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [in] */ JAVA_CHAR value);
        
        END_INTERFACE
    } IRemoteCharObjectVtbl;

    interface IRemoteCharObject
    {
        CONST_VTBL struct IRemoteCharObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteCharObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteCharObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteCharObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteCharObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteCharObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteCharObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteCharObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteCharObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteCharObject_GetValue_Proxy( 
    IRemoteCharObject __RPC_FAR * This,
    /* [out] */ JAVA_CHAR __RPC_FAR *pvalue);


void __RPC_STUB IRemoteCharObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteCharObject_SetValue_Proxy( 
    IRemoteCharObject __RPC_FAR * This,
    /* [in] */ JAVA_CHAR value);


void __RPC_STUB IRemoteCharObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteCharObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteContainerObject_INTERFACE_DEFINED__
#define __IRemoteContainerObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteContainerObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteContainerObject __RPC_FAR *LPREMOTECONTAINEROBJECT;


EXTERN_C const IID IID_IRemoteContainerObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteContainerObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFieldObject( 
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteContainerObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldObject )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);
        
        END_INTERFACE
    } IRemoteContainerObjectVtbl;

    interface IRemoteContainerObject
    {
        CONST_VTBL struct IRemoteContainerObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteContainerObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteContainerObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteContainerObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteContainerObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteContainerObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteContainerObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteContainerObject_GetFieldObject(This,pField,ppFieldObject)	\
    (This)->lpVtbl -> GetFieldObject(This,pField,ppFieldObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteContainerObject_GetFieldObject_Proxy( 
    IRemoteContainerObject __RPC_FAR * This,
    /* [unique][in] */ IRemoteField __RPC_FAR *pField,
    /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);


void __RPC_STUB IRemoteContainerObject_GetFieldObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteContainerObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteClassObject_INTERFACE_DEFINED__
#define __IRemoteClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteClassObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteClassObject __RPC_FAR *LPREMOTECLASSOBJECT;


EXTERN_C const IID IID_IRemoteClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteClassObject : public IRemoteContainerObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDerivedMostType( 
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldObject )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDerivedMostType )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField);
        
        END_INTERFACE
    } IRemoteClassObjectVtbl;

    interface IRemoteClassObject
    {
        CONST_VTBL struct IRemoteClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteClassObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteClassObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteClassObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteClassObject_GetFieldObject(This,pField,ppFieldObject)	\
    (This)->lpVtbl -> GetFieldObject(This,pField,ppFieldObject)


#define IRemoteClassObject_GetDerivedMostType(This,ppDerivedMostField)	\
    (This)->lpVtbl -> GetDerivedMostType(This,ppDerivedMostField)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteClassObject_GetDerivedMostType_Proxy( 
    IRemoteClassObject __RPC_FAR * This,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField);


void __RPC_STUB IRemoteClassObject_GetDerivedMostType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteClassObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteDoubleObject_INTERFACE_DEFINED__
#define __IRemoteDoubleObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDoubleObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDoubleObject __RPC_FAR *LPREMOTEDOUBLEOBJECT;


EXTERN_C const IID IID_IRemoteDoubleObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDoubleObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDoubleObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue);
        
        END_INTERFACE
    } IRemoteDoubleObjectVtbl;

    interface IRemoteDoubleObject
    {
        CONST_VTBL struct IRemoteDoubleObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDoubleObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDoubleObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDoubleObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDoubleObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteDoubleObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteDoubleObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteDoubleObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteDoubleObject_SetValue(This,pvalue)	\
    (This)->lpVtbl -> SetValue(This,pvalue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDoubleObject_GetValue_Proxy( 
    IRemoteDoubleObject __RPC_FAR * This,
    /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteDoubleObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDoubleObject_SetValue_Proxy( 
    IRemoteDoubleObject __RPC_FAR * This,
    /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteDoubleObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDoubleObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteFloatObject_INTERFACE_DEFINED__
#define __IRemoteFloatObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteFloatObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteFloatObject __RPC_FAR *LPREMOTEFLOATOBJECT;


EXTERN_C const IID IID_IRemoteFloatObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteFloatObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteFloatObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue);
        
        END_INTERFACE
    } IRemoteFloatObjectVtbl;

    interface IRemoteFloatObject
    {
        CONST_VTBL struct IRemoteFloatObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteFloatObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteFloatObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteFloatObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteFloatObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteFloatObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteFloatObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteFloatObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteFloatObject_SetValue(This,pvalue)	\
    (This)->lpVtbl -> SetValue(This,pvalue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteFloatObject_GetValue_Proxy( 
    IRemoteFloatObject __RPC_FAR * This,
    /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteFloatObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteFloatObject_SetValue_Proxy( 
    IRemoteFloatObject __RPC_FAR * This,
    /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteFloatObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteFloatObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteIntObject_INTERFACE_DEFINED__
#define __IRemoteIntObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteIntObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteIntObject __RPC_FAR *LPREMOTEINTOBJECT;


EXTERN_C const IID IID_IRemoteIntObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteIntObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_INT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_INT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteIntObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteIntObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [out] */ JAVA_INT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [in] */ JAVA_INT value);
        
        END_INTERFACE
    } IRemoteIntObjectVtbl;

    interface IRemoteIntObject
    {
        CONST_VTBL struct IRemoteIntObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteIntObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteIntObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteIntObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteIntObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteIntObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteIntObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteIntObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteIntObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteIntObject_GetValue_Proxy( 
    IRemoteIntObject __RPC_FAR * This,
    /* [out] */ JAVA_INT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteIntObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteIntObject_SetValue_Proxy( 
    IRemoteIntObject __RPC_FAR * This,
    /* [in] */ JAVA_INT value);


void __RPC_STUB IRemoteIntObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteIntObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteLongObject_INTERFACE_DEFINED__
#define __IRemoteLongObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteLongObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteLongObject __RPC_FAR *LPREMOTELONGOBJECT;


EXTERN_C const IID IID_IRemoteLongObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteLongObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_LONG __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_LONG value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteLongObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteLongObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [out] */ JAVA_LONG __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [in] */ JAVA_LONG value);
        
        END_INTERFACE
    } IRemoteLongObjectVtbl;

    interface IRemoteLongObject
    {
        CONST_VTBL struct IRemoteLongObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteLongObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteLongObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteLongObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteLongObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteLongObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteLongObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteLongObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteLongObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteLongObject_GetValue_Proxy( 
    IRemoteLongObject __RPC_FAR * This,
    /* [out] */ JAVA_LONG __RPC_FAR *pvalue);


void __RPC_STUB IRemoteLongObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteLongObject_SetValue_Proxy( 
    IRemoteLongObject __RPC_FAR * This,
    /* [in] */ JAVA_LONG value);


void __RPC_STUB IRemoteLongObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteLongObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteShortObject_INTERFACE_DEFINED__
#define __IRemoteShortObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteShortObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteShortObject __RPC_FAR *LPREMOTESHORTOBJECT;


EXTERN_C const IID IID_IRemoteShortObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteShortObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_SHORT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_SHORT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteShortObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteShortObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [out] */ JAVA_SHORT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [in] */ JAVA_SHORT value);
        
        END_INTERFACE
    } IRemoteShortObjectVtbl;

    interface IRemoteShortObject
    {
        CONST_VTBL struct IRemoteShortObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteShortObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteShortObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteShortObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteShortObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteShortObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteShortObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteShortObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteShortObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteShortObject_GetValue_Proxy( 
    IRemoteShortObject __RPC_FAR * This,
    /* [out] */ JAVA_SHORT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteShortObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteShortObject_SetValue_Proxy( 
    IRemoteShortObject __RPC_FAR * This,
    /* [in] */ JAVA_SHORT value);


void __RPC_STUB IRemoteShortObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteShortObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteStackFrame_INTERFACE_DEFINED__
#define __IRemoteStackFrame_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteStackFrame
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteStackFrame __RPC_FAR *LPREMOTESTACKOBJECT;


enum __MIDL_IRemoteStackFrame_0001
    {	FRAME_KIND_INVALID	= 0,
	FRAME_KIND_INTERPRETED	= 0x1,
	FRAME_KIND_NATIVE	= 0x2,
	FRAME_KIND_JIT_COMPILED	= 0x3
    };
typedef ULONG FRAMEKIND;


EXTERN_C const IID IID_IRemoteStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteStackFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallingFrame( 
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodObject( 
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPC( 
            /* [out] */ ULONG __RPC_FAR *offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPC( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKind( 
            /* [out] */ FRAMEKIND __RPC_FAR *pfk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteStackFrame __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteStackFrame __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallingFrame )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodObject )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPC )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPC )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ FRAMEKIND __RPC_FAR *pfk);
        
        END_INTERFACE
    } IRemoteStackFrameVtbl;

    interface IRemoteStackFrame
    {
        CONST_VTBL struct IRemoteStackFrameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteStackFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteStackFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteStackFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteStackFrame_GetCallingFrame(This,ppCallingFrame)	\
    (This)->lpVtbl -> GetCallingFrame(This,ppCallingFrame)

#define IRemoteStackFrame_GetMethodObject(This,ppMethodObject)	\
    (This)->lpVtbl -> GetMethodObject(This,ppMethodObject)

#define IRemoteStackFrame_GetPC(This,offPC)	\
    (This)->lpVtbl -> GetPC(This,offPC)

#define IRemoteStackFrame_SetPC(This,offPC)	\
    (This)->lpVtbl -> SetPC(This,offPC)

#define IRemoteStackFrame_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetCallingFrame_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame);


void __RPC_STUB IRemoteStackFrame_GetCallingFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetMethodObject_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject);


void __RPC_STUB IRemoteStackFrame_GetMethodObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetPC_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *offPC);


void __RPC_STUB IRemoteStackFrame_GetPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_SetPC_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteStackFrame_SetPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetKind_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ FRAMEKIND __RPC_FAR *pfk);


void __RPC_STUB IRemoteStackFrame_GetKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteStackFrame_INTERFACE_DEFINED__ */


#ifndef __IRemoteThreadGroup_INTERFACE_DEFINED__
#define __IRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteThreadGroup __RPC_FAR *LPREMOTETHREADGROUP;


EXTERN_C const IID IID_IRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteThreadGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreads( 
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroups( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreads )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroups )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteThreadGroupVtbl;

    interface IRemoteThreadGroup
    {
        CONST_VTBL struct IRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteThreadGroup_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteThreadGroup_GetThreads(This,ppEnum)	\
    (This)->lpVtbl -> GetThreads(This,ppEnum)

#define IRemoteThreadGroup_GetThreadGroups(This,ppEnum)	\
    (This)->lpVtbl -> GetThreadGroups(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetName_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteThreadGroup_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetThreads_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteThreadGroup_GetThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetThreadGroups_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteThreadGroup_GetThreadGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteThreadGroup_INTERFACE_DEFINED__
#define __IEnumRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteThreadGroup __RPC_FAR *LPENUMREMOTETHREADGROUP;


EXTERN_C const IID IID_IEnumRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteThreadGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteThreadGroupVtbl;

    interface IEnumRemoteThreadGroup
    {
        CONST_VTBL struct IEnumRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteThreadGroup_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteThreadGroup_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteThreadGroup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteThreadGroup_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Next_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteThreadGroup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Skip_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteThreadGroup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Reset_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This);


void __RPC_STUB IEnumRemoteThreadGroup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Clone_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteThreadGroup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__
#define __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteThreadGroup : public IEnumRemoteThreadGroup
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg);
        
        END_INTERFACE
    } IJavaEnumRemoteThreadGroupVtbl;

    interface IJavaEnumRemoteThreadGroup
    {
        CONST_VTBL struct IJavaEnumRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteThreadGroup_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteThreadGroup_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteThreadGroup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteThreadGroup_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteThreadGroup_GetNext(This,ppirtg)	\
    (This)->lpVtbl -> GetNext(This,ppirtg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteThreadGroup_GetNext_Proxy( 
    IJavaEnumRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg);


void __RPC_STUB IJavaEnumRemoteThreadGroup_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IRemoteThread_INTERFACE_DEFINED__
#define __IRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteThread __RPC_FAR *LPREMOTETHREAD;


EXTERN_C const IID IID_IRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFrame( 
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroup( 
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Go( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepIn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeStep( 
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeStepIn( 
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuspendCount( 
            /* [out] */ ULONG __RPC_FAR *pcSuspend) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentFrame )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroup )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Go )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Step )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepIn )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepOut )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeStep )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeStepIn )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuspendCount )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcSuspend);
        
        END_INTERFACE
    } IRemoteThreadVtbl;

    interface IRemoteThread
    {
        CONST_VTBL struct IRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteThread_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteThread_GetCurrentFrame(This,ppCurrentFrame)	\
    (This)->lpVtbl -> GetCurrentFrame(This,ppCurrentFrame)

#define IRemoteThread_GetThreadGroup(This,ppThreadGroup)	\
    (This)->lpVtbl -> GetThreadGroup(This,ppThreadGroup)

#define IRemoteThread_Go(This)	\
    (This)->lpVtbl -> Go(This)

#define IRemoteThread_Step(This)	\
    (This)->lpVtbl -> Step(This)

#define IRemoteThread_StepIn(This)	\
    (This)->lpVtbl -> StepIn(This)

#define IRemoteThread_StepOut(This)	\
    (This)->lpVtbl -> StepOut(This)

#define IRemoteThread_RangeStep(This,offStart,offEnd)	\
    (This)->lpVtbl -> RangeStep(This,offStart,offEnd)

#define IRemoteThread_RangeStepIn(This,offStart,offEnd)	\
    (This)->lpVtbl -> RangeStepIn(This,offStart,offEnd)

#define IRemoteThread_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IRemoteThread_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IRemoteThread_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IRemoteThread_GetSuspendCount(This,pcSuspend)	\
    (This)->lpVtbl -> GetSuspendCount(This,pcSuspend)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteThread_GetName_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteThread_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetCurrentFrame_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame);


void __RPC_STUB IRemoteThread_GetCurrentFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetThreadGroup_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup);


void __RPC_STUB IRemoteThread_GetThreadGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Go_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Go_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Step_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_StepIn_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_StepIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_StepOut_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_StepOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_RangeStep_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG offStart,
    /* [in] */ ULONG offEnd);


void __RPC_STUB IRemoteThread_RangeStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_RangeStepIn_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG offStart,
    /* [in] */ ULONG offEnd);


void __RPC_STUB IRemoteThread_RangeStepIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Destroy_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Suspend_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Resume_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetSuspendCount_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcSuspend);


void __RPC_STUB IRemoteThread_GetSuspendCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteThread_INTERFACE_DEFINED__
#define __IEnumRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteThread __RPC_FAR *LPENUMREMOTETHREAD;


EXTERN_C const IID IID_IEnumRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteThreadVtbl;

    interface IEnumRemoteThread
    {
        CONST_VTBL struct IEnumRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteThread_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteThread_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteThread_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteThread_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Next_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteThread_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Skip_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteThread_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Reset_Proxy( 
    IEnumRemoteThread __RPC_FAR * This);


void __RPC_STUB IEnumRemoteThread_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Clone_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteThread_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteThread_INTERFACE_DEFINED__
#define __IJavaEnumRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteThread : public IEnumRemoteThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt);
        
        END_INTERFACE
    } IJavaEnumRemoteThreadVtbl;

    interface IJavaEnumRemoteThread
    {
        CONST_VTBL struct IJavaEnumRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteThread_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteThread_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteThread_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteThread_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteThread_GetNext(This,ppt)	\
    (This)->lpVtbl -> GetNext(This,ppt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteThread_GetNext_Proxy( 
    IJavaEnumRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt);


void __RPC_STUB IJavaEnumRemoteThread_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IRemoteProcessCallback_INTERFACE_DEFINED__
#define __IRemoteProcessCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteProcessCallback
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteProcessCallback __RPC_FAR *LPREMOTEPROCESSCALLBACK;


enum __MIDL_IRemoteProcessCallback_0001
    {	EXCEPTION_KIND_FIRST_CHANCE	= 0x1,
	EXCEPTION_KIND_LAST_CHANCE	= 0x2
    };
typedef ULONG EXCEPTIONKIND;


EXTERN_C const IID IID_IRemoteProcessCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteProcessCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DebugStringEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [in] */ LPCOLESTR pszDebugString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CodeBreakpointEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DataBreakpointEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteObject __RPC_FAR *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
            /* [in] */ EXCEPTIONKIND exceptionKind) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStopEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadCreateEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadGroupCreateEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadGroupDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TraceEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCompleteEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteProcessCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteProcessCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteProcessCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugStringEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [in] */ LPCOLESTR pszDebugString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodeBreakpointEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataBreakpointEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteObject __RPC_FAR *pObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExceptionEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
            /* [in] */ EXCEPTIONKIND exceptionKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanStopEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BreakEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadCreateEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadGroupCreateEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadGroupDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClassLoadEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClassUnloadEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TraceEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadCompleteEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        END_INTERFACE
    } IRemoteProcessCallbackVtbl;

    interface IRemoteProcessCallback
    {
        CONST_VTBL struct IRemoteProcessCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteProcessCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteProcessCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteProcessCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteProcessCallback_DebugStringEvent(This,pThread,pszDebugString)	\
    (This)->lpVtbl -> DebugStringEvent(This,pThread,pszDebugString)

#define IRemoteProcessCallback_CodeBreakpointEvent(This,pThread)	\
    (This)->lpVtbl -> CodeBreakpointEvent(This,pThread)

#define IRemoteProcessCallback_DataBreakpointEvent(This,pThread,pObject)	\
    (This)->lpVtbl -> DataBreakpointEvent(This,pThread,pObject)

#define IRemoteProcessCallback_ExceptionEvent(This,pThread,pExceptionClass,exceptionKind)	\
    (This)->lpVtbl -> ExceptionEvent(This,pThread,pExceptionClass,exceptionKind)

#define IRemoteProcessCallback_StepEvent(This,pThread)	\
    (This)->lpVtbl -> StepEvent(This,pThread)

#define IRemoteProcessCallback_CanStopEvent(This,pThread)	\
    (This)->lpVtbl -> CanStopEvent(This,pThread)

#define IRemoteProcessCallback_BreakEvent(This,pThread)	\
    (This)->lpVtbl -> BreakEvent(This,pThread)

#define IRemoteProcessCallback_ThreadCreateEvent(This,pThread)	\
    (This)->lpVtbl -> ThreadCreateEvent(This,pThread)

#define IRemoteProcessCallback_ThreadDestroyEvent(This,pThread)	\
    (This)->lpVtbl -> ThreadDestroyEvent(This,pThread)

#define IRemoteProcessCallback_ThreadGroupCreateEvent(This,pThread,pThreadGroup)	\
    (This)->lpVtbl -> ThreadGroupCreateEvent(This,pThread,pThreadGroup)

#define IRemoteProcessCallback_ThreadGroupDestroyEvent(This,pThread,pThreadGroup)	\
    (This)->lpVtbl -> ThreadGroupDestroyEvent(This,pThread,pThreadGroup)

#define IRemoteProcessCallback_ClassLoadEvent(This,pThread,pClassType)	\
    (This)->lpVtbl -> ClassLoadEvent(This,pThread,pClassType)

#define IRemoteProcessCallback_ClassUnloadEvent(This,pThread,pClassType)	\
    (This)->lpVtbl -> ClassUnloadEvent(This,pThread,pClassType)

#define IRemoteProcessCallback_ProcessDestroyEvent(This,pThread)	\
    (This)->lpVtbl -> ProcessDestroyEvent(This,pThread)

#define IRemoteProcessCallback_TraceEvent(This,pThread)	\
    (This)->lpVtbl -> TraceEvent(This,pThread)

#define IRemoteProcessCallback_LoadCompleteEvent(This,pThread)	\
    (This)->lpVtbl -> LoadCompleteEvent(This,pThread)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_DebugStringEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [in] */ LPCOLESTR pszDebugString);


void __RPC_STUB IRemoteProcessCallback_DebugStringEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_CodeBreakpointEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_CodeBreakpointEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_DataBreakpointEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteObject __RPC_FAR *pObject);


void __RPC_STUB IRemoteProcessCallback_DataBreakpointEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ExceptionEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
    /* [in] */ EXCEPTIONKIND exceptionKind);


void __RPC_STUB IRemoteProcessCallback_ExceptionEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_StepEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_StepEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_CanStopEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_CanStopEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_BreakEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_BreakEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadCreateEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ThreadCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ThreadDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadGroupCreateEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);


void __RPC_STUB IRemoteProcessCallback_ThreadGroupCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadGroupDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);


void __RPC_STUB IRemoteProcessCallback_ThreadGroupDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ClassLoadEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);


void __RPC_STUB IRemoteProcessCallback_ClassLoadEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ClassUnloadEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);


void __RPC_STUB IRemoteProcessCallback_ClassUnloadEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ProcessDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ProcessDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_TraceEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_TraceEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_LoadCompleteEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_LoadCompleteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteProcessCallback_INTERFACE_DEFINED__ */


#ifndef __IRemoteProcess_INTERFACE_DEFINED__
#define __IRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteProcess __RPC_FAR *LPREMOTEPROCESS;


EXTERN_C const IID IID_IRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalContainerObject( 
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClass( 
            /* [in] */ LPCOLESTR pszClassName,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TraceMethods( 
            /* [in] */ BOOL bTraceOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroups( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCallback )( 
            IRemoteProcess __RPC_FAR * This,
            /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Break )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGlobalContainerObject )( 
            IRemoteProcess __RPC_FAR * This,
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindClass )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszClassName,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TraceMethods )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ BOOL bTraceOn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroups )( 
            IRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteProcessVtbl;

    interface IRemoteProcess
    {
        CONST_VTBL struct IRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteProcess_RegisterCallback(This,pCallback)	\
    (This)->lpVtbl -> RegisterCallback(This,pCallback)

#define IRemoteProcess_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IRemoteProcess_Break(This)	\
    (This)->lpVtbl -> Break(This)

#define IRemoteProcess_GetGlobalContainerObject(This,ppGlobalContainerObject)	\
    (This)->lpVtbl -> GetGlobalContainerObject(This,ppGlobalContainerObject)

#define IRemoteProcess_FindClass(This,pszClassName,ppClassType)	\
    (This)->lpVtbl -> FindClass(This,pszClassName,ppClassType)

#define IRemoteProcess_TraceMethods(This,bTraceOn)	\
    (This)->lpVtbl -> TraceMethods(This,bTraceOn)

#define IRemoteProcess_GetThreadGroups(This,ppEnum)	\
    (This)->lpVtbl -> GetThreadGroups(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteProcess_RegisterCallback_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback);


void __RPC_STUB IRemoteProcess_RegisterCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_Detach_Proxy( 
    IRemoteProcess __RPC_FAR * This);


void __RPC_STUB IRemoteProcess_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_Break_Proxy( 
    IRemoteProcess __RPC_FAR * This);


void __RPC_STUB IRemoteProcess_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_GetGlobalContainerObject_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject);


void __RPC_STUB IRemoteProcess_GetGlobalContainerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_FindClass_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszClassName,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType);


void __RPC_STUB IRemoteProcess_FindClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_TraceMethods_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [in] */ BOOL bTraceOn);


void __RPC_STUB IRemoteProcess_TraceMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_GetThreadGroups_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteProcess_GetThreadGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteProcess_INTERFACE_DEFINED__
#define __IEnumRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteProcess __RPC_FAR *LPENUMREMOTEPROCESS;


EXTERN_C const IID IID_IEnumRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteProcessVtbl;

    interface IEnumRemoteProcess
    {
        CONST_VTBL struct IEnumRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteProcess_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteProcess_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteProcess_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteProcess_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Next_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteProcess_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Skip_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteProcess_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Reset_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This);


void __RPC_STUB IEnumRemoteProcess_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Clone_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteProcess_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteProcess_INTERFACE_DEFINED__
#define __IJavaEnumRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteProcess : public IEnumRemoteProcess
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp);
        
        END_INTERFACE
    } IJavaEnumRemoteProcessVtbl;

    interface IJavaEnumRemoteProcess
    {
        CONST_VTBL struct IJavaEnumRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteProcess_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteProcess_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteProcess_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteProcess_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteProcess_GetNext(This,ppirp)	\
    (This)->lpVtbl -> GetNext(This,ppirp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteProcess_GetNext_Proxy( 
    IJavaEnumRemoteProcess __RPC_FAR * This,
    /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp);


void __RPC_STUB IJavaEnumRemoteProcess_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugManagerCallback_INTERFACE_DEFINED__
#define __IRemoteDebugManagerCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDebugManagerCallback
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDebugManagerCallback __RPC_FAR *LPREMOTEDEBUGMANAGERCALLBACK;


EXTERN_C const IID IID_IRemoteDebugManagerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDebugManagerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessCreateEvent( 
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugManagerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugManagerCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugManagerCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugManagerCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessCreateEvent )( 
            IRemoteDebugManagerCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent);
        
        END_INTERFACE
    } IRemoteDebugManagerCallbackVtbl;

    interface IRemoteDebugManagerCallback
    {
        CONST_VTBL struct IRemoteDebugManagerCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugManagerCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugManagerCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugManagerCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugManagerCallback_ProcessCreateEvent(This,pProcessNew,pProcessParent)	\
    (This)->lpVtbl -> ProcessCreateEvent(This,pProcessNew,pProcessParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugManagerCallback_ProcessCreateEvent_Proxy( 
    IRemoteDebugManagerCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
    /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent);


void __RPC_STUB IRemoteDebugManagerCallback_ProcessCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDebugManagerCallback_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugManager_INTERFACE_DEFINED__
#define __IRemoteDebugManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDebugManager
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDebugManager __RPC_FAR *LPREMOTEDEBUGMANAGER;


EXTERN_C const IID IID_IRemoteDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveProcesses( 
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCreateEvent( 
            /* [in] */ LPCOLESTR pszProcessName,
            /* [in] */ DWORD dwParentProcessId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCallback )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveProcesses )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestCreateEvent )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszProcessName,
            /* [in] */ DWORD dwParentProcessId);
        
        END_INTERFACE
    } IRemoteDebugManagerVtbl;

    interface IRemoteDebugManager
    {
        CONST_VTBL struct IRemoteDebugManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugManager_RegisterCallback(This,pCallback)	\
    (This)->lpVtbl -> RegisterCallback(This,pCallback)

#define IRemoteDebugManager_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IRemoteDebugManager_GetActiveProcesses(This,ppEnum)	\
    (This)->lpVtbl -> GetActiveProcesses(This,ppEnum)

#define IRemoteDebugManager_RequestCreateEvent(This,pszProcessName,dwParentProcessId)	\
    (This)->lpVtbl -> RequestCreateEvent(This,pszProcessName,dwParentProcessId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugManager_RegisterCallback_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback);


void __RPC_STUB IRemoteDebugManager_RegisterCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_Detach_Proxy( 
    IRemoteDebugManager __RPC_FAR * This);


void __RPC_STUB IRemoteDebugManager_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_GetActiveProcesses_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteDebugManager_GetActiveProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_RequestCreateEvent_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszProcessName,
    /* [in] */ DWORD dwParentProcessId);


void __RPC_STUB IRemoteDebugManager_RequestCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDebugManager_INTERFACE_DEFINED__ */


#ifndef __IJavaDebugManager_INTERFACE_DEFINED__
#define __IJavaDebugManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaDebugManager
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterRemoteDebugManager( 
            /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
            /* [in] */ DWORD dwProcessID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaDebugManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaDebugManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterRemoteDebugManager )( 
            IJavaDebugManager __RPC_FAR * This,
            /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
            /* [in] */ DWORD dwProcessID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IJavaDebugManager __RPC_FAR * This);
        
        END_INTERFACE
    } IJavaDebugManagerVtbl;

    interface IJavaDebugManager
    {
        CONST_VTBL struct IJavaDebugManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaDebugManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaDebugManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaDebugManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaDebugManager_RegisterRemoteDebugManager(This,pirdm,dwProcessID)	\
    (This)->lpVtbl -> RegisterRemoteDebugManager(This,pirdm,dwProcessID)

#define IJavaDebugManager_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaDebugManager_RegisterRemoteDebugManager_Proxy( 
    IJavaDebugManager __RPC_FAR * This,
    /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
    /* [in] */ DWORD dwProcessID);


void __RPC_STUB IJavaDebugManager_RegisterRemoteDebugManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaDebugManager_Detach_Proxy( 
    IJavaDebugManager __RPC_FAR * This);


void __RPC_STUB IJavaDebugManager_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaDebugManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\icecap\prologue.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
	call	_penter
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java15\include\jdbgguid.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   jdbgguid.hpp

Abstract:

   Java debug manager GUID definitions.

--*/


/* GUIDs
 ********/

DEFINE_GUID(CLSID_RemoteJavaDebugManager,	0x275d9d50, 0x5ff5, 0x11cf, 0xa5, 0xe1, 0x00, 0xaa, 0x00, 0x6b, 0xbf, 0x16);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java15\include\nativcom.h ===
// (C) Copyright 1996, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for COM-marshaling facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVCOM_
#define _NATIVCOM_


#include <windows.h>
#include <native.h>


#ifdef __cplusplus
extern "C" {
#endif


//----------------------------------------------------------------------------
// COM data wrapper helpers...
//----------------------------------------------------------------------------
void* __cdecl jcdwNewData(Hjava_lang_Object * phJCDW, unsigned int numBytes);
void* __cdecl jcdwGetData(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwSizeOf(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwClassSizeOf(Hjava_lang_Object * phJavaClass);
unsigned int __cdecl jcdwOffsetOf(Hjava_lang_Object * phJCDW, const char *pFieldName);
unsigned int __cdecl jcdwClassOffsetOf(Hjava_lang_Object * phJCDWClass, const char *pFieldName);
Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object(IUnknown *punk,
                                                            Hjava_lang_Object *phJavaClass,
                                                            int       fAssumeThreadSafe);
IUnknown * __cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID);

Hjava_lang_Object * __cdecl convert_ptr_to_jcdw(void              *pExtData,
                                                Hjava_lang_Object *phJavaClass
                                                );

int __cdecl jcdw_memory_freed_on_gc(Hjava_lang_Object *phJCDW);


int   __cdecl jcdwSetData(Hjava_lang_Object * phJCDW, LPVOID pv);
int   __cdecl jcdw_java_owned(Hjava_lang_Object *phJCDW);


    

#ifdef __cplusplus
}
#endif



#endif _NATIVCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java15\include\native.h ===
// (C) Copyright 1996, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVE_
#define _NATIVE_

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// Since handles have gone away, this is no op. The unhands() in this file
// a redundant but useful for clarity.
// Note: You can not just unhand an array to get at it's data, you must now 
// use unhand(x)->body.
//----------------------------------------------------------------------------
#define unhand(phobj) (phobj)

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define JAVAPKG	"java/lang/"

//----------------------------------------------------------------------------
// Standard Java declarations for built in types.
//----------------------------------------------------------------------------
typedef long OBJECT;
typedef OBJECT Classjava_lang_Object;
typedef OBJECT Hjava_lang_Object;
typedef OBJECT ClassObject;
typedef Hjava_lang_Object JHandle;
typedef Hjava_lang_Object HObject;

typedef unsigned short unicode;
typedef long int32_t;
typedef __int64 int64_t;
typedef int BOOL;
typedef void *PVOID;    
typedef unsigned long DWORD;
#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif
#ifndef VOID
#define VOID void
#endif
#ifndef _BOOL_T_DEFINED
#define _BOOL_T_DEFINED
typedef BOOL bool_t;
#endif

//----------------------------------------------------------------------------
// Use to get the length of an array an HObject.
//----------------------------------------------------------------------------
#define obj_length(hobj) (((ArrayOfSomething*)unhand(hobj))->length)

//----------------------------------------------------------------------------
// Garbage Collection.
//----------------------------------------------------------------------------
typedef struct {
	DWORD	reserved[6];
} GCFrame;

void    __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, 
                DWORD cbObjectStructSize);
void    __cdecl GCFramePop(PVOID pGCFrame);

// 'Weak' ptrs
HObject** __cdecl GCGetPtr(HObject *phobj);
void    __cdecl GCFreePtr(HObject **pphobj);

#define GCGetWeakPtr    GCGetPtr
#define GCFreeWeakPtr   GCFreePtr

// 'Strong' ptrs
HObject** __cdecl GCNewHandle(HObject *phobj);
void __cdecl GCFreeHandle(HObject **pphobj);

int     __cdecl GCEnable();
int     __cdecl GCDisable();
int     __cdecl GCDisableCount();
int     __cdecl GCEnableCompletely();
void    __cdecl GCDisableMultiple(int cDisable);

//----------------------------------------------------------------------------
// "Built-in" object structures...
// These include helper macro's to get at array data.
//----------------------------------------------------------------------------

#pragma pack(push,4)
typedef struct Classjava_lang_String {
    int32_t MSReserved;
    struct ClassArrayOfChar *value;
    long offset;
    long count;
} Classjava_lang_String;
#define Hjava_lang_String Classjava_lang_String
typedef Hjava_lang_String HString;

typedef struct ClassArrayOfByte
{
    int32_t MSReserved;
    unsigned long length;
    char body[1];
} ClassArrayOfByte;
#define HArrayOfByte ClassArrayOfByte
#define ArrayOfByte ClassArrayOfByte

typedef struct ClassArrayOfChar
{
    int32_t MSReserved;
    unsigned long length;
    unsigned short body[1];
} ClassArrayOfChar;
#define HArrayOfChar ClassArrayOfChar
#define ArrayOfChar ClassArrayOfChar

typedef struct ClassArrayOfShort
{
    int32_t MSReserved;
    unsigned long length;
    short body[1];
} ClassArrayOfShort;
#define HArrayOfShort ClassArrayOfShort
#define ArrayOfShort ClassArrayOfShort

typedef struct ClassArrayOfInt
{
    int32_t MSReserved;
    unsigned long length;
    long body[1];
} ClassArrayOfInt;
#define HArrayOfInt ClassArrayOfInt
#define ArrayOfInt ClassArrayOfInt

typedef struct ClassArrayOfLong
{
    int32_t MSReserved;
    unsigned long length;
    __int64 body[1];
} ClassArrayOfLong;
#define HArrayOfLong ClassArrayOfLong
#define ArrayOfLong ClassArrayOfLong

typedef struct ClassArrayOfFloat
{
    int32_t MSReserved;
    unsigned long length;
    float body[1];
} ClassArrayOfFloat;
#define HArrayOfFloat ClassArrayOfFloat
#define ArrayOfFloat ClassArrayOfFloat

typedef struct ClassArrayOfDouble
{
    int32_t MSReserved;
    unsigned long length;
    double body[1];
} ClassArrayOfDouble;
#define HArrayOfDouble ClassArrayOfDouble
#define ArrayOfDouble ClassArrayOfDouble

typedef struct ClassArrayOfObject
{
    int32_t MSReserved;
    unsigned long length;
    HObject *body[1];
} ClassArrayOfObject;
#define HArrayOfObject ClassArrayOfObject
#define ArrayOfObject ClassArrayOfObject

typedef struct ClassArrayOfString
{
    int32_t MSReserved;
    unsigned long length;
    HString  *(body[1]);
} ClassArrayOfString;
#define HArrayOfString ClassArrayOfString
#define ArrayOfString ClassArrayOfString

typedef struct ClassArrayOfArray
{
    int32_t MSReserved;
    unsigned long length;
    JHandle *(body[1]);
} ClassArrayOfArray;
#define HArrayOfArray ClassArrayOfArray
#define ArrayOfArray ClassArrayOfArray

typedef struct
{
    int32_t MSReserved;
    unsigned long length;
} ArrayOfSomething;
#pragma pack(pop)

//----------------------------------------------------------------------------
// We automatically track the execution environment so there's no EE() call
// needed anymore, just pass NULL if an API needs one.
//----------------------------------------------------------------------------
#define EE() NULL
typedef void ExecEnv;

//----------------------------------------------------------------------------
// Exception handling stuff...
//----------------------------------------------------------------------------
void __cdecl SignalError(struct execenv *ee, char *ename, char *DetailMessage);
void __cdecl SignalErrorPrintf( char *ename, char *pszFormat, ...);

bool_t __cdecl exceptionOccurred(ExecEnv *ee);
void __cdecl exceptionDescribe(ExecEnv *ee);
void __cdecl exceptionClear(ExecEnv *ee);


//----------------------------------------------------------------------------
// Standard exec functions...
//----------------------------------------------------------------------------
typedef PVOID ClassClass;

HObject* __cdecl execute_java_constructor(ExecEnv *ee, char *classname, 
        ClassClass *cb, char *signature, ...);
        
long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, char 
        *method_name, char *signature, ...);

        
//----------------------------------------------------------------------------
// NB The resolve flag is ignored, classes found with this api will always
// be resolved.
//----------------------------------------------------------------------------
ClassClass* __cdecl FindClass(ExecEnv *ee, char *classname, bool_t resolve);

long __cdecl execute_java_static_method(ExecEnv *ee, ClassClass *cb, 
        char *method_name, char *signature, ...);

//----------------------------------------------------------------------------
// Helper function that returns a methodblock.
//----------------------------------------------------------------------------
struct methodblock* __cdecl get_methodblock(HObject *pjobj, char *method_name, 
        char *signature);

//----------------------------------------------------------------------------
// If you pass in a methodblock from get_methodblock the method name and
// sig are ignored and so it's faster than a regular execute.
//----------------------------------------------------------------------------
long __cdecl do_execute_java_method(ExecEnv *ee, void *obj, char *method_name, 
        char *signature, struct methodblock *mb, bool_t isStaticCall, ...);

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
BOOL __cdecl isInstanceOf(JHandle *phobj, char *classname);

//----------------------------------------------------------------------------
#define T_TMASK	034
#define T_LMASK 003
#define T_MKTYPE( t, l )  ( ( (t)&T_TMASK ) | ( (l)&T_LMASK) )

#define T_CLASS		2
#define T_FLOATING	4	
#define T_CHAR		5
#define T_INTEGER	010
#define T_BOOLEAN	4

#define T_FLOAT     T_MKTYPE(T_FLOATING,2)
#define T_DOUBLE    T_MKTYPE(T_FLOATING,3)
#define T_BYTE	    T_MKTYPE(T_INTEGER,0)
#define T_SHORT	    T_MKTYPE(T_INTEGER,1)
#define T_INT	    T_MKTYPE(T_INTEGER,2)
#define T_LONG	    T_MKTYPE(T_INTEGER,3)

//----------------------------------------------------------------------------
// Create an array of primitive types only (int, long etc).
//----------------------------------------------------------------------------
HObject* __cdecl ArrayAlloc(int type, int cItems);

//----------------------------------------------------------------------------
// Create an array of objects.
//----------------------------------------------------------------------------
HObject* __cdecl ClassArrayAlloc(int type, int cItems, char *szSig);

//----------------------------------------------------------------------------
// Copy an array ala System.arrayCopy()
//----------------------------------------------------------------------------
void __cdecl ArrayCopy(HObject *srch, long src_pos, HObject *dsth, 
        long dst_pos, long length);

//----------------------------------------------------------------------------
// Create and return a new array of bytes initialized from the C string.
//----------------------------------------------------------------------------
HArrayOfByte* __cdecl MakeByteString(char *str, long len);

//----------------------------------------------------------------------------
// Create and return a new Java String object, initialized from the C string.
//----------------------------------------------------------------------------
Hjava_lang_String* __cdecl makeJavaString(char *str, int len);
Hjava_lang_String* __cdecl makeJavaStringW( unicode *pszwSrc, int cch );

//----------------------------------------------------------------------------
// Get the characters of the String object into a C string buffer.
// No allocation occurs. Assumes that len is the size of the buffer.
// The C string's address is returned.
//----------------------------------------------------------------------------
char* __cdecl javaString2CString(Hjava_lang_String *s, char *buf, int buflen);

//----------------------------------------------------------------------------
// Return the length of the String object.
//----------------------------------------------------------------------------
int __cdecl javaStringLength(Hjava_lang_String *s);

//----------------------------------------------------------------------------
// Note: The int passed to these API's must be an object ptr.
//----------------------------------------------------------------------------
#define obj_monitor(handlep) ((int) handlep)
void __cdecl monitorEnter(unsigned int);
void __cdecl monitorExit(unsigned int);
void __cdecl monitorNotify(unsigned int);
void __cdecl monitorNotifyAll(unsigned int);

#define ObjectMonitorEnter(obj)         monitorEnter((int)obj)
#define ObjectMonitorExit(obj)          monitorExit((int)obj)
#define ObjectMonitorNotify(obj)        monitorNotify((int)obj)
#define ObjectMonitorNotifyAll(obj)     monitorNotifyAll((int)obj)

//----------------------------------------------------------------------------
// String helpers...
//----------------------------------------------------------------------------
int __cdecl jio_snprintf(char *str, size_t count, const char *fmt, ...);
int __cdecl jio_vsnprintf(char *str, size_t count, const char *fmt, va_list 
        args);

// Member attributes, as appear in Java class file.
#define ACC_PUBLIC      0x0001       
#define ACC_PRIVATE     0x0002       
#define ACC_PROTECTED   0x0004       
#define ACC_STATIC      0x0008       
#define ACC_FINAL       0x0010       
#define ACC_SYNCH       0x0020       
#define ACC_SUPER       0x0020       
#define ACC_THREADSAFE  0x0040       
#define ACC_VOLATILE    0x0040        
#define ACC_TRANSIENT   0x0080        
#define ACC_NATIVE      0x0100        
#define ACC_INTERFACE   0x0200        
#define ACC_ABSTRACT    0x0400        

//----------------------------------------------------------------------------
// Class information
//----------------------------------------------------------------------------

// Total number of fields in the class, including supers
unsigned __cdecl            Class_GetFieldCount(ClassClass *cls);
struct fieldblock * __cdecl Class_GetField(ClassClass *cls, const char *name);
struct fieldblock * __cdecl Class_GetFieldByIndex(ClassClass *cls, unsigned index);
// Total number of methods, including supers.
unsigned __cdecl            Class_GetMethodCount(ClassClass *cls);
struct methodblock* __cdecl Class_GetMethod(ClassClass *cls, const char *name, const char *signature);
struct methodblock* __cdecl Class_GetMethodByIndex(ClassClass *cls, unsigned index);
ClassClass * __cdecl        Class_GetSuper(ClassClass *cls);
const char * __cdecl        Class_GetName(ClassClass *cls);
unsigned __cdecl            Class_GetInterfaceCount(ClassClass *cls);
ClassClass * __cdecl        Class_GetInterface(ClassClass *cls, unsigned index);
// Returns combination of ACC_* constants.
int __cdecl                 Class_GetAttributes(ClassClass *cls);

//----------------------------------------------------------------------------
// Field/method information
//----------------------------------------------------------------------------

const char * __cdecl        Member_GetName(PVOID member);
const char * __cdecl        Member_GetSignature(PVOID member);
// class of the field/method is implemented in.
ClassClass * __cdecl        Member_GetClass(PVOID member);
// Returns combination of ACC_* constants.
int __cdecl                 Member_GetAttributes(PVOID member);

// For non-static fields, Offset of field in object.  See also Field_Get/SetValue.
unsigned __cdecl            Field_GetOffset(struct fieldblock * field);
// Ptr to static value
PVOID __cdecl               Field_GetStaticPtr(struct fieldblock * field);


//----------------------------------------------------------------------------
// Object accessors
//----------------------------------------------------------------------------
ClassClass * __cdecl        Object_GetClass(HObject *obj);

__int32 __cdecl             Field_GetValue(HObject *obj, struct fieldblock * field);
__int64 __cdecl             Field_GetValue64(HObject *obj, struct fieldblock * field);
float __cdecl               Field_GetFloat(HObject *obj, struct fieldblock * field);
double __cdecl              Field_GetDouble(HObject *obj, struct fieldblock * field);
void __cdecl                Field_SetValue(HObject *obj, struct fieldblock * field, __int32 value);
void __cdecl                Field_SetValue64(HObject *obj, struct fieldblock * field, __int64 value);
void __cdecl                Field_SetFloat(HObject *obj, struct fieldblock * field, float value);
void __cdecl                Field_SetDouble(HObject *obj, struct fieldblock * field, double value);

#define Field_GetBoolean(obj,field)     ((bool_t)       Field_GetValue(obj,field))
#define Field_GetByte(obj,field)        ((signed char)  Field_GetValue(obj,field))
#define Field_GetChar(obj,field)        ((unicode)      Field_GetValue(obj,field))
#define Field_GetShort(obj,field)       ((short)        Field_GetValue(obj,field))
#define Field_GetInt(obj,field)                         Field_GetValue(obj,field)
#define Field_GetLong(obj,field)                        Field_GetValue64(obj,field)
#define Field_GetObject(obj,field)      ((HObject*)     Field_GetValue(obj,field))
#define Field_GetFloat(obj,field)                       Field_GetFloat(obj,field)
#define Field_GetDouble(obj,field)                      Field_GetDouble(obj,field)

#define Field_SetBoolean(obj,field,value)               Field_SetValue(obj,field,(bool_t)(value))
#define Field_SetByte(obj,field,value)                  Field_SetValue(obj,field,(signed char)(value))
#define Field_SetChar(obj,field,value)                  Field_SetValue(obj,field,(unicode)(value))
#define Field_SetShort(obj,field,value)                 Field_SetValue(obj,field,(short)(value))
#define Field_SetInt(obj,field,value)                   Field_SetValue(obj,field,value)
#define Field_SetLong(obj,field,value)                  Field_SetValue64(obj,field,value)
#define Field_SetObject(obj,field,value)                Field_SetValue(obj,field,(__int32)(value))
#define Field_SetFloat(obj,field,value)                 Field_SetFloat(obj,field,value)
#define Field_SetDouble(obj,field,value)                Field_SetDouble(obj,field,value)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java15\include\javaexec.h ===
// (C) Copyright 1996, Microsoft Corporation.

//----------------------------------------------------------------------------
// Public header for invocation facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef __javaexec_h__
#define __javaexec_h__

#ifdef __cplusplus
interface IEnumJAVAPROPERTY;
interface IJavaExecute;
interface IJavaExecute2;
#else
typedef interface IEnumJAVAPROPERTY IEnumJAVAPROPERTY;
typedef interface IJavaExecute IJavaExecute;
typedef interface IJavaExecute2 IJavaExecute2;
#endif

typedef IEnumJAVAPROPERTY *LPENUMJAVAPROPERTY;
typedef IJavaExecute *LPJAVAEXECUTE;
typedef IJavaExecute2 *LPJAVAEXECUTE2;


typedef struct {
    LPOLESTR pszKey;
    LPOLESTR pszValue;
}   JAVAPROPERTY, * LPJAVAPROPERTY;


// IJavaExecute2::SetClassSource Type Flags

#define CLASS_SOURCE_TYPE_MODULERESOURCES  0x00000001 
#define CLASS_SOURCE_TYPE_ISTORAGE         0x00000002

// Data structure to be passed to IJavaExecute2::SetClassSource 
// when using the CLASS_SOURCE_TYPE_MODULERESOURCES source type.

typedef struct {
    HMODULE hModule;
    DWORD   dwResourceID;
} JAVACLASSRESOURCEINFO, * LPJAVACLASSRESOURCEINFO;

#undef  INTERFACE
#define INTERFACE IEnumJAVAPROPERTY

DECLARE_INTERFACE_(IEnumJAVAPROPERTY, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IEnumJAVAPROPERTY methods */
    STDMETHOD(Next)(THIS_ ULONG celt, LPJAVAPROPERTY rgelt, ULONG
        *pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ LPENUMJAVAPROPERTY *ppenum) PURE;
};


typedef struct tagJAVAEXECUTEINFO {
    DWORD cbSize;
    DWORD dwFlags;
    LPCOLESTR pszClassName;
    LPCOLESTR *rgszArgs;
    ULONG cArgs;
    LPCOLESTR pszClassPath;
}   JAVAEXECUTEINFO, * LPJAVAEXECUTEINFO;

#define JEIF_VERIFYCLASSES            0x00000002

#define JEIF_ALL_FLAGS                  (                               \
                                         JEIF_VERIFYCLASSES             \
                                        )

#undef  INTERFACE
#define INTERFACE IJavaExecute

DECLARE_INTERFACE_(IJavaExecute, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IJavaExecute methods */
    STDMETHOD(GetDefaultClassPath)(THIS_ LPOLESTR *ppszClassPath) PURE;
    STDMETHOD(Execute)(THIS_ LPJAVAEXECUTEINFO pjei, LPERRORINFO *pperrorinfo) PURE;
};

#undef  INTERFACE
#define INTERFACE IJavaExecute2

DECLARE_INTERFACE_(IJavaExecute2, IJavaExecute)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IJavaExecute methods */
    STDMETHOD(GetDefaultClassPath)(THIS_ LPOLESTR *ppszClassPath) PURE;
    STDMETHOD(Execute)(THIS_ LPJAVAEXECUTEINFO pjei, LPERRORINFO *pperrorinfo) PURE;
    /* IJavaExecute2 methods */
    STDMETHOD(SetSystemProperties)(THIS_ LPENUMJAVAPROPERTY penumProperties) PURE;
    STDMETHOD(SetClassSource)(THIS_ DWORD dwType, LPVOID pData, DWORD dwLen) PURE;
};

// {3EFB1800-C2A1-11cf-960C-0080C7C2BA87}
DEFINE_GUID(CLSID_JavaExecute,
0x3efb1800, 0xc2a1, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0xc2, 0xba, 0x87);
// {3EFB1803-C2A1-11cf-960C-0080C7C2BA87}
DEFINE_GUID(IID_IJavaExecute,
0x3efb1803, 0xc2a1, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0xc2, 0xba, 0x87);
// {D7658820-01DD-11d0-9746-00AA00342BD8}
DEFINE_GUID(IID_IJavaExecute2,
0xd7658820, 0x1dd, 0x11d0, 0x97, 0x46, 0x0, 0xaa, 0x0, 0x34, 0x2b, 0xd8);
// {56E7DF80-F527-11cf-B728-FC8703C10000}
DEFINE_GUID(IID_IEnumJAVAPROPERTY,
0x56e7df80, 0xf527, 0x11cf, 0xb7, 0x28, 0xfc, 0x87, 0x3, 0xc1, 0x0, 0x0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java20\include\jdbgguid.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   jdbgguid.hpp

Abstract:

   Java debug manager GUID definitions.

--*/


/* GUIDs
 ********/

DEFINE_GUID(CLSID_RemoteJavaDebugManager,	0x275d9d50, 0x5ff5, 0x11cf, 0xa5, 0xe1, 0x00, 0xaa, 0x00, 0x6b, 0xbf, 0x16);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java20\include\javaexec.h ===
// (C) Copyright 1996, Microsoft Corporation.

//----------------------------------------------------------------------------
// Public header for invocation facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef __javaexec_h__
#define __javaexec_h__

#ifdef __cplusplus
interface IEnumJAVAPROPERTY;
interface IJavaExecute;
interface IJavaExecute2;
#else
typedef interface IEnumJAVAPROPERTY IEnumJAVAPROPERTY;
typedef interface IJavaExecute IJavaExecute;
typedef interface IJavaExecute2 IJavaExecute2;
#endif

typedef IEnumJAVAPROPERTY *LPENUMJAVAPROPERTY;
typedef IJavaExecute *LPJAVAEXECUTE;
typedef IJavaExecute2 *LPJAVAEXECUTE2;


typedef struct {
    LPOLESTR pszKey;
    LPOLESTR pszValue;
}   JAVAPROPERTY, * LPJAVAPROPERTY;


// IJavaExecute2::SetClassSource Type Flags

#define CLASS_SOURCE_TYPE_MODULERESOURCES  0x00000001 
#define CLASS_SOURCE_TYPE_ISTORAGE         0x00000002

// Data structure to be passed to IJavaExecute2::SetClassSource 
// when using the CLASS_SOURCE_TYPE_MODULERESOURCES source type.

typedef struct {
    HMODULE hModule;
    DWORD   dwResourceID;
} JAVACLASSRESOURCEINFO, * LPJAVACLASSRESOURCEINFO;

#undef  INTERFACE
#define INTERFACE IEnumJAVAPROPERTY

DECLARE_INTERFACE_(IEnumJAVAPROPERTY, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IEnumJAVAPROPERTY methods */
    STDMETHOD(Next)(THIS_ ULONG celt, LPJAVAPROPERTY rgelt, ULONG
        *pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ LPENUMJAVAPROPERTY *ppenum) PURE;
};


typedef struct tagJAVAEXECUTEINFO {
    DWORD cbSize;
    DWORD dwFlags;
    LPCOLESTR pszClassName;
    LPCOLESTR *rgszArgs;
    ULONG cArgs;
    LPCOLESTR pszClassPath;
}   JAVAEXECUTEINFO, * LPJAVAEXECUTEINFO;

#define JEIF_VERIFYCLASSES            0x00000002

#define JEIF_ALL_FLAGS                  (                               \
                                         JEIF_VERIFYCLASSES             \
                                        )

#undef  INTERFACE
#define INTERFACE IJavaExecute

DECLARE_INTERFACE_(IJavaExecute, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IJavaExecute methods */
    STDMETHOD(GetDefaultClassPath)(THIS_ LPOLESTR *ppszClassPath) PURE;
    STDMETHOD(Execute)(THIS_ LPJAVAEXECUTEINFO pjei, LPERRORINFO *pperrorinfo) PURE;
};

#undef  INTERFACE
#define INTERFACE IJavaExecute2

DECLARE_INTERFACE_(IJavaExecute2, IJavaExecute)
{
#ifndef NO_BASEINTERFACE_FUNCS
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif
    /* IJavaExecute methods */
    STDMETHOD(GetDefaultClassPath)(THIS_ LPOLESTR *ppszClassPath) PURE;
    STDMETHOD(Execute)(THIS_ LPJAVAEXECUTEINFO pjei, LPERRORINFO *pperrorinfo) PURE;
    /* IJavaExecute2 methods */
    STDMETHOD(SetSystemProperties)(THIS_ LPENUMJAVAPROPERTY penumProperties) PURE;
    STDMETHOD(SetClassSource)(THIS_ DWORD dwType, LPVOID pData, DWORD dwLen) PURE;
};

// {3EFB1800-C2A1-11cf-960C-0080C7C2BA87}
DEFINE_GUID(CLSID_JavaExecute,
0x3efb1800, 0xc2a1, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0xc2, 0xba, 0x87);
// {3EFB1803-C2A1-11cf-960C-0080C7C2BA87}
DEFINE_GUID(IID_IJavaExecute,
0x3efb1803, 0xc2a1, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0xc2, 0xba, 0x87);
// {D7658820-01DD-11d0-9746-00AA00342BD8}
DEFINE_GUID(IID_IJavaExecute2,
0xd7658820, 0x1dd, 0x11d0, 0x97, 0x46, 0x0, 0xaa, 0x0, 0x34, 0x2b, 0xd8);
// {56E7DF80-F527-11cf-B728-FC8703C10000}
DEFINE_GUID(IID_IEnumJAVAPROPERTY,
0x56e7df80, 0xf527, 0x11cf, 0xb7, 0x28, 0xfc, 0x87, 0x3, 0xc1, 0x0, 0x0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java20\include\nativcom.h ===
// (C) Copyright 1996, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for COM-marshaling facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVCOM_
#define _NATIVCOM_


#include <windows.h>
#include <native.h>


#ifdef __cplusplus
extern "C" {
#endif


//----------------------------------------------------------------------------
// COM data wrapper helpers...
//----------------------------------------------------------------------------
void* __cdecl jcdwNewData(Hjava_lang_Object * phJCDW, unsigned int numBytes);
void* __cdecl jcdwGetData(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwSizeOf(Hjava_lang_Object * phJCDW);
unsigned int __cdecl jcdwClassSizeOf(Hjava_lang_Object * phJavaClass);
unsigned int __cdecl jcdwOffsetOf(Hjava_lang_Object * phJCDW, const char *pFieldName);
unsigned int __cdecl jcdwClassOffsetOf(Hjava_lang_Object * phJCDWClass, const char *pFieldName);
Hjava_lang_Object * __cdecl convert_IUnknown_to_Java_Object(IUnknown *punk,
                                                            Hjava_lang_Object *phJavaClass,
                                                            int       fAssumeThreadSafe);
IUnknown * __cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID);

Hjava_lang_Object * __cdecl convert_ptr_to_jcdw(void              *pExtData,
                                                Hjava_lang_Object *phJavaClass
                                                );

int __cdecl jcdw_memory_freed_on_gc(Hjava_lang_Object *phJCDW);


int   __cdecl jcdwSetData(Hjava_lang_Object * phJCDW, LPVOID pv);
int   __cdecl jcdw_java_owned(Hjava_lang_Object *phJCDW);


    

#ifdef __cplusplus
}
#endif



#endif _NATIVCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java20\include\javadbg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Wed Sep 25 22:22:04 1996
 */
/* Compiler settings for javadbg.idl:
    Oi, W4, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __javadbg_h__
#define __javadbg_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumLINEINFO_FWD_DEFINED__
#define __IEnumLINEINFO_FWD_DEFINED__
typedef interface IEnumLINEINFO IEnumLINEINFO;
#endif 	/* __IEnumLINEINFO_FWD_DEFINED__ */


#ifndef __IJavaEnumLINEINFO_FWD_DEFINED__
#define __IJavaEnumLINEINFO_FWD_DEFINED__
typedef interface IJavaEnumLINEINFO IJavaEnumLINEINFO;
#endif 	/* __IJavaEnumLINEINFO_FWD_DEFINED__ */


#ifndef __IRemoteField_FWD_DEFINED__
#define __IRemoteField_FWD_DEFINED__
typedef interface IRemoteField IRemoteField;
#endif 	/* __IRemoteField_FWD_DEFINED__ */


#ifndef __IEnumRemoteField_FWD_DEFINED__
#define __IEnumRemoteField_FWD_DEFINED__
typedef interface IEnumRemoteField IEnumRemoteField;
#endif 	/* __IEnumRemoteField_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteField_FWD_DEFINED__
#define __IJavaEnumRemoteField_FWD_DEFINED__
typedef interface IJavaEnumRemoteField IJavaEnumRemoteField;
#endif 	/* __IJavaEnumRemoteField_FWD_DEFINED__ */


#ifndef __IRemoteDataField_FWD_DEFINED__
#define __IRemoteDataField_FWD_DEFINED__
typedef interface IRemoteDataField IRemoteDataField;
#endif 	/* __IRemoteDataField_FWD_DEFINED__ */


#ifndef __IRemoteArrayField_FWD_DEFINED__
#define __IRemoteArrayField_FWD_DEFINED__
typedef interface IRemoteArrayField IRemoteArrayField;
#endif 	/* __IRemoteArrayField_FWD_DEFINED__ */


#ifndef __IRemoteContainerField_FWD_DEFINED__
#define __IRemoteContainerField_FWD_DEFINED__
typedef interface IRemoteContainerField IRemoteContainerField;
#endif 	/* __IRemoteContainerField_FWD_DEFINED__ */


#ifndef __IRemoteMethodField_FWD_DEFINED__
#define __IRemoteMethodField_FWD_DEFINED__
typedef interface IRemoteMethodField IRemoteMethodField;
#endif 	/* __IRemoteMethodField_FWD_DEFINED__ */


#ifndef __IRemoteClassField_FWD_DEFINED__
#define __IRemoteClassField_FWD_DEFINED__
typedef interface IRemoteClassField IRemoteClassField;
#endif 	/* __IRemoteClassField_FWD_DEFINED__ */


#ifndef __IRemoteObject_FWD_DEFINED__
#define __IRemoteObject_FWD_DEFINED__
typedef interface IRemoteObject IRemoteObject;
#endif 	/* __IRemoteObject_FWD_DEFINED__ */


#ifndef __IEnumRemoteObject_FWD_DEFINED__
#define __IEnumRemoteObject_FWD_DEFINED__
typedef interface IEnumRemoteObject IEnumRemoteObject;
#endif 	/* __IEnumRemoteObject_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteObject_FWD_DEFINED__
#define __IJavaEnumRemoteObject_FWD_DEFINED__
typedef interface IJavaEnumRemoteObject IJavaEnumRemoteObject;
#endif 	/* __IJavaEnumRemoteObject_FWD_DEFINED__ */


#ifndef __IEnumRemoteValue_FWD_DEFINED__
#define __IEnumRemoteValue_FWD_DEFINED__
typedef interface IEnumRemoteValue IEnumRemoteValue;
#endif 	/* __IEnumRemoteValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteBooleanValue_FWD_DEFINED__
#define __IEnumRemoteBooleanValue_FWD_DEFINED__
typedef interface IEnumRemoteBooleanValue IEnumRemoteBooleanValue;
#endif 	/* __IEnumRemoteBooleanValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteBooleanValue_FWD_DEFINED__
#define __IJavaEnumRemoteBooleanValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteBooleanValue IJavaEnumRemoteBooleanValue;
#endif 	/* __IJavaEnumRemoteBooleanValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteByteValue_FWD_DEFINED__
#define __IEnumRemoteByteValue_FWD_DEFINED__
typedef interface IEnumRemoteByteValue IEnumRemoteByteValue;
#endif 	/* __IEnumRemoteByteValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteByteValue_FWD_DEFINED__
#define __IJavaEnumRemoteByteValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteByteValue IJavaEnumRemoteByteValue;
#endif 	/* __IJavaEnumRemoteByteValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteCharValue_FWD_DEFINED__
#define __IEnumRemoteCharValue_FWD_DEFINED__
typedef interface IEnumRemoteCharValue IEnumRemoteCharValue;
#endif 	/* __IEnumRemoteCharValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteCharValue_FWD_DEFINED__
#define __IJavaEnumRemoteCharValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteCharValue IJavaEnumRemoteCharValue;
#endif 	/* __IJavaEnumRemoteCharValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteDoubleValue_FWD_DEFINED__
#define __IEnumRemoteDoubleValue_FWD_DEFINED__
typedef interface IEnumRemoteDoubleValue IEnumRemoteDoubleValue;
#endif 	/* __IEnumRemoteDoubleValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteDoubleValue_FWD_DEFINED__
#define __IJavaEnumRemoteDoubleValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteDoubleValue IJavaEnumRemoteDoubleValue;
#endif 	/* __IJavaEnumRemoteDoubleValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteFloatValue_FWD_DEFINED__
#define __IEnumRemoteFloatValue_FWD_DEFINED__
typedef interface IEnumRemoteFloatValue IEnumRemoteFloatValue;
#endif 	/* __IEnumRemoteFloatValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteFloatValue_FWD_DEFINED__
#define __IJavaEnumRemoteFloatValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteFloatValue IJavaEnumRemoteFloatValue;
#endif 	/* __IJavaEnumRemoteFloatValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteIntValue_FWD_DEFINED__
#define __IEnumRemoteIntValue_FWD_DEFINED__
typedef interface IEnumRemoteIntValue IEnumRemoteIntValue;
#endif 	/* __IEnumRemoteIntValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteIntValue_FWD_DEFINED__
#define __IJavaEnumRemoteIntValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteIntValue IJavaEnumRemoteIntValue;
#endif 	/* __IJavaEnumRemoteIntValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteLongValue_FWD_DEFINED__
#define __IEnumRemoteLongValue_FWD_DEFINED__
typedef interface IEnumRemoteLongValue IEnumRemoteLongValue;
#endif 	/* __IEnumRemoteLongValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteLongValue_FWD_DEFINED__
#define __IJavaEnumRemoteLongValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteLongValue IJavaEnumRemoteLongValue;
#endif 	/* __IJavaEnumRemoteLongValue_FWD_DEFINED__ */


#ifndef __IEnumRemoteShortValue_FWD_DEFINED__
#define __IEnumRemoteShortValue_FWD_DEFINED__
typedef interface IEnumRemoteShortValue IEnumRemoteShortValue;
#endif 	/* __IEnumRemoteShortValue_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteShortValue_FWD_DEFINED__
#define __IJavaEnumRemoteShortValue_FWD_DEFINED__
typedef interface IJavaEnumRemoteShortValue IJavaEnumRemoteShortValue;
#endif 	/* __IJavaEnumRemoteShortValue_FWD_DEFINED__ */


#ifndef __IRemoteArrayObject_FWD_DEFINED__
#define __IRemoteArrayObject_FWD_DEFINED__
typedef interface IRemoteArrayObject IRemoteArrayObject;
#endif 	/* __IRemoteArrayObject_FWD_DEFINED__ */


#ifndef __IRemoteBooleanObject_FWD_DEFINED__
#define __IRemoteBooleanObject_FWD_DEFINED__
typedef interface IRemoteBooleanObject IRemoteBooleanObject;
#endif 	/* __IRemoteBooleanObject_FWD_DEFINED__ */


#ifndef __IRemoteByteObject_FWD_DEFINED__
#define __IRemoteByteObject_FWD_DEFINED__
typedef interface IRemoteByteObject IRemoteByteObject;
#endif 	/* __IRemoteByteObject_FWD_DEFINED__ */


#ifndef __IRemoteCharObject_FWD_DEFINED__
#define __IRemoteCharObject_FWD_DEFINED__
typedef interface IRemoteCharObject IRemoteCharObject;
#endif 	/* __IRemoteCharObject_FWD_DEFINED__ */


#ifndef __IRemoteContainerObject_FWD_DEFINED__
#define __IRemoteContainerObject_FWD_DEFINED__
typedef interface IRemoteContainerObject IRemoteContainerObject;
#endif 	/* __IRemoteContainerObject_FWD_DEFINED__ */


#ifndef __IRemoteClassObject_FWD_DEFINED__
#define __IRemoteClassObject_FWD_DEFINED__
typedef interface IRemoteClassObject IRemoteClassObject;
#endif 	/* __IRemoteClassObject_FWD_DEFINED__ */


#ifndef __IRemoteDoubleObject_FWD_DEFINED__
#define __IRemoteDoubleObject_FWD_DEFINED__
typedef interface IRemoteDoubleObject IRemoteDoubleObject;
#endif 	/* __IRemoteDoubleObject_FWD_DEFINED__ */


#ifndef __IRemoteFloatObject_FWD_DEFINED__
#define __IRemoteFloatObject_FWD_DEFINED__
typedef interface IRemoteFloatObject IRemoteFloatObject;
#endif 	/* __IRemoteFloatObject_FWD_DEFINED__ */


#ifndef __IRemoteIntObject_FWD_DEFINED__
#define __IRemoteIntObject_FWD_DEFINED__
typedef interface IRemoteIntObject IRemoteIntObject;
#endif 	/* __IRemoteIntObject_FWD_DEFINED__ */


#ifndef __IRemoteLongObject_FWD_DEFINED__
#define __IRemoteLongObject_FWD_DEFINED__
typedef interface IRemoteLongObject IRemoteLongObject;
#endif 	/* __IRemoteLongObject_FWD_DEFINED__ */


#ifndef __IRemoteShortObject_FWD_DEFINED__
#define __IRemoteShortObject_FWD_DEFINED__
typedef interface IRemoteShortObject IRemoteShortObject;
#endif 	/* __IRemoteShortObject_FWD_DEFINED__ */


#ifndef __IRemoteStackFrame_FWD_DEFINED__
#define __IRemoteStackFrame_FWD_DEFINED__
typedef interface IRemoteStackFrame IRemoteStackFrame;
#endif 	/* __IRemoteStackFrame_FWD_DEFINED__ */


#ifndef __IRemoteThreadGroup_FWD_DEFINED__
#define __IRemoteThreadGroup_FWD_DEFINED__
typedef interface IRemoteThreadGroup IRemoteThreadGroup;
#endif 	/* __IRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IEnumRemoteThreadGroup_FWD_DEFINED__
#define __IEnumRemoteThreadGroup_FWD_DEFINED__
typedef interface IEnumRemoteThreadGroup IEnumRemoteThreadGroup;
#endif 	/* __IEnumRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteThreadGroup_FWD_DEFINED__
#define __IJavaEnumRemoteThreadGroup_FWD_DEFINED__
typedef interface IJavaEnumRemoteThreadGroup IJavaEnumRemoteThreadGroup;
#endif 	/* __IJavaEnumRemoteThreadGroup_FWD_DEFINED__ */


#ifndef __IRemoteThread_FWD_DEFINED__
#define __IRemoteThread_FWD_DEFINED__
typedef interface IRemoteThread IRemoteThread;
#endif 	/* __IRemoteThread_FWD_DEFINED__ */


#ifndef __IEnumRemoteThread_FWD_DEFINED__
#define __IEnumRemoteThread_FWD_DEFINED__
typedef interface IEnumRemoteThread IEnumRemoteThread;
#endif 	/* __IEnumRemoteThread_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteThread_FWD_DEFINED__
#define __IJavaEnumRemoteThread_FWD_DEFINED__
typedef interface IJavaEnumRemoteThread IJavaEnumRemoteThread;
#endif 	/* __IJavaEnumRemoteThread_FWD_DEFINED__ */


#ifndef __IRemoteProcessCallback_FWD_DEFINED__
#define __IRemoteProcessCallback_FWD_DEFINED__
typedef interface IRemoteProcessCallback IRemoteProcessCallback;
#endif 	/* __IRemoteProcessCallback_FWD_DEFINED__ */


#ifndef __IRemoteProcess_FWD_DEFINED__
#define __IRemoteProcess_FWD_DEFINED__
typedef interface IRemoteProcess IRemoteProcess;
#endif 	/* __IRemoteProcess_FWD_DEFINED__ */


#ifndef __IEnumRemoteProcess_FWD_DEFINED__
#define __IEnumRemoteProcess_FWD_DEFINED__
typedef interface IEnumRemoteProcess IEnumRemoteProcess;
#endif 	/* __IEnumRemoteProcess_FWD_DEFINED__ */


#ifndef __IJavaEnumRemoteProcess_FWD_DEFINED__
#define __IJavaEnumRemoteProcess_FWD_DEFINED__
typedef interface IJavaEnumRemoteProcess IJavaEnumRemoteProcess;
#endif 	/* __IJavaEnumRemoteProcess_FWD_DEFINED__ */


#ifndef __IRemoteDebugManagerCallback_FWD_DEFINED__
#define __IRemoteDebugManagerCallback_FWD_DEFINED__
typedef interface IRemoteDebugManagerCallback IRemoteDebugManagerCallback;
#endif 	/* __IRemoteDebugManagerCallback_FWD_DEFINED__ */


#ifndef __IRemoteDebugManager_FWD_DEFINED__
#define __IRemoteDebugManager_FWD_DEFINED__
typedef interface IRemoteDebugManager IRemoteDebugManager;
#endif 	/* __IRemoteDebugManager_FWD_DEFINED__ */


#ifndef __IJavaDebugManager_FWD_DEFINED__
#define __IJavaDebugManager_FWD_DEFINED__
typedef interface IJavaDebugManager IJavaDebugManager;
#endif 	/* __IJavaDebugManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */ 


























































// error codes
//
// errors returned by IRemoteContainer::GetFieldObject
static const int E_FIELDOUTOFSCOPE       = MAKE_HRESULT(1, FACILITY_ITF, 0x01);
static const int E_FIELDNOTINOBJECT      = MAKE_HRESULT(1, FACILITY_ITF, 0x02);
static const int E_NOFIELDS              = MAKE_HRESULT(1, FACILITY_ITF, 0x03);
static const int E_NULLOBJECTREF         = MAKE_HRESULT(1, FACILITY_ITF, 0x04);
// errors returned by IRemoteProcess::FindClass
static const int E_CLASSNOTFOUND         = MAKE_HRESULT(1, FACILITY_ITF, 0x10);
static const int E_BADMETHOD             = MAKE_HRESULT(1, FACILITY_ITF, 0x20);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumLINEINFO_INTERFACE_DEFINED__
#define __IEnumLINEINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumLINEINFO
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumLINEINFO __RPC_FAR *LPENUMLINEINFO;

typedef struct  tagLINEINFO
    {
    USHORT offPC;
    USHORT iLine;
    }	LINEINFO;

typedef struct tagLINEINFO __RPC_FAR *LPLINEINFO;


EXTERN_C const IID IID_IEnumLINEINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumLINEINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumLINEINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumLINEINFO __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumLINEINFOVtbl;

    interface IEnumLINEINFO
    {
        CONST_VTBL struct IEnumLINEINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumLINEINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumLINEINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumLINEINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumLINEINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumLINEINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumLINEINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumLINEINFO_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumLINEINFO_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Next_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPLINEINFO rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumLINEINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Skip_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumLINEINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Reset_Proxy( 
    IEnumLINEINFO __RPC_FAR * This);


void __RPC_STUB IEnumLINEINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_Clone_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumLINEINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumLINEINFO_GetCount_Proxy( 
    IEnumLINEINFO __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumLINEINFO_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumLINEINFO_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumLINEINFO_INTERFACE_DEFINED__
#define __IJavaEnumLINEINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumLINEINFO
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumLINEINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumLINEINFO : public IEnumLINEINFO
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ LINEINFO __RPC_FAR *pli) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumLINEINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPLINEINFO rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumLINEINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumLINEINFO __RPC_FAR * This,
            /* [out] */ LINEINFO __RPC_FAR *pli);
        
        END_INTERFACE
    } IJavaEnumLINEINFOVtbl;

    interface IJavaEnumLINEINFO
    {
        CONST_VTBL struct IJavaEnumLINEINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumLINEINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumLINEINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumLINEINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumLINEINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumLINEINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumLINEINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumLINEINFO_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumLINEINFO_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumLINEINFO_GetNext(This,pli)	\
    (This)->lpVtbl -> GetNext(This,pli)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumLINEINFO_GetNext_Proxy( 
    IJavaEnumLINEINFO __RPC_FAR * This,
    /* [out] */ LINEINFO __RPC_FAR *pli);


void __RPC_STUB IJavaEnumLINEINFO_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumLINEINFO_INTERFACE_DEFINED__ */


#ifndef __IRemoteField_INTERFACE_DEFINED__
#define __IRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteField __RPC_FAR *LPREMOTEFIELD;


enum __MIDL_IRemoteField_0001
    {	FIELD_KIND_DATA_OBJECT	= 0x1,
	FIELD_KIND_DATA_PRIMITIVE	= 0x2,
	FIELD_KIND_ARRAY	= 0x4,
	FIELD_KIND_CLASS	= 0x8,
	FIELD_KIND_METHOD	= 0x10,
	FIELD_KIND_LOCAL	= 0x1000,
	FIELD_KIND_PARAM	= 0x2000,
	FIELD_KIND_THIS	= 0x4000
    };
typedef ULONG FIELDKIND;


enum __MIDL_IRemoteField_0002
    {	FIELD_ACC_PUBLIC	= 0x1,
	FIELD_ACC_PRIVATE	= 0x2,
	FIELD_ACC_PROTECTED	= 0x4,
	FIELD_ACC_STATIC	= 0x8,
	FIELD_ACC_FINAL	= 0x10,
	FIELD_ACC_SYNCHRONIZED	= 0x20,
	FIELD_ACC_VOLATILE	= 0x40,
	FIELD_ACC_TRANSIENT	= 0x80,
	FIELD_ACC_NATIVE	= 0x100,
	FIELD_ACC_INTERFACE	= 0x200,
	FIELD_ACC_ABSTRACT	= 0x400
    };
typedef ULONG FIELDMODIFIERS;


EXTERN_C const IID IID_IRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteField : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKind( 
            /* [out] */ FIELDKIND __RPC_FAR *pfk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModifiers( 
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        END_INTERFACE
    } IRemoteFieldVtbl;

    interface IRemoteField
    {
        CONST_VTBL struct IRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteField_GetName_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteField_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetKind_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ FIELDKIND __RPC_FAR *pfk);


void __RPC_STUB IRemoteField_GetKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetType_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);


void __RPC_STUB IRemoteField_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetContainer_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);


void __RPC_STUB IRemoteField_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteField_GetModifiers_Proxy( 
    IRemoteField __RPC_FAR * This,
    /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);


void __RPC_STUB IRemoteField_GetModifiers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteField_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteField_INTERFACE_DEFINED__
#define __IEnumRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteField __RPC_FAR *LPENUMREMOTEFIELD;


EXTERN_C const IID IID_IEnumRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteField : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteFieldVtbl;

    interface IEnumRemoteField
    {
        CONST_VTBL struct IEnumRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteField_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteField_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteField_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteField_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteField_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteField_Next_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteField_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Skip_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteField_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Reset_Proxy( 
    IEnumRemoteField __RPC_FAR * This);


void __RPC_STUB IEnumRemoteField_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_Clone_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteField_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteField_GetCount_Proxy( 
    IEnumRemoteField __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteField_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteField_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteField_INTERFACE_DEFINED__
#define __IJavaEnumRemoteField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteField : public IEnumRemoteField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteField __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf);
        
        END_INTERFACE
    } IJavaEnumRemoteFieldVtbl;

    interface IJavaEnumRemoteField
    {
        CONST_VTBL struct IJavaEnumRemoteFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteField_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteField_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteField_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteField_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteField_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteField_GetNext(This,ppirf)	\
    (This)->lpVtbl -> GetNext(This,ppirf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteField_GetNext_Proxy( 
    IJavaEnumRemoteField __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppirf);


void __RPC_STUB IJavaEnumRemoteField_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteField_INTERFACE_DEFINED__ */


#ifndef __IRemoteDataField_INTERFACE_DEFINED__
#define __IRemoteDataField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDataField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDataField __RPC_FAR *LPREMOTEDATAFIELD;


EXTERN_C const IID IID_IRemoteDataField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDataField : public IRemoteField
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDataFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDataField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDataField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDataField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteDataField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        END_INTERFACE
    } IRemoteDataFieldVtbl;

    interface IRemoteDataField
    {
        CONST_VTBL struct IRemoteDataFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDataField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDataField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDataField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDataField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteDataField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteDataField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteDataField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteDataField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDataField_INTERFACE_DEFINED__ */


#ifndef __IRemoteArrayField_INTERFACE_DEFINED__
#define __IRemoteArrayField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteArrayField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteArrayField __RPC_FAR *LPREMOTEARRAYFIELD;


EXTERN_C const IID IID_IRemoteArrayField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteArrayField : public IRemoteDataField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcElements) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteArrayFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteArrayField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteArrayField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IRemoteArrayField __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcElements);
        
        END_INTERFACE
    } IRemoteArrayFieldVtbl;

    interface IRemoteArrayField
    {
        CONST_VTBL struct IRemoteArrayFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteArrayField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteArrayField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteArrayField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteArrayField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteArrayField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteArrayField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteArrayField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteArrayField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)



#define IRemoteArrayField_GetSize(This,pcElements)	\
    (This)->lpVtbl -> GetSize(This,pcElements)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteArrayField_GetSize_Proxy( 
    IRemoteArrayField __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcElements);


void __RPC_STUB IRemoteArrayField_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteArrayField_INTERFACE_DEFINED__ */


#ifndef __IRemoteContainerField_INTERFACE_DEFINED__
#define __IRemoteContainerField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteContainerField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteContainerField __RPC_FAR *LPREMOTECONTAINERFIELD;


EXTERN_C const IID IID_IRemoteContainerField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteContainerField : public IRemoteField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFields( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteContainerFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteContainerField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteContainerField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteContainerField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        END_INTERFACE
    } IRemoteContainerFieldVtbl;

    interface IRemoteContainerField
    {
        CONST_VTBL struct IRemoteContainerFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteContainerField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteContainerField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteContainerField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteContainerField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteContainerField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteContainerField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteContainerField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteContainerField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteContainerField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteContainerField_GetFields_Proxy( 
    IRemoteContainerField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
    /* [in] */ FIELDKIND ulKind,
    /* [in] */ FIELDMODIFIERS ulModifiers,
    /* [unique][in] */ LPCOLESTR lpcszName);


void __RPC_STUB IRemoteContainerField_GetFields_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteContainerField_INTERFACE_DEFINED__ */


#ifndef __IRemoteMethodField_INTERFACE_DEFINED__
#define __IRemoteMethodField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteMethodField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteMethodField __RPC_FAR *LPREMOTEMETHODFIELD;


EXTERN_C const IID IID_IRemoteMethodField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteMethodField : public IRemoteContainerField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBreakpoint( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearBreakpoint( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineInfo( 
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBytes( 
            /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScope( 
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ ULONG __RPC_FAR *poffStart,
            /* [out] */ ULONG __RPC_FAR *pcbScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexedField( 
            /* [in] */ ULONG slot,
            /* [in] */ ULONG offPC,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteMethodFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteMethodField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteMethodField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineInfo )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBytes )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScope )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ ULONG __RPC_FAR *poffStart,
            /* [out] */ ULONG __RPC_FAR *pcbScope);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexedField )( 
            IRemoteMethodField __RPC_FAR * This,
            /* [in] */ ULONG slot,
            /* [in] */ ULONG offPC,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField);
        
        END_INTERFACE
    } IRemoteMethodFieldVtbl;

    interface IRemoteMethodField
    {
        CONST_VTBL struct IRemoteMethodFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteMethodField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteMethodField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteMethodField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteMethodField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteMethodField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteMethodField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteMethodField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteMethodField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteMethodField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)


#define IRemoteMethodField_SetBreakpoint(This,offPC)	\
    (This)->lpVtbl -> SetBreakpoint(This,offPC)

#define IRemoteMethodField_ClearBreakpoint(This,offPC)	\
    (This)->lpVtbl -> ClearBreakpoint(This,offPC)

#define IRemoteMethodField_GetLineInfo(This,ppEnum)	\
    (This)->lpVtbl -> GetLineInfo(This,ppEnum)

#define IRemoteMethodField_GetBytes(This,ppLockBytes)	\
    (This)->lpVtbl -> GetBytes(This,ppLockBytes)

#define IRemoteMethodField_GetScope(This,pField,poffStart,pcbScope)	\
    (This)->lpVtbl -> GetScope(This,pField,poffStart,pcbScope)

#define IRemoteMethodField_GetIndexedField(This,slot,offPC,ppField)	\
    (This)->lpVtbl -> GetIndexedField(This,slot,offPC,ppField)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteMethodField_SetBreakpoint_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteMethodField_SetBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_ClearBreakpoint_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteMethodField_ClearBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetLineInfo_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [out] */ IJavaEnumLINEINFO __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteMethodField_GetLineInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetBytes_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [out] */ ILockBytes __RPC_FAR *__RPC_FAR *ppLockBytes);


void __RPC_STUB IRemoteMethodField_GetBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetScope_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [unique][in] */ IRemoteField __RPC_FAR *pField,
    /* [out] */ ULONG __RPC_FAR *poffStart,
    /* [out] */ ULONG __RPC_FAR *pcbScope);


void __RPC_STUB IRemoteMethodField_GetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteMethodField_GetIndexedField_Proxy( 
    IRemoteMethodField __RPC_FAR * This,
    /* [in] */ ULONG slot,
    /* [in] */ ULONG offPC,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppField);


void __RPC_STUB IRemoteMethodField_GetIndexedField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteMethodField_INTERFACE_DEFINED__ */


#ifndef __IRemoteClassField_INTERFACE_DEFINED__
#define __IRemoteClassField_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteClassField
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteClassField __RPC_FAR *LPREMOTECLASSFIELD;


enum __MIDL_IRemoteClassField_0001
    {	CP_CONSTANT_UTF8	= 1,
	CP_CONSTANT_UNICODE	= 2,
	CP_CONSTANT_INTEGER	= 3,
	CP_CONSTANT_FLOAT	= 4,
	CP_CONSTANT_LONG	= 5,
	CP_CONSTANT_DOUBLE	= 6,
	CP_CONSTANT_CLASS	= 7,
	CP_CONSTANT_STRING	= 8,
	CP_CONSTANT_FIELDREF	= 9,
	CP_CONSTANT_METHODREF	= 10,
	CP_CONSTANT_INTERFACEMETHODREF	= 11,
	CP_CONSTANT_NAMEANDTYPE	= 12
    };

EXTERN_C const IID IID_IRemoteClassField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteClassField : public IRemoteContainerField
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceFileName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuperclass( 
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfaces( 
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConstantPoolItem( 
            /* [in] */ ULONG indexCP,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
            /* [out] */ ULONG __RPC_FAR *plength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteClassFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteClassField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteClassField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteClassField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ FIELDKIND __RPC_FAR *pfk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainer )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteContainerField __RPC_FAR *__RPC_FAR *ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetModifiers )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ FIELDMODIFIERS __RPC_FAR *pulModifiers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFields )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum,
            /* [in] */ FIELDKIND ulKind,
            /* [in] */ FIELDMODIFIERS ulModifiers,
            /* [unique][in] */ LPCOLESTR lpcszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceFileName )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperclass )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfaces )( 
            IRemoteClassField __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConstantPoolItem )( 
            IRemoteClassField __RPC_FAR * This,
            /* [in] */ ULONG indexCP,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
            /* [out] */ ULONG __RPC_FAR *plength);
        
        END_INTERFACE
    } IRemoteClassFieldVtbl;

    interface IRemoteClassField
    {
        CONST_VTBL struct IRemoteClassFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteClassField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteClassField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteClassField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteClassField_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteClassField_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#define IRemoteClassField_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteClassField_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IRemoteClassField_GetModifiers(This,pulModifiers)	\
    (This)->lpVtbl -> GetModifiers(This,pulModifiers)


#define IRemoteClassField_GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)	\
    (This)->lpVtbl -> GetFields(This,ppEnum,ulKind,ulModifiers,lpcszName)


#define IRemoteClassField_GetFileName(This,ppszFileName)	\
    (This)->lpVtbl -> GetFileName(This,ppszFileName)

#define IRemoteClassField_GetSourceFileName(This,ppszSourceFileName)	\
    (This)->lpVtbl -> GetSourceFileName(This,ppszSourceFileName)

#define IRemoteClassField_GetSuperclass(This,ppSuperclass)	\
    (This)->lpVtbl -> GetSuperclass(This,ppSuperclass)

#define IRemoteClassField_GetInterfaces(This,ppEnum)	\
    (This)->lpVtbl -> GetInterfaces(This,ppEnum)

#define IRemoteClassField_GetConstantPoolItem(This,indexCP,ppCPBytes,plength)	\
    (This)->lpVtbl -> GetConstantPoolItem(This,indexCP,ppCPBytes,plength)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteClassField_GetFileName_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszFileName);


void __RPC_STUB IRemoteClassField_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetSourceFileName_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszSourceFileName);


void __RPC_STUB IRemoteClassField_GetSourceFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetSuperclass_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppSuperclass);


void __RPC_STUB IRemoteClassField_GetSuperclass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetInterfaces_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteField __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteClassField_GetInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteClassField_GetConstantPoolItem_Proxy( 
    IRemoteClassField __RPC_FAR * This,
    /* [in] */ ULONG indexCP,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppCPBytes,
    /* [out] */ ULONG __RPC_FAR *plength);


void __RPC_STUB IRemoteClassField_GetConstantPoolItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteClassField_INTERFACE_DEFINED__ */


#ifndef __IRemoteObject_INTERFACE_DEFINED__
#define __IRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteObject __RPC_FAR *LPREMOTEOBJECT;

typedef BYTE JAVA_BOOLEAN;

typedef signed char JAVA_BYTE;

typedef USHORT JAVA_CHAR;

typedef double JAVA_DOUBLE;

typedef float JAVA_FLOAT;

typedef LONG JAVA_INT;

typedef LONGLONG JAVA_LONG;

typedef SHORT JAVA_SHORT;

typedef LPOLESTR JAVA_STRING;


EXTERN_C const IID IID_IRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBreakpoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearBreakpoint( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteObject __RPC_FAR * This);
        
        END_INTERFACE
    } IRemoteObjectVtbl;

    interface IRemoteObject
    {
        CONST_VTBL struct IRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteObject_GetType_Proxy( 
    IRemoteObject __RPC_FAR * This,
    /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);


void __RPC_STUB IRemoteObject_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteObject_SetBreakpoint_Proxy( 
    IRemoteObject __RPC_FAR * This);


void __RPC_STUB IRemoteObject_SetBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteObject_ClearBreakpoint_Proxy( 
    IRemoteObject __RPC_FAR * This);


void __RPC_STUB IRemoteObject_ClearBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteObject_INTERFACE_DEFINED__
#define __IEnumRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteObject __RPC_FAR *LPENUMREMOTEOBJECT;


EXTERN_C const IID IID_IEnumRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteObjectVtbl;

    interface IEnumRemoteObject
    {
        CONST_VTBL struct IEnumRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteObject_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteObject_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Next_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Skip_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Reset_Proxy( 
    IEnumRemoteObject __RPC_FAR * This);


void __RPC_STUB IEnumRemoteObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_Clone_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteObject_GetCount_Proxy( 
    IEnumRemoteObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteObject_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteObject_INTERFACE_DEFINED__
#define __IJavaEnumRemoteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteObject : public IEnumRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteObject __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteObject __RPC_FAR * This,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro);
        
        END_INTERFACE
    } IJavaEnumRemoteObjectVtbl;

    interface IJavaEnumRemoteObject
    {
        CONST_VTBL struct IJavaEnumRemoteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteObject_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteObject_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteObject_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteObject_GetNext(This,ppiro)	\
    (This)->lpVtbl -> GetNext(This,ppiro)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteObject_GetNext_Proxy( 
    IJavaEnumRemoteObject __RPC_FAR * This,
    /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppiro);


void __RPC_STUB IJavaEnumRemoteObject_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteObject_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteValue_INTERFACE_DEFINED__
#define __IEnumRemoteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteValue __RPC_FAR *LPENUMREMOTEVALUE;


EXTERN_C const IID IID_IEnumRemoteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumRemoteValueVtbl;

    interface IEnumRemoteValue
    {
        CONST_VTBL struct IEnumRemoteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Skip_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteValue_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Reset_Proxy( 
    IEnumRemoteValue __RPC_FAR * This);


void __RPC_STUB IEnumRemoteValue_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_Clone_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteValue_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteValue_GetCount_Proxy( 
    IEnumRemoteValue __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumRemoteValue_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteBooleanValue_INTERFACE_DEFINED__
#define __IEnumRemoteBooleanValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteBooleanValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteBooleanValue __RPC_FAR *LPENUMREMOTEBOOLEANVALUE;


EXTERN_C const IID IID_IEnumRemoteBooleanValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteBooleanValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteBooleanValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteBooleanValueVtbl;

    interface IEnumRemoteBooleanValue
    {
        CONST_VTBL struct IEnumRemoteBooleanValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteBooleanValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteBooleanValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteBooleanValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteBooleanValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteBooleanValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteBooleanValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteBooleanValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteBooleanValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteBooleanValue_Next_Proxy( 
    IEnumRemoteBooleanValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteBooleanValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteBooleanValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteBooleanValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteBooleanValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteBooleanValue : public IEnumRemoteBooleanValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteBooleanValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BOOLEAN __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteBooleanValue __RPC_FAR * This,
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb);
        
        END_INTERFACE
    } IJavaEnumRemoteBooleanValueVtbl;

    interface IJavaEnumRemoteBooleanValue
    {
        CONST_VTBL struct IJavaEnumRemoteBooleanValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteBooleanValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteBooleanValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteBooleanValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteBooleanValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteBooleanValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteBooleanValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteBooleanValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteBooleanValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteBooleanValue_GetNext(This,pjb)	\
    (This)->lpVtbl -> GetNext(This,pjb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteBooleanValue_GetNext_Proxy( 
    IJavaEnumRemoteBooleanValue __RPC_FAR * This,
    /* [out] */ JAVA_BOOLEAN __RPC_FAR *pjb);


void __RPC_STUB IJavaEnumRemoteBooleanValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteBooleanValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteByteValue_INTERFACE_DEFINED__
#define __IEnumRemoteByteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteByteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteByteValue __RPC_FAR *LPENUMREMOTEBYTEVALUE;


EXTERN_C const IID IID_IEnumRemoteByteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteByteValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteByteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteByteValueVtbl;

    interface IEnumRemoteByteValue
    {
        CONST_VTBL struct IEnumRemoteByteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteByteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteByteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteByteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteByteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteByteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteByteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteByteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteByteValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteByteValue_Next_Proxy( 
    IEnumRemoteByteValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteByteValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteByteValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteByteValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteByteValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteByteValue : public IEnumRemoteByteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteByteValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_BYTE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteByteValue __RPC_FAR * This,
            /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte);
        
        END_INTERFACE
    } IJavaEnumRemoteByteValueVtbl;

    interface IJavaEnumRemoteByteValue
    {
        CONST_VTBL struct IJavaEnumRemoteByteValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteByteValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteByteValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteByteValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteByteValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteByteValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteByteValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteByteValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteByteValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteByteValue_GetNext(This,pjbyte)	\
    (This)->lpVtbl -> GetNext(This,pjbyte)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteByteValue_GetNext_Proxy( 
    IJavaEnumRemoteByteValue __RPC_FAR * This,
    /* [out] */ JAVA_BYTE __RPC_FAR *pjbyte);


void __RPC_STUB IJavaEnumRemoteByteValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteByteValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteCharValue_INTERFACE_DEFINED__
#define __IEnumRemoteCharValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteCharValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteCharValue __RPC_FAR *LPENUMREMOTECHARVALUE;


EXTERN_C const IID IID_IEnumRemoteCharValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteCharValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteCharValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteCharValueVtbl;

    interface IEnumRemoteCharValue
    {
        CONST_VTBL struct IEnumRemoteCharValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteCharValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteCharValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteCharValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteCharValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteCharValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteCharValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteCharValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteCharValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteCharValue_Next_Proxy( 
    IEnumRemoteCharValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteCharValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteCharValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteCharValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteCharValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteCharValue : public IEnumRemoteCharValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_CHAR __RPC_FAR *pjch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteCharValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_CHAR __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteCharValue __RPC_FAR * This,
            /* [out] */ JAVA_CHAR __RPC_FAR *pjch);
        
        END_INTERFACE
    } IJavaEnumRemoteCharValueVtbl;

    interface IJavaEnumRemoteCharValue
    {
        CONST_VTBL struct IJavaEnumRemoteCharValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteCharValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteCharValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteCharValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteCharValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteCharValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteCharValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteCharValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteCharValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteCharValue_GetNext(This,pjch)	\
    (This)->lpVtbl -> GetNext(This,pjch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteCharValue_GetNext_Proxy( 
    IJavaEnumRemoteCharValue __RPC_FAR * This,
    /* [out] */ JAVA_CHAR __RPC_FAR *pjch);


void __RPC_STUB IJavaEnumRemoteCharValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteCharValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDoubleValue_INTERFACE_DEFINED__
#define __IEnumRemoteDoubleValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteDoubleValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteDoubleValue __RPC_FAR *LPENUMREMOTEDOUBLEVALUE;


EXTERN_C const IID IID_IEnumRemoteDoubleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteDoubleValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteDoubleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteDoubleValueVtbl;

    interface IEnumRemoteDoubleValue
    {
        CONST_VTBL struct IEnumRemoteDoubleValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDoubleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteDoubleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteDoubleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteDoubleValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteDoubleValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteDoubleValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteDoubleValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteDoubleValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteDoubleValue_Next_Proxy( 
    IEnumRemoteDoubleValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteDoubleValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteDoubleValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteDoubleValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteDoubleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteDoubleValue : public IEnumRemoteDoubleValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteDoubleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_DOUBLE __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteDoubleValue __RPC_FAR * This,
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl);
        
        END_INTERFACE
    } IJavaEnumRemoteDoubleValueVtbl;

    interface IJavaEnumRemoteDoubleValue
    {
        CONST_VTBL struct IJavaEnumRemoteDoubleValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteDoubleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteDoubleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteDoubleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteDoubleValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteDoubleValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteDoubleValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteDoubleValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteDoubleValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteDoubleValue_GetNext(This,pjdbl)	\
    (This)->lpVtbl -> GetNext(This,pjdbl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteDoubleValue_GetNext_Proxy( 
    IJavaEnumRemoteDoubleValue __RPC_FAR * This,
    /* [out] */ JAVA_DOUBLE __RPC_FAR *pjdbl);


void __RPC_STUB IJavaEnumRemoteDoubleValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteDoubleValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteFloatValue_INTERFACE_DEFINED__
#define __IEnumRemoteFloatValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteFloatValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteFloatValue __RPC_FAR *LPENUMREMOTEFLOATVALUE;


EXTERN_C const IID IID_IEnumRemoteFloatValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteFloatValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteFloatValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteFloatValueVtbl;

    interface IEnumRemoteFloatValue
    {
        CONST_VTBL struct IEnumRemoteFloatValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteFloatValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteFloatValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteFloatValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteFloatValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteFloatValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteFloatValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteFloatValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteFloatValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteFloatValue_Next_Proxy( 
    IEnumRemoteFloatValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteFloatValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteFloatValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteFloatValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteFloatValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteFloatValue : public IEnumRemoteFloatValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteFloatValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_FLOAT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteFloatValue __RPC_FAR * This,
            /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt);
        
        END_INTERFACE
    } IJavaEnumRemoteFloatValueVtbl;

    interface IJavaEnumRemoteFloatValue
    {
        CONST_VTBL struct IJavaEnumRemoteFloatValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteFloatValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteFloatValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteFloatValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteFloatValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteFloatValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteFloatValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteFloatValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteFloatValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteFloatValue_GetNext(This,pjflt)	\
    (This)->lpVtbl -> GetNext(This,pjflt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteFloatValue_GetNext_Proxy( 
    IJavaEnumRemoteFloatValue __RPC_FAR * This,
    /* [out] */ JAVA_FLOAT __RPC_FAR *pjflt);


void __RPC_STUB IJavaEnumRemoteFloatValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteFloatValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteIntValue_INTERFACE_DEFINED__
#define __IEnumRemoteIntValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteIntValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteIntValue __RPC_FAR *LPENUMREMOTEINTVALUE;


EXTERN_C const IID IID_IEnumRemoteIntValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteIntValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteIntValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteIntValueVtbl;

    interface IEnumRemoteIntValue
    {
        CONST_VTBL struct IEnumRemoteIntValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteIntValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteIntValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteIntValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteIntValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteIntValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteIntValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteIntValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteIntValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteIntValue_Next_Proxy( 
    IEnumRemoteIntValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteIntValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteIntValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteIntValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteIntValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteIntValue : public IEnumRemoteIntValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_INT __RPC_FAR *pjn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteIntValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_INT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteIntValue __RPC_FAR * This,
            /* [out] */ JAVA_INT __RPC_FAR *pjn);
        
        END_INTERFACE
    } IJavaEnumRemoteIntValueVtbl;

    interface IJavaEnumRemoteIntValue
    {
        CONST_VTBL struct IJavaEnumRemoteIntValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteIntValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteIntValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteIntValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteIntValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteIntValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteIntValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteIntValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteIntValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteIntValue_GetNext(This,pjn)	\
    (This)->lpVtbl -> GetNext(This,pjn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteIntValue_GetNext_Proxy( 
    IJavaEnumRemoteIntValue __RPC_FAR * This,
    /* [out] */ JAVA_INT __RPC_FAR *pjn);


void __RPC_STUB IJavaEnumRemoteIntValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteIntValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteLongValue_INTERFACE_DEFINED__
#define __IEnumRemoteLongValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteLongValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteLongValue __RPC_FAR *LPENUMREMOTELONGVALUE;


EXTERN_C const IID IID_IEnumRemoteLongValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteLongValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteLongValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteLongValueVtbl;

    interface IEnumRemoteLongValue
    {
        CONST_VTBL struct IEnumRemoteLongValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteLongValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteLongValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteLongValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteLongValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteLongValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteLongValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteLongValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteLongValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteLongValue_Next_Proxy( 
    IEnumRemoteLongValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteLongValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteLongValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteLongValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteLongValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteLongValue : public IEnumRemoteLongValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_LONG __RPC_FAR *pjl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteLongValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_LONG __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteLongValue __RPC_FAR * This,
            /* [out] */ JAVA_LONG __RPC_FAR *pjl);
        
        END_INTERFACE
    } IJavaEnumRemoteLongValueVtbl;

    interface IJavaEnumRemoteLongValue
    {
        CONST_VTBL struct IJavaEnumRemoteLongValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteLongValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteLongValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteLongValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteLongValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteLongValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteLongValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteLongValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteLongValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteLongValue_GetNext(This,pjl)	\
    (This)->lpVtbl -> GetNext(This,pjl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteLongValue_GetNext_Proxy( 
    IJavaEnumRemoteLongValue __RPC_FAR * This,
    /* [out] */ JAVA_LONG __RPC_FAR *pjl);


void __RPC_STUB IJavaEnumRemoteLongValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteLongValue_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteShortValue_INTERFACE_DEFINED__
#define __IEnumRemoteShortValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteShortValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteShortValue __RPC_FAR *LPENUMREMOTESHORTVALUE;


EXTERN_C const IID IID_IEnumRemoteShortValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteShortValue : public IEnumRemoteValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteShortValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumRemoteShortValueVtbl;

    interface IEnumRemoteShortValue
    {
        CONST_VTBL struct IEnumRemoteShortValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteShortValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteShortValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteShortValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteShortValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteShortValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteShortValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRemoteShortValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IEnumRemoteShortValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteShortValue_Next_Proxy( 
    IEnumRemoteShortValue __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteShortValue_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteShortValue_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__
#define __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteShortValue
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteShortValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteShortValue : public IEnumRemoteShortValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ JAVA_SHORT __RPC_FAR *pjsh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteShortValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ JAVA_SHORT __RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteShortValue __RPC_FAR * This,
            /* [out] */ JAVA_SHORT __RPC_FAR *pjsh);
        
        END_INTERFACE
    } IJavaEnumRemoteShortValueVtbl;

    interface IJavaEnumRemoteShortValue
    {
        CONST_VTBL struct IJavaEnumRemoteShortValueVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteShortValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteShortValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteShortValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteShortValue_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteShortValue_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteShortValue_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IJavaEnumRemoteShortValue_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define IJavaEnumRemoteShortValue_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)


#define IJavaEnumRemoteShortValue_GetNext(This,pjsh)	\
    (This)->lpVtbl -> GetNext(This,pjsh)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteShortValue_GetNext_Proxy( 
    IJavaEnumRemoteShortValue __RPC_FAR * This,
    /* [out] */ JAVA_SHORT __RPC_FAR *pjsh);


void __RPC_STUB IJavaEnumRemoteShortValue_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteShortValue_INTERFACE_DEFINED__ */


#ifndef __IRemoteArrayObject_INTERFACE_DEFINED__
#define __IRemoteArrayObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteArrayObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteArrayObject __RPC_FAR *LPREMOTEARRAYOBJECT;


EXTERN_C const IID IID_IRemoteArrayObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteArrayObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElementObjects( 
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcElements) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementValues( 
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteArrayObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteArrayObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElementObjects )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcElements);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElementValues )( 
            IRemoteArrayObject __RPC_FAR * This,
            /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteArrayObjectVtbl;

    interface IRemoteArrayObject
    {
        CONST_VTBL struct IRemoteArrayObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteArrayObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteArrayObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteArrayObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteArrayObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteArrayObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteArrayObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteArrayObject_GetElementObjects(This,ppEnum)	\
    (This)->lpVtbl -> GetElementObjects(This,ppEnum)

#define IRemoteArrayObject_GetSize(This,pcElements)	\
    (This)->lpVtbl -> GetSize(This,pcElements)

#define IRemoteArrayObject_GetElementValues(This,ppEnum)	\
    (This)->lpVtbl -> GetElementValues(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetElementObjects_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteArrayObject_GetElementObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetSize_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcElements);


void __RPC_STUB IRemoteArrayObject_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteArrayObject_GetElementValues_Proxy( 
    IRemoteArrayObject __RPC_FAR * This,
    /* [out] */ IEnumRemoteValue __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteArrayObject_GetElementValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteArrayObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteBooleanObject_INTERFACE_DEFINED__
#define __IRemoteBooleanObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteBooleanObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteBooleanObject __RPC_FAR *LPREMOTEBOOLEANOBJECT;


EXTERN_C const IID IID_IRemoteBooleanObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteBooleanObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_BOOLEAN value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteBooleanObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteBooleanObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteBooleanObject __RPC_FAR * This,
            /* [in] */ JAVA_BOOLEAN value);
        
        END_INTERFACE
    } IRemoteBooleanObjectVtbl;

    interface IRemoteBooleanObject
    {
        CONST_VTBL struct IRemoteBooleanObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteBooleanObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteBooleanObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteBooleanObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteBooleanObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteBooleanObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteBooleanObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteBooleanObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteBooleanObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteBooleanObject_GetValue_Proxy( 
    IRemoteBooleanObject __RPC_FAR * This,
    /* [out] */ JAVA_BOOLEAN __RPC_FAR *pvalue);


void __RPC_STUB IRemoteBooleanObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteBooleanObject_SetValue_Proxy( 
    IRemoteBooleanObject __RPC_FAR * This,
    /* [in] */ JAVA_BOOLEAN value);


void __RPC_STUB IRemoteBooleanObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteBooleanObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteByteObject_INTERFACE_DEFINED__
#define __IRemoteByteObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteByteObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteByteObject __RPC_FAR *LPREMOTEBYTEOBJECT;


EXTERN_C const IID IID_IRemoteByteObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteByteObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_BYTE __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_BYTE value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteByteObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteByteObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteByteObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [out] */ JAVA_BYTE __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteByteObject __RPC_FAR * This,
            /* [in] */ JAVA_BYTE value);
        
        END_INTERFACE
    } IRemoteByteObjectVtbl;

    interface IRemoteByteObject
    {
        CONST_VTBL struct IRemoteByteObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteByteObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteByteObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteByteObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteByteObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteByteObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteByteObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteByteObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteByteObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteByteObject_GetValue_Proxy( 
    IRemoteByteObject __RPC_FAR * This,
    /* [out] */ JAVA_BYTE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteByteObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteByteObject_SetValue_Proxy( 
    IRemoteByteObject __RPC_FAR * This,
    /* [in] */ JAVA_BYTE value);


void __RPC_STUB IRemoteByteObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteByteObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteCharObject_INTERFACE_DEFINED__
#define __IRemoteCharObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteCharObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteCharObject __RPC_FAR *LPREMOTECHAROBJECT;


EXTERN_C const IID IID_IRemoteCharObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteCharObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_CHAR __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_CHAR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteCharObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteCharObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteCharObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [out] */ JAVA_CHAR __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteCharObject __RPC_FAR * This,
            /* [in] */ JAVA_CHAR value);
        
        END_INTERFACE
    } IRemoteCharObjectVtbl;

    interface IRemoteCharObject
    {
        CONST_VTBL struct IRemoteCharObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteCharObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteCharObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteCharObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteCharObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteCharObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteCharObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteCharObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteCharObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteCharObject_GetValue_Proxy( 
    IRemoteCharObject __RPC_FAR * This,
    /* [out] */ JAVA_CHAR __RPC_FAR *pvalue);


void __RPC_STUB IRemoteCharObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteCharObject_SetValue_Proxy( 
    IRemoteCharObject __RPC_FAR * This,
    /* [in] */ JAVA_CHAR value);


void __RPC_STUB IRemoteCharObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteCharObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteContainerObject_INTERFACE_DEFINED__
#define __IRemoteContainerObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteContainerObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteContainerObject __RPC_FAR *LPREMOTECONTAINEROBJECT;


EXTERN_C const IID IID_IRemoteContainerObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteContainerObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFieldObject( 
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteContainerObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteContainerObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldObject )( 
            IRemoteContainerObject __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);
        
        END_INTERFACE
    } IRemoteContainerObjectVtbl;

    interface IRemoteContainerObject
    {
        CONST_VTBL struct IRemoteContainerObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteContainerObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteContainerObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteContainerObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteContainerObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteContainerObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteContainerObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteContainerObject_GetFieldObject(This,pField,ppFieldObject)	\
    (This)->lpVtbl -> GetFieldObject(This,pField,ppFieldObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteContainerObject_GetFieldObject_Proxy( 
    IRemoteContainerObject __RPC_FAR * This,
    /* [unique][in] */ IRemoteField __RPC_FAR *pField,
    /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);


void __RPC_STUB IRemoteContainerObject_GetFieldObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteContainerObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteClassObject_INTERFACE_DEFINED__
#define __IRemoteClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteClassObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteClassObject __RPC_FAR *LPREMOTECLASSOBJECT;


EXTERN_C const IID IID_IRemoteClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteClassObject : public IRemoteContainerObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDerivedMostType( 
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldObject )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [unique][in] */ IRemoteField __RPC_FAR *pField,
            /* [out] */ IRemoteObject __RPC_FAR *__RPC_FAR *ppFieldObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDerivedMostType )( 
            IRemoteClassObject __RPC_FAR * This,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField);
        
        END_INTERFACE
    } IRemoteClassObjectVtbl;

    interface IRemoteClassObject
    {
        CONST_VTBL struct IRemoteClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteClassObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteClassObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteClassObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteClassObject_GetFieldObject(This,pField,ppFieldObject)	\
    (This)->lpVtbl -> GetFieldObject(This,pField,ppFieldObject)


#define IRemoteClassObject_GetDerivedMostType(This,ppDerivedMostField)	\
    (This)->lpVtbl -> GetDerivedMostType(This,ppDerivedMostField)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteClassObject_GetDerivedMostType_Proxy( 
    IRemoteClassObject __RPC_FAR * This,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppDerivedMostField);


void __RPC_STUB IRemoteClassObject_GetDerivedMostType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteClassObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteDoubleObject_INTERFACE_DEFINED__
#define __IRemoteDoubleObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDoubleObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDoubleObject __RPC_FAR *LPREMOTEDOUBLEOBJECT;


EXTERN_C const IID IID_IRemoteDoubleObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDoubleObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDoubleObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteDoubleObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteDoubleObject __RPC_FAR * This,
            /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue);
        
        END_INTERFACE
    } IRemoteDoubleObjectVtbl;

    interface IRemoteDoubleObject
    {
        CONST_VTBL struct IRemoteDoubleObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDoubleObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDoubleObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDoubleObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDoubleObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteDoubleObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteDoubleObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteDoubleObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteDoubleObject_SetValue(This,pvalue)	\
    (This)->lpVtbl -> SetValue(This,pvalue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDoubleObject_GetValue_Proxy( 
    IRemoteDoubleObject __RPC_FAR * This,
    /* [out] */ JAVA_DOUBLE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteDoubleObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDoubleObject_SetValue_Proxy( 
    IRemoteDoubleObject __RPC_FAR * This,
    /* [in] */ JAVA_DOUBLE __RPC_FAR *pvalue);


void __RPC_STUB IRemoteDoubleObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDoubleObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteFloatObject_INTERFACE_DEFINED__
#define __IRemoteFloatObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteFloatObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteFloatObject __RPC_FAR *LPREMOTEFLOATOBJECT;


EXTERN_C const IID IID_IRemoteFloatObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteFloatObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteFloatObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteFloatObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteFloatObject __RPC_FAR * This,
            /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue);
        
        END_INTERFACE
    } IRemoteFloatObjectVtbl;

    interface IRemoteFloatObject
    {
        CONST_VTBL struct IRemoteFloatObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteFloatObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteFloatObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteFloatObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteFloatObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteFloatObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteFloatObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteFloatObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteFloatObject_SetValue(This,pvalue)	\
    (This)->lpVtbl -> SetValue(This,pvalue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteFloatObject_GetValue_Proxy( 
    IRemoteFloatObject __RPC_FAR * This,
    /* [out] */ JAVA_FLOAT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteFloatObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteFloatObject_SetValue_Proxy( 
    IRemoteFloatObject __RPC_FAR * This,
    /* [in] */ JAVA_FLOAT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteFloatObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteFloatObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteIntObject_INTERFACE_DEFINED__
#define __IRemoteIntObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteIntObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteIntObject __RPC_FAR *LPREMOTEINTOBJECT;


EXTERN_C const IID IID_IRemoteIntObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteIntObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_INT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_INT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteIntObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteIntObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteIntObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [out] */ JAVA_INT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteIntObject __RPC_FAR * This,
            /* [in] */ JAVA_INT value);
        
        END_INTERFACE
    } IRemoteIntObjectVtbl;

    interface IRemoteIntObject
    {
        CONST_VTBL struct IRemoteIntObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteIntObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteIntObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteIntObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteIntObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteIntObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteIntObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteIntObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteIntObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteIntObject_GetValue_Proxy( 
    IRemoteIntObject __RPC_FAR * This,
    /* [out] */ JAVA_INT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteIntObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteIntObject_SetValue_Proxy( 
    IRemoteIntObject __RPC_FAR * This,
    /* [in] */ JAVA_INT value);


void __RPC_STUB IRemoteIntObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteIntObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteLongObject_INTERFACE_DEFINED__
#define __IRemoteLongObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteLongObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteLongObject __RPC_FAR *LPREMOTELONGOBJECT;


EXTERN_C const IID IID_IRemoteLongObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteLongObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_LONG __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_LONG value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteLongObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteLongObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteLongObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [out] */ JAVA_LONG __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteLongObject __RPC_FAR * This,
            /* [in] */ JAVA_LONG value);
        
        END_INTERFACE
    } IRemoteLongObjectVtbl;

    interface IRemoteLongObject
    {
        CONST_VTBL struct IRemoteLongObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteLongObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteLongObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteLongObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteLongObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteLongObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteLongObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteLongObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteLongObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteLongObject_GetValue_Proxy( 
    IRemoteLongObject __RPC_FAR * This,
    /* [out] */ JAVA_LONG __RPC_FAR *pvalue);


void __RPC_STUB IRemoteLongObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteLongObject_SetValue_Proxy( 
    IRemoteLongObject __RPC_FAR * This,
    /* [in] */ JAVA_LONG value);


void __RPC_STUB IRemoteLongObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteLongObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteShortObject_INTERFACE_DEFINED__
#define __IRemoteShortObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteShortObject
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteShortObject __RPC_FAR *LPREMOTESHORTOBJECT;


EXTERN_C const IID IID_IRemoteShortObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteShortObject : public IRemoteObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ JAVA_SHORT __RPC_FAR *pvalue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ JAVA_SHORT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteShortObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteShortObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [out] */ IRemoteField __RPC_FAR *__RPC_FAR *ppType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakpoint )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearBreakpoint )( 
            IRemoteShortObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [out] */ JAVA_SHORT __RPC_FAR *pvalue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IRemoteShortObject __RPC_FAR * This,
            /* [in] */ JAVA_SHORT value);
        
        END_INTERFACE
    } IRemoteShortObjectVtbl;

    interface IRemoteShortObject
    {
        CONST_VTBL struct IRemoteShortObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteShortObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteShortObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteShortObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteShortObject_GetType(This,ppType)	\
    (This)->lpVtbl -> GetType(This,ppType)

#define IRemoteShortObject_SetBreakpoint(This)	\
    (This)->lpVtbl -> SetBreakpoint(This)

#define IRemoteShortObject_ClearBreakpoint(This)	\
    (This)->lpVtbl -> ClearBreakpoint(This)


#define IRemoteShortObject_GetValue(This,pvalue)	\
    (This)->lpVtbl -> GetValue(This,pvalue)

#define IRemoteShortObject_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteShortObject_GetValue_Proxy( 
    IRemoteShortObject __RPC_FAR * This,
    /* [out] */ JAVA_SHORT __RPC_FAR *pvalue);


void __RPC_STUB IRemoteShortObject_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteShortObject_SetValue_Proxy( 
    IRemoteShortObject __RPC_FAR * This,
    /* [in] */ JAVA_SHORT value);


void __RPC_STUB IRemoteShortObject_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteShortObject_INTERFACE_DEFINED__ */


#ifndef __IRemoteStackFrame_INTERFACE_DEFINED__
#define __IRemoteStackFrame_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteStackFrame
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteStackFrame __RPC_FAR *LPREMOTESTACKOBJECT;


enum __MIDL_IRemoteStackFrame_0001
    {	FRAME_KIND_INVALID	= 0,
	FRAME_KIND_INTERPRETED	= 0x1,
	FRAME_KIND_NATIVE	= 0x2,
	FRAME_KIND_JIT_COMPILED	= 0x3
    };
typedef ULONG FRAMEKIND;


EXTERN_C const IID IID_IRemoteStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteStackFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallingFrame( 
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodObject( 
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPC( 
            /* [out] */ ULONG __RPC_FAR *offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPC( 
            /* [in] */ ULONG offPC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKind( 
            /* [out] */ FRAMEKIND __RPC_FAR *pfk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteStackFrame __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteStackFrame __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallingFrame )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodObject )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPC )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPC )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [in] */ ULONG offPC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKind )( 
            IRemoteStackFrame __RPC_FAR * This,
            /* [out] */ FRAMEKIND __RPC_FAR *pfk);
        
        END_INTERFACE
    } IRemoteStackFrameVtbl;

    interface IRemoteStackFrame
    {
        CONST_VTBL struct IRemoteStackFrameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteStackFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteStackFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteStackFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteStackFrame_GetCallingFrame(This,ppCallingFrame)	\
    (This)->lpVtbl -> GetCallingFrame(This,ppCallingFrame)

#define IRemoteStackFrame_GetMethodObject(This,ppMethodObject)	\
    (This)->lpVtbl -> GetMethodObject(This,ppMethodObject)

#define IRemoteStackFrame_GetPC(This,offPC)	\
    (This)->lpVtbl -> GetPC(This,offPC)

#define IRemoteStackFrame_SetPC(This,offPC)	\
    (This)->lpVtbl -> SetPC(This,offPC)

#define IRemoteStackFrame_GetKind(This,pfk)	\
    (This)->lpVtbl -> GetKind(This,pfk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetCallingFrame_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCallingFrame);


void __RPC_STUB IRemoteStackFrame_GetCallingFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetMethodObject_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppMethodObject);


void __RPC_STUB IRemoteStackFrame_GetMethodObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetPC_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *offPC);


void __RPC_STUB IRemoteStackFrame_GetPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_SetPC_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [in] */ ULONG offPC);


void __RPC_STUB IRemoteStackFrame_SetPC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteStackFrame_GetKind_Proxy( 
    IRemoteStackFrame __RPC_FAR * This,
    /* [out] */ FRAMEKIND __RPC_FAR *pfk);


void __RPC_STUB IRemoteStackFrame_GetKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteStackFrame_INTERFACE_DEFINED__ */


#ifndef __IRemoteThreadGroup_INTERFACE_DEFINED__
#define __IRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteThreadGroup __RPC_FAR *LPREMOTETHREADGROUP;


EXTERN_C const IID IID_IRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteThreadGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreads( 
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroups( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreads )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroups )( 
            IRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteThreadGroupVtbl;

    interface IRemoteThreadGroup
    {
        CONST_VTBL struct IRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteThreadGroup_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteThreadGroup_GetThreads(This,ppEnum)	\
    (This)->lpVtbl -> GetThreads(This,ppEnum)

#define IRemoteThreadGroup_GetThreadGroups(This,ppEnum)	\
    (This)->lpVtbl -> GetThreadGroups(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetName_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteThreadGroup_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetThreads_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteThreadGroup_GetThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThreadGroup_GetThreadGroups_Proxy( 
    IRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteThreadGroup_GetThreadGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteThreadGroup_INTERFACE_DEFINED__
#define __IEnumRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteThreadGroup __RPC_FAR *LPENUMREMOTETHREADGROUP;


EXTERN_C const IID IID_IEnumRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteThreadGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteThreadGroupVtbl;

    interface IEnumRemoteThreadGroup
    {
        CONST_VTBL struct IEnumRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteThreadGroup_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteThreadGroup_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteThreadGroup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteThreadGroup_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Next_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteThreadGroup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Skip_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteThreadGroup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Reset_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This);


void __RPC_STUB IEnumRemoteThreadGroup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThreadGroup_Clone_Proxy( 
    IEnumRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteThreadGroup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__
#define __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteThreadGroup
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteThreadGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteThreadGroup : public IEnumRemoteThreadGroup
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteThreadGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteThreadGroup __RPC_FAR * This,
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg);
        
        END_INTERFACE
    } IJavaEnumRemoteThreadGroupVtbl;

    interface IJavaEnumRemoteThreadGroup
    {
        CONST_VTBL struct IJavaEnumRemoteThreadGroupVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteThreadGroup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteThreadGroup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteThreadGroup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteThreadGroup_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteThreadGroup_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteThreadGroup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteThreadGroup_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteThreadGroup_GetNext(This,ppirtg)	\
    (This)->lpVtbl -> GetNext(This,ppirtg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteThreadGroup_GetNext_Proxy( 
    IJavaEnumRemoteThreadGroup __RPC_FAR * This,
    /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppirtg);


void __RPC_STUB IJavaEnumRemoteThreadGroup_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteThreadGroup_INTERFACE_DEFINED__ */


#ifndef __IRemoteThread_INTERFACE_DEFINED__
#define __IRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteThread __RPC_FAR *LPREMOTETHREAD;


EXTERN_C const IID IID_IRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentFrame( 
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroup( 
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Go( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepIn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeStep( 
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeStepIn( 
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuspendCount( 
            /* [out] */ ULONG __RPC_FAR *pcSuspend) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentFrame )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroup )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Go )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Step )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepIn )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepOut )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeStep )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeStepIn )( 
            IRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG offStart,
            /* [in] */ ULONG offEnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuspendCount )( 
            IRemoteThread __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcSuspend);
        
        END_INTERFACE
    } IRemoteThreadVtbl;

    interface IRemoteThread
    {
        CONST_VTBL struct IRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteThread_GetName(This,ppszName)	\
    (This)->lpVtbl -> GetName(This,ppszName)

#define IRemoteThread_GetCurrentFrame(This,ppCurrentFrame)	\
    (This)->lpVtbl -> GetCurrentFrame(This,ppCurrentFrame)

#define IRemoteThread_GetThreadGroup(This,ppThreadGroup)	\
    (This)->lpVtbl -> GetThreadGroup(This,ppThreadGroup)

#define IRemoteThread_Go(This)	\
    (This)->lpVtbl -> Go(This)

#define IRemoteThread_Step(This)	\
    (This)->lpVtbl -> Step(This)

#define IRemoteThread_StepIn(This)	\
    (This)->lpVtbl -> StepIn(This)

#define IRemoteThread_StepOut(This)	\
    (This)->lpVtbl -> StepOut(This)

#define IRemoteThread_RangeStep(This,offStart,offEnd)	\
    (This)->lpVtbl -> RangeStep(This,offStart,offEnd)

#define IRemoteThread_RangeStepIn(This,offStart,offEnd)	\
    (This)->lpVtbl -> RangeStepIn(This,offStart,offEnd)

#define IRemoteThread_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IRemoteThread_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IRemoteThread_Resume(This)	\
    (This)->lpVtbl -> Resume(This)

#define IRemoteThread_GetSuspendCount(This,pcSuspend)	\
    (This)->lpVtbl -> GetSuspendCount(This,pcSuspend)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteThread_GetName_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszName);


void __RPC_STUB IRemoteThread_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetCurrentFrame_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteStackFrame __RPC_FAR *__RPC_FAR *ppCurrentFrame);


void __RPC_STUB IRemoteThread_GetCurrentFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetThreadGroup_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppThreadGroup);


void __RPC_STUB IRemoteThread_GetThreadGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Go_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Go_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Step_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_StepIn_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_StepIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_StepOut_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_StepOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_RangeStep_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG offStart,
    /* [in] */ ULONG offEnd);


void __RPC_STUB IRemoteThread_RangeStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_RangeStepIn_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG offStart,
    /* [in] */ ULONG offEnd);


void __RPC_STUB IRemoteThread_RangeStepIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Destroy_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Suspend_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_Resume_Proxy( 
    IRemoteThread __RPC_FAR * This);


void __RPC_STUB IRemoteThread_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteThread_GetSuspendCount_Proxy( 
    IRemoteThread __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcSuspend);


void __RPC_STUB IRemoteThread_GetSuspendCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteThread_INTERFACE_DEFINED__
#define __IEnumRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteThread __RPC_FAR *LPENUMREMOTETHREAD;


EXTERN_C const IID IID_IEnumRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteThreadVtbl;

    interface IEnumRemoteThread
    {
        CONST_VTBL struct IEnumRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteThread_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteThread_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteThread_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteThread_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Next_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteThread_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Skip_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteThread_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Reset_Proxy( 
    IEnumRemoteThread __RPC_FAR * This);


void __RPC_STUB IEnumRemoteThread_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteThread_Clone_Proxy( 
    IEnumRemoteThread __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteThread_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteThread_INTERFACE_DEFINED__
#define __IJavaEnumRemoteThread_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteThread
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteThread : public IEnumRemoteThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteThread __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThread __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteThread __RPC_FAR * This,
            /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt);
        
        END_INTERFACE
    } IJavaEnumRemoteThreadVtbl;

    interface IJavaEnumRemoteThread
    {
        CONST_VTBL struct IJavaEnumRemoteThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteThread_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteThread_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteThread_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteThread_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteThread_GetNext(This,ppt)	\
    (This)->lpVtbl -> GetNext(This,ppt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteThread_GetNext_Proxy( 
    IJavaEnumRemoteThread __RPC_FAR * This,
    /* [out] */ IRemoteThread __RPC_FAR *__RPC_FAR *ppt);


void __RPC_STUB IJavaEnumRemoteThread_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteThread_INTERFACE_DEFINED__ */


#ifndef __IRemoteProcessCallback_INTERFACE_DEFINED__
#define __IRemoteProcessCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteProcessCallback
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteProcessCallback __RPC_FAR *LPREMOTEPROCESSCALLBACK;


enum __MIDL_IRemoteProcessCallback_0001
    {	EXCEPTION_KIND_FIRST_CHANCE	= 0x1,
	EXCEPTION_KIND_LAST_CHANCE	= 0x2
    };
typedef ULONG EXCEPTIONKIND;


EXTERN_C const IID IID_IRemoteProcessCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteProcessCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DebugStringEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [in] */ LPCOLESTR pszDebugString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CodeBreakpointEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DataBreakpointEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteObject __RPC_FAR *pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
            /* [in] */ EXCEPTIONKIND exceptionKind) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStopEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadCreateEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadGroupCreateEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadGroupDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDestroyEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TraceEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadCompleteEvent( 
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteProcessCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteProcessCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteProcessCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugStringEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [in] */ LPCOLESTR pszDebugString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CodeBreakpointEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataBreakpointEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteObject __RPC_FAR *pObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExceptionEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
            /* [in] */ EXCEPTIONKIND exceptionKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanStopEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BreakEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadCreateEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadGroupCreateEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadGroupDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClassLoadEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClassUnloadEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
            /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessDestroyEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TraceEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadCompleteEvent )( 
            IRemoteProcessCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);
        
        END_INTERFACE
    } IRemoteProcessCallbackVtbl;

    interface IRemoteProcessCallback
    {
        CONST_VTBL struct IRemoteProcessCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteProcessCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteProcessCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteProcessCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteProcessCallback_DebugStringEvent(This,pThread,pszDebugString)	\
    (This)->lpVtbl -> DebugStringEvent(This,pThread,pszDebugString)

#define IRemoteProcessCallback_CodeBreakpointEvent(This,pThread)	\
    (This)->lpVtbl -> CodeBreakpointEvent(This,pThread)

#define IRemoteProcessCallback_DataBreakpointEvent(This,pThread,pObject)	\
    (This)->lpVtbl -> DataBreakpointEvent(This,pThread,pObject)

#define IRemoteProcessCallback_ExceptionEvent(This,pThread,pExceptionClass,exceptionKind)	\
    (This)->lpVtbl -> ExceptionEvent(This,pThread,pExceptionClass,exceptionKind)

#define IRemoteProcessCallback_StepEvent(This,pThread)	\
    (This)->lpVtbl -> StepEvent(This,pThread)

#define IRemoteProcessCallback_CanStopEvent(This,pThread)	\
    (This)->lpVtbl -> CanStopEvent(This,pThread)

#define IRemoteProcessCallback_BreakEvent(This,pThread)	\
    (This)->lpVtbl -> BreakEvent(This,pThread)

#define IRemoteProcessCallback_ThreadCreateEvent(This,pThread)	\
    (This)->lpVtbl -> ThreadCreateEvent(This,pThread)

#define IRemoteProcessCallback_ThreadDestroyEvent(This,pThread)	\
    (This)->lpVtbl -> ThreadDestroyEvent(This,pThread)

#define IRemoteProcessCallback_ThreadGroupCreateEvent(This,pThread,pThreadGroup)	\
    (This)->lpVtbl -> ThreadGroupCreateEvent(This,pThread,pThreadGroup)

#define IRemoteProcessCallback_ThreadGroupDestroyEvent(This,pThread,pThreadGroup)	\
    (This)->lpVtbl -> ThreadGroupDestroyEvent(This,pThread,pThreadGroup)

#define IRemoteProcessCallback_ClassLoadEvent(This,pThread,pClassType)	\
    (This)->lpVtbl -> ClassLoadEvent(This,pThread,pClassType)

#define IRemoteProcessCallback_ClassUnloadEvent(This,pThread,pClassType)	\
    (This)->lpVtbl -> ClassUnloadEvent(This,pThread,pClassType)

#define IRemoteProcessCallback_ProcessDestroyEvent(This,pThread)	\
    (This)->lpVtbl -> ProcessDestroyEvent(This,pThread)

#define IRemoteProcessCallback_TraceEvent(This,pThread)	\
    (This)->lpVtbl -> TraceEvent(This,pThread)

#define IRemoteProcessCallback_LoadCompleteEvent(This,pThread)	\
    (This)->lpVtbl -> LoadCompleteEvent(This,pThread)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_DebugStringEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [in] */ LPCOLESTR pszDebugString);


void __RPC_STUB IRemoteProcessCallback_DebugStringEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_CodeBreakpointEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_CodeBreakpointEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_DataBreakpointEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteObject __RPC_FAR *pObject);


void __RPC_STUB IRemoteProcessCallback_DataBreakpointEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ExceptionEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pExceptionClass,
    /* [in] */ EXCEPTIONKIND exceptionKind);


void __RPC_STUB IRemoteProcessCallback_ExceptionEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_StepEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_StepEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_CanStopEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_CanStopEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_BreakEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_BreakEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadCreateEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ThreadCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ThreadDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadGroupCreateEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);


void __RPC_STUB IRemoteProcessCallback_ThreadGroupCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ThreadGroupDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteThreadGroup __RPC_FAR *pThreadGroup);


void __RPC_STUB IRemoteProcessCallback_ThreadGroupDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ClassLoadEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);


void __RPC_STUB IRemoteProcessCallback_ClassLoadEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ClassUnloadEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread,
    /* [unique][in] */ IRemoteClassField __RPC_FAR *pClassType);


void __RPC_STUB IRemoteProcessCallback_ClassUnloadEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_ProcessDestroyEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_ProcessDestroyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_TraceEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_TraceEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcessCallback_LoadCompleteEvent_Proxy( 
    IRemoteProcessCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteThread __RPC_FAR *pThread);


void __RPC_STUB IRemoteProcessCallback_LoadCompleteEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteProcessCallback_INTERFACE_DEFINED__ */


#ifndef __IRemoteProcess_INTERFACE_DEFINED__
#define __IRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteProcess __RPC_FAR *LPREMOTEPROCESS;


EXTERN_C const IID IID_IRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalContainerObject( 
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClass( 
            /* [in] */ LPCOLESTR pszClassName,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TraceMethods( 
            /* [in] */ BOOL bTraceOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadGroups( 
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCallback )( 
            IRemoteProcess __RPC_FAR * This,
            /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Break )( 
            IRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGlobalContainerObject )( 
            IRemoteProcess __RPC_FAR * This,
            /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindClass )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszClassName,
            /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TraceMethods )( 
            IRemoteProcess __RPC_FAR * This,
            /* [in] */ BOOL bTraceOn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadGroups )( 
            IRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IRemoteProcessVtbl;

    interface IRemoteProcess
    {
        CONST_VTBL struct IRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteProcess_RegisterCallback(This,pCallback)	\
    (This)->lpVtbl -> RegisterCallback(This,pCallback)

#define IRemoteProcess_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IRemoteProcess_Break(This)	\
    (This)->lpVtbl -> Break(This)

#define IRemoteProcess_GetGlobalContainerObject(This,ppGlobalContainerObject)	\
    (This)->lpVtbl -> GetGlobalContainerObject(This,ppGlobalContainerObject)

#define IRemoteProcess_FindClass(This,pszClassName,ppClassType)	\
    (This)->lpVtbl -> FindClass(This,pszClassName,ppClassType)

#define IRemoteProcess_TraceMethods(This,bTraceOn)	\
    (This)->lpVtbl -> TraceMethods(This,bTraceOn)

#define IRemoteProcess_GetThreadGroups(This,ppEnum)	\
    (This)->lpVtbl -> GetThreadGroups(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteProcess_RegisterCallback_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [unique][in] */ IRemoteProcessCallback __RPC_FAR *pCallback);


void __RPC_STUB IRemoteProcess_RegisterCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_Detach_Proxy( 
    IRemoteProcess __RPC_FAR * This);


void __RPC_STUB IRemoteProcess_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_Break_Proxy( 
    IRemoteProcess __RPC_FAR * This);


void __RPC_STUB IRemoteProcess_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_GetGlobalContainerObject_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [out] */ IRemoteContainerObject __RPC_FAR *__RPC_FAR *ppGlobalContainerObject);


void __RPC_STUB IRemoteProcess_GetGlobalContainerObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_FindClass_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszClassName,
    /* [out] */ IRemoteClassField __RPC_FAR *__RPC_FAR *ppClassType);


void __RPC_STUB IRemoteProcess_FindClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_TraceMethods_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [in] */ BOOL bTraceOn);


void __RPC_STUB IRemoteProcess_TraceMethods_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteProcess_GetThreadGroups_Proxy( 
    IRemoteProcess __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteThreadGroup __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteProcess_GetThreadGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteProcess_INTERFACE_DEFINED__
#define __IEnumRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IEnumRemoteProcess __RPC_FAR *LPENUMREMOTEPROCESS;


EXTERN_C const IID IID_IEnumRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumRemoteProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumRemoteProcessVtbl;

    interface IEnumRemoteProcess
    {
        CONST_VTBL struct IEnumRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteProcess_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumRemoteProcess_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteProcess_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteProcess_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Next_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteProcess_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Skip_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteProcess_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Reset_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This);


void __RPC_STUB IEnumRemoteProcess_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteProcess_Clone_Proxy( 
    IEnumRemoteProcess __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRemoteProcess_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IJavaEnumRemoteProcess_INTERFACE_DEFINED__
#define __IJavaEnumRemoteProcess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaEnumRemoteProcess
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaEnumRemoteProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaEnumRemoteProcess : public IEnumRemoteProcess
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaEnumRemoteProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IRemoteProcess __RPC_FAR *__RPC_FAR rgelt[  ],
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IJavaEnumRemoteProcess __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IJavaEnumRemoteProcess __RPC_FAR * This,
            /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp);
        
        END_INTERFACE
    } IJavaEnumRemoteProcessVtbl;

    interface IJavaEnumRemoteProcess
    {
        CONST_VTBL struct IJavaEnumRemoteProcessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaEnumRemoteProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaEnumRemoteProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaEnumRemoteProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaEnumRemoteProcess_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IJavaEnumRemoteProcess_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IJavaEnumRemoteProcess_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IJavaEnumRemoteProcess_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)


#define IJavaEnumRemoteProcess_GetNext(This,ppirp)	\
    (This)->lpVtbl -> GetNext(This,ppirp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaEnumRemoteProcess_GetNext_Proxy( 
    IJavaEnumRemoteProcess __RPC_FAR * This,
    /* [out] */ IRemoteProcess __RPC_FAR *__RPC_FAR *ppirp);


void __RPC_STUB IJavaEnumRemoteProcess_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaEnumRemoteProcess_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugManagerCallback_INTERFACE_DEFINED__
#define __IRemoteDebugManagerCallback_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDebugManagerCallback
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDebugManagerCallback __RPC_FAR *LPREMOTEDEBUGMANAGERCALLBACK;


EXTERN_C const IID IID_IRemoteDebugManagerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDebugManagerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessCreateEvent( 
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugManagerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugManagerCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugManagerCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugManagerCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessCreateEvent )( 
            IRemoteDebugManagerCallback __RPC_FAR * This,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
            /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent);
        
        END_INTERFACE
    } IRemoteDebugManagerCallbackVtbl;

    interface IRemoteDebugManagerCallback
    {
        CONST_VTBL struct IRemoteDebugManagerCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugManagerCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugManagerCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugManagerCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugManagerCallback_ProcessCreateEvent(This,pProcessNew,pProcessParent)	\
    (This)->lpVtbl -> ProcessCreateEvent(This,pProcessNew,pProcessParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugManagerCallback_ProcessCreateEvent_Proxy( 
    IRemoteDebugManagerCallback __RPC_FAR * This,
    /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessNew,
    /* [unique][in] */ IRemoteProcess __RPC_FAR *pProcessParent);


void __RPC_STUB IRemoteDebugManagerCallback_ProcessCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDebugManagerCallback_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugManager_INTERFACE_DEFINED__
#define __IRemoteDebugManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteDebugManager
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 


typedef IRemoteDebugManager __RPC_FAR *LPREMOTEDEBUGMANAGER;


EXTERN_C const IID IID_IRemoteDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRemoteDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveProcesses( 
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCreateEvent( 
            /* [in] */ LPCOLESTR pszProcessName,
            /* [in] */ DWORD dwParentProcessId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCallback )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IRemoteDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveProcesses )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestCreateEvent )( 
            IRemoteDebugManager __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszProcessName,
            /* [in] */ DWORD dwParentProcessId);
        
        END_INTERFACE
    } IRemoteDebugManagerVtbl;

    interface IRemoteDebugManager
    {
        CONST_VTBL struct IRemoteDebugManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugManager_RegisterCallback(This,pCallback)	\
    (This)->lpVtbl -> RegisterCallback(This,pCallback)

#define IRemoteDebugManager_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IRemoteDebugManager_GetActiveProcesses(This,ppEnum)	\
    (This)->lpVtbl -> GetActiveProcesses(This,ppEnum)

#define IRemoteDebugManager_RequestCreateEvent(This,pszProcessName,dwParentProcessId)	\
    (This)->lpVtbl -> RequestCreateEvent(This,pszProcessName,dwParentProcessId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugManager_RegisterCallback_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [unique][in] */ IRemoteDebugManagerCallback __RPC_FAR *pCallback);


void __RPC_STUB IRemoteDebugManager_RegisterCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_Detach_Proxy( 
    IRemoteDebugManager __RPC_FAR * This);


void __RPC_STUB IRemoteDebugManager_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_GetActiveProcesses_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [out] */ IJavaEnumRemoteProcess __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IRemoteDebugManager_GetActiveProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugManager_RequestCreateEvent_Proxy( 
    IRemoteDebugManager __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszProcessName,
    /* [in] */ DWORD dwParentProcessId);


void __RPC_STUB IRemoteDebugManager_RequestCreateEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDebugManager_INTERFACE_DEFINED__ */


#ifndef __IJavaDebugManager_INTERFACE_DEFINED__
#define __IJavaDebugManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IJavaDebugManager
 * at Wed Sep 25 22:22:04 1996
 * using MIDL 3.00.15
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IJavaDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IJavaDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterRemoteDebugManager( 
            /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
            /* [in] */ DWORD dwProcessID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJavaDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IJavaDebugManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IJavaDebugManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IJavaDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterRemoteDebugManager )( 
            IJavaDebugManager __RPC_FAR * This,
            /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
            /* [in] */ DWORD dwProcessID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IJavaDebugManager __RPC_FAR * This);
        
        END_INTERFACE
    } IJavaDebugManagerVtbl;

    interface IJavaDebugManager
    {
        CONST_VTBL struct IJavaDebugManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJavaDebugManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IJavaDebugManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IJavaDebugManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IJavaDebugManager_RegisterRemoteDebugManager(This,pirdm,dwProcessID)	\
    (This)->lpVtbl -> RegisterRemoteDebugManager(This,pirdm,dwProcessID)

#define IJavaDebugManager_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IJavaDebugManager_RegisterRemoteDebugManager_Proxy( 
    IJavaDebugManager __RPC_FAR * This,
    /* [unique][in] */ IRemoteDebugManager __RPC_FAR *pirdm,
    /* [in] */ DWORD dwProcessID);


void __RPC_STUB IJavaDebugManager_RegisterRemoteDebugManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IJavaDebugManager_Detach_Proxy( 
    IJavaDebugManager __RPC_FAR * This);


void __RPC_STUB IJavaDebugManager_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IJavaDebugManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\java20\include\native.h ===
// (C) Copyright 1996-1997, Microsoft Corporation and it suppliers.

//----------------------------------------------------------------------------
// Public header for facilities provided by MSJava.dll
//----------------------------------------------------------------------------

#ifndef _NATIVE_
#define _NATIVE_

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// Since handles have gone away, this is no op. The unhands() in this file
// a redundant but useful for clarity.
// Note: You can not just unhand an array to get at it's data, you must now 
// use unhand(x)->body.
//----------------------------------------------------------------------------
#define unhand(phobj) (phobj)

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#define JAVAPKG	"java/lang/"

//----------------------------------------------------------------------------
// Standard Java declarations for built in types.
//----------------------------------------------------------------------------
typedef long OBJECT;
typedef OBJECT Classjava_lang_Object;
typedef OBJECT Hjava_lang_Object;
typedef OBJECT ClassObject;
typedef Hjava_lang_Object JHandle;
typedef Hjava_lang_Object HObject;

typedef unsigned short unicode;
typedef long int32_t;
typedef __int64 int64_t;
typedef int BOOL;
typedef void *PVOID;    
typedef unsigned long DWORD;
#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif
#ifndef VOID
#define VOID void
#endif
#ifndef _BOOL_T_DEFINED
#define _BOOL_T_DEFINED
typedef BOOL bool_t;
#endif

//----------------------------------------------------------------------------
// All RNI DLLs should export the following function to let the VM determine
// if the DLL is compatible with it.
//----------------------------------------------------------------------------

DWORD __cdecl RNIGetCompatibleVersion();

#ifndef RNIVER
#define RNIMAJORVER         2
#define RNIMINORVER         0
#define RNIVER              ((((DWORD) RNIMAJORVER) << 16) + (DWORD) RNIMINORVER)
#endif

//----------------------------------------------------------------------------
// Use to get the length of an array an HObject.
//----------------------------------------------------------------------------
#define obj_length(hobj) (((ArrayOfSomething*)unhand(hobj))->length)

//----------------------------------------------------------------------------
// Thread entry/exit functions.
// These functions should wrap any calls into the virtual machine.
//----------------------------------------------------------------------------
typedef struct {
	DWORD	reserved[6];
} ThreadEntryFrame;

BOOL __cdecl PrepareThreadForJava(PVOID pThreadEntryFrame);
VOID __cdecl UnprepareThreadForJava(PVOID pThreadEntryFrame);

//----------------------------------------------------------------------------
// Garbage Collection.
//----------------------------------------------------------------------------
typedef struct {
	DWORD	reserved[6];
} GCFrame;

void    __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, 
                DWORD cbObjectStructSize);
void    __cdecl GCFramePop(PVOID pGCFrame);

// 'Weak' ptrs
HObject** __cdecl GCGetPtr(HObject *phobj);
void    __cdecl GCFreePtr(HObject **pphobj);

#define GCGetWeakPtr    GCGetPtr
#define GCFreeWeakPtr   GCFreePtr

// 'Strong' ptrs
HObject** __cdecl GCNewHandle(HObject *phobj);
void __cdecl GCFreeHandle(HObject **pphobj);

// 'Internal reserved pinned ptrs
HObject** __cdecl GCNewPinnedHandle(HObject *phobj);
void __cdecl GCFreePinnedHandle(HObject **pphobj);

// GC write barrier support

void __cdecl GCSetObjectReferenceForObject (HObject** location, HObject* phobj);
void __cdecl GCSetObjectReferenceForHandle (HObject** handle, HObject* phobj);


int     __cdecl GCEnable();
int     __cdecl GCDisable();
int     __cdecl GCDisableCount();
int     __cdecl GCEnableCompletely();
void    __cdecl GCDisableMultiple(int cDisable);

//----------------------------------------------------------------------------
// "Built-in" object structures...
// These include helper macro's to get at array data.
//----------------------------------------------------------------------------

#pragma pack(push,4)

typedef struct Classjava_lang_String Classjava_lang_String;
#define Hjava_lang_String Classjava_lang_String
typedef Hjava_lang_String HString;

typedef struct ClassArrayOfByte
{
    int32_t MSReserved;
    unsigned long length;
    char body[1];
} ClassArrayOfByte;
#define HArrayOfByte ClassArrayOfByte
#define ArrayOfByte ClassArrayOfByte

typedef struct ClassArrayOfChar
{
    int32_t MSReserved;
    unsigned long length;
    unsigned short body[1];
} ClassArrayOfChar;
#define HArrayOfChar ClassArrayOfChar
#define ArrayOfChar ClassArrayOfChar

typedef struct ClassArrayOfShort
{
    int32_t MSReserved;
    unsigned long length;
    short body[1];
} ClassArrayOfShort;
#define HArrayOfShort ClassArrayOfShort
#define ArrayOfShort ClassArrayOfShort

typedef struct ClassArrayOfInt
{
    int32_t MSReserved;
    unsigned long length;
    long body[1];
} ClassArrayOfInt;
#define HArrayOfInt ClassArrayOfInt
#define ArrayOfInt ClassArrayOfInt

typedef struct ClassArrayOfLong
{
    int32_t MSReserved;
    unsigned long length;
    __int64 body[1];
} ClassArrayOfLong;
#define HArrayOfLong ClassArrayOfLong
#define ArrayOfLong ClassArrayOfLong

typedef struct ClassArrayOfFloat
{
    int32_t MSReserved;
    unsigned long length;
    float body[1];
} ClassArrayOfFloat;
#define HArrayOfFloat ClassArrayOfFloat
#define ArrayOfFloat ClassArrayOfFloat

typedef struct ClassArrayOfDouble
{
    int32_t MSReserved;
    unsigned long length;
    double body[1];
} ClassArrayOfDouble;
#define HArrayOfDouble ClassArrayOfDouble
#define ArrayOfDouble ClassArrayOfDouble

typedef struct ClassArrayOfObject
{
    int32_t MSReserved;
    unsigned long length;
    HObject *body[1];
} ClassArrayOfObject;
#define HArrayOfObject ClassArrayOfObject
#define ArrayOfObject ClassArrayOfObject

typedef struct ClassArrayOfString
{
    int32_t MSReserved;
    unsigned long length;
    HString  *(body[1]);
} ClassArrayOfString;
#define HArrayOfString ClassArrayOfString
#define ArrayOfString ClassArrayOfString

typedef struct ClassArrayOfArray
{
    int32_t MSReserved;
    unsigned long length;
    JHandle *(body[1]);
} ClassArrayOfArray;
#define HArrayOfArray ClassArrayOfArray
#define ArrayOfArray ClassArrayOfArray

typedef struct
{
    int32_t MSReserved;
    unsigned long length;
} ArrayOfSomething;

#pragma pack(pop)

//----------------------------------------------------------------------------
// We automatically track the execution environment so there's no EE() call
// needed anymore, just pass NULL if an API needs one.
//----------------------------------------------------------------------------
#define EE() NULL
typedef void ExecEnv;

//----------------------------------------------------------------------------
// Exception handling stuff...
//----------------------------------------------------------------------------
void __cdecl SignalError(struct execenv *ee, const char *ename, const char *DetailMessage);
void __cdecl SignalErrorPrintf( const char *ename, const char *pszFormat, ...);

bool_t __cdecl exceptionOccurred(ExecEnv *ee);
void __cdecl exceptionDescribe(ExecEnv *ee);
void __cdecl exceptionClear(ExecEnv *ee);

HObject * __cdecl getPendingException(ExecEnv *ee);

//----------------------------------------------------------------------------
// Standard exec functions...
//----------------------------------------------------------------------------
typedef PVOID ClassClass;

HObject* __cdecl execute_java_constructor(ExecEnv *ee, const char *classname,
        ClassClass *cb, const char *signature, ...);
        
long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, ...);

long __cdecl execute_java_interface_method(ExecEnv *ee, HObject *pobj,
    ClassClass j_interface, char *method_name, char *signature, ...);

//----------------------------------------------------------------------------
// NB The resolve flag is ignored, classes found with this api will always
// be resolved.
//----------------------------------------------------------------------------
ClassClass* __cdecl FindClass(ExecEnv *ee, char *classname, bool_t resolve);

long __cdecl execute_java_static_method(ExecEnv *ee, ClassClass *cb, 
        const char *method_name, const char *signature, ...);

//----------------------------------------------------------------------------
// Helper function that returns a methodblock.
//----------------------------------------------------------------------------
struct methodblock* __cdecl get_methodblock(HObject *pjobj, const char
        *method_name, char *signature);

//----------------------------------------------------------------------------
// If you pass in a methodblock from get_methodblock the method name and
// sig are ignored and so it's faster than a regular execute.
//----------------------------------------------------------------------------
long __cdecl do_execute_java_method(ExecEnv *ee, void *obj, const char
        *method_name, const char *signature, struct methodblock *mb,
        bool_t isStaticCall, ...);

//----------------------------------------------------------------------------
// isInstanceOf
//
// Returns true if the specified object can be cast to the named class
// type.
//----------------------------------------------------------------------------

BOOL __cdecl isInstanceOf(JHandle *phobj, const char *classname);

//----------------------------------------------------------------------------
// is_instance_of
//
// Returns true if the specified object can be cast to the specified
// class type.
//----------------------------------------------------------------------------

BOOL __cdecl is_instance_of(JHandle *phobj,ClassClass *dcb,ExecEnv *ee);

//----------------------------------------------------------------------------
// is_subclass_of
//
// Returns true if the class (cb) is a subclass of the specified class(dcb).
//----------------------------------------------------------------------------

BOOL __cdecl is_subclass_of(ClassClass *cb, ClassClass *dcb, ExecEnv *ee);

//----------------------------------------------------------------------------
// ImplementsInterface
//
// Returns true if the class (cb) implements the specified interface (icb).
//----------------------------------------------------------------------------

BOOL __cdecl ImplementsInterface(ClassClass *cb,ClassClass *icb,ExecEnv *ee);

//----------------------------------------------------------------------------
#define T_TMASK	034
#define T_LMASK 003
#define T_MKTYPE( t, l )  ( ( (t)&T_TMASK ) | ( (l)&T_LMASK) )

#define T_CLASS		2
#define T_FLOATING	4	
#define T_CHAR		5
#define T_INTEGER	010
#define T_BOOLEAN	4

#define T_FLOAT     T_MKTYPE(T_FLOATING,2)
#define T_DOUBLE    T_MKTYPE(T_FLOATING,3)
#define T_BYTE	    T_MKTYPE(T_INTEGER,0)
#define T_SHORT	    T_MKTYPE(T_INTEGER,1)
#define T_INT	    T_MKTYPE(T_INTEGER,2)
#define T_LONG	    T_MKTYPE(T_INTEGER,3)

//----------------------------------------------------------------------------
// Create an array of primitive types only (int, long etc).
//----------------------------------------------------------------------------
HObject* __cdecl ArrayAlloc(int type, int cItems);

//----------------------------------------------------------------------------
// Create an array of objects.
//----------------------------------------------------------------------------
HObject* __cdecl ClassArrayAlloc(int type, int cItems, const char *szSig);

//----------------------------------------------------------------------------
// Copy an array ala System.arrayCopy()
//----------------------------------------------------------------------------
void __cdecl ArrayCopy(HObject *srch, long src_pos, HObject *dsth, 
        long dst_pos, long length);

//----------------------------------------------------------------------------
// Create and return a new array of bytes initialized from the C string.
//----------------------------------------------------------------------------
HArrayOfByte* __cdecl MakeByteString(const char *str, long len);

//----------------------------------------------------------------------------
// Create and return a new Java String object, initialized from the C string.
//----------------------------------------------------------------------------
Hjava_lang_String* __cdecl makeJavaString(const char *str, int len);
Hjava_lang_String* __cdecl makeJavaStringW(const unicode *pszwSrc, int cch);

//----------------------------------------------------------------------------
// Create and return a new Java String object, initialized from a null 
// terminated, UTF8 formatted, C string.
//----------------------------------------------------------------------------
Hjava_lang_String* __cdecl makeJavaStringFromUtf8(const char *pszUtf8);

//----------------------------------------------------------------------------
// Get the characters of the String object into a C string buffer.
// No allocation occurs. Assumes that len is the size of the buffer.
// The C string's address is returned.
//----------------------------------------------------------------------------
char* __cdecl javaString2CString(Hjava_lang_String *s, char *buf, int buflen);

//----------------------------------------------------------------------------
// Return the length of the String object.
//----------------------------------------------------------------------------
int __cdecl javaStringLength(Hjava_lang_String *s);

//----------------------------------------------------------------------------
// Return temporary ptr to first char of the String object.
// May change when gc happens.
//----------------------------------------------------------------------------
unicode * __cdecl javaStringStart (HString *string);

//----------------------------------------------------------------------------
// Note: The int passed to these API's must be an object ptr.
//----------------------------------------------------------------------------
#define obj_monitor(handlep) ((int) handlep)
void __cdecl monitorEnter(unsigned int);
void __cdecl monitorExit(unsigned int);
void __cdecl monitorNotify(unsigned int);
void __cdecl monitorNotifyAll(unsigned int);
void __cdecl monitorWait(unsigned int, int64_t millis);

#define ObjectMonitorEnter(obj)         monitorEnter((int)obj)
#define ObjectMonitorExit(obj)          monitorExit((int)obj)
#define ObjectMonitorNotify(obj)        monitorNotify((int)obj)
#define ObjectMonitorNotifyAll(obj)     monitorNotifyAll((int)obj)
#define ObjectMonitorWait(obj,millis)   monitorWait((int)obj,millis)

//----------------------------------------------------------------------------
// String helpers...
//----------------------------------------------------------------------------
int __cdecl jio_snprintf(char *str, size_t count, const char *fmt, ...);
int __cdecl jio_vsnprintf(char *str, size_t count, const char *fmt, va_list 
        args);

//----------------------------------------------------------------------------
// Methods to get information about the caller of a native method.
//----------------------------------------------------------------------------

ClassClass * __cdecl GetNativeMethodCallersClass();
struct methodblock* __cdecl GetNativeMethodCallersMethodInfo();

//----------------------------------------------------------------------------
// Member attributes, as appear in Java class file.
//----------------------------------------------------------------------------

#define ACC_PUBLIC      0x0001       
#define ACC_PRIVATE     0x0002       
#define ACC_PROTECTED   0x0004       
#define ACC_STATIC      0x0008       
#define ACC_FINAL       0x0010       
#define ACC_SYNCH       0x0020       
#define ACC_SUPER       0x0020       
#define ACC_THREADSAFE  0x0040       
#define ACC_VOLATILE    0x0040        
#define ACC_TRANSIENT   0x0080        
#define ACC_NATIVE      0x0100        
#define ACC_INTERFACE   0x0200        
#define ACC_ABSTRACT    0x0400        

//----------------------------------------------------------------------------
// Class information
//----------------------------------------------------------------------------

// Total number of fields in the class, including supers
unsigned __cdecl            Class_GetFieldCount(ClassClass *cls);
struct fieldblock * __cdecl Class_GetField(ClassClass *cls, const char *name);
struct fieldblock * __cdecl Class_GetFieldByIndex(ClassClass *cls, unsigned index);
// Total number of methods, including supers.
unsigned __cdecl            Class_GetMethodCount(ClassClass *cls);
struct methodblock* __cdecl Class_GetMethod(ClassClass *cls, const char *name, const char *signature);
struct methodblock* __cdecl Class_GetMethodByIndex(ClassClass *cls, unsigned index);
ClassClass * __cdecl        Class_GetSuper(ClassClass *cls);
const char * __cdecl        Class_GetName(ClassClass *cls);
unsigned __cdecl            Class_GetInterfaceCount(ClassClass *cls);
ClassClass * __cdecl        Class_GetInterface(ClassClass *cls, unsigned index);
// Returns combination of ACC_* constants.
int __cdecl                 Class_GetAttributes(ClassClass *cls);

//----------------------------------------------------------------------------
// Field/method information
//----------------------------------------------------------------------------

const char * __cdecl        Member_GetName(PVOID member);
const char * __cdecl        Member_GetSignature(PVOID member);
// class of the field/method is implemented in.
ClassClass * __cdecl        Member_GetClass(PVOID member);
// Returns combination of ACC_* constants.
int __cdecl                 Member_GetAttributes(PVOID member);

// For non-static fields, Offset of field in object.  See also Field_Get/SetValue.
unsigned __cdecl            Field_GetOffset(struct fieldblock * field);
// Ptr to static value
PVOID __cdecl               Field_GetStaticPtr(struct fieldblock * field);


//----------------------------------------------------------------------------
// Object accessors
//----------------------------------------------------------------------------
ClassClass * __cdecl        Object_GetClass(HObject *obj);

__int32 __cdecl             Field_GetValue(HObject *obj, struct fieldblock * field);
__int64 __cdecl             Field_GetValue64(HObject *obj, struct fieldblock * field);
float __cdecl               Field_GetFloat(HObject *obj, struct fieldblock * field);
double __cdecl              Field_GetDouble(HObject *obj, struct fieldblock * field);
void __cdecl                Field_SetValue(HObject *obj, struct fieldblock * field, __int32 value);
void __cdecl                Field_SetValue64(HObject *obj, struct fieldblock * field, __int64 value);
void __cdecl                Field_SetFloat(HObject *obj, struct fieldblock * field, float value);
void __cdecl                Field_SetDouble(HObject *obj, struct fieldblock * field, double value);

#define Field_GetBoolean(obj,field)     ((bool_t)       Field_GetValue(obj,field))
#define Field_GetByte(obj,field)        ((signed char)  Field_GetValue(obj,field))
#define Field_GetChar(obj,field)        ((unicode)      Field_GetValue(obj,field))
#define Field_GetShort(obj,field)       ((short)        Field_GetValue(obj,field))
#define Field_GetInt(obj,field)                         Field_GetValue(obj,field)
#define Field_GetLong(obj,field)                        Field_GetValue64(obj,field)
#define Field_GetObject(obj,field)      ((HObject*)     Field_GetValue(obj,field))
#define Field_GetFloat(obj,field)                       Field_GetFloat(obj,field)
#define Field_GetDouble(obj,field)                      Field_GetDouble(obj,field)

#define Field_SetBoolean(obj,field,value)               Field_SetValue(obj,field,(bool_t)(value))
#define Field_SetByte(obj,field,value)                  Field_SetValue(obj,field,(signed char)(value))
#define Field_SetChar(obj,field,value)                  Field_SetValue(obj,field,(unicode)(value))
#define Field_SetShort(obj,field,value)                 Field_SetValue(obj,field,(short)(value))
#define Field_SetInt(obj,field,value)                   Field_SetValue(obj,field,value)
#define Field_SetLong(obj,field,value)                  Field_SetValue64(obj,field,value)
#define Field_SetObject(obj,field,value)                Field_SetValue(obj,field,(__int32)(value))
#define Field_SetFloat(obj,field,value)                 Field_SetFloat(obj,field,value)
#define Field_SetDouble(obj,field,value)                Field_SetDouble(obj,field,value)


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\misc\include\jpeglib.h ===
/*
 * jpeglib.h
 *
 * Copyright (C) 1991-1995, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file defines the application interface for the JPEG library.
 * Most applications using the library need only include this file,
 * and perhaps jerror.h if they want to know the exact error codes.
 */

#ifndef JPEGLIB_H
#define JPEGLIB_H
#pragma pack (8)   // pack on 8-byte boundaries for best perf

/*
 * First we include the configuration files that record how this
 * installation of the JPEG library is set up.  jconfig.h can be
 * generated automatically for many systems.  jmorecfg.h contains
 * manual configuration options that most people need not worry about.
 */

#ifndef JCONFIG_INCLUDED        /* in case jinclude.h already did */
#include "jconfig.h"            /* widely used configuration options */
#endif
#include "jmorecfg.h"           /* seldom changed options */

/* Version ID for the JPEG library.
 * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
 */

#define JPEG_LIB_VERSION  60    /* Version 6 */


/* Various constants determining the sizes of things.
 * All of these are specified by the JPEG standard, so don't change them
 * if you want to be compatible.
 */

#define DCTSIZE             8   /* The basic DCT block is 8x8 samples */
#define DCTSIZE2            64  /* DCTSIZE squared; # of elements in a block */
#define NUM_QUANT_TBLS      4   /* Quantization tables are numbered 0..3 */
#define NUM_HUFF_TBLS       4   /* Huffman tables are numbered 0..3 */
#define NUM_ARITH_TBLS      16  /* Arith-coding tables are numbered 0..15 */
#define MAX_COMPS_IN_SCAN   4   /* JPEG limit on # of components in one scan */
#define MAX_SAMP_FACTOR     4   /* JPEG limit on sampling factors */
/* Unfortunately, it seems Adobe doesn't always follow the standard;
 * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
 * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
 * to handle it.  We even let you do this from the jconfig.h file.  However,
 * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
 * sometimes emits noncompliant files doesn't mean you should too.
 */
#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
#ifndef D_MAX_BLOCKS_IN_MCU
#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
#endif


/* This macro is used to declare a "method", that is, a function pointer.
 * We want to supply prototype parameters if the compiler can cope.
 * Note that the arglist parameter must be parenthesized!
 */

#ifdef HAVE_PROTOTYPES
#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
#else
#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
#endif


/* Data structures for images (arrays of samples and of DCT coefficients).
 * On 80x86 machines, the image arrays are too big for near pointers,
 * but the pointer arrays can fit in near memory.
 */

typedef JSAMPLE FAR *JSAMPROW;  /* ptr to one image row of pixel samples. */
typedef JSAMPROW *JSAMPARRAY;   /* ptr to some rows (a 2-D sample array) */
typedef JSAMPARRAY *JSAMPIMAGE; /* a 3-D sample array: top index is color */

typedef JCOEF JBLOCK[DCTSIZE2]; /* one block of coefficients */
typedef JBLOCK FAR *JBLOCKROW;  /* pointer to one row of coefficient blocks */
typedef JBLOCKROW *JBLOCKARRAY;         /* a 2-D array of coefficient blocks */
typedef JBLOCKARRAY *JBLOCKIMAGE;       /* a 3-D array of coefficient blocks */

typedef JCOEF FAR *JCOEFPTR;    /* useful in a couple of places */


/* Types for JPEG compression parameters and working tables. */


/* DCT coefficient quantization tables. */

typedef struct {
  /* This field directly represents the contents of a JPEG DQT marker.
   * Note: the values are always given in zigzag order.
   */
  UINT16 quantval[DCTSIZE2];    /* quantization step for each coefficient */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;           /* TRUE when table has been output */
} JQUANT_TBL;


/* Huffman coding tables. */

typedef struct {
  /* These two fields directly represent the contents of a JPEG DHT marker */
  UINT8 bits[17];               /* bits[k] = # of symbols with codes of */
				/* length k bits; bits[0] is unused */
  UINT8 huffval[256];           /* The symbols, in order of incr code length */
  /* This field is used only during compression.  It's initialized FALSE when
   * the table is created, and set TRUE when it's been output to the file.
   * You could suppress output of a table by setting this to TRUE.
   * (See jpeg_suppress_tables for an example.)
   */
  boolean sent_table;           /* TRUE when table has been output */
} JHUFF_TBL;


/* Basic info about one component (color channel). */

typedef struct {
  /* These values are fixed over the whole image. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOF marker. */
  int component_id;             /* identifier for this component (0..255) */
  int component_index;          /* its index in SOF or cinfo->comp_info[] */
  int h_samp_factor;            /* horizontal sampling factor (1..4) */
  int v_samp_factor;            /* vertical sampling factor (1..4) */
  int quant_tbl_no;             /* quantization table selector (0..3) */
  /* These values may vary between scans. */
  /* For compression, they must be supplied by parameter setup; */
  /* for decompression, they are read from the SOS marker. */
  /* The decompressor output side may not use these variables. */
  int dc_tbl_no;                /* DC entropy table selector (0..3) */
  int ac_tbl_no;                /* AC entropy table selector (0..3) */
  
  /* Remaining fields should be treated as private by applications. */
  
  /* These values are computed during compression or decompression startup: */
  /* Component's size in DCT blocks.
   * Any dummy blocks added to complete an MCU are not counted; therefore
   * these values do not depend on whether a scan is interleaved or not.
   */
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;
  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
   * For decompression this is the size of the output from one DCT block,
   * reflecting any scaling we choose to apply during the IDCT step.
   * Values of 1,2,4,8 are likely to be supported.  Note that different
   * components may receive different IDCT scalings.
   */
  int DCT_scaled_size;
  /* The downsampled dimensions are the component's actual, unpadded number
   * of samples at the main buffer (preprocessing/compression interface), thus
   * downsampled_width = ceil(image_width * Hi/Hmax)
   * and similarly for height.  For decompression, IDCT scaling is included, so
   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
   */
  JDIMENSION downsampled_width;  /* actual width in samples */
  JDIMENSION downsampled_height; /* actual height in samples */
  /* This flag is used only for decompression.  In cases where some of the
   * components will be ignored (eg grayscale output from YCbCr image),
   * we can skip most computations for the unused components.
   */
  boolean component_needed;     /* do we need the value of this component? */

  /* These values are computed before starting a scan of the component. */
  /* The decompressor output side may not use these variables. */
  int MCU_width;                /* number of blocks per MCU, horizontally */
  int MCU_height;               /* number of blocks per MCU, vertically */
  int MCU_blocks;               /* MCU_width * MCU_height */
  int MCU_sample_width;         /* MCU width in samples, MCU_width*DCT_scaled_size */
  int last_col_width;           /* # of non-dummy blocks across in last MCU */
  int last_row_height;          /* # of non-dummy blocks down in last MCU */

  /* Saved quantization table for component; NULL if none yet saved.
   * See jdinput.c comments about the need for this information.
   * This field is not currently used by the compressor.
   */
  JQUANT_TBL * quant_table;

  /* Private per-component storage for DCT or IDCT subsystem. */
  void * dct_table;
} jpeg_component_info;


/* The script for encoding a multiple-scan file is an array of these: */

typedef struct {
  int comps_in_scan;            /* number of components encoded in this scan */
  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
  int Ss, Se;                   /* progressive JPEG spectral selection parms */
  int Ah, Al;                   /* progressive JPEG successive approx. parms */
} jpeg_scan_info;


/* Known color spaces. */

typedef enum {
	JCS_UNKNOWN,            /* error/unspecified */
	JCS_GRAYSCALE,          /* monochrome */
	JCS_RGB,                /* red/green/blue */
	JCS_YCbCr,              /* Y/Cb/Cr (also known as YUV) */
	JCS_CMYK,               /* C/M/Y/K */
	JCS_YCCK                /* Y/Cb/Cr/K */
} J_COLOR_SPACE;

/* DCT/IDCT algorithm options. */

typedef enum {
	JDCT_ISLOW,             /* slow but accurate integer algorithm */
	JDCT_IFAST,             /* faster, less accurate integer method */
	JDCT_FLOAT              /* floating-point: accurate, fast on fast HW */
} J_DCT_METHOD;

#ifndef JDCT_DEFAULT            /* may be overridden in jconfig.h */
#define JDCT_DEFAULT  JDCT_ISLOW
#endif
#ifndef JDCT_FASTEST            /* may be overridden in jconfig.h */
#define JDCT_FASTEST  JDCT_IFAST
#endif

/* Dithering options for decompression. */

typedef enum {
	JDITHER_NONE,           /* no dithering */
	JDITHER_ORDERED,        /* simple ordered dither */
	JDITHER_FS              /* Floyd-Steinberg error diffusion dither */
} J_DITHER_MODE;


/* Common fields between JPEG compression and decompression master structs. */

#define jpeg_common_fields \
  struct jpeg_error_mgr * err;  /* Error handler module */\
  struct jpeg_memory_mgr * mem; /* Memory manager module */\
  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
  boolean is_decompressor;      /* so common code can tell which is which */\
  int global_state              /* for checking call sequence validity */

/* Routines that are to be used by both halves of the library are declared
 * to receive a pointer to this structure.  There are no actual instances of
 * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
 */
struct jpeg_common_struct {
  jpeg_common_fields;           /* Fields common to both master struct types */
  /* Additional fields follow in an actual jpeg_compress_struct or
   * jpeg_decompress_struct.  All three structs must agree on these
   * initial fields!  (This would be a lot cleaner in C++.)
   */
};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;


/* Master record for a compression instance */

struct jpeg_compress_struct {
  jpeg_common_fields;           /* Fields shared with jpeg_decompress_struct */

  /* Destination for compressed data */
  struct jpeg_destination_mgr * dest;

  /* Description of source image --- these fields must be filled in by
   * outer application before starting compression.  in_color_space must
   * be correct before you can even call jpeg_set_defaults().
   */

  JDIMENSION image_width;       /* input image width */
  JDIMENSION image_height;      /* input image height */
  int input_components;         /* # of color components in input image */
  J_COLOR_SPACE in_color_space; /* colorspace of input image */

  double input_gamma;           /* image gamma of input image */

  /* Compression parameters --- these fields must be set before calling
   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
   * initialize everything to reasonable defaults, then changing anything
   * the application specifically wants to change.  That way you won't get
   * burnt when new parameters are added.  Also note that there are several
   * helper routines to simplify changing parameters.
   */

  int data_precision;           /* bits of precision in image data */

  int num_components;           /* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */
  
  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */
  
  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */
  
  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  int num_scans;                /* # of entries in scan_info array */
  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
  /* The default value of scan_info is NULL, which causes a single-scan
   * sequential JPEG file to be emitted.  To create a multi-scan file,
   * set num_scans and scan_info to point to an array of scan definitions.
   */

  boolean raw_data_in;          /* TRUE=caller supplies downsampled data */
  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */
  boolean optimize_coding;      /* TRUE=optimize entropy encoding parms */
  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */
  int smoothing_factor;         /* 1..100, or 0 for no input smoothing */
  J_DCT_METHOD dct_method;      /* DCT algorithm selector */

  /* The restart interval can be specified in absolute MCUs by setting
   * restart_interval, or in MCU rows by setting restart_in_rows
   * (in which case the correct restart_interval will be figured
   * for each scan).
   */
  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
  int restart_in_rows;          /* if > 0, MCU rows per restart interval */

  /* Parameters controlling emission of special markers. */

  boolean write_JFIF_header;    /* should a JFIF marker be written? */
  /* These three values are not used by the JPEG code, merely copied */
  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
  /* ratio is defined by X_density/Y_density even when density_unit=0. */
  UINT8 density_unit;           /* JFIF code for pixel size units */
  UINT16 X_density;             /* Horizontal pixel density */
  UINT16 Y_density;             /* Vertical pixel density */
  boolean write_Adobe_marker;   /* should an Adobe marker be written? */
  
  /* State variable: index of next scanline to be written to
   * jpeg_write_scanlines().  Application may use this to control its
   * processing loop, e.g., "while (next_scanline < image_height)".
   */

  JDIMENSION next_scanline;     /* 0 .. image_height-1  */

  /* Remaining fields are known throughout compressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during compression startup
   */
  boolean progressive_mode;     /* TRUE if scan script uses progressive mode */
  int max_h_samp_factor;        /* largest h_samp_factor */
  int max_v_samp_factor;        /* largest v_samp_factor */

  JDIMENSION total_iMCU_rows;   /* # of iMCU rows to be input to coef ctlr */
  /* The coefficient controller receives data in units of MCU rows as defined
   * for fully interleaved scans (whether the JPEG file is interleaved or not).
   * There are v_samp_factor * DCTSIZE sample rows of each component in an
   * "iMCU" (interleaved MCU) row.
   */
  
  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   */
  int comps_in_scan;            /* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */
  
  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */
  
  int blocks_in_MCU;            /* # of DCT blocks per MCU */
  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;           /* progressive JPEG parameters for scan */

  /*
   * Links to compression subobjects (methods and private variables of modules)
   */
  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
};


/* Master record for a decompression instance */

struct jpeg_decompress_struct {
  jpeg_common_fields;           /* Fields shared with jpeg_compress_struct */

  /* Source of compressed data */
  struct jpeg_source_mgr * src;

  /* Basic description of image --- filled in by jpeg_read_header(). */
  /* Application may inspect these values to decide how to process image. */

  JDIMENSION image_width;       /* nominal image width (from SOF marker) */
  JDIMENSION image_height;      /* nominal image height */
  int num_components;           /* # of color components in JPEG image */
  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */

  /* Decompression processing parameters --- these fields must be set before
   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
   * them to default values.
   */

  J_COLOR_SPACE out_color_space; /* colorspace for output */

  unsigned int scale_num, scale_denom; /* fraction by which to scale image */

  double output_gamma;          /* image gamma wanted in output */

  boolean buffered_image;       /* TRUE=multiple output passes */
  boolean raw_data_out;         /* TRUE=downsampled data wanted */

  J_DCT_METHOD dct_method;      /* IDCT algorithm selector */
  boolean do_fancy_upsampling;  /* TRUE=apply fancy upsampling */
  boolean do_block_smoothing;   /* TRUE=apply interblock smoothing */

  boolean quantize_colors;      /* TRUE=colormapped output wanted */
  /* the following are ignored if not quantize_colors: */
  J_DITHER_MODE dither_mode;    /* type of color dithering to use */
  boolean two_pass_quantize;    /* TRUE=use two-pass color quantization */
  int desired_number_of_colors; /* max # colors to use in created colormap */
  /* these are significant only in buffered-image mode: */
  boolean enable_1pass_quant;   /* enable future use of 1-pass quantizer */
  boolean enable_external_quant;/* enable future use of external colormap */
  boolean enable_2pass_quant;   /* enable future use of 2-pass quantizer */

  /* Description of actual output image that will be returned to application.
   * These fields are computed by jpeg_start_decompress().
   * You can also use jpeg_calc_output_dimensions() to determine these values
   * in advance of calling jpeg_start_decompress().
   */

  JDIMENSION output_width;      /* scaled image width */
  JDIMENSION output_height;     /* scaled image height */
  int out_color_components;     /* # of color components in out_color_space */
  int output_components;        /* # of color components returned */
  /* output_components is 1 (a colormap index) when quantizing colors;
   * otherwise it equals out_color_components.
   */
  int rec_outbuf_height;        /* min recommended height of scanline buffer */
  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
   * high, space and time will be wasted due to unnecessary data copying.
   * Usually rec_outbuf_height will be 1 or 2, at most 4.
   */

  /* When quantizing colors, the output colormap is described by these fields.
   * The application can supply a colormap by setting colormap non-NULL before
   * calling jpeg_start_decompress; otherwise a colormap is created during
   * jpeg_start_decompress or jpeg_start_output.
   * The map has out_color_components rows and actual_number_of_colors columns.
   */
  int actual_number_of_colors;  /* number of entries in use */
  JSAMPARRAY colormap;          /* The color map as a 2-D pixel array */

  /* State variables: these variables indicate the progress of decompression.
   * The application may examine these but must not modify them.
   */

  /* Row index of next scanline to be read from jpeg_read_scanlines().
   * Application may use this to control its processing loop, e.g.,
   * "while (output_scanline < output_height)".
   */
  JDIMENSION output_scanline;   /* 0 .. output_height-1  */

  /* Current input scan number and number of iMCU rows completed in scan.
   * These indicate the progress of the decompressor input side.
   */
  int input_scan_number;        /* Number of SOS markers seen so far */
  JDIMENSION input_iMCU_row;    /* Number of iMCU rows completed */

  /* The "output scan number" is the notional scan being displayed by the
   * output side.  The decompressor will not allow output scan/row number
   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
   */
  int output_scan_number;       /* Nominal scan number being displayed */
  JDIMENSION output_iMCU_row;   /* Number of iMCU rows read */

  /* Current progression status.  coef_bits[c][i] indicates the precision
   * with which component c's DCT coefficient i (in zigzag order) is known.
   * It is -1 when no data has yet been received, otherwise it is the point
   * transform (shift) value for the most recent scan of the coefficient
   * (thus, 0 at completion of the progression).
   * This pointer is NULL when reading a non-progressive file.
   */
  int (*coef_bits)[DCTSIZE2];   /* -1 or current Al value for each coef */

  /* Internal JPEG parameters --- the application usually need not look at
   * these fields.  Note that the decompressor output side may not use
   * any parameters that can change between scans.
   */

  /* Quantization and Huffman tables are carried forward across input
   * datastreams when processing abbreviated JPEG datastreams.
   */

  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
  /* ptrs to coefficient quantization tables, or NULL if not defined */

  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
  /* ptrs to Huffman coding tables, or NULL if not defined */

  /* These parameters are never carried across datastreams, since they
   * are given in SOF/SOS markers or defined to be reset by SOI.
   */

  int data_precision;           /* bits of precision in image data */

  jpeg_component_info * comp_info;
  /* comp_info[i] describes component that appears i'th in SOF */

  boolean progressive_mode;     /* TRUE if SOFn specifies progressive mode */
  boolean arith_code;           /* TRUE=arithmetic coding, FALSE=Huffman */

  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */

  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */

  /* These fields record data obtained from optional markers recognized by
   * the JPEG library.
   */
  boolean saw_JFIF_marker;      /* TRUE iff a JFIF APP0 marker was found */
  /* Data copied from JFIF marker: */
  UINT8 density_unit;           /* JFIF code for pixel size units */
  UINT16 X_density;             /* Horizontal pixel density */
  UINT16 Y_density;             /* Vertical pixel density */
  boolean saw_Adobe_marker;     /* TRUE iff an Adobe APP14 marker was found */
  UINT8 Adobe_transform;        /* Color transform code from Adobe marker */

  boolean CCIR601_sampling;     /* TRUE=first samples are cosited */

  /* Remaining fields are known throughout decompressor, but generally
   * should not be touched by a surrounding application.
   */

  /*
   * These fields are computed during decompression startup
   */
  int max_h_samp_factor;        /* largest h_samp_factor */
  int max_v_samp_factor;        /* largest v_samp_factor */

  int min_DCT_scaled_size;      /* smallest DCT_scaled_size of any component */

  JDIMENSION total_iMCU_rows;   /* # of iMCU rows in image */
  /* The coefficient controller's input and output progress is measured in
   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
   * in fully interleaved JPEG scans, but are used whether the scan is
   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
   * rows of each component.  Therefore, the IDCT output contains
   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
   */

  JSAMPLE * sample_range_limit; /* table for fast range-limiting */

  /*
   * These fields are valid during any one scan.
   * They describe the components and MCUs actually appearing in the scan.
   * Note that the decompressor output side must not use these fields.
   */
  int comps_in_scan;            /* # of JPEG components in this scan */
  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
  /* *cur_comp_info[i] describes component that appears i'th in SOS */

  JDIMENSION MCUs_per_row;      /* # of MCUs across the image */
  JDIMENSION MCU_rows_in_scan;  /* # of MCU rows in the image */

  int blocks_in_MCU;            /* # of DCT blocks per MCU */
  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
  /* MCU_membership[i] is index in cur_comp_info of component owning */
  /* i'th block in an MCU */

  int Ss, Se, Ah, Al;           /* progressive JPEG parameters for scan */

  /* This field is shared between entropy decoder and marker parser.
   * It is either zero or the code of a JPEG marker that has been
   * read from the data source, but has not yet been processed.
   */
  int unread_marker;

  /*
   * Links to decompression subobjects (methods, private variables of modules)
   */
  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};


/* "Object" declarations for JPEG modules that may be supplied or called
 * directly by the surrounding application.
 * As with all objects in the JPEG library, these structs only define the
 * publicly visible methods and state variables of a module.  Additional
 * private fields may exist after the public ones.
 */


/* Error handler object */

struct jpeg_error_mgr {
  /* Error exit handler: does not return to caller */
  JMETHOD(void, error_exit, (j_common_ptr cinfo));
  /* Conditionally emit a trace or warning message */
  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
  /* Routine that actually outputs a trace or error message */
  JMETHOD(void, output_message, (j_common_ptr cinfo));
  /* Format a message string for the most recent JPEG error or message */
  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
#define JMSG_LENGTH_MAX  200    /* recommended size of format_message buffer */
  /* Reset error state variables at start of a new image */
  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
  
  /* The message ID code and any parameters are saved here.
   * A message can have one string parameter or up to 8 int parameters.
   */
  int msg_code;
#define JMSG_STR_PARM_MAX  80
  union {
    int i[8];
    char s[JMSG_STR_PARM_MAX];
  } msg_parm;
  
  /* Standard state variables for error facility */
  
  int trace_level;              /* max msg_level that will be displayed */
  
  /* For recoverable corrupt-data errors, we emit a warning message,
   * but keep going unless emit_message chooses to abort.  emit_message
   * should count warnings in num_warnings.  The surrounding application
   * can check for bad data by seeing if num_warnings is nonzero at the
   * end of processing.
   */
  long num_warnings;            /* number of corrupt-data warnings */

  /* These fields point to the table(s) of error message strings.
   * An application can change the table pointer to switch to a different
   * message list (typically, to change the language in which errors are
   * reported).  Some applications may wish to add additional error codes
   * that will be handled by the JPEG library error mechanism; the second
   * table pointer is used for this purpose.
   *
   * First table includes all errors generated by JPEG library itself.
   * Error code 0 is reserved for a "no such error string" message.
   */
  const char * const * jpeg_message_table; /* Library errors */
  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
  /* Second table can be added by application (see cjpeg/djpeg for example).
   * It contains strings numbered first_addon_message..last_addon_message.
   */
  const char * const * addon_message_table; /* Non-library errors */
  int first_addon_message;      /* code for first string in addon table */
  int last_addon_message;       /* code for last string in addon table */
};


/* Progress monitor object */

struct jpeg_progress_mgr {
  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));

  long pass_counter;            /* work units completed in this pass */
  long pass_limit;              /* total number of work units in this pass */
  int completed_passes;         /* passes completed so far */
  int total_passes;             /* total number of passes expected */
};


/* Data destination object for compression */

struct jpeg_destination_mgr {
  JOCTET * next_output_byte;    /* => next byte to write in buffer */
  size_t free_in_buffer;        /* # of byte spaces remaining in buffer */

  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
};


/* Data source object for decompression */

struct jpeg_source_mgr {
  const JOCTET * next_input_byte; /* => next byte to read from buffer */
  size_t bytes_in_buffer;       /* # of bytes remaining in buffer */

  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
};


/* Memory manager object.
 * Allocates "small" objects (a few K total), "large" objects (tens of K),
 * and "really big" objects (virtual arrays with backing store if needed).
 * The memory manager does not allow individual objects to be freed; rather,
 * each created object is assigned to a pool, and whole pools can be freed
 * at once.  This is faster and more convenient than remembering exactly what
 * to free, especially where malloc()/free() are not too speedy.
 * NB: alloc routines never return NULL.  They exit to error_exit if not
 * successful.
 */

#define JPOOL_PERMANENT 0       /* lasts until master record is destroyed */
#define JPOOL_IMAGE     1       /* lasts until done with image/datastream */
#define JPOOL_NUMPOOLS  2

typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {
  /* Method pointers */
  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
				size_t sizeofobject));
  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
				     size_t sizeofobject));
  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
				     JDIMENSION samplesperrow,
				     JDIMENSION numrows));
  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
				      JDIMENSION blocksperrow,
				      JDIMENSION numrows));
  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION samplesperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
						  int pool_id,
						  boolean pre_zero,
						  JDIMENSION blocksperrow,
						  JDIMENSION numrows,
						  JDIMENSION maxaccess));
  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
					   jvirt_sarray_ptr ptr,
					   JDIMENSION start_row,
					   JDIMENSION num_rows,
					   boolean writable));
  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
					    jvirt_barray_ptr ptr,
					    JDIMENSION start_row,
					    JDIMENSION num_rows,
					    boolean writable));
  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
  JMETHOD(void, self_destruct, (j_common_ptr cinfo));

  /* Limit on memory allocation for this JPEG object.  (Note that this is
   * merely advisory, not a guaranteed maximum; it only affects the space
   * used for virtual-array buffers.)  May be changed by outer application
   * after creating the JPEG object.
   */
  long max_memory_to_use;
};


/* Routine signature for application-supplied marker processing methods.
 * Need not pass marker code since it is stored in cinfo->unread_marker.
 */
typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));


/* Declarations for routines called by application.
 * The JPP macro hides prototype parameters from compilers that can't cope.
 * Note JPP requires double parentheses.
 */

#ifdef HAVE_PROTOTYPES
#define JPP(arglist)    arglist
#else
#define JPP(arglist)    ()
#endif


/* Short forms of external names for systems with brain-damaged linkers.
 * We shorten external names to be unique in the first six letters, which
 * is good enough for all known systems.
 * (If your compiler itself needs names to be unique in less than 15 
 * characters, you are out of luck.  Get a better compiler.)
 */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_std_error          jStdError
#define jpeg_create_compress    jCreaCompress
#define jpeg_create_decompress  jCreaDecompress
#define jpeg_destroy_compress   jDestCompress
#define jpeg_destroy_decompress jDestDecompress
#define jpeg_stdio_dest         jStdDest
#define jpeg_stdio_src          jStdSrc
#define jpeg_set_defaults       jSetDefaults
#define jpeg_set_colorspace     jSetColorspace
#define jpeg_default_colorspace jDefColorspace
#define jpeg_set_quality        jSetQuality
#define jpeg_set_linear_quality jSetLQuality
#define jpeg_add_quant_table    jAddQuantTable
#define jpeg_quality_scaling    jQualityScaling
#define jpeg_simple_progression jSimProgress
#define jpeg_suppress_tables    jSuppressTables
#define jpeg_alloc_quant_table  jAlcQTable
#define jpeg_alloc_huff_table   jAlcHTable
#define jpeg_start_compress     jStrtCompress
#define jpeg_write_scanlines    jWrtScanlines
#define jpeg_finish_compress    jFinCompress
#define jpeg_write_raw_data     jWrtRawData
#define jpeg_write_marker       jWrtMarker
#define jpeg_write_tables       jWrtTables
#define jpeg_read_header        jReadHeader
#define jpeg_start_decompress   jStrtDecompress
#define jpeg_read_scanlines     jReadScanlines
#define jpeg_finish_decompress  jFinDecompress
#define jpeg_read_raw_data      jReadRawData
#define jpeg_has_multiple_scans jHasMultScn
#define jpeg_start_output       jStrtOutput
#define jpeg_finish_output      jFinOutput
#define jpeg_input_complete     jInComplete
#define jpeg_new_colormap       jNewCMap
#define jpeg_consume_input      jConsumeInput
#define jpeg_calc_output_dimensions     jCalcDimensions
#define jpeg_set_marker_processor       jSetMarker
#define jpeg_read_coefficients  jReadCoefs
#define jpeg_write_coefficients jWrtCoefs
#define jpeg_copy_critical_parameters   jCopyCrit
#define jpeg_abort_compress     jAbrtCompress
#define jpeg_abort_decompress   jAbrtDecompress
#define jpeg_abort              jAbort
#define jpeg_destroy            jDestroy
#define jpeg_resync_to_restart  jResyncRestart
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Default error-management setup */
EXTERN "C" { struct jpeg_error_mgr *jpeg_std_error JPP((struct jpeg_error_mgr *err));}

/* Initialization and destruction of JPEG compression objects */
/* NB: you must set up the error-manager BEFORE calling jpeg_create_xxx */
EXTERN "C" { void jpeg_create_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_create_decompress JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_destroy_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));}

/* Standard data source and destination managers: stdio streams. */
/* Caller is responsible for opening the file before and closing after. */
EXTERN "C" { void jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));}
EXTERN "C" { void jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));}

/* Default parameter setup for compression */
EXTERN "C" { void jpeg_set_defaults JPP((j_compress_ptr cinfo));}
/* Compression parameter setup aids */
EXTERN "C" { void jpeg_set_colorspace JPP((j_compress_ptr cinfo,
				     J_COLOR_SPACE colorspace));}
EXTERN "C" { void jpeg_default_colorspace JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
				  boolean force_baseline));     }
EXTERN "C" { void jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
					 int scale_factor,
					 boolean force_baseline)); }
EXTERN "C" { void jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
				      const unsigned int *basic_table,
				      int scale_factor,
				      boolean force_baseline));}
EXTERN "C" { int jpeg_quality_scaling JPP((int quality));}
EXTERN "C" { void jpeg_simple_progression JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_suppress_tables JPP((j_compress_ptr cinfo,
				      boolean suppress));}
EXTERN "C" { JQUANT_TBL * jpeg_alloc_quant_table JPP((j_common_ptr cinfo));}
EXTERN "C" { JHUFF_TBL * jpeg_alloc_huff_table JPP((j_common_ptr cinfo));}

/* Main entry points for compression */
EXTERN "C" { void jpeg_start_compress JPP((j_compress_ptr cinfo,
				     boolean write_all_tables));}
EXTERN "C" { JDIMENSION jpeg_write_scanlines JPP((j_compress_ptr cinfo,
					    JSAMPARRAY scanlines,
					    JDIMENSION num_lines));}
EXTERN "C" { void jpeg_finish_compress JPP((j_compress_ptr cinfo));}

/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
EXTERN "C" { JDIMENSION jpeg_write_raw_data JPP((j_compress_ptr cinfo,
					   JSAMPIMAGE data,
					   JDIMENSION num_lines));}

/* Write a special marker.  See libjpeg.doc concerning safe usage. */
EXTERN "C" { void jpeg_write_marker JPP((j_compress_ptr cinfo, int marker,
				   const JOCTET *dataptr, unsigned int datalen));}

/* Alternate compression function: just write an abbreviated table file */
EXTERN "C" { void jpeg_write_tables JPP((j_compress_ptr cinfo));}

/* Decompression startup: read start of JPEG datastream to see what's there */
EXTERN "C" { int jpeg_read_header JPP((j_decompress_ptr cinfo,
				 boolean require_image));}
/* Return value is one of: */
#define JPEG_SUSPENDED          0 /* Suspended due to lack of input data */
#define JPEG_HEADER_OK          1 /* Found valid image datastream */
#define JPEG_HEADER_TABLES_ONLY 2 /* Found valid table-specs-only datastream */
/* If you pass require_image = TRUE (normal case), you need not check for
 * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
 * JPEG_SUSPENDED is only possible if you use a data source module that can
 * give a suspension return (the stdio source module doesn't).
 */

/* Main entry points for decompression */
EXTERN "C" { boolean jpeg_start_decompress JPP((j_decompress_ptr cinfo));}
EXTERN "C" { JDIMENSION jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
					   JSAMPARRAY scanlines,
					   JDIMENSION max_lines));}
EXTERN "C" { boolean jpeg_finish_decompress JPP((j_decompress_ptr cinfo));}

/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
EXTERN "C" { JDIMENSION jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
					  JSAMPIMAGE data,
					  JDIMENSION max_lines));}

/* Additional entry points for buffered-image mode. */
EXTERN "C" { boolean jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));}
EXTERN "C" { boolean jpeg_start_output JPP((j_decompress_ptr cinfo,
				      int scan_number));}
EXTERN "C" { boolean jpeg_finish_output JPP((j_decompress_ptr cinfo));}
EXTERN "C" { boolean jpeg_input_complete JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_new_colormap JPP((j_decompress_ptr cinfo));}
EXTERN "C" { int jpeg_consume_input JPP((j_decompress_ptr cinfo));}
/* Return value is one of: */
/* #define JPEG_SUSPENDED       0    Suspended due to lack of input data */
#define JPEG_REACHED_SOS        1 /* Reached start of new scan */
#define JPEG_REACHED_EOI        2 /* Reached end of image */
#define JPEG_ROW_COMPLETED      3 /* Completed one iMCU row */
#define JPEG_SCAN_COMPLETED     4 /* Completed last iMCU row of a scan */

/* Precalculate output dimensions for current decompression parameters. */
EXTERN "C" { void jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));}

/* Install a special processing method for COM or APPn markers. */
EXTERN "C" { void jpeg_set_marker_processor JPP((j_decompress_ptr cinfo,
					   int marker_code,
					   jpeg_marker_parser_method routine));}

/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
EXTERN "C" { jvirt_barray_ptr * jpeg_read_coefficients JPP((j_decompress_ptr cinfo));}
EXTERN "C" { void jpeg_write_coefficients JPP((j_compress_ptr cinfo,
					 jvirt_barray_ptr * coef_arrays));}
EXTERN "C" { void jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
					       j_compress_ptr dstinfo));}

/* If you choose to abort compression or decompression before completing
 * jpeg_finish_(de)compress, then you need to clean up to release memory,
 * temporary files, etc.  You can just call jpeg_destroy_(de)compress
 * if you're done with the JPEG object, but if you want to clean it up and
 * reuse it, call this:
 */
EXTERN "C" { void jpeg_abort_compress JPP((j_compress_ptr cinfo));}
EXTERN "C" { void jpeg_abort_decompress JPP((j_decompress_ptr cinfo));}

/* Generic versions of jpeg_abort and jpeg_destroy that work on either
 * flavor of JPEG object.  These may be more convenient in some places.
 */
EXTERN "C" { void jpeg_abort JPP((j_common_ptr cinfo));}
EXTERN "C" { void jpeg_destroy JPP((j_common_ptr cinfo));}

/* Default restart-marker-resync procedure for use by data source modules */
EXTERN "C" { boolean jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
					   int desired));}


/* These marker codes are exported since applications and data source modules
 * are likely to want to use them.
 */

#define JPEG_RST0       0xD0    /* RST0 marker code */
#define JPEG_EOI        0xD9    /* EOI marker code */
#define JPEG_APP0       0xE0    /* APP0 marker code */
#define JPEG_COM        0xFE    /* COM marker code */


/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
 * for structure definitions that are never filled in, keep it quiet by
 * supplying dummy definitions for the various substructures.
 */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef JPEG_INTERNALS          /* will be defined in jpegint.h */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
struct jpeg_comp_master { long dummy; };
struct jpeg_c_main_controller { long dummy; };
struct jpeg_c_prep_controller { long dummy; };
struct jpeg_c_coef_controller { long dummy; };
struct jpeg_marker_writer { long dummy; };
struct jpeg_color_converter { long dummy; };
struct jpeg_downsampler { long dummy; };
struct jpeg_forward_dct { long dummy; };
struct jpeg_entropy_encoder { long dummy; };
struct jpeg_decomp_master { long dummy; };
struct jpeg_d_main_controller { long dummy; };
struct jpeg_d_coef_controller { long dummy; };
struct jpeg_d_post_controller { long dummy; };
struct jpeg_input_controller { long dummy; };
struct jpeg_marker_reader { long dummy; };
struct jpeg_entropy_decoder { long dummy; };
struct jpeg_inverse_dct { long dummy; };
struct jpeg_upsampler { long dummy; };
struct jpeg_color_deconverter { long dummy; };
struct jpeg_color_quantizer { long dummy; };
#endif /* JPEG_INTERNALS */
#endif /* INCOMPLETE_TYPES_BROKEN */


/*
 * The JPEG library modules define JPEG_INTERNALS before including this file.
 * The internal structure declarations are read only when that is true.
 * Applications using the library should not include jpegint.h, but may wish
 * to include jerror.h.
 */

#ifdef JPEG_INTERNALS
#include "jpegint.h"            /* fetch private declarations */
#include "jerror.h"             /* fetch error codes too */
#endif

#pragma pack ()                // restore structure packing to /Zp setting

#endif /* JPEGLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_multimedia.ini  ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\main.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Main.cpp
//
// Microsoft CONFIDENTIAL
//
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////

//
// Make sure to enable multi-threading and OLE2
//

#ifndef _MT
#define _MT
#endif

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <assert.h>
#include <string.h>
#include "Global.h"
#include "RunOnce.h"
#include "RegistryKey.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL ExtractComponent(const DWORD dwIndex, LPCTSTR strPath)
{
  BOOL    fSuccess = FALSE;
  HRSRC   hResourceInfo;
  HGLOBAL hResource;
  LPVOID  lpResourceImage;
  HANDLE  hFileHandle;
  DWORD   dwBytesToWrite, dwBytesWritten;
  TCHAR   strDestinationFilename[MAX_PATH];

  //
  // Build the destination filename
  //

  wsprintf(strDestinationFilename, TEXT("%s\\%s"), strPath, g_sComponentInfo[dwIndex].strFilename);

  //
  // Get the resource that contains the binary image of TestSample.exe
  //

  hResourceInfo = FindResource(g_hInstance, MAKEINTRESOURCE(g_sComponentInfo[dwIndex].dwResourceId), "BINARY");
  if (NULL != hResourceInfo)
  {
    hResource = LoadResource(g_hInstance, hResourceInfo);
    if (NULL != hResource)
    {
      dwBytesToWrite = SizeofResource(g_hInstance, hResourceInfo);
      if (0 < dwBytesToWrite)
      {
        lpResourceImage = LockResource(hResource);
        if (NULL != lpResourceImage)
        {
          //
          // Make sure to delete the existing file
          //

          if (FileExists(strDestinationFilename))
          {
            SetFileAttributes(strDestinationFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(strDestinationFilename);
          }

          //
          // Write it to a file
          //
      
          hFileHandle = CreateFile(strDestinationFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
          if (INVALID_HANDLE_VALUE != hFileHandle)
          {
            //
            // Write the bits to the file
            //

            if (WriteFile(hFileHandle, lpResourceImage, dwBytesToWrite, &dwBytesWritten, NULL))
            {
              if (dwBytesToWrite == dwBytesWritten)
              {
                fSuccess = TRUE;
              }
            }

            //
            // Close the file
            //

            CloseHandle(hFileHandle);
          }
        }
      }
    }
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL GetFileVersion(LPTSTR strFilename, VS_FIXEDFILEINFO * lpFileInfo)
{
  BOOL    fSuccess = FALSE;
  LPVOID  lpVersion;
  LPVOID  lpVersionInfo;
  UINT    uSize;
  DWORD	  dwSize, dwEmpty;

  //
  // By default we zero out the lpFileInfo buffer
  //

	ZeroMemory(lpFileInfo, sizeof(VS_FIXEDFILEINFO));

  //
  // Go get the version info for that file
  //

	dwSize = GetFileVersionInfoSize((LPTSTR) strFilename, &dwEmpty);
	if (0 != dwSize)
	{
	  lpVersion = new BYTE [dwSize];
 	  ZeroMemory(lpVersion, dwSize);
	  if (NULL != lpVersion)
    {
	    if (0 != GetFileVersionInfo(strFilename, 0, dwSize, lpVersion))
	    {	
	      if (0 != VerQueryValue(lpVersion, TEXT("\\"), &lpVersionInfo, &uSize))
	      {
		      if (uSize == sizeof(VS_FIXEDFILEINFO))
	        {
            //
            // Save the version information
            //

	          CopyMemory(lpFileInfo, lpVersionInfo, sizeof(VS_FIXEDFILEINFO));

            //
            // delete the memory allocated to lpVersion
            //

            delete [] lpVersion;

            //
            // Everything was successful
            //

            fSuccess = TRUE;
          }
        }
      }
    }
  }

	return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CompareFileVersions(VS_FIXEDFILEINFO * lpFileInfo1, VS_FIXEDFILEINFO * lpFileInfo2)
{
  if (HIWORD(lpFileInfo1->dwFileVersionMS) > HIWORD(lpFileInfo2->dwFileVersionMS))
	{
		return COMPONENT_NEWER_VERSION;
	}

	if (HIWORD(lpFileInfo1->dwFileVersionMS) < HIWORD(lpFileInfo2->dwFileVersionMS))
	{
		return COMPONENT_OLDER_VERSION;
	}

	if (LOWORD(lpFileInfo1->dwFileVersionMS) > LOWORD(lpFileInfo2->dwFileVersionMS))
	{
		return COMPONENT_NEWER_VERSION;
	}

	if (LOWORD(lpFileInfo1->dwFileVersionMS) < LOWORD(lpFileInfo2->dwFileVersionMS))
	{
		return COMPONENT_OLDER_VERSION;
	}

	if (HIWORD(lpFileInfo1->dwFileVersionLS) > HIWORD(lpFileInfo2->dwFileVersionLS))
	{
		return COMPONENT_NEWER_VERSION;
	}

	if (HIWORD(lpFileInfo1->dwFileVersionLS) < HIWORD(lpFileInfo2->dwFileVersionLS))
	{
		return COMPONENT_OLDER_VERSION;
	}

	if (LOWORD(lpFileInfo1->dwFileVersionLS) > LOWORD(lpFileInfo2->dwFileVersionLS))
	{
		return COMPONENT_NEWER_VERSION;
	}
	
	if (LOWORD(lpFileInfo1->dwFileVersionLS) < LOWORD(lpFileInfo2->dwFileVersionLS))
	{
		return COMPONENT_OLDER_VERSION;
	}

  return COMPONENT_SAME_VERSION;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CompareFiles(LPCTSTR strFile1, LPCTSTR strFile2)
{
  HANDLE  hFileHandle[2];
  HANDLE  hFileMapping[2];
  LPVOID  lpFileView[2];
  DWORD   dwFileSize[2];
  DWORD   dwReturnCode = 0xffffffff;

  //
  // Open strFile1
  //

  hFileHandle[0] = CreateFile(strFile1, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (INVALID_HANDLE_VALUE != hFileHandle[0])
  {
    //
    // Open strFile2
    //

    hFileHandle[1] = CreateFile(strFile2, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFileHandle[1])
    {
      //
      // Get the file size for both files. They should be the same in order for us to continue
      //

      dwFileSize[0] = GetFileSize(hFileHandle[0], NULL);
      dwFileSize[1] = GetFileSize(hFileHandle[1], NULL);

      if (dwFileSize[0] == dwFileSize[1])
      {
        //
        // Create a file mapping for hFileHandle[0]
        //

        hFileMapping[0] = CreateFileMapping(hFileHandle[0], NULL, PAGE_READONLY, 0, dwFileSize[0], NULL);
        if (NULL != hFileMapping[0])
        {
          //
          // Map a view of hFileMapping[0]
          //

          lpFileView[0] = MapViewOfFile(hFileMapping[0], FILE_MAP_READ, 0, 0, 0);
          if (NULL != lpFileView[0])
          {
            //
            // Create a file mapping for hFileHandle[1]
            //

            hFileMapping[1] = CreateFileMapping(hFileHandle[1], NULL, PAGE_READONLY, 0, dwFileSize[1], NULL);
            if (NULL != hFileMapping[1])
            {
              //
              // Map a view of hFileMapping[1]
              //

              lpFileView[1] = MapViewOfFile(hFileMapping[1], FILE_MAP_READ, 0, 0, 0);
              if (NULL != lpFileView[1])
              {
                //
                // Compare lpFileView[0] and lpFileView[1]
                //

                if (0 != memcmp(lpFileView[0], lpFileView[1], dwFileSize[0]))
                {
                  dwReturnCode = COMPONENT_NOT_IDENTICAL;
                }
                else
                {
                  dwReturnCode = 0;
                }

                //
                // Make sure to unmap the view of file for lpFileView[1]
                //

                UnmapViewOfFile(lpFileView[1]);
              }

              //
              // Make sure to release the mapping for hFileMapping[1]
              //

              CloseHandle(hFileMapping[1]);
            }

            //
            // Make sure to unmap the view of file for lpFileView[0]
            //

            UnmapViewOfFile(lpFileView[0]);
          }

          //
          // Make sure to release the mapping for hFileMapping[0]
          //

          CloseHandle(hFileMapping[0]);
        }
      }
      else
      {
        //
        // Files are not the same size
        //

        dwReturnCode = COMPONENT_NOT_IDENTICAL;
      }

      //
      // Make sure to close hFileHandle2
      //

      CloseHandle(hFileHandle[1]);
    }

    //
    // Make sure to close hFileHandle1
    //

    CloseHandle(hFileHandle[0]);
  }

  return dwReturnCode;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL RegisterComponent(LPCTSTR strFilename)
{
  BOOL                    fSuccess = FALSE;
  HRESULT                 hResult;
  HINSTANCE               hInstance;
  LPFNDLLREGISTERSERVER   DllRegisterServer;

  hInstance = LoadLibrary(strFilename);
  if (hInstance) 
  {
    DllRegisterServer = (LPFNDLLREGISTERSERVER) GetProcAddress(hInstance, "DllRegisterServer");
    if ((DllRegisterServer)&&(SUCCEEDED(DllRegisterServer())))
    {
      fSuccess = TRUE;
    }

    //
    // Make sure to free the library
    //

    FreeLibrary(hInstance);
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL UnRegisterComponent(LPCTSTR strFilename)
{
  BOOL                    fSuccess = FALSE;
  HRESULT                 hResult;
  HINSTANCE               hInstance;
  LPFNDLLUNREGISTERSERVER DllUnregisterServer;

  hInstance = LoadLibrary(strFilename);
  if (hInstance) 
  {
    DllUnregisterServer = (LPFNDLLREGISTERSERVER) GetProcAddress(hInstance, "DllUnregisterServer");
    if ((DllUnregisterServer)&&(SUCCEEDED(DllUnregisterServer())))
    {
      fSuccess = TRUE;
    }

    //
    // Make sure to free the library
    //

    FreeLibrary(hInstance);
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL SetDebugMode(void)
{
  BOOL          fSuccess = FALSE;
  CRegistryKey  oRegistryKey;
  TCHAR         strValueName[MAX_PATH];
  DWORD         dwValue, dwKeyDisposition;

  //
  // Do we want to run in debug mode ?
  //

  if (g_fInstallDebug)
  {
    //
    // Make sure our target registry key exists
    //

    if (S_OK != oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AppMan")))
    {
      oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AppMan"), 0, KEY_ALL_ACCESS, &dwKeyDisposition);
    }

    //
    // Open the target registry key
    //

    if (S_OK == oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AppMan"), KEY_ALL_ACCESS))
    {
      wsprintf(strValueName, TEXT("Debug"));
      dwValue = 0;
      if (S_OK == oRegistryKey.SetValue(strValueName, REG_DWORD, (LPBYTE) &dwValue, sizeof(dwValue)))
      {
        wsprintf(strValueName, TEXT("LoadDebugRuntime"));
        dwValue = 1;
        if (S_OK == oRegistryKey.SetValue(strValueName, REG_DWORD, (LPBYTE) &dwValue, sizeof(dwValue)))
        {
          fSuccess = TRUE;
        }
      }

      //
      // Make sure to close the registry
      //

      oRegistryKey.CloseKey();
    }
  }
  else
  {
    //
    // We do not want to run in debug mode. Make sure to delete the target registry key
    //

    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AppMan")))
    {
      if (S_OK == oRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\AppMan")))
      {
        fSuccess = TRUE;
      }
    }
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

LONG SetupAndLaunch(void)
{
  LONG                lReturnCode = -2;
  BOOL                fReady = FALSE;
  STARTUPINFO         sStartupInfo;
  PROCESS_INFORMATION sProcessInfo;
  DWORD               dwIndex, dwReturnValue;
  TCHAR               strTempPath[MAX_PATH];
  TCHAR               strSystemPath[MAX_PATH];
  TCHAR               strSourceFilename[MAX_PATH];
  TCHAR               strDestinationFilename[MAX_PATH];
  TCHAR               strCmdLine[MAX_PATH];
  VS_FIXEDFILEINFO    sSourceFileInfo;
  VS_FIXEDFILEINFO    sDestinationFileInfo;

  //
  // Where should the temporary files go
  //

  if (GetSystemDirectory(strSystemPath, MAX_PATH))
  {
    if (GetTempPath(MAX_PATH, strTempPath))
    {
      //
      // What is the source filename ?
      //

      if (GetModuleFileName(NULL, strSourceFilename, MAX_PATH))
      {
        //
        // Generate the path/filename pair for the destination of the setup bits
        //

        wsprintf(strDestinationFilename, TEXT("%s\\WAMSetup.exe"), strSystemPath);
        
        if (FileExists(strDestinationFilename))
        {
          SetFileAttributes(strDestinationFilename, FILE_ATTRIBUTE_NORMAL);
          if (DeleteFile(strDestinationFilename))
          {
            if (CopyFile(strSourceFilename, strDestinationFilename, FALSE))
            {
              fReady = TRUE;
            }
          }
        }
        else
        {
          //
          // There is no existing destination file. Just copy the source to the destination
          //

          if (CopyFile(strSourceFilename, strDestinationFilename, FALSE))
          {
            fReady = TRUE;
          }
        }
      }

      //
      // Did we successfully copy the setup executable to the system directory. Continue if so.
      //

      if (fReady)
      {
        //
        // Execute the temporary executable
        //

        ZeroMemory(&sStartupInfo, sizeof(sStartupInfo));
        sStartupInfo.cb = sizeof(sStartupInfo);
        ZeroMemory(&sProcessInfo, sizeof(PROCESS_INFORMATION));
        if (g_fInstallDebug)
        {  
          wsprintf(strCmdLine, TEXT("""%s"" /DoInstall /Debug"), strDestinationFilename);
        }
        else
        {
          wsprintf(strCmdLine, TEXT("""%s"" /DoInstall"), strDestinationFilename);
        }

        if (CreateProcess(NULL, strCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &sStartupInfo, &sProcessInfo))
        {
          //
          // Wait for the process to end
          //

          WaitForSingleObject(sProcessInfo.hProcess, INFINITE);

          //
          // What was the return value ?
          //

          if (GetExitCodeProcess(sProcessInfo.hProcess, &dwReturnValue))
          {
            switch(dwReturnValue)
            {
              case _EXIT_SUCCESS
              : lReturnCode = 1;
                break;

              case _EXIT_SUCCESS_REBOOT
              : lReturnCode = 2;
                break;

              default
              : lReturnCode = -1;
                break;
            }
          }

          //
          // Close the process and thread handles created by CreateProcess()
          //

          CloseHandle(sProcessInfo.hThread);
          CloseHandle(sProcessInfo.hProcess);
        }
      }
    }
  }

  return lReturnCode;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

LONG DoInstall(void)
{
  LONG    lReturnCode = -1;
  BOOL    fReady = TRUE;
  BOOL    fRebootNeeded = FALSE;
  DWORD   dwIndex;
  TCHAR   strSystemPath[MAX_PATH];
  TCHAR   strTempPath[MAX_PATH];
  TCHAR   strSourceFilename[MAX_PATH];
  TCHAR   strTargetFilename[MAX_PATH];
  TCHAR   strAlternateTargetFilename[MAX_PATH];

  //
  // Get the system and temp path to start with
  //

  if (GetSystemDirectory(strSystemPath, MAX_PATH))
  {
    if (GetTempPath(MAX_PATH, strTempPath))
    {
      //
      // Extract the DLLs to a temporary directory
      //

      for (dwIndex = 0; dwIndex < COMPONENT_COUNT; dwIndex++)
      {
        if (g_dwOSVersion & g_sComponentInfo[dwIndex].dwTargetOS)
        {
          if ((FALSE == g_sComponentInfo[dwIndex].fDebugVersion)||(g_fInstallDebug))
          {
            if (!ExtractComponent(dwIndex, strTempPath))
            {
              fReady = FALSE;
            }
          }
        }
      }

      //
      // Continue on if the DLLS were properly extracted
      //

      if (fReady)
      {
        //
        // First we need to initialize the RunOnce process
        //

        if (InitializeRunOnce(TRUE))
        {
          //
          // Determine the status of the component
          //

          for (dwIndex = 0; dwIndex < COMPONENT_COUNT; dwIndex++)
          {
            if (g_dwOSVersion & g_sComponentInfo[dwIndex].dwTargetOS)
            {
              if ((FALSE == g_sComponentInfo[dwIndex].fDebugVersion)||(g_fInstallDebug))
              {
                //
                // What would be the target filename for component at dwIndex
                //

                wsprintf(strSourceFilename, TEXT("%s%s"), strTempPath, g_sComponentInfo[dwIndex].strFilename);
                wsprintf(strTargetFilename, TEXT("%s\\%s"), strSystemPath, g_sComponentInfo[dwIndex].strFilename);
                if (FileExists(strTargetFilename))
                {
                  //
                  // Flag the component as being on the system
                  //

                  g_sComponentInfo[dwIndex].dwStatus |= COMPONENT_ON_SYSTEM;

                  //
                  // Get the version of the component on the system
                  //

                  GetFileVersion(strTargetFilename, &g_sComponentInfo[dwIndex].sCurrentVersionInfo);
                  GetFileVersion(strSourceFilename, &g_sComponentInfo[dwIndex].sTargetVersionInfo);

                  //
                  // Compare the component on the system and the target component
                  //

                  g_sComponentInfo[dwIndex].dwStatus |= CompareFileVersions(&g_sComponentInfo[dwIndex].sCurrentVersionInfo, &g_sComponentInfo[dwIndex].sTargetVersionInfo);

                  //
                  // If the two files are the same version, they should be identical. Check that fact
                  //

                  g_sComponentInfo[dwIndex].dwStatus |= CompareFiles(strTargetFilename, strSourceFilename);
                }
              }
            }
          }

          //
          // At first, we will try to copy each component to the system directory. Otherwise we
          // will copy the components to the system directory under temporary names.
          //

          for (dwIndex = 0; dwIndex < COMPONENT_COUNT; dwIndex++)
          {
            if (g_dwOSVersion & g_sComponentInfo[dwIndex].dwTargetOS)
            {
              if ((FALSE == g_sComponentInfo[dwIndex].fDebugVersion)||(g_fInstallDebug))
              {
                //
                // Determine whether or not the component should be updated before proceeding
                //

                if ((!(COMPONENT_ON_SYSTEM & g_sComponentInfo[dwIndex].dwStatus))||(COMPONENT_OLDER_VERSION & g_sComponentInfo[dwIndex].dwStatus)||((COMPONENT_NOT_IDENTICAL & g_sComponentInfo[dwIndex].dwStatus)&&(COMPONENT_SAME_VERSION & g_sComponentInfo[dwIndex].dwStatus)))
                {
                  //
                  // What will be the target filename
                  //

                  wsprintf(strSourceFilename, TEXT("%s%s"), strTempPath, g_sComponentInfo[dwIndex].strFilename);
                  wsprintf(strTargetFilename, TEXT("%s\\%s"), strSystemPath, g_sComponentInfo[dwIndex].strFilename);
                  if (!CopyFile(strSourceFilename, strTargetFilename, FALSE))
                  {
                    //
                    // We will need to copy the DLL to a temporary directory
                    //

                    if ((GenerateUniqueFilename(strSystemPath, TEXT("dll"), strAlternateTargetFilename))&&(CopyFile(strSourceFilename, strAlternateTargetFilename, FALSE)))
                    {
                      SetRunOnceCleanupFile(strAlternateTargetFilename, strTargetFilename, g_sComponentInfo[dwIndex].fRegister);
                      fRebootNeeded = TRUE;
                    }
                    else
                    {
                      break;
                    }
                  }

                  //
                  // Excellent, all we need to do is register the component if required
                  //

                  if (g_sComponentInfo[dwIndex].fRegister)
                  {
                    if (!RegisterComponent(strTargetFilename))
                    {
                      break;
                    }
                  }
                }
              }
            }
          }

          //
          // Did everything go as planned
          //

          if (COMPONENT_COUNT == dwIndex)
          {
            //
            // Finish off the DoInstall process
            //

            SetDebugMode();
            if (fRebootNeeded)
            {
              FinalizeRunOnce(TRUE);
              lReturnCode = 2;
            }
            else
            {
              FinalizeRunOnce(FALSE);
              lReturnCode = 1;
            }
          }
        }
      }

      //
      // Did we fail ?
      //

      if (-1 == lReturnCode)
      {
        FinalizeRunOnce(FALSE);
      }

      //
      // Delete the temporary DLLs
      //

      for (dwIndex = 0; dwIndex < COMPONENT_COUNT; dwIndex++)
      {
        if (g_dwOSVersion & g_sComponentInfo[dwIndex].dwTargetOS)
        {
          if ((FALSE == g_sComponentInfo[dwIndex].fDebugVersion)||(g_fInstallDebug))
          {
            wsprintf(strTargetFilename, TEXT("%s\\%s"), strTempPath, g_sComponentInfo[dwIndex].strFilename);
            SetFileAttributes(strTargetFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(strTargetFilename);
          }
        }
      }
    }
  }

  return lReturnCode;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

LONG DoCleanup(void)
{
  LONG    lReturnCode = 1;
  BOOL    fSuccess;
  TCHAR   strSourceFilename[MAX_PATH];
  TCHAR   strDestinationFilename[MAX_PATH];

  //
  // First we need to initialize the RunOnce process
  //

  if (InitializeRunOnce(FALSE))
  {
    //
    // Get the components that do need to be registered
    //

    fSuccess = TRUE;
    while ((fSuccess)&&(GetRunOnceCleanupFile(strSourceFilename, MAX_PATH, strDestinationFilename, MAX_PATH, TRUE)))
    {
      //
      // By default we pretend that the operation will fail until proven otherwise
      //

      fSuccess = FALSE;

      //
      // Make sure the file attribute is set properly prior to deleting the destination file
      //

      SetFileAttributes(strDestinationFilename, FILE_ATTRIBUTE_NORMAL);
      if (UnRegisterComponent(strDestinationFilename))
      {
        if (CopyFile(strSourceFilename, strDestinationFilename, FALSE))
        {
          //
          // Redo the registration on the component
          //

          if (UnRegisterComponent(strSourceFilename))
          {
            SetFileAttributes(strSourceFilename, FILE_ATTRIBUTE_NORMAL);
            if (DeleteFile(strSourceFilename))
            {
              if (RegisterComponent(strDestinationFilename))
              {
                fSuccess = TRUE;
              }
            }
          }
        }
        else
        {
          //
          // We were unable to overwrite the destination component. Make sure to re-register it
          //

          RegisterComponent(strDestinationFilename);
        }
      }
    }

    //
    // If we were not successful, put the RunOnceCleanupFile back into the registry before exiting
    //

    if (!fSuccess)
    {
      SetRunOnceCleanupFile(strSourceFilename, strDestinationFilename, TRUE);
      FinalizeRunOnce(TRUE);
      lReturnCode = 2;
    }
    else
    {
      //
      // Get the components that do not need to be registered
      //

      while ((fSuccess)&&(GetRunOnceCleanupFile(strSourceFilename, MAX_PATH, strDestinationFilename, MAX_PATH, FALSE)))
      {
        //
        // By default we pretend that the operation will fail until proven otherwise
        //

        fSuccess = FALSE;

        //
        // Make sure the file attribute is set properly prior to deleting the destination file
        //

        SetFileAttributes(strDestinationFilename, FILE_ATTRIBUTE_NORMAL);
        if (CopyFile(strSourceFilename, strDestinationFilename, FALSE))
        {
          //
          // Redo the registration on the component
          //

          SetFileAttributes(strSourceFilename, FILE_ATTRIBUTE_NORMAL);
          if (DeleteFile(strSourceFilename))
          {
            fSuccess = TRUE;
          }
        }
      }

      if (!fSuccess)
      {
        SetRunOnceCleanupFile(strSourceFilename, strDestinationFilename, FALSE);
        FinalizeRunOnce(TRUE);
        lReturnCode = 2;
      }
      else
      {
        FinalizeRunOnce(FALSE);
        lReturnCode = 1;
      }
    }
  }

  return lReturnCode;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR lpCommandLine, int nCmdShow)
{
  //
  // Initialize some global variables
  //

  g_hInstance = hInstance;
  g_dwOSVersion = GetOSVersion();
  g_dwSuccessCode = 0;

  //
  // For now, we do not work in Win95
  //

  //if (OS_VERSION_WIN95 == g_dwOSVersion)
  //{
  //  return -3;
  //}

  //
  // Cast the command line into uppercase
  //

  _strupr(lpCommandLine);

  //
  // Define whether or not we care about the DEBUG files
  //

  if (NULL != strstr((LPCSTR) lpCommandLine, "/DEBUG"))
  {
    g_fInstallDebug = TRUE;
  }
  else
  {
    g_fInstallDebug = FALSE;
  }

  //
  // Is the /DoInstall command line parameter on the command line
  //

  if (NULL != strstr((LPCSTR) lpCommandLine, "/DOINSTALL"))
  {
    //
    // Do the installation here
    //

    g_dwSuccessCode = (DWORD) DoInstall();
  }
  else if (NULL == strstr((LPCSTR) lpCommandLine, "/CLEANUP"))
  {
    //
    // Copy the executable to a temporary directory and restart it
    //

    g_dwSuccessCode = (DWORD) SetupAndLaunch();
  }
  else
  {
    //
    // Do the installation cleanup here. Please note that DoCleanup does not return errors.
    //

    g_dwSuccessCode = (DWORD) DoCleanup();
  }

  return (int) g_dwSuccessCode;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\global.h ===
#ifndef __GLOBAL_
#define __GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>

//
// Defines
//

#define MAX_FILENAME_LEN              13

#define COMPONENT_COUNT               6

#define COMPONENT_ON_SYSTEM           0x00000001
#define COMPONENT_OLDER_VERSION       0x00000002
#define COMPONENT_SAME_VERSION        0x00000004
#define COMPONENT_NEWER_VERSION       0x00000008
#define COMPONENT_NOT_IDENTICAL       0x00000010
#define COMPONENT_IN_USE              0x00000020
#define COMPONENT_SUCCESS             0x00000040

#define OS_VERSION_WIN32S             0x00000000
#define OS_VERSION_WIN95              0x00000001
#define OS_VERSION_WIN98              0x00000002
#define OS_VERSION_WINNT              0x00000004
#define OS_VERSION_WIN2000            0x00000008

#define OS_VERSION_WIN9X              (OS_VERSION_WIN95 | OS_VERSION_WIN98)
#define OS_VERSION_WIN2K              (OS_VERSION_WIN2000)

#define _EXIT_SUCCESS                 0x00000001
#define _EXIT_SUCCESS_REBOOT          0x00000002
#define _EXIT_FAIL                    0xffffffff

typedef HRESULT (STDAPICALLTYPE * LPFNDLLREGISTERSERVER) (void);
typedef HRESULT (STDAPICALLTYPE * LPFNDLLUNREGISTERSERVER) (void);

//
// Structure used to track component information used during installation
//

typedef struct
{
  TCHAR             strFilename[MAX_FILENAME_LEN];
  BOOL              fDebugVersion;
  BOOL              fRegister;
  DWORD             dwTargetOS;
  DWORD             dwResourceId;
  DWORD             dwStatus;
  VS_FIXEDFILEINFO  sCurrentVersionInfo;
  VS_FIXEDFILEINFO  sTargetVersionInfo;

} COMPONENT_INFO, LPCOMPONENT_INFO;

//
// Global variables
//

extern HINSTANCE        g_hInstance;
extern DWORD            g_dwOSVersion;
extern BOOL             g_fInstallDebug;
extern DWORD            g_dwSuccessCode;
extern COMPONENT_INFO   g_sComponentInfo[COMPONENT_COUNT];

//
// Global methods
//

extern BOOL   FileExists(LPCTSTR strFilename);
extern DWORD  GetOSVersion(void);
extern DWORD  StrLen(LPCTSTR strString);
extern BOOL   GenerateUniqueFilename(LPCTSTR strRootPath, LPCTSTR strExtension, LPTSTR strFilename);

//////////////////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif  // __GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppManSetup.rc
//

#define IDI_ICON1                       101
#define IDR_APPMAN_9X                   102
#define IDR_APPMAND_9X                  103
#define IDR_APPMANDP_9X                 104
#define IDR_APPMANDD_9X                 105
#define IDR_APPMAN_2K                   106
#define IDR_APPMAND_2K                  107
#define IDR_APPMANDP_2K                 108
#define IDR_APPMANDD_2K                 109

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\global.cpp ===
#include <windows.h>
#include "Global.h"
#include "Resource.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Global variables
//
//////////////////////////////////////////////////////////////////////////////////////////////

HINSTANCE   g_hInstance;
DWORD       g_dwOSVersion;
BOOL        g_fInstallDebug;
DWORD       g_dwSuccessCode;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// This is the global structure used by this applications state machine
//
//////////////////////////////////////////////////////////////////////////////////////////////

COMPONENT_INFO  g_sComponentInfo[COMPONENT_COUNT] =
{
  { TEXT("AppMan.dll"),     FALSE, TRUE,  OS_VERSION_WIN9X, IDR_APPMAN_9X,     0, { 0 }, { 0 } },
  { TEXT("AppManD.dll"),    TRUE,  FALSE, OS_VERSION_WIN9X, IDR_APPMAND_9X,    0, { 0 }, { 0 } },
  { TEXT("AppManDp.dll"),   FALSE, TRUE,  OS_VERSION_WIN9X, IDR_APPMANDP_9X,   0, { 0 }, { 0 } },
  { TEXT("AppMan.dll"),     FALSE, TRUE,  OS_VERSION_WIN2K, IDR_APPMAN_2K,     0, { 0 }, { 0 } },
  { TEXT("AppManD.dll"),    TRUE,  FALSE, OS_VERSION_WIN2K, IDR_APPMAND_2K,    0, { 0 }, { 0 } },
  { TEXT("AppManDp.dll"),   FALSE, TRUE,  OS_VERSION_WIN2K, IDR_APPMANDP_2K,   0, { 0 }, { 0 } }
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL FileExists(LPCTSTR strFilename)
{
  BOOL              fSuccess = TRUE;
  WIN32_FIND_DATA   sFindFileInfo;
  HANDLE            hFindFileHandle;

  hFindFileHandle = FindFirstFile(strFilename, &sFindFileInfo);
  if (INVALID_HANDLE_VALUE == hFindFileHandle)
  {
    fSuccess = FALSE;
  }
  else
  {
    FindClose(hFindFileHandle);
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD GetOSVersion(void)
{
  OSVERSIONINFOEX   sOSVersionInfo;
  DWORD             dwOSVersion = OS_VERSION_WIN32S;

  //
  // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
  // which is supported on Windows 2000.
  //
  // If that fails, try using the OSVERSIONINFO structure.
  //

  ZeroMemory(&sOSVersionInfo, sizeof(OSVERSIONINFOEX));
  sOSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
  if(!GetVersionEx((OSVERSIONINFO *) &sOSVersionInfo))
  {
    //
    // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
    //

    sOSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx((OSVERSIONINFO *) &sOSVersionInfo)) 
    {
      return OS_VERSION_WIN32S;
    }
  }

  //
  // What OS are we running
  //

  switch (sOSVersionInfo.dwPlatformId)
  {
    case VER_PLATFORM_WIN32_NT
    : if (5 == sOSVersionInfo.dwMajorVersion)
      {
        dwOSVersion = OS_VERSION_WIN2000;
      }
      else
      {
        dwOSVersion = OS_VERSION_WINNT;
      }
      break;

    case VER_PLATFORM_WIN32_WINDOWS
    : if ((4 < sOSVersionInfo.dwMajorVersion)||((4 == sOSVersionInfo.dwMajorVersion)&&(0 < sOSVersionInfo.dwMinorVersion)))
      {
        dwOSVersion = OS_VERSION_WIN98;
      } 
      else
      {
        dwOSVersion = OS_VERSION_WIN95;
      }
      break;
   }

   return dwOSVersion; 
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD  StrLen(LPCTSTR strString)
{
  DWORD dwIndex;

  dwIndex = 0;
  while (0 != strString[dwIndex])
  {
    dwIndex++;
  }

  return dwIndex;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL GenerateUniqueFilename(LPCTSTR strRootPath, LPCTSTR strExtension, LPTSTR strFilename)
{
  BOOL    fSuccess = FALSE;
  DWORD   dwTimeTick;
  DWORD   dwIndex, dwRootPathLen;
  LPTSTR  strAdjustedRootPath;

  //
  // Build strAdjustedRootPath
  //

  dwRootPathLen = StrLen(strRootPath) + 1;
  strAdjustedRootPath = new TCHAR [dwRootPathLen];
  if (NULL != strAdjustedRootPath)
  {

#ifdef _UNICODE
    memcpy((LPVOID) strAdjustedRootPath, (LPVOID) strRootPath, (dwRootPathLen * 2));
#else
    memcpy((LPVOID) strAdjustedRootPath, (LPVOID) strRootPath, dwRootPathLen);
#endif

    //
    // If there is a trailing backslash at the end of strRootPath, remove it
    //

    dwIndex = 0;
    do
    {
      dwIndex++;
      if ((0 == strAdjustedRootPath[dwIndex])&&(92 == strAdjustedRootPath[dwIndex - 1]))
      {
        strAdjustedRootPath[dwIndex - 1] = 0;
      }
    }
    while (0 != strAdjustedRootPath[dwIndex]);

    //
    // Generate a temporary filename
    //

    do
    {
      dwTimeTick = GetTickCount();
      wsprintf(strFilename, TEXT("%s\\%08x.%s"), strAdjustedRootPath, dwTimeTick, strExtension);
      if (!FileExists(strFilename))
      {
        fSuccess = TRUE;
      }
    }
    while (!fSuccess);

    //
    // Dont forget to deallocate strAdjustedRootPath
    //

    delete [] strAdjustedRootPath;
  }

  return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\runonce.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include "RunOnce.h"
#include "Global.h"
#include "RegistryKey.h"

BOOL      g_fRunOnceInitialized = FALSE;
TCHAR     g_strRunOnceFilename[MAX_PATH];

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitializeRunOnce(const BOOL fCleanStart)
{
  CRegistryKey  oRegistryKey;
  TCHAR         strSystemPath[MAX_PATH];
  DWORD         dwKeyDisposition;

  //
  // Only run this if g_fRunOnceInitialized is FALSE
  //

  if (!g_fRunOnceInitialized)
  {
    //
    // Where will we find the setup program
    //

    if (GetSystemDirectory(strSystemPath, MAX_PATH))
    {
      wsprintf(g_strRunOnceFilename, TEXT("%s\\WAMSetup.exe"), strSystemPath);

      if (fCleanStart)
      {
        //
        // Now we need to delete any old WAMSetup registry key if it exists
        //

        if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup")))
        {
          oRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup"));
        }

        //
        // Ok, let's create the root registry key used to store setup information
        //

        if (S_OK == oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup"), 0, KEY_ALL_ACCESS, &dwKeyDisposition))
        {
          if (S_OK == oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithRegistration"), 0, KEY_ALL_ACCESS, &dwKeyDisposition))
          {
            if (S_OK == oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithoutRegistration"), 0, KEY_ALL_ACCESS, &dwKeyDisposition))
            {
              g_fRunOnceInitialized = TRUE;
            }
          }
        }

        //
        // Close the Registry Key
        //

        oRegistryKey.CloseKey();
      }
      else
      {
        g_fRunOnceInitialized = TRUE;
      }
    }
  }

  return g_fRunOnceInitialized;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL FinalizeRunOnce(const BOOL fComplete)
{
  BOOL          fSuccess = FALSE;
  CRegistryKey  oRegistryKey;
  DWORD         dwBytesToWrite, dwKeyDisposition;
  TCHAR         strRunOnceCmdLine[MAX_PATH];

  if (g_fRunOnceInitialized)
  {
    if (fComplete)
    {
      //
      // Create/Open the registry key
      //

      if (S_OK == oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"), 0, KEY_ALL_ACCESS, &dwKeyDisposition))
      {
        //
        // What will be the run once command
        //

        wsprintf(strRunOnceCmdLine, TEXT("%s /Cleanup"), g_strRunOnceFilename);

        #ifdef _UNICODE
        dwBytesToWrite = (StrLen(strRunOnceCmdLine) + 1) * 2;
        #else
        dwBytesToWrite = StrLen(strRunOnceCmdLine) + 1;
        #endif  // _UNICODE

        if (S_OK == oRegistryKey.SetValue(TEXT("WAMSetup"), REG_SZ, (LPBYTE) strRunOnceCmdLine, dwBytesToWrite))
        {          
          fSuccess = TRUE;
        }

        //
        // Close the registry key
        //

        oRegistryKey.CloseKey();
      }
    }
    else
    {
      if (FileExists(g_strRunOnceFilename))
      {
        //
        // Make sure we can delete g_strRunOnceFilename on Reboot
        //

        SetFileAttributes(g_strRunOnceFilename, FILE_ATTRIBUTE_NORMAL);

        //
        // Create/Open the registry key
        //

        if (S_OK == oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"), 0, KEY_ALL_ACCESS, &dwKeyDisposition))
        {
          //
          // What will be the run once command do
          //

          if (OS_VERSION_WIN9X & g_dwOSVersion)
          {
            wsprintf(strRunOnceCmdLine, TEXT("command /C del ""%s"""), g_strRunOnceFilename);
          }
          else
          {
            wsprintf(strRunOnceCmdLine, TEXT("cmd /C del /F ""%s"""), g_strRunOnceFilename);
          }

          #ifdef _UNICODE
          dwBytesToWrite = (StrLen(strRunOnceCmdLine) + 1) * 2;
          #else
          dwBytesToWrite = StrLen(strRunOnceCmdLine) + 1;
          #endif  // _UNICODE

          if (S_OK == oRegistryKey.SetValue(TEXT("WAMSetup"), REG_SZ, (LPBYTE) strRunOnceCmdLine, dwBytesToWrite))
          {          
            fSuccess = TRUE;
          }

          //
          // Close the registry key
          //

          oRegistryKey.CloseKey();
        }
      }

      //
      // Delete the WAMSetup registry key
      //

      if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup")))
      {
        oRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup"));
      }

      fSuccess = TRUE;
    }

    //
    // Flag g_fRunOnceInitialized
    //

    g_fRunOnceInitialized = FALSE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL SetRunOnceCleanupFile(LPCTSTR strSourceFilename, LPCTSTR strDestinationFilename, const BOOL fRegister)
{
  BOOL          fSuccess = FALSE;
  CRegistryKey  oRegistryKey;
  TCHAR         strRegistryKey[MAX_PATH];

  if (g_fRunOnceInitialized)
  {
    //
    // What is the target registry key
    //

    if (fRegister)
    {
      wsprintf(strRegistryKey, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithRegistration"));
    }
    else
    {
      wsprintf(strRegistryKey, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithoutRegistration"));
    }

    if (S_OK == oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, strRegistryKey, KEY_ALL_ACCESS))
    {
      //
      // Add a value to the registry. Because it is a REG_SZ value, we do not have to pass in
      // a dwDataLen parameter.
      //

      if (S_OK == oRegistryKey.SetValue(strSourceFilename, REG_SZ, (LPBYTE) strDestinationFilename, 0))
      {
        fSuccess = TRUE;
      }

      //
      // Close the registry key
      //

      oRegistryKey.CloseKey();
    }
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL GetRunOnceCleanupFile(LPTSTR strSourceFilename, const DWORD dwSourceFilenameLen, LPTSTR strDestinationFilename, const DWORD dwDestinationFilenameLen, const BOOL fRegister)
{
  BOOL          fSuccess = FALSE;
  CRegistryKey  oRegistryKey;
  DWORD         dwSourceLen, dwDestinationLen, dwType;
  TCHAR         strRegistryKey[MAX_PATH];

  if (g_fRunOnceInitialized)
  {
    //
    // What is the target registry key
    //

    if (fRegister)
    {
      wsprintf(strRegistryKey, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithRegistration"));
    }
    else
    {
      wsprintf(strRegistryKey, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WAMSetup\\WithoutRegistration"));
    }

    if (S_OK == oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, strRegistryKey, KEY_ALL_ACCESS))
    {
      //
      // Enumerate the first value in the registry key. Once this is done, delete it automatically
      //

      dwSourceLen = dwSourceFilenameLen;
      dwDestinationLen = dwDestinationFilenameLen;
      if (S_OK == oRegistryKey.EnumValues(0, strSourceFilename, &dwSourceLen, &dwType, (LPBYTE) strDestinationFilename, &dwDestinationLen))
      {
        if (S_OK == oRegistryKey.DeleteValue(strSourceFilename))
        {
          fSuccess = TRUE;
        }
      }

      //
      // Close the registry key
      //

      oRegistryKey.CloseKey();
    }
  }

  return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\registrykey.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// RegistryKey.cpp
// 
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of the CRegistryKey class. 
//
// History :
//
//   05/05/2000 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "RegistryKey.h"
#include "Global.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CRegistryKey::CRegistryKey(void)
{
  m_fKeyOpen = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CRegistryKey::~CRegistryKey(void)
{
  CloseKey();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::EnumKeys(const DWORD dwIndex, LPTSTR strKeyName, LPDWORD lpdwKeyNameLen)
{
  FILETIME  sFileTime;
  HRESULT   hResult = S_OK;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (m_fKeyOpen)
  {
    if (ERROR_SUCCESS != RegEnumKeyEx(m_hRegistryKey, dwIndex, strKeyName, lpdwKeyNameLen, NULL, NULL, NULL, &sFileTime))
    {
      hResult = S_FALSE;
    }
  }
  else
  {
    hResult = E_FAIL;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CheckForExistingKey(HKEY hKey, LPCTSTR strKeyName)
{
  HKEY      hRegistryKey;
  HRESULT   hResult = S_OK;

  if (ERROR_SUCCESS != RegOpenKeyEx(hKey, strKeyName, 0, KEY_READ, &hRegistryKey))
  {
    hResult = S_FALSE;
  }
  else
  {
    RegCloseKey(hRegistryKey);
  }

  return hResult;
}


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CreateKey(HKEY hKey, LPCTSTR strKeyName, const DWORD dwOptions, const REGSAM samDesired, LPDWORD lpdwDisposition)
{
  HRESULT               hResult = S_OK;
  SECURITY_ATTRIBUTES   sSecurityAttributes = {0};
  SECURITY_DESCRIPTOR   sSecurityDescriptor = {0};
  
  //
  // Make sure that current registry is closed before proceeding
  //

  CloseKey();

  //
  // Set the security attributes
  //

  sSecurityAttributes.nLength = sizeof sSecurityAttributes;
  sSecurityAttributes.lpSecurityDescriptor = &sSecurityDescriptor;

  InitializeSecurityDescriptor(&sSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(&sSecurityDescriptor, TRUE, NULL, FALSE);

  //
  // Create the new key
  //

  if (ERROR_SUCCESS != RegCreateKeyEx(hKey, strKeyName, 0, NULL, dwOptions, samDesired, &sSecurityAttributes, &m_hRegistryKey, lpdwDisposition))
  {
    hResult = E_FAIL;
  }
  else
  {
    m_fKeyOpen = TRUE;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::OpenKey(HKEY hKey, LPCTSTR strKeyName, const REGSAM samDesired)
{
  HRESULT   hResult = S_OK;

  //
  // Make sure that current registry is closed before proceeding
  //

  CloseKey();

  //
  // Open the existing key
  //

  if (ERROR_SUCCESS != RegOpenKeyEx(hKey, strKeyName, 0, samDesired, &m_hRegistryKey))
  {
    hResult = E_FAIL;
  }
  else
  {
    m_fKeyOpen = TRUE;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CloseKey(void)
{
  HRESULT   hResult = E_FAIL;

  if (m_fKeyOpen)
  {
    if (ERROR_SUCCESS == RegCloseKey(m_hRegistryKey))
    {
      m_fKeyOpen = FALSE;
      hResult = S_OK;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::DeleteKey(HKEY hKey, LPCTSTR strKeyName)
{
  HRESULT   hResult = S_OK;
  DWORD     dwSubKeyNameLen;
  HKEY      hRegistryKey;
  FILETIME  sFileTime;
  TCHAR     strSubKeyName[MAX_PATH];
  TCHAR     strFullSubKeyName[MAX_PATH];
  //
  // Recursively delete all subkeys
  //

  if (ERROR_SUCCESS == RegOpenKeyEx(hKey, strKeyName, 0, KEY_ALL_ACCESS, &hRegistryKey))
  {
    dwSubKeyNameLen = MAX_PATH;
    while ((S_OK == hResult)&&(ERROR_SUCCESS == RegEnumKeyEx(hRegistryKey, 0, strSubKeyName, &dwSubKeyNameLen, NULL, NULL, NULL, &sFileTime)))
    {
      wsprintf(strFullSubKeyName, TEXT("%s\\%s"), strKeyName, strSubKeyName);
      hResult = DeleteKey(hKey, strFullSubKeyName);
      dwSubKeyNameLen = MAX_PATH;
    }

    //
    // Close the key
    //

    RegCloseKey(hRegistryKey);

    //
    // If all the subkeys were successfully deleted
    //

    if (S_OK == hResult)
    {
      //
      // Delete this subkey
      //
  
      if (ERROR_SUCCESS != RegDeleteKey(hKey, strKeyName))
      {
        hResult = E_FAIL;
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::EnumValues(const DWORD dwIndex, LPTSTR strValueName, LPDWORD lpdwValueNameLen, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen)
{
  HRESULT hResult = S_OK;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (m_fKeyOpen)
  {
    if (ERROR_SUCCESS != RegEnumValue(m_hRegistryKey, dwIndex, strValueName, lpdwValueNameLen, NULL, lpdwType, lpData, lpdwDataLen))
    {
      hResult = S_FALSE;
    }
  }
  else
  {
    hResult = E_FAIL;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CheckForExistingValue(LPCTSTR strValueName)
{
  HRESULT   hResult = E_FAIL;

  //
  // If there is no currently opened registry key, then CheckForExistingValue was
  // called unexpectedly
  //

  if (m_fKeyOpen)
  {
    //
    // Check to see whether we can RegQueryValueEx() on the target. If we can then the value
    // exists, othersize it does not
    //

    if (ERROR_SUCCESS != RegQueryValueEx(m_hRegistryKey, strValueName, NULL, NULL, NULL, NULL))
    {
      hResult = S_FALSE;
    }
    else
    {
      hResult = S_OK;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::GetValue(LPCTSTR strValueName, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen)
{
  HRESULT   hResult = E_FAIL;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (m_fKeyOpen)
  {
    if (ERROR_SUCCESS == RegQueryValueEx(m_hRegistryKey, strValueName, NULL, lpdwType, lpData, lpdwDataLen))
    {
      hResult = S_OK;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::SetValue(LPCTSTR strValueName, const DWORD dwType, const BYTE * lpData, const DWORD dwDataLen)
{
  HRESULT   hResult = E_FAIL;
  DWORD     dwActualDataLen;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (m_fKeyOpen)
  {
    //
    // If this value is of type REG_SZ, define the lenght of the string
    //

    if (REG_SZ == dwType)
    {
      #ifdef _UNICODE
      dwActualDataLen = ((StrLen((LPCTSTR) lpData) + 1) * 2);
      #else
      dwActualDataLen = (StrLen((LPCTSTR) lpData) + 1);
      #endif  // _UNICODE
    }
    else
    {
      dwActualDataLen = dwDataLen;
    }

    //
    // Set the registry value
    //

    if (ERROR_SUCCESS == RegSetValueEx(m_hRegistryKey, strValueName, 0, dwType, lpData, dwActualDataLen))
    {
      hResult = S_OK;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::DeleteValue(LPCTSTR strValueName)
{
  HRESULT   hResult = E_FAIL;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (m_fKeyOpen)
  {
    if (ERROR_SUCCESS == RegDeleteValue(m_hRegistryKey, strValueName))
    {
      hResult = S_OK;
    }
  }

  return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\registrykey.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// RegistryKey.h
// 
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the definition of the CRegistryKey class.
//
// History :
//
//   05/05/2000 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if !defined(__REGISTRYKEY_)
#define __REGISTRYKEY_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <objbase.h>
#include <stdio.h>

class CRegistryKey
{
  public :

    CRegistryKey(void);
    ~CRegistryKey(void);

    STDMETHOD (EnumKeys) (const DWORD dwIndex, LPTSTR strKeyName, LPDWORD lpdwKeyNameLen);
    STDMETHOD (CheckForExistingKey) (HKEY hKey, LPCTSTR strKeyName);
    STDMETHOD (CreateKey) (HKEY hKey, LPCTSTR strKeyName, const DWORD dwOptions, const REGSAM samDesired, LPDWORD lpdwDisposition);
    STDMETHOD (OpenKey) (HKEY hKey, LPCTSTR strKeyName, const REGSAM samDesired);
    STDMETHOD (CloseKey) (void);
    STDMETHOD (DeleteKey) (HKEY hKey, LPCTSTR strKeyName);
 
    STDMETHOD (EnumValues) (const DWORD dwIndex, LPTSTR strValueName, LPDWORD lpdwValueNameLen, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen);
    STDMETHOD (CheckForExistingValue) (LPCTSTR strValueName);
    STDMETHOD (GetValue) (LPCTSTR strValueName, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen);
    STDMETHOD (SetValue) (LPCTSTR strValueName, const DWORD dwType, const BYTE * lpData, const DWORD dwDataLen);
    STDMETHOD (DeleteValue) (LPCTSTR strValueName);

  private :

    BOOL    m_fKeyOpen;
    HKEY    m_hRegistryKey;
};

#ifdef __cplusplus
}
#endif

#endif  // __REGISTRYKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\sources.inc ===
MAJORCOMP=
MINORCOMP=

TARGETNAME=WAMSetup
TARGETTYPE=PROGRAM
TARGETPATH=Obj

BINPLACE_PLACEFILE=$(DXROOT)\public\sdk\lib\placefil.txt
C_DEFINES=$(C_DEFINES) -DWIN9X_RETAIL_APPMAN=$(_NTDRIVE)\binaries.x86fre\Win9x\AppMan.dll -DWIN9X_DEBUG_APPMAN=$(_NTDRIVE)\binaries.x86chk\Win9x\AppManD.dll -DWIN9X_RETAIL_APPMANDP=$(_NTDRIVE)\binaries.x86fre\Win9x\AppManDp.dll -DWIN2K_RETAIL_APPMAN=$(_NTDRIVE)\binaries.x86fre\AppMan.dll -DWIN2K_DEBUG_APPMAN=$(_NTDRIVE)\binaries.x86chk\AppManD.dll -DWIN2K_RETAIL_APPMANDP=$(_NTDRIVE)\binaries.x86fre\AppManDp.dll

!IF "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

USE_MAPSYM = 1
RC_DEFINES=$(RC_DEFINES) -DDEBUG=1
C_DEFINES=$(C_DEFINES) -DWIN32 -D_DEBUG -D_WINDOWS -DMBCS -D__INTERNAL_
TARGETLIBS= $(BASEDIR)\Public\sdk\lib\*\comctl32.lib    \
            $(BASEDIR)\Public\sdk\lib\*\winmm.lib       \
            $(BASEDIR)\Public\sdk\lib\*\comdlg32.lib    \
            $(BASEDIR)\Public\sdk\lib\*\version.lib     \
            $(BASEDIR)\Public\sdk\lib\*\shell32.lib     \
            $(BASEDIR)\Public\sdk\lib\*\ole32.lib       \
            $(BASEDIR)\Public\sdk\lib\*\uuid.lib

!ELSE

C_DEFINES=$(C_DEFINES) -DWIN32 -DNDEBUG -D_WINDOWS -DMBCS
TARGETLIBS= $(BASEDIR)\Public\sdk\lib\*\comctl32.lib    \
            $(BASEDIR)\Public\sdk\lib\*\winmm.lib       \
            $(BASEDIR)\Public\sdk\lib\*\comdlg32.lib    \
            $(BASEDIR)\Public\sdk\lib\*\version.lib     \
            $(BASEDIR)\Public\sdk\lib\*\shell32.lib     \
            $(BASEDIR)\Public\sdk\lib\*\ole32.lib       \
            $(BASEDIR)\Public\sdk\lib\*\uuid.lib

!ENDIF

INCLUDES=$(SDXROOT)\Multimedia\Directx\inc; \
         $(SDK_INC_PATH); \
         $(MM_INC_PATH)\ApplicationManager; \
         $(SDXROOT)\public\sdk\inc\mfc42;

SOURCES=AppManSetup.rc \
        Global.cpp \
        Main.cpp \
        RegistryKey.cpp \
        RunOnce.cpp \

UMTYPE=windows
UMENTRY=winmain
UMAPPL=
UMLIBS=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\win9x\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\daytona\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\appmansetup\runonce.h ===
#ifndef __RUNONCE_
#define __RUNONCE_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>

extern BOOL InitializeRunOnce(const BOOL fCleanStart);
extern BOOL FinalizeRunOnce(const BOOL fComplete);
extern BOOL SetRunOnceCleanupFile(LPCTSTR strSourceFilename, LPCTSTR strDestinationFilename, const BOOL fRegister);
extern BOOL GetRunOnceCleanupFile(LPTSTR strSourceFilename, const DWORD dwSourceFilenameLen, LPTSTR strDestinationFilename, const DWORD dwDestinationFilenameLen, const BOOL fRegister);

//////////////////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif  // __RUNONCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\applicationentry.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ApplicationEntry.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of IApplicationEntry
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <string.h>
#include "Resource.h"
#include "AppMan.h"
#include "Win32API.h"
#include "ApplicationManager.h"
#include "ExceptionHandler.h"
#include "Lock.h"
#include "AppManDebug.h"
#include "StructIdentifiers.h"
#include "Global.h"

//To flag as DBG_APPENTRY
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPENTRY

//
// Macro definition used within this source file only
//

#define VALIDATE_PROPERTY(a)          m_InformationManager.ValidateApplicationPropertyWithIndex((a), &m_sApplicationData)
#define INVALIDATE_PROPERTY(a)        m_InformationManager.InvalidateApplicationPropertyWithIndex((a), &m_sApplicationData)

#define RESET_ACTIONSTATE(a)          m_dwCurrentAction = (a)
#define SET_ACTIONSTATE(a)            m_dwCurrentAction = (a)
#define CHECK_ACTIONSTATE(a)          ((a) == m_dwCurrentAction)
#define GET_ACTIONSTATE(a)            (m_dwCurrentAction)
#define CLEAR_ACTIONSTATE(a)          m_dwCurrentAction = CURRENT_ACTION_NONE

#define VALIDATE_STATE_FIELD()        if (0 != m_sApplicationData.sBaseInfo.dwState) { VALIDATE_PROPERTY(IDX_PROPERTY_STATE); m_InformationManager.SetApplicationState(&m_sApplicationData, &m_sInstanceGuid); } else { INVALIDATE_PROPERTY(IDX_PROPERTY_STATE); }
#define CHECK_APPLICATIONSTATE(a)     (m_sApplicationData.sBaseInfo.dwState & (a))
#define RESET_APPLICATIONSTATE(a)     m_sApplicationData.sBaseInfo.dwState = (a); VALIDATE_STATE_FIELD()
#define SET_APPLICATIONSTATE(a)       m_sApplicationData.sBaseInfo.dwState = (a); VALIDATE_STATE_FIELD()
#define GET_APPLICATIONSTATE()        (m_sApplicationData.sBaseInfo.dwState)
#define CLEAR_APPLICATIONSTATE()      m_sApplicationData.sBaseInfo.dwState = 0; VALIDATE_STATE_FIELD()

#define VALIDATE_CATEGORY_FIELD()     if (APP_CATEGORY_NONE != m_sApplicationData.sBaseInfo.dwCategory) { VALIDATE_PROPERTY(IDX_PROPERTY_CATEGORY); } else { INVALIDATE_PROPERTY(IDX_PROPERTY_CATEGORY); }
#define CHECK_APPLICATIONCATEGORY(a)  ((a) == (m_sApplicationData.sBaseInfo.dwCategory & (a)))
#define RESET_APPLICATIONCATEGORY(a)  m_sApplicationData.sBaseInfo.dwCategory = (a); VALIDATE_CATEGORY_FIELD()
#define SET_APPLICATIONCATEGORY(a)    m_sApplicationData.sBaseInfo.dwCategory |= (a); VALIDATE_CATEGORY_FIELD()
#define GET_APPLICATIONCATEGORY()     (m_sApplicationData.sBaseInfo.dwCategory)
#define CLEAR_APPLICATIONCATEGORY()   m_sApplicationData.sBaseInfo.dwCategory = APP_CATEGORY_NONE; VALIDATE_CATEGORY_FIELD()

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationEntry::CApplicationEntry(void)
{
  FUNCTION("CApplicationEntry::CApplicationEntry (void)");

  m_dwLockCount = 0;
  m_fIsInitialized = FALSE;
  m_dwCurrentAction = CURRENT_ACTION_NONE;
  m_lReferenceCount = 1;
  m_hInstanceMutex = NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationEntry::~CApplicationEntry(void)
{
  FUNCTION("CApplicationEntry::~CApplicationEntry (void)");

  if (CURRENT_ACTION_NONE != m_dwCurrentAction)
  {
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;

    //
    // We need to force a leave event
    //

    switch(m_dwCurrentAction)
    {
      case CURRENT_ACTION_DOWNSIZING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);
        break;

      case CURRENT_ACTION_REINSTALLING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
        break;

      case CURRENT_ACTION_UNINSTALLING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL);
        break;

      case CURRENT_ACTION_SELFTESTING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
        break;

      case (CURRENT_ACTION_SELFTESTING | CURRENT_ACTION_REINSTALLING)
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
        m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
        break;
    }

    //
    // Before we do anything, make sure to unlock the parent apps
    //

    ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
    dwIndex = 0;
    while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
    {
      if (0 == memcmp((LPVOID) &(sAssociationInfo.sChildGuid), (LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), sizeof(GUID)))
      {
        //
        // Get the associated application
        //

        ZeroMemory(&sApplicationData, sizeof(sApplicationData));
        memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
        m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
        if (SUCCEEDED(m_InformationManager.GetApplicationData(&sApplicationData)))
        {
          //
          // Unlock the parent applications
          //

          m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
        }
      }
      dwIndex++;
    }

    //
    // If the application was doing an initial install, abort will cause the application
    // entry to be removed from the system
    //

    UnLockApplication();
  }

  //  4/12/2000(RichGr): If we've got a mutex, release and close it.  We were leaking handles
  //     when swopping between AppManDiagTool tabs.
  if (NULL != m_hInstanceMutex)
  {
    ReleaseMutex(m_hInstanceMutex);
    CloseHandle(m_hInstanceMutex);
    m_hInstanceMutex = NULL;
  }

  if (TRUE == m_fIsInitialized)
  {
    m_InformationManager.ForceUnlockApplicationData(&m_sApplicationData, &m_sInstanceGuid);
  }

}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO : the constructor requires that the incoming parameter
//        be a const, we cannot lock the source object by calling Lock() (which is not
//        a const method. So, when the copying occurs, the source object will not be locked
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationEntry::CApplicationEntry(const CApplicationEntry & /*refSourceObject*/)     // Get rid of /W4 warnings.
{
  FUNCTION("CApplicationEntry::CApplicationEntry (const CApplicationEntry &refSourceObject)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationEntry & CApplicationEntry::operator = (const CApplicationEntry & /*refSourceObject*/)
{
  return * this;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::QueryInterface(REFIID RefIID, LPVOID * ppVoidObject)
{
  FUNCTION("CAppEntry::QueryInterface ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (NULL == &RefIID)
    {
      THROW(E_UNEXPECTED);
    }

    if (NULL == ppVoidObject)
    {
      THROW(E_UNEXPECTED);
    }

    *ppVoidObject = NULL;

    if ((RefIID == IID_IUnknown)||(RefIID == IID_ApplicationEntry))
    {
      *ppVoidObject = (LPVOID) this;
    }

    if (*ppVoidObject)
    {
      ((LPUNKNOWN)*ppVoidObject)->AddRef();
    }
    else
    {
      hResult = E_NOINTERFACE;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    if ((NULL == &RefIID)||(NULL == ppVoidObject)||(IsBadWritePtr(ppVoidObject, sizeof(LPVOID))))
    {
      hResult = E_INVALIDARG;
    }
    else
    {
      hResult = E_UNEXPECTED;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;  
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationEntry::AddRef(void)
{
  FUNCTION("CAppEntry::AddRef ()");

  return InterlockedIncrement(&m_lReferenceCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationEntry::Release(void)
{
  FUNCTION("CAppEntry::Release ()");

  DWORD dwReferenceCount;

  dwReferenceCount = InterlockedDecrement(&m_lReferenceCount);
  if (0 == dwReferenceCount)
  {
    delete this;
  }

  return dwReferenceCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::Initialize(void)
{
  FUNCTION("CAppEntry::Initialize ()");

  HRESULT hResult;

  hResult = m_sCriticalSection.Initialize();
  if (SUCCEEDED(hResult))
  {
    hResult = m_InformationManager.Initialize();
    if (SUCCEEDED(hResult))
    {
      hResult = Clear();
      if (SUCCEEDED(hResult))
      {
        m_fIsInitialized = TRUE;
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::SetInitializationLevel(DWORD dwInitializationLevel)
{
  FUNCTION("CAppEntry::SetInitializationLevel ()");

  m_dwInitializationLevel = dwInitializationLevel;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(DWORD) CApplicationEntry::GetActionState(void)
{
  FUNCTION("CAppEntry::GetActionState ()");

  return m_dwCurrentAction;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::LockApplication(void)
{
  FUNCTION("CAppEntry::LockApplication ()");

  HRESULT   hResult;

  hResult = m_InformationManager.LockApplicationData(&m_sApplicationData, &m_sInstanceGuid);
  if (SUCCEEDED(hResult))
  {
    m_dwLockCount++;
  }
  else
  {
    THROW(APPMAN_E_APPLICATIONALREADYLOCKED);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::UnLockApplication(void)
{
  FUNCTION("CAppEntry::UnLockApplication ()");

  HRESULT   hResult;

  hResult = m_InformationManager.UnlockApplicationData(&m_sApplicationData, &m_sInstanceGuid);
  if (SUCCEEDED(hResult))
  {
    if (0 < m_dwLockCount)
    {
      m_dwLockCount--;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::Clear(void)
{
  FUNCTION("CAppEntry::Clear ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CLock   sLock(&m_sCriticalSection);
    DWORD   dwIndex;
    CHAR    szString[MAX_PATH];

    sLock.Lock();

    //
    // Make sure we are not in the middle of an action
    //

    if (CURRENT_ACTION_NONE != m_dwCurrentAction)
    {
  		THROW(APPMAN_E_ACTIONINPROGRESS);
    }

    //
    // Make sure this application instance is not locked
    //

    if (0 != m_dwLockCount)
    {
      THROW(APPMAN_E_APPLICATIONALREADYLOCKED);
    }

    //
    // Ok, let's wipe the object
    //

    m_dwInitializationLevel = INIT_LEVEL_NONE;
    ZeroMemory(&m_sApplicationData, sizeof(m_sApplicationData));

    //
    // Initialize the structure headers
    //

    m_sApplicationData.sAgingInfo.dwSize = sizeof(m_sApplicationData.sAgingInfo);
    m_sApplicationData.sAgingInfo.dwStructId = AGING_STRUCT;

    m_sApplicationData.sBaseInfo.dwSize = sizeof(m_sApplicationData.sBaseInfo);
    m_sApplicationData.sBaseInfo.dwStructId = BASIC_APPINFO_STRUCT;

    m_sApplicationData.sAssociation.dwSize = sizeof(m_sApplicationData.sAssociation);
    m_sApplicationData.sAssociation.dwStructId = ASSOCIATION_STRUCT;

    //
    // Since this is a new object, let's initialize the crypto string
    //

    RandomInit();

    for (dwIndex = 0; dwIndex < MAX_PATH_CHARCOUNT + 1; dwIndex++)
    {
      m_sApplicationData.wszStringProperty[APP_STRING_CRYPTO][dwIndex] = RandomWORD();
    }

    //
    // If the object was assigned a mutex, kill the mutex
    //


    if (NULL != m_hInstanceMutex)
    {
      ReleaseMutex(m_hInstanceMutex);
      CloseHandle(m_hInstanceMutex);
      m_hInstanceMutex = NULL;
    }

    //
    // Create the instance info and constructs
    //

    if (FAILED(CoCreateGuid(&m_sInstanceGuid)))
    {
      THROW(E_UNEXPECTED);
    }
    sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", m_sInstanceGuid.Data1, m_sInstanceGuid.Data2, m_sInstanceGuid.Data3, m_sInstanceGuid.Data4[0], m_sInstanceGuid.Data4[1], m_sInstanceGuid.Data4[2], m_sInstanceGuid.Data4[3], m_sInstanceGuid.Data4[4], m_sInstanceGuid.Data4[5], m_sInstanceGuid.Data4[6], m_sInstanceGuid.Data4[7]);
    m_hInstanceMutex = CreateMutex(NULL, TRUE, szString);

    sLock.UnLock();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ValidateGetPropertyParameters(const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CApplicationInfo::ValidateGetPropertyParameters (const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPVOID lpData, const DWORD dwDataLen)");

  //
  // Is the property currently initialized
  //

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(dwPropertyIndex, &m_sApplicationData))
  {
    THROW(APPMAN_E_PROPERTYNOTSET);
  }

  //
  // Are we actually allowed to read this property
  //

  if (!(m_dwInitializationLevel & gPropertyInfo[dwPropertyIndex].dwReadMask))
  {
    THROW(APPMAN_E_PROPERTYNOTSET);
  }

  //
  // The property being passed in is either a GUID, a DWORD or a string
  //

  if (APP_STRING_NONE == gPropertyInfo[dwPropertyIndex].dwStringId)
  {

    //
    // dwPropertyModifers should be 0
    //

    if (0 != dwPropertyModifiers)
    {
      THROW(APPMAN_E_INVALIDPROPERTY);
    }

    //
    // Make sure dwDataLen is correct
    //

    if (gPropertyInfo[dwPropertyIndex].dwMaxLen != dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPROPERTYSIZE);
    }

    //
    // Since the property is a GUID or a DWORD, the dwDatalen should be fixed
    //

    if ((NULL == lpData)||(IsBadWritePtr(lpData, dwDataLen)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }
  }
  else
  {
    //
    // Make sure dwDataLen is correct
    //

    if (0 == dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPROPERTYSIZE);
    }

    //
    // Determine the character count in the incoming string
    //

    if ((APP_PROPERTY_STR_ANSI != dwPropertyModifiers)&&(APP_PROPERTY_STR_UNICODE != dwPropertyModifiers)&&(0 != dwPropertyModifiers))
    {
      THROW(APPMAN_E_INVALIDPROPERTYVALUE);
    }

    //
    // The property is a string
    //

    if ((NULL == lpData)||(IsBadWritePtr(lpData, dwDataLen)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }
  }
  
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ValidateStringProperty(const DWORD dwPropertyIndex, const DWORD /*dwPropertyModifiers*/, LPCWSTR wszStringProperty)
{
  FUNCTION("CAppEntry::ValidateStringProperty ()");

  CWin32API   sWin32API;

  if ((IDX_PROPERTY_COMPANYNAME == dwPropertyIndex)||(IDX_PROPERTY_SIGNATURE == dwPropertyIndex))
  {
    //
    // First we make sure that this is even a valid path
    //

    if (!sWin32API.IsValidFilename(wszStringProperty))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ValidateSetPropertyParameters(const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPCVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CApplicationInfo::ValidateSetPropertyParameters (const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPCVOID lpData, const DWORD dwDataLen)");

  DWORD   dwCharCount = 0;

  //
  // Determine whether or not we are allowed to set this property at this time
  //

  if (!(m_dwCurrentAction & gPropertyInfo[dwPropertyIndex].dwWriteMask))
  {
	  THROW(APPMAN_E_READONLYPROPERTY);
  }

  //
  // This is a special case when APP_PROPERTY_EXECUTECMDLINE is used. If the category has the
  // APP_CATEGORY_PATCH or APP_CATEGORY_DATA, then the APP_PROPERTY_EXECUTECMDLINE is
  // not setable
  //

  if (((APP_CATEGORY_PATCH | APP_CATEGORY_DATA) & m_sApplicationData.sBaseInfo.dwCategory)&&(IDX_PROPERTY_EXECUTECMDLINE == dwPropertyIndex))
  {
    THROW(APPMAN_E_READONLYPROPERTY);
  }
  
  //
  // The property being passed in is either a GUID/DWORD or a string
  //

  if (APP_STRING_NONE == gPropertyInfo[dwPropertyIndex].dwStringId)
  {
    //
    // dwPropertyModifers should be 0
    //

    if (0 != dwPropertyModifiers)
    {
      THROW(APPMAN_E_INVALIDPROPERTY);
    }

    //
    // Make sure dwDataLen is correct
    //

    if (gPropertyInfo[dwPropertyIndex].dwMaxLen != dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPROPERTYSIZE);
    }
    
    //
    // Since the property is a GUID or a DWORD, the dwDatalen should be fixed
    //

    if ((NULL == lpData)||(IsBadReadPtr(lpData, dwDataLen)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }
  }
  else
  {
    //
    // The property is a string.
    //

    if (NULL != lpData)
    {
      if (0 == dwDataLen)
      {
        THROW(APPMAN_E_INVALIDPROPERTYSIZE);
      }

      //
      // First determine whether or not we can actual read the incoming string
      //

      if (IsBadReadPtr(lpData, dwDataLen))
      {
        THROW(APPMAN_E_INVALIDPARAMETERS);
      }

      //
      // Determine the character count in the incoming string
      //

      if (APP_PROPERTY_STR_ANSI == dwPropertyModifiers)
      {
        dwCharCount = StrLenA((LPSTR) lpData);
      }
      else
      {
        if ((APP_PROPERTY_STR_UNICODE == dwPropertyModifiers)||(0 == dwPropertyModifiers))
        {
          dwCharCount = StrLenW((LPWSTR) lpData);
        }
        else
        {
          THROW(APPMAN_E_INVALIDPROPERTYVALUE);
        }
      }

      //
      // Determine whether or not the storage buffer are big enough for the incoming string
      //

      if (gPropertyInfo[dwPropertyIndex].dwMaxLen < dwCharCount)
      {
        THROW(APPMAN_E_OVERFLOW);
      }
    }
  }
  
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ValidateCommandLine(LPCWSTR wszRootPath, LPCWSTR wszCommandLine)
{
  FUNCTION("CAppEntry::ValidateCommandLine ()");
  
  CWin32API   Win32API;
  BOOL        fApplicationExists = FALSE;
  DWORD       dwIndex, dwRootPathLen, dwCommandLineLen;
  WCHAR       wszTempPath[MAX_PATH_CHARCOUNT+1];

  dwRootPathLen = wcslen(wszRootPath);
  dwCommandLineLen = wcslen(wszCommandLine);
  ZeroMemory(wszTempPath, sizeof(wszTempPath));
  wcscpy(wszTempPath, wszCommandLine);

  //
  // Make sure that wszRootPath is the subpath of wszCommandLine
  //

  if (0 != _wcsnicmp(wszRootPath, wszCommandLine, dwRootPathLen))
  {
    return E_FAIL;
  }

  //
  // At this point we go looking for .exe/.bat/.com and try to findfirstfile on the string
  //

  dwIndex = dwRootPathLen;
  while ((FALSE == fApplicationExists)&&(dwIndex <= dwCommandLineLen))
  {
    //
    // Slowly increment the wszTempPath string
    //

    wszTempPath[dwIndex] = wszCommandLine[dwIndex];
    dwIndex++;
    wszTempPath[dwIndex] = 0;

    if (4 < dwIndex)
    {
      //
      // Are the last 4 characters of wszTEmpPath ".EXE"
      //

      if (!_wcsnicmp(&wszTempPath[dwIndex-4], L".EXE", 4))
      {
        if (Win32API.FileExists(wszTempPath))
        {
          if (!(FILE_ATTRIBUTE_DIRECTORY & Win32API.FileAttributes(wszTempPath)))
          {
            fApplicationExists = TRUE;
          }
        }
      }

      //
      // Are the last 4 characters of wszTEmpPath ".BAT"
      //

      if (!_wcsnicmp(&wszTempPath[dwIndex-4], L".BAT", 4))
      {
        if (Win32API.FileExists(wszTempPath))
        {
          if (!(FILE_ATTRIBUTE_DIRECTORY & Win32API.FileAttributes(wszTempPath)))
          {
            fApplicationExists = TRUE;
          }
        }
      }

      //
      // Are the last 4 characters of wszTEmpPath ".COM"
      //

      if (!_wcsnicmp(&wszTempPath[dwIndex-4], L".COM", 4))
      {
        if (Win32API.FileExists(wszTempPath))
        {
          if (!(FILE_ATTRIBUTE_DIRECTORY & Win32API.FileAttributes(wszTempPath)))
          {
            fApplicationExists = TRUE;
          }
        }
      }

      //
      // Are the last 4 characters of wszTEmpPath ".CMD"
      //

      if (!_wcsnicmp(&wszTempPath[dwIndex-4], L".CMD", 4))
      {
        if (Win32API.FileExists(wszTempPath))
        {
          if (!(FILE_ATTRIBUTE_DIRECTORY & Win32API.FileAttributes(wszTempPath)))
          {
            fApplicationExists = TRUE;
          }
        }
      }
    }
  }

  if (FALSE == fApplicationExists)
  {
    return S_FALSE;
  } 
  else 
  {
    return S_OK;
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO : Insert checking to make sure properties are not set at a bad time
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::SetProperty(const DWORD dwProperty, LPCVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::SetProperty ()");
  DPFMSG(MakeString("dwProperty = 0x%08x", dwProperty));

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CLock   sLock(&m_sCriticalSection);
    DWORD   dwFilteredProperty, dwPropertyModifiers, dwPropertyIndex;
    DWORD   dwStringIndex, dwCharCount;

    if (FALSE == m_fIsInitialized)
    {
      THROW(APPMAN_E_NOTINITIALIZED);
    }

    sLock.Lock();

    //
    // Extract the filtered property value and the property modifier value
    //

    dwFilteredProperty = dwProperty & 0x0000ffff;
    dwPropertyModifiers = dwProperty & 0xffff0000;

    //
    // Was the property passed in a valid property value
    //

    if (S_OK != m_InformationManager.IsValidApplicationProperty(dwFilteredProperty))
    {
      THROW(APPMAN_E_INVALIDPROPERTY);
    }

    //
    // Get the internal property index for dwProperty
    //

    dwPropertyIndex = m_InformationManager.GetPropertyIndex(dwFilteredProperty);

    //
    // Are the dwProperty/lpData/dwDataLen parameters valid and properly sized
    //

    ValidateSetPropertyParameters(dwPropertyIndex, dwPropertyModifiers, lpData, dwDataLen);

    //
    // Get the property
    //

    dwStringIndex = gPropertyInfo[dwPropertyIndex].dwStringId;

    if (APP_STRING_NONE == dwStringIndex)
    {
      switch(dwPropertyIndex)
      {
        case IDX_PROPERTY_GUID
        : memcpy(&m_sApplicationData.sBaseInfo.sApplicationGuid, lpData, sizeof(GUID));
          break;
        case IDX_PROPERTY_STATE
        : m_sApplicationData.sBaseInfo.dwState = *((LPDWORD) lpData);
          if (APP_STATE_DOWNSIZED != m_sApplicationData.sBaseInfo.dwState)
          {
            THROW(APPMAN_E_INVALIDPROPERTYVALUE);
          }
          break;
        case IDX_PROPERTY_CATEGORY
        : m_sApplicationData.sBaseInfo.dwCategory = *((LPDWORD) lpData);
          if (((~APP_CATEGORY_ALL) & m_sApplicationData.sBaseInfo.dwCategory)||(!(0x0000ffff & m_sApplicationData.sBaseInfo.dwCategory)))
          {
            THROW(APPMAN_E_INVALIDPROPERTYVALUE);
          }
          break;
        case IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES
        : m_sApplicationData.sBaseInfo.dwReservedKilobytes = *((LPDWORD) lpData);
          break;
        case IDX_PROPERTY_NONREMOVABLEKILOBYTES
        : 
          break;
        case IDX_PROPERTY_REMOVABLEKILOBYTES
        : 
          break;
        case IDX_PROPERTY_INSTALLDATE:
        case IDX_PROPERTY_LASTUSEDDATE
        : THROW(APPMAN_E_READONLYPROPERTY);
          break;
        default
        : THROW(E_UNEXPECTED);
          break;
      }
    }
    else
    {
      //
      // Are we dealing with the APP_PROPERTY_ROOTPATH
      // 

      if (IDX_PROPERTY_ROOTPATH == dwPropertyIndex)
      {
        DWORD dwAdvancedMode = 0;

        m_InformationManager.GetAdvancedMode(&dwAdvancedMode);
        if (0 == dwAdvancedMode)
        {
          THROW(APPMAN_E_READONLYPROPERTY);
        }
        else
        {
          if (0 != m_sApplicationData.sAssociation.dwAssociationType)
          {
            THROW(APPMAN_E_READONLYPROPERTY);
          }
        }
      }

      //
      // Make ANSI into UNICODE string if required
      //

      if (APP_PROPERTY_STR_ANSI & dwProperty)
      {
        dwCharCount = StrLenA((LPSTR) lpData);
        CWin32API::MultiByteToWideChar((LPCSTR) lpData, dwDataLen, m_sApplicationData.wszStringProperty[dwStringIndex], MAX_PATH_CHARCOUNT);
      }
      else
      {
        dwCharCount = StrLenW((LPWSTR) lpData);
        memcpy((LPVOID) m_sApplicationData.wszStringProperty[dwStringIndex], (LPVOID) lpData, dwDataLen);
      }

      //
      // Make sure that the value we have just set is a valid string
      //

      ValidateStringProperty(dwPropertyIndex, dwPropertyModifiers, m_sApplicationData.wszStringProperty[dwStringIndex]);
    }

    //
    // Make sure the validate the newly set property
    //

    m_InformationManager.ValidateApplicationPropertyWithIndex(dwPropertyIndex, &m_sApplicationData);

    sLock.UnLock();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::GetProperty(const DWORD dwProperty, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::GetProperty ()");
  DPFMSG(MakeString("dwProperty = 0x%08x", dwProperty));

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CLock   sLock(&m_sCriticalSection);
    DWORD   dwFilteredProperty, dwPropertyModifiers, dwPropertyIndex, dwCharCount, dwStringIndex;

    if (FALSE == m_fIsInitialized)
    {
      THROW(APPMAN_E_NOTINITIALIZED);
    }

    sLock.Lock();

    //
    // Extract the filtered property value and the property modifier value
    //

    dwFilteredProperty = dwProperty & 0x0000ffff;
    dwPropertyModifiers = dwProperty & 0xffff0000;

    //
    // Was the property passed in a valid property value
    //

    if (S_OK != m_InformationManager.IsValidApplicationProperty(dwFilteredProperty))
    {
      THROW(APPMAN_E_INVALIDPROPERTY);
    }

    //
    // Get the internal property index for dwProperty
    //

    dwPropertyIndex = m_InformationManager.GetPropertyIndex(dwFilteredProperty);

    //
    // Are the dwProperty/lpData/dwDataLen parameters valid and properly sized
    //

    ValidateGetPropertyParameters(dwPropertyIndex, dwPropertyModifiers, lpData, dwDataLen);

    //
    // Get the property
    //

    dwStringIndex = gPropertyInfo[dwPropertyIndex].dwStringId;
    if (APP_STRING_NONE == dwStringIndex)
    {
      switch(dwPropertyIndex)
      {
        case IDX_PROPERTY_GUID
        : memcpy((LPVOID) lpData, (LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID));
          break;
        case IDX_PROPERTY_STATE
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwState;
          break;
        case IDX_PROPERTY_CATEGORY
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwCategory;
          break;
        case IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwReservedKilobytes;
          break;
        case IDX_PROPERTY_NONREMOVABLEKILOBYTES
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes;
          break;
        case IDX_PROPERTY_REMOVABLEKILOBYTES
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwRemovableKilobytes;
          break;
        case IDX_PROPERTY_INSTALLDATE
        : memcpy((LPVOID) lpData, (LPVOID) &m_sApplicationData.sAgingInfo.stInstallDate, sizeof(SYSTEMTIME));
          break;
        case IDX_PROPERTY_LASTUSEDDATE
        : memcpy((LPVOID) lpData, (LPVOID) &m_sApplicationData.sAgingInfo.stLastUsedDate, sizeof(SYSTEMTIME));
          break;
        case IDX_PROPERTY_PIN
        : *(LPDWORD)lpData = m_sApplicationData.sBaseInfo.dwPinState;
          break;
        default
        : THROW(E_UNEXPECTED);
          break;
      }
    }
    else
    {
      if (APP_PROPERTY_STR_ANSI == dwPropertyModifiers)
      {
        dwCharCount = StrLenW((LPWSTR) m_sApplicationData.wszStringProperty[dwStringIndex]);
        if (dwDataLen < dwCharCount)
        {
          THROW(APPMAN_E_OVERFLOW);
        }
        CWin32API::WideCharToMultiByte((LPCWSTR) m_sApplicationData.wszStringProperty[dwStringIndex], MAX_PATH_CHARCOUNT, (LPSTR) lpData, dwDataLen);
      }
      else
      {
        dwCharCount = StrLenW((LPWSTR) m_sApplicationData.wszStringProperty[dwStringIndex]);
        if (dwDataLen < (dwCharCount*2))
        {
          THROW(APPMAN_E_OVERFLOW);
        }
        memcpy((LPVOID) lpData, (LPVOID) m_sApplicationData.wszStringProperty[dwStringIndex], dwCharCount*2);
      }
    }

    sLock.UnLock();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// The InitializeInstall() method will do the following actions before successfully returning.
// If any of these steps fail, the method will return a failure.
//
// (1) Make sure the application object is not undergoing any other action
// (2) Make sure that APP_PROPERTY_TYPE is set
// (3) Make sure that APP_PROPERTY_SIGNATURE is set
// (4) Make sure that APP_PROPERTY_ESTIMATED_INSTALL_SIZE is set
// (5) Make sure that the application is not already installed
// (6) Make sure to set the state of the application to APP_STATE_INSTALLING
// (7) Explicitly call m_InformationManager.SetApplicationInfo() in order to prevent
//     step (8) from happening in case of a failure
// (8) Make sure to set the state of the m_dwCurrentAction
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::InitializeInstall(void)
{
  FUNCTION("CAppEntry::InitializeInstall ()");

  HRESULT   hResult = S_OK;
  BOOL      fParentLocked = FALSE;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CWin32API         Win32API;
    DWORD             dwIndex, dwReservedKilobytes, dwAdvancedMode;
    BOOL              fApplicationRootExists;
    APPLICATION_DATA  sApplicationData;
    DEVICE_RECORD     sDeviceRecord;
    WCHAR             wszRootPath[5];
    GUID              sPathGuid;

    //
    // Make sure this object is not currently being used in another action
    //

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }

    //
    // Get the advanced mode
    //

    m_InformationManager.GetAdvancedMode(&dwAdvancedMode);

    //
    // Make sure the required fields are present
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_COMPANYNAME, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }
     
    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SIGNATURE, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }
 
    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_CATEGORY, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    if ((0 < dwAdvancedMode)&&(0 == m_sApplicationData.sAssociation.dwAssociationType))
    {
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
      else
      {
        if (FALSE == Win32API.FileExists(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]))
        {
          //
          // We want to see if we can even create this directory. If we can, delete it right
          // away in order to make sure that an empty directory is not created until we absolutely
          // have to
          //

          if (!Win32API.CreateDirectory(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], TRUE))
          {
            THROW(APPMAN_E_INVALIDROOTPATH);
          }
          else
          {
            Win32API.RemoveDirectory(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]);
          }
        }
      }
    }

    //
    // Since this should be a new application
    //

    m_sApplicationData.sBaseInfo.dwPinState = FALSE;
    VALIDATE_PROPERTY(IDX_PROPERTY_PIN);

    //
    // Is this is a brand new application entry
    //

    if (S_FALSE == m_InformationManager.CheckApplicationExistance(&m_sApplicationData))
    {
      DWORD     dwDeviceIndex;
      WCHAR     wszAppManRoot[MAX_PATH_CHARCOUNT];
      WCHAR     wszAppManSetup[MAX_PATH_CHARCOUNT];
      WCHAR     wszCategory[MAX_PATH_CHARCOUNT];

      //
      // Initialize the path substrings
      //

      (OS_VERSION_9x & Win32API.GetOSVersion()) ? GetResourceStringW(IDS_APPMAN9x, wszAppManRoot, MAX_PATH_CHARCOUNT): GetResourceStringW(IDS_APPMANNT, wszAppManRoot, MAX_PATH_CHARCOUNT);
      GetResourceStringW(IDS_APPMAN, wszAppManSetup, MAX_PATH_CHARCOUNT);

      switch(GET_APPLICATIONCATEGORY())
      {
        case APP_CATEGORY_MISC:
        case APP_CATEGORY_NONE
        : ZeroMemory(wszCategory, sizeof(wszCategory));
          break;
        case APP_CATEGORY_ENTERTAINMENT
        : GetResourceStringW(IDS_ENTERTAINMENT, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_PRODUCTIVITY
        : GetResourceStringW(IDS_PRODUCTIVITY, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_PUBLISHING
        : GetResourceStringW(IDS_PUBLISHING, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_SCIENTIFIC
        : GetResourceStringW(IDS_SCIENTIFIC, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_AUTHORING
        : GetResourceStringW(IDS_AUTHORING, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_MEDICAL
        : GetResourceStringW(IDS_MEDICAL, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_BUSINESS
        : GetResourceStringW(IDS_BUSINESS, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_FINANCIAL
        : GetResourceStringW(IDS_FINANCIAL, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_EDUCATIONAL
        : GetResourceStringW(IDS_EDUCATIONAL, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_REFERENCE
        : GetResourceStringW(IDS_REFERENCE, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_WEB
        : GetResourceStringW(IDS_WEB, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_DEVELOPMENTTOOL
        : GetResourceStringW(IDS_DEVTOOL, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_MULTIMEDIA
        : GetResourceStringW(IDS_MULTIMEDIA, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_VIRUSCLEANER
        : GetResourceStringW(IDS_VIRUSCLEANER, wszCategory, MAX_PATH_CHARCOUNT);
          break;
        case APP_CATEGORY_CONNECTIVITY
        : GetResourceStringW(IDS_CONNECTIVITY, wszCategory, MAX_PATH_CHARCOUNT);
          break;
      }

      //
      // Initialize the aging information
      //

      m_sApplicationData.sAgingInfo.dwInstallCost = 0;
      m_sApplicationData.sAgingInfo.dwReInstallCount = 0;
      m_sApplicationData.sAgingInfo.dwUsageCount = 0;
      GetLocalTime(&(m_sApplicationData.sAgingInfo.stInstallDate));
      VALIDATE_PROPERTY(IDX_PROPERTY_INSTALLDATE);
      GetLocalTime(&(m_sApplicationData.sAgingInfo.stLastUsedDate));
      VALIDATE_PROPERTY(IDX_PROPERTY_LASTUSEDDATE);

      //
      // Is this application associated with anything at all
      //

      if (0 != m_sApplicationData.sAssociation.dwAssociationType)
      {
        //
        // Go get the application data of the associated application
        //

        memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &m_sApplicationData.sAssociation.sParentGuid, sizeof(GUID));
        m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
        hResult = m_InformationManager.GetApplicationData(&sApplicationData);
        if (FAILED(hResult))
        {
          THROW(APPMAN_E_INVALIDASSOCIATION);
        }

        //
        // Make sure the parent is in a ready state
        //

        hResult = m_InformationManager.ReadyApplication(&sApplicationData);
        if (FAILED(hResult))
        {
          THROW(APPMAN_E_APPLICATIONREQUIRED);
        }

        //
        // Lock the parent applications
        //

        hResult = m_InformationManager.LockParentApplications(&sApplicationData, &m_sInstanceGuid);
        if (FAILED(hResult))
        {
          THROW(hResult);
        }
        else
        {
          fParentLocked = TRUE;
        }

        //
        // Go get the device index of the associated applications
        //

        memcpy((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &sApplicationData.sBaseInfo.sDeviceGuid, sizeof(GUID));
        hResult = m_InformationManager.GetDeviceInfo(&sDeviceRecord);
        if (FAILED(hResult))
        {
          THROW(E_UNEXPECTED);
        }

        dwDeviceIndex = sDeviceRecord.sDeviceInfo.dwDeviceIndex;

        //
        // Go get the space required to install the application on the device
        //

        hResult = m_InformationManager.FreeSpaceOnDevice(&sDeviceRecord.sDeviceGuid, m_sApplicationData.sBaseInfo.dwReservedKilobytes);
        if (FAILED(hResult))
        {
          THROW(APPMAN_E_NODISKSPACEAVAILABLE);
        }

        //
        // Add the application to the database and then assign it a device. Note that we do
        // not have to check for success code since these methods throw exceptions on error
        //

        m_InformationManager.AddApplicationData(&m_sApplicationData, &m_sInstanceGuid);
        m_InformationManager.AssignDeviceToApplication(dwDeviceIndex, &m_sApplicationData);

        //
        // Lock the application
        //

        LockApplication();

        //
        // Setup the root paths and setup root paths depending on association type
        //
 
        switch(m_sApplicationData.sAssociation.dwAssociationType)
        {
          case APP_ASSOCIATION_INHERITBOTHPATHS  // inherits both setup and application root paths
          : memcpy((LPVOID) m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], MAX_PATH_CHARCOUNT+1);
            memcpy((LPVOID) m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], MAX_PATH_CHARCOUNT+1);
            VALIDATE_PROPERTY(IDX_PROPERTY_ROOTPATH);
            VALIDATE_PROPERTY(IDX_PROPERTY_SETUPROOTPATH);
            break;
          case APP_ASSOCIATION_INHERITAPPROOTPATH // inherits application root path
          : memcpy((LPVOID) m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], MAX_PATH_CHARCOUNT+1);
            if (FAILED(CoCreateGuid(&sPathGuid)))
            {
              THROW(E_UNEXPECTED);
            }
            swprintf(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], L"%c:\\%s\\%s\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", dwDeviceIndex + 65, wszAppManRoot, wszAppManSetup, sPathGuid.Data1, sPathGuid.Data2, sPathGuid.Data3, sPathGuid.Data4[0], sPathGuid.Data4[1], sPathGuid.Data4[2], sPathGuid.Data4[3], sPathGuid.Data4[4], sPathGuid.Data4[5], sPathGuid.Data4[6], sPathGuid.Data4[7]);
            VALIDATE_PROPERTY(IDX_PROPERTY_ROOTPATH);
            VALIDATE_PROPERTY(IDX_PROPERTY_SETUPROOTPATH);
            break;
          case APP_ASSOCIATION_INHERITSETUPROOTPATH  // inherits setup root path and is rooted within application root path
          : swprintf(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], L"%s\\%s", sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_SIGNATURE]);
            VALIDATE_PROPERTY(IDX_PROPERTY_ROOTPATH);
            memcpy((LPVOID) m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], MAX_PATH_CHARCOUNT+1);
            VALIDATE_PROPERTY(IDX_PROPERTY_SETUPROOTPATH);
            break;
          default
          : THROW(APPMAN_E_INVALIDASSOCIATION);
            break;
        }

        //
        // Record the application guid within the association
        //

        memcpy((LPVOID) &m_sApplicationData.sAssociation.sChildGuid, (LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID));

        //
        // Set the application data into the registry
        //

        m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);

        //
        // Add the association
        //

        m_InformationManager.AddAssociation(&m_sApplicationData.sAssociation);
      }
      else
      {
        //
        // Are we in advanced mode
        //

        if (0 != dwAdvancedMode)
        {
          DWORD         dwBaseIndex;

          //
          // Figure out where the first legal character is in the root path
          //

          dwBaseIndex = 0;
          while ((dwBaseIndex < StrLenW(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]))&&(!((65 <= m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH][dwBaseIndex])&&(90 >= m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH][dwBaseIndex]))&&(!((97 <= m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH][dwBaseIndex])&&(122 >= m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH][dwBaseIndex])))))
          {
            dwBaseIndex++;
          }

          if (!(dwBaseIndex < StrLenW(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH])))
          {
            THROW(APPMAN_E_INVALIDROOTPATH);
          }

          //
          // Figure out which drive it is supposed to be in
          //

          dwIndex = 0;
          do
          {
            dwDeviceIndex = dwIndex;
            swprintf(wszRootPath, L"%c:\\", dwDeviceIndex + 65);
            dwIndex++;

          } while ((26 > dwIndex)&&(0 != _wcsnicmp(wszRootPath, &(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH][dwBaseIndex]), 3)));

          //
          // Did we fail to find a matching device string
          //

          if (26 <= dwIndex)
          {
            THROW(APPMAN_E_INVALIDROOTPATH);
          }

          //
          // Go get the device index of the associated applications
          //

          hResult = m_InformationManager.GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
          if (FAILED(hResult))
          {
            THROW(E_UNEXPECTED);
          }

          //
          // Go get the space required to install the application on the device
          //

          hResult = m_InformationManager.FreeSpaceOnDevice(&sDeviceRecord.sDeviceGuid, m_sApplicationData.sBaseInfo.dwReservedKilobytes);
          if (FAILED(hResult))
          {
            THROW(APPMAN_E_NODISKSPACEAVAILABLE);
          }

          //
          // Add the application to the database and then assign it a device. Note that we do
          // not have to check for success code since these methods throw exceptions on error
          //

          m_InformationManager.AddApplicationData(&m_sApplicationData, &m_sInstanceGuid);
          m_InformationManager.AssignDeviceToApplication(dwDeviceIndex, &m_sApplicationData);

          //
          // Lock the application
          //

          LockApplication();

          //
          // Setup the setup root paths depending on association type
          //
 
          if (FAILED(CoCreateGuid(&sPathGuid)))
          {
            THROW(E_UNEXPECTED);
          }
          swprintf(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], L"%c:\\%s\\%s\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", dwDeviceIndex + 65, wszAppManRoot, wszAppManSetup, sPathGuid.Data1, sPathGuid.Data2, sPathGuid.Data3, sPathGuid.Data4[0], sPathGuid.Data4[1], sPathGuid.Data4[2], sPathGuid.Data4[3], sPathGuid.Data4[4], sPathGuid.Data4[5], sPathGuid.Data4[6], sPathGuid.Data4[7]);
          VALIDATE_PROPERTY(IDX_PROPERTY_SETUPROOTPATH);

          //
          // Set the application data into the registry
          //

          m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);
        }
        else
        {
          //
          // Check to see if the application root path already exists on a device and if so, 
          // attempt to install the application on that device
          //

          fApplicationRootExists = FALSE;
          dwDeviceIndex = 0xffffffff;
          dwIndex = 2;
          do
          {
            //
            // Build the application root path
            //

            if (1 == StrLenW(wszCategory))
            {
              swprintf(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], L"%c:\\%s\\%s\\%s", dwIndex + 65, wszAppManRoot, m_sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], m_sApplicationData.wszStringProperty[APP_STRING_SIGNATURE]);
            }
            else
            {
              swprintf(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], L"%c:\\%s\\%s\\%s\\%s", dwIndex + 65, wszAppManRoot, wszCategory, m_sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], m_sApplicationData.wszStringProperty[APP_STRING_SIGNATURE]);
            }

            //
            // Check to see whether or not it exists
            //

            swprintf(wszRootPath, L"%c:\\", dwIndex + 65);
            if (DRIVE_FIXED == Win32API.GetDriveType(wszRootPath))
            {
              fApplicationRootExists = Win32API.FileExists(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]);
              if (TRUE == fApplicationRootExists)
              {
                dwDeviceIndex = dwIndex;
              }
            }

            dwIndex++;
          } 
          while ((FALSE == fApplicationRootExists)&&(26 > dwIndex));

          //
          // Go get the space
          //

          hResult = APPMAN_E_NODISKSPACEAVAILABLE;
          if (0xffffffff != dwDeviceIndex)
          {
            //
            // The root path of the application was found on device dwDeviceIndex. Is this
            // device excluded
            //

            m_InformationManager.GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
            if (0 == (m_sApplicationData.sBaseInfo.dwCategory & sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask))
            {
              hResult = m_InformationManager.FreeSpaceOnDevice(&sDeviceRecord.sDeviceGuid, m_sApplicationData.sBaseInfo.dwReservedKilobytes);
            }
          }

          if (FAILED(hResult))
          {
            //
            // We failed to get space on the device that contained the legacy application 
            // root path. Therefore, we fall back
            //

            hResult = m_InformationManager.GetSpace(m_sApplicationData.sBaseInfo.dwCategory, m_sApplicationData.sBaseInfo.dwReservedKilobytes, &dwDeviceIndex);
          }

          //
          // Go get the space
          //

          if (SUCCEEDED(hResult))
          {
            //
            // Add the application to the database and then assign it a device. Note that we do
            // not have to check for success code since these methods throw exceptions on error
            //

            m_InformationManager.AddApplicationData(&m_sApplicationData, &m_sInstanceGuid);
            m_InformationManager.AssignDeviceToApplication(dwDeviceIndex, &m_sApplicationData);
  
            //
            // Lock the application
            //

            LockApplication();

            //
            // Create the root paths
            //
    
            if (1 == StrLenW(wszCategory))
            {
              swprintf(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], L"%c:\\%s\\%s\\%s", dwDeviceIndex + 65, wszAppManRoot, m_sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], m_sApplicationData.wszStringProperty[APP_STRING_SIGNATURE]);
            }
            else
            {
              swprintf(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], L"%c:\\%s\\%s\\%s\\%s", dwDeviceIndex + 65, wszAppManRoot, wszCategory, m_sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], m_sApplicationData.wszStringProperty[APP_STRING_SIGNATURE]);
            }

            if (FAILED(CoCreateGuid(&sPathGuid)))
            {
              THROW(E_UNEXPECTED);
            }
            swprintf(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], L"%c:\\%s\\%s\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", dwDeviceIndex + 65, wszAppManRoot, wszAppManSetup, sPathGuid.Data1, sPathGuid.Data2, sPathGuid.Data3, sPathGuid.Data4[0], sPathGuid.Data4[1], sPathGuid.Data4[2], sPathGuid.Data4[3], sPathGuid.Data4[4], sPathGuid.Data4[5], sPathGuid.Data4[6], sPathGuid.Data4[7]);

            VALIDATE_PROPERTY(IDX_PROPERTY_ROOTPATH);
            VALIDATE_PROPERTY(IDX_PROPERTY_SETUPROOTPATH);

            //
            // Set the Appplication Info
            //

            m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);
          }
          else
          {
            THROW(APPMAN_E_NODISKSPACEAVAILABLE);
          }
        }
      }
    }
    else
    {
      //
      // Let's get the current information about this application
      //

      hResult = m_InformationManager.GetApplicationData(&m_sApplicationData);
      if (FAILED(hResult))
      {
        THROW(E_UNEXPECTED);
      }

      //
      // First we lock the application
      //

      LockApplication();

      //
      // Save the reserved space into dwReservedKilobytes temporarily
      //

      dwReservedKilobytes = m_sApplicationData.sBaseInfo.dwReservedKilobytes;

      //
      // Get the application information as registered within the database.
      //

      if (FAILED(m_InformationManager.GetApplicationData(&m_sApplicationData)))
      {
        SetInitializationLevel(INIT_LEVEL_BASIC);
        THROW(E_UNEXPECTED);
      }

      //
      // Restore the dwReservedKilobytes value
      //

      m_sApplicationData.sBaseInfo.dwReservedKilobytes = dwReservedKilobytes;
      VALIDATE_PROPERTY(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES);

      //
      // Make sure the app is in an APP_STATE_INSTALLING state
      //

      if (!CHECK_APPLICATIONSTATE(APP_STATE_INSTALLING))
      {
        SetInitializationLevel(INIT_LEVEL_BASIC);
        THROW(APPMAN_E_APPLICATIONALREADYEXISTS);
      }

      //
      // Go get the space
      //

      if (FAILED(m_InformationManager.FreeSpaceOnDevice(&(m_sApplicationData.sBaseInfo.sDeviceGuid), m_sApplicationData.sBaseInfo.dwReservedKilobytes)))
      {
        THROW(APPMAN_E_NODISKSPACEAVAILABLE);
      }
    }

    //
    // Create the root paths if required
    //

    if (FALSE == Win32API.FileExists(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]))
    {
      Win32API.CreateDirectory(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], TRUE);
    }

    if (FALSE == Win32API.FileExists(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH]))
    {
      Win32API.CreateDirectory(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], TRUE);
    }

    //
    // Record the original size of the root paths in order to compute the deltas during 
    // FinalizeInstall
    //

    ComputeOriginalApplicationSpaceInfo();

    //
    // Initialize some other properties
    //

    m_sApplicationData.sBaseInfo.dwRemovableKilobytes = 0;
    m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes = 0;
    VALIDATE_PROPERTY(IDX_PROPERTY_REMOVABLEKILOBYTES);
    VALIDATE_PROPERTY(IDX_PROPERTY_NONREMOVABLEKILOBYTES);

    //
    // Get the application record ready for installation
    //

    SET_APPLICATIONSTATE(APP_STATE_INSTALLING);
    SET_ACTIONSTATE(CURRENT_ACTION_INSTALLING);
    m_dwInitializationLevel = INIT_LEVEL_TOTAL;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Make sure that if we have locked parents, we unlock them here
    //

    if (fParentLocked)
    {
      APPLICATION_DATA  sApplicationData;

      //
      // Go get the application data of the associated application
      //

      memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &m_sApplicationData.sAssociation.sParentGuid, sizeof(GUID));
      m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      hResult = m_InformationManager.GetApplicationData(&sApplicationData);
      if (SUCCEEDED(hResult))
      {
        m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
      }
    }

    //
    // Make sure to record the hResult that caused the error
    //

    hResult = pException->GetResultCode();

    delete pException;
  }

  catch(...)
  {
    //
    // Make sure that if we have locked parents, we unlock them here
    //

    if (fParentLocked)
    {
      APPLICATION_DATA  sApplicationData;

      //
      // Go get the application data of the associated application
      //

      memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &m_sApplicationData.sAssociation.sParentGuid, sizeof(GUID));
      m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      hResult = m_InformationManager.GetApplicationData(&sApplicationData);
      if (SUCCEEDED(hResult))
      {
        m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
      }
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::FinalizeInstall(void)
{
  FUNCTION("CAppEntry::FinalizeInstall ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CWin32API         sWin32API;
    DWORD             dwIndex;//, dwActualApplicationSize;  // Get rid of /W4 warning.
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;

    //
    // Make sure we are currently installing
    //

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_INSTALLING))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }

    if (INIT_LEVEL_TOTAL != m_dwInitializationLevel)
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }

    //
    // Are the required properties set
    //

    if (((APP_CATEGORY_PATCH | APP_CATEGORY_DATA) & m_sApplicationData.sBaseInfo.dwCategory))
    {
      if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_EXECUTECMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
    }
    else
    {
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_EXECUTECMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }

      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE]))
      {
        THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
      }
    }

    //
    // Was a default setup command line given to us
    //

    if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, &m_sApplicationData))
    {
      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
   
      if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DOWNSIZECMDLINE, &m_sApplicationData))
      {
        if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_DOWNSIZECMDLINE]))
        {
          THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
        }
      }
  
      if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_REINSTALLCMDLINE, &m_sApplicationData))
      {
        if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_REINSTALLCMDLINE]))
        {
          THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
        }
      }
  
      if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_UNINSTALLCMDLINE, &m_sApplicationData))
      {
        if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_UNINSTALLCMDLINE]))
        {
          THROW(APPMAN_E_INVALIDUNINSTALLCMDLINE);
        }
      }
  
      if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SELFTESTCMDLINE, &m_sApplicationData))
      {
        if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_SELFTESTCMDLINE]))
        {
          THROW(APPMAN_E_INVALIDSELFTESTCMDLINE);
        }
      }
    }
    else
    {
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DOWNSIZECMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
   
      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_DOWNSIZECMDLINE]))
      {
        THROW(APPMAN_E_INVALIDDOWNSIZECMDLINE);
      }
  
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_REINSTALLCMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
  
      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_REINSTALLCMDLINE]))
      {
        THROW(APPMAN_E_INVALIDREINSTALLCMDLINE);
      }
  
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_UNINSTALLCMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
  
      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_UNINSTALLCMDLINE]))
      {
        THROW(APPMAN_E_INVALIDUNINSTALLCMDLINE);
      }
  
      if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SELFTESTCMDLINE, &m_sApplicationData))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
  
      if (S_OK != ValidateCommandLine(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], m_sApplicationData.wszStringProperty[APP_STRING_SELFTESTCMDLINE]))
      {
        THROW(APPMAN_E_INVALIDSELFTESTCMDLINE);
      }
    }

    //
    // Do we need to do a cache fixup
    //

    ComputeApplicationSpaceInfo(m_sApplicationData.sBaseInfo.dwReservedKilobytes);

    //
    // Delete the reserved space field
    //

    m_sApplicationData.sBaseInfo.dwReservedKilobytes = 0;
    INVALIDATE_PROPERTY(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES);

    //
    // Before we arbitrarily set the state of the application to APP_STATE_READY, check
    // to see if the setup technology hasn't already changed
    //

    if (APP_STATE_INSTALLING == GET_APPLICATIONSTATE())
    {
      RESET_APPLICATIONSTATE(APP_STATE_READY);
    }
    else
    {
      if (APP_STATE_DOWNSIZED != GET_APPLICATIONSTATE())
      {
        THROW(APPMAN_E_INVALIDPROPERTYVALUE);
      }
    }

    //
    // Save the application info
    //

    m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);

    //
    // Make sure this IApplicationEntry instance is no longer in an action state
    //
 
    SET_ACTIONSTATE(CURRENT_ACTION_NONE);

    //
    // Unlock the parent apps
    //

    ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
    dwIndex = 0;
    while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
    {
      if (0 == memcmp((LPVOID) &(sAssociationInfo.sChildGuid), (LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), sizeof(GUID)))
      {
        //
        // Get the associated application
        //

        ZeroMemory(&sApplicationData, sizeof(sApplicationData));
        memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
        m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
        hResult = m_InformationManager.GetApplicationData(&sApplicationData);
        if (SUCCEEDED(hResult))
        {
          //
          // Unlock the parent applications
          //

          m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
        }
      }
      dwIndex++;
    }

    //
    // Unlock this app
    //

    UnLockApplication();
  }
 
  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult; 
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::InitializeDownsize(void)
{
  FUNCTION("CAppEntry::InitializeDownsize ()");

  HRESULT   hResult = S_OK;
  HRESULT   hLockResult = S_FALSE;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }  

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    //
    // Lock the application
    //

    hResult = LockApplication();
    if (S_OK == hResult)
    {
      hLockResult = S_OK;

      hResult = m_InformationManager.GetApplicationData(&m_sApplicationData);
      if (SUCCEEDED(hResult))
      {
        //
        // Since GetApplicationInfo succeeded this means we have a totally initialized object
        //

        m_dwInitializationLevel = INIT_LEVEL_TOTAL;

        //
        // Record the original size of the root paths in order to compute the deltas during 
        // FinalizeInstall
        //
    
        ComputeOriginalApplicationSpaceInfo();

        //
        // Set the states
        //

        m_dwOriginalState = m_sApplicationData.sBaseInfo.dwState;
        RESET_APPLICATIONSTATE(APP_STATE_DOWNSIZING);
        SET_ACTIONSTATE(CURRENT_ACTION_DOWNSIZING);

        //
        // Enter the wait event if any
        //

        m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE, &m_sInstanceGuid);
      }
    }
    else
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);
    }

    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Record the error code
    //

    hResult = pException->GetResultCode();

    delete pException;
  }

  catch(...)
  {
    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);
    }

    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult; 
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::FinalizeDownsize(void)
{
  FUNCTION("CAppEntry::FinalizeDownsize ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_DOWNSIZING))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }

    //
    // Do we need to do a cache fixup
    //

    ComputeApplicationSpaceInfo(0);

    //
    // Set the application state to downsized
    //

    m_sApplicationData.sBaseInfo.dwState = APP_STATE_DOWNSIZED;

    //
    // Save the application info
    //

    m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);

    //
    // Unlock the application
    //

    UnLockApplication();

    //
    // Leave the wait event
    //

    m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);

    SET_ACTIONSTATE(CURRENT_ACTION_NONE);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::InitializeReInstall(void)
{
  FUNCTION("CAppEntry::InitializeReInstall ()");

  HRESULT   hResult = S_OK;
  HRESULT   hLockResult = S_FALSE;
  BOOL      fParentLocked = FALSE;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;
    DWORD             dwReservedKilobytes;
    CWin32API         sWin32API;

    if ((!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))&&(!CHECK_ACTIONSTATE(CURRENT_ACTION_SELFTESTING)))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }  

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }
    
    //
    // Save the dwReservedKilobytes property before calling GetApplicationData
    //

    dwReservedKilobytes = m_sApplicationData.sBaseInfo.dwReservedKilobytes;

    //
    // First we lock this application
    //

    hResult = LockApplication();
    if (S_OK == hResult)
    {
      hLockResult = S_OK;

      hResult = m_InformationManager.GetApplicationData(& m_sApplicationData);
      if (SUCCEEDED(hResult))
      {
        //
        // Since GetApplicationInfo succeeded this means we have a totally initialized object
        //

        m_dwInitializationLevel = INIT_LEVEL_TOTAL;

        //
        // Make sure to restore and validate the dwReservedKilobytes
        //

        m_sApplicationData.sBaseInfo.dwReservedKilobytes = dwReservedKilobytes;
        VALIDATE_PROPERTY(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES);

        //
        // Make sure that the parent associated apps are associated
        //

        ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
        dwIndex = 0;
        while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
        {
          if (0 == memcmp((LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sChildGuid), sizeof(GUID)))
          {
            //
            // Get the associated application
            //

            ZeroMemory(&sApplicationData, sizeof(sApplicationData));
            memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
            m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
            hResult = m_InformationManager.GetApplicationData(&sApplicationData);
            if (FAILED(hResult))
            {
              THROW(APPMAN_E_INVALIDASSOCIATION);
            }

            //
            // Make sure the associated app is in a ready state
            //

            hResult = m_InformationManager.ReadyApplication(&sApplicationData);
            if (FAILED(hResult))
            {
              THROW(APPMAN_E_APPLICATIONREQUIRED);
            }

            //
            // Lock the parent applications
            //

            hResult = m_InformationManager.LockParentApplications(&sApplicationData, &m_sInstanceGuid);
            if (FAILED(hResult))
            {
              THROW(hResult);
            }
            else
            {
              fParentLocked = TRUE;
            }
          }
          dwIndex++;
        }

        //
        // Go get the space
        //

        if (FAILED(m_InformationManager.FreeSpaceOnDevice(&(m_sApplicationData.sBaseInfo.sDeviceGuid), m_sApplicationData.sBaseInfo.dwReservedKilobytes)))
        {
          THROW(APPMAN_E_NODISKSPACEAVAILABLE);
        }

        //
        // Record the original size of the root paths in order to computer the deltas during 
        // FinalizeInstall
        //
    
        ComputeOriginalApplicationSpaceInfo();

        //
        // Set the state of the application
        //

        m_dwOriginalState = m_sApplicationData.sBaseInfo.dwState;
        m_sApplicationData.sBaseInfo.dwState = APP_STATE_REINSTALLING;
        m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);

        if (CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
        {
          SET_ACTIONSTATE(CURRENT_ACTION_REINSTALLING);
        }
        else
        {
          SET_ACTIONSTATE(CURRENT_ACTION_REINSTALLING | CURRENT_ACTION_SELFTESTING);
        }

        //
        // Enter the wait event if any
        //

        m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL, &m_sInstanceGuid);
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;

    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure that if we have locked parents, we unlock them here
    //

    if (fParentLocked)
    {
      ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
      dwIndex = 0;
      while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
      {
        if (0 == memcmp((LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sChildGuid), sizeof(GUID)))
        {
          //
          // Get the associated application
          //

          ZeroMemory(&sApplicationData, sizeof(sApplicationData));
          memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
          m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
          if (SUCCEEDED(m_InformationManager.GetApplicationData(&sApplicationData)))
          {
            //
            // Unlock the parent applications
            //

            m_InformationManager.LockParentApplications(&sApplicationData, &m_sInstanceGuid);
          }
        }
        dwIndex++;
      }
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
    }
    
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;

    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure that if we have locked parents, we unlock them here
    //

    if (fParentLocked)
    {
      ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
      dwIndex = 0;
      while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
      {
        if (0 == memcmp((LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sChildGuid), sizeof(GUID)))
        {
          //
          // Get the associated application
          //

          ZeroMemory(&sApplicationData, sizeof(sApplicationData));
          memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
          m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
          if (SUCCEEDED(m_InformationManager.GetApplicationData(&sApplicationData)))
          {
            //
            // Unlock the parent applications
            //

            m_InformationManager.LockParentApplications(&sApplicationData, &m_sInstanceGuid);
          }
        }
        dwIndex++;
      }
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::FinalizeReInstall(void)
{
  FUNCTION("CAppEntry::FinalizeReInstall ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CWin32API         sWin32API;
    DWORD             dwIndex;  //, dwActualApplicationSize;    Get rid of /W4 warning.
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;

    //
    // Make sure we are currently reinstalling
    //

    if ((!CHECK_ACTIONSTATE(CURRENT_ACTION_REINSTALLING))&&(!CHECK_ACTIONSTATE(CURRENT_ACTION_REINSTALLING | CURRENT_ACTION_SELFTESTING)))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }
      
    //
    // Do we need to do a cache fixup
    //

    ComputeApplicationSpaceInfo(m_sApplicationData.sBaseInfo.dwReservedKilobytes);

    //
    // Clear the dwReservedKilobytes data member
    //

    m_sApplicationData.sBaseInfo.dwReservedKilobytes = 0;
    INVALIDATE_PROPERTY(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES);

    //
    // Update the aging information
    //

    m_sApplicationData.sAgingInfo.dwReInstallCount++;
    GetLocalTime(&(m_sApplicationData.sAgingInfo.stLastUsedDate));
    VALIDATE_PROPERTY(IDX_PROPERTY_LASTUSEDDATE);

    //
    // Set the application state to ready
    //

    m_sApplicationData.sBaseInfo.dwState = APP_STATE_READY;

    //
    // Save the application info
    //

    m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);
    if (CHECK_ACTIONSTATE(CURRENT_ACTION_REINSTALLING))
    {
      RESET_ACTIONSTATE(CURRENT_ACTION_NONE);
    }
    else
    {
      RESET_ACTIONSTATE(CURRENT_ACTION_SELFTESTING);
    }

    //
    // Before we do anything, make sure to unlock the parent apps
    //

    ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
    dwIndex = 0;
    while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
    {
      if (0 == memcmp((LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sChildGuid), sizeof(GUID)))
      {
        //
        // Get the associated application
        //

        ZeroMemory(&sApplicationData, sizeof(sApplicationData));
        memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
        m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
        hResult = m_InformationManager.GetApplicationData(&sApplicationData);
        if (SUCCEEDED(hResult))
        {
          //
          // Unlock the parent applications
          //

          m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
        }
      }
      dwIndex++;
    }

    UnLockApplication();

    //
    // Leave the wait event
    //

    m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::InitializeUnInstall(void)
{
  FUNCTION("CAppEntry::InitializeUnInstall ()");

  HRESULT   hResult = S_OK;
  HRESULT   hLockResult = S_FALSE;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }  

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    hResult = m_InformationManager.GetApplicationData(&m_sApplicationData);
    if (SUCCEEDED(hResult))
    {
      //
      // Since GetApplicationInfo succeeded this means we have a totally initialized object
      //

      m_dwInitializationLevel = INIT_LEVEL_TOTAL;

      //
      // Check to make sure that this application is not required for another to run
      //

      dwIndex = 0;

      while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
      {
        if (0 == memcmp((LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID)))
        {
          THROW(APPMAN_E_APPLICATIONREQUIRED);
        }

        dwIndex++;
      }

      //
      // Lock the application
      //

      hResult = LockApplication();
      if (S_OK == hResult)
      {
        hLockResult = S_OK;
        m_dwOriginalState = m_sApplicationData.sBaseInfo.dwState;
        RESET_APPLICATIONSTATE(APP_STATE_UNINSTALLING);
        SET_ACTIONSTATE(CURRENT_ACTION_UNINSTALLING);

        //
        // Enter the wait event if any
        //

        m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL, &m_sInstanceGuid);
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL);
    }

    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL);
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::FinalizeUnInstall(void)
{
  FUNCTION("CAppEntry::FinalizeUnInstall ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_UNINSTALLING))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }

    //
    // Remove the application from the system
    //

    m_InformationManager.RemoveApplicationData(&m_sApplicationData);
    UnLockApplication();
    RESET_ACTIONSTATE(CURRENT_ACTION_NONE);

    //
    // Leave the wait event
    //

    m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::InitializeSelfTest(void)
{
  FUNCTION("CAppEntry::InitializeSelfTest ()");

  HRESULT   hResult = S_OK;
  HRESULT   hLockResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }  

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    hResult = LockApplication();
    if (S_OK == hResult)
    {
      hLockResult = S_OK;
      hResult = m_InformationManager.GetApplicationData(&m_sApplicationData);
      if (SUCCEEDED(hResult))
      {
        //
        // Since GetApplicationInfo succeeded this means we have a totally initialized object
        //

        m_dwInitializationLevel = INIT_LEVEL_TOTAL;

        m_dwOriginalState = m_sApplicationData.sBaseInfo.dwState;
        m_sApplicationData.sBaseInfo.dwState |= APP_STATE_SELFTESTING;
        m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);
        SET_ACTIONSTATE(CURRENT_ACTION_SELFTESTING);

        //
        // Enter the wait event if any
        //

        m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST, &m_sInstanceGuid);
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
    }

    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    //
    // Make sure to unlock the application if it was locked
    //

    if (S_OK == hLockResult)
    {
      UnLockApplication();
    }

    //
    // Make sure to kill the wait event
    //

    if (INIT_LEVEL_TOTAL == m_dwInitializationLevel)
    {
      m_InformationManager.EnterWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST, &m_sInstanceGuid);
      m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::FinalizeSelfTest(void)
{
  FUNCTION("CAppEntry::FinalizeSelfTest ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    APPLICATION_DATA  sApplicationData;

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_SELFTESTING))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }  

    //
    // Get the latest information from the database
    //

    ZeroMemory(&sApplicationData, sizeof(sApplicationData));
    memcpy((LPVOID) &sApplicationData, (LPVOID) &m_sApplicationData, sizeof(sApplicationData));
    m_InformationManager.SetApplicationData(&sApplicationData, &m_sInstanceGuid);

    //
    // Remove the selftest state flag from the application state
    //

    sApplicationData.sBaseInfo.dwState &= ~APP_STATE_SELFTESTING;
    memcpy((LPVOID) &m_sApplicationData, (LPVOID) &sApplicationData, sizeof(sApplicationData));

    //
    // Save the application info
    //

    m_InformationManager.SetApplicationData(&sApplicationData, &m_sInstanceGuid);
    UnLockApplication();
    RESET_ACTIONSTATE(CURRENT_ACTION_NONE);

    //
    // Leave the wait event
    //

    m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::Abort(void)
{
  FUNCTION("CAppEntry::Abort ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    APPLICATION_DATA  sApplicationData;
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex;

    if (CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONNOTINITIALIZED);
    }

    //
    // We need to force a leave event
    //

    switch(m_dwCurrentAction)
    {
      case CURRENT_ACTION_DOWNSIZING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_DOWNSIZE);
        break;

      case CURRENT_ACTION_REINSTALLING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_REINSTALL);
        break;

      case CURRENT_ACTION_UNINSTALLING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_UNINSTALL);
        break;

      case CURRENT_ACTION_SELFTESTING
      : m_InformationManager.LeaveWaitEvent(&m_sApplicationData, WAIT_FINALIZE_SELFTEST);
        break;
    }

    //
    // Before we do anything, make sure to unlock the parent apps
    //

    ZeroMemory(&sAssociationInfo, sizeof(sAssociationInfo));
    dwIndex = 0;
    while (S_OK == m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo))
    {
      if (0 == memcmp((LPVOID) &(sAssociationInfo.sChildGuid), (LPVOID) &(m_sApplicationData.sBaseInfo.sApplicationGuid), sizeof(GUID)))
      {
        //
        // Get the associated application
        //

        ZeroMemory(&sApplicationData, sizeof(sApplicationData));
        memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
        m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
        hResult = m_InformationManager.GetApplicationData(&sApplicationData);
        if (SUCCEEDED(hResult))
        {
          //
          // Unlock the parent applications
          //

          m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
        }
      }
      dwIndex++;
    }

    //
    // If the application was doing an initial install, abort will cause the application
    // entry to be removed from the system
    //

    if (CHECK_ACTIONSTATE(CURRENT_ACTION_INSTALLING))
    {
      UnLockApplication();
      m_InformationManager.RemoveApplicationData(&m_sApplicationData);
    }
    else
    {
      //
      // Simply restore the application info with the record currently saved in the
      // registry
      //

      m_InformationManager.GetApplicationData(&m_sApplicationData);
      m_sApplicationData.sBaseInfo.dwState = m_dwOriginalState;
      m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);
      UnLockApplication();
    }

    SET_ACTIONSTATE(CURRENT_ACTION_NONE);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::Run(const DWORD dwRunFlags, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::Run ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    WCHAR                 wszParameters[MAX_PATH_CHARCOUNT];
    WCHAR                 wszCommandLine[MAX_PATH_CHARCOUNT];
    CWin32API             sWin32API;
    BOOL                  fRunning = FALSE;
    PROCESS_INFORMATION   sProcessInformation;

    //
    // We can only run if this object is not doing anything
    //

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      if ((S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_COMPANYNAME, &m_sApplicationData))||(S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SIGNATURE, &m_sApplicationData)))
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
    }

    //
    // Make sure the application actually exists
    //

    if (INIT_LEVEL_NONE == m_dwInitializationLevel)
    {
      hResult = m_InformationManager.GetApplicationData(&m_sApplicationData);
      if (FAILED(hResult))
      {
        THROW(hResult);
      }
      m_dwInitializationLevel = INIT_LEVEL_BASIC;
    }

    //
    // This object cannot be run if it is APP_CATEGORY_PATCH or APP_CATEGORY_DAT
    //

    if ((APP_CATEGORY_PATCH | APP_CATEGORY_DATA) & m_sApplicationData.sBaseInfo.dwCategory)
    {
      THROW(APPMAN_E_APPNOTEXECUTABLE);
    }

    //
    // Are the required properties set
    //

    //
    // Ready the application
    //

    m_InformationManager.ReadyApplication(&m_sApplicationData);

    //
    // Build the command line parameters
    //

    ZeroMemory(wszParameters, sizeof(wszParameters));
    if ((APP_PROPERTY_STR_ANSI == dwStringMask)||(APP_PROPERTY_STR_UNICODE == dwStringMask))
    {
      //
      // Check to make sure the parameters are valid
      //

      if (NULL != lpData)
      {
        if (IsBadReadPtr(lpData, dwDataLen))
        {
          THROW(APPMAN_E_INVALIDPARAMETERS);
        }

        if (0 < dwDataLen)
        {
          //
          // Make sure the command line parameters are converted to unicode
          //

          if (APP_PROPERTY_STR_ANSI == dwStringMask)
          {
            if (MAX_PATH_CHARCOUNT < StrLenA((LPCSTR) lpData))
            {
              THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
            }
            else
            {
              sWin32API.MultiByteToWideChar((LPCSTR) lpData, dwDataLen, wszParameters, MAX_PATH_CHARCOUNT);
            }
          }
          else
          {
            if (MAX_PATH_CHARCOUNT < StrLenW((LPCWSTR) lpData))
            {
              THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
            }
            else
            {
              memcpy(wszParameters, lpData, StrLenW((LPCWSTR) lpData) * 2);
            }
          }
        }
      }
    }
    else
    {
      if (0 != dwStringMask)
      {
        THROW(APPMAN_E_INVALIDPARAMETERS);
      }
    }

    //
    // Construct the command line
    //

    if (1 < StrLenW(wszParameters))
    {
      //
      // Make sure the total lenght does not exceed MAX_PATH_CHARCOUNT
      //

      if (MAX_PATH_CHARCOUNT < (StrLenW(m_sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE])+StrLenW(wszParameters)))
      {
        THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
      }

      wcscpy(wszCommandLine, m_sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE]);
      wcscat(wszCommandLine, L" /AppManStarted ");
      wcscat(wszCommandLine, wszParameters);
    }
    else
    {
      wcscpy(wszCommandLine, m_sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE]);
      wcscat(wszCommandLine, L" /AppManStarted");
    }

    //
    // Run it
    //

    if (sWin32API.CreateProcess(wszCommandLine, &sProcessInformation))
    {
      fRunning = TRUE;
    }
    else
    {
      if (SUCCEEDED(m_InformationManager.SelfTestApplication(&m_sApplicationData)))
      {
        if (sWin32API.CreateProcess(wszCommandLine, &sProcessInformation))
        {
          fRunning = TRUE;
        }
        else
        {
          THROW(E_FAIL);
        }
      }
      else
      {
        THROW(E_FAIL);
      }
    }

    if (fRunning)
    {
      m_sApplicationData.sAgingInfo.dwUsageCount++;
      GetLocalTime(&(m_sApplicationData.sAgingInfo.stLastUsedDate));
      m_InformationManager.SetApplicationData(&m_sApplicationData, &m_sInstanceGuid);

      if (APP_RUN_BLOCK & dwRunFlags)
      {
        WaitForSingleObject(sProcessInformation.hProcess, INFINITE);
      }

      CloseHandle(sProcessInformation.hThread);
      CloseHandle(sProcessInformation.hProcess);

      hResult = S_OK;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::AddAssociation(const DWORD dwAssociationType, const IApplicationEntry * lpApplicationEntry)
{
  FUNCTION("CAppEntry::AddAssociation ()");

  HRESULT             hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    ASSOCIATION_INFO  sAssociationRecord;
    APPLICATION_DATA  sApplicationData;

    //
    // Make sure we are in a proper state
    //

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(APPMAN_E_CANNOTASSOCIATE);
    }

    //
    // The initialization level should be INIT_LEVEL_NONE
    //

    if (INIT_LEVEL_NONE != m_dwInitializationLevel)
    {
      THROW(APPMAN_E_CANNOTASSOCIATE);
    }

    //
    // Make sure an association does not already exist
    //

    if (0 != m_sApplicationData.sAssociation.dwAssociationType)
    {
      THROW(APPMAN_E_CANNOTASSOCIATE);
    }

    //
    // Make sure the lpApplicationEntry parameter is valid
    //

    if (NULL == lpApplicationEntry)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadReadPtr((LPVOID) lpApplicationEntry, sizeof(CApplicationEntry)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that dwAssociationType is valid
    //

    if ((APP_ASSOCIATION_INHERITBOTHPATHS != dwAssociationType)&&(APP_ASSOCIATION_INHERITAPPROOTPATH != dwAssociationType)&&(APP_ASSOCIATION_INHERITSETUPROOTPATH != dwAssociationType))
    {
      THROW(APPMAN_E_INVALIDASSOCIATION);
    }

    //
    // Make sure the root path is not already set
    //

    if (S_OK == m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, &m_sApplicationData))
    {
      THROW(APPMAN_E_CANNOTASSOCIATE);
    }

    //
    // Initialize the sAssociationRecord structure
    //

    sAssociationRecord.dwSize = sizeof(ASSOCIATION_INFO);
    sAssociationRecord.dwStructId = ASSOCIATION_STRUCT;
    sAssociationRecord.dwAssociationType = dwAssociationType;

    //
    // Does the application we want to association with even exist
    //

    memcpy((LPVOID) &sApplicationData, (LPVOID) ((CApplicationEntry *)lpApplicationEntry)->GetApplicationDataPtr(), sizeof(APPLICATION_DATA));
    hResult = m_InformationManager.GetApplicationData(&sApplicationData);
    if (FAILED(hResult))
    {
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }

    //
    // Fill in the rest of the information
    //

    memcpy((LPVOID)&sAssociationRecord.sParentGuid, (LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID));

    //
    // Is there an association already ?
    //

    if (0 != m_sApplicationData.sAssociation.dwAssociationType)
    {
      THROW(APPMAN_E_ALREADYASSOCIATED);
    }

    //
    // Ok make the association happen
    //

    memcpy((LPVOID) &m_sApplicationData.sAssociation, (LPVOID) &sAssociationRecord, sizeof(ASSOCIATION_INFO));

  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::RemoveAssociation(const DWORD dwAssociationType, const IApplicationEntry * lpApplicationEntry)
{
  FUNCTION("CAppEntry::RemoveAssociation ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Make sure we are in a proper state
    //

    if (!CHECK_ACTIONSTATE(CURRENT_ACTION_NONE))
    {
      THROW(E_FAIL);
    }

    //
    // The initialization level should be INIT_LEVEL_NONE
    //

    if (INIT_LEVEL_NONE != m_dwInitializationLevel)
    {
      THROW(E_FAIL);
    }

    //
    // Make sure the lpApplicationEntry parameter is proper
    //

    if (NULL == lpApplicationEntry)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadReadPtr((LPVOID) lpApplicationEntry, sizeof(CApplicationEntry)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that dwAssociationType is valid
    //

    if ((APP_ASSOCIATION_INHERITBOTHPATHS != dwAssociationType)&&(APP_ASSOCIATION_INHERITAPPROOTPATH != dwAssociationType)&&(APP_ASSOCIATION_INHERITSETUPROOTPATH != dwAssociationType))
    {
      THROW(APPMAN_E_INVALIDASSOCIATION);
    }

    //
    // Make sure an association does exist
    //

    if (0 == m_sApplicationData.sAssociation.dwAssociationType)
    {
      THROW(E_FAIL);
    }

    ZeroMemory(&m_sApplicationData.sAssociation, sizeof(ASSOCIATION_INFO));
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::EnumAssociations(const DWORD dwTargetIndex, LPDWORD lpdwAssociationType, IApplicationEntry * lpApplicationEntry)
{
  FUNCTION("CAppEntry::EnumAssociations ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    ASSOCIATION_INFO  sAssociationInfo;
    DWORD             dwIndex, dwActualIndex;

    //
    // Make sure the lpApplicationEntry pointer is good
    //

    if (NULL == lpApplicationEntry)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadReadPtr((LPVOID) lpApplicationEntry, sizeof(CApplicationEntry)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that the lpdwAssociationType is valid
    //

    if (NULL == lpdwAssociationType)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadWritePtr((LPVOID) lpdwAssociationType, sizeof(DWORD)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Get the nth association record. Ignore associations that belong to other applications
    //
    
    dwActualIndex = dwTargetIndex;
    dwIndex = 0;
    do
    {
      hResult = m_InformationManager.EnumAssociations(dwIndex, &sAssociationInfo);
      if (S_OK == hResult)
      {
        if (memcmp((LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sChildGuid, sizeof(GUID)))
        {
          if (memcmp((LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID)))
          {
            dwActualIndex++;
          }
        }
      }
      dwIndex++;
    } 
    while ((dwIndex <= dwActualIndex)&&(S_OK == hResult));

    //
    // Did we find an association
    //

    if (S_OK == hResult)
    {
      if (0 == memcmp((LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sChildGuid, sizeof(GUID)))
      {
        //
        // The association is a child associations
        //

        *lpdwAssociationType = sAssociationInfo.dwAssociationType | APP_ASSOCIATION_CHILD;
        hResult = lpApplicationEntry->Clear();
        if (SUCCEEDED(hResult))
        {
          hResult = lpApplicationEntry->SetProperty(APP_PROPERTY_GUID, (LPCVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
          if (SUCCEEDED(hResult))
          {
            hResult = m_InformationManager.GetApplicationData(((CApplicationEntry *) lpApplicationEntry)->GetApplicationDataPtr());
            if (SUCCEEDED(hResult))
            {
              ((CApplicationEntry *) lpApplicationEntry)->SetInitializationLevel(INIT_LEVEL_BASIC);
            }
          }
        }
      }
      else
      {
        if (0 == memcmp((LPVOID) &m_sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID)))
        {
          //
          // The association is a parent association
          //

          *lpdwAssociationType = sAssociationInfo.dwAssociationType | APP_ASSOCIATION_PARENT;
          hResult = lpApplicationEntry->Clear();
          if (SUCCEEDED(hResult))
          {
            hResult = lpApplicationEntry->SetProperty(APP_PROPERTY_GUID, (LPCVOID) &sAssociationInfo.sChildGuid, sizeof(GUID));
            if (SUCCEEDED(hResult))
            {
              hResult = m_InformationManager.GetApplicationData(((CApplicationEntry *) lpApplicationEntry)->GetApplicationDataPtr());
              if (SUCCEEDED(hResult))
              {
                ((CApplicationEntry *) lpApplicationEntry)->SetInitializationLevel(INIT_LEVEL_BASIC);
              }
            }
          }
        }
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::GetTemporarySpace(const DWORD dwKilobytes, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::GetTemporarySpace ()");

  HRESULT           hResult = E_FAIL;
  BOOL              fParentsLocked = FALSE;
  BOOL              fLocked = FALSE;
  APPLICATION_DATA  sApplicationData;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    TEMP_SPACE_RECORD sTempSpaceRecord;
    DWORD             dwCharCount;

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    //
    // Is the object a valid application object
    //

    memcpy((LPVOID) &sApplicationData, (LPVOID) &m_sApplicationData, sizeof(APPLICATION_DATA));
    hResult = m_InformationManager.GetApplicationData(&sApplicationData);
    if (FAILED(hResult))
    {
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }

    //
    // Make sure the string mask is good
    //

    if ((APP_PROPERTY_STR_ANSI != dwStringMask)&&(APP_PROPERTY_STR_UNICODE != dwStringMask))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure dwDataLen is greater than 0
    //

    if (0 == dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that the lpData parameter is valid
    //

    if (NULL == lpData)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadWritePtr(lpData, dwDataLen))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure the dwKilobytes is not 0
    //

    if (0 == dwKilobytes)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Lock this application and all of it's parents
    //

    if (SUCCEEDED(m_InformationManager.LockParentApplications(&sApplicationData, &m_sInstanceGuid)))
    {
      //
      // Make sure to record that fact that the applications got locked (in case of a THROW)
      //

      fParentsLocked = TRUE;

      if (SUCCEEDED(m_InformationManager.LockApplicationData(&sApplicationData, &m_sInstanceGuid)))
      {

        //
        // Make sure to record the fact that this application is locked (in case of a THROW)
        //

        fLocked = TRUE;

        //
        // Get the space
        //
    
        sTempSpaceRecord.dwSize = sizeof(TEMP_SPACE_RECORD);
        sTempSpaceRecord.dwStructId = TEMP_SPACE_STRUCT;
        sTempSpaceRecord.dwKilobytes = dwKilobytes;
        memcpy((LPVOID) &sTempSpaceRecord.sApplicationGuid, (LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID));
        hResult = m_InformationManager.AddTempSpace(&sTempSpaceRecord);
        if (FAILED(hResult))
        {
          THROW(hResult);
        }

        dwCharCount = StrLenW(sTempSpaceRecord.wszDirectory);
        if (APP_PROPERTY_STR_ANSI == dwStringMask)
        {
          if (dwCharCount > dwDataLen)
          {
            m_InformationManager.RemoveTempSpace(&sTempSpaceRecord);
            THROW(APPMAN_E_OVERFLOW);
          }
          CWin32API::WideCharToMultiByte((LPCWSTR) sTempSpaceRecord.wszDirectory, MAX_PATH_CHARCOUNT, (LPSTR) lpData, dwDataLen);
        }
        else
        {
          if (dwDataLen < (dwCharCount*2))
          {
            m_InformationManager.RemoveTempSpace(&sTempSpaceRecord);
            THROW(APPMAN_E_OVERFLOW);
          }
          memcpy((LPVOID) lpData, (LPVOID) sTempSpaceRecord.wszDirectory, dwCharCount*2);
        }

        //
        // Unlock this application
        //

        m_InformationManager.UnlockApplicationData(&sApplicationData, &m_sInstanceGuid);
      }

      //
      // Unlock the parent applications
      //

      m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Unlock the applications if required
    //

    if (fParentsLocked)
    {
      m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
    }

    //
    // Is this application locked
    //

    if (fLocked)
    {
      m_InformationManager.UnlockApplicationData(&sApplicationData, &m_sInstanceGuid);
    }

    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    //
    // Unlock the applications if required
    //

    if (fParentsLocked)
    {
      m_InformationManager.UnlockParentApplications(&sApplicationData, &m_sInstanceGuid);
    }

    //
    // Is this application locked
    //

    if (fLocked)
    {
      m_InformationManager.UnlockApplicationData(&sApplicationData, &m_sInstanceGuid);
    }

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::RemoveTemporarySpace(const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::RemoveTemporarySpace ()");

  HRESULT           hResult = S_OK;
  APPLICATION_DATA  sApplicationData;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    TEMP_SPACE_RECORD sTempSpaceRecord;
    DWORD             dwCharCount;

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    //
    // Is the object a valid application object
    //

    memcpy((LPVOID) &sApplicationData, (LPVOID) &m_sApplicationData, sizeof(APPLICATION_DATA));
    hResult = m_InformationManager.GetApplicationData(&sApplicationData);
    if (FAILED(hResult))
    {
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }

    //
    // Make sure the string mask is good
    //

    if ((APP_PROPERTY_STR_ANSI != dwStringMask)&&(APP_PROPERTY_STR_UNICODE != dwStringMask))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure dwDataLen is greater than 0
    //

    if (0 == dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that the lpData parameter is valid
    //

    if (NULL == lpData)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadReadPtr(lpData, dwDataLen))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Initialize the sTempSpaceRecord structure
    //

    sTempSpaceRecord.dwSize = sizeof(TEMP_SPACE_RECORD);
    sTempSpaceRecord.dwStructId = TEMP_SPACE_STRUCT;
    memcpy((LPVOID) &sTempSpaceRecord.sApplicationGuid, (LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID));
    if (APP_PROPERTY_STR_ANSI == dwStringMask)
    {
      dwCharCount = StrLenA((LPSTR) lpData);
      if (dwCharCount > MAX_PATH_CHARCOUNT)
      {
        THROW(APPMAN_E_OVERFLOW);
      }
      CWin32API::MultiByteToWideChar((LPCSTR) lpData, dwDataLen, sTempSpaceRecord.wszDirectory, MAX_PATH_CHARCOUNT);
    }
    else
    {
      dwCharCount = StrLenW((LPWSTR) lpData);
      if (dwCharCount > MAX_PATH_CHARCOUNT)
      {
        THROW(APPMAN_E_OVERFLOW);
      }
      memcpy((LPVOID) sTempSpaceRecord.wszDirectory, (LPVOID) lpData, dwCharCount*2);
    }

    //
    // Delete the temporary space
    //

    hResult = m_InformationManager.RemoveTempSpace(&sTempSpaceRecord);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::EnumTemporarySpaces(const DWORD dwTargetIndex, LPDWORD lpdwSpace, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CAppEntry::EnumTemporarySpaces ()");

  HRESULT           hResult = S_OK;
  APPLICATION_DATA  sApplicationData;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    TEMP_SPACE_RECORD sTempSpaceRecord;
    DWORD             dwIndex, dwActualIndex;
    DWORD             dwCharCount;

    //
    // Are the required properties set
    //

    if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, &m_sApplicationData))
    {
      THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
    }

    //
    // Is the object a valid application object
    //

    memcpy((LPVOID) &sApplicationData, (LPVOID) &m_sApplicationData, sizeof(APPLICATION_DATA));
    hResult = m_InformationManager.GetApplicationData(&sApplicationData);
    if (FAILED(hResult))
    {
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }

    //
    // Make sure the string mask is good
    //

    if ((APP_PROPERTY_STR_ANSI != dwStringMask)&&(APP_PROPERTY_STR_UNICODE != dwStringMask))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure dwDataLen is greater than 0
    //

    if (0 == dwDataLen)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Make sure that the lpData parameter is valid
    //

    if (NULL == lpData)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadWritePtr(lpData, dwDataLen))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure lpdwSpace is valid
    //

    if (NULL == lpdwSpace)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    if (IsBadWritePtr(lpdwSpace, sizeof(DWORD)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Get the nth temp space. Ignore temp spaces that are not owned by this application
    //
    
    dwActualIndex = dwTargetIndex;
    dwIndex = 0;
    do
    {
      hResult = m_InformationManager.EnumTempSpace(dwIndex, &sTempSpaceRecord);
      if (S_OK == hResult)
      {
        if (memcmp((LPVOID) &sTempSpaceRecord.sApplicationGuid, (LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, sizeof(GUID)))
        {
          dwActualIndex++;
        }
      }
      dwIndex++;
    } 
    while ((dwIndex <= dwActualIndex)&&(S_OK == hResult));

    //
    // Did we find a target temp space
    //

    if (S_OK == hResult)
    {
      //
      // Record the size
      //

      *lpdwSpace = sTempSpaceRecord.dwKilobytes;

      //
      // Record the string
      //

      dwCharCount = StrLenW(sTempSpaceRecord.wszDirectory);
      if (APP_PROPERTY_STR_ANSI == dwStringMask)
      {
        if (dwCharCount > dwDataLen)
        {
          THROW(APPMAN_E_OVERFLOW);
        }
        CWin32API::WideCharToMultiByte((LPCWSTR) sTempSpaceRecord.wszDirectory, MAX_PATH_CHARCOUNT, (LPSTR) lpData, dwDataLen);
      }
      else
      {
        if (dwDataLen < (dwCharCount*2))
        {
          THROW(APPMAN_E_OVERFLOW);
        }
        memcpy((LPVOID) lpData, (LPVOID) sTempSpaceRecord.wszDirectory, dwCharCount*2);
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ComputeOriginalApplicationSpaceInfo(void)
{
  FUNCTION("CAppEntry::ComputeOriginalApplicationSpaceInfo ()");
  
  CWin32API   Win32API;

  //
  // Make sure the root paths are set
  //

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // How much space is currently take by the application
  //

  m_dwOriginalSetupRootPathSizeKilobytes = Win32API.GetDirectorySize(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH]);
  m_dwOriginalApplicationRootPathSizeKilobytes = Win32API.GetDirectorySize(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]);

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationEntry::ComputeApplicationSpaceInfo(const DWORD dwInstalledKilobytesExpected)
{
  FUNCTION("CAppEntry::ComputeApplicationSpaceInfo ()");

  HRESULT     hResult = S_OK;
  DWORD       dwSetupInstalledKilobytes, dwSetupUnInstalledKilobytes;
  DWORD       dwApplicationInstalledKilobytes, dwApplicationUnInstalledKilobytes;
  DWORD       dwInstalledKilobytes, dwUnInstalledKilobytes;
  DWORD       dwSetupRootPathSizeKilobytes, dwApplicationRootPathSizeKilobytes;
  CWin32API   Win32API;

  //
  // Make sure the root paths and estimated install kilobytes are set
  //

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_REMOVABLEKILOBYTES, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  if (S_OK != m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_NONREMOVABLEKILOBYTES, &m_sApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // What is the actual amount of kilobytes taken up by the application paths
  //

  dwSetupRootPathSizeKilobytes = Win32API.GetDirectorySize(m_sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH]);
  dwApplicationRootPathSizeKilobytes = Win32API.GetDirectorySize(m_sApplicationData.wszStringProperty[APP_STRING_APPROOTPATH]);

  //
  // Did we add or remove kilobytes from the setup root path
  //

  if (dwSetupRootPathSizeKilobytes > m_dwOriginalSetupRootPathSizeKilobytes)
  {
    dwSetupInstalledKilobytes = dwSetupRootPathSizeKilobytes - m_dwOriginalSetupRootPathSizeKilobytes;
    dwSetupUnInstalledKilobytes = 0;
  }
  else
  {
    dwSetupInstalledKilobytes = 0;
    dwSetupUnInstalledKilobytes = m_dwOriginalSetupRootPathSizeKilobytes - dwSetupRootPathSizeKilobytes;
  }

  //
  // Did we add or remove kilobytes from the application root path
  //

  if (dwApplicationRootPathSizeKilobytes > m_dwOriginalApplicationRootPathSizeKilobytes)
  {
    dwApplicationInstalledKilobytes = dwApplicationRootPathSizeKilobytes - m_dwOriginalApplicationRootPathSizeKilobytes;
    dwApplicationUnInstalledKilobytes = 0;
  }
  else
  {
    dwApplicationInstalledKilobytes = 0;
    dwApplicationUnInstalledKilobytes = m_dwOriginalApplicationRootPathSizeKilobytes - dwApplicationRootPathSizeKilobytes;
  }
  
  //
  // The total is
  //

  dwInstalledKilobytes = dwSetupInstalledKilobytes + dwApplicationInstalledKilobytes;
  dwUnInstalledKilobytes = dwSetupUnInstalledKilobytes + dwApplicationUnInstalledKilobytes;

  //
  // Did we use up more kilobytes than expected
  //

  if (dwInstalledKilobytes > dwUnInstalledKilobytes)
  {
    if ((dwInstalledKilobytes - dwUnInstalledKilobytes) > dwInstalledKilobytesExpected)
    {
      DWORD dwExtraKilobytes;

      //
      // How many extra kilobytes were used up by the installation
      //

      dwExtraKilobytes = (dwInstalledKilobytes - dwUnInstalledKilobytes) - dwInstalledKilobytesExpected;

      //
      // Go get the space required to install the application on the device
      //

      hResult = m_InformationManager.FixCacheOverrun(&m_sApplicationData.sBaseInfo.sDeviceGuid, dwExtraKilobytes);
      if (FAILED(hResult))
      {
        THROW(APPMAN_E_CACHEOVERRUN);
      }
    }
  }

  //
  // Update the removable and non-removable space and validate the properties
  //

  m_sApplicationData.sBaseInfo.dwRemovableKilobytes += dwApplicationInstalledKilobytes;
  if (m_sApplicationData.sBaseInfo.dwRemovableKilobytes > dwApplicationUnInstalledKilobytes)
  {
    m_sApplicationData.sBaseInfo.dwRemovableKilobytes -= dwApplicationUnInstalledKilobytes;
  }
  else
  {
    m_sApplicationData.sBaseInfo.dwRemovableKilobytes = 0;
  }

  m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes += dwSetupInstalledKilobytes;
  if (m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes > dwSetupUnInstalledKilobytes)
  {
    m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes -= dwSetupUnInstalledKilobytes;
  }
  else
  {
    m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes = 0;
  }

  //
  // Make sure dwRemovableKilobytes and dwNonRemovableKilobytes are not recursively adding
  //

  if (m_sApplicationData.sBaseInfo.dwRemovableKilobytes > dwApplicationRootPathSizeKilobytes)
  {
    m_sApplicationData.sBaseInfo.dwRemovableKilobytes = dwApplicationRootPathSizeKilobytes;
  }

  if (m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes > dwSetupRootPathSizeKilobytes)
  {
    m_sApplicationData.sBaseInfo.dwNonRemovableKilobytes = dwSetupRootPathSizeKilobytes;
  }

  VALIDATE_PROPERTY(IDX_PROPERTY_REMOVABLEKILOBYTES);
  VALIDATE_PROPERTY(IDX_PROPERTY_NONREMOVABLEKILOBYTES);

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

LPAPPLICATION_DATA  CApplicationEntry::GetApplicationDataPtr(void)
{
  FUNCTION("CAppEntry::GetApplicationDataPtr()");

  return &m_sApplicationData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\applicationmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ApplicationManager.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of IApplicationManager
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "Resource.h"
#include "AppMan.h"
#include "ExceptionHandler.h"
#include "ApplicationManager.h"
#include "AppManDebug.h"
#include "Global.h"
#include "RegistryKey.h"
#include "Win32API.h"

//To flag as DBG_APPMAN
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMAN

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManager::CApplicationManager(void)
{
  FUNCTION("CApplicationManager::CApplicationManager (void)");
  assert(TRUE);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManager::CApplicationManager(CApplicationManagerRoot * pParent)
{
  FUNCTION("CApplicationManager::CApplicationManager (CApplicationManagerRoot * pParent)");

  HRESULT     hResult = S_OK;

  assert(NULL != pParent);

  m_pParentObject = pParent;

  if ((hResult = m_InformationManager.Initialize()) == E_ACCESSDENIED)
  {  
    pParent->m_bInsufficientAccessToRun = TRUE;
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManager::~CApplicationManager(void)
{
  FUNCTION("CApplicationManager::~CApplicationManager (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::QueryInterface(REFIID RefIID, LPVOID * ppVoidObject)
{
  FUNCTION("CApplicationManager::QueryInterface ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (NULL == &RefIID)
    {
      THROW(E_UNEXPECTED);
    }

    *ppVoidObject = NULL;

	  if ((RefIID == IID_IUnknown)||(RefIID == IID_ApplicationManager))
	  {
		  *ppVoidObject = (LPVOID) this;
	  }

	  if (*ppVoidObject)
	  {
		  ((LPUNKNOWN)*ppVoidObject)->AddRef();
	  }
    else
    {
      hResult = E_NOINTERFACE;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    if ((NULL == &RefIID)||(NULL == ppVoidObject)||(IsBadWritePtr(ppVoidObject, sizeof(LPVOID))))
    {
      hResult = E_INVALIDARG;
    }
    else
    {
      hResult = E_UNEXPECTED;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManager::AddRef(void)
{
  FUNCTION("CApplicationManager::AddRef ()");

  if (NULL != m_pParentObject)
  {
    return m_pParentObject->AddRef();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// IUnknown interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManager::Release(void)
{
  FUNCTION("CApplicationManager::Release ()");

  if (NULL != m_pParentObject)
  {
    return m_pParentObject->Release();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::GetAdvancedMode(LPDWORD lpdwAdvancedModeMask)
{
  FUNCTION("CApplicationManager::GetAdvancedMode ()");

  HRESULT hResult = APPMAN_E_INVALIDDATA;

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpdwAdvancedModeMask)||(IsBadWritePtr(lpdwAdvancedModeMask, sizeof(DWORD))))
    {
      THROW(APPMAN_E_INVALIDDATA);
    }

    //
    // Get the advanced mode
    //

    hResult = m_InformationManager.GetAdvancedMode(lpdwAdvancedModeMask);
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::GetAvailableSpace(const DWORD dwApplicationCategory, LPDWORD lpdwMaximumSpace, LPDWORD lpdwOptimalSpace)
{
  FUNCTION("CApplicationManager::GetAvailableSpace ()");

  HRESULT hResult = S_OK;

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpdwMaximumSpace)||(NULL == lpdwOptimalSpace)||(IsBadWritePtr(lpdwMaximumSpace, sizeof(DWORD)))||(IsBadWritePtr(lpdwOptimalSpace, sizeof(DWORD))))
    {
      THROW(E_INVALIDARG);
    }

    hResult = m_InformationManager.GetMaximumAvailableSpace(dwApplicationCategory, lpdwMaximumSpace);
    if (SUCCEEDED(hResult))
    {
      hResult = m_InformationManager.GetOptimalAvailableSpace(dwApplicationCategory, lpdwOptimalSpace);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// The CreateObject() method will return a new instantiation of an IApplicationEntry 
// to the caller.
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::CreateApplicationEntry(IApplicationEntry ** lppObject)
{
  FUNCTION("CApplicationManager::CreateApplicationEntry ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lppObject)||(IsBadWritePtr(lppObject, sizeof(IApplicationEntry *))))
    {
      THROW(E_INVALIDARG);
    }

    *lppObject = (IApplicationEntry *) new CApplicationEntry;
    hResult = ((CApplicationEntry *) *lppObject)->Initialize();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Make sure we clean up and delete the CApplicationEntry object
    //

    if ((NULL != lppObject)&&(!IsBadReadPtr(lppObject, sizeof(IApplicationEntry *))))
    {
      delete ((CApplicationEntry *) *lppObject);
      *lppObject = NULL;
    }

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // Make sure we clean up and delete the CApplicationEntry object
    //

    if ((NULL != lppObject)&&(!IsBadReadPtr(lppObject, sizeof(IApplicationEntry *))))
    {
      delete ((CApplicationEntry *) *lppObject);
      *lppObject = NULL;
    }

    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// The GetApplicationInfo() method will take a pre-initialized object as parameter and seek 
// the first matching registered object based on what was pre-initialized in the pObject. The 
// valid fields for pre-initialization in order of importance are:
//
//    OBJECT_PROPERTY_GUID
//    OBJECT_PROPERTY_SIGNATURE
//
// If none of the above properties are set within the object being passed in, the function 
// will fail.
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::GetApplicationInfo(IApplicationEntry * lpObject)
{
  FUNCTION("CApplicationManager::GetApplicationInfo ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    HRESULT hGuidInitialized;

    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpObject)||(IsBadReadPtr(lpObject, sizeof(CApplicationEntry))))
    {
      THROW(E_INVALIDARG);
    }

    if (CURRENT_ACTION_NONE != ((CApplicationEntry *) lpObject)->GetActionState())
    {
      THROW(APPMAN_E_ACTIONINPROGRESS);
    }

    hGuidInitialized = m_InformationManager.IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, ((CApplicationEntry *) lpObject)->GetApplicationDataPtr());
    hResult = m_InformationManager.GetApplicationData(((CApplicationEntry *) lpObject)->GetApplicationDataPtr());
    if (SUCCEEDED(hResult))
    {
      if (S_OK == hGuidInitialized)
      {
        ((CApplicationEntry *) lpObject)->SetInitializationLevel(INIT_LEVEL_TOTAL);
      }
      else
      {
        ((CApplicationEntry *) lpObject)->SetInitializationLevel(INIT_LEVEL_BASIC);
      }
    }
  }
  
  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::EnumApplications(const DWORD dwApplicationIndex, IApplicationEntry * lpObject)
{
  FUNCTION("CApplicationManager::EnumApplications ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpObject)||(IsBadReadPtr(lpObject, sizeof(CApplicationEntry))))
    {
      THROW(E_INVALIDARG);
    }

    hResult = m_InformationManager.GetApplicationDataWithIndex(dwApplicationIndex, ((CApplicationEntry *) lpObject)->GetApplicationDataPtr());
    if (SUCCEEDED(hResult))
    {
      ((CApplicationEntry *) lpObject)->SetInitializationLevel(INIT_LEVEL_BASIC);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManager::EnumDevices(const DWORD dwTargetIndex, LPDWORD lpdwKilobytes, LPDWORD lpdwExclusionMask, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CApplicationManager::EnumDevices()");

  HRESULT             hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DEVICE_RECORD     sDeviceRecord = {0};
    BOOL              fFound;
    DWORD             dwIndex, dwActualTargetIndex;
    DWORD             dwKilobytes = 0;

    //
    // Make sure the string mask is good
    //

    if ((APP_PROPERTY_STR_ANSI != dwStringMask)&&(APP_PROPERTY_STR_UNICODE != dwStringMask))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure dwDataLen is greater than 0
    //

    if ((0 == dwDataLen)||(NULL == lpData)||(IsBadWritePtr(lpData, dwDataLen)))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure lpdwKilobytes is valid
    //

    if ((NULL == lpdwKilobytes)||(IsBadWritePtr(lpdwKilobytes, sizeof(DWORD))))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Check to make sure lpdwExclusionMask is valid
    //

    if ((NULL == lpdwExclusionMask)||(IsBadWritePtr(lpdwExclusionMask, sizeof(DWORD))))
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }

    //
    // Get the nth device record.
    //
    
    fFound = FALSE;
    dwActualTargetIndex = dwTargetIndex;
    dwIndex = 0;
    do
    {
      if (S_OK == m_InformationManager.CheckDeviceExistance(dwIndex))
      {
        if (dwActualTargetIndex == dwIndex)
        {
          hResult = m_InformationManager.GetDeviceInfoWithIndex(dwIndex, &sDeviceRecord);
          if (SUCCEEDED(hResult))
          {
            hResult = m_InformationManager.GetDeviceMaximumSpaceWithIndex(dwIndex, &dwKilobytes);
            if (SUCCEEDED(hResult))
            {
              fFound = TRUE;
            }
          }
        }
      }
      else
      {
        if (25 > dwActualTargetIndex)
        {
          dwActualTargetIndex++;
        }
      }
      dwIndex++;
    } 
    while ((FALSE == fFound)&&(dwIndex <= dwActualTargetIndex)&&(SUCCEEDED(hResult)));

    //
    // Did we get the information we were looking for
    //

    if (TRUE == fFound)
    {
      //
      // Get the Program files folder
      //

      CRegistryKey  oRegistryKey;
      CHAR          szProgramFiles[MAX_PATH];
      DWORD         dwSize, dwType;

      if (SUCCEEDED(oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), KEY_READ)))
      {
        dwSize = sizeof(szProgramFiles);
        if (SUCCEEDED(oRegistryKey.GetValue(TEXT("ProgramFilesDir"), &dwType, (LPBYTE) szProgramFiles, &dwSize)))
        {
          *lpdwKilobytes = dwKilobytes;
          *lpdwExclusionMask = sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask;
          szProgramFiles[0] = ((CHAR) (sDeviceRecord.sDeviceInfo.dwDeviceIndex + 65));
          strcat(szProgramFiles, "\\");
          if (StrLenA(szProgramFiles) > dwDataLen)
          {
            THROW(APPMAN_E_OVERFLOW);
          }
          if (APP_PROPERTY_STR_ANSI == dwStringMask)
          {
            sprintf((LPSTR) lpData, "%s", szProgramFiles);
          }
          else
          {
            CWin32API   oWin32API;

            oWin32API.MultiByteToWideChar(szProgramFiles, MAX_PATH, (LPWSTR) lpData, dwDataLen);
          }
        }
      }
    }
    else
    {
      hResult = APPMAN_E_INVALIDINDEX;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\applicationmanager.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ApplicationManager.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//  This include file supports all the definitions used internally by the Application Manager
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __APPLICATIONMANAGER_
#define __APPLICATIONMANAGER_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winbase.h>
#include <objbase.h>
#include <assert.h>
#include "AppMan.h"
#include "AppManAdmin.h"
#include "EmptyVc.h"
#include "CriticalSection.h"
#include "InformationManager.h"

#define DISKCLEANER_DAY_THRESHOLD                 120
#define DEFAULT_PERCENT_CACHE_SIZE                70

//
// The defines are used to denote the current action of an object
//

#define CURRENT_ACTION_NONE                       0x00000001
#define CURRENT_ACTION_INSTALLING                 0x00000002
#define CURRENT_ACTION_REINSTALLING               0x00000004
#define CURRENT_ACTION_DOWNSIZING                 0x00000008
#define CURRENT_ACTION_UNINSTALLING               0x00000010
#define CURRENT_ACTION_SELFTESTING                0x00000020
#define CURRENT_ACTION_RUNNING                    0x00000040

//////////////////////////////////////////////////////////////////////////////////////////////

class CApplicationManagerRoot;
class CEmptyVolumeCache;
class CEmptyVolumeCacheCallBack;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CApplicationManager
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CApplicationManager : public IApplicationManager
{
  public :

    //
    // Constructor and destructor
    //

    CApplicationManager(void);
    CApplicationManager(CApplicationManagerRoot *pParent);
    ~CApplicationManager(void);

    //
    // IUnknown Interfaces
    //

    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    //
    // IApplicationManager Interfaces
    //

    STDMETHOD (GetAdvancedMode) (LPDWORD lpdwAdvancedModeMask);
    STDMETHOD (GetAvailableSpace) (const DWORD dwApplicationCategory, LPDWORD lpdwMaximumSpace, LPDWORD lpdwOptimalSpace);
    STDMETHOD (CreateApplicationEntry) (IApplicationEntry ** lppObject);
    STDMETHOD (GetApplicationInfo) (IApplicationEntry * lpObject);
    STDMETHOD (EnumApplications) (const DWORD dwIndex, IApplicationEntry * lpObject);
    STDMETHOD (EnumDevices) (const DWORD dwIndex, LPDWORD lpdwKilobytes, LPDWORD lpdwExclusionMask, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);

  private:

    CApplicationManagerRoot * m_pParentObject;
    CInformationManager       m_InformationManager;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CApplicationEntry
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CApplicationEntry : public IApplicationEntry
{
  public:
	
    //
    // Constructors, default copy constructor and assignment operator
    //

    CApplicationEntry(void);
    CApplicationEntry(const CApplicationEntry & refApplicationEntry);
    CApplicationEntry & operator = (const CApplicationEntry & refSourceObject);
    ~CApplicationEntry(void);

    //
    // IUnknown interfaces
    //

    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    //
    // IApplicationEntry Interfaces
    //

    STDMETHOD (Initialize) (void);
    STDMETHOD (SetInitializationLevel) (DWORD dwInitializationLevel);
    STDMETHOD_(DWORD, GetActionState) (void);
    STDMETHOD (Clear) (void);
    STDMETHOD (GetProperty) (const DWORD dwProperty, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (SetProperty) (const DWORD dwProperty, LPCVOID lpData, const DWORD dwDataLen);
    STDMETHOD (InitializeInstall) (void);
    STDMETHOD (FinalizeInstall) (void);
    STDMETHOD (InitializeDownsize) (void);
    STDMETHOD (FinalizeDownsize) (void);
    STDMETHOD (InitializeReInstall) (void);
    STDMETHOD (FinalizeReInstall) (void);
    STDMETHOD (InitializeUnInstall) (void);
    STDMETHOD (FinalizeUnInstall) (void);
    STDMETHOD (InitializeSelfTest) (void);
    STDMETHOD (FinalizeSelfTest) (void);
    STDMETHOD (Abort) (void);
    STDMETHOD (Run) (const DWORD dwRunFlags, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (AddAssociation) (const DWORD dwAssociationType, const IApplicationEntry * pApplicationEntry);
    STDMETHOD (RemoveAssociation) (const DWORD dwAssociationType, const IApplicationEntry * pApplicationEntry);
    STDMETHOD (EnumAssociations) (const DWORD dwIndex, LPDWORD lpdwAssociationMask, IApplicationEntry * pApplicationEntry);
    STDMETHOD (GetTemporarySpace) (const DWORD dwSpace, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (RemoveTemporarySpace) (const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (EnumTemporarySpaces) (const DWORD dwIndex, LPDWORD lpdwSpace, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);

    LPAPPLICATION_DATA  GetApplicationDataPtr(void);

  private :

    STDMETHOD (LockApplication) (void);
    STDMETHOD (UnLockApplication) (void);
    STDMETHOD (ValidateGetPropertyParameters) (const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (ValidateStringProperty) (const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPCWSTR wszStringProperty);
    STDMETHOD (ValidateSetPropertyParameters) (const DWORD dwPropertyIndex, const DWORD dwPropertyModifiers, LPCVOID lpData, const DWORD dwDataLen);
    STDMETHOD (ValidateCommandLine) (LPCWSTR wszRootPath, LPCWSTR wszCommandLine);
    STDMETHOD (ComputeApplicationSpaceInfo) (const DWORD dwInstalledKilobytesExpected);
    STDMETHOD (ComputeOriginalApplicationSpaceInfo) (void);

    GUID                  m_sInstanceGuid;
    HANDLE                m_hInstanceMutex;
    DWORD                 m_dwLockCount;
    BOOL                  m_fIsInitialized;
    LONG                  m_lReferenceCount;
    CInformationManager   m_InformationManager;
    DWORD                 m_dwInitializationLevel;
    DWORD                 m_dwCurrentAction;
    DWORD                 m_dwOriginalSetupRootPathSizeKilobytes;
    DWORD                 m_dwOriginalApplicationRootPathSizeKilobytes;
    DWORD                 m_dwOriginalState;
    CCriticalSection      m_sCriticalSection;
    APPLICATION_DATA      m_sApplicationData;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CEmptyVolumeCache
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CEmptyVolumeCache : public IEmptyVolumeCache
{
  public:
	
    //
    // Constructors, default copy constructor and assignment operator
    //

    CEmptyVolumeCache(void);
    CEmptyVolumeCache(CApplicationManagerRoot * lpParent);
    ~CEmptyVolumeCache(void);

    //
    // IUnknown interfaces
    //

    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    STDMETHOD (Initialize) (HKEY hRegKey, LPCWSTR lpwszVolume, LPWSTR * lppwszDisplayName, LPWSTR * lppwszDescription, DWORD * lpdwFlags);
    STDMETHOD (GetSpaceUsed) (DWORDLONG * lpdwSpaceUsed, IEmptyVolumeCacheCallBack * lpCallBack);
    STDMETHOD (Purge) (DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack * lpCallBack);
    STDMETHOD (ShowProperties) (HWND hwnd);
    STDMETHOD (Deactivate) (DWORD * lpdwFlags);   

    WCHAR     m_wszDiskCleanerName[MAX_PATH_CHARCOUNT];
    WCHAR     m_wszDiskCleanerName2[MAX_PATH_CHARCOUNT];
    WCHAR     m_wszDiskCleanerDesc[2048];
    WCHAR     m_wszDiskCleanerDesc2[1024];
    WCHAR     m_wszDiskCleanerDayTH[10];

  private:

    HRESULT   GetSpaceUtilization(DWORD dwDeviceIndex, DWORD dwDays, LPDWORD lpdwKilobytes, IEmptyVolumeCacheCallBack * lpCallBack);
    HRESULT   CleanDisk(DWORD dwDeviceIndex, DWORD dwDays, DWORD dwKilobytesToFree, IEmptyVolumeCacheCallBack * lpCallBack);
    HRESULT   CleanDiskUnattended(DWORD dwDays);
    DWORD     VolumeStringToNumber(LPCWSTR lpwszVolume);
    DWORD     ElapsedDays(SYSTEMTIME * lpLastUsedDate);

    DWORD                       m_dwVolume;
    DWORD                       m_dwDiskCleanerDayThreshold; 
    CApplicationManagerRoot   * m_lpoParentObject;
    CInformationManager         m_oInformationManager;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CApplicationManager
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CApplicationManagerAdmin : public IApplicationManagerAdmin
{
  public :

    //
    // Constructor and destructor
    //

    CApplicationManagerAdmin(void);
    CApplicationManagerAdmin(CApplicationManagerRoot * lpParent);
    ~CApplicationManagerAdmin(void);

    //
    // IUnknown Interfaces
    //

    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    //
    // IApplicationManager Interfaces
    //

    STDMETHOD (EnumerateDevices) (const DWORD dwIndex, GUID * lpGuid);
    STDMETHOD (GetDeviceProperty) (const DWORD dwProperty, const GUID * lpGuid, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (SetDeviceProperty) (const DWORD dwProperty, const GUID * lpGuid, LPVOID lpData, const DWORD dwDataLen);

    STDMETHOD (GetAppManProperty) (const DWORD dwProperty, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (SetAppManProperty) (const DWORD dwProperty, LPCVOID lpData, const DWORD dwDataLen);

    STDMETHOD (CreateApplicationEntry) (IApplicationEntry **ppObject);
    STDMETHOD (GetApplicationInfo) (IApplicationEntry * pObject);
    STDMETHOD (EnumApplications) (const DWORD dwApplicationIndex, IApplicationEntry * lpObject);
    STDMETHOD (DoApplicationAction) (const DWORD dwAction, const GUID * lpGuid, const DWORD dwStringProperty, LPVOID lpData, const DWORD dwDataLen);

  private:

    CApplicationManagerRoot * m_pParentObject;
    CInformationManager       m_InformationManager;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CApplicationManagerRoot class
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CApplicationManagerRoot : public IUnknown
{
  public :

    //
    // Constructor and Destructor
    //

    CApplicationManagerRoot(void);
    ~CApplicationManagerRoot(void);

    //
    // IUnknow interface methods
    //

    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID *ppVoidObject);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    BOOL                      m_bInsufficientAccessToRun;  

    private :

    CApplicationManager       m_ApplicationManager;
    CApplicationManagerAdmin  m_ApplicationManagerAdmin;
    CEmptyVolumeCache         m_EmptyVolumeCache;
    LONG                      m_lReferenceCount;
};

#ifdef __cplusplus
}
#endif

#endif // __APPLICATIONMANAGER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\applicationmanageradmin.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ApplicationManagerAdmin.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of IApplicationManagerAdmin
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include "AppMan.h"
#include "AppManAdmin.h"
#include "ApplicationManager.h"
#include "AppManDebug.h"
#include "ExceptionHandler.h"
#include "RegistryKey.h"

//To flag as DBG_APPMANADMIN
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMANADMIN

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManagerAdmin::CApplicationManagerAdmin(void)
{
  FUNCTION("CApplicationManagerAdmin::CApplicationManagerAdmin (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManagerAdmin::CApplicationManagerAdmin(CApplicationManagerRoot * lpParent)
{
  FUNCTION("CApplicationManagerAdmin::CApplicationManagerAdmin (CApplicationManagerRoot *pParent)");

  assert(NULL != lpParent);

  m_pParentObject = lpParent;
  m_InformationManager.Initialize();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManagerAdmin::~CApplicationManagerAdmin(void)
{
  FUNCTION("CApplicationManagerAdmin::~CApplicationManagerAdmin (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::QueryInterface(REFIID RefIID, LPVOID * lppVoidObject)
{
  FUNCTION("CApplicationManagerAdmin::QueryInterface ()");

	if (NULL == m_pParentObject)
  {
    return E_NOINTERFACE;
  }

	return m_pParentObject->QueryInterface(RefIID, lppVoidObject);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManagerAdmin::AddRef(void)
{
  FUNCTION("CApplicationManagerAdmin::AddRef ()");

  if (NULL != m_pParentObject)
  {
    return m_pParentObject->AddRef();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManagerAdmin::Release(void)
{
  FUNCTION("CApplicationManagerAdmin::Release ()");

  if (NULL != m_pParentObject)
  {
    return m_pParentObject->Release();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::EnumerateDevices(const DWORD dwIndex, GUID * lpGuid)
{
  FUNCTION("CApplicationManagerAdmin::EnumerateDevices ()");

  HRESULT             hResult = E_FAIL;
  DEVICE_RECORD       sDeviceRecord;
  
  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Enumerate devices. Get the device GUID for device record at dwIndex
    //

    if (S_OK == m_InformationManager.CheckDeviceExistance(dwIndex))
    {
      hResult = m_InformationManager.GetDeviceInfoWithIndex(dwIndex, &sDeviceRecord);
      if (SUCCEEDED(hResult))
      {
        memcpy(lpGuid, &(sDeviceRecord.sDeviceGuid), sizeof(GUID));
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::GetDeviceProperty(const DWORD dwProperty, const GUID * lpGuid, LPVOID lpData, const DWORD /*dwDataLen*/)     // Get rid of /W4 warning.
{
  FUNCTION("CApplicationManagerAdmin::GetDeviceProperty ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DEVICE_RECORD       sDeviceRecord = {0};
    DEVICE_SPACE_INFO   sDeviceSpaceInfo = {0};

    //
    // Prefetch the device information
    //

    ZeroMemory(&sDeviceRecord, sizeof(sDeviceRecord));
    memcpy(&(sDeviceRecord.sDeviceGuid), lpGuid, sizeof(GUID));
    hResult = m_InformationManager.GetDeviceInfo(&sDeviceRecord);
    if (SUCCEEDED(hResult))
    {
      hResult = m_InformationManager.GetDeviceSpaceInfoWithIndex(sDeviceRecord.sDeviceInfo.dwDeviceIndex, &sDeviceSpaceInfo);
      if (SUCCEEDED(hResult))
      {
        hResult = m_InformationManager.GetDeviceInfo(&sDeviceRecord);
      }
    }

    if (SUCCEEDED(hResult))
    {
      switch(dwProperty)
      {
        case DEVICE_PROPERTY_TOTALKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalKilobytes;
          break;

        case DEVICE_PROPERTY_TOTALFREEKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalFreeKilobytes;
          break;

        case DEVICE_PROPERTY_TOTALAVAILABLEKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwMaximumUsableKilobytes;
          break;

        case DEVICE_PROPERTY_OPTIMALAVAILABLEKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwOptimalUsableKilobytes;
          break;

        case DEVICE_PROPERTY_REMOVABLEKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalRemovableKilobytes;
          break;

        case DEVICE_PROPERTY_NONREMOVABLEKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalNonRemovableKilobytes;
          break;

        case DEVICE_PROPERTY_RESERVEDKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalReservedKilobytes;
          break;

        case DEVICE_PROPERTY_TOTALTEMPORARYKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalReservedTemporaryKilobytes;
          break;

        case DEVICE_PROPERTY_USEDTEMPORARYKILOBYTES
        : *(LPDWORD)lpData = sDeviceSpaceInfo.dwTotalUsedTemporaryKilobytes;
          break;

        case DEVICE_PROPERTY_PERCENTCACHESIZE
        : *(LPDWORD)lpData = sDeviceRecord.sDeviceInfo.dwPercentCacheSize;
          break;

        case DEVICE_PROPERTY_PERCENTMINIMUMFREESIZE
        : *(LPDWORD)lpData = sDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize;
          break;

        case DEVICE_PROPERTY_EXCLUSIONMASK
        : *(LPDWORD)lpData = sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask;
          break;

        default
        : THROW(APPMANADMIN_E_INVALIDPROPERTY);
          break;
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::SetDeviceProperty(const DWORD dwProperty, const GUID * lpGuid, LPVOID lpData, const DWORD /*dwDataLen*/)     // Get rid of /W4 warning.
{
  FUNCTION("CApplicationManagerAdmin::SetDeviceProperty ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DEVICE_RECORD   sDeviceRecord;

    ZeroMemory(&sDeviceRecord, sizeof(sDeviceRecord));
    memcpy(&(sDeviceRecord.sDeviceGuid), lpGuid, sizeof(GUID));
    hResult = m_InformationManager.GetDeviceInfo(&sDeviceRecord);

    if (SUCCEEDED(hResult))
    {
      switch(dwProperty)
      {
        case DEVICE_PROPERTY_TOTALKILOBYTES:
        case DEVICE_PROPERTY_TOTALFREEKILOBYTES:
        case DEVICE_PROPERTY_TOTALAVAILABLEKILOBYTES:
        case DEVICE_PROPERTY_OPTIMALAVAILABLEKILOBYTES:
        case DEVICE_PROPERTY_REMOVABLEKILOBYTES:
        case DEVICE_PROPERTY_NONREMOVABLEKILOBYTES:
        case DEVICE_PROPERTY_RESERVEDKILOBYTES:
        case DEVICE_PROPERTY_TOTALTEMPORARYKILOBYTES:
        case DEVICE_PROPERTY_USEDTEMPORARYKILOBYTES
        : THROW(APPMANADMIN_E_READONLYPROPERTY);
          break;

        case DEVICE_PROPERTY_PERCENTCACHESIZE
        : sDeviceRecord.sDeviceInfo.dwPercentCacheSize = (DWORD) *((LPDWORD) lpData);
          if (100 < sDeviceRecord.sDeviceInfo.dwPercentCacheSize)
          {
            if (0xffffffff == sDeviceRecord.sDeviceInfo.dwPercentCacheSize)
            {
              CRegistryKey  sRegistryKey;
              DWORD         dwType, dwSize;

              sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_ALL_ACCESS);
              sDeviceRecord.sDeviceInfo.dwPercentCacheSize = DEFAULT_PERCENT_CACHE_SIZE;
              if (S_OK == sRegistryKey.CheckForExistingValue("DefaultPercentCacheSize"))
              {
                dwSize = sizeof(sDeviceRecord.sDeviceInfo.dwPercentCacheSize);
                sRegistryKey.GetValue("DefaultPercentCacheSize", &dwType, (LPBYTE) &sDeviceRecord.sDeviceInfo.dwPercentCacheSize, &dwSize);
              }

              //
              // Is the registry value corrupt
              //

              if (100 < sDeviceRecord.sDeviceInfo.dwPercentCacheSize)
              {
                sDeviceRecord.sDeviceInfo.dwPercentCacheSize = DEFAULT_PERCENT_CACHE_SIZE;
                sRegistryKey.SetValue("DefaultPercentCacheSize", REG_DWORD, (const BYTE *) &sDeviceRecord.sDeviceInfo.dwPercentCacheSize, sizeof(sDeviceRecord.sDeviceInfo.dwPercentCacheSize));
              }
            }
            else
            {
              THROW(APPMAN_E_INVALIDPROPERTYVALUE);
            }
          }
          hResult = m_InformationManager.SetDeviceInfoWithIndex(sDeviceRecord.sDeviceInfo.dwDeviceIndex, &sDeviceRecord);
          break;

        case DEVICE_PROPERTY_PERCENTMINIMUMFREESIZE
        : sDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize = (DWORD) *((LPDWORD) lpData);
          if (100 < sDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize)
          {
            THROW(APPMAN_E_INVALIDPROPERTYVALUE);
          }
          hResult = m_InformationManager.SetDeviceInfoWithIndex(sDeviceRecord.sDeviceInfo.dwDeviceIndex, &sDeviceRecord);
          break;

        case DEVICE_PROPERTY_EXCLUSIONMASK
        : sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask &= ~DEVICE_EXCLUSION_MASK;
          sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask |= (DWORD) *((LPDWORD) lpData);
          hResult = m_InformationManager.SetDeviceInfoWithIndex(sDeviceRecord.sDeviceInfo.dwDeviceIndex, &sDeviceRecord);
          break;

        default
        : THROW(APPMANADMIN_E_INVALIDPROPERTY);
          break;
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::GetAppManProperty(const DWORD dwProperty, LPVOID lpData, const DWORD /*dwDataLen*/)
{
  FUNCTION("CApplicationManagerAdmin::GetAppManProperty ()");

  HRESULT             hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DWORD   dwMaxKilobytes = 0, dwOptimalKilobytes = 0, dwAdvancedMode = 0;

    //
    // Prefetch some of the global information
    //

    hResult = m_InformationManager.GetMaximumAvailableSpace(APP_CATEGORY_ENTERTAINMENT, &dwMaxKilobytes);
    if (SUCCEEDED(hResult))
    {
      hResult = m_InformationManager.GetOptimalAvailableSpace(APP_CATEGORY_ENTERTAINMENT, &dwOptimalKilobytes);
      if (SUCCEEDED(hResult))
      {
        hResult = m_InformationManager.GetAdvancedMode(&dwAdvancedMode);
      }
    }

    if (SUCCEEDED(hResult))
    {
      switch(dwProperty)
      {
        case APPMAN_PROPERTY_TOTALKILOBYTES
        : *(LPDWORD)lpData = dwMaxKilobytes;
          break;

        case APPMAN_PROPERTY_OPTIMALKILOBYTES
        : *(LPDWORD)lpData = dwOptimalKilobytes;
          break;

        case APPMAN_PROPERTY_ADVANCEDMODE
        : *(LPDWORD)lpData = dwAdvancedMode;
          break;

        default
        : THROW(APPMANADMIN_E_INVALIDPROPERTY);
          break;
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::SetAppManProperty(const DWORD dwProperty, LPCVOID lpData, const DWORD /*dwDataLen*/)
{
  FUNCTION("CApplicationManagerAdmin::SetAppManProperty()");

  HRESULT             hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (APPMAN_PROPERTY_ADVANCEDMODE == dwProperty)
    {
      hResult = m_InformationManager.SetAdvancedMode((DWORD) *((LPDWORD) lpData));
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::CreateApplicationEntry(IApplicationEntry ** ppObject)
{
  FUNCTION("CApplicationManagerAdmin::CreateApplicationEntry ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    *ppObject = (IApplicationEntry *) new CApplicationEntry;
    hResult = ((CApplicationEntry *) *ppObject)->Initialize();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Make sure we clean up and delete the CApplicationEntry object
    //

    delete ((CApplicationEntry *) *ppObject);
    *ppObject = NULL;

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // Make sure we clean up and delete the CApplicationEntry object
    //

    delete ((CApplicationEntry *) *ppObject);
    *ppObject = NULL;

    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::GetApplicationInfo(IApplicationEntry * lpObject)
{
  FUNCTION("CApplicationManagerAdmin::GetApplicationInfo ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpObject)||(IsBadReadPtr(lpObject, sizeof(CApplicationEntry))))
    {
      THROW(E_INVALIDARG);
    }

    hResult = m_InformationManager.GetApplicationData(((CApplicationEntry *) lpObject)->GetApplicationDataPtr());
    if (SUCCEEDED(hResult))
    {
      ((CApplicationEntry *) lpObject)->SetInitializationLevel(INIT_LEVEL_TOTAL);
    }
  }
  
  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::EnumApplications(const DWORD dwApplicationIndex, IApplicationEntry * lpObject)
{
  FUNCTION("CApplicationManagerAdmin::EnumApplications ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
    // Check to make sure the pointer we receive is good
    //

    if ((NULL == lpObject)||(IsBadReadPtr(lpObject, sizeof(CApplicationEntry))))
    {
      THROW(E_INVALIDARG);
    }

    hResult = m_InformationManager.GetApplicationDataWithIndex(dwApplicationIndex, ((CApplicationEntry *) lpObject)->GetApplicationDataPtr());
    if (SUCCEEDED(hResult))
    {
      ((CApplicationEntry *) lpObject)->SetInitializationLevel(INIT_LEVEL_TOTAL);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    //
    // Get Result code
    //

    hResult = pException->GetResultCode();

    //
    // Delete exception handler
    //

    delete pException;
  }

  catch(...)
  {
    //
    // If we failed to handle an exception, we default to APPMAN_E_CRITICALERROR
    //

    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerAdmin::DoApplicationAction(const DWORD dwAction, const GUID * lpGuid, const DWORD dwStringProperty, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CApplicationManagerAdmin::DoApplicationAction ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    APPLICATION_DATA  sApplicationData;
    DWORD             dwVariable;

    ZeroMemory(&sApplicationData, sizeof(sApplicationData));
    memcpy(&(sApplicationData.sBaseInfo.sApplicationGuid), lpGuid, sizeof(GUID));
    m_InformationManager.ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);

    hResult = m_InformationManager.GetApplicationData(&sApplicationData);
    if (SUCCEEDED(hResult))
    {
      //
      // Handle the GetProperty() request
      //

      switch(dwAction)
      {
        case ACTION_APP_DOWNSIZE
        : //
          // Make sure the required parameters are proper
          //

          if ((NULL == lpData)||(sizeof(DWORD) != dwDataLen))
          {
            THROW(APPMANADMIN_E_INVALIDPARAMETERS);
          }
          hResult = m_InformationManager.DownsizeApplication((DWORD) *((LPDWORD) lpData), &sApplicationData);
          break;

        case ACTION_APP_REINSTALL
        : hResult = m_InformationManager.ReInstallApplication(&sApplicationData);
          break;

        case ACTION_APP_UNINSTALL
        : hResult = m_InformationManager.UnInstallApplication(&sApplicationData);
          break;

        case ACTION_APP_UNINSTALLBLOCK
        : hResult = m_InformationManager.UnInstallApplicationWait(&sApplicationData);
          break;

        case ACTION_APP_SELFTEST
        : hResult = m_InformationManager.SelfTestApplication(&sApplicationData);
          break;

        case ACTION_APP_RUN_BLOCK
        : hResult = m_InformationManager.RunApplication(&sApplicationData, APP_RUN_BLOCK, dwStringProperty, (LPWSTR) lpData, dwDataLen);
          break;

        case ACTION_APP_RUN_NOBLOCK
        : hResult = m_InformationManager.RunApplication(&sApplicationData, APP_RUN_NOBLOCK, dwStringProperty, (LPWSTR) lpData, dwDataLen);
          break;

        case ACTION_APP_PIN
        : if (FALSE == sApplicationData.sBaseInfo.dwPinState)
          {
            dwVariable = TRUE;
          }
          else
          {
            dwVariable = FALSE;
          }
          hResult = m_InformationManager.PinApplication(&sApplicationData, (BOOL *) &dwVariable);
          break;
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\apppropertyrules.cpp ===
#include <windows.h>
#include "ApplicationManager.h"
#include "AppPropertyRules.h"

#define NEVER 0

//
// Property info array
//

extern PROPERTY_INFO gPropertyInfo[PROPERTY_COUNT] =
{
  /* IDX_PROPERTY_GUID */                       { APP_PROPERTY_GUID,                      0x00000000, 0x00000001, CURRENT_ACTION_NONE,                                                                  INIT_LEVEL_NONE | INIT_LEVEL_TOTAL,                     sizeof(GUID),                 APP_STRING_NONE                   },
  /* IDX_PROPERTY_COMPANYNAME */                { APP_PROPERTY_COMPANYNAME,               0x00000000, 0x00000002, CURRENT_ACTION_NONE,                                                                  INIT_LEVEL_NONE | INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,  MAX_COMPANYNAME_CHARCOUNT,    APP_STRING_COMPANYNAME            },
  /* IDX_PROPERTY_SIGNATURE */                  { APP_PROPERTY_SIGNATURE,                 0x00000000, 0x00000004, CURRENT_ACTION_NONE,                                                                  INIT_LEVEL_NONE | INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,  MAX_SIGNATURE_CHARCOUNT,      APP_STRING_SIGNATURE              },
  /* IDX_PROPERTY_VERSIONSTRING */              { APP_PROPERTY_VERSIONSTRING,             0x00000000, 0x00000008, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_NONE | INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,  MAX_VERSIONSTRING_CHARCOUNT,  APP_STRING_VERSION                },
  /* IDX_PROPERTY_ROOTPATH */                   { APP_PROPERTY_ROOTPATH,                  0x00000000, 0x00000010, CURRENT_ACTION_NONE,                                                                  INIT_LEVEL_TOTAL,                                       MAX_PATH_CHARCOUNT,           APP_STRING_APPROOTPATH            },
  /* IDX_PROPERTY_SETUPROOTPATH */              { APP_PROPERTY_SETUPROOTPATH,             0x00000000, 0x00000020, NEVER,                                                                                INIT_LEVEL_TOTAL,                                       MAX_PATH_CHARCOUNT,           APP_STRING_SETUPROOTPATH          },
  /* IDX_PROPERTY_STATE */                      { APP_PROPERTY_STATE,                     0x00000000, 0x00000040, CURRENT_ACTION_INSTALLING,                                                            INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_CATEGORY */                   { APP_PROPERTY_CATEGORY,                  0x00000000, 0x00000080, CURRENT_ACTION_NONE,                                                                  INIT_LEVEL_NONE | INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,  sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES */  { APP_PROPERTY_ESTIMATEDINSTALLKILOBYTES, 0x00000000, 0x00000100, CURRENT_ACTION_NONE | CURRENT_ACTION_SELFTESTING,                                     INIT_LEVEL_NONE | INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,  sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_NONREMOVABLEKILOBYTES */      { APP_PROPERTY_NONREMOVABLEKILOBYTES,     0x00000000, 0x00000200, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_REMOVABLEKILOBYTES */         { APP_PROPERTY_REMOVABLEKILOBYTES,        0x00000000, 0x00000400, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_DOWNSIZING | CURRENT_ACTION_REINSTALLING,  INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_EXECUTECMDLINE */             { APP_PROPERTY_EXECUTECMDLINE,            0x00000000, 0x00000800, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_EXECUTECMDLINE         },
  /* IDX_PROPERTY_DOWNSIZECMDLINE */            { APP_PROPERTY_DOWNSIZECMDLINE,           0x00000000, 0x00001000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_TOTAL,                                       MAX_PATH_CHARCOUNT,           APP_STRING_DOWNSIZECMDLINE        },
  /* IDX_PROPERTY_REINSTALLCMDLINE */           { APP_PROPERTY_REINSTALLCMDLINE,          0x00000000, 0x00002000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_TOTAL,                                       MAX_PATH_CHARCOUNT,           APP_STRING_REINSTALLCMDLINE       },
  /* IDX_PROPERTY_UNINSTALLCMDLINE */           { APP_PROPERTY_UNINSTALLCMDLINE,          0x00000000, 0x00004000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_UNINSTALLCMDLINE       },
  /* IDX_PROPERTY_SELFTESTCMDLINE */            { APP_PROPERTY_SELFTESTCMDLINE,           0x00000000, 0x00008000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_TOTAL,                                       MAX_PATH_CHARCOUNT,           APP_STRING_SELFTESTCMDLINE        },
  /* IDX_PROPERTY_INSTALLDATE */                { APP_PROPERTY_INSTALLDATE,               0x00000000, 0x00040000, NEVER,                                                                                INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(SYSTEMTIME),           APP_STRING_NONE                   },
  /* IDX_PROPERTY_LASTUSEDDATE */               { APP_PROPERTY_LASTUSEDDATE,              0x00000000, 0x00080000, NEVER,                                                                                INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(SYSTEMTIME),           APP_STRING_NONE                   },
  /* IDX_PROPERTY_TITLEURL */                   { APP_PROPERTY_TITLEURL,                  0x00000000, 0x00100000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_TITLEURL               },
  /* IDX_PROPERTY_PUBLISHERURL */               { APP_PROPERTY_PUBLISHERURL,              0x00000000, 0x00200000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_PUBLISHERURL           },
  /* IDX_PROPERTY_DEVELOPERURL */               { APP_PROPERTY_DEVELOPERURL,              0x00000000, 0x00400000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_DEVELOPERURL           },
  /* IDX_PROPERTY_PIN */                        { APP_PROPERTY_PIN,                       0x00000000, 0x00800000, NEVER,                                                                                INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    sizeof(DWORD),                APP_STRING_NONE                   },
  /* IDX_PROPERTY_DEVICEGUID */                 { 0,                                      0x00000000, 0x01000000, NEVER,                                                                                NEVER,                                                  sizeof(GUID),                 APP_STRING_NONE                   },
  /* IDX_PROPERTY_XMLINFOFILE */                { APP_PROPERTY_XMLINFOFILE,               0x00000000, 0x02000000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_XMLINFOFILE            },
  /* IDX_PROPERTY_DEFAULTSETUPEXECMDLINE */     { APP_PROPERTY_DEFAULTSETUPEXECMDLINE,    0x00000000, 0x04000000, CURRENT_ACTION_INSTALLING | CURRENT_ACTION_REINSTALLING,                              INIT_LEVEL_BASIC | INIT_LEVEL_TOTAL,                    MAX_PATH_CHARCOUNT,           APP_STRING_DEFAULTSETUPEXECMDLINE }
};

extern void InitializePropertyRules(void)
{
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\applicationmanagerroot.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ApplicationManagerRoot.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the IWindowsGameManager code.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "ApplicationManager.h"
#include "AppManDebug.h"
#include "ExceptionHandler.h"
#include "Global.h"

extern LONG g_lDLLReferenceCount;

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMANROOT

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4355)
CApplicationManagerRoot::CApplicationManagerRoot(void)
                        :m_bInsufficientAccessToRun(FALSE),
                         m_ApplicationManager(this), m_ApplicationManagerAdmin(this), m_EmptyVolumeCache(this)
#pragma warning(default : 4355)
{
  FUNCTION("CApplicationManagerRoot::CApplicationManagerRoot (void)");
	m_lReferenceCount = 1;
  InterlockedIncrement(&g_lDLLReferenceCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CApplicationManagerRoot::~CApplicationManagerRoot(void)
{
  FUNCTION("CApplicationManagerRoot::~CApplicationManagerRoot (void)");

	InterlockedDecrement(&g_lDLLReferenceCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CApplicationManagerRoot::QueryInterface(REFIID RefIID, LPVOID *ppVoidObject)
{
  FUNCTION("CApplicationManagerRoot::QueryInterface ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    if (NULL == &RefIID)
    {
      THROW(E_UNEXPECTED);
    }

	  *ppVoidObject = NULL;

	  if (RefIID == IID_IUnknown)
	  {
		  *ppVoidObject = (LPVOID) this;
	  }
	  else
	  {
		  if (RefIID == IID_ApplicationManager)
		  {
			  *ppVoidObject = (LPVOID) &m_ApplicationManager;
		  }
		  else
		  {
			  if (RefIID == IID_ApplicationManagerAdmin)
			  {
				  *ppVoidObject = (LPVOID) &m_ApplicationManagerAdmin;
			  }
			  else 
			  {
				  if (RefIID == IID_IEmptyVolumeCache)
				  {
					  *ppVoidObject = (LPVOID) &m_EmptyVolumeCache;
				  }
			  }
		  }
	  }

	  if (*ppVoidObject)
	  {
		  ((LPUNKNOWN)*ppVoidObject)->AddRef();
	  }
    else
    {
      hResult = E_NOINTERFACE;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    if ((NULL == &RefIID)||(NULL == ppVoidObject)||(IsBadWritePtr(ppVoidObject, sizeof(LPVOID))))
    {
      hResult = E_INVALIDARG;
    }
    else
    {
      hResult = E_UNEXPECTED;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManagerRoot::AddRef(void)
{
  FUNCTION("CApplicationManagerRoot::AddRef ()");

	return InterlockedIncrement(&m_lReferenceCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CApplicationManagerRoot::Release(void)
{
  FUNCTION("CApplicationManagerRoot::Release ()");

  DWORD dwReferenceCount;

  dwReferenceCount = InterlockedDecrement(&m_lReferenceCount);
	if (0 == dwReferenceCount)
	{
		delete this;
	}

	return dwReferenceCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\appmandebug.cpp ===
#include <stdarg.h>
#include "AppManDebug.h"

#if _TRACEON == TRUE

#pragma message("Trace is on")

CAppManDebugHandler   g_oDebugHandler;
CHAR                  g_szDebugString[256];

#define APPMAN_REG_DBG

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD GetExternalMask(const DWORD dwMsgType)
{
  return (DBG_EXTERNAL & dwMsgType);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD GetLevel(const DWORD dwMsgType)
{
  DWORD dwLevel = 0;

  if ((DBG_ERROR | DBG_THROW | DBG_CATCH) & dwMsgType)
  {
    dwLevel = 0;
  }
  else if (DBG_WARNING & dwMsgType)
  {
    dwLevel = 1;
  }
  else if ((DBG_FUNCENTRY | DBG_FUNCEXIT | DBG_CONSTRUCTOR | DBG_DESTRUCTOR) & dwMsgType)
  {
    dwLevel = 2;
  }
  else
  {
    dwLevel = 5;
  }

  return dwLevel;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD GetSourceMask(const DWORD dwMsgType)
{
  return (DBG_ALL_MODULES & dwMsgType);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern CHAR * MakeDebugString(const CHAR * szFormat, ...)
{
  va_list   ArgumentList;

  if (NULL != szFormat)
  {
    va_start(ArgumentList, szFormat);
    _vsnprintf(g_szDebugString, 256, szFormat, ArgumentList);
    va_end(ArgumentList);
  }

  return g_szDebugString;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManDebugHandler::CAppManDebugHandler(void)
{
  m_fDebugInitialized = FALSE;
  m_dwDebugLevel = 0;
  m_dwDebugInternal = 0;
  m_dwSourceFlags = 0xffffffff;
  m_dwOperationalFlags = OP_NOTHING;
  m_dwReportMode = _CRTDBG_MODE_DEBUG;
  m_dwFunctionDepth = 0;
  strcpy(m_szOutputFilename,"c:\\AppManDebug.txt");
  m_MutexHandle = CreateMutex(NULL, FALSE, "AppManDebug");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManDebugHandler::~CAppManDebugHandler(void)
{
  CloseHandle(m_MutexHandle);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::InitDebug(void) 
{
  DWORD   dwType;
  DWORD   dwSize;
  HKEY    hRegistryKey = NULL;
  BYTE    cBuffer[512];

  if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_APPMAN, 0, KEY_READ, &hRegistryKey))
  {
    //
    // What is the debug level
    //

	  dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "Debug", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_DWORD == dwType)&&(sizeof(DWORD) == dwSize))
      {
        m_dwDebugLevel = *((LPDWORD) cBuffer);
      }
    }

    //
    // What is the debug level
    //

	  dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "DebugInternal", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_DWORD == dwType)&&(sizeof(DWORD) == dwSize))
      {
        m_dwDebugInternal = *((LPDWORD) cBuffer);
      }
    }

	  //
	  // What is the DebugSourceFlag
	  //

	  dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "DebugSourceFlags", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_DWORD == dwType)&&(sizeof(DWORD) == dwSize))
      {
        m_dwSourceFlags = *((LPDWORD) cBuffer);
      }
    }

	  //
	  // What is the DebugOperationFlags
	  //

	  dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "DebugOperationFlags", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_DWORD == dwType)&&(sizeof(DWORD) == dwSize))
      {
        m_dwOperationalFlags = *((LPDWORD) cBuffer);
      }
    }

    //
    // What is the DebugReportMode
    //
	  // _CRTDBG_MODE_FILE      0x00000001
    // _CRTDBG_MODE_DEBUG     0x00000002
    // _CRTDBG_MODE_WNDW      0x00000004
    //

    dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "DebugReportMode", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_DWORD == dwType)&&(sizeof(DWORD) == dwSize))
      {
        m_dwReportMode = *((LPDWORD) cBuffer);
      }
    }

    //
    // What is the DebugOutputFilename
    //

    dwSize = sizeof(cBuffer);
    if (ERROR_SUCCESS == RegQueryValueEx(hRegistryKey, "DebugOutputFilename", NULL, &dwType, (LPBYTE) cBuffer, &dwSize))
    {
      if ((REG_SZ == dwType)&&(sizeof(DWORD) == dwSize))
      {
        strcpy(m_szOutputFilename, (LPCSTR) cBuffer);
      }
    }

    //
    // Check that the filename is valid and can be opened
    //

    if (_CRTDBG_MODE_FILE & m_dwReportMode)
    {
      HANDLE  hFile;

      hFile = CreateFile(m_szOutputFilename, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
      if (NULL == hFile)
      {
        m_dwReportMode &= ~_CRTDBG_MODE_FILE;
      }
      else
      {
        CloseHandle(hFile);
      }
    }

    //
    // Close the registry key
    //

    RegCloseKey(hRegistryKey);

    //
    // We are ready
    //

    m_fDebugInitialized = TRUE;
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::DebugPrintf(const DWORD dwMsgType, const DWORD dwLineNumber, LPCSTR szFilename, const TCHAR * szFormat, ...)
{
  va_list     sVariableList;
  DWORD       dwProcessId, dwThreadId;
  SYSTEMTIME  sSystemTime;
  CHAR        szHeader[512];
  CHAR        szBaseMessage[512];
  CHAR        szIntermediateString[1024];
  CHAR        szOutputString[1024];

  //
  // Initialize the debug spew
  //

  if (!m_fDebugInitialized)
  {
    InitDebug();
    m_fDebugInitialized = TRUE;
  }

  if (WAIT_TIMEOUT != WaitForSingleObject(m_MutexHandle, 1000))
  {

    //
    // Is this an internal message. If so, should we print it out
    //


    if (((0 == m_dwDebugInternal)&&(GetExternalMask(dwMsgType)))||(0 != m_dwDebugInternal))
    {
      if (m_dwDebugLevel >= GetLevel(dwMsgType))
      {
        if (m_dwSourceFlags & GetSourceMask(dwMsgType))
        {
          //
          // Build the main output message
          //

          va_start(sVariableList, szFormat);
          _vsnprintf(szBaseMessage, 512, szFormat, sVariableList);
          va_end(sVariableList);

          //
          // Build szTmpString
          //

          ZeroMemory(szHeader, sizeof(szHeader));
          memset(szHeader, 32, m_dwFunctionDepth * 2);
          szHeader[m_dwFunctionDepth * 2] = 0;
            
          switch(dwMsgType & DBG_LEVEL)
          {
            case DBG_ERROR
            : wsprintfA(szIntermediateString, "%s[  ERROR  ] %s", szHeader, szBaseMessage);
              break;

            case DBG_THROW
            : wsprintfA(szIntermediateString, "%s[  THROW  ] %s", szHeader, szBaseMessage);
              break;

            case DBG_CATCH
            : wsprintfA(szIntermediateString, "%s[  CATCH  ] %s", szHeader, szBaseMessage);
              break;

            case DBG_WARNING
            : wsprintfA(szIntermediateString, "%s[ WARNING ] %s", szHeader, szBaseMessage);
              break;

            case DBG_FUNCENTRY
            : wsprintfA(szIntermediateString, "%s[vvvv] %s", szHeader, szBaseMessage);
              m_dwFunctionDepth++;
              break;

            case DBG_FUNCEXIT
            : m_dwFunctionDepth--;
              ZeroMemory(szHeader, sizeof(szHeader));
              memset(szHeader, 32, m_dwFunctionDepth * 2);
              szHeader[m_dwFunctionDepth * 2] = 0;
              wsprintfA(szIntermediateString, "%s[^^^^] %s", szHeader, szBaseMessage);
              break;

            case DBG_CONSTRUCTOR
            : wsprintfA(szIntermediateString, "%s[ CONSTRUCTOR ] %s", szHeader, szBaseMessage);
              m_dwFunctionDepth++;
              break;

            case DBG_DESTRUCTOR
            : m_dwFunctionDepth--;
              ZeroMemory(szHeader, sizeof(szHeader));
              memset(szHeader, 32, m_dwFunctionDepth * 2);
              szHeader[m_dwFunctionDepth * 2] = 0;
              wsprintfA(szIntermediateString, "%s[ DESTRUCTOR ] %s", szHeader, szBaseMessage);
              break;

            default
            : wsprintfA(szIntermediateString, "%s> %s", szHeader, szBaseMessage);
              break;
          }

          if (OP_OUTPUTTIMESTAMP & m_dwOperationalFlags)
          {
            if (OP_OUTPUTFILENAME & m_dwOperationalFlags)
            {
              if (OP_OUTPUTLINENUMBER & m_dwOperationalFlags)
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTLINENUMBER, OUTPUTFILENAME, OUTPUTTIMESTAMP
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[p%05d][t%05d] [Time %02d:%02d:%02d:%02d %02d-%02d-%04d] File %032s Line %05d %s\r\n", dwProcessId, dwThreadId, sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szFilename, dwLineNumber, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTLINENUMBER, OUTPUTFILENAME, OUTPUTTIMESTAMP
                  //

                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[Time %02d:%02d:%02d:%02d %02d-%02d-%04d] File %032s Line %05d %s\r\n", sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szFilename, dwLineNumber, szIntermediateString);
                }
              }
              else
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTFILENAME, OUTPUTTIMESTAMP
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[p%05d][t%05d] [Time %02d:%02d:%02d:%02d %02d-%02d-%04d] File %032s %s\r\n", dwProcessId, dwThreadId, sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szFilename, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTFILENAME, OUTPUTTIMESTAMP
                  //

                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[Time %02d:%02d:%02d:%02d %02d-%02d-%04d] File %032s %s\r\n", sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szFilename, szIntermediateString);
                }
              }
            }
            else
            {
              if (OP_OUTPUTLINENUMBER & m_dwOperationalFlags)
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTLINENUMBER, OUTPUTTIMESTAMP
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[p%05d][t%05d] [Time %02d:%02d:%02d:%02d %02d-%02d-%04d] Line %05d %s\r\n", dwProcessId, dwThreadId, sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, dwLineNumber, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTLINENUMBER, OUTPUTTIMESTAMP
                  //

                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[Time %02d:%02d:%02d:%02d %02d-%02d-%04d] Line %05d %s\r\n", sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, dwLineNumber, szIntermediateString);
                }
              }
              else
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTTIMESTAMP
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[p%05d][t%05d] [Time %02d:%02d:%02d:%02d %02d-%02d-%04d] %05d %s\r\n", dwProcessId, dwThreadId, sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTTIMESTAMP
                  //

                  GetLocalTime(&sSystemTime);
                  wsprintfA(szOutputString, "[Time %02d:%02d:%02d:%02d %02d-%02d-%04d] %s\r\n", sSystemTime.wHour, sSystemTime.wMinute, sSystemTime.wSecond, sSystemTime.wMilliseconds, sSystemTime.wMonth, sSystemTime.wDay, sSystemTime.wYear, szIntermediateString);
                }
              }
            }
          }
          else
          {
            if (OP_OUTPUTFILENAME & m_dwOperationalFlags)
            {
              if (OP_OUTPUTLINENUMBER & m_dwOperationalFlags)
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTLINENUMBER, OUTPUTFILENAME
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  wsprintfA(szOutputString, "[p%05d][t%05d] File %032s Line %05d %s\r\n", dwProcessId, dwThreadId, szFilename, dwLineNumber, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTLINENUMBER, OUTPUTFILENAME
                  //

                  wsprintfA(szOutputString, "File %032s Line %05d %s\r\n", szFilename, dwLineNumber, szIntermediateString);
                }
              }
              else
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTFILENAME
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  wsprintfA(szOutputString, "[p%05d][t%05d] File %032s %s\r\n", dwProcessId, dwThreadId, szFilename, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTFILENAME
                  //

                  wsprintfA(szOutputString, "File %032s %s\r\n", szFilename, szIntermediateString);
                }
              }
            }
            else
            {
              if (OP_OUTPUTLINENUMBER & m_dwOperationalFlags)
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID, OUTPUTLINENUMBER
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  wsprintfA(szOutputString, "[p%05d][t%05d] Line %05d %s\r\n", dwProcessId, dwThreadId, dwLineNumber, szIntermediateString);
                }
                else
                {
                  //
                  // OUTPUTLINENUMBER
                  //

                  wsprintfA(szOutputString, "Line %05d %s\r\n", dwLineNumber, szIntermediateString);
                }
              }
              else
              {
                if (OP_OUTPUTPTID & m_dwOperationalFlags)
                {
                  //
                  // OUTPUTPTID
                  //

                  dwProcessId = GetCurrentProcessId();
                  dwThreadId = GetCurrentThreadId();
                  wsprintfA(szOutputString, "[p%05d][t%05d] %s\r\n", dwProcessId, dwThreadId, szIntermediateString);
                }
                else
                {
                  //
                  // NONE
                  //

                  wsprintfA(szOutputString, "%s\r\n", szIntermediateString);
                }
              }
            }
          }

          //
          // Should we output to file
          //

          if (_CRTDBG_MODE_FILE & m_dwReportMode)
          {
            HANDLE  hFileHandle;
            DWORD   dwBytesWritten;

            hFileHandle = CreateFile(m_szOutputFilename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE != hFileHandle)
            {
              SetFilePointer(hFileHandle, 0, NULL, FILE_END);
              WriteFile(hFileHandle, szOutputString, strlen(szOutputString), &dwBytesWritten, NULL);
              CloseHandle(hFileHandle);
            }
          }

          //
          // Should we output to the debug window
          //

          if ((_CRTDBG_MODE_DEBUG | _CRTDBG_MODE_WNDW) & m_dwReportMode)
          {
            OutputDebugString(szOutputString);
          }
        }
      }
    }

    //
    // Release the mutex
    //

    ReleaseMutex(m_MutexHandle);
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::DebugPrintfW(const DWORD dwMsgType, const DWORD dwLineNumber, LPCSTR szFilename, const wchar_t * wszFormat, ...)
{
  CWin32API oWin32API;
  va_list   sVariableList;
  WCHAR     wszMessage[512];
  CHAR      szMessage[512];

  va_start(sVariableList, wszFormat);
  _vsnwprintf(wszMessage, 512, wszFormat, sVariableList);
  oWin32API.WideCharToMultiByte(wszMessage, 512, szMessage, 512);
  va_end(sVariableList);

  DebugPrintf(dwMsgType, dwLineNumber, szFilename, szMessage);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::SetSourceFlags(const DWORD dwFilter)
{
  m_dwSourceFlags = dwFilter;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::SetOperationalFlags(const DWORD dwOperationalFlags)
{
  m_dwOperationalFlags = dwOperationalFlags;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::SetOutputFilename(LPCSTR szFilename)
{
  wsprintfA(m_szOutputFilename, szFilename);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CAppManDebugHandler::GetSourceFlags(void)
{
  return m_dwSourceFlags;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CAppManDebugHandler::GetOperationalFlags(void)
{
  return m_dwOperationalFlags;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void CAppManDebugHandler::GetOutputFilename(LPSTR szFilename)
{
  wsprintfA(szFilename, m_szOutputFilename);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAutoTrace::CAutoTrace(DWORD dwModule, LPSTR lpFunctionName, INT iLine, LPSTR  lpFileName)
{
  //
  // Save the function name
  //

  m_dwModule = dwModule;
  strncpy(m_szFunctionName, lpFunctionName, MAX_PATH_CHARCOUNT);
  strncpy(m_szFilename, lpFileName, MAX_PATH_CHARCOUNT);
  g_oDebugHandler.DebugPrintf(m_dwModule | DBG_FUNCENTRY, iLine, m_szFilename, m_szFunctionName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAutoTrace::~CAutoTrace(void)
{
  g_oDebugHandler.DebugPrintf(m_dwModule | DBG_FUNCEXIT, NULL, m_szFilename, m_szFunctionName);
}

#endif // _TRACEON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\appmandebug.h ===
#ifndef __APPMAN_DEBUG_
#define __APPMAN_DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <stdio.h>
#include <crtdbg.h>
#include <tchar.h>
#include "Win32API.h"
#include "AppMan.h"

#define REGPATH_APPMAN  _T("Software\\Microsoft\\AppMan")

#ifdef _DEBUG
#define _TRACEON                  TRUE
#else
#define _TRACEON                  FALSE
#endif

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Make sure to define the different trace message types
//
//////////////////////////////////////////////////////////////////////////////////////////////

// 0: Error useful for application developers.
// 1: Warning useful for application developers.
// 2: API Entered
// 3: API parameters, API return values
// 4: Driver conversation
//
// 5: Deeper program flow notifications
// 6: Dump structures 

//
// Debug Level
//

#define DBGLVL_ERROR              0
#define DBGLVL_WARNING            1
#define DBGLVL_APIENTRY           2
#define DBGLVL_APIPARAMS          3
#define DBGLVL_DRIVER             4
#define DBGLVL_INTERNAL           5
#define DBGLVL_DUMPSTRUCTS        6

//
// Debug Type (Not set in Registry)
//

#define DBG_ERROR                 0x00000001  // Maps to Level 0
#define DBG_THROW                 0x00000002  // Maps to Level 0
#define DBG_CATCH                 0x00000004  // Maps to Level 0
#define DBG_WARNING               0x00000008  // Maps to Level 1
#define DBG_FUNCENTRY             0x00000010  // Maps to Level 2
#define DBG_FUNCEXIT              0x00000020  // Maps to Level 2
#define DBG_CONSTRUCTOR           0x00000040  // Maps to Level 2
#define DBG_DESTRUCTOR            0x00000080  // Maps to Level 2
#define DBG_MSG                   0x00000100  // Maps to Level 5
#define DBG_EXTERNAL              0x00000200

#define DBG_LEVEL                 (DBG_ERROR | DBG_THROW | DBG_CATCH | DBG_WARNING | DBG_FUNCENTRY | DBG_FUNCEXIT | DBG_CONSTRUCTOR | DBG_DESTRUCTOR | DBG_MSG | DBG_EXTERNAL)
#define DBG_ENTRY                 (DBG_FUNCENTRY | DBG_FUNCEXIT | DBG_CONSTRUCTOR | DBG_DESTRUCTOR)

//
// Debug Sources Flags
//

#define DBG_APPENTRY              0x00001000
#define DBG_APPMAN                0x00002000
#define DBG_APPMANROOT            0x00008000
#define DBG_APPMANADMIN           0x00004000
#define DBG_LOCK                  0x00010000
#define DBG_EXCEPTION             0x00020000
#define DBG_FAPPMAN               0x00040000
#define DBG_INFOMAN               0x00080000
#define DBG_REGISTRY              0x00100000
#define DBG_WIN32                 0x00400000
#define DBG_EMPTYVOLUMECACHE      0x00800000
#define DBG_WAITEVENT             0x01000000
#define DBG_APPMANDP              0x02000000

#define DBG_ALL_MODULES           (DBG_APPENTRY | DBG_APPMAN | DBG_APPMANROOT | DBG_APPMANADMIN | DBG_LOCK | DBG_EXCEPTION | DBG_FAPPMAN | DBG_INFOMAN | DBG_REGISTRY | DBG_WIN32 | DBG_EMPTYVOLUMECACHE | DBG_WAITEVENT | DBG_APPMANDP)
#define DBG_STD_MODULES           (DBG_APPENTRY | DBG_APPMAN | DBG_APPMANADMIN | DBG_FAPPMAN | DBG_INFOMAN | DBG_WAITEVENT)

//
// Debug Operations Flags
//

#define OP_NOTHING                0x00000000
#define OP_OUTPUTPARAMETERS       0x00000001
#define OP_OUTPUTTIMESTAMP        0x00000002
#define OP_OUTPUTFILENAME         0x00000004
#define OP_OUTPUTLINENUMBER       0x00000008
#define OP_OUTPUTPTID			        0x00000010
#define OP_OUTPUTMODULENAME       0x00000020
#define OP_OUTPUTINDENT           0x00000040

//
// Debug Report Mode (Not set in Registry)
//

#define DBGMODE_FILE             _CRTDBG_MODE_FILE   //0x1
#define DBGMODE_DBGR             _CRTDBG_MODE_DEBUG  //0x2
#define DBGMODE_WNDW             _CRTDBG_MODE_WNDW   //0x4

#define DBG_MODULE                0x00000000    //By default, have all off.

#if _TRACEON == TRUE

#define PROF_SECT_APPMAN          "ApplicationManager"

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Define the CAppManDebugHandler class
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CAppManDebugHandler
{
  public :

    CAppManDebugHandler(void);
    ~CAppManDebugHandler(void);

    void    DebugPrintf(const DWORD dwMsgType, const DWORD dwLineNumber, LPCSTR szFilename, const TCHAR * szFormat, ...);
    void    DebugPrintfW(const DWORD dwMsgType, const DWORD dwLineNumber, LPCSTR szFilename, const wchar_t * wszFormat, ...);
    BOOL    DebugAccessTest(void);
    void    InitDebug(void);
    void    SetSourceFlags(const DWORD dwFilter);
    void    SetOperationalFlags(const DWORD dwOperationalFlags);
    void    SetOutputFilename(LPCSTR szFilename);
    DWORD   GetSourceFlags(void);
    DWORD   GetOperationalFlags(void);
    void    GetOutputFilename(LPSTR szFilename);


  private :

    HANDLE       m_MutexHandle;
    DWORD        m_dwReportMode;				                                  
    DWORD        m_dwOperationalFlags;
    DWORD        m_dwSourceFlags;
    DWORD        m_dwFunctionDepth;
    DWORD        m_dwDebugLevel;
    DWORD        m_dwDebugInternal;
    CHAR         m_szOutputFilename[MAX_PATH_CHARCOUNT];
    BOOL         m_fDebugInitialized; 
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Define the CAutoTrace class. This class is use to track function entry and exit
// automatically
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CAutoTrace
{
  public :

    CAutoTrace(DWORD dwModule, LPSTR lpFunctionName, INT iLine, LPSTR lpFileName);
    ~CAutoTrace(void);

  private :

    char    m_szFunctionName[MAX_PATH_CHARCOUNT];
    char    m_szFilename[MAX_PATH_CHARCOUNT];
	  DWORD   m_dwModule;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Share some global variables
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern CAppManDebugHandler g_oDebugHandler;
extern CHAR                g_szDebugString[256];

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Share some global functions
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern CHAR * MakeDebugString(const CHAR * szFormat, ...);

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

#define FUNCTION(a)            CAutoTrace  sAutoTrace(DBG_MODULE, (a), __LINE__, __FILE__)
#define TRACE(a,b)             g_oDebugHandler.DebugPrintf((a) | DBG_MSG, __LINE__, __FILE__, (b))
#define THROWEXCEPTION(a)      g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_THROW, __LINE__, __FILE__, "EXCEPTION: Severity= 0x%08x", (a))

#define DPF                    g_oDebugHandler.DebugPrintf
#define DPFW                   g_oDebugHandler.DebugPrintfW

#define DPFMSG(a)              g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_MSG, __LINE__, __FILE__, (a))
#define DPFERR(a)              g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_ERROR, __LINE__, __FILE__, (a))
#define DPFWARN(a)             g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_WARNING, __LINE__, __FILE__, (a))

#define DPFCONSTRUCTOR(a)      g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_CONSTRUCTOR, __LINE__, __FILE__, (a))
#define DPFDESTRUCTOR(a)       g_oDebugHandler.DebugPrintf(DBG_MODULE | DBG_DESTRUCTOR, __LINE__, __FILE__, (a))

#else

#define FUNCTION(a)  
#define TRACE(a, b)  
#define THROWEXCEPTION(a)

#define DPF     
#define DPFW  

#define DPFMSG(a)    
#define DPFERR(a)    
#define DPFWARN(a)   
    
#define DPFCONSTRUCTOR(a)   
#define DPFDESTRUCTOR(a)   

#endif  // _TRACEON

#ifdef __cplusplus
}
#endif

#endif  // __APPMAN_DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\apppropertyrules.h ===
#ifndef __APP_PROPERTY_RULES_
#define __APP_PROPERTY_RULES_

#ifndef __cplusplus
extern "C" {
#endif

#include <windows.h>

//
// Property index defines
//

#define IDX_PROPERTY_GUID                         0x00000000
#define IDX_PROPERTY_COMPANYNAME                  0x00000001
#define IDX_PROPERTY_SIGNATURE                    0x00000002
#define IDX_PROPERTY_VERSIONSTRING                0x00000003
#define IDX_PROPERTY_ROOTPATH                     0x00000004
#define IDX_PROPERTY_SETUPROOTPATH                0x00000005
#define IDX_PROPERTY_STATE                        0x00000006
#define IDX_PROPERTY_CATEGORY                     0x00000007
#define IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES    0x00000008
#define IDX_PROPERTY_NONREMOVABLEKILOBYTES        0x00000009
#define IDX_PROPERTY_REMOVABLEKILOBYTES           0x0000000a
#define IDX_PROPERTY_EXECUTECMDLINE               0x0000000b
#define IDX_PROPERTY_DOWNSIZECMDLINE              0x0000000c
#define IDX_PROPERTY_REINSTALLCMDLINE             0x0000000d
#define IDX_PROPERTY_UNINSTALLCMDLINE             0x0000000e
#define IDX_PROPERTY_SELFTESTCMDLINE              0x0000000f
#define IDX_PROPERTY_INSTALLDATE                  0x00000010
#define IDX_PROPERTY_LASTUSEDDATE                 0x00000011
#define IDX_PROPERTY_TITLEURL                     0x00000012
#define IDX_PROPERTY_PUBLISHERURL                 0x00000013
#define IDX_PROPERTY_DEVELOPERURL                 0x00000014
#define IDX_PROPERTY_PIN                          0x00000015
#define IDX_PROPERTY_DEVICEGUID                   0x00000016
#define IDX_PROPERTY_XMLINFOFILE                  0x00000017
#define IDX_PROPERTY_DEFAULTSETUPEXECMDLINE       0x00000018

#define PROPERTY_COUNT                            0x00000019
#define INVALID_PROPERTY_INDEX                    0xffffffff

//
// Property string IDs
//

#define APP_STRING_NONE                           0xffffffff
#define APP_STRING_CRYPTO                         0x00000000
#define APP_STRING_COMPANYNAME                    0x00000001
#define APP_STRING_SIGNATURE                      0x00000002
#define APP_STRING_VERSION                        0x00000003
#define APP_STRING_APPROOTPATH                    0x00000004
#define APP_STRING_SETUPROOTPATH                  0x00000005
#define APP_STRING_DOCROOTPATH                    0x00000006
#define APP_STRING_EXECUTECMDLINE                 0x00000007
#define APP_STRING_PATCHCMDLINE                   0x00000008
#define APP_STRING_DOWNSIZECMDLINE                0x00000009
#define APP_STRING_REINSTALLCMDLINE               0x0000000a
#define APP_STRING_UNINSTALLCMDLINE               0x0000000b
#define APP_STRING_SELFTESTCMDLINE                0x0000000c
#define APP_STRING_TITLEURL                       0x0000000d
#define APP_STRING_PUBLISHERURL                   0x0000000e
#define APP_STRING_DEVELOPERURL                   0x0000000f
#define APP_STRING_XMLINFOFILE                    0x00000010
#define APP_STRING_DEFAULTSETUPEXECMDLINE         0x00000011

#define APP_STRING_COUNT                          0x00000012

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwProperty;
  DWORD             dwLowPropertyMask;
  DWORD             dwHighPropertyMask;
  DWORD             dwWriteMask;
  DWORD             dwReadMask;
  DWORD             dwMaxLen;
  DWORD             dwStringId;

} PROPERTY_INFO, *LPPROPERTY_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

extern PROPERTY_INFO gPropertyInfo[PROPERTY_COUNT];

//////////////////////////////////////////////////////////////////////////////////////////////

extern void InitializePropertyRules(void);

//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __cplusplus
}
#endif

#endif  // __APP_PROPERTY_RULES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\criticalsection.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// CriticalSection.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of CCriticalSection
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include "CriticalSection.h"
#include "ExceptionHandler.h"
#include "AppManDebug.h"

//To flag as DBG_LOCK
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_LOCK

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CCriticalSection::CCriticalSection(void)
{
  FUNCTION("CCriticalSection::CCriticalSection (void)");

  m_lLockCount = 0;
  m_hAccessMutex = NULL;
  m_fCreator = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CCriticalSection::~CCriticalSection(void)
{
  FUNCTION("CCriticalSection::~CCriticalSection (void)");

  Shutdown();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Initialize(void)
{
  FUNCTION("CCriticalSection::Initialize ()");

  if (NULL != m_hAccessMutex)
  {
    Shutdown();
  }
  
  if (NULL == m_hAccessMutex)
  {
    m_lLockCount = 0;
    m_hAccessMutex = CreateMutex(NULL, FALSE, NULL);
    if (NULL == m_hAccessMutex)
    {
      THROW(E_UNEXPECTED);
    }
    m_fCreator = TRUE;
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Initialize(const BOOL fOwner)
{
  FUNCTION("CCriticalSection::Initialize ()");

  if (NULL != m_hAccessMutex)
  {
    Shutdown();
  }

  if (NULL == m_hAccessMutex)
  {
    //
    // Please note that since this is not a named mutex object, we are guaranteed to create
    // it if the memory is available
    //

    m_lLockCount = 0;
    m_hAccessMutex = CreateMutex(NULL, fOwner, NULL);
    if (NULL == m_hAccessMutex)
    {
      THROW(E_UNEXPECTED);
    }
    m_fCreator = TRUE;

    if (fOwner)
    {
      InterlockedIncrement(&m_lLockCount);
    }
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Initialize(const BOOL fOwner, const CHAR * pName)
{
  FUNCTION("CCriticalSection::Initialize ()");

  if (NULL != m_hAccessMutex)
  {
    Shutdown();
  }

  if (NULL == m_hAccessMutex)
  {
    m_lLockCount = 0;
    m_hAccessMutex = CreateMutex(NULL, fOwner, pName);
    if (NULL == m_hAccessMutex)
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Use GetLastError() to define whether or not the call to CreateMutex() actually created
    // a new mutex object or simply returned the handle of an existing mutex object
    //

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
      m_fCreator = FALSE;
    }
    else
    {
      m_fCreator = TRUE;
    }

    //
    // Since it is possible for this named mutex to have been created prior, we must check
    // to see if we created it or simply copied it. If we copied it and TRUE == fOwner, then
    // we will not have ownership of the mutex and henceforth must call Enter() before
    // returning
    //

    if (fOwner)
    {
      if (!m_fCreator)
      {
        return Enter();
      }
      else
      {
        InterlockedIncrement(&m_lLockCount);
      }
    }
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Shutdown(void)
{
  FUNCTION("CCriticalSection::Shutdown ()");

  //
  // If the m_hAccessMutex handle was successfully created, we need to make sure that
  // we release all lock instances associated with this object is we own the lock
  //

  if (NULL != m_hAccessMutex)
  {
    while (0 < m_lLockCount)
    {
      ReleaseMutex(m_hAccessMutex);
      m_lLockCount--;
    } 

    CloseHandle(m_hAccessMutex);
    m_hAccessMutex = NULL;
  }

  m_lLockCount = 0;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::IsInitialized(void)
{
  FUNCTION("CCriticalSection::IsInitialized ()");

  if (NULL == m_hAccessMutex)
  {
    return S_FALSE;
  }
  
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::IsCreator(void)
{
  FUNCTION("CCriticalSection::IsCreator ()");

  if (!m_fCreator)
  {
    return S_FALSE;
  }
  
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(DWORD) CCriticalSection::GetLockCount(void)
{
  FUNCTION("CCriticalSection::GetLockCount ()");

  LONG  lLockCount;

  lLockCount = InterlockedExchange(&m_lLockCount, m_lLockCount);
  if (0 > lLockCount)
  {
    THROW(E_UNEXPECTED);
  }

  return (DWORD) lLockCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Enter(void)
{
  FUNCTION("CCriticalSection::Enter ()");

  if (NULL == m_hAccessMutex)
  {
    THROW(E_UNEXPECTED);
  }

  if (WAIT_TIMEOUT == WaitForSingleObject(m_hAccessMutex, TEN_SECONDS))
  {
    THROW(E_UNEXPECTED);
  }

  InterlockedIncrement(&m_lLockCount);
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Enter(const DWORD dwWaitTime)
{
  FUNCTION("CCriticalSection::Enter ()");

  if (NULL == m_hAccessMutex)
  {
    THROW(E_UNEXPECTED);
  }

  if (WAIT_TIMEOUT == WaitForSingleObject(m_hAccessMutex, dwWaitTime))
  {
    return S_FALSE;
  }

  InterlockedIncrement(&m_lLockCount);
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// NOTE : This function can never fail. It will always return CSECTION_S_OK
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CCriticalSection::Leave(void)
{
  FUNCTION("CCriticalSection::Leave ()");

  if (NULL == m_hAccessMutex)
  {
    THROW(E_UNEXPECTED);
  }

  //
  // If the lock count is greater than 0, release the mutex and decrement the lock count
  //

  if (0 < GetLockCount())
  {
    InterlockedDecrement(&m_lLockCount);
    if (!ReleaseMutex(m_hAccessMutex))
    {
      THROW(E_UNEXPECTED);
    }
  
    return S_OK;
  }

  return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\exceptionhandler.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ExceptionHandler.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the definition of CAppManExceptionHandler
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __EXCEPTIONHANDLER_
#define __EXCEPTIONHANDLER_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <objbase.h>
#include "AppManDebug.h"

#ifdef _DEBUG
#define THROW(a)            { THROWEXCEPTION((a)); throw (new CAppManExceptionHandler((a), __FILE__, __LINE__)); }
#else
#define THROW(a)            throw (new CAppManExceptionHandler((a), __FILE__, __LINE__))
#endif

#define MAX_FILENAME_LEN    64

class CAppManExceptionHandler
{
  public :

    CAppManExceptionHandler(void);
    CAppManExceptionHandler(HRESULT hResult, LPCSTR lpFilename, const DWORD dwLineNumber);
    virtual ~CAppManExceptionHandler(void);

    STDMETHOD (GetResultCode) (void);

  private :

    HRESULT   m_hResult;
};

#ifdef __cplusplus
}
#endif

#endif  // __EXCEPTIONHANDLER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\criticalsection.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// CriticalSection.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//  This include files supports the CCriticalSection class object. 
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __CRITICALSECTION_
#define __CRITICALSECTION_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <objbase.h>

//////////////////////////////////////////////////////////////////////////////////////////////

#define TEN_SECONDS                     10000

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CCriticalSection
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CCriticalSection  
{

  public:

	  CCriticalSection(void);
	  virtual ~CCriticalSection(void);

    STDMETHOD (Initialize) (void);
    STDMETHOD (Initialize) (const BOOL fOwner);
    STDMETHOD (Initialize) (const BOOL fOwner, const CHAR * pName);
	  STDMETHOD (Shutdown) (void);
    STDMETHOD (IsCreator) (void);
    STDMETHOD (IsInitialized) (void);
    STDMETHOD_(DWORD, GetLockCount) (THIS);
    STDMETHOD (Enter) (void);
    STDMETHOD (Enter) (const DWORD dwWaitTimer);
    STDMETHOD (Leave) (void);

  private:

	  LONG      m_lLockCount;
    HANDLE    m_hAccessMutex;
    BOOL      m_fCreator;
};

#ifdef __cplusplus
}
#endif

#endif  // __CRITICALSECTION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\exceptionhandler.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// ExceptionHandler.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of CAppManExceptionHandler
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "ExceptionHandler.h"
#include "AppManDebug.h"

//To flag as DBG_EXCEPTION
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_EXCEPTION

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManExceptionHandler::CAppManExceptionHandler(void)
{
  FUNCTION("CAppManExceptionHandler::CAppManExceptionHandler (void)");

  m_hResult = E_UNEXPECTED;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManExceptionHandler::CAppManExceptionHandler(HRESULT hResult, LPCSTR /*lpFilename*/, const DWORD /*dwLineNumber*/)      // Get rid of /W4 warning.
{
  FUNCTION("CAppManExceptionHandler::CAppManExceptionHandler (HRESULT hResult, LPCSTR lpFilename, const DWORD dwLineNumber)");

  m_hResult = hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManExceptionHandler::~CAppManExceptionHandler(void)
{
  FUNCTION("CAppManExceptionHandler::~CAppManExceptionHandler (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManExceptionHandler::GetResultCode(void)
{
  FUNCTION("CAppManExceptionHandler::GetResultCode ()");

  return m_hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\fapplicationmanager.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// FApplicationManager.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//  This file contains the class definition for the Windows Game Manager class factory.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __CFApplicationManager_
#define __CFApplicationManager_

#include <windows.h>
#include <objbase.h>

#undef EXPORT
#ifdef  WIN32
#define EXPORT __declspec(dllexport)
#else
#define EXPORT __export
#endif


#define REGPATH_APPMAN  _T("Software\\Microsoft\\AppMan")


//////////////////////////////////////////////////////////////////////////////////////////////
//
// This is the class factory for the WindowsGameManager object. 
//
// publicly inherits from :
//
//   IClassFactory
//
// public members :
//
//   QueryInterface()
//   AddRef()
//   Release()
//   CreateInstance()
//   LockServer()
//
// private members :
//
//   DWORD m_dwReferenceCount
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CFApplicationManager : public IClassFactory
{
	public :

		CFApplicationManager(void);
		~CFApplicationManager(void);

		STDMETHOD (QueryInterface) (REFIID RefIID, void ** lppVoidObject);
		STDMETHOD_(ULONG, AddRef) (void);
		STDMETHOD_(ULONG, Release) (void);
		STDMETHOD (CreateInstance) (IUnknown * lpoParent, REFIID RefIID, LPVOID * lppVoidObject);
		STDMETHOD (LockServer) (BOOL fLock);

	private :

		LONG      m_lReferenceCount;
};

#endif	// __CFApplicationManager_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\fapplicationmanager.cpp ===
/////7/////////////////////////////////////////////////////////////////////////////////////////
//
// FApplicationManager.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the class factory for the Windows Game Manager
//
// History :
//
//   05/06/1999 luish     Created
//    4/09/2000 RichGr    LoadDebugRuntime Registry setting delegates calls to Debug dll. 
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <objbase.h>
#include <verinfo.h>
#include <string.h>
#include <tchar.h>
#include "FApplicationManager.h"
#include "ApplicationManager.h"
#include "RegistryKey.h"
#include "Win32API.h"
#include "AppManDebug.h"
#include "Global.h"
#include "StructIdentifiers.h"
#include "ExceptionHandler.h"

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_FAPPMAN
                                             
HANDLE              g_hModule;
LONG                g_lDLLReferenceCount = 0;
HINSTANCE           g_hDebugDLL;
LPFNGETCLASSOBJECT  g_pfnDllGetClassObject = NULL;
BOOL                g_bUseDebugRuntime = FALSE;

#ifndef DX_FINAL_RELEASE
// Handy variable when debugging. 
#ifdef _DEBUG
BOOL    g_bThisIsDebugBuild = TRUE;
#else
BOOL    g_bThisIsDebugBuild = FALSE;
#endif

#define  APPMAN_RETAIL_FILENAME   _T("AppMan.dll")    
#define  APPMAN_DEBUG_FILENAME    _T("AppManD.dll")
#endif  // DX_FINAL_RELEASE


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllMain(HANDLE hModule, DWORD dwReason, LPVOID /*lpReserved*/)
{
  FUNCTION(" ::DllMain()");

  HRESULT   hResult = S_OK;

  ////////////////////////////////////////////////////////////////////////////////////////////

  try
  {
    TCHAR   szFileAndPath[MAX_PATH] = {0};
    DWORD   dwLen = 0;
    TCHAR  *pszFile = NULL;
    HKEY    hKey = 0;

    //
    // Save the module handle. This is used to extract resources
    //

    g_hModule = hModule;

#ifndef _DEBUG

    if (dwReason == DLL_PROCESS_ATTACH)
    {
      //
      // Retail code
      //
      // Make sure we are in APPMAN_RETAIL_FILENAME - we don't want to recursively LoadLibrary(APPMAN_DEBUG_FILENAME)
      // if someone renamed the dlls or the dlls built incorrectly.
      //

      g_bUseDebugRuntime = FALSE;
      dwLen = GetModuleFileName((HMODULE) hModule, &szFileAndPath[0], sizeof(szFileAndPath));
      if (0 < dwLen)
      {
        //
        // Find the position of the last '\'.  This precedes the filename.
        //

        pszFile = _tcsrchr(szFileAndPath, _T('\\'));

        if (NULL != pszFile)
        {
          pszFile += 1;

          //
          // Is module name valid?  Exit with error if not.
          //

          if (0 == _tcsnicmp(APPMAN_RETAIL_FILENAME, pszFile, MAX_PATH))
          {
            if ((!RegOpenKey(HKEY_LOCAL_MACHINE, REGPATH_APPMAN, &hKey))&&(hKey))
            {
              DWORD   type = 0;
              DWORD   dwLoadDebugRuntime;
              DWORD   cb = sizeof(dwLoadDebugRuntime);

              if (!RegQueryValueEx(hKey, _T("LoadDebugRuntime"), NULL, &type, (CONST LPBYTE)&dwLoadDebugRuntime, &cb))
              {
                if (dwLoadDebugRuntime)
                {
                  g_hDebugDLL = LoadLibrary(APPMAN_DEBUG_FILENAME);
                  if (NULL != g_hDebugDLL)
                  {
                    g_pfnDllGetClassObject = (LPFNGETCLASSOBJECT)GetProcAddress(g_hDebugDLL, "DllGetClassObject");
                    if (NULL != g_pfnDllGetClassObject)
                    {
                      g_bUseDebugRuntime = TRUE;
                    }
                    else
                    {
                      FreeLibrary(g_hDebugDLL);
                      g_hDebugDLL = NULL;
                    }
                  }
                }
              }

              //
              // Close the registry key
              //

              RegCloseKey(hKey);
            }
          }
        }
      }

      //
      // Time bomb this
      //

#ifndef DX_FINAL_RELEASE
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")

      if (FALSE == g_bUseDebugRuntime)
      {
        SYSTEMTIME sSystemTime;
        GetSystemTime(&sSystemTime);

        if ((sSystemTime.wYear > DX_EXPIRE_YEAR)||((sSystemTime.wYear == DX_EXPIRE_YEAR)&&(MAKELONG(sSystemTime.wDay, sSystemTime.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))))
        {
          MessageBox(0, DX_EXPIRE_TEXT, TEXT("Microsoft Application Manager"), MB_OK);
        }
      }

#endif  // DX_FINAL_RELEASE

    }
    else if (dwReason == DLL_PROCESS_DETACH && g_bUseDebugRuntime)
    {
      FreeLibrary(g_hDebugDLL);
      g_hDebugDLL = NULL;
    }

#else  // preprocessor #else...

    if (dwReason == DLL_PROCESS_ATTACH)
    {
      //
      // Debug code - AppManD.dll.
      // If we are debug, then spew a string at level 1
      //

#ifndef DX_FINAL_RELEASE
#pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")

      SYSTEMTIME sSystemTime;
      GetSystemTime(&sSystemTime);

      if ((sSystemTime.wYear > DX_EXPIRE_YEAR)||((sSystemTime.wYear == DX_EXPIRE_YEAR)&&(MAKELONG(sSystemTime.wDay, sSystemTime.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH))))
      {
        MessageBox(0, DX_EXPIRE_TEXT, TEXT("Microsoft Application Manager"), MB_OK);
      }

#endif  // DX_FINAL_RELEASE
    }

#endif

  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID ClassIDReference, REFIID RefIID, void ** lppVoidObject)
{
  FUNCTION(" ::DllGetClassObject ()");

  HRESULT   hResult = S_OK;

  ////////////////////////////////////////////////////////////////////////////////////////////
  try
  {
    LPCLASSFACTORY	pClassFactory;

    *lppVoidObject = NULL;

#ifndef _DEBUG

    //
    //  4/09/2000(RichGr): We want to delegate this call to the debug version if we've been asked to
    //     and everything's valid.
    //

    if (g_bUseDebugRuntime)
    {
      hResult = g_pfnDllGetClassObject(ClassIDReference, RefIID, lppVoidObject);

      return hResult; 
    }

#endif

	  //
	  // Make sure the ppVoidObject is not null
	  //

    if (NULL == lppVoidObject)
	  {
		  return E_INVALIDARG;
	  }

    *lppVoidObject = NULL;

	  //
    // Check to make sure that the proper CLSID is being specified
    //

    if (ClassIDReference != CLSID_ApplicationManager)
	  {
		  return CLASS_E_CLASSNOTAVAILABLE;
	  }

    //
    // Create the class factory
    //

    pClassFactory = (LPCLASSFACTORY) new CFApplicationManager;

	  if (NULL == pClassFactory)
	  {
		  return E_OUTOFMEMORY;
	  }

    //
    // Get the requested interface
    //

	  hResult = pClassFactory->QueryInterface(RefIID, lppVoidObject);
    pClassFactory->Release();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
  FUNCTION(" ::DllCanUnloadNow ()");

  if (g_lDLLReferenceCount)
	{
		return S_FALSE;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllRegisterServer(void)
{
  FUNCTION(" ::DllRegisterServer ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CRegistryKey                oRegistryKey;
    APPLICATION_MANAGER_RECORD  sApplicationManagerRecord;
    DWORD                       dwDisposition, dwDWORD;
    CHAR                        szString[MAX_PATH_CHARCOUNT];
    CHAR                        szDLLFileName[MAX_PATH_CHARCOUNT];

    //
    // Get the current windows directory
    //

    GetModuleFileNameA((HMODULE) g_hModule, szDLLFileName, MAX_PATH_CHARCOUNT);

    //
    // Register [HKEY_CLASSES_ROOT\CLSID\{79FF4730-235C-11d3-A76C-00C04F8F8B94}]
    //

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) "Application Manager", sizeof("Application Manager") + 1);
    wsprintfA(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.SetValue("AppID", REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);
  
    //
    // Register [HKEY_CLASSES_ROOT\CLSID\{79FF4730-235C-11d3-A76C-00C04F8F8B94}\InProcServer32]
    //

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\InprocServer32", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szDLLFileName, MAX_PATH_CHARCOUNT);
    oRegistryKey.SetValue("ThreadingModel", REG_SZ, (LPBYTE) "Apartment", sizeof("Apartment") + 1);

    //
    // Now add icon for the disk cleaner
    //

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\DefaultIcon", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString,szDLLFileName);
    strcat(szString,", 0"); 
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, sizeof(szString));

    //
    // Register [HKEY_CLASSES_ROOT\CLSID\{79FF4730-235C-11d3-A76C-00C04F8F8B94}\ProgID]
    //

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\ProgID", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString, "ApplicationManager.%d", GetAppManVersion());
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);

    //
    // Register [HKEY_CLASSES_ROOT\CLSID\{79FF4730-235C-11d3-A76C-00C04F8F8B94}\VersionIndependentProgID]
    //

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\VersionIndependentProgID", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) "ApplicationManager", sizeof("ApplicationManager") + 1);

    //
    // Register [HKEY_CLASSES_ROOT\ApplicationManager]
    //

    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, "ApplicationManager", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) "Application Manager", sizeof("Application Manager") + 1);

    //
    // Register [HKEY_CLASSES_ROOT\ApplicationManager\CLSID]
    //

    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CLSID", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);

    //
    // Register [HKEY_CLASSES_ROOT\ApplicationManager\CurVer]
    //

    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CurVer", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString, "ApplicationManager.%d", GetAppManVersion());
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);

    //
    // Register [HKEY_CLASSES_ROOT\ApplicationManager.%d]
    //

    wsprintfA(szString, "ApplicationManager.%d", GetAppManVersion());
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) "Application Manager", sizeof("Application Manager") + 1);

    //
    // Register [HKEY_CLASSES_ROOT\ApplicationManager.%d\CLSID]
    //

    wsprintfA(szString, "ApplicationManager.%d\\CLSID", GetAppManVersion());
    oRegistryKey.CreateKey(HKEY_CLASSES_ROOT, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);

    //
    // Register [HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Explorer/VolumeCaches/Delete Game Manager Files]
    //

    wsprintfA(szString, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\Delete Game Manager Files");
    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, FALSE, NULL);
    wsprintfA(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    oRegistryKey.SetValue(NULL, REG_SZ, (LPBYTE) szString, MAX_PATH_CHARCOUNT);
    DWORD dwDiskCleanerDayThreshold = DISKCLEANER_DAY_THRESHOLD;
    oRegistryKey.SetValue("DiskCleanerDayThreshold", REG_DWORD, (unsigned char *)&dwDiskCleanerDayThreshold, sizeof(DWORD));

    //
    // Open the root key if possible
    //

    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan"))
    {
      oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_ALL_ACCESS);

      //
      // Make sure the AppMan version is the right version
      //

      if (S_OK == oRegistryKey.CheckForExistingValue("AppManVersion"))
      {
        DWORD dwDataLen, dwDataValue, dwDataType;

        dwDataLen = sizeof(dwDataValue);
        oRegistryKey.GetValue("AppManVersion", &dwDataType, (BYTE *) &dwDataValue, &dwDataLen);
        if (REG_VERSION > dwDataValue)
        {
          oRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan");
        }
      }
    }

    //
    // Create the application manager registry keys
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Initialize the AppMan\Version value
    //

    dwDWORD = REG_VERSION;
    oRegistryKey.SetValue("AppManVersion", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));

    //
    // Initialize wait event extra wait vars
    //

    dwDWORD = 0;
    oRegistryKey.SetValue("WaitEntryEventExtraTime", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));

    dwDWORD = 0;
    oRegistryKey.SetValue("WaitLeaveEventExtraTime", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));

    //
    // Initialize the AppMan\DefaultCacheSize
    //

    dwDWORD = DEFAULT_PERCENT_CACHE_SIZE;
    oRegistryKey.SetValue("DefaultPercentCacheSize", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));

    //
    // Insert the original APPLICATION_MANAGER_RECORD
    //

    sApplicationManagerRecord.dwSize = sizeof(APPLICATION_MANAGER_RECORD);
    sApplicationManagerRecord.dwStructId = APPLICATION_MANAGER_STRUCT;
    if (FAILED(CoCreateGuid(&sApplicationManagerRecord.sSystemGuid)))
    {
      THROW(E_UNEXPECTED);
    }
    sApplicationManagerRecord.dwAdvancedMode = FALSE;
    oRegistryKey.SetValue("Vector000", REG_BINARY, (LPBYTE) &sApplicationManagerRecord, sizeof(APPLICATION_MANAGER_RECORD));

    //
    // Create the AppMan\Devices key.
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\Applications key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\Associations key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Associations", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\TempAllocation key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\TempSpaceAllocation", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\Cleanup key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Cleanup", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\Lock key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    //
    // Create the AppMan\Lock key
    //

    oRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwDisposition);

    oRegistryKey.CloseKey();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// TODO : Replace literal .1 with actual version number
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllUnregisterServer(void)
{
  FUNCTION(" ::DllUnregisterServer ()");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CRegistryKey  oRegistryKey;
	  CHAR          szString[MAX_PATH_CHARCOUNT];

    //
    // Delete the registry keys
    //

    wsprintfA(szString, "ApplicationManager.%d\\CLSID", GetAppManVersion());
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    wsprintfA(szString, "ApplicationManager.%d", GetAppManVersion());
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CurVer"))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CurVer");
    }

    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CLSID"))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, "ApplicationManager\\CLSID");
    }

    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, "ApplicationManager"))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, "ApplicationManager");
    }

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\VersionIndependentProgID", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\ProgID", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\InprocServer32", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    wsprintfA(szString, "CLSID\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", CLSID_ApplicationManager.Data1, CLSID_ApplicationManager.Data2, CLSID_ApplicationManager.Data3, CLSID_ApplicationManager.Data4[0], CLSID_ApplicationManager.Data4[1], CLSID_ApplicationManager.Data4[2], CLSID_ApplicationManager.Data4[3], CLSID_ApplicationManager.Data4[4], CLSID_ApplicationManager.Data4[5], CLSID_ApplicationManager.Data4[6], CLSID_ApplicationManager.Data4[7]);
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_CLASSES_ROOT, szString))
    {
      oRegistryKey.DeleteKey(HKEY_CLASSES_ROOT, szString);
    }

    wsprintfA(szString, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\Delete Game Manager Files");
    if (S_OK == oRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, szString))
    {
      oRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, szString);
    }

    //
    // Close oRegistryKey
    //

    oRegistryKey.CloseKey();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CFApplicationManager::CFApplicationManager(void)
{
  FUNCTION("CFApplicationManager::CFApplicationManager (void)");

  m_lReferenceCount = 1;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CFApplicationManager::~CFApplicationManager(void)
{
  FUNCTION("CFApplicationManager::~CFApplicationManager (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFApplicationManager::QueryInterface(REFIID RefIID, void ** lppVoidObject)
{
  FUNCTION("CFApplicationManager::QueryInterface ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    //
	  // Check to make sure that &RefIID is not null
	  //

    if (NULL == &RefIID)
    {
      return E_UNEXPECTED;
    }

	  //
	  // Check to make sure that ppVoidObject is not null
	  //

    if (NULL == lppVoidObject)
	  {
		  return E_INVALIDARG;
	  }

    *lppVoidObject = NULL;

    //
	  // Check for known interfaces
	  //

	  if (RefIID == IID_IUnknown)
	  {
		  *lppVoidObject = (LPVOID) this;
		  AddRef();
		  hResult = S_OK;
	  }
	  else
	  {
		  if (RefIID == IID_IClassFactory)
		  {
			  *lppVoidObject = (LPVOID) this;
			  AddRef();
			  hResult = S_OK;
		  }
		  else
		  {
			  hResult = E_NOINTERFACE;
		  }
	  }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CFApplicationManager::AddRef(void)
{
  FUNCTION("CFApplicationManager::AddRef ()");

	return InterlockedIncrement(&m_lReferenceCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CFApplicationManager::Release(void)
{
  FUNCTION("CFApplicationManager::Release ()");

  DWORD dwReferenceCount;

  dwReferenceCount = InterlockedDecrement(&m_lReferenceCount);
	if (0 == dwReferenceCount)
	{
		delete this;
	}

	return dwReferenceCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFApplicationManager::CreateInstance(IUnknown * lpoParent, REFIID RefIID, LPVOID * lppVoidObject)
{
  FUNCTION("CFApplicationManager::CreateInstance ()");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CApplicationManagerRoot * lpoApplicationManagerRoot;
	  IUnknown						    * lpoUnknownObject;

	  //
	  // Make sure no one is trying to aggregrate this interface
	  //

	  if (NULL != lpoParent)
	  {
		  return CLASS_E_NOAGGREGATION;
	  }

    //
    // Check that parameters are valid
    //

    if (NULL == lppVoidObject)
    {
      return E_INVALIDARG;
    }

	  //
	  // Ok, let's create a new CWindowsGameManager instance.
	  //

	  lpoApplicationManagerRoot = new CApplicationManagerRoot;
	  if (NULL == lpoApplicationManagerRoot)
	  {
		  return E_OUTOFMEMORY;
	  }
    else if (lpoApplicationManagerRoot->m_bInsufficientAccessToRun)
    {
        return E_ACCESSDENIED;
    }    

	  //
	  // Cast the CWindowsGameManager object to an IUnknown
	  //

	  lpoUnknownObject = (IUnknown *) lpoApplicationManagerRoot;

	  //
	  // Get an interface pointer for RefIID
	  //

	  hResult = lpoUnknownObject->QueryInterface(RefIID, lppVoidObject);
    lpoUnknownObject->Release();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFApplicationManager::LockServer(BOOL fLock)
{
  FUNCTION("CFApplicationManager::LockServer ()");

	if (TRUE == fLock)
	{
		InterlockedIncrement(&g_lDLLReferenceCount);
	}
	else
	{
		InterlockedDecrement(&g_lDLLReferenceCount);
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\emptyvolumecache.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// EmptyVolumeCache.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of IEmptyVolumeCache
//
// History :
//
//   10/12/1999 jchauvin/luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include "AppMan.h"
#include "AppManAdmin.h"
#include "emptyvc.h"
#include "resource.h"
#include "ApplicationManager.h"
#include "AppManDebug.h"
#include "ExceptionHandler.h"
#include "ExceptionHandler.h"
#include "Lock.h"
#include "StructIdentifiers.h"
#include "Global.h"
#include "RegistryKey.h"

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_EMPTYVOLUMECACHE

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CEmptyVolumeCache::CEmptyVolumeCache(void)
{
  FUNCTION("CEmptyVolumeCache::CEmptyVolumeCache (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CEmptyVolumeCache::CEmptyVolumeCache(CApplicationManagerRoot * lpParent)
{
  FUNCTION("CEmptyVolumeCache::CEmptyVolumeCache (CApplicationManagerRoot *pParent)");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    assert(NULL != lpParent);

    m_lpoParentObject = lpParent;
    m_oInformationManager.Initialize();
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CEmptyVolumeCache::~CEmptyVolumeCache(void)
{
  FUNCTION("CEmptyVolumeCache::~CEmptyVolumeCache (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::QueryInterface(REFIID RefIID, LPVOID * lppVoidObject)
{
  FUNCTION("CEmptyVolumeCache::QueryInterface (REFIID RefIID, LPVOID * lppVoidObject)");

	if (NULL == m_lpoParentObject)
  {
    return E_NOINTERFACE;
  }

	return m_lpoParentObject->QueryInterface(RefIID, lppVoidObject);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CEmptyVolumeCache::AddRef(void)
{
  FUNCTION("CEmptyVolumeCache::AddRef (void)");

  if (NULL != m_lpoParentObject)
  {
    return m_lpoParentObject->AddRef();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CEmptyVolumeCache::Release(void)
{
  FUNCTION("CEmptyVolumeCache::Release (void)");

  if (NULL != m_lpoParentObject)
  {
    return m_lpoParentObject->Release();
  }

	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::Initialize(HKEY /*hRegKey*/, LPCWSTR lpwszVolume, LPWSTR * lppwszDisplayName, LPWSTR * lppwszDescription, DWORD * lpdwFlags)
{
  FUNCTION("CEmptyVolumeCache::Initialize (HKEY hRegKey, LPCWSTR lpwszVolume, LPWSTR * lppwszDisplayName, LPWSTR * lppwszDescription, DWORD * lpdwFlags)");

  HRESULT hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    CRegistryKey  oRegistryKey;
    DWORD         dwSize;
    DWORD         dwType;
    CHAR          cBuffer[20];

    //
    // Now Get Day Threshold from Registry
    //

    oRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\Delete Game Manager Files", KEY_READ);
    dwSize = sizeof(cBuffer);
    hResult = oRegistryKey.GetValue("DiskCleanerDayThreshold", &dwType, (LPBYTE) cBuffer, &dwSize);
    m_dwDiskCleanerDayThreshold = *((LPDWORD) cBuffer);

    //
    // Check to make sure sub key exists and correct type and size, else use default
    //

	  if (FAILED(hResult)||(dwType != REG_DWORD)||(dwSize != sizeof(DWORD)))
	  {
		  m_dwDiskCleanerDayThreshold = DISKCLEANER_DAY_THRESHOLD;
	  } 

    //
    // Now convert Day Threshold into String
    //

	  _ltow(m_dwDiskCleanerDayThreshold, m_wszDiskCleanerDayTH, 10);

    //
	  // Break Strings into several parts for easier localization, and because string table is
	  // limited to 1024 per string
    //

	  GetResourceStringW(IDS_DISKCLEANERNAME1, m_wszDiskCleanerName, sizeof(m_wszDiskCleanerName));
	  GetResourceStringW(IDS_DISKCLEANERNAME2, m_wszDiskCleanerName2, sizeof(m_wszDiskCleanerName2));
	  wcscat(m_wszDiskCleanerName,m_wszDiskCleanerDayTH);  //Append Day Threshold
	  wcscat(m_wszDiskCleanerName,m_wszDiskCleanerName2);  //Append Rest of String;

	  GetResourceStringW(IDS_DISKCLEANERDESC1, m_wszDiskCleanerDesc, sizeof(m_wszDiskCleanerDesc));
	  GetResourceStringW(IDS_DISKCLEANERDESC2, m_wszDiskCleanerDesc2, sizeof(m_wszDiskCleanerDesc2));
	  wcscat(m_wszDiskCleanerDesc,m_wszDiskCleanerDayTH);  //Append Day Threshold
	  wcscat(m_wszDiskCleanerDesc,m_wszDiskCleanerDesc2);  //Append Rest of String;

	  *lppwszDisplayName = (LPWSTR) m_wszDiskCleanerName;
	  *lppwszDescription = (LPWSTR) m_wszDiskCleanerDesc;

    //	
		// Set Volume number and make sure we are not enabled by default.
    //

		m_dwVolume = VolumeStringToNumber(lpwszVolume);

    //
		// *pdwFlags = EVCF_DONTSHOWIFZERO | EVCF_ENABLEBYDEFAULT | EVCF_ENABLEBYDEFAULT_AUTO;
    //

		*lpdwFlags = EVCF_DONTSHOWIFZERO;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}
                                
//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::GetSpaceUsed(DWORDLONG * lpdwSpaceUsed, IEmptyVolumeCacheCallBack * lpCallBack)  
{
  FUNCTION("CEmptyVolumeCache::GetSpaceUsed(DWORDLONG * lpdwSpaceUsed, IEmptyVolumeCacheCallBack * lpCallBack)");

  HRESULT hResult = S_OK;

  try
  {
    DWORD       dwKilobytes;
    DWORDLONG   dwlSpaceUtilization;


	  GetSpaceUtilization(m_dwVolume, m_dwDiskCleanerDayThreshold, (LPDWORD) &dwKilobytes, lpCallBack);
	  dwlSpaceUtilization = (DWORDLONG)(dwKilobytes)*(DWORDLONG)1024;

	  (*lpdwSpaceUsed) = dwlSpaceUtilization;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}
    
                               
//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack * lpCallBack)
{

  FUNCTION("CEmptyVolumeCache::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack * lpCallBack)");

  HRESULT hResult = S_OK;
  
  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DWORD dwKilobytes;

	  dwKilobytes = (DWORD) (dwSpaceToFree / 1024);


	  hResult = CleanDisk(m_dwVolume, m_dwDiskCleanerDayThreshold, dwKilobytes, lpCallBack);

    if (FAILED(hResult))
    {
		  THROW(hResult);
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}
    
                                
//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::ShowProperties(HWND /*hwnd*/)  
{
  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CEmptyVolumeCache::Deactivate(DWORD * /*pdwFlags*/)  
{
  return S_OK;
}
                                                                                                                                                                                                                                             
//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEmptyVolumeCache::GetSpaceUtilization(DWORD dwDeviceIndex, DWORD dwDays, LPDWORD lpdwKilobytes, IEmptyVolumeCacheCallBack * lpCallBack)
{
  FUNCTION("CEmptyVolumeCache::GetSpaceUtilization(DWORD dwDeviceIndex, DWORD dwDays, LPDWORD lpdwKilobytes, IEmptyVolumeCacheCallBack * lpCallBack)");

  HRESULT   hResult = S_OK;
  DWORD     dwKilobytesAvailable = 0;

  ///////////////////////////////////////////////////////////////////////////////////////

  try 
  {
    DEVICE_RECORD       sDeviceRecord;
    APPLICATION_DATA    sApplicationData;
    DWORD               dwElapsedDays;
    SYSTEMTIME		      stLastUsedDate;

    //
	  // Record the initial state
	  //

    if (FAILED(m_oInformationManager.GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord)))
    {
      THROW(E_UNEXPECTED);
    }

	  //
	  // Go through each application to determine removable diskspace consumed by game apps 
	  // that have been last accessed over X days ago, where X = DiskCleanerDayThreshold value 
	  // from registry. These are candidates for downsizing.
	  // Note:  X default value = 120 days.  Also, pinned apps are not considered candidates for
	  // downsizing, regardless of age.
	  //

	  if (S_OK == m_oInformationManager.GetOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData))
	  {
		  do
		  {
        //
        // Get the age of the application
        //

        stLastUsedDate = sApplicationData.sAgingInfo.stLastUsedDate;
        dwElapsedDays = ElapsedDays(&stLastUsedDate);

        //
        // Determine amount that can be freed sApplicationRecord
        //

        if ((dwElapsedDays >= dwDays)&&(APP_CATEGORY_ENTERTAINMENT & sApplicationData.sBaseInfo.dwCategory)&&(sApplicationData.sBaseInfo.dwPinState == 0))
        {
          dwKilobytesAvailable += sApplicationData.sBaseInfo.dwRemovableKilobytes;
          hResult = lpCallBack->ScanProgress(dwKilobytesAvailable*1024, 0, NULL);

          if(FAILED(hResult))
          {
	          THROW(E_UNEXPECTED);
          }
        }
      }
      while ((dwElapsedDays >= dwDays)&&(S_OK == m_oInformationManager.GetNextOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData)));
    }

    //
	  // Now pass back the available kilobytes
    //

    *lpdwKilobytes = dwKilobytesAvailable;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

 	catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  hResult = lpCallBack->ScanProgress(dwKilobytesAvailable * 1024, EVCCBF_LASTNOTIFICATION, NULL);
 	if(FAILED(hResult))
  {
    hResult = E_UNEXPECTED;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEmptyVolumeCache::CleanDisk(DWORD dwDeviceIndex, DWORD dwDays, DWORD dwKilobytesToFree, IEmptyVolumeCacheCallBack * lpCallBack)
{
  FUNCTION("CEmptyVolumeCache::CleanDisk(DWORD dwDeviceIndex, DWORD dwDays, DWORD dwKilobytesToFree, IEmptyVolumeCacheCallBack * lpCallBack)");

  HRESULT   hResult = S_OK;

  ///////////////////////////////////////////////////////////////////////////////////////

  try
  {
    DEVICE_SPACE_INFO   sDeviceSpaceInfo;
    APPLICATION_DATA    sApplicationData;
    DWORD               dwKilobytesFreed;
    DWORD               dwElapsedDays;
    DWORDLONG           dwlMBFreed;
    DWORDLONG           dwlMBToFree;  
    SYSTEMTIME          stLastUsedDate;

    if (FAILED(m_oInformationManager.GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo)))
	  {
		  THROW(E_UNEXPECTED);
	  }

	  //
	  // Record the initial state
	  //

	  dwlMBToFree = dwKilobytesToFree * 1024;
	  dwlMBFreed = 0;

	  //
	  // Downsize removable diskspace consumed by game apps that have been last accessed over 
	  // X days ago, where X = DiskCleanerDayThreshold value from registry. 
	  // Note:  X default value = 120 days.  Also, pinned apps are not downsized, 
	  // regardless of age.
	  //

    if (S_OK == m_oInformationManager.GetOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData))
	  {
		  do
      {
        //
        // Get the age of the application
        //

        stLastUsedDate = sApplicationData.sAgingInfo.stLastUsedDate;
        dwElapsedDays = ElapsedDays(&stLastUsedDate);

        //
        // Determine amount that can be freed sApplicationRecord
        //

        if ((dwElapsedDays >= dwDays)&&(APP_CATEGORY_ENTERTAINMENT & sApplicationData.sBaseInfo.dwCategory)&&(sApplicationData.sBaseInfo.dwPinState == 0))
        {
          m_oInformationManager.DownsizeApplication(sApplicationData.sBaseInfo.dwRemovableKilobytes, &sApplicationData);
          dwKilobytesFreed = sApplicationData.sBaseInfo.dwRemovableKilobytes;
          dwlMBFreed += (DWORDLONG)dwKilobytesFreed*(DWORDLONG)1024;  //dwlMBFreed is cumulative up to that point
          hResult = lpCallBack->PurgeProgress(dwlMBFreed,dwlMBToFree-dwlMBFreed, 0,NULL);
 
          if (FAILED(hResult))
          {
            THROW(E_UNEXPECTED);
          }      
        }
      } 
      while ((dwElapsedDays >= dwDays)&&(S_OK == m_oInformationManager.GetNextOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData)));

	    hResult = lpCallBack->PurgeProgress(dwlMBFreed,dwlMBToFree-dwlMBFreed, EVCCBF_LASTNOTIFICATION,NULL);
	    if (FAILED(hResult)) 
      {
  		  THROW(E_UNEXPECTED);
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  catch(CAppManExceptionHandler * pException)
  {
    hResult = pException->GetResultCode();
    delete pException;
  }

  catch(...)
  {
    hResult = E_UNEXPECTED;
  }

  ///////////////////////////////////////////////////////////////////////////////////////

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//   Miscellaneous functions
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CEmptyVolumeCache::VolumeStringToNumber(LPCWSTR lpszVolume)
{
  FUNCTION("CEmptyVolumeCache::VolumeStringToNumber(LPCWSTR lpszVolume)");

	WORD    wDrive;
	DWORD   dwDrive;

  //
	// First get the first DWORD which makes up the drive label (i.e. c:\)
  //

	wDrive = *(WORD *) lpszVolume;

  //
	// Now convert the character to uppercase
  //

	dwDrive = toupper((INT) wDrive);

  //
	// Now Subtract the ASCII index off to have a drive number from 0 - 25.
  //

	dwDrive -= 65;

	return dwDrive;	
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CEmptyVolumeCache::ElapsedDays(SYSTEMTIME * lpLastUsedDate)
{

  FUNCTION("CEmptyVolumeCache::ElapsedDays(SYSTEMTIME * lpLastUsedDate)");
  SYSTEMTIME  stTodaysDate; 
  FILETIME	  ftTodaysDate, ftLastUsedDate;
  DWORDLONG	  dwlTodaysDate, dwlLastUsedDate;

  DWORD       dwElapsedDays;

  GetLocalTime(&stTodaysDate);

  //
  // Convert from systemtime to filetime
  //

  SystemTimeToFileTime(&stTodaysDate,&ftTodaysDate);
  SystemTimeToFileTime(lpLastUsedDate, &ftLastUsedDate);

  //
  // Copy to a DWORDLONG element
  //

  memcpy((void *)&dwlTodaysDate,(void *)&ftTodaysDate,sizeof(DWORDLONG));
  memcpy((void *)&dwlLastUsedDate,(void *)&ftLastUsedDate,sizeof(DWORDLONG));

	// Conversion:  100 nsec to days
	// 
	// 10000000 (100 nsec)   60 sec   60 min    24 hours     864000000000 (100 nsec)
	// ------------------- x ------ x ------- x --------  =  -----------------------
	//   sec			      min      hour       day               day
	//
  
  if (dwlTodaysDate <= dwlLastUsedDate) 
  {
	  dwElapsedDays = 0;
  } 
  else 
  {
	  dwElapsedDays = (DWORD)((dwlTodaysDate - dwlLastUsedDate) / (DWORDLONG) 864000000000);
  }

  return dwElapsedDays;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\global.cpp ===
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <time.h>
#include "Global.h"
#include "Win32API.h"
#include "AppMan.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Global Variables
//
//////////////////////////////////////////////////////////////////////////////////////////////

WCHAR gwszGlobalString[MAX_STRING_LEN];
CHAR  gszGlobalString[MAX_STRING_LEN];
GUID  gsCryptoGuid = { 0xb47c09c9, 0x1ace, 0x4bc3, 0xab, 0x45, 0x29, 0xa1, 0x80, 0x37, 0xa6, 0xf9 };

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPSTR MakeString(LPCSTR szFormat, ...)
{
  va_list   ArgumentList;

  if (NULL != szFormat)
  {
    va_start(ArgumentList, szFormat);
    _vsnprintf(gszGlobalString, 512, szFormat, ArgumentList);
    va_end(ArgumentList);
  }

  return gszGlobalString;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern DWORD GetAppManVersion(void)
{
  return 1;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL StringToGuidW(LPCWSTR wszGuidString, GUID * lpGuid)
{
  BOOL fSuccess = FALSE;

  if (11 == swscanf(wszGuidString, L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", &lpGuid->Data1, &lpGuid->Data2, &lpGuid->Data3, &lpGuid->Data4[0], &lpGuid->Data4[1], &lpGuid->Data4[2], &lpGuid->Data4[3], &lpGuid->Data4[4], &lpGuid->Data4[5], &lpGuid->Data4[6], &lpGuid->Data4[7]))
  {
    fSuccess = TRUE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL GuidToStringW(const GUID * lpGuid, LPWSTR wszGuidString)
{
  BOOL fSuccess = FALSE;

  if (38 == swprintf(wszGuidString, L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpGuid->Data1, lpGuid->Data2, lpGuid->Data3, lpGuid->Data4[0], lpGuid->Data4[1], lpGuid->Data4[2], lpGuid->Data4[3], lpGuid->Data4[4], lpGuid->Data4[5], lpGuid->Data4[6], lpGuid->Data4[7]))
  {
    fSuccess = TRUE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL StringToGuidA(LPCSTR szGuidString, GUID * lpGuid)
{
  BOOL fSuccess = FALSE;
  DWORD dwDword[11];

  if (11 == sscanf(szGuidString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", &dwDword[0], &dwDword[1], &dwDword[2], &dwDword[3], &dwDword[4], &dwDword[5], &dwDword[6], &dwDword[7], &dwDword[8], &dwDword[9], &dwDword[10]))
  {
    lpGuid->Data1 = dwDword[0];
    lpGuid->Data2 = (WORD) dwDword[1];
    lpGuid->Data3 = (WORD) dwDword[2];
    lpGuid->Data4[0] = (BYTE) dwDword[3];
    lpGuid->Data4[1] = (BYTE) dwDword[4];
    lpGuid->Data4[2] = (BYTE) dwDword[5];
    lpGuid->Data4[3] = (BYTE) dwDword[6];
    lpGuid->Data4[4] = (BYTE) dwDword[7];
    lpGuid->Data4[5] = (BYTE) dwDword[8];
    lpGuid->Data4[6] = (BYTE) dwDword[9];
    lpGuid->Data4[7] = (BYTE) dwDword[10];

    fSuccess = TRUE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL GuidToStringA(const GUID * lpGuid, LPSTR szGuidString)
{
  BOOL fSuccess = FALSE;

  if (38 == wsprintfA(szGuidString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpGuid->Data1, lpGuid->Data2, lpGuid->Data3, lpGuid->Data4[0], lpGuid->Data4[1], lpGuid->Data4[2], lpGuid->Data4[3], lpGuid->Data4[4], lpGuid->Data4[5], lpGuid->Data4[6], lpGuid->Data4[7]))
  {
    fSuccess = TRUE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern void EncryptGuid(GUID * lpGuid)
{
  DWORD   dwIndex;
  BYTE  * lpCryptoByte;
  BYTE  * lpGuidByte;

  lpCryptoByte = (BYTE *) &gsCryptoGuid;
  lpGuidByte = (BYTE *) lpGuid;

  for (dwIndex = 0; dwIndex < sizeof(GUID); dwIndex++)
  {
    *(lpGuidByte + dwIndex) = (BYTE)(*(lpGuidByte + dwIndex) ^ *(lpCryptoByte + dwIndex));
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern void DecryptGuid(GUID * lpGuid)
{
  DWORD   dwIndex;
  BYTE  * lpCryptoByte;
  BYTE  * lpGuidByte;

  lpCryptoByte = (BYTE *) &gsCryptoGuid;
  lpGuidByte = (BYTE *) lpGuid;

  for (dwIndex = 0; dwIndex < sizeof(GUID); dwIndex++)
  {
    *(lpGuidByte + dwIndex) = (BYTE)(*(lpGuidByte + dwIndex) ^ *(lpCryptoByte + dwIndex));
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern void RandomInit(void)
{
  srand((unsigned) time(NULL));
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BYTE RandomBYTE(void)
{
  DWORD dwRandom;

  dwRandom = (rand() * 0xff) / RAND_MAX;

  return (BYTE) dwRandom;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern WORD RandomWORD(void)
{
  WORD wRandom;

  wRandom = (WORD)(rand() * 2);

  return wRandom;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern DWORD RandomDWORD(void)
{
  DWORD dwRandom;

  dwRandom = rand() * (0xffffffff/RAND_MAX);

  return dwRandom;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern DWORD StrLenA(LPCSTR szString)
{
  DWORD dwIndex;

  dwIndex = 0;
  while ((MAX_PATH_CHARCOUNT > dwIndex)&&(0 != szString[dwIndex]))
  {
    dwIndex++;
  }

  return dwIndex + 1;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern DWORD StrLenW(LPCWSTR wszString)
{
  DWORD dwIndex;

  dwIndex = 0;
  while ((MAX_PATH_CHARCOUNT > dwIndex)&&(0 != wszString[dwIndex]))
  {
    dwIndex++;
  }

  return dwIndex + 1;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL GetResourceStringA(DWORD dwResourceId, LPSTR szString, DWORD dwStringCharLen)
{
  HINSTANCE hDllInstance;
  BOOL      fSuccess = FALSE;

  hDllInstance = (HINSTANCE) GetModuleHandle("AppMan.dll");
  if (0 < LoadStringA(hDllInstance, dwResourceId, szString, dwStringCharLen))
  {
    fSuccess = TRUE;
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL GetResourceStringW(DWORD dwResourceId, LPWSTR wszString, DWORD dwStringCharLen)
{
  HINSTANCE hDllInstance;
  BOOL      fSuccess = FALSE;
  CWin32API sWin32API;

  hDllInstance = (HINSTANCE) GetModuleHandle("AppMan.dll");
  if (0 < LoadStringA(hDllInstance, dwResourceId, gszGlobalString, MAX_PATH_CHARCOUNT))
  {
    if (0 < sWin32API.MultiByteToWideChar(gszGlobalString, MAX_PATH_CHARCOUNT, wszString, dwStringCharLen))
    {
      fSuccess = TRUE;
    }
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPSTR GetResourceStringPtrA(DWORD dwResourceId)
{
  LPSTR lpszStringPtr = NULL;

  if (TRUE == GetResourceStringA(dwResourceId, gszGlobalString, MAX_PATH_CHARCOUNT))
  {
    lpszStringPtr = gszGlobalString;
  }

  return lpszStringPtr;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPWSTR GetResourceStringPtrW(DWORD dwResourceId)
{
  LPWSTR lpwszStringPtr = NULL;

  if (TRUE == GetResourceStringW(dwResourceId, gwszGlobalString, MAX_PATH_CHARCOUNT))
  {
    lpwszStringPtr = gwszGlobalString;
  }

  return lpwszStringPtr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\global.h ===
#ifndef __GLOBAL_
#define __GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Global defines
//
//////////////////////////////////////////////////////////////////////////////////////////////

#define MAX_STRING_LEN    512

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Global Variables prototypes
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern CHAR   gszGlobalString[MAX_STRING_LEN];
extern GUID   gsCryptoGuid;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Global Functions
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPSTR  MakeString(LPCSTR szFormat, ...);
extern DWORD  GetAppManVersion(void);
extern BOOL   StringToGuidW(LPCWSTR szGuidString, GUID * lpGuid);
extern BOOL   GuidToStringW(const GUID * lpGuid, LPWSTR szGuidString);
extern BOOL   StringToGuidA(LPCSTR szGuidString, GUID * lpGuid);
extern BOOL   GuidToStringA(const GUID * lpGuid, LPSTR szGuidString);
extern void   EncryptGuid(GUID * lpGuid);
extern void   DecryptGuid(GUID * lpGuid);
extern void   RandomInit(void);
extern BYTE   RandomBYTE(void);
extern WORD   RandomWORD(void);
extern DWORD  RandomDWORD(void);
extern DWORD  StrLenA(LPCSTR szString);
extern DWORD  StrLenW(LPCWSTR wszString);
extern BOOL   GetResourceStringA(DWORD dwResourceId, LPSTR szString, DWORD dwStringCharLen);
extern BOOL   GetResourceStringW(DWORD dwResourceId, LPWSTR wszString, DWORD dwStringCharLen);
extern LPSTR  GetResourceStringPtrA(DWORD dwResourceId);
extern LPWSTR GetResourceStringPtrW(DWORD dwResourceId);

#ifdef __cplusplus
}
#endif

#endif __GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\informationmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// InformationManager.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of CInformationManager
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <string.h>
#include <ntverp.h>
#include "Resource.h"
#include "ApplicationManager.h"
#include "AppPropertyRules.h"
#include "ExceptionHandler.h"
#include "Win32API.h"
#include "RegistryKey.h"
#include "Lock.h"
#include "AppManDebug.h"
#include "Global.h"
#include "StructIdentifiers.h"

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_INFOMAN

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the number of elapsed minutes since October 25th 1968 (my birthday)
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD GetAgingCountInSeconds(LPAGING_INFO lpAgingInfo)
{
  FUNCTION(" ::GetAgingCountInSeconds (LPSYSTEMTIME lpSystemTime)");
  
  DWORD dwElapsedDays = 0;
  DWORD dwElapsedMinutes;
  DWORD dwElapsedSeconds;
  
  dwElapsedDays += (lpAgingInfo->stLastUsedDate.wYear - 1980) * 366;
  dwElapsedDays += lpAgingInfo->stLastUsedDate.wMonth * 31;
  dwElapsedDays += lpAgingInfo->stLastUsedDate.wDay;

  dwElapsedMinutes = (dwElapsedDays * 1440) + (lpAgingInfo->stLastUsedDate.wHour * 60) + lpAgingInfo->stLastUsedDate.wMinute;

  dwElapsedSeconds = (dwElapsedMinutes * 60) + (lpAgingInfo->stLastUsedDate.wSecond);

  return dwElapsedSeconds;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CInformationManager::CInformationManager(void)
{
  FUNCTION("CInformationManager::CInformationManager (void)");

  m_lInitializationIndex = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CInformationManager::~CInformationManager(void)
{
  FUNCTION("CInformationManager::~CInformationManager (void)");

  Shutdown();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::Initialize(void)
{
  FUNCTION("CInfoMgr::Initialize ()");

  HRESULT       hResult = S_OK;

  CLock sLock(&m_CriticalSection);

  //
  // Initialize the information manager if it is not already initialized
  //                                                               

  if (0 == InterlockedExchange(&m_lInitializationIndex, m_lInitializationIndex))
  {
    //
    // Before we proceed any further we need to initialize a system wide 'critical section'
    // and lock it. This ensures that any further processing past the function call is
    // exclusive to this process
    //

    m_CriticalSection.Initialize(TRUE, "W7407540-46a4-11d2-8d53-00c04f8f8b94");
  
    //
    // Did we create the critical section. If we did, we have to initialize the data in the
    // registry.
    //

    if (S_OK == m_CriticalSection.IsCreator())
    {
      //
      // Well if we are the creator we should initialize the registry and be the first to
      // AddRef()
      //

      RegInitialize();
    }

    //
    // Everything is ready
    //

    InterlockedIncrement(&m_lInitializationIndex);

    AddRef();
    m_CriticalSection.Leave();
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::Shutdown(void)
{
  FUNCTION("CInfoMgr::Shutdown ()");

  m_CriticalSection.Shutdown();
  InterlockedDecrement(&m_lInitializationIndex);

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CInformationManager::AddRef(void)
{
  FUNCTION("CInfoMgr::AddRef ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  TCHAR         szString[MAX_PATH_CHARCOUNT];
  DWORD         dwReferenceCount, dwBufferSize, dwValueType;

  sLock.Lock();

  //
  // By default the dwReturnCount = BAD_REFERENCE_COUNT
  //

  dwReferenceCount = BAD_REFERENCE_COUNT;
  if (0 < InterlockedExchange(&m_lInitializationIndex, m_lInitializationIndex))
  {
    //
    // Open the AppMan registry key
    //

    sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan");
    sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, szString, KEY_ALL_ACCESS);

    //
    // Get the current value of ReferenceCount. Make sure it is a DWORD
    //

    dwBufferSize = sizeof(dwReferenceCount);
    sRegistryKey.GetValue(TEXT("ReferenceCount"), &dwValueType, (LPBYTE) &dwReferenceCount, &dwBufferSize);

    if (REG_DWORD != dwValueType)
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Increment the ReferenceCount and write it to the Registry
    //

    dwReferenceCount++;
    sRegistryKey.SetValue(TEXT("ReferenceCount"), REG_DWORD, (LPBYTE) &dwReferenceCount, dwBufferSize);

    //
    // Close sRegistryKey
    //
  
    sRegistryKey.CloseKey();
  }

  sLock.UnLock();

  return (ULONG) dwReferenceCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CInformationManager::Release(void)
{
  FUNCTION("CInfoMgr::Release ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  TCHAR         szString[MAX_PATH_CHARCOUNT];
  DWORD         dwReferenceCount = 0, dwBufferSize, dwValueType;
  HRESULT       hResult = S_OK;

  sLock.Lock();

  //
  // By default the dwReturnCount = BAD_REFERENCE_COUNT
  //

  dwReferenceCount = BAD_REFERENCE_COUNT;

  if (0 < InterlockedExchange(&m_lInitializationIndex, m_lInitializationIndex))
  {
    //
    // Open the AppMan registry key
    //

    sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan");
    sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, szString, KEY_ALL_ACCESS);

    //
    // Get the current value of ReferenceCount. Make sure it is a DWORD
    //

    dwBufferSize = sizeof(dwReferenceCount);
    sRegistryKey.GetValue(TEXT("ReferenceCount"), &dwValueType, (LPBYTE) &dwReferenceCount, &dwBufferSize);

    if (REG_DWORD != dwValueType)
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Decrement the ReferenceCount and write it to the Registry
    //

    if (0 < dwReferenceCount)
    {
      dwReferenceCount--;
      sRegistryKey.SetValue(TEXT("ReferenceCount"), REG_DWORD, (LPBYTE) &dwReferenceCount, dwBufferSize);
    }

    //
    // Close sRegistryKey
    //
  
    sRegistryKey.CloseKey();
  }

  sLock.UnLock();

  return (ULONG) dwReferenceCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetAdvancedMode(LPDWORD lpdwAdvancedMode)
{
  FUNCTION("CInfoMgr::GetAdvancedMode ()");

  CLock                       sLock(&m_CriticalSection);
  CRegistryKey                sRegistryKey;
  APPLICATION_MANAGER_RECORD  sApplicationManagerRecord;
  DWORD                       dwType, dwSize;
  HRESULT                     hResult = S_OK;

  sLock.Lock();

  //
  // If we cannot create/open the root AppMan key then this is a catastrophic failure
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_READ);

  //
  // Get the APPLICATION_MANAGER_RECORD
  //

  dwSize = sizeof(APPLICATION_MANAGER_RECORD);
  sRegistryKey.GetValue("Vector000", &dwType, (LPBYTE) &sApplicationManagerRecord, &dwSize);
  if ((REG_BINARY != dwType)||(sizeof(APPLICATION_MANAGER_RECORD) != dwSize))
  {
    THROW(APPMAN_E_REGISTRYCORRUPT);
  }

  *lpdwAdvancedMode = sApplicationManagerRecord.dwAdvancedMode;

  sRegistryKey.CloseKey();

  sLock.UnLock();
  
  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::SetAdvancedMode(DWORD dwAdvancedMode)
{
  FUNCTION("CInfoMgr::SetAdvancedMode ()");

  CLock                       sLock(&m_CriticalSection);
  CRegistryKey                sRegistryKey;
  APPLICATION_MANAGER_RECORD  sApplicationManagerRecord;
  DWORD                       dwType, dwSize;
  
  sLock.Lock();

  //
  // If we cannot create/open the root AppMan key then this is a catastrophic failure
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_ALL_ACCESS);

  //
  // Get the APPLICATION_MANAGER_RECORD
  //

  dwSize = sizeof(APPLICATION_MANAGER_RECORD);
  sRegistryKey.GetValue("Vector000", &dwType, (LPBYTE) &sApplicationManagerRecord, &dwSize);
  if ((REG_BINARY != dwType)||(sizeof(APPLICATION_MANAGER_RECORD) != dwSize))
  {
    THROW(APPMAN_E_REGISTRYCORRUPT);
  }

  sApplicationManagerRecord.dwAdvancedMode = dwAdvancedMode;

  sRegistryKey.SetValue("Vector000", REG_BINARY, (LPBYTE) &sApplicationManagerRecord, sizeof(APPLICATION_MANAGER_RECORD));

  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetOptimalAvailableSpace(const DWORD dwApplicationCategory, LPDWORD lpdwOptimalKilobytes)
{
  FUNCTION("CInfoMgr::GetOptimalAvailableSpace ()");

  CLock           sLock(&m_CriticalSection);
  DEVICE_RECORD   sDeviceRecord;
  DWORD           dwDeviceIndex;
  DWORD           dwOptimalKilobytes;
  HRESULT         hResult = S_OK;

  sLock.Lock();
  
  //
  // Initialize the parameter to it's default value
  //

  *(lpdwOptimalKilobytes) = 0;

  //
  // Traverse all the local drives
  //

  for (dwDeviceIndex = 0; dwDeviceIndex < MAX_DEVICES; dwDeviceIndex++)
  {
    if (S_OK == CheckDeviceExistance(dwDeviceIndex))
    {
      GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
      GetDeviceOptimalSpaceWithIndex(dwDeviceIndex, &dwOptimalKilobytes);

      //
      // Consider the device space info if it does not exclude dwApplicationCategory
      //

      if (!(dwApplicationCategory & sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask))
      {
        if ((*(lpdwOptimalKilobytes)) < dwOptimalKilobytes)
        {
          *(lpdwOptimalKilobytes) = dwOptimalKilobytes;
        }
      }
    }
  }

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetMaximumAvailableSpace(const DWORD dwApplicationCategory, LPDWORD lpdwMaximumKilobytes)
{
  FUNCTION("CInfoMgr::GetMaximumAvailableSpace ()");

  CLock           sLock(&m_CriticalSection);
  DEVICE_RECORD   sDeviceRecord;
  DWORD           dwDeviceIndex;
  DWORD           dwMaximumKilobytes;

  sLock.Lock();

  //
  // Initialize the parameter to it's default value
  //

  *(lpdwMaximumKilobytes) = 0;

  //
  // Traverse all the local drives
  //

  for (dwDeviceIndex = 0; dwDeviceIndex < MAX_DEVICES; dwDeviceIndex++)
  {
    if (S_OK == CheckDeviceExistance(dwDeviceIndex))
    {
      GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
      GetDeviceMaximumSpaceWithIndex(dwDeviceIndex, &dwMaximumKilobytes);

      //
      // Consider the device space info if it does not exclude dwApplicationCategory
      //

      if (!(dwApplicationCategory & sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask))
      {
        if ((*(lpdwMaximumKilobytes)) < dwMaximumKilobytes)
        {
          *(lpdwMaximumKilobytes) = dwMaximumKilobytes;
        }
      }
    }
  }

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetSpace(const DWORD dwApplicationCategory, const DWORD dwRequiredKilobytes, LPDWORD lpdwDeviceIndex)
{
  FUNCTION("CInfoMgr::GetSpace ()");

  CLock               sLock(&m_CriticalSection);
  DEVICE_RECORD       sDeviceRecord;
  DWORD               dwDeviceIndex, dwTargetDeviceIndex;
  DWORD               dwKilobytes, dwTargetKilobytes;
  HRESULT             hResult = APPMAN_E_NODISKSPACEAVAILABLE;

  sLock.Lock();

  //
  // Initialize the startup parameters
  //

  *(lpdwDeviceIndex) = dwTargetDeviceIndex = 0xffffffff;
  dwTargetKilobytes = 0;

  //
  // Get the device with the most available Kilobytes. We attempt to do this for an optimal target
  //

  for (dwDeviceIndex = 0; dwDeviceIndex < MAX_DEVICES; dwDeviceIndex++)
  {
    if (S_OK == CheckDeviceExistance(dwDeviceIndex))
    {
      //
      // Get the device information
      //

      GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

      //
      // Process devices that are not excluded
      //

      if (!(dwApplicationCategory & sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask))
      {
        GetDeviceOptimalSpaceWithIndex(dwDeviceIndex, &dwKilobytes);
        if ((dwRequiredKilobytes <= dwKilobytes)&&(dwTargetKilobytes < dwKilobytes))
        {
          dwTargetDeviceIndex = dwDeviceIndex;
          dwTargetKilobytes = dwKilobytes;
        }
      }
    }
  }

  //
  // If we failed to find an optimal fit, then we will go for a maximal fit
  //

  if (0xffffffff == dwTargetDeviceIndex)
  {
    for (dwDeviceIndex = 0; dwDeviceIndex < MAX_DEVICES; dwDeviceIndex++)
    {
      if (S_OK == CheckDeviceExistance(dwDeviceIndex))
      {
        //
        // Get the device information
        //

        GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

        //
        // Process devices that are not excluded
        //

        if (!(dwApplicationCategory & sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask))
        {
          GetDeviceMaximumSpaceWithIndex(dwDeviceIndex, &dwKilobytes);
          if ((dwRequiredKilobytes <= dwKilobytes)&&(dwTargetKilobytes < dwKilobytes))
          {
			      dwTargetDeviceIndex = dwDeviceIndex;
            dwTargetKilobytes = dwKilobytes;
          }
        }
      }
    }
  }

  //
  // Did we find a target drive ?
  //

  if (0xffffffff == dwTargetDeviceIndex)
  {
    THROW(APPMAN_E_NODISKSPACEAVAILABLE);
  }

  //
  // Make sure to unlock before we try and free up the space
  //

  sLock.UnLock();

  //
  // Free up the space on the target device. Make sure that FreeSpaceOnDeviceWithIndex()
  // is called outside of a locking region
  //

  hResult = FreeSpaceOnDeviceWithIndex(dwTargetDeviceIndex, dwRequiredKilobytes);

  if (SUCCEEDED(hResult))
  {
    //
    // Record the target device to lpdwDeviceIndex
    //

    *(lpdwDeviceIndex) = dwTargetDeviceIndex;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::FreeSpaceOnDevice(const GUID * lpDeviceGuid, const DWORD dwRequiredKilobytes)
{
  FUNCTION("CInfoMgr::FreeSpaceOnDevice ()");
  
  DEVICE_RECORD   sDeviceRecord;
  HRESULT         hResult;

  //
  // Translate the device guid into a device index
  //

  ZeroMemory(&sDeviceRecord, sizeof(DEVICE_RECORD));
  memcpy(&(sDeviceRecord.sDeviceGuid), lpDeviceGuid, sizeof(GUID));
  hResult = GetDeviceInfo(&sDeviceRecord);
  if (SUCCEEDED(hResult))
  {
    hResult = FreeSpaceOnDeviceWithIndex(GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial), dwRequiredKilobytes);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the number of elapsed minutes since October 25th 1968 (my birthday)
//
//////////////////////////////////////////////////////////////////////////////////////////////

//STDMETHODIMP_(DWORD) CInformationManager::GetApplicationAge(LPAPPLICATION_DATA lpApplicationData)
//{
//  FUNCTION("CInfoMgr::GetApplicationAge ()");
//
//  return GetAgingCount(lpApplicationData);
//}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::CheckApplicationExistance(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::CheckApplicationExistance ()");

  CLock             sLock(&m_CriticalSection);
  HRESULT           hResult = S_FALSE;
  DWORD             dwApplicationIndex;
  APPLICATION_DATA  sApplicationData;

  sLock.Lock();

  dwApplicationIndex = 0;
  while ((S_FALSE == hResult)&&(SUCCEEDED(GetApplicationDataWithIndex(dwApplicationIndex, &sApplicationData))))
  {
    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
    {
      if (0 == memcmp((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, sizeof(GUID)))
      {
        hResult = S_OK;
      }
    }
    else
    {
      if ((S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_COMPANYNAME, lpApplicationData))&&(S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SIGNATURE, lpApplicationData)))
      {
        if (0 == _wcsnicmp(lpApplicationData->wszStringProperty[APP_STRING_COMPANYNAME], sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], MAX_PATH_CHARCOUNT+1))
        {
          if (0 == _wcsnicmp(lpApplicationData->wszStringProperty[APP_STRING_SIGNATURE], sApplicationData.wszStringProperty[APP_STRING_SIGNATURE], MAX_PATH_CHARCOUNT+1))
          {
            hResult = S_OK;
          }
        }
      }
      else
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
    }
    dwApplicationIndex++;
  }

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CInformationManager::IsApplicationPinned(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::IsApplicationPinned ()");

  CLock             sLock(&m_CriticalSection);
  APPLICATION_DATA  sApplicationData;
  ASSOCIATION_INFO  sAssociationData;
  DWORD             dwIndex;
  BOOL              fResult = FALSE;

  //
  // Lock the information manager to prevent other processes from using it
  //

  sLock.Lock();

  //
  // First we make sure the root path is not pinned itself
  //

  fResult = lpApplicationData->sBaseInfo.dwPinState;

  //
  // Lock this application and all of it's parents
  //

  ZeroMemory(&sAssociationData, sizeof(sAssociationData));
  dwIndex = 0;
  while ((FALSE == fResult)&&(S_OK == EnumAssociations(dwIndex, &sAssociationData)))
  {
    if (0 == memcmp((LPVOID) &(sAssociationData.sParentGuid), (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
    {
      //
      // We have found an association parented by lpApplicationData
      //

      ZeroMemory(&sApplicationData, sizeof(sApplicationData));
      memcpy((LPVOID) &(sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationData.sChildGuid), sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      if (SUCCEEDED(GetApplicationData(&sApplicationData)))
      {
        fResult = IsApplicationPinned(&sApplicationData);
      }
    }

    ZeroMemory(&sAssociationData, sizeof(sAssociationData));
    dwIndex++;
  }

  //
  // Now that we are done, unlock the Information Manager
  //

  sLock.UnLock();

  return fResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::IsInstanceGuidStillAlive(const GUID * lpGuid)
{
  FUNCTION("CInfoMgr::IsInstanceGuidStillAlive ()");

  CLock   sLock(&m_CriticalSection);
  HANDLE  hMutex;
  CHAR    szString[MAX_PATH];
  HRESULT hResult = S_OK;

  sLock.Lock();

  //
  // Create a named mutex
  //

  sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpGuid->Data1, lpGuid->Data2, lpGuid->Data3, lpGuid->Data4[0], lpGuid->Data4[1], lpGuid->Data4[2], lpGuid->Data4[3], lpGuid->Data4[4], lpGuid->Data4[5], lpGuid->Data4[6], lpGuid->Data4[7]);
  hMutex = CreateMutex(NULL, FALSE, szString);
  if (NULL == hMutex)
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Did we create the mutex
  //

  if (ERROR_ALREADY_EXISTS == GetLastError())
  {
    //
    // If we get WAIT_TIMEOUT then the thread is still alive
    // If we get WAIT_OBJECT_0 then the thread is the current one using this function
    // If we get WAIT_ABANDONNED then the thread died
    //

    switch (WaitForSingleObject(hMutex, 0))
    {
      case WAIT_TIMEOUT
      : hResult = S_OK;
        break;

      case WAIT_OBJECT_0
      : hResult = S_OK;
        break;

      case WAIT_ABANDONED
      : hResult = S_FALSE;
        break;
    }
  }
  else
  {
    //
    // We created the mutex. This means that instance is no longer alive
    //

    hResult = S_FALSE;
  }

  //
  // Close the mutex handle
  //

  CloseHandle(hMutex);

  //
  // Now that we are done, unlock the Information Manager
  //
 
  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::IsApplicationLocked(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::IsApplicationLocked ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  GUID          sEncryptedGuid;
  CHAR          szString[40];
  HRESULT       hResult;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Open the AppMan\\Lock registry entry
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", KEY_ALL_ACCESS);

  //
  // What would be the encrypted guid for this application. This value will be used as the
  // Value Name of the registry entry
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Is the application already locked
  //

  hResult = sRegistryKey.CheckForExistingValue(szString);
  if (S_OK == hResult)
  {
    LOCK_INFO   sLockInfo;
    DWORD       dwDataType, dwDataLen;

    //
    // Well the application is locked, but is the lock still valid, let's check
    //

    dwDataLen = sizeof(sLockInfo);
    ZeroMemory(&sLockInfo, sizeof(sLockInfo));
    sRegistryKey.GetValue(szString, &dwDataType, (LPBYTE) &sLockInfo, &dwDataLen);

    if ((REG_BINARY != dwDataType)||(dwDataLen != sizeof(sLockInfo))||(S_FALSE == IsInstanceGuidStillAlive(&sLockInfo.guidInstanceGuid)))
    {
      //
      // The lock is invalid
      //

      if (S_OK == sRegistryKey.CheckForExistingValue(szString))
      {
        sRegistryKey.DeleteValue(szString);
      }
      ZeroMemory(&sLockInfo, sizeof(sLockInfo));
      hResult = S_FALSE;
    }
  }

  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  //
  // Unlock the information manager
  //

  sLock.UnLock();


  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::LockApplicationData(LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::LockApplicationData ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  LOCK_INFO     sLockInfo;
  GUID          sEncryptedGuid;
  DWORD         dwIndex, dwDataType, dwDataLen;
  CHAR          szGuid[40];
  HRESULT       hResult = S_OK;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Open the AppMan\\Lock registry entry
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", KEY_ALL_ACCESS);

  //
  // What would be the encrypted guid for this application. This value will be used as the
  // Value Name of the registry entry
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Is the application already locked
  //

  if (S_OK == IsApplicationLocked(lpApplicationData))
  {
    //
    // Get the lock info for this application
    //

    dwDataLen = sizeof(sLockInfo);
    ZeroMemory(&sLockInfo, sizeof(sLockInfo));
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sLockInfo, &dwDataLen);

    //
    // Make sure the data that we have retrieved makes sense
    //

    if ((REG_BINARY != dwDataType)||(dwDataLen != sizeof(sLockInfo)))
    {
      //
      // The registry entry isnt very good.
      //

      sRegistryKey.DeleteValue(szGuid);
      ZeroMemory(&sLockInfo, sizeof(sLockInfo));
    }

    //
    // Handle depending on reentry case or wait state
    //

    if (0 == memcmp((LPVOID) &(sLockInfo.guidInstanceGuid), (LPVOID) lpInstanceGuid, sizeof(GUID)))
    {
      //
      // Reentry case
      //

      sLockInfo.dwLockCount++;
      hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sLockInfo, sizeof(sLockInfo));
    }
    else
    {
      DWORD dwStartTime;

      //
      // Other instance has the object locked. We have to wait for lock to go away
      //

      dwStartTime = GetTickCount();
      sLock.UnLock();
      hResult = APPMAN_E_OBJECTLOCKED;
      dwIndex = 0;
      do
      {
        //
        // Give the lock owner thread a chance to relinquish the lock
        //

        Sleep(100);

    
        if (S_FALSE == IsApplicationLocked(lpApplicationData))
        {
          hResult = S_OK;
        }

        //
        // Each time we increment dwIndex, 1/10 of a second went by.
        //

        dwIndex++;

        //
        // Did we run out of time
        //

        if (10000 > (GetTickCount() - dwStartTime))
        {
          THROW(APPMAN_E_APPLICATIONALREADYLOCKED);
        }
      }
      while (FAILED(hResult));
    }
  }
  else
  {
    //
    // There is no lock on this object
    //

    sLockInfo.dwSize = sizeof(sLockInfo);
    sLockInfo.dwStructId = LOCK_STRUCT;
    sLockInfo.dwLockCount = 1;
    memcpy((LPVOID) &(sLockInfo.guidInstanceGuid), (LPVOID) lpInstanceGuid, sizeof(GUID));

    //
    // Write out the new lock info to the registry
    //

    hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sLockInfo, sizeof(sLockInfo));
  }

  //
  // Close the registry key
  //

  sRegistryKey.CloseKey();

  //
  // Make sure the information manager unlocked
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnlockApplicationData(LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::UnlockApplicationData ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  LOCK_INFO     sLockInfo;
  DWORD         dwDataType, dwDataLen;
  GUID          sEncryptedGuid;
  CHAR          szGuid[40];
  HRESULT       hResult = S_OK;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Open the AppMan\\Lock registry entry
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", KEY_ALL_ACCESS);

  //
  // What would be the encrypted guid for this application. This value will be used as the
  // Value Name of the registry entry
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Is the application already locked
  //

  if (S_OK == IsApplicationLocked(lpApplicationData))
  {
    //
    // Get the lock info for this application
    //

    dwDataLen = sizeof(sLockInfo);
    ZeroMemory(&sLockInfo, sizeof(sLockInfo));
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sLockInfo, &dwDataLen);

    //
    // Make sure the data that we have retrieved makes sense
    //

    if ((REG_BINARY != dwDataType)||(dwDataLen != sizeof(sLockInfo)))
    {
      //
      // The registry entry isnt very good.
      //

      sRegistryKey.DeleteValue(szGuid);
    }
    else
    {
      //
      // Make sure that we do own this lock
      //

      if (0 == memcmp((LPVOID) &(sLockInfo.guidInstanceGuid), (LPVOID) lpInstanceGuid, sizeof(GUID)))
      {
        sLockInfo.dwLockCount--;
        if (0 == sLockInfo.dwLockCount)
        {
          //
          // The lock is over. Delete the registry entry
          //

          sRegistryKey.DeleteValue(szGuid);
        }
        else
        {
          //
          // We still own the lock. Write out the new registry information with the updated
          // lock count
          //

          hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sLockInfo, sizeof(sLockInfo));
        }
      }
    }
  }

  //
  // Close the registry key
  //

  sRegistryKey.CloseKey();
  
  //
  // Make sure the information manager unlocked
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ForceUnlockApplicationData(LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::UnlockApplicationData ()");

  CLock   sLock(&m_CriticalSection);
  HRESULT hResult = S_OK;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Is the application already locked
  //

  if (S_OK == IsApplicationLocked(lpApplicationData))
  {
    CRegistryKey  sRegistryKey;
    GUID          sEncryptedGuid;
    CHAR          szString[MAX_PATH];
    LOCK_INFO     sLockInfo;
    DWORD         dwDataType, dwDataLen;

    //
    // Open the AppMan\\Lock registry entry
    //

    sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", KEY_ALL_ACCESS);

    //
    // What would be the encrypted guid for this application. This value will be used as the
    // Value Name of the registry entry
    //

    memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
    EncryptGuid(&sEncryptedGuid);
    sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

    //
    // Well the application is locked, but do we own the lock ?
    //

    dwDataLen = sizeof(sLockInfo);
    ZeroMemory(&sLockInfo, sizeof(sLockInfo));
    sRegistryKey.GetValue(szString, &dwDataType, (LPBYTE) &sLockInfo, &dwDataLen);
    if (0 == memcmp(&sLockInfo.guidInstanceGuid, lpInstanceGuid, sizeof(GUID)))
    {
      //
      // We own the lock so let's kill it
      //

      sRegistryKey.DeleteValue(szString);
    }

    //
    // Close the registry key
    //

    sRegistryKey.CloseKey();
  }

  //
  // Make sure the information manager unlocked
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::LockApplicationData(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::LockApplicationData ()");

  GUID          sZeroGuid;
  
  ZeroMemory(&sZeroGuid, sizeof(sZeroGuid));

  return LockApplicationData(lpApplicationData, &sZeroGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnlockApplicationData(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::UnlockApplicationData ()");

  GUID          sZeroGuid;
  
  ZeroMemory(&sZeroGuid, sizeof(sZeroGuid));

  return UnlockApplicationData(lpApplicationData, &sZeroGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::LockParentApplications(LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::LockParentApplications ()");

  CLock             sLock(&m_CriticalSection);
  APPLICATION_DATA  sApplicationData;
  ASSOCIATION_INFO  sAssociationData;
  DWORD             dwIndex;
  HRESULT           hResult = S_OK;

  //
  // Lock the information manager to prevent other processes from using it
  //

  sLock.Lock();

  //
  // Lock this application and all of it's parents
  //

  ZeroMemory(&sAssociationData, sizeof(sAssociationData));
  dwIndex = 0;
  while (S_OK == EnumAssociations(dwIndex, &sAssociationData))
  {
    if (0 == memcmp((LPVOID) &(sAssociationData.sChildGuid), (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
    {
      //
      // We have found a parent application. There can only be one parent per application
      //

      ZeroMemory(&sApplicationData, sizeof(sApplicationData));
      memcpy((LPVOID) &(sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationData.sParentGuid), sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      if (SUCCEEDED(GetApplicationData(&sApplicationData)))
      {
        hResult = LockParentApplications(&sApplicationData, lpInstanceGuid);
      }
    }

    ZeroMemory(&sAssociationData, sizeof(sAssociationData));
    dwIndex++;
  }

  //
  // If everything is going ok, lock this applications
  //

  if (SUCCEEDED(hResult))
  {
    hResult = LockApplicationData(lpApplicationData, lpInstanceGuid);
  }

  //
  // Now that we are done, unlock the Information Manager
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnlockParentApplications(LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::UnlockParentApplications ()");

  CLock             sLock(&m_CriticalSection);
  APPLICATION_DATA  sApplicationData;
  ASSOCIATION_INFO  sAssociationData;
  DWORD             dwIndex;
  HRESULT           hResult = S_OK;

  //
  // Lock the information manager to prevent other processes from using it
  //

  sLock.Lock();

  //
  // Unlock this application and all of it's parents
  //

  ZeroMemory(&sAssociationData, sizeof(sAssociationData));
  dwIndex = 0;
  while (S_OK == EnumAssociations(dwIndex, &sAssociationData))
  {
    if (0 == memcmp((LPVOID) &(sAssociationData.sChildGuid), (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
    {
      //
      // We have found a parent application. There can only be one parent per application
      //

      ZeroMemory(&sApplicationData, sizeof(sApplicationData));
      memcpy((LPVOID) &(sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationData.sParentGuid), sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      if (SUCCEEDED(GetApplicationData(&sApplicationData)))
      {
        hResult = UnlockParentApplications(&sApplicationData, lpInstanceGuid);
      }
    }

    ZeroMemory(&sAssociationData, sizeof(sAssociationData));
    dwIndex++;
  }

  //
  // If everything is going ok, lock this applications
  //

  if (SUCCEEDED(hResult))
  {
    hResult = UnlockApplicationData(lpApplicationData, lpInstanceGuid);
  }

  //
  // Now that we are done, unlock the Information Manager
  //

  sLock.Lock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::LockParentApplications(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::LockParentApplications ()");

  GUID  sZeroGuid;

  ZeroMemory(&sZeroGuid, sizeof(sZeroGuid));

  return LockParentApplications(lpApplicationData, &sZeroGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnlockParentApplications(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::UnlockParentApplications ()");

  GUID  sZeroGuid;

  ZeroMemory(&sZeroGuid, sizeof(sZeroGuid));

  return UnlockParentApplications(lpApplicationData, &sZeroGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::AddApplicationData(LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::AddApplicationData ()");

  CLock   sLock(&m_CriticalSection);

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Make sure the SIGNATURE and COMPANYNAME properties are set
  //

  if ((S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_COMPANYNAME, lpApplicationData))||(S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SIGNATURE, lpApplicationData)))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Does the application already exist 
  //

  if (S_OK == CheckApplicationExistance(lpApplicationData))
  {
    THROW(APPMAN_E_APPLICATIONALREADYEXISTS);
  }

  //
  // Assign a new GUID to the application record
  //

  if (FAILED(CoCreateGuid(&(lpApplicationData->sBaseInfo.sApplicationGuid))))
  {
    THROW(E_UNEXPECTED);
  }

  ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, lpApplicationData);

  //
  // Set the application record
  //

  SetApplicationData(lpApplicationData, lpInstanceGuid);

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RemoveApplicationData(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::RemoveApplicationData ()");

  CLock             sLock(&m_CriticalSection);
  CRegistryKey      sRegistryKey;
  APPLICATION_DATA  sApplicationData;
  CHAR              szString[MAX_PATH_CHARCOUNT];
  GUID              sEncryptedGuid;
  BOOL              fEraseSetupRoot = TRUE;
  DWORD             dwIndex;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // In order to remove an application, we must have DATA_FIELD_GUID validated
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Does the application already exist 
  //

  if (S_OK == CheckApplicationExistance(lpApplicationData))
  {
    //
    // Make sure we have a fully populated application object
    //

    if (SUCCEEDED(GetApplicationData(lpApplicationData)))
    {
      ASSOCIATION_INFO  sAssociationInfo;

      //
      // Remove related associations from system
      //

      dwIndex = 0;
      while (S_OK == EnumAssociations(dwIndex, &sAssociationInfo))
      {
        if (0 == memcmp((LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID)))
        {
          RemoveAssociation(&sAssociationInfo);
        }
        else if (0 == memcmp((LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sChildGuid, sizeof(GUID)))
        {
          RemoveAssociation(&sAssociationInfo);
        }
        dwIndex++;
      }

      //
      // Delete the application record
      //

      memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, sizeof(GUID));
      EncryptGuid(&sEncryptedGuid);
      sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);
      if (S_OK == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, szString))
      {
        sRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, szString);
      }

      //
      // Find out if any other applications are using this directory
      //

      dwIndex = 0;
      while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
      {
        if (0 == wcscmp(sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH], lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
        {
          fEraseSetupRoot = FALSE;
        }
        dwIndex++;
      }

      //
      // Delete the setup root directory.
      //

      if (fEraseSetupRoot)
      {
        if (FAILED(DeleteDirectoryTree(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH])))
        {
          RegFutureDirectoryCleanup(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]);
        }
      }

      //
      // Close sRegistryKey
      //
  
      sRegistryKey.CloseKey();
    }
  }

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetApplicationDataWithIndex(const DWORD dwApplicationIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::GetApplicationDataWithIndex ()");

  CLock         sLock(&m_CriticalSection);
  DEVICE_RECORD sDeviceRecord;
  CWin32API     sWin32API;
  CRegistryKey  sRegistryKey;
  CHAR          szString[MAX_PATH_CHARCOUNT+1];
  DWORD         dwIndex, dwTargetIndex;
  DWORD         dwValueType, dwValueLen;
  DWORD         dwStringLen, dwStringIndex;
  HRESULT       hResult = S_OK;
  BOOL          fRemoveApp = FALSE;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // First we need to open the application root key
  //

  sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications");
  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, szString, KEY_READ);

  //
  // Because of the way the registry works, we have to start enumerating keys with
  // a starting index of 0 and increment constantly until we get to the desired index
  //

  dwTargetIndex = dwApplicationIndex;
  dwIndex = 0;
  while ((dwIndex <= dwTargetIndex)&&(SUCCEEDED(hResult)))
  {
    dwStringLen = sizeof(szString);
    if (S_OK == sRegistryKey.EnumKeys(dwIndex, szString, &dwStringLen))
    {
      ZeroMemory(lpApplicationData, sizeof(APPLICATION_DATA));
      if (!StringToGuidA(szString, &lpApplicationData->sBaseInfo.sApplicationGuid))
      {
       dwTargetIndex++;
      }
    }
    else
    {
      hResult = APPMAN_E_INVALIDINDEX;
    }
    dwIndex++;
  }

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  //
  // Did we find a candidate application
  //

  if (SUCCEEDED(hResult))
  {
    sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);
    if (S_FALSE == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, szString))
    {
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }

    //
    // Open the application registry key
    //

    sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, szString, KEY_READ);

    //
    // Read in the binary data
    //

    dwValueLen = sizeof(lpApplicationData->sBaseInfo);
    sRegistryKey.GetValue("Vector000", &dwValueType, (LPBYTE) &lpApplicationData->sBaseInfo, &dwValueLen);
    if (sizeof(lpApplicationData->sBaseInfo) != dwValueLen)
    {
      THROW(E_UNEXPECTED);
    }
  
    dwValueLen = sizeof(lpApplicationData->sAgingInfo);
    sRegistryKey.GetValue("Vector001", &dwValueType, (LPBYTE) &lpApplicationData->sAgingInfo, &dwValueLen);
    if (sizeof(lpApplicationData->sAgingInfo) != dwValueLen)
    {
      THROW(E_UNEXPECTED);
    }

    dwValueLen = sizeof(lpApplicationData->wszStringProperty[APP_STRING_CRYPTO]);
    sRegistryKey.GetValue("Vector002", &dwValueType, (LPBYTE) lpApplicationData->wszStringProperty[APP_STRING_CRYPTO], &dwValueLen);
    if (sizeof(lpApplicationData->wszStringProperty[APP_STRING_CRYPTO]) != dwValueLen)
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Read in the string data
    //

    for (dwIndex = 0; dwIndex < PROPERTY_COUNT; dwIndex++)
    {
      //
      // If the property is set, is it a string ?
      //

      if ((S_OK == IsApplicationPropertyInitializedWithIndex(dwIndex, lpApplicationData))&&(APP_STRING_NONE != gPropertyInfo[dwIndex].dwStringId))
      {
        //
        // Get the encrypted string from the registry
        //

        sprintf(szString, "Vector%03x", gPropertyInfo[dwIndex].dwStringId + 2);
        dwValueLen = (MAX_PATH_CHARCOUNT+1)*2;
        sRegistryKey.GetValue(szString, &dwValueType, (LPBYTE) lpApplicationData->wszStringProperty[gPropertyInfo[dwIndex].dwStringId], &dwValueLen);

        //
        // Decrypt the string
        //

        for (dwStringIndex = 0; dwStringIndex < MAX_PATH_CHARCOUNT+1; dwStringIndex++)
        {
          lpApplicationData->wszStringProperty[gPropertyInfo[dwIndex].dwStringId][dwStringIndex] ^= lpApplicationData->wszStringProperty[APP_STRING_CRYPTO][dwStringIndex];

        }
      }
    }

    //
    // Close sRegistryKey
    //
  
    sRegistryKey.CloseKey();

    //
    // Compensate for a changing device index (i.e. problem with SCSI pluggins)
    //

    ZeroMemory(&sDeviceRecord, sizeof(sDeviceRecord));
    memcpy(&sDeviceRecord.sDeviceGuid, &lpApplicationData->sBaseInfo.sDeviceGuid, sizeof(GUID));
    GetDeviceInfo(&sDeviceRecord);

    //
    // Get the device index of the device using the volume serial passed in
    //
    
    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_EXECUTECMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_EXECUTECMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DOWNSIZECMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_DOWNSIZECMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_REINSTALLCMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_REINSTALLCMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_UNINSTALLCMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_UNINSTALLCMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SELFTESTCMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_SELFTESTCMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
    {
      lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE][0] = (WORD) (65 + GetDeviceIndex(sDeviceRecord.sDeviceInfo.dwVolumeSerial));
    }

    //
    // If the application is in a ready state and the setup root path is gone, this is not so bad
    //

    if (APP_STATE_READY == lpApplicationData->sBaseInfo.dwState)
    {
      if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
      {
        if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH]))
        {
          fRemoveApp = TRUE;
        }
      }
    }
    else
    {
      if ((APP_STATE_DOWNSIZING | APP_STATE_DOWNSIZED | APP_STATE_REINSTALLING | APP_STATE_UNINSTALLING | APP_STATE_SELFTESTING) && lpApplicationData->sBaseInfo.dwState)
      {
        if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
        {
          fRemoveApp = TRUE;
        }
      }
    }

    //
    // Should we remove the application
    //

    if (fRemoveApp)
    {
      ASSOCIATION_INFO  sAssociationInfo;

      //
      // Well there's no sense in keeping the application lying around since both of it's root paths
      // are gone. Let's delete the record
      //

      EncryptGuid(&lpApplicationData->sBaseInfo.sApplicationGuid);
      sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);
      if (S_OK == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, szString))
      {
        sRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, szString);
      }

      //
      // Remove related associations from system
      //

      DecryptGuid(&lpApplicationData->sBaseInfo.sApplicationGuid);
      dwIndex = 0;
      while (S_OK == EnumAssociations(dwIndex, &sAssociationInfo))
      {
        if (0 == memcmp((LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID)))
        {
          RemoveAssociation(&sAssociationInfo);
        }
        else if (0 == memcmp((LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sChildGuid, sizeof(GUID)))
        {
          RemoveAssociation(&sAssociationInfo);
        }
        dwIndex++;
      }

      //
      // Recursively call
      //

      hResult = GetApplicationDataWithIndex(dwApplicationIndex, lpApplicationData);
    }
  }

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetApplicationData(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::GetApplicationData ()");

  CLock             sLock(&m_CriticalSection);
  HRESULT           hResult = S_FALSE;
  DWORD             dwApplicationIndex;
  APPLICATION_DATA  sApplicationData;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  dwApplicationIndex = 0;
  while ((S_FALSE == hResult)&&(SUCCEEDED(GetApplicationDataWithIndex(dwApplicationIndex, &sApplicationData))))
  {
    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
    {
      if (0 == memcmp((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, sizeof(GUID)))
      {
        memcpy((LPVOID) lpApplicationData, (LPVOID) &sApplicationData, sizeof(APPLICATION_DATA));
        hResult = S_OK;
      }
    }
    else
    {
      if ((S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_COMPANYNAME, lpApplicationData))&&(S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SIGNATURE, lpApplicationData)))
      {
        if (0 == _wcsnicmp(lpApplicationData->wszStringProperty[APP_STRING_COMPANYNAME], sApplicationData.wszStringProperty[APP_STRING_COMPANYNAME], MAX_PATH_CHARCOUNT+1))
        {
          if (0 == _wcsnicmp(lpApplicationData->wszStringProperty[APP_STRING_SIGNATURE], sApplicationData.wszStringProperty[APP_STRING_SIGNATURE], MAX_PATH_CHARCOUNT+1))
          {
            memcpy((LPVOID) lpApplicationData, (LPVOID) &sApplicationData, sizeof(APPLICATION_DATA));
            hResult = S_OK;
          }
        }
      }
      else
      {
        THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
      }
    }
    dwApplicationIndex++;
  }

  sLock.UnLock();

  //
  // Did we find the application we were looking for ?
  //

  if (S_FALSE == hResult)
  {
    hResult = APPMAN_E_UNKNOWNAPPLICATION;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::SetApplicationData(LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::SetApplicationData ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  GUID          sApplicationGuid;
  CHAR          szString[MAX_PATH_CHARCOUNT+1];
  DWORD         dwStringLen, dwIndex;
  WCHAR         wszEncryptedString[MAX_PATH_CHARCOUNT+1];
  
  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Record the instance guid
  //

  if (NULL != lpInstanceGuid)
  {
    memcpy(&lpApplicationData->sBaseInfo.sInstanceGuid, lpInstanceGuid, sizeof(GUID));
  }
  else
  {
    ZeroMemory(&lpApplicationData->sBaseInfo.sInstanceGuid, sizeof(GUID));
  }

  //
  // First we need to determine how the encrypted GUID is going to look like
  //

  memcpy(&sApplicationGuid, &lpApplicationData->sBaseInfo.sApplicationGuid, sizeof(GUID));
  EncryptGuid(&sApplicationGuid);

  //
  // Now that we have the encrypted GUID, we need to build the root registry entry for this
  // application.
  //

  sprintf(szString, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sApplicationGuid.Data1, sApplicationGuid.Data2, sApplicationGuid.Data3, sApplicationGuid.Data4[0], sApplicationGuid.Data4[1], sApplicationGuid.Data4[2], sApplicationGuid.Data4[3], sApplicationGuid.Data4[4], sApplicationGuid.Data4[5], sApplicationGuid.Data4[6], sApplicationGuid.Data4[7]);
  if (S_OK == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, szString))
  {
    sRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, szString);
  }

  //
  // Open the application registry key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, szString, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, NULL);

  //
  // Write out the binary data
  //

  sRegistryKey.SetValue("Vector000", REG_BINARY, (LPBYTE) &lpApplicationData->sBaseInfo, sizeof(lpApplicationData->sBaseInfo));
  sRegistryKey.SetValue("Vector001", REG_BINARY, (LPBYTE) &lpApplicationData->sAgingInfo, sizeof(lpApplicationData->sAgingInfo));
  sRegistryKey.SetValue("Vector002", REG_BINARY, (LPBYTE) lpApplicationData->wszStringProperty[APP_STRING_CRYPTO], sizeof(lpApplicationData->wszStringProperty[APP_STRING_CRYPTO]));

  //
  // Write out the string data
  //

  for (dwIndex = 0; dwIndex < PROPERTY_COUNT; dwIndex++)
  {
    //
    // If the property is set, is it a string ?
    //

    if ((S_OK == IsApplicationPropertyInitializedWithIndex(dwIndex, lpApplicationData))&&(APP_STRING_NONE != gPropertyInfo[dwIndex].dwStringId))
    {
      //
      // First determine how many bytes we want to write out to the registry
      //

      ZeroMemory(wszEncryptedString, sizeof(wszEncryptedString));
      dwStringLen = 0;
      do
      {
        wszEncryptedString[dwStringLen] = lpApplicationData->wszStringProperty[gPropertyInfo[dwIndex].dwStringId][dwStringLen];
        wszEncryptedString[dwStringLen] ^= lpApplicationData->wszStringProperty[APP_STRING_CRYPTO][dwStringLen];
        dwStringLen++;
      }
      while (0 != lpApplicationData->wszStringProperty[gPropertyInfo[dwIndex].dwStringId][dwStringLen-1]);

      //
      // Write out the encrypted string into a binary buffer into the registry
      //

      sprintf(szString, "Vector%03x", gPropertyInfo[dwIndex].dwStringId + 2);
      sRegistryKey.SetValue(szString, REG_BINARY, (LPBYTE) wszEncryptedString, dwStringLen*2);
    }
  }

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::SetApplicationState(const LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::SetApplicationState ()");

  CLock               sLock(&m_CriticalSection);
  APPLICATION_DATA    sApplicationData;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  memcpy(&sApplicationData, lpApplicationData, sizeof(APPLICATION_DATA));
  if (SUCCEEDED(GetApplicationData(&sApplicationData)))
  {
    sApplicationData.sBaseInfo.dwState = lpApplicationData->sBaseInfo.dwState;
    ValidateApplicationPropertyWithIndex(IDX_PROPERTY_STATE, &sApplicationData);
    SetApplicationData(&sApplicationData, lpInstanceGuid);
  }
  else
  {
    THROW(APPMAN_E_UNKNOWNAPPLICATION);
  }

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::AssignDeviceToApplication(const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::AssignDeviceToApplication ()");

  CLock               sLock(&m_CriticalSection);
  DEVICE_RECORD       sDeviceRecord;

  assert(NULL != lpApplicationData);

  sLock.Lock();

  //
  // Make sure that dwDeviceIndex points to a valid device
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Get the device record
  //

  GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

  //
  // Update the lpApplicationData
  //

  memcpy(&(lpApplicationData->sBaseInfo.sDeviceGuid), &(sDeviceRecord.sDeviceGuid), sizeof(GUID));

  //
  // Validate the field
  //

  ValidateApplicationPropertyWithIndex(IDX_PROPERTY_DEVICEGUID, lpApplicationData);

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::DownsizeApplication(const DWORD dwRequiredKilobytes, const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::DownsizeApplication ()");

  HRESULT               hResult = E_FAIL;
  CHAR                  szExeLine[MAX_PATH_CHARCOUNT];
  CHAR                  szCmdLine[MAX_PATH_CHARCOUNT];
  PROCESS_INFORMATION   sProcessInformation;

  assert(NULL != lpApplicationData);

  //
  // Make sure the application is not locked
  //

  if (S_FALSE == IsApplicationLocked(lpApplicationData))
  {
    //
    // Make sure the setup root path exists
    //

    if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, lpApplicationData))
    {
      THROW(E_UNEXPECTED);
    }

    if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
    {
      DisableApplication(lpApplicationData);
      THROW(APPMAN_E_UNKNOWNAPPLICATION);
    }
       
    //
    // Make sure the application is in a proper state
    //

    if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & lpApplicationData->sBaseInfo.dwState)
    {
      //
      // Make sure the application is not pinned
      //

      if (FALSE == IsApplicationPinned(lpApplicationData))
      {
        //
        // Are we using the IDX_PROPERTY_DOWNSIZECMDLINE or IDX_PROPERTY_DEFAULTSETUPEXECMDLINE
        //

        ZeroMemory(szExeLine, sizeof(szExeLine));
        if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DOWNSIZECMDLINE, lpApplicationData))
        {
          m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DOWNSIZECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DOWNSIZECMDLINE]), szExeLine, sizeof(szExeLine));
        }
        else if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
        {
          m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]), szExeLine, sizeof(szExeLine));
        }

        if (1 < StrLenA(szExeLine))
        {
          //
          // Trigger the wait event
          //

          if (SUCCEEDED(InitializeWaitEvent(lpApplicationData, WAIT_FINALIZE_DOWNSIZE)))
          {
            //
            // Construct the downsize command line
            //

            sprintf(szCmdLine, "%s /action=DOWNSIZE /size=%d /guid={%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} /silent", szExeLine, dwRequiredKilobytes, lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);

            if (m_Win32API.CreateProcess(szCmdLine, &sProcessInformation))
            {
              CloseHandle(sProcessInformation.hThread);
              CloseHandle(sProcessInformation.hProcess);
              hResult = WaitForEventCompletion(lpApplicationData, WAIT_FINALIZE_DOWNSIZE, 150000, 150000);

            }
            else
            {
              KillWaitEvent(lpApplicationData, WAIT_FINALIZE_DOWNSIZE);
            }
          }
        }
      }
      else
      {
        hResult = S_OK;
      }
    }
  }
  else
  {
    hResult = APPMAN_E_OBJECTLOCKED;
  }
        
  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ReInstallApplication(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::ReInstallApplication ()");

  HRESULT               hResult = E_FAIL;
  CHAR                  szExeLine[MAX_PATH_CHARCOUNT];
  CHAR                  szCmdLine[MAX_PATH_CHARCOUNT];
  PROCESS_INFORMATION   sProcessInformation;

  assert(NULL != lpApplicationData);

  //
  // Make sure the application is in a proper state
  //

  if ((APP_STATE_READY | APP_STATE_DOWNSIZED | APP_STATE_DOWNSIZING) & lpApplicationData->sBaseInfo.dwState)
  {
    //
    // Make sure the application root path exists
    //

    if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, lpApplicationData))
    {
      THROW(E_UNEXPECTED);
    }

    if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH]))
    {
      m_Win32API.CreateDirectory(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH], TRUE);
    }

    //
    // Are we using the IDX_PROPERTY_DOWNSIZECMDLINE or IDX_PROPERTY_DEFAULTSETUPEXECMDLINE
    //

    ZeroMemory(szExeLine, sizeof(szExeLine));
    if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_REINSTALLCMDLINE, lpApplicationData))
    {
      m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_REINSTALLCMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_REINSTALLCMDLINE]), szExeLine, sizeof(szExeLine));
    }
    else if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
    {
      m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]), szExeLine, sizeof(szExeLine));
    }

    if (1 < StrLenA(szExeLine))
    {
      //
      // Trigger the wait event
      //

      if (SUCCEEDED(InitializeWaitEvent(lpApplicationData, WAIT_FINALIZE_REINSTALL)))
      {
        //
        // Construct the downsize command line
        //

        sprintf(szCmdLine, "%s /guid={%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} /action=REINSTALL", szExeLine, lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);

        if (m_Win32API.CreateProcess(szCmdLine, &sProcessInformation))
        {
          CloseHandle(sProcessInformation.hThread);
          CloseHandle(sProcessInformation.hProcess);
          hResult = WaitForEventCompletion(lpApplicationData, WAIT_FINALIZE_REINSTALL, 40000, 0xffffffff);
        }
        else
        {
          KillWaitEvent(lpApplicationData, WAIT_FINALIZE_REINSTALL);
        }
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnInstallApplication(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::UnInstallApplication ()");

  HRESULT               hResult = E_FAIL;
  CHAR                  szExeLine[MAX_PATH_CHARCOUNT];
  CHAR                  szCmdLine[MAX_PATH_CHARCOUNT];
  PROCESS_INFORMATION   sProcessInformation;

  assert(NULL != lpApplicationData);

  //
  // Make sure the setup root path exists
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, lpApplicationData))
  {
    THROW(E_UNEXPECTED);
  }

  if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
  {
    DisableApplication(lpApplicationData);
    THROW(APPMAN_E_UNKNOWNAPPLICATION);
  }

  //
  // Are we using the APP_STRING_UNINSTALLCMDLINE or IDX_PROPERTY_DEFAULTSETUPEXECMDLINE
  //

  ZeroMemory(szExeLine, sizeof(szExeLine));
  if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_UNINSTALLCMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_UNINSTALLCMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_UNINSTALLCMDLINE]), szExeLine, sizeof(szExeLine));
  }
  else if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]), szExeLine, sizeof(szExeLine));
  }

  if (1 < StrLenA(szExeLine))
  {
    //
    // Trigger the wait event
    //

    sprintf(szCmdLine, "%s /guid={%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} /action=UNINSTALL", szExeLine, lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);

    if (m_Win32API.CreateProcess(szCmdLine, &sProcessInformation))
    {
      CloseHandle(sProcessInformation.hThread);
      CloseHandle(sProcessInformation.hProcess);
    }
  }
        
  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UnInstallApplicationWait(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInformationManager::UnInstallApplicationWait (const LPAPPLICATION_DATA lpApplicationData)");

  HRESULT               hResult = E_FAIL;
  CHAR                  szExeLine[MAX_PATH_CHARCOUNT];
  CHAR                  szCmdLine[MAX_PATH_CHARCOUNT];
  PROCESS_INFORMATION   sProcessInformation;

  assert(NULL != lpApplicationData);

  //
  // Make sure the setup root path exists
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, lpApplicationData))
  {
    THROW(E_UNEXPECTED);
  }

  if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
  {
    DisableApplication(lpApplicationData);
    THROW(APPMAN_E_UNKNOWNAPPLICATION);
  }

  //
  // Are we using the IDX_PROPERTY_DOWNSIZECMDLINE or IDX_PROPERTY_DEFAULTSETUPEXECMDLINE
  //

  ZeroMemory(szExeLine, sizeof(szExeLine));
  if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_UNINSTALLCMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_UNINSTALLCMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_UNINSTALLCMDLINE]), szExeLine, sizeof(szExeLine));
  }
  else if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]), szExeLine, sizeof(szExeLine));
  }

  if (1 < StrLenA(szExeLine))
  {
    //
    // Trigger the wait event
    //

    if (SUCCEEDED(InitializeWaitEvent(lpApplicationData, WAIT_FINALIZE_UNINSTALL)))
    {
      //
      // Construct the downsize command line
      //

      sprintf(szCmdLine, "%s /guid={%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} /action=UNINSTALL", szExeLine, lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);

      if (m_Win32API.CreateProcess(szCmdLine, &sProcessInformation))
      {
        CloseHandle(sProcessInformation.hThread);
        CloseHandle(sProcessInformation.hProcess);
        hResult = WaitForEventCompletion(lpApplicationData, WAIT_FINALIZE_UNINSTALL, 40000, 0xffffffff);
      }
      else
      {
        KillWaitEvent(lpApplicationData, WAIT_FINALIZE_UNINSTALL);
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::SelfTestApplication(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::SelfTestApplication ()");

  HRESULT               hResult = E_FAIL;
  CHAR                  szExeLine[MAX_PATH_CHARCOUNT];
  CHAR                  szCmdLine[MAX_PATH_CHARCOUNT];
  PROCESS_INFORMATION   sProcessInformation;

  assert(NULL != lpApplicationData);

  //
  // Make sure the setup root path exists
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, lpApplicationData))
  {
    THROW(E_UNEXPECTED);
  }

  if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
  {
    DisableApplication(lpApplicationData);
    THROW(APPMAN_E_UNKNOWNAPPLICATION);
  }

  //
  // Make sure the application root path exists
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, lpApplicationData))
  {
    THROW(E_UNEXPECTED);
  }

  if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH]))
  {
    m_Win32API.CreateDirectory(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH], TRUE);
  }

  //
  // Are we using the IDX_PROPERTY_DOWNSIZECMDLINE or IDX_PROPERTY_DEFAULTSETUPEXECMDLINE
  //

  ZeroMemory(szExeLine, sizeof(szExeLine));
  if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SELFTESTCMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_SELFTESTCMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_SELFTESTCMDLINE]), szExeLine, sizeof(szExeLine));
  }
  else if (S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_DEFAULTSETUPEXECMDLINE, lpApplicationData))
  {
    m_Win32API.WideCharToMultiByte(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE], sizeof(lpApplicationData->wszStringProperty[APP_STRING_DEFAULTSETUPEXECMDLINE]), szExeLine, sizeof(szExeLine));
  }

  if (1 < StrLenA(szExeLine))
  {
    //
    // Trigger the wait event
    //

    if (SUCCEEDED(InitializeWaitEvent(lpApplicationData, WAIT_FINALIZE_SELFTEST)))
    {
      //
      // Construct the downsize command line
      //

      sprintf(szCmdLine, "%s /guid={%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} /action=SELFTEST", szExeLine, lpApplicationData->sBaseInfo.sApplicationGuid.Data1, lpApplicationData->sBaseInfo.sApplicationGuid.Data2, lpApplicationData->sBaseInfo.sApplicationGuid.Data3, lpApplicationData->sBaseInfo.sApplicationGuid.Data4[0], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[1], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[2], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[3], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[4], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[5], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[6], lpApplicationData->sBaseInfo.sApplicationGuid.Data4[7]);

      if (m_Win32API.CreateProcess(szCmdLine, &sProcessInformation))
      {
        CloseHandle(sProcessInformation.hThread);
        CloseHandle(sProcessInformation.hProcess);
        hResult = WaitForEventCompletion(lpApplicationData, WAIT_FINALIZE_SELFTEST, 40000, 0xffffffff);
      }
      else
      {
        KillWaitEvent(lpApplicationData, WAIT_FINALIZE_SELFTEST);
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RunApplication(const LPAPPLICATION_DATA lpApplicationData, const DWORD dwRunFlags, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen)
{
  FUNCTION("CInfoMgr::RunApplication ()");

  HRESULT   hResult = S_OK;

  APPLICATION_DATA      sApplicationData;
  WCHAR                 wszParameters[MAX_PATH_CHARCOUNT];
  WCHAR                 wszCommandLine[MAX_PATH_CHARCOUNT];
  CWin32API             sWin32API;
  BOOL                  fRunning = FALSE;
  PROCESS_INFORMATION   sProcessInformation;

  //
  // Make a local copy of the application object
  //

  memcpy((LPVOID) &sApplicationData, (LPVOID) lpApplicationData, sizeof(sApplicationData));
  hResult = GetApplicationData(&sApplicationData);
  if (FAILED(hResult))
  {
    THROW(hResult);
  }

  //
  // Ready the application
  //

  ReadyApplication(&sApplicationData);

  //
  // Build the command line parameters
  //

  ZeroMemory(wszParameters, sizeof(wszParameters));
  if ((APP_PROPERTY_STR_ANSI == dwStringMask)||(APP_PROPERTY_STR_UNICODE == dwStringMask))
  {
    //
    // Check to make sure the parameters are valid
    //

    if (NULL != lpData)
    {
      if (IsBadReadPtr(lpData, dwDataLen))
      {
        THROW(APPMAN_E_INVALIDPARAMETERS);
      }

      if (0 < dwDataLen)
      {
        //
        // Make sure the command line parameters are converted to unicode
        //

        if (APP_PROPERTY_STR_ANSI == dwStringMask)
        {
          if (MAX_PATH_CHARCOUNT < StrLenA((LPCSTR) lpData))
          {
            THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
          }
          else
          {
            sWin32API.MultiByteToWideChar((LPCSTR) lpData, dwDataLen, wszParameters, MAX_PATH_CHARCOUNT);
          }
        }
        else
        {
          if (MAX_PATH_CHARCOUNT < StrLenW((LPCWSTR) lpData))
          {
            THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
          }
          else
          {
            memcpy(wszParameters, lpData, StrLenW((LPCWSTR) lpData) * 2);
          }
        }
      }
    }
  }
  else
  {
    if (0 != dwStringMask)
    {
      THROW(APPMAN_E_INVALIDPARAMETERS);
    }
  }

  //
  // Construct the command line
  //

  if (1 < StrLenW(wszParameters))
  {
    //
    // Make sure the total lenght does not exceed MAX_PATH_CHARCOUNT
    //

    if (MAX_PATH_CHARCOUNT < (StrLenW(sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE])+StrLenW(wszParameters)))
    {
      THROW(APPMAN_E_INVALIDEXECUTECMDLINE);
    }

    wcscpy(wszCommandLine, sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE]);
    wcscat(wszCommandLine, L" /AppManStarted ");
    wcscat(wszCommandLine, wszParameters);
  }
  else
  {
    wcscpy(wszCommandLine, sApplicationData.wszStringProperty[APP_STRING_EXECUTECMDLINE]);
    wcscat(wszCommandLine, L" /AppManStarted");
  }

  //
  // Run it
  //

  if (sWin32API.CreateProcess(wszCommandLine, &sProcessInformation))
  {
    fRunning = TRUE;
  }
  else
  {
    if (SUCCEEDED(SelfTestApplication(&sApplicationData)))
    {
      if (sWin32API.CreateProcess(wszCommandLine, &sProcessInformation))
      {
        fRunning = TRUE;
      }
      else
      {
        THROW(E_FAIL);
      }
    }
    else
    {
      THROW(E_FAIL);
    }
  }

  if (fRunning)
  {
    sApplicationData.sAgingInfo.dwUsageCount++;
    GetLocalTime(&(sApplicationData.sAgingInfo.stLastUsedDate));
    SetApplicationData(&sApplicationData, NULL);

    if (APP_RUN_BLOCK & dwRunFlags)
    {
      do
      {
        //
        // Make sure to prevent message pump starvation
        //

        MSG Message;

        while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
        {
          TranslateMessage(&Message);
          DispatchMessage(&Message);
        }

        //
        // Give other threads/processes the time to do stuff
        //

        Sleep(100);

      }
      while (WAIT_TIMEOUT == WaitForSingleObject(sProcessInformation.hProcess, 0));
    }

    CloseHandle(sProcessInformation.hThread);
    CloseHandle(sProcessInformation.hProcess);

    hResult = S_OK;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::PinApplication(const LPAPPLICATION_DATA lpApplicationData, BOOL * lpfPinState)
{
  FUNCTION("CInfoMgr::PinApplication ()");

  CLock             sLock(&m_CriticalSection);
  HRESULT           hResult = E_FAIL;
  APPLICATION_DATA  sApplicationData;
  BOOL              fPinState;

  //
  // Lock the application manager
  //

  sLock.Lock();

  //
  // Define the target pin state
  //

  if (NULL == lpfPinState)
  {
    fPinState = FALSE;
  }
  else
  {
    if (FALSE == *lpfPinState)
    {
      fPinState = FALSE;
    }
    else
    {
      fPinState = TRUE;
    }
  }

  //
  // Make a local copy of the application data in order to get the latest information
  //

  memcpy(&sApplicationData, lpApplicationData, sizeof(APPLICATION_DATA));
  if (FAILED(GetApplicationData(&sApplicationData)))
  {
    THROW(APPMAN_E_UNKNOWNAPPLICATION);
  }

  if ((APP_STATE_READY == sApplicationData.sBaseInfo.dwState)||(APP_STATE_DOWNSIZED == sApplicationData.sBaseInfo.dwState))
  {
    //
    // Update the application data with the new pin state
    //

    sApplicationData.sBaseInfo.dwPinState = fPinState;
    hResult = SetApplicationData(&sApplicationData, NULL);
  }
  else
  {
    hResult = APPMAN_E_INVALIDSTATE;
  }

  //
  // Unlock the application manager
  //

  sLock.UnLock();

  return hResult;

}


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ReadyApplication(const LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::ReadyApplication ()");

  ASSOCIATION_INFO  sAssociationInfo;
  HRESULT           hResult = E_FAIL;
  DWORD             dwIndex;

  assert(NULL != lpApplicationData);

  //
  // Find out if any other applications are using this directory
  //

  dwIndex = 0;
  while (S_OK == EnumAssociations(dwIndex, &sAssociationInfo))
  {
    if (0 == memcmp((LPVOID) &lpApplicationData->sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sChildGuid, sizeof(GUID)))
    {
      APPLICATION_DATA      sApplicationData;

      //
      // Check to make sure the parent is in a ready state
      //

      ZeroMemory(&sApplicationData, sizeof(sApplicationData));
      memcpy((LPVOID) &sApplicationData.sBaseInfo.sApplicationGuid, (LPVOID) &sAssociationInfo.sParentGuid, sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      if (FAILED(GetApplicationData(&sApplicationData)))
      {
        THROW(E_UNEXPECTED);
      }

      hResult = ReadyApplication(&sApplicationData);
      if (FAILED(hResult))
      {
        THROW(hResult);
      }
      else
      {
        if (FAILED(GetApplicationData(&sApplicationData)))
        {
          THROW(E_UNEXPECTED);
        }
        else
        {
          if (sApplicationData.sBaseInfo.dwState != APP_STATE_READY)
          {
            THROW(APPMAN_E_PARENTAPPNOTREADY);
          }
        }
      }
    }
    dwIndex++;
  }

  //
  // Make sure the application is in a proper state
  //

  if (APP_STATE_READY != lpApplicationData->sBaseInfo.dwState)
  {
    if (SUCCEEDED(ReInstallApplication(lpApplicationData)))
    {
      if (FAILED(GetApplicationData(lpApplicationData)))
      {
        THROW(E_UNEXPECTED);
      }
      else
      {
        if (APP_STATE_READY != lpApplicationData->sBaseInfo.dwState)
        {
          THROW(APPMAN_E_PARENTAPPNOTREADY);
        }
      }
    }
    else
    {

      THROW(APPMAN_E_PARENTAPPNOTREADY);
    }
  }
  else
  {
    //
    // Well the application reports that it is in a ready state but is it ? Check to make sure
    // the root paths exist. If both are gone, remove the application from the registry
    // and throw APPMAN_E_UNKNOWNAPPLICATION. If the root path is missing, call selftest on
    // the application and ready it.
    //

    if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_APPROOTPATH]))
    {
      if (FALSE == m_Win32API.FileExists(lpApplicationData->wszStringProperty[APP_STRING_SETUPROOTPATH]))
      {
        RemoveApplicationData(lpApplicationData);
        THROW(APPMAN_E_UNKNOWNAPPLICATION);
      }
      else
      {
        if (FAILED(SelfTestApplication(lpApplicationData)))
        {
          THROW(APPMAN_E_PARENTAPPNOTREADY);
        }

        ReadyApplication(lpApplicationData);
      }
    }

  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::DisableApplication(const LPAPPLICATION_DATA lpApplicationData)
{
  APPLICATION_DATA  sApplicationData;
  ASSOCIATION_INFO  sAssociationInfo;
  DWORD             dwIndex;
  HRESULT           hResult;

  //
  // Disable this application
  //

  lpApplicationData->sBaseInfo.dwReservedKilobytes = 0;
  lpApplicationData->sBaseInfo.dwRemovableKilobytes = 0;
  lpApplicationData->sBaseInfo.dwNonRemovableKilobytes = 0;
  lpApplicationData->sBaseInfo.dwState |= APP_STATE_UNSTABLE;
  hResult = SetApplicationData(lpApplicationData, NULL);

  //
  // Disable all of the children of this application
  //

  dwIndex = 0;
  while (S_OK == EnumAssociations(dwIndex, &sAssociationInfo))
  {
    if (0 == memcmp((LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sParentGuid), sizeof(GUID)))
    {
      ZeroMemory(&sApplicationData, sizeof(sApplicationData));
      memcpy((LPVOID) &(sApplicationData.sBaseInfo.sApplicationGuid), (LPVOID) &(sAssociationInfo.sChildGuid), sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sApplicationData);
      if (SUCCEEDED(GetApplicationData(&sApplicationData)))
      {
        hResult = DisableApplication(&sApplicationData);
      }
    }
    dwIndex++;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(DWORD) CInformationManager::GetPropertyIndex(const DWORD dwProperty)
{
  FUNCTION("CInfoMgr::GetPropertyIndex ()");

  DWORD dwIndex;
  DWORD dwPropertyIndex;

  dwIndex = 0;
  dwPropertyIndex = INVALID_PROPERTY_INDEX;
  while ((PROPERTY_COUNT > dwIndex)&&(INVALID_PROPERTY_INDEX == dwPropertyIndex))
  {
    if (gPropertyInfo[dwIndex].dwProperty == dwProperty)
    {
      dwPropertyIndex = dwIndex;
    }
    dwIndex++;
  }
       
  return dwPropertyIndex;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::IsValidApplicationProperty(const DWORD dwProperty)
{
  FUNCTION("CInfoMgr::IsValidApplicationProperty ()");

  HRESULT hResult = S_FALSE;
  DWORD   dwFilteredProperty, dwPropertyModifiers;
  DWORD   dwPropertyIndex;

  //
  // What is the base property
  //

  dwFilteredProperty = dwProperty & 0x0000ffff;
  dwPropertyModifiers = dwProperty & 0xffff0000;
  dwPropertyIndex = GetPropertyIndex(dwFilteredProperty);
  if (INVALID_PROPERTY_INDEX != dwPropertyIndex)
  {
    if ((APP_PROPERTY_STR_ANSI == dwPropertyModifiers)||(APP_PROPERTY_STR_UNICODE == dwPropertyModifiers)||(0 == dwPropertyModifiers))
    {
      hResult = S_OK;
    }
  }
       
  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ValidateApplicationPropertyWithIndex(const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::ValidateApplicationPropertyWithIndex ()");

  lpApplicationData->sBaseInfo.dwLowPropertyMask |= gPropertyInfo[dwPropertyIndex].dwLowPropertyMask;
  lpApplicationData->sBaseInfo.dwHighPropertyMask |= gPropertyInfo[dwPropertyIndex].dwHighPropertyMask;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::InvalidateApplicationPropertyWithIndex(const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::InvalidateApplicationPropertyWithIndex ()");

  lpApplicationData->sBaseInfo.dwLowPropertyMask &= ~(gPropertyInfo[dwPropertyIndex].dwLowPropertyMask);
  lpApplicationData->sBaseInfo.dwHighPropertyMask &= ~(gPropertyInfo[dwPropertyIndex].dwHighPropertyMask);

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::IsApplicationPropertyInitializedWithIndex(const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::IsApplicationPropertyInitializedWithIndex ()");

  HRESULT hResult = S_FALSE;

  if ((lpApplicationData->sBaseInfo.dwLowPropertyMask & gPropertyInfo[dwPropertyIndex].dwLowPropertyMask)||(lpApplicationData->sBaseInfo.dwHighPropertyMask & gPropertyInfo[dwPropertyIndex].dwHighPropertyMask))
  {
    hResult = S_OK;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::DeleteDirectoryTree(LPCSTR lpszDirectory)
{
  FUNCTION("CInfoMgr::DeleteDirectoryTree ()");

  HRESULT hResult = E_FAIL;

  if (m_Win32API.RemoveDirectory(lpszDirectory))
  {
    hResult = S_OK;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::DeleteDirectoryTree(LPCWSTR lpwszDirectory)
{
  FUNCTION("CInfoMgr::DeleteDirectoryTree ()");

  HRESULT   hResult = E_FAIL;
  CHAR      szString[MAX_PATH_CHARCOUNT];

  if (m_Win32API.WideCharToMultiByte(lpwszDirectory, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    hResult = DeleteDirectoryTree(szString);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// The InitializeRegistry() method ensures the following things :
//
// (1) That all the required registry entries are initialized properly
// (2) That the registry entries are in synch with the backup file (if applicable)
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RegInitialize(void)
{
  FUNCTION("CInfoMgr::RegInitialize ()");

  CLock               sLock(&m_CriticalSection);
  CRegistryKey        sRegistryKey;
  APPLICATION_DATA    sApplicationData;
  DWORD               dwKeyDisposition, dwDWORD;
  TEMP_SPACE_RECORD   sTempSpaceRecord;
  CHAR                szValueName[MAX_PATH_CHARCOUNT];
  WCHAR               wszDirectory[MAX_PATH_CHARCOUNT];
  DWORD               dwIndex, dwCounter;
  DWORD               dwDataType, dwDataLen, dwDataValue, dwValueLen;

  sLock.Lock();

  //
  // Open the root key
  //

  if (S_FALSE == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan"))
  {
    //
    // Hum the root key doesn't exist, let's see if we can create it. Otherwise return APPMAN_E_REINSTALLDX
    //

    THROW(APPMAN_E_REINSTALLDX);
  }

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_ALL_ACCESS);

  //
  // Make sure the AppMan version is the right version
  //

  if (S_OK == sRegistryKey.CheckForExistingValue("AppManVersion"))
  {
    dwDataLen = sizeof(dwDataValue);
    sRegistryKey.GetValue("AppManVersion", &dwDataType, (BYTE *) &dwDataValue, &dwDataLen);
    if (REG_VERSION > dwDataValue)
    {
      THROW(APPMAN_E_REINSTALLDX);
    }
  }

  //
  // Initialize the AppMan\ReferenceCounter value
  //

  dwDWORD = 0;
  sRegistryKey.SetValue("ReferenceCount", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));

  //
  // Initialize the AppMan\Version value
  //

  if (S_FALSE == sRegistryKey.CheckForExistingValue("AppManVersion"))
  {
    dwDWORD = REG_VERSION;
    sRegistryKey.SetValue("AppManVersion", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));
  }

  //
  // Initialize wait event extra wait vars
  //

  if (S_FALSE == sRegistryKey.CheckForExistingValue("WaitEntryEventExtraTime"))
  {
    dwDWORD = 0;
    sRegistryKey.SetValue("WaitEntryEventExtraTime", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));
  }

  if (S_FALSE == sRegistryKey.CheckForExistingValue("WaitLeaveEventExtraTime"))
  {
    dwDWORD = 0;
    sRegistryKey.SetValue("WaitLeaveEventExtraTime", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));
  }

  //
  // Initialize the AppMan\DefaultCacheSize
  //

  if (S_FALSE == sRegistryKey.CheckForExistingValue("DefaultPercentCacheSize"))
  {
    dwDWORD = DEFAULT_PERCENT_CACHE_SIZE;
    sRegistryKey.SetValue("DefaultPercentCacheSize", REG_DWORD, (const BYTE *) &dwDWORD, sizeof(dwDWORD));
  }

  //
  // Insert the original APPLICATION_MANAGER_RECORD
  //

  if (S_FALSE == sRegistryKey.CheckForExistingValue("Vector000"))
  {
    APPLICATION_MANAGER_RECORD  sApplicationManagerRecord;

    sApplicationManagerRecord.dwSize = sizeof(APPLICATION_MANAGER_RECORD);
    sApplicationManagerRecord.dwStructId = APPLICATION_MANAGER_STRUCT;
    if (FAILED(CoCreateGuid(&sApplicationManagerRecord.sSystemGuid)))
    {
      THROW(E_UNEXPECTED);
    }
    sApplicationManagerRecord.dwAdvancedMode = FALSE;
    sRegistryKey.SetValue("Vector000", REG_BINARY, (LPBYTE) &sApplicationManagerRecord, sizeof(APPLICATION_MANAGER_RECORD));
  }

  //
  // Create the AppMan\Devices key.
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Create the AppMan\Applications key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Applications", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Create the AppMan\Associations key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Associations", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Create the AppMan\TempAllocation key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\TempSpaceAllocation", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Create the AppMan\Cleanup key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Cleanup", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Get rid of any leftover locks
  //

  if (S_OK == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock"))
  {
    sRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock");
  }

  //
  // Create the AppMan\Lock key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Lock", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Make sure that any leftover wait events are deleted
  //

  if (S_OK == sRegistryKey.CheckForExistingKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent"))
  {
    sRegistryKey.DeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent");
  }

  //
  // Create the AppMan\Lock key
  //

  sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, &dwKeyDisposition);

  //
  // Clean up the directories if required
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Cleanup", KEY_ALL_ACCESS);

  dwIndex = 0;
  ZeroMemory(szValueName, sizeof(szValueName));
  ZeroMemory(wszDirectory, sizeof(wszDirectory));
  dwValueLen = sizeof(szValueName);
  dwDataLen = sizeof(wszDirectory);
  while (S_OK == sRegistryKey.EnumValues(dwIndex, szValueName, &dwValueLen, &dwDataType, (LPBYTE) wszDirectory, &dwDataLen))
  {
    //
    // Decrypt the cleanup directory
    //

    for (dwCounter = 0; dwCounter < (dwDataLen/2)-1; dwCounter++)
    {
      wszDirectory[dwCounter] ^= 0xffffffff;
    }

    //
    // Attempt to delete the directory to be cleaned up
    //

    if (1 < StrLenW(wszDirectory))
    {
      m_Win32API.RemoveDirectory(wszDirectory);
      if (!m_Win32API.FileExists(wszDirectory))
      {
        sRegistryKey.DeleteValue(szValueName);
      }
      else
      {
        dwIndex++;
      }
    }

    //
    // Get ready for the next loop
    //

    ZeroMemory(szValueName, sizeof(szValueName));
    ZeroMemory(wszDirectory, sizeof(wszDirectory));
    dwValueLen = sizeof(szValueName);
    dwDataLen = sizeof(wszDirectory);
  }

  //
  // Scan through each application record and make sure that none of them have
  // any reserved space assigned to them
  //

  dwIndex = 0;
  while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
  {
    if (0 < sApplicationData.sBaseInfo.dwReservedKilobytes)
    {
      sApplicationData.sBaseInfo.dwReservedKilobytes = 0;
      InvalidateApplicationPropertyWithIndex(IDX_PROPERTY_ESTIMATEDINSTALLKILOBYTES, &sApplicationData);
      SetApplicationData(&sApplicationData, NULL);
    }
    dwIndex++;
  }

  //
  // Scan through the temporary directories and delete them
  //

  dwIndex = 0;
  while (S_OK == EnumTempSpace(dwIndex, &sTempSpaceRecord))
  {
    if (FAILED(RemoveTempSpace(&sTempSpaceRecord)))
    {
      dwIndex++;
    }
  }

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  //
  // Scan through the devices and update their information
  //

  ScanDevices();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RegFutureDirectoryCleanup(LPCWSTR lpwszDirectory)
{
  FUNCTION("CInfoMgr::RegFutureDirectoryCleanup ()");

  CLock               sLock(&m_CriticalSection);
  CRegistryKey        sRegistryKey;
  DWORD               dwDefaultValue, dwIndex;
  GUID                sGuid;
  HRESULT             hResult = E_FAIL;
  CHAR                szValueName[64];
  WCHAR               wszDirectory[MAX_PATH_CHARCOUNT+1];

  sLock.Lock();

  //
  // Encrypt the key.
  //

  dwIndex = 0;
  while (0 != lpwszDirectory[dwIndex])
  {
    wszDirectory[dwIndex] = (WCHAR)(lpwszDirectory[dwIndex] ^ 0xffffffff);
    dwIndex++;
  }
  wszDirectory[dwIndex] = 0;

  //
  // Generate a unique value name for the key
  //

  if (FAILED(CoCreateGuid(&sGuid)))
  {
    THROW(E_UNEXPECTED);
  }
  sprintf(szValueName, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sGuid.Data1, sGuid.Data2, sGuid.Data3, sGuid.Data4[0], sGuid.Data4[1], sGuid.Data4[2], sGuid.Data4[3], sGuid.Data4[4], sGuid.Data4[5], sGuid.Data4[6], sGuid.Data4[7]);

  //
  // Add the directory name to the AppMan\Cleanup registry key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Cleanup", KEY_ALL_ACCESS);
  dwDefaultValue = 1;
  sRegistryKey.SetValue(szValueName, REG_BINARY, (LPBYTE) wszDirectory, (dwIndex+1)*2);

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return hResult;  
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::InitializeWaitEvent(LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent)
{
  FUNCTION("CInfoMgr::InitializeWaitEvent()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  WAIT_INFO       sWaitInfo;
  GUID            sEncryptedGuid;
  CHAR            szGuid[40];
  DWORD           dwDataType, dwDataSize;
  HRESULT         hResult = E_FAIL;

  //
  // Make sure that lpApplicationData and dwWaitEvent are valid
  //

  if ((NULL == lpApplicationData)||(IsBadReadPtr(lpApplicationData, sizeof(APPLICATION_DATA)))||(WAIT_EVENT_COUNT <= dwWaitEvent))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Lock the information manager
  //

  sLock.Lock();

  //
  // Open the root registry key for the wait events
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", KEY_ALL_ACCESS);

  //
  // Make sure we have a valid application guid within lpApplicationData
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Computer the encrypted guid for lpApplicationData
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Initialize the local sWaitEvent to Zero
  //

  ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));

  //
  // Is there an existing event initialized for lpApplicationGuid
  //

  if (S_OK == sRegistryKey.CheckForExistingValue(szGuid))
  {
    //
    // There is already a wait event in the system. Let's check to see if the wait event
    // conflicts with this one or whether or not we can just add to it.
    //

    dwDataSize = sizeof(sWaitInfo);
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);
    if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
    {
      //
      // The registry entry is bogus, delete it
      //

      sRegistryKey.DeleteValue(szGuid);
      ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));
    }
  }

  //
  // Initialize the wait event if possible
  //

  if (0 != sWaitInfo.dwEventCount[dwWaitEvent])
  {
    THROW(E_UNEXPECTED);
  }
  else
  {
    sWaitInfo.dwEventCount[dwWaitEvent] = 0xffffffff;
  }

  //
  // Write out the event
  //

  sWaitInfo.dwSize = sizeof(sWaitInfo);
  sWaitInfo.dwStructId = WAIT_STRUCT;
  hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sWaitInfo, sizeof(sWaitInfo));

  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  //
  // unlock the information manager
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::EnterWaitEvent(LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent, const GUID * lpInstanceGuid)
{
  FUNCTION("CInfoMgr::EnterWaitEvent()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  WAIT_INFO       sWaitInfo;
  GUID            sEncryptedGuid;
  CHAR            szGuid[40];
  DWORD           dwDataType, dwDataSize;
  HRESULT         hResult = E_FAIL;

  //
  // Lock the information manager
  //

  sLock.Lock();

  //
  // Open the root registry key for the wait events
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", KEY_ALL_ACCESS);

  //
  // Make sure we have a valid application guid within lpApplicationData
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Computer the encrypted guid for lpApplicationData
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Initialize the local sWaitEvent to Zero
  //

  ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));

  //
  // Is there an existing event initialized for lpApplicationGuid
  //

  if (S_OK == sRegistryKey.CheckForExistingValue(szGuid))
  {
    //
    // There is already a wait event in the system. Let's check to see if the wait event
    // conflicts with this one or whether or not we can just add to it.
    //

    dwDataSize = sizeof(sWaitInfo);
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);
    if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Initialize the wait event if possible
    //

    if (0xffffffff == sWaitInfo.dwEventCount[dwWaitEvent])
    {
      sWaitInfo.dwEventCount[dwWaitEvent] = 1;
    }
    else if (0 < sWaitInfo.dwEventCount[dwWaitEvent])
    {
      (sWaitInfo.dwEventCount[dwWaitEvent])++;
    }

    //
    // Save the instance guid
    //

    if (NULL != lpInstanceGuid)
    {
      memcpy(&sWaitInfo.guidInstanceGuid, lpInstanceGuid, sizeof(GUID));
    }

    //
    // Write out the event
    //

    sWaitInfo.dwSize = sizeof(sWaitInfo);
    sWaitInfo.dwStructId = WAIT_STRUCT;
    hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sWaitInfo, sizeof(sWaitInfo));
  }  

  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  //
  // unlock the information manager
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::LeaveWaitEvent(LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent)
{
  FUNCTION("CInfoMgr::LeaveWaitEvent()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  WAIT_INFO       sWaitInfo;
  GUID            sEncryptedGuid;
  CHAR            szGuid[40];
  DWORD           dwDataType, dwDataSize;
  HRESULT         hResult = E_FAIL;

  //
  // Lock the information manager
  //

  sLock.Lock();

  //
  // Open the root registry key for the wait events
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", KEY_ALL_ACCESS);

  //
  // Make sure we have a valid application guid within lpApplicationData
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Computer the encrypted guid for lpApplicationData
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Initialize the local sWaitEvent to Zero
  //

  ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));

  //
  // Is there an existing event initialized for lpApplicationGuid
  //

  if (S_OK == sRegistryKey.CheckForExistingValue(szGuid))
  {
    //
    // There is already a wait event in the system. Let's check to see if the wait event
    // conflicts with this one or whether or not we can just add to it.
    //

    dwDataSize = sizeof(sWaitInfo);
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);
    if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Initialize the wait event if possible
    //

    if ((0 < sWaitInfo.dwEventCount[dwWaitEvent])&&(0xffffffff != sWaitInfo.dwEventCount[dwWaitEvent]))
    {
      sWaitInfo.dwEventCount[dwWaitEvent]--;
    }


    //
    // Write out the event
    //

    sWaitInfo.dwSize = sizeof(sWaitInfo);
    sWaitInfo.dwStructId = WAIT_STRUCT;
    hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sWaitInfo, sizeof(sWaitInfo));
  }

  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  //
  // unlock the information manager
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::WaitForEventCompletion(LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent, const DWORD dwEntryMilliseconds, const DWORD dwExitMilliseconds)
{
  FUNCTION("CInfoMgr::WaitForEventCompletion()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  WAIT_INFO       sWaitInfo;
  GUID            sEncryptedGuid;
  CHAR            szGuid[40];
  DWORD           dwStartTime;
  DWORD           dwDataType, dwDataSize;
  DWORD           dwEntryTime, dwExitTime;
  BOOL            fDone;
  HRESULT         hResult = E_FAIL;

  //
  // Open the root registry key for the wait events
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", KEY_ALL_ACCESS);

  //
  // Make sure we have a valid application guid within lpApplicationData
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Computer the encrypted guid for lpApplicationData
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Initialize the local sWaitEvent to Zero
  //

  ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));

  //
  // Add bias to wait times
  //

  dwEntryTime = dwEntryMilliseconds + GetExtraWaitEventEntryTime();
  dwExitTime = dwExitMilliseconds + GetExtraWaitEventExitTime();

  //
  // Wait for the event to start
  //



  dwStartTime = GetTickCount();
  fDone = FALSE;
  do
  {
    //
    // Lock the information manager
    //

    sLock.Lock();

    //
    // Read in the event record
    //

    dwDataSize = sizeof(sWaitInfo);
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);

    if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
    {
      THROW(E_UNEXPECTED);
    }

    //
    // unlock the information manager
    //

    sLock.UnLock();

    //
    // Is the event started
    //

     if (0xffffffff == sWaitInfo.dwEventCount[dwWaitEvent])
    {
      //
      // Make sure to prevent message pump starvation
      //

      MSG Message;

      while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
      {
        TranslateMessage(&Message);
        DispatchMessage(&Message);
      }

      //
      // Give other threads/processes the time to do stuff
      //

      Sleep(100);
    }
    else if (0 <= sWaitInfo.dwEventCount[dwWaitEvent])
    {
      fDone = TRUE;
    }
  }
  while ((FALSE == fDone)&&(dwEntryTime > (GetTickCount() - dwStartTime)));

  if (TRUE == fDone)
  {
    //
    // Wait for the event to end
    //

    dwStartTime = GetTickCount();
    fDone = FALSE;
    do
    {
      //
      // Lock the information manager
      //

      sLock.Lock();

      //
      // Read in the event record
      //

      dwDataSize = sizeof(sWaitInfo);
      sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);

      if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
      {
        THROW(E_UNEXPECTED);
      }

      //
      // Is the event over
      //

      if (0xffffffff == sWaitInfo.dwEventCount[dwWaitEvent])
      {
        THROW(E_UNEXPECTED);
      }
      else if (0 == sWaitInfo.dwEventCount[dwWaitEvent])
      {
        fDone = TRUE;

        //
        // Should we delete the wait event from the registry
        //
        
        if (0 == (sWaitInfo.dwEventCount[WAIT_FINALIZE_DOWNSIZE] + sWaitInfo.dwEventCount[WAIT_FINALIZE_REINSTALL] + sWaitInfo.dwEventCount[WAIT_FINALIZE_UNINSTALL] + sWaitInfo.dwEventCount[WAIT_FINALIZE_SELFTEST]))
        {
          sRegistryKey.DeleteValue(szGuid);
        }

        //
        // Did the owner thread die on us
        //

        if (S_FALSE == IsInstanceGuidStillAlive(&sWaitInfo.guidInstanceGuid))
        {
          if (S_OK == sRegistryKey.CheckForExistingValue(szGuid))
          {
            sRegistryKey.DeleteValue(szGuid);
          }
        }
      }

      //
      // unlock the information manager
      //

      sLock.UnLock();

      //
      // Should we sleep ?
      //

      if (FALSE == fDone)
      {
        //
        // Make sure to prevent message pump starvation
        //

        MSG Message;

        while (PeekMessage(&Message, NULL, 0, 0, PM_REMOVE))
        {
          TranslateMessage(&Message);
          DispatchMessage(&Message);
        }

        //
        // Give other threads/processes the time to do stuff
        //

        Sleep(100);
      }
    }
    while ((FALSE == fDone)&&(dwExitTime > (GetTickCount() - dwStartTime)));

    //
    // Did the event finish
    //

    if (TRUE == fDone)
    {
      hResult = S_OK;
    }
  }
  else
  {
    //
    // The wait event has expired unsuccessfully. We will now delete the wait event since it
    // will no longer be used
    //

    sRegistryKey.DeleteValue(szGuid);
  }

  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::KillWaitEvent(LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent)
{
  FUNCTION("CInfoMgr::KillWaitEvent()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  WAIT_INFO       sWaitInfo;
  GUID            sEncryptedGuid;
  CHAR            szGuid[40];
  DWORD           dwDataType, dwDataSize;
  HRESULT         hResult = E_FAIL;

  //
  // Lock the information manager
  //

  sLock.Lock();

  //
  // Open the root registry key for the wait events
  //          

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\WaitEvent", KEY_ALL_ACCESS);

  //
  // Make sure we have a valid application guid within lpApplicationData
  //

  if (S_OK != IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_GUID, lpApplicationData))
  {
    THROW(APPMAN_E_REQUIREDPROPERTIESMISSING);
  }

  //
  // Computer the encrypted guid for lpApplicationData
  //

  memcpy((LPVOID) &sEncryptedGuid, (LPVOID) &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));
  EncryptGuid(&sEncryptedGuid);
  sprintf(szGuid, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sEncryptedGuid.Data1, sEncryptedGuid.Data2, sEncryptedGuid.Data3, sEncryptedGuid.Data4[0], sEncryptedGuid.Data4[1], sEncryptedGuid.Data4[2], sEncryptedGuid.Data4[3], sEncryptedGuid.Data4[4], sEncryptedGuid.Data4[5], sEncryptedGuid.Data4[6], sEncryptedGuid.Data4[7]);

  //
  // Initialize the local sWaitEvent to Zero
  //

  ZeroMemory(&sWaitInfo, sizeof(sWaitInfo));

  //
  // Is there an existing event initialized for lpApplicationGuid
  //

  if (S_OK == sRegistryKey.CheckForExistingValue(szGuid))
  {
    //
    // There is already a wait event in the system. Let's check to see if the wait event
    // conflicts with this one or whether or not we can just add to it.
    //

    dwDataSize = sizeof(sWaitInfo);
    sRegistryKey.GetValue(szGuid, &dwDataType, (LPBYTE) &sWaitInfo, &dwDataSize);
    if ((REG_BINARY != dwDataType)||(sizeof(sWaitInfo) != dwDataSize))
    {
      THROW(E_UNEXPECTED);
    }

    //
    // Initialize the wait event if possible
    //

    if (0xffffffff != sWaitInfo.dwEventCount[dwWaitEvent])
    {
      THROW(E_UNEXPECTED);
    }
    else
    {
      sWaitInfo.dwEventCount[dwWaitEvent] = 0;
    }
  }  

  //
  // Should we delete the event or write the update record to the registry
  //

  if (0 == (sWaitInfo.dwEventCount[WAIT_FINALIZE_DOWNSIZE] + sWaitInfo.dwEventCount[WAIT_FINALIZE_REINSTALL] + sWaitInfo.dwEventCount[WAIT_FINALIZE_UNINSTALL] + sWaitInfo.dwEventCount[WAIT_FINALIZE_SELFTEST]))
  {
    sRegistryKey.DeleteValue(szGuid);
  }
  else
  {
    //
    // Write out the event
    //

    sWaitInfo.dwSize = sizeof(sWaitInfo);
    sWaitInfo.dwStructId = WAIT_STRUCT;
    hResult = sRegistryKey.SetValue(szGuid, REG_BINARY, (LPBYTE) &sWaitInfo, sizeof(sWaitInfo));
  }


  //
  // Close the registry
  //

  sRegistryKey.CloseKey();

  //
  // unlock the information manager
  //

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::CheckDeviceExistance(const DWORD dwDeviceIndex)
{
  FUNCTION("CInfoMgr::CheckDeviceExistance ()");

  CLock           sLock(&m_CriticalSection);
  CRegistryKey    sRegistryKey;
  TCHAR           szString[MAX_PATH_CHARCOUNT];
  HRESULT         hResult = S_FALSE;

  sLock.Lock();

  //
  // Open the AppMan\Devices key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices"), KEY_ALL_ACCESS);

  //
  // Add the device record to the registry
  //

  sprintf(szString, "[0x%08x]", dwDeviceIndex);
  hResult = sRegistryKey.CheckForExistingValue(szString);

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CInformationManager::GetDeviceIndex(const DWORD dwVolumeSerial)
{
  CHAR    szString[MAX_PATH_CHARCOUNT];
  DWORD   dwDeviceIndex, dwReturnValue, dwTempVolumeSerial;

  dwDeviceIndex = 0;
  dwReturnValue = 0xffffffff;

  while ((0xffffffff == dwReturnValue)&&(MAX_DEVICES > dwDeviceIndex))
  {
    sprintf(szString, "%c:\\", dwDeviceIndex + 65);
    if (DRIVE_FIXED == m_Win32API.GetDriveType(szString))
    {
      if (m_Win32API.IsDriveFormatted(szString))
      {
        if ((m_Win32API.GetVolumeInformation(szString, NULL, 0, &dwTempVolumeSerial))&&(dwVolumeSerial == dwTempVolumeSerial))
        {
          dwReturnValue = dwDeviceIndex;
        }
      }
    }

    dwDeviceIndex++;
  }

  return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::AddDeviceWithIndex(const DWORD dwDeviceIndex)
{
  FUNCTION("CInfoMgr::AddDeviceIndex ()");

  CLock           sLock(&m_CriticalSection);
  TCHAR           szString[10];
  DEVICE_RECORD   sDeviceRecord;

  sLock.Lock();

  //
  // Initialize the device info
  //

  sprintf(szString, "%c:\\", dwDeviceIndex + 65);
  if (!m_Win32API.GetVolumeInformation(szString, NULL, 0, &(sDeviceRecord.sDeviceInfo.dwVolumeSerial)))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // create the device record
  //

  if (FAILED(CoCreateGuid(&(sDeviceRecord.sDeviceGuid))))
  {
    THROW(E_UNEXPECTED);
  }
  sDeviceRecord.sDeviceInfo.dwDeviceIndex = dwDeviceIndex;
  sDeviceRecord.sDeviceInfo.dwDeviceFlags = DRIVE_FIXED;
  sDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask = 0;
  sDeviceRecord.sDeviceInfo.dwPercentCacheSize = DEFAULT_PERCENT_CACHE_SIZE;
  sDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize = 100;
  sDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes = 0;
  sDeviceRecord.sDeviceInfo.dwRemovableKilobytes = 0;
  sDeviceRecord.sDeviceInfo.dwReservedKilobytes = 0;
  sDeviceRecord.sDeviceInfo.dwLastUsedThreshold = 0;

  //
  // Set the device info
  //

  SetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RemoveDeviceWithIndex(const DWORD dwDeviceIndex)
{
  FUNCTION("CInfoMgr::RemoveDeviceIndex ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  TCHAR         szString[MAX_PATH_CHARCOUNT];

  sLock.Lock();

  //
  // Open the AppMan\Devices key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices"), KEY_ALL_ACCESS);

  //
  // Get the GUID of the device at dwDeviceIndex
  //

  sprintf(szString, "[0x%08x]", dwDeviceIndex);
  if (S_OK == sRegistryKey.CheckForExistingValue(szString))
  {
    sRegistryKey.DeleteValue(szString);
  }

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::UpdateDeviceInfoWithIndex(const DWORD dwDeviceIndex)
{
  FUNCTION("CInfoMgr::UpdateDeviceInfoWithIndex ()");

  CLock             sLock(&m_CriticalSection);
  DEVICE_RECORD     sDeviceRecord;
  APPLICATION_DATA  sApplicationData;
  DWORD             dwIndex;
  WCHAR             wszString[MAX_PATH_CHARCOUNT];
  CWin32API         sWin32API;

  sLock.Lock();

  //
  // Make sure the device really exists
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_UNEXPECTED);
  }

  swprintf(wszString, L"%c:\\", dwDeviceIndex + 65);
  if (m_Win32API.IsDriveFormatted(wszString))
  {
    //
    // Get the device record
    //

    GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

    //
    // Initialize the sDeviceRecord
    //

    sDeviceRecord.sDeviceInfo.dwRemovableKilobytes = 0;
    sDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes = 0;
    sDeviceRecord.sDeviceInfo.dwReservedKilobytes = 0;
    sDeviceRecord.sDeviceInfo.dwLastUsedThreshold = 0;

    //  
    // Enumerate all of the applications on the system and verify that they do really exist
    // (i.e. both setup root path and application root path are there). If the setup root
    // path is missin, remove the game from the cache
    //

    dwIndex = 0;
    while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
    {
      if ((S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_SETUPROOTPATH, &sApplicationData))&&(S_OK == IsApplicationPropertyInitializedWithIndex(IDX_PROPERTY_ROOTPATH, &sApplicationData)))
      {
        if (FALSE == sWin32API.FileExists(sApplicationData.wszStringProperty[APP_STRING_SETUPROOTPATH]))
        {
          DisableApplication(&sApplicationData);
        }
      }
      dwIndex++;
    }

    //
    // Enumerate all of the applications on the system and consider those that belong
    // to this device
    //

    dwIndex = 0;
    while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
    {
      //
      // Is the application assigned to this device
      //

      if (!memcmp(&(sApplicationData.sBaseInfo.sDeviceGuid), &(sDeviceRecord.sDeviceGuid), sizeof(GUID)))
      {
        //
        // Is the application in an installing state ?
        //

        if (APP_STATE_INSTALLING != sApplicationData.sBaseInfo.dwState)
        {
          //
          // Update the device information
          //

          if (FALSE == sApplicationData.sBaseInfo.dwPinState)
          {
            sDeviceRecord.sDeviceInfo.dwRemovableKilobytes += sApplicationData.sBaseInfo.dwRemovableKilobytes;
            sDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes += sApplicationData.sBaseInfo.dwNonRemovableKilobytes;
          }
          else
          {
            sDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes += sApplicationData.sBaseInfo.dwNonRemovableKilobytes + sApplicationData.sBaseInfo.dwRemovableKilobytes;
          }

          if ((0 < sApplicationData.sBaseInfo.dwReservedKilobytes)&&(S_FALSE == IsInstanceGuidStillAlive(&sApplicationData.sBaseInfo.sInstanceGuid)))
          {
            //
            // The application has some reserved space assigned to it but it is no longer valid
            //

            sApplicationData.sBaseInfo.dwReservedKilobytes = 0;
            SetApplicationData(&sApplicationData, NULL);
          }

          sDeviceRecord.sDeviceInfo.dwReservedKilobytes += sApplicationData.sBaseInfo.dwReservedKilobytes;
        }
        else
        {
          if ((0 < sApplicationData.sBaseInfo.dwReservedKilobytes)&&(S_FALSE == IsInstanceGuidStillAlive(&sApplicationData.sBaseInfo.sInstanceGuid)))
          {
            //
            // The application has some reserved space assigned to it but it is no longer valid
            //

            sApplicationData.sBaseInfo.dwReservedKilobytes = 0;
            SetApplicationData(&sApplicationData, NULL);
          }

          sDeviceRecord.sDeviceInfo.dwReservedKilobytes += sApplicationData.sBaseInfo.dwReservedKilobytes;
        }
      }
      dwIndex++;
    }

    //
    // Update the device record
    //

    SetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
  }

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ScanDevices(void)
{
  FUNCTION("CInfoMgr::ScanDevices ()");

  CLock     sLock(&m_CriticalSection);
  HRESULT   hResult;

  sLock.Lock();

  hResult = ScanDevices(0);

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::ScanDevices(const DWORD dwDeviceIndex)
{
  FUNCTION("CInfoMgr::ScanDevices ()");

  HRESULT   hResult = S_OK;

  if (MAX_DEVICES > dwDeviceIndex)
  {
    CHAR            szString[MAX_PATH_CHARCOUNT];
    DEVICE_RECORD   sDeviceRecord;
    DEVICE_RECORD   sExistingDeviceRecord;
    BOOL            fGuidAlreadyAssigned = FALSE;
    DWORD           dwIndex;

    ZeroMemory(&sExistingDeviceRecord, sizeof(sExistingDeviceRecord));

    //
    // What does the system say about the device at dwDeviceIndex
    //

    sprintf(szString, "%c:\\", dwDeviceIndex + 65);
    if (DRIVE_FIXED == m_Win32API.GetDriveType(szString))
    {
      //
      // Get the volume serial of the device if it is formatted
      //

      if (m_Win32API.IsDriveFormatted(szString))
      {
        //
        // Initialize the existing device record
        //

        ZeroMemory(&(sExistingDeviceRecord.sDeviceGuid), sizeof(GUID));
        sExistingDeviceRecord.sDeviceInfo.dwDeviceIndex = dwDeviceIndex;
        sExistingDeviceRecord.sDeviceInfo.dwDeviceFlags = DRIVE_FIXED;
        sExistingDeviceRecord.sDeviceInfo.dwApplicationCategoryExclusionMask = 0;
        sExistingDeviceRecord.sDeviceInfo.dwPercentCacheSize = DEFAULT_PERCENT_CACHE_SIZE;
        sExistingDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize = 100;
        sExistingDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes = 0;
        sExistingDeviceRecord.sDeviceInfo.dwRemovableKilobytes = 0;
        sExistingDeviceRecord.sDeviceInfo.dwReservedKilobytes = 0;
        sExistingDeviceRecord.sDeviceInfo.dwLastUsedThreshold = 0;

        //
        // Get the volume serial information
        //

        m_Win32API.GetVolumeInformation(szString, NULL, 0, &sExistingDeviceRecord.sDeviceInfo.dwVolumeSerial);

        //
        // Enumerate the devices recorded inside AppMan and figure out if one of them already
        // has this volume serial. Record the Guid of the device for later use
        //

        for (dwIndex = 0; dwIndex < MAX_DEVICES; dwIndex++)
        {
          if (S_OK == CheckDeviceExistance(dwIndex))
          {
            //
            // Get the existing record
            //

            hResult = GetDeviceInfoWithIndex(dwIndex, &sDeviceRecord);
            if (FAILED(hResult))
            {
              THROW(E_UNEXPECTED);
            }

            //
            // Is the currently enumerated device the target record we are looking for
            //

            if (sExistingDeviceRecord.sDeviceInfo.dwVolumeSerial == sDeviceRecord.sDeviceInfo.dwVolumeSerial)
            {
              fGuidAlreadyAssigned = TRUE;
              memcpy(&sExistingDeviceRecord, &sDeviceRecord, sizeof(sDeviceRecord));
              sExistingDeviceRecord.sDeviceInfo.dwDeviceIndex = dwDeviceIndex;
            }
          }
        }
      }
    }

    //
    // Recursively go to the next device
    //

    ScanDevices(dwDeviceIndex + 1);
    RemoveDeviceWithIndex(dwDeviceIndex);
    if (SUCCEEDED(hResult))
    {
      if (0 != sExistingDeviceRecord.sDeviceInfo.dwVolumeSerial)
      {
        if (TRUE == fGuidAlreadyAssigned)
        {
          SetDeviceInfoWithIndex(dwDeviceIndex, &sExistingDeviceRecord);
          UpdateDeviceInfoWithIndex(dwDeviceIndex);
        }
        else
        {
          if (m_Win32API.IsDriveFormatted(szString))
          {
            AddDeviceWithIndex(dwDeviceIndex);
          }
        }
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetDeviceInfo(LPDEVICE_RECORD lpDeviceRecord)
{
  FUNCTION("CInfoMgr::GetDeviceInfo ()");

  DEVICE_RECORD   sDeviceRecord;
  DWORD           dwDeviceIndex;
  HRESULT         hResult = E_FAIL;

  assert(NULL != lpDeviceRecord);

  //
  // Enumerate all of the devices and find the one that matches
  //

  dwDeviceIndex = 0;
  while ((FAILED(hResult))&&(MAX_DEVICES > dwDeviceIndex))
  {
    if (S_OK == CheckDeviceExistance(dwDeviceIndex))
    {
      GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
      if (!memcmp(&(sDeviceRecord.sDeviceGuid), &(lpDeviceRecord->sDeviceGuid), sizeof(GUID)))
      {
        memcpy(lpDeviceRecord, &sDeviceRecord, sizeof(DEVICE_RECORD));
        hResult = S_OK;
      }
    }
    dwDeviceIndex++;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetDeviceInfoWithIndex(const DWORD dwDeviceIndex, LPDEVICE_RECORD lpDeviceRecord)
{
  FUNCTION("CInfoMgr::GetDeviceInfoWithIndex ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  TCHAR         szString[MAX_PATH_CHARCOUNT];
  DWORD         dwDataType, dwDataLen;

  assert(NULL != lpDeviceRecord);

  //
  // Does the device exist
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_FAIL);
  }

  sLock.Lock();

  //
  // Open the AppMan\Devices key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices"), KEY_ALL_ACCESS);

  //
  // Get the GUID of the device at dwDeviceIndex
  //

  sprintf(szString, "[0x%08x]", dwDeviceIndex);
  if (S_FALSE == sRegistryKey.CheckForExistingValue(szString))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Get the device info from the registry and make sure it is valid
  //

  dwDataLen = sizeof(DEVICE_RECORD);
  sRegistryKey.GetValue(szString, &dwDataType, (LPBYTE) lpDeviceRecord, &dwDataLen);
  if ((REG_BINARY != dwDataType)||(sizeof(DEVICE_RECORD) != dwDataLen))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::SetDeviceInfoWithIndex(const DWORD dwDeviceIndex, LPDEVICE_RECORD lpDeviceRecord)
{
  FUNCTION("CInfoMgr::SetDeviceInfoWithIndex ()");

  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  TCHAR         szString[MAX_PATH_CHARCOUNT];

  assert(NULL != lpDeviceRecord);

  sLock.Lock();

  //
  // Open the AppMan\Devices key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Devices"), KEY_ALL_ACCESS);

  //
  // Get the GUID of the device at dwDeviceIndex
  //

  sprintf(szString, "[0x%08x]", dwDeviceIndex);
  sRegistryKey.SetValue(szString, REG_BINARY, (LPBYTE) lpDeviceRecord, sizeof(DEVICE_RECORD));

  //
  // Close sRegistryKey
  //
  
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetDeviceSpaceInfoWithIndex(const DWORD dwDeviceIndex, LPDEVICE_SPACE_INFO lpDeviceSpaceInfo)
{
  FUNCTION("CInfoMgr::GetDeviceSpaceInfoWithIndex ()");

  CLock             sLock(&m_CriticalSection);
  DEVICE_RECORD     sDeviceRecord;
  TEMP_SPACE_RECORD sTempSpaceRecord;
  TCHAR             szString[MAX_PATH_CHARCOUNT];
  DWORD             dwTheoreticalMaximumAvailableKilobytes, dwIndex;

  sLock.Lock();

  //
  // Make sure the device really exists
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // update and retrieve the device information
  //

  UpdateDeviceInfoWithIndex(dwDeviceIndex);
  GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

  //
  // How much temporary reserved space is there ?
  //

  lpDeviceSpaceInfo->dwTotalReservedTemporaryKilobytes = 0;
  lpDeviceSpaceInfo->dwTotalUsedTemporaryKilobytes = 0;

  dwIndex = 0;
  while (S_OK == EnumTempSpace(dwIndex, &sTempSpaceRecord))
  {
    if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &sTempSpaceRecord.sDeviceGuid, sizeof(GUID)))
    {
      lpDeviceSpaceInfo->dwTotalReservedTemporaryKilobytes += sTempSpaceRecord.dwKilobytes;
      lpDeviceSpaceInfo->dwTotalUsedTemporaryKilobytes += m_Win32API.GetDirectorySize(sTempSpaceRecord.wszDirectory);
    }
    dwIndex++;
  }

  //
  // Get the basic numbers
  //

  sprintf(szString, "%c:\\", dwDeviceIndex + 65);
  lpDeviceSpaceInfo->dwTotalKilobytes = m_Win32API.GetDriveSize(szString);
  lpDeviceSpaceInfo->dwTotalFreeKilobytes = m_Win32API.GetDriveFreeSpace(szString);
  lpDeviceSpaceInfo->dwCacheSizeKilobytes = sDeviceRecord.sDeviceInfo.dwPercentCacheSize * (lpDeviceSpaceInfo->dwTotalKilobytes / 100);
  lpDeviceSpaceInfo->dwMinimumFreeKilobytes = sDeviceRecord.sDeviceInfo.dwPercentMinimumFreeSize * (lpDeviceSpaceInfo->dwTotalKilobytes / 100);
  lpDeviceSpaceInfo->dwTotalRemovableKilobytes = sDeviceRecord.sDeviceInfo.dwRemovableKilobytes;
  lpDeviceSpaceInfo->dwTotalNonRemovableKilobytes = sDeviceRecord.sDeviceInfo.dwNonRemovableKilobytes + sDeviceRecord.sDeviceInfo.dwReservedKilobytes + lpDeviceSpaceInfo->dwTotalReservedTemporaryKilobytes;
  lpDeviceSpaceInfo->dwOptimalRemovableKilobytes = lpDeviceSpaceInfo->dwTotalRemovableKilobytes >> 1; 
  lpDeviceSpaceInfo->dwCacheUsedKilobytes = lpDeviceSpaceInfo->dwTotalRemovableKilobytes + lpDeviceSpaceInfo->dwTotalNonRemovableKilobytes;

  //
  // How many free kilobytes do we have in the cache and if not how many kilobytes are spilling over
  // in the slack space
  //

  if (lpDeviceSpaceInfo->dwCacheSizeKilobytes > lpDeviceSpaceInfo->dwCacheUsedKilobytes)
  {
    lpDeviceSpaceInfo->dwCacheFreeKilobytes = min(lpDeviceSpaceInfo->dwCacheSizeKilobytes - lpDeviceSpaceInfo->dwCacheUsedKilobytes, (lpDeviceSpaceInfo->dwTotalFreeKilobytes - (sDeviceRecord.sDeviceInfo.dwReservedKilobytes + lpDeviceSpaceInfo->dwTotalReservedTemporaryKilobytes)));
    lpDeviceSpaceInfo->dwSlackUsedKilobytes = 0;
  }
  else
  {
    lpDeviceSpaceInfo->dwCacheFreeKilobytes = 0;
    lpDeviceSpaceInfo->dwSlackUsedKilobytes = lpDeviceSpaceInfo->dwCacheUsedKilobytes - lpDeviceSpaceInfo->dwCacheSizeKilobytes;
  }

  //
  // How big is the slack space
  //  

  if (lpDeviceSpaceInfo->dwTotalFreeKilobytes > (lpDeviceSpaceInfo->dwMinimumFreeKilobytes + lpDeviceSpaceInfo->dwCacheFreeKilobytes))
  {
    lpDeviceSpaceInfo->dwSlackSizeKilobytes = lpDeviceSpaceInfo->dwSlackUsedKilobytes + lpDeviceSpaceInfo->dwTotalFreeKilobytes - (lpDeviceSpaceInfo->dwMinimumFreeKilobytes + lpDeviceSpaceInfo->dwCacheFreeKilobytes);
  }
  else
  {
    lpDeviceSpaceInfo->dwSlackSizeKilobytes = 0;
  }  

  //
  // How much free slack space do we have left over
  //

  if (lpDeviceSpaceInfo->dwSlackSizeKilobytes > lpDeviceSpaceInfo->dwSlackUsedKilobytes)
  {
    lpDeviceSpaceInfo->dwSlackFreeKilobytes = min(lpDeviceSpaceInfo->dwSlackSizeKilobytes - lpDeviceSpaceInfo->dwSlackUsedKilobytes, lpDeviceSpaceInfo->dwTotalFreeKilobytes);
  }
  else
  {
    lpDeviceSpaceInfo->dwSlackFreeKilobytes = 0;
  }

  //
  // What is the theoretical maximum amount of kilobytes that could be made available
  //

  if ((lpDeviceSpaceInfo->dwCacheSizeKilobytes + lpDeviceSpaceInfo->dwSlackSizeKilobytes) < lpDeviceSpaceInfo->dwTotalNonRemovableKilobytes )
  {
    dwTheoreticalMaximumAvailableKilobytes = 0;
  }
  else
  {
    dwTheoreticalMaximumAvailableKilobytes = lpDeviceSpaceInfo->dwCacheSizeKilobytes + lpDeviceSpaceInfo->dwSlackSizeKilobytes - lpDeviceSpaceInfo->dwTotalNonRemovableKilobytes;
  }

  //
  // Compute the final values
  //

  lpDeviceSpaceInfo->dwTotalUsableFreeKilobytes = lpDeviceSpaceInfo->dwCacheFreeKilobytes + lpDeviceSpaceInfo->dwSlackFreeKilobytes;
  lpDeviceSpaceInfo->dwMaximumUsableKilobytes = min((lpDeviceSpaceInfo->dwCacheFreeKilobytes + lpDeviceSpaceInfo->dwSlackFreeKilobytes + lpDeviceSpaceInfo->dwTotalRemovableKilobytes), dwTheoreticalMaximumAvailableKilobytes);
  lpDeviceSpaceInfo->dwOptimalUsableKilobytes = min((lpDeviceSpaceInfo->dwCacheFreeKilobytes + lpDeviceSpaceInfo->dwSlackFreeKilobytes + lpDeviceSpaceInfo->dwOptimalRemovableKilobytes), dwTheoreticalMaximumAvailableKilobytes);
  lpDeviceSpaceInfo->dwTotalReservedKilobytes = sDeviceRecord.sDeviceInfo.dwReservedKilobytes;

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetDeviceOptimalSpaceWithIndex(const DWORD dwDeviceIndex, LPDWORD lpdwKilobytes)
{
  FUNCTION("CInfoMgr::GetDeviceOptimalSpaceWithIndex ()");

  DEVICE_SPACE_INFO sDeviceSpaceInfo;

  //
  // Make sure the device really exists
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // update and retrieve the device information
  //

  GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);

  //
  // Calculate the optimal size available
  //

  *lpdwKilobytes = sDeviceSpaceInfo.dwOptimalUsableKilobytes;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetDeviceMaximumSpaceWithIndex(const DWORD dwDeviceIndex, LPDWORD lpdwKilobytes)
{
  FUNCTION("CInfoMgr::GetDeviceMaximumSpaceWithIndex()");

  DEVICE_SPACE_INFO sDeviceSpaceInfo;

  //
  // Make sure the device really exists
  //

  if (S_FALSE == CheckDeviceExistance(dwDeviceIndex))
  {
    THROW(E_UNEXPECTED);
  }

  //
  // update and retrieve the device information
  //

  GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);

  //
  // Calculate the maximum size available
  //

  *lpdwKilobytes = sDeviceSpaceInfo.dwMaximumUsableKilobytes;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::FreeSpaceOnDeviceWithIndex(const DWORD dwDeviceIndex, const DWORD dwRequiredKilobytes)
{
  FUNCTION("CInfoMgr::FreeSpaceOnDeviceWithIndex ()");

  APPLICATION_DATA    sApplicationData;
  DEVICE_SPACE_INFO   sDeviceSpaceInfo;
  DWORD               dwNeededKilobytes = 0;
  HRESULT             hResult = APPMAN_E_NODISKSPACEAVAILABLE;

  //
  // Get the device space information
  //

  GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);

  //
  // Check to see whether or not we even have a chance at getting the space in the first place
  //

  if (dwRequiredKilobytes > sDeviceSpaceInfo.dwMaximumUsableKilobytes)
  {
    THROW(APPMAN_E_NODISKSPACEAVAILABLE);
  }

  //
  // Compute the amount of Kilobytes that are needed
  //

  if (dwRequiredKilobytes > sDeviceSpaceInfo.dwTotalUsableFreeKilobytes)
  {
    dwNeededKilobytes = dwRequiredKilobytes - sDeviceSpaceInfo.dwTotalUsableFreeKilobytes;

    //
    // We start off with the oldest application in the system
    //

    if (S_OK == GetOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData))
    {
      do
      {
        //
        // Downsize sApplicationRecord
        //

        if (0 < sApplicationData.sBaseInfo.dwRemovableKilobytes)
        {
          if (S_FALSE == IsApplicationLocked(&sApplicationData))
          {
            DownsizeApplication(dwNeededKilobytes, &sApplicationData);
          }
        }

        //
        // Recomputer the amount of Kilobytes needed
        //

        GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);
        if (dwRequiredKilobytes > sDeviceSpaceInfo.dwTotalUsableFreeKilobytes)
        {
          dwNeededKilobytes = dwRequiredKilobytes - sDeviceSpaceInfo.dwTotalUsableFreeKilobytes;
        }
        else
        {
          dwNeededKilobytes = 0;
        }
      } 
      while ((0 < dwNeededKilobytes)&&(S_OK == GetNextOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData)));
    }
  }

  //
  // Did we succeed ?
  //

  if (0 == dwNeededKilobytes)
  {
    hResult = S_OK;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::FixCacheOverrun(const GUID * lpDeviceGuid, const DWORD dwExtraKilobytes)
{
  FUNCTION("CInfoMgr::FixCacheOverrun()");

  APPLICATION_DATA    sApplicationData = {0};
  DEVICE_RECORD       sDeviceRecord = {0};
  DEVICE_SPACE_INFO   sDeviceSpaceInfo = {0};
  DWORD               dwDeviceIndex;
  DWORD               dwNeededKilobytes, dwCacheUsedKilobytes, dwCacheSizeKilobytes;
  HRESULT             hResult = APPMAN_E_NODISKSPACEAVAILABLE;

  //
  // Enumerate all of the devices and find the one that matches
  //

  dwDeviceIndex = 0;
  while ((FAILED(hResult))&&(MAX_DEVICES > dwDeviceIndex))
  {
    if (S_OK == CheckDeviceExistance(dwDeviceIndex))
    {
      GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);
      if (!memcmp(&(sDeviceRecord.sDeviceGuid), lpDeviceGuid, sizeof(GUID)))
      {
        hResult = S_OK;
        break;
      }
    }
    dwDeviceIndex++;
  }

  if (SUCCEEDED(hResult))
  {
    //
    // Get the device space information
    //

    hResult = GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);
    if (SUCCEEDED(hResult))
    {
      //
      // What is the maximum possible cache size ?
      //

      dwCacheSizeKilobytes = sDeviceRecord.sDeviceInfo.dwPercentCacheSize * (sDeviceSpaceInfo.dwTotalKilobytes / 100);
      dwCacheUsedKilobytes = sDeviceSpaceInfo.dwCacheUsedKilobytes + dwExtraKilobytes;

      //
      // Check to see whether or not we even have a chance at getting the space in the first place
      //

      if (dwCacheUsedKilobytes > dwCacheSizeKilobytes)
      {
        //
        // How many kilobytes do we need to free up on the device
        //

        dwNeededKilobytes = dwCacheUsedKilobytes - dwCacheSizeKilobytes;

        //
        // By default, we set the hResult value prior to calling GetOldest...
        //

        hResult = APPMAN_E_CACHEOVERRUN;

        //
        // We start off with the oldest application in the system
        //

        if (S_OK == GetOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData))
        {
          do
          {
            //
            // Downsize sApplicationRecord
            //

            if (0 < sApplicationData.sBaseInfo.dwRemovableKilobytes)
            {
              if (S_FALSE == IsApplicationLocked(&sApplicationData))
              {
                DownsizeApplication(dwNeededKilobytes, &sApplicationData);
              }
            }

            //
            // Recomputer the amount of Kilobytes needed
            //

            hResult = GetDeviceSpaceInfoWithIndex(dwDeviceIndex, &sDeviceSpaceInfo);
            if (FAILED(hResult))
            {
              THROW(hResult);
            }

            //
            // Now that we have downsized a title, how many used kilobytes are there in
            // the cache
            //

            dwCacheUsedKilobytes = sDeviceSpaceInfo.dwCacheUsedKilobytes + dwExtraKilobytes;

            //
            // Should we keep going
            //

            if (dwCacheUsedKilobytes <= dwCacheSizeKilobytes)
            {
              hResult = S_OK;
            }
            else
            {
              hResult = APPMAN_E_CACHEOVERRUN;
            }
          }
          while ((FAILED(hResult))&&(S_OK == GetNextOldestApplicationDataByDeviceWithIndex(dwDeviceIndex, &sApplicationData)));
        }
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the number of elapsed minutes since October 25th 1968 (my birthday)
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CInformationManager::GetAgingCount(LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::GetAgingCount ()");
  
  APPLICATION_DATA  sChildData;
  ASSOCIATION_INFO  sAssociationInfo;
  DWORD             dwIndex;
  DWORD             dwElapsedSeconds, dwChildElapsedSeconds;

  dwElapsedSeconds = GetAgingCountInSeconds(&lpApplicationData->sAgingInfo);
  dwChildElapsedSeconds = 0;
  dwIndex = 0;
  while (S_OK == EnumAssociations(dwIndex, &sAssociationInfo))
  {
    if (0 == memcmp(&(lpApplicationData->sBaseInfo.sApplicationGuid), &(sAssociationInfo.sParentGuid), sizeof(GUID)))
    {
      ZeroMemory(&sChildData, sizeof(sChildData));
      memcpy(&(sChildData.sBaseInfo.sApplicationGuid), &(sAssociationInfo.sChildGuid), sizeof(GUID));
      ValidateApplicationPropertyWithIndex(IDX_PROPERTY_GUID, &sChildData);
      if (FAILED(GetApplicationData(&sChildData)))
      {
        THROW(E_UNEXPECTED);
      }
      dwChildElapsedSeconds = GetAgingCount(&sChildData);
      if (dwChildElapsedSeconds >= dwElapsedSeconds)
      {
        dwElapsedSeconds = dwChildElapsedSeconds + 1;
      }
    }
    dwIndex++;
  }

  OutputDebugString(MakeString("App %s %s is %d seconds old", lpApplicationData->wszStringProperty[APP_STRING_COMPANYNAME], lpApplicationData->wszStringProperty[APP_STRING_SIGNATURE], dwElapsedSeconds));

  return dwElapsedSeconds;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetOldestApplicationDataByDeviceWithIndex(const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::GetOldestApplicationDataByDeviceWithIndex ()");

  CLock               sLock(&m_CriticalSection);
  DEVICE_RECORD       sDeviceRecord;
  APPLICATION_DATA    sApplicationData;
  DWORD               dwIndex;
  HRESULT             hResult = E_FAIL;

  sLock.Lock();

  //
  // Get the device information
  //

  if (FAILED(GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord)))
  {
    THROW(APPMAN_E_INVALIDINDEX);
  }

  //
  // By default, lpApplicationRecord will represent the first viable application
  //

  dwIndex = 0;
  do
  {
    hResult = GetApplicationDataWithIndex(dwIndex, lpApplicationData);
    dwIndex++;
    if (SUCCEEDED(hResult))
    {
      if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &lpApplicationData->sBaseInfo.sDeviceGuid, sizeof(GUID)))
      {
        if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & lpApplicationData->sBaseInfo.dwState)
        {
          break;
        }
      }
    }
  } 
  while (SUCCEEDED(hResult));

  //
  // If we have a viable initial application record, we move on to try and find the oldest one
  //

  if (SUCCEEDED(hResult))
  {
    //
    // Now we enumerate the remaining application and figure out which one is the oldest
    //

    while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
    {
      if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &sApplicationData.sBaseInfo.sDeviceGuid, sizeof(GUID)))
      {
        if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & sApplicationData.sBaseInfo.dwState)
        {
          if (GetAgingCount(&sApplicationData) < GetAgingCount(lpApplicationData))
          {
            memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
          }
          else
          {
            if (GetAgingCount(&sApplicationData) == GetAgingCount(lpApplicationData))
            {
              //
              // Both applications have the same aging count. We use the application guid as a bias to decide
              // which of the two apps is actually older
              //

              if (0 < memcmp(&(lpApplicationData->sBaseInfo.sApplicationGuid), &(sApplicationData.sBaseInfo.sApplicationGuid), sizeof(GUID)))
              {
                memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
              }
            }
          }
        }
      }
      dwIndex++;
    }
  }

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::GetNextOldestApplicationDataByDeviceWithIndex(const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData)
{
  FUNCTION("CInfoMgr::GetNextOldestApplicationDataByDeviceWithIndex ()");

  CLock               sLock(&m_CriticalSection);
  DEVICE_RECORD       sDeviceRecord;
  APPLICATION_DATA    sApplicationData;
  DWORD               dwOriginalAgeInSeconds;
  GUID                sOriginalApplicationGuid;
  DWORD               dwIndex;
  HRESULT             hResult = E_FAIL;

  sLock.Lock();

  //
  // Save the original information
  //

  dwOriginalAgeInSeconds = GetAgingCount(lpApplicationData);
  memcpy(&sOriginalApplicationGuid, &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID));

  //
  // Get the device information
  //

  if (FAILED(GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord)))
  {
    THROW(APPMAN_E_INVALIDINDEX);
  }

  //
  // By default, lpApplicationRecord will represent the first viable application
  //

  dwIndex = 0;
  do
  {
    hResult = GetApplicationDataWithIndex(dwIndex, lpApplicationData);
    dwIndex++;
    if (SUCCEEDED(hResult))
    {
      if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &lpApplicationData->sBaseInfo.sDeviceGuid, sizeof(GUID)))
      {
        if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & lpApplicationData->sBaseInfo.dwState)
        {
          break;
        }
      }
    }
  } 
  while (SUCCEEDED(hResult));

  //
  // First we need to find the newest application
  //

  if (SUCCEEDED(hResult))
  {
    //
    // Now we enumerate the remaining application and figure out which one is the newest
    //

    while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
    {
      if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &sApplicationData.sBaseInfo.sDeviceGuid, sizeof(GUID)))
      {
        if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & sApplicationData.sBaseInfo.dwState)
        {
          if (GetAgingCount(&sApplicationData) > GetAgingCount(lpApplicationData))
          {
            memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
          }
          else
          {
            if (GetAgingCount(&sApplicationData) == GetAgingCount(lpApplicationData))
            {
              //
              // Both applications have the same aging count. We use the application guid as a bias to decide
              // which of the two apps is actually older
              //

              if (0 < memcmp(&(sApplicationData.sBaseInfo.sApplicationGuid), &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
              {
                memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
              }
            }
          }
        }
      }
      dwIndex++;
    }

    //
    // Ok we have the newest application represented by lpApplicationRecor. Now we go looking
    // for the Oldest app that is newer that dwOriginalAgeInSeconds
    //

    dwIndex = 0;
    while (SUCCEEDED(GetApplicationDataWithIndex(dwIndex, &sApplicationData)))
    {
      if (0 == memcmp((LPVOID) &sDeviceRecord.sDeviceGuid, (LPVOID) &sApplicationData.sBaseInfo.sDeviceGuid, sizeof(GUID)))
      {
        if ((APP_STATE_READY | APP_STATE_DOWNSIZED) & sApplicationData.sBaseInfo.dwState)
        {
          //
          // Is sApplicationRecord older than lpApplicationRecord 
          //

          if (GetAgingCount(&sApplicationData) < GetAgingCount(lpApplicationData))
          {
            //
            // Is sApplicationRecord newer than sAgingInfo
            //

            if (GetAgingCount(&sApplicationData) > dwOriginalAgeInSeconds)
            {
              memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
            }
            else
            {
              if (GetAgingCount(&sApplicationData) == GetAgingCount(lpApplicationData))
              {
                //
                // Both applications have the same aging count. We use the application guid as a bias to decide
                // which of the two apps is actually older
                //

                if (0 < memcmp(&(sApplicationData.sBaseInfo.sApplicationGuid), &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
                {
                  memcpy(lpApplicationData, &(sApplicationData), sizeof(APPLICATION_DATA));
                }
              }
            }
          }
        }
      }
      dwIndex++;
    }
  }

  //
  // Check to make sure that lpApplicationRecord represents a valid application record
  //

  if (SUCCEEDED(hResult))
  {
    //
    // Ok now we need to check and make sure that the outgoing lpApplicationRecord is not identical
    // to the incoming one (i.e. in the case where we only have a single app in system, this will
    // occur
    //

    if (!memcmp(&sOriginalApplicationGuid, &(lpApplicationData->sBaseInfo.sApplicationGuid), sizeof(GUID)))
    {
      ZeroMemory(lpApplicationData, sizeof(APPLICATION_DATA));
      hResult = E_FAIL;
    }
    else
    {
      hResult = S_OK;
    }
  }

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::AddTempSpace(LPTEMP_SPACE_RECORD lpTempSpaceRecord)
{
  FUNCTION("CInfoMgr::AddTempSpace ()");

  CLock               sLock(&m_CriticalSection);
  DWORD               dwDeviceIndex;
  HRESULT             hResult;
  CWin32API           Win32API;
  DEVICE_RECORD       sDeviceRecord;
  CRegistryKey        sRegistryKey;
  CHAR                szString[MAX_PATH_CHARCOUNT];

  hResult = GetSpace(0, lpTempSpaceRecord->dwKilobytes, &dwDeviceIndex);
  if (SUCCEEDED(hResult))
  {
    sLock.Lock();

    //
    // update and retrieve the device information
    //

    UpdateDeviceInfoWithIndex(dwDeviceIndex);
    GetDeviceInfoWithIndex(dwDeviceIndex, &sDeviceRecord);

    //
    // Fill in the TEMP_SPACE_RECORD var
    //

    if (FAILED(CoCreateGuid(&lpTempSpaceRecord->sGuid)))
    {
      THROW(E_UNEXPECTED);
    }
    memcpy((LPVOID) &lpTempSpaceRecord->sDeviceGuid, (LPVOID) &sDeviceRecord.sDeviceGuid, sizeof(GUID));
    swprintf(lpTempSpaceRecord->wszDirectory, L"%c:\\Temp\\{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", dwDeviceIndex + 65, lpTempSpaceRecord->sGuid.Data1, lpTempSpaceRecord->sGuid.Data2, lpTempSpaceRecord->sGuid.Data3, lpTempSpaceRecord->sGuid.Data4[0], lpTempSpaceRecord->sGuid.Data4[1], lpTempSpaceRecord->sGuid.Data4[2], lpTempSpaceRecord->sGuid.Data4[3], lpTempSpaceRecord->sGuid.Data4[4], lpTempSpaceRecord->sGuid.Data4[5], lpTempSpaceRecord->sGuid.Data4[6], lpTempSpaceRecord->sGuid.Data4[7]);

    //
    // Add the entry to the registry
    //

    sRegistryKey.CreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\TempSpaceAllocation", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, TRUE, NULL);
    sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", lpTempSpaceRecord->sGuid.Data1, lpTempSpaceRecord->sGuid.Data2, lpTempSpaceRecord->sGuid.Data3, lpTempSpaceRecord->sGuid.Data4[0], lpTempSpaceRecord->sGuid.Data4[1], lpTempSpaceRecord->sGuid.Data4[2], lpTempSpaceRecord->sGuid.Data4[3], lpTempSpaceRecord->sGuid.Data4[4], lpTempSpaceRecord->sGuid.Data4[5], lpTempSpaceRecord->sGuid.Data4[6], lpTempSpaceRecord->sGuid.Data4[7]);
    sRegistryKey.SetValue(szString, REG_BINARY, (LPBYTE) lpTempSpaceRecord, sizeof(TEMP_SPACE_RECORD));

    //
    // Create the directory
    //

    Win32API.CreateDirectory(lpTempSpaceRecord->wszDirectory, FALSE);

    sLock.UnLock();
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RemoveTempSpace(LPTEMP_SPACE_RECORD lpTempSpaceRecord)
{
  FUNCTION("CInfoMgr::RemoveTempSpace ()");

  CLock               sLock(&m_CriticalSection);
  TEMP_SPACE_RECORD   sTempSpaceRecord;
  DWORD               dwIndex;
  HRESULT             hResult = E_FAIL;
  CWin32API           Win32API;
  CRegistryKey        sRegistryKey;
  CHAR                szString[MAX_PATH_CHARCOUNT];
  BOOL                fRemoved;

  sLock.Lock();

  //
  // First we need to find the matching entry (based on path and sApplicationGuid)
  //

  fRemoved = FALSE;
  dwIndex = 0;
  while (S_OK == EnumTempSpace(dwIndex, &sTempSpaceRecord))
  {
    //
    // Does the enumerated temp space belong to the current application
    //

    if (0 == memcmp((LPVOID) &sTempSpaceRecord.sApplicationGuid, (LPVOID) &lpTempSpaceRecord->sApplicationGuid, sizeof(GUID)))
    {
      //
      // Does the enumerated temp space have the same directory
      //

      if (0 == _wcsnicmp(sTempSpaceRecord.wszDirectory, lpTempSpaceRecord->wszDirectory, MAX_PATH_CHARCOUNT))
      {
        //
        // This is the winner. Let's wack it
        //

        //
        // Delete the directory
        //

        if (FAILED(DeleteDirectoryTree(sTempSpaceRecord.wszDirectory)))
        {
          RegFutureDirectoryCleanup(sTempSpaceRecord.wszDirectory);
        }

        //
        // Remove the entry from the registry
        //

        sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\TempSpaceAllocation", KEY_ALL_ACCESS);
        sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sTempSpaceRecord.sGuid.Data1, sTempSpaceRecord.sGuid.Data2, sTempSpaceRecord.sGuid.Data3, sTempSpaceRecord.sGuid.Data4[0], sTempSpaceRecord.sGuid.Data4[1], sTempSpaceRecord.sGuid.Data4[2], sTempSpaceRecord.sGuid.Data4[3], sTempSpaceRecord.sGuid.Data4[4], sTempSpaceRecord.sGuid.Data4[5], sTempSpaceRecord.sGuid.Data4[6], sTempSpaceRecord.sGuid.Data4[7]);
        hResult = sRegistryKey.DeleteValue(szString);
        fRemoved = TRUE;
      }
    }
    dwIndex++;
  }
  
  sLock.UnLock();

  //
  // Did we actually find the matching temp space entry and remove it ?
  //

  if (FALSE == fRemoved)
  {
    hResult = APPMAN_E_INVALIDDATA;
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::EnumTempSpace(const DWORD dwIndex, LPTEMP_SPACE_RECORD lpTempSpaceRecord)
{
  FUNCTION("CInfoMgr::EnumTempSpace ()");

  CLock               sLock(&m_CriticalSection);
  CRegistryKey        sRegistryKey;
  TEMP_SPACE_RECORD   sTempSpaceRecord;
  HRESULT             hResult = S_OK;
  DWORD               dwLoopIndex, dwTargetIndex, dwStringLen, dwSize, dwType;
  CHAR                szString[MAX_PATH_CHARCOUNT];

  sLock.Lock();

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\TempSpaceAllocation", KEY_READ);
 
  //
  // Because of the way the registry works, we have to start enumerating keys with
  // a starting index of 0 and increment constantly until we get to the desired index
  //

  dwTargetIndex = dwIndex;
  dwLoopIndex = 0;
  while ((dwLoopIndex <= dwTargetIndex)&&(S_OK == hResult))
  {
    dwStringLen = MAX_PATH_CHARCOUNT;
    dwSize = sizeof(sTempSpaceRecord);
    hResult = sRegistryKey.EnumValues(dwLoopIndex, szString, &dwStringLen, &dwType, (LPBYTE) &sTempSpaceRecord, &dwSize);
    if (S_OK == hResult)
    {
      if (dwSize != sizeof(sTempSpaceRecord))
      {
        dwTargetIndex++;
      }
    }
    dwLoopIndex++;
  }

  if (S_OK == hResult)
  {
    memcpy((LPVOID) lpTempSpaceRecord, (LPVOID) &sTempSpaceRecord, sizeof(TEMP_SPACE_RECORD));
  }
  else
  {
    hResult = APPMAN_E_INVALIDINDEX;
  }

  sRegistryKey.CloseKey();

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::AddAssociation(LPASSOCIATION_INFO lpAssociationInfo)
{
  FUNCTION("CInfoMgr::AddAssociation ()");

  CLock               sLock(&m_CriticalSection);
  CRegistryKey        sRegistryKey;
  CHAR                szString[MAX_PATH_CHARCOUNT];
  GUID                sAssociationGuid;

  sLock.Lock();

  //
  // Open the root registry key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Associations", KEY_ALL_ACCESS);

  //
  // Assign a GUID to the association
  //

  if (FAILED(CoCreateGuid(&sAssociationGuid)))
  {
    THROW(E_UNEXPECTED);
  }

  sprintf(szString, "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", sAssociationGuid.Data1, sAssociationGuid.Data2, sAssociationGuid.Data3, sAssociationGuid.Data4[0], sAssociationGuid.Data4[1], sAssociationGuid.Data4[2], sAssociationGuid.Data4[3], sAssociationGuid.Data4[4], sAssociationGuid.Data4[5], sAssociationGuid.Data4[6], sAssociationGuid.Data4[7]);
  sRegistryKey.SetValue(szString, REG_BINARY, (LPBYTE) lpAssociationInfo, sizeof(ASSOCIATION_INFO));

  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::RemoveAssociation(LPASSOCIATION_INFO lpAssociationInfo)
{
  FUNCTION("CInfoMgr::RemoveAssociation ()");

  CLock             sLock(&m_CriticalSection);
  CRegistryKey      sRegistryKey;
  ASSOCIATION_INFO  sAssociationInfo;
  CHAR              szString[MAX_PATH_CHARCOUNT];
  DWORD             dwIndex, dwValueNameLen, dwDataType, dwDataLen;

  sLock.Lock();

  //
  // Open the root registry key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Associations", KEY_ALL_ACCESS);

  //
  // Enumerate all of the associations and find the matching one
  //

  dwIndex = 0;
  dwDataLen = sizeof(ASSOCIATION_INFO);
  dwValueNameLen = MAX_PATH_CHARCOUNT;
  while (S_OK == sRegistryKey.EnumValues(dwIndex, szString, &dwValueNameLen, &dwDataType, (LPBYTE) &sAssociationInfo, &dwDataLen))
  {
    //
    // Did we find the match
    //

    if (!memcmp(&sAssociationInfo, lpAssociationInfo, sizeof(ASSOCIATION_INFO)))
    {
      sRegistryKey.DeleteValue(szString);
      break;
    }
    dwIndex++;
    dwDataLen = sizeof(ASSOCIATION_INFO);
    dwValueNameLen = MAX_PATH_CHARCOUNT;
  }

  sRegistryKey.CloseKey();

  sLock.UnLock();

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CInformationManager::EnumAssociations(const DWORD dwTargetIndex, LPASSOCIATION_INFO lpAssociationInfo)
{
  FUNCTION("CInfoMgr::EnumAssociations ()");

  CLock             sLock(&m_CriticalSection);
  CRegistryKey      sRegistryKey;
  ASSOCIATION_INFO  sAssociationInfo;
  CHAR              szString[MAX_PATH_CHARCOUNT];
  HRESULT           hResult;
  DWORD             dwIndex, dwValueNameLen, dwDataType, dwDataLen;

  sLock.Lock();

  //
  // Open the root registry key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan\\Associations", KEY_ALL_ACCESS);

  //
  // Enumerate all of the associations and find the matching one
  //

  dwIndex = 0;
  do
  {
    dwDataLen = sizeof(ASSOCIATION_INFO);
    dwValueNameLen = MAX_PATH_CHARCOUNT;
    hResult = sRegistryKey.EnumValues(dwIndex, szString, &dwValueNameLen, &dwDataType, (LPBYTE) &sAssociationInfo, &dwDataLen);
    dwIndex++;
  }
  while ((dwIndex <= dwTargetIndex)&&(S_OK == hResult));

  //
  // Did the while loop terminate because we read in our target entry ?
  //

  if (S_OK == hResult)
  {
    memcpy((LPVOID) lpAssociationInfo, (LPVOID) &sAssociationInfo, sizeof(ASSOCIATION_INFO));
  }
  else
  {
    hResult = APPMAN_E_INVALIDINDEX;
  }

  sRegistryKey.CloseKey();

  sLock.UnLock();

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the number of extra milliseconds that AppMan should wait for an Entry event
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CInformationManager::GetExtraWaitEventEntryTime(void)
{
  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  DWORD         dwType, dwSize;
  DWORD         dwWaitTime = 0;

  sLock.Lock();

  //
  // Open the root AppMan key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_READ);
  dwSize = sizeof(dwWaitTime);
  sRegistryKey.GetValue("WaitEntryEventExtraTime", &dwType, (BYTE *) &dwWaitTime, &dwSize);
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return dwWaitTime;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the number of extra milliseconds that AppMan should wait for a Leave event
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CInformationManager::GetExtraWaitEventExitTime(void)
{
  CLock         sLock(&m_CriticalSection);
  CRegistryKey  sRegistryKey;
  DWORD         dwType, dwSize;
  DWORD         dwWaitTime = 0;

  sLock.Lock();

  //
  // Open the root AppMan key
  //

  sRegistryKey.OpenKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppMan", KEY_READ);
  dwSize = sizeof(dwWaitTime);
  sRegistryKey.GetValue("WaitLeaveEventExtraTime", &dwType, (BYTE *) &dwWaitTime, &dwSize);
  sRegistryKey.CloseKey();

  sLock.UnLock();

  return dwWaitTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\lock.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Lock.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//    This is the implementation of the CLock class. This class was created in order to
//    support automatic destruction of C++ object when an exception is thrown.
//
// Note :
//
//    The CLock class is not thread safe (although the CCriticalSection class is). The CLock
//    class should be used as a local variable when locking using a CCriticalSection object.
//    This is done in order to warranty that all locks on an object are released when an
//    exception is thrown.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <assert.h>
#include "Lock.h"
#include "ExceptionHandler.h"
#include "AppManDebug.h"

//To flag as DBG_LOCK
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_LOCK

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CLock::CLock(CCriticalSection * lpCriticalSection)
{
  FUNCTION("CLock::CLock (CCriticalSection * lpCriticalSection)");

  assert(NULL != lpCriticalSection);

  //
  // We need to record what the lock could of the critical section when the CLock object
  // is created. When the object is destroyed we make sure that the lock count
  // on the critical section object is the same as when CLock was created
  //

  m_lpCriticalSection = lpCriticalSection;
  m_dwBaseLockCount = m_lpCriticalSection->GetLockCount();
  m_dwLockCount = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CLock::~CLock(void)
{
  FUNCTION("CLock::~CLock (void)");

  DWORD dwLockCount;

  do
  {
    dwLockCount = m_lpCriticalSection->GetLockCount();

    //
    // If the lock count on the critical section is greater than when the CLock object was
    // created, then we call m_lpCriticalSection->Leave()
    //

    if (dwLockCount > m_dwBaseLockCount)
    {
      m_lpCriticalSection->Leave();
    }
  } 
  while (dwLockCount > m_dwBaseLockCount);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CLock::Lock(void)
{
  FUNCTION("CLock::Lock ()");

  m_lpCriticalSection->Enter();
  m_dwLockCount++;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CLock::UnLock(void)
{
  FUNCTION("CLock::UnLock ()");

  HRESULT hResult;

  if (0 < m_dwLockCount)
  {
    hResult = m_lpCriticalSection->Leave();

    //
    // Make sure that hResult == S_OK and not S_FALSE
    //
    
    if (S_OK == hResult)
    {
      m_dwLockCount--;
    }

    return S_OK;
  }

  return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\guids.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Guids.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This source file contains the INITGUID define that declares the GUID variables for
//   this project
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#define INITGUID
#include <objbase.h>
#include <initguid.h>

#include "AppMan.h"
#include "AppManAdmin.h"
#include "EmptyVc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\lock.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Lock.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//    This is the definition of the CLock class. This class was created in order to
//    support automatic destruction of C++ object when an exception is thrown.
//
// Note :
//
//    The CLock class is not thread safe (although the CCriticalSection class is). The CLock
//    class should be used as a local variable when locking using a CCriticalSection object.
//    This is done in order to warranty that all locks on an object are released when an
//    exception is thrown.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if !defined(__LOCK_)
#define __LOCK_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <objbase.h>
#include "CriticalSection.h"

class CLock
{
  public :

    CLock(CCriticalSection * lpCriticalSection);
    ~CLock(void);

    STDMETHOD (Lock) (void);
    STDMETHOD (UnLock) (void);

  private :

    CCriticalSection  * m_lpCriticalSection;
    DWORD               m_dwBaseLockCount;
    DWORD               m_dwLockCount;
};

#ifdef __cplusplus
}
#endif

#endif  // __LOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\registrykey.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// RegistryKey.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the implementation of the CRegistryKey class. This class was created in order to
//   support automatic destruction of C++ object when an exception is thrown.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <shlwapi.h>
#include "RegistryKey.h"
#include "ExceptionHandler.h"
#include "AppManDebug.h"
#include "Win32API.h"

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_REGISTRY

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CRegistryKey::CRegistryKey(void)
{
  FUNCTION("CRegistryKey::CRegistryKey (void)");

  m_fKeyOpen = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CRegistryKey::~CRegistryKey(void)
{
  FUNCTION("CRegistryKey::~CRegistryKey (void)");

  CloseKey();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::EnumKeys(const DWORD dwIndex, LPSTR lpszSubKeyName, LPDWORD lpdwSubKeyNameLen)
{
  FUNCTION("CRegistryKey::EnumKeys ()");

  FILETIME  sFileTime;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  if (ERROR_SUCCESS != RegEnumKeyEx(m_hRegistryKey, dwIndex, lpszSubKeyName, lpdwSubKeyNameLen, NULL, NULL, NULL, &sFileTime))
  {
    return S_FALSE;
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CheckForExistingKey(HKEY hKey, LPCSTR lpszSubKeyName)
{
  FUNCTION("CRegistryKey::CheckForExistingKey ()");

  HKEY    hRegistryKey;

  if (ERROR_SUCCESS != RegOpenKeyEx(hKey, lpszSubKeyName, 0, KEY_READ, &hRegistryKey))
  {
    return S_FALSE;
  }
  
  RegCloseKey(hRegistryKey);

  return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CreateKey(HKEY hKey, LPCSTR lpszSubKeyName, const DWORD dwOptions, const REGSAM samDesired, BOOL bSpecifySecurityAttributes, LPDWORD lpdwDisposition)
{
  FUNCTION("CRegistryKey::CreateKey ()");

  LONG        lReturn = ERROR_SUCCESS;
  HRESULT     hResult = S_OK;
  CWin32API   oWin32API;

  //
  // Make sure that current registry is closed before proceeding
  //

  CloseKey();

  //
  // Create the new key
  //

  if ((!(OS_VERSION_9x & oWin32API.GetOSVersion()))&&(bSpecifySecurityAttributes))
  {
    SECURITY_ATTRIBUTES   sSecurityAttributes = {0};
    SECURITY_DESCRIPTOR   sSecurityDescriptor = {0};

    sSecurityAttributes.nLength = sizeof sSecurityAttributes;
    sSecurityAttributes.lpSecurityDescriptor = &sSecurityDescriptor;

    InitializeSecurityDescriptor(&sSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sSecurityDescriptor, TRUE, NULL, FALSE);

    lReturn = RegCreateKeyEx(hKey, lpszSubKeyName, 0, NULL, dwOptions, samDesired, &sSecurityAttributes, &m_hRegistryKey, lpdwDisposition);
  }
  else
  {
    lReturn = RegCreateKeyEx(hKey, lpszSubKeyName, 0, NULL, dwOptions, samDesired, NULL, &m_hRegistryKey, lpdwDisposition);
  }

  if (lReturn != ERROR_SUCCESS)
  {
    if (lReturn == ERROR_ACCESS_DENIED)
    {
      hResult = E_ACCESSDENIED;
    }
    else
    {
      hResult = E_FAIL;
    }
      
    THROW(hResult);
  }

  m_fKeyOpen = TRUE;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::OpenKey(HKEY hKey, LPCSTR lpszSubKeyName, const REGSAM samDesired)
{
  FUNCTION("CRegistryKey::OpenKey ()");

  //
  // Make sure that current registry is closed before proceeding
  //

  CloseKey();

  //
  // Open the existing key
  //

  if (ERROR_SUCCESS != RegOpenKeyEx(hKey, lpszSubKeyName, 0, samDesired, &m_hRegistryKey))
  {
    THROW(E_FAIL);
  }

  m_fKeyOpen = TRUE;

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CloseKey(void)
{
  FUNCTION("CRegistryKey::CloseKey ()");

  if (m_fKeyOpen)
  {
    RegCloseKey(m_hRegistryKey);
    m_fKeyOpen = FALSE;
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::DeleteKey(HKEY hKey, LPCSTR lpszSubKeyName)
{
  FUNCTION("CRegistryKey::DeleteKey ()");

  HRESULT   hResult = S_OK;
  DWORD     dwSubKeyNameLen;
  HKEY      hRegistryKey;
  FILETIME  sFileTime;
  CHAR      strSubKeyName[MAX_PATH];
  CHAR      strFullSubKeyName[MAX_PATH];

  //
  // Recursively delete all subkeys
  //

  if (ERROR_SUCCESS == RegOpenKeyEx(hKey, lpszSubKeyName, 0, KEY_ALL_ACCESS, &hRegistryKey))
  {
    dwSubKeyNameLen = MAX_PATH;
    while ((S_OK == hResult)&&(ERROR_SUCCESS == RegEnumKeyEx(hRegistryKey, 0, strSubKeyName, &dwSubKeyNameLen, NULL, NULL, NULL, &sFileTime)))
    {
      sprintf(strFullSubKeyName, "%s\\%s", lpszSubKeyName, strSubKeyName);
      hResult = DeleteKey(hKey, strFullSubKeyName);
      dwSubKeyNameLen = MAX_PATH;
    }

    //
    // Close the key
    //

    RegCloseKey(hRegistryKey);

    //
    // If all the subkeys were successfully deleted
    //

    if (S_OK == hResult)
    {
      //
      // Delete this subkey
      //
  
      if (ERROR_SUCCESS != RegDeleteKey(hKey, lpszSubKeyName))
      {
        hResult = E_FAIL;
      }
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::EnumValues(const DWORD dwIndex, LPSTR lpszValueName, LPDWORD lpdwValueNameLen, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen)
{
  FUNCTION("CRegistryKey::EnumValues ()");

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  if (ERROR_SUCCESS != RegEnumValue(m_hRegistryKey, dwIndex, lpszValueName, lpdwValueNameLen, NULL, lpdwType, lpData, lpdwDataLen))
  {
    return S_FALSE;
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::CheckForExistingValue(LPCSTR lpszValueName)
{
  FUNCTION("CRegistryKey::CheckForExistingValue ()");

  //
  // If there is no currently opened registry key, then CheckForExistingValue was
  // called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  //
  // Check to see whether we can RegQueryValueEx() on the target. If we can then the value
  // exists, othersize it does not
  //

  if (ERROR_SUCCESS != RegQueryValueEx(m_hRegistryKey, lpszValueName, NULL, NULL, NULL, NULL))
  {
    return S_FALSE;
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::GetValue(LPCSTR lpszValueName, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen)
{
  FUNCTION("CRegistryKey::GetValue ()");

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  if (ERROR_SUCCESS != RegQueryValueEx(m_hRegistryKey, lpszValueName, NULL, lpdwType, lpData, lpdwDataLen))
  {
    THROW(E_FAIL);
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::SetValue(LPCSTR lpszValueName, const DWORD dwType, const BYTE * lpData, const DWORD dwDataLen)
{
  FUNCTION("CRegistryKey::SetValue ()");

  DWORD dwActualDataLen;

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  //
  // If this value is of type REG_SZ, define the lenght of the string
  //

  if (REG_SZ == dwType)
  {
    dwActualDataLen = strlen((LPSTR)lpData) + 1;
    if (dwActualDataLen > dwDataLen)
    {
      dwActualDataLen = dwDataLen - 1;
    }
  }
  else
  {
    dwActualDataLen = dwDataLen;
  }

  //
  //
  // Set the registry value
  //

  if (ERROR_SUCCESS != RegSetValueEx(m_hRegistryKey, lpszValueName, 0, dwType, lpData, dwActualDataLen))
  {
    THROW(E_FAIL);
  }

  return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryKey::DeleteValue(LPCSTR lpszValueName)
{
  FUNCTION("CRegistryKey::DeleteValue ()");

  //
  // If there is no currently opened registry key, then GetValue was called unexpectedly
  //

  if (!m_fKeyOpen)
  {
    THROW(E_UNEXPECTED);
  }

  if (ERROR_SUCCESS != RegDeleteValue(m_hRegistryKey, lpszValueName))
  {
    THROW(E_FAIL);
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\informationmanager.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// InformationManager.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the header file for the CInformationManager class used by the Application 
//   Manager. It is a private class that will never be distributed to the public.
//
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////


#ifndef __INFORMATIONMANAGER_
#define __INFORMATIONMANAGER_

#ifdef __cplusplus
extern "C" {
#endif

#include <objbase.h>
#include "ApplicationManager.h"
#include "AppPropertyRules.h"
#include "Win32API.h"

//////////////////////////////////////////////////////////////////////////////////////////////

#define REG_VERSION         0x00000004

#ifndef UNLEN
#define UNLEN               256
#endif

//
// Defines used as mask for the dwValidFields data member
//

#define DATA_FIELD_GUID                           0x00000001
#define DATA_FIELD_SIGNATURE                      0x00000002
#define DATA_FIELD_COMPANYNAME                    0x00000004
#define DATA_FIELD_VERSION                        0x00000008
#define DATA_FIELD_TYPE                           0x00000010
#define DATA_FIELD_STATE                          0x00000020
#define DATA_FIELD_CATEGORY                       0x00000040
#define DATA_FIELD_INSTALLCOST                    0x00000080
#define DATA_FIELD_REINSTALLCOUNT                 0x00000100
#define DATA_FIELD_USAGECOUNT                     0x00000200
#define DATA_FIELD_INSTALLDATE                    0x00000400
#define DATA_FIELD_LASTUSEDDATE                   0x00000800
#define DATA_FIELD_NONREMOVABLESIZE               0x00001000
#define DATA_FIELD_REMOVABLESIZE                  0x00002000
#define DATA_FIELD_RESERVEDSIZE                   0x00004000
#define DATA_FIELD_ROOTPATH                       0x00008000
#define DATA_FIELD_SETUPROOTPATH                  0x00010000
#define DATA_FIELD_EXECUTECMDLINE                 0x00020000
#define DATA_FIELD_SETUPINTERFACECLSID            0x00040000
#define DATA_FIELD_DOWNSIZECMDLINE                0x00080000
#define DATA_FIELD_REINSTALLCMDLINE               0x00100000
#define DATA_FIELD_UNINSTALLCMDLINE               0x00200000
#define DATA_FIELD_SELFTESTCMDLINE                0x00400000
#define DATA_FIELD_CUSTOMIZECMDLINE               0x00800000
#define DATA_FIELD_DEVICEGUID                     0x01000000
#define DATA_FIELD_WEBURL                         0x02000000
#define DATA_FIELD_ICONPATH                       0x04000000

//
// Defines used to define the device type
//

#define DEVICE_NONE                               0x00000000
#define DEVICE_FIXED                              0x00000001
#define DEVICE_REMOVABLE                          0x00000002
#define DEVICE_NETWORK                            0x00000004
#define DEVICE_RAMDISK                            0x00000008

//
// Wait events
//

#define WAIT_FINALIZE_DOWNSIZE                    0x00000000
#define WAIT_FINALIZE_REINSTALL                   0x00000001
#define WAIT_FINALIZE_UNINSTALL                   0x00000002
#define WAIT_FINALIZE_SELFTEST                    0x00000003

#define WAIT_EVENT_COUNT                          0x00000004

//
// Misc defines
//

#define BAD_REFERENCE_COUNT                       0xffffffff
#define BAD_INDEX                                 0xffffffff

//
// These defines are used to denote the initialization level of an CApplicationInfo object
//

#define INIT_LEVEL_NONE                           0x00000001
#define INIT_LEVEL_BASIC                          0x00000002
#define INIT_LEVEL_TOTAL                          0x00000004

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct  // sizeof(SYNC_INFO) = 28 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  SYSTEMTIME        stDate;
  GUID              sSynchronizationGuid;

} SYNC_INFO, *LPSYNC_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  GUID              guidInstanceGuid;
  DWORD             dwLockCount;

} LOCK_INFO, *LPLOCK_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwEventCount[WAIT_EVENT_COUNT];
  GUID              guidInstanceGuid;

} WAIT_INFO, *LPWAIT_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct  // sizeof(TEMP_SPACE_INFO) = 524 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwKilobytes;
  GUID              sGuid;
  GUID              sApplicationGuid;
  GUID              sDeviceGuid;
  WCHAR             wszDirectory[MAX_PATH_CHARCOUNT];

} TEMP_SPACE_RECORD, *LPTEMP_SPACE_RECORD;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwAssociationType;
  GUID              sParentGuid;
  GUID              sChildGuid;

} ASSOCIATION_INFO, *LPASSOCIATION_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwUsageCount;
  DWORD             dwReInstallCount;
  DWORD             dwInstallCost;
  SYSTEMTIME        stInstallDate;
  SYSTEMTIME        stLastUsedDate;

} AGING_INFO, *LPAGING_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwLowPropertyMask;
  DWORD             dwHighPropertyMask;
  GUID              sApplicationGuid;
  GUID              sDeviceGuid;
  GUID              sInstanceGuid;
  DWORD             dwState;
  DWORD             dwCategory;
  DWORD             dwRemovableKilobytes;
  DWORD             dwNonRemovableKilobytes;
  DWORD             dwReservedKilobytes;
  DWORD             dwPinState;

} BASE_INFO, *LPBASE_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  BASE_INFO         sBaseInfo;
  AGING_INFO        sAgingInfo;
  ASSOCIATION_INFO  sAssociation;
  WCHAR             wszStringProperty[APP_STRING_COUNT][MAX_PATH_CHARCOUNT+1];

} APPLICATION_DATA, *LPAPPLICATION_DATA;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct  // sizeof(DEVICE_INFO) = 32 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwDeviceFlags;
  DWORD             dwDeviceIndex;
  DWORD             dwVolumeSerial;
  DWORD             dwPercentCacheSize;
  DWORD             dwPercentMinimumFreeSize;
  DWORD             dwRemovableKilobytes;
  DWORD             dwNonRemovableKilobytes;
  DWORD             dwReservedKilobytes;
  DWORD             dwApplicationCategoryExclusionMask;
  DWORD             dwLastUsedThreshold;
  
} DEVICE_INFO, *LPDEVICE_INFO;

typedef struct  // sizeof(DEVICE_SPACE_INFO) = 72 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  DWORD             dwTotalKilobytes;
  DWORD             dwTotalFreeKilobytes;
  DWORD             dwMinimumFreeKilobytes;
  DWORD             dwTotalUsableFreeKilobytes;
  DWORD             dwCacheSizeKilobytes;
  DWORD             dwCacheUsedKilobytes;
  DWORD             dwCacheFreeKilobytes;
  DWORD             dwSlackSizeKilobytes;
  DWORD             dwSlackUsedKilobytes;
  DWORD             dwSlackFreeKilobytes;
  DWORD             dwTotalRemovableKilobytes;
  DWORD             dwTotalNonRemovableKilobytes;
  DWORD             dwOptimalRemovableKilobytes;
  DWORD             dwMaximumUsableKilobytes;
  DWORD             dwOptimalUsableKilobytes;
  DWORD             dwTotalReservedKilobytes;
  DWORD             dwTotalReservedTemporaryKilobytes;
  DWORD             dwTotalUsedTemporaryKilobytes;
  

} DEVICE_SPACE_INFO, *LPDEVICE_SPACE_INFO;

//////////////////////////////////////////////////////////////////////////////////////////////

typedef struct  // sizeof(APPLICATION_MANAGER_RECORD) = 32 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  GUID              sSystemGuid;
  DWORD             dwAdvancedMode;
  
} APPLICATION_MANAGER_RECORD, *LPAPPLICATION_MANAGER_RECORD;

typedef struct  // sizeof(DEVICE_RECORD) = 48 bytes
{
  DWORD             dwSize;
  DWORD             dwStructId;
  DWORD             dwReserved;
  GUID              sDeviceGuid;
  DEVICE_INFO       sDeviceInfo;

} DEVICE_RECORD, *LPDEVICE_RECORD;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// CInformationManager
//
//////////////////////////////////////////////////////////////////////////////////////////////

class CInformationManager  
{
  friend class CApplicationManagerAdmin;

  public :

    CInformationManager(void);
    ~CInformationManager(void);

    STDMETHOD (Initialize) (void);
    STDMETHOD (Shutdown) (void);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD (GetAdvancedMode) (LPDWORD lpdwAdvancedMode);
    STDMETHOD (SetAdvancedMode) (DWORD dwAdvancedMode);
    STDMETHOD (GetOptimalAvailableSpace) (const DWORD dwApplicationCategory, LPDWORD lpdwOptimalKilobytes);
    STDMETHOD (GetMaximumAvailableSpace) (const DWORD dwApplicationCategory, LPDWORD lpdwMaximumKilobytes);
    STDMETHOD (GetSpace) (const DWORD dwApplicationCategory, const DWORD dwRequiredKilobytes, LPDWORD lpdwDeviceIndex);
    STDMETHOD (FreeSpaceOnDevice) (const GUID * lpDeviceGuid, const DWORD dwRequiredKilobytes);
    STDMETHOD (FixCacheOverrun) (const GUID * lpDeviceGuid, const DWORD dwExtraKilobytes);
    //STDMETHOD_(DWORD, GetApplicationAge) (LPAPPLICATION_DATA lpApplicationData);

    STDMETHOD (CheckApplicationExistance) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (AddApplicationData) (LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid);
    STDMETHOD (RemoveApplicationData) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (GetApplicationDataWithIndex) (const DWORD dwApplicationIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (GetApplicationData) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (SetApplicationData) (LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid);
    STDMETHOD (SetApplicationState) (const LPAPPLICATION_DATA lpApplicationData, const GUID * lpInstanceGuid);
    STDMETHOD (AssignDeviceToApplication) (const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (DownsizeApplication) (const DWORD dwRequiredKilobytes, const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (ReInstallApplication) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (UnInstallApplication) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (UnInstallApplicationWait) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (SelfTestApplication) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (RunApplication) (const LPAPPLICATION_DATA lpApplicationData, const DWORD dwRunFlags, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLen);
    STDMETHOD (PinApplication) (const LPAPPLICATION_DATA lpApplicationData, BOOL * lpfPinState);
    STDMETHOD (ReadyApplication) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (DisableApplication) (const LPAPPLICATION_DATA lpApplicationData);

    STDMETHOD_(DWORD, GetPropertyIndex) (const DWORD dwProperty);
    STDMETHOD (IsValidApplicationProperty) (const DWORD dwProperty);
    STDMETHOD (ValidateApplicationPropertyWithIndex) (const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (InvalidateApplicationPropertyWithIndex) (const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (IsApplicationPropertyInitializedWithIndex) (const DWORD dwPropertyIndex, LPAPPLICATION_DATA lpApplicationData);

    STDMETHOD (DeleteDirectoryTree) (LPCSTR lpszDirectory);
    STDMETHOD (DeleteDirectoryTree) (LPCWSTR lpwszDirectory);
    STDMETHOD (RegInitialize) (void);
    STDMETHOD (RegFutureDirectoryCleanup) (LPCWSTR lpwszDirectory);

    STDMETHOD (InitializeWaitEvent) (LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent);
    STDMETHOD (EnterWaitEvent) (LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent, const GUID * lpInstanceGuid);
    STDMETHOD (LeaveWaitEvent) (LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent);
    STDMETHOD (WaitForEventCompletion) (LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent, const DWORD dwEntryMilliseconds, const DWORD dwExitMilliseconds);
    STDMETHOD (KillWaitEvent) (LPAPPLICATION_DATA lpApplicationData, const DWORD dwWaitEvent);
    STDMETHOD (CheckDeviceExistance) (const DWORD dwDeviceIndex);

    STDMETHOD_(BOOL, IsApplicationPinned) (const LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (IsInstanceGuidStillAlive) (const GUID * lpGuid);
    STDMETHOD (IsApplicationLocked) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (LockApplicationData) (LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid);
    STDMETHOD (UnlockApplicationData) (LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid);
    STDMETHOD (ForceUnlockApplicationData) (LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid);
    STDMETHOD (LockApplicationData) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (UnlockApplicationData) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (LockParentApplications) (LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid);
    STDMETHOD (UnlockParentApplications) (LPAPPLICATION_DATA lpApplicationData, GUID * lpInstanceGuid);
    STDMETHOD (LockParentApplications) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (UnlockParentApplications) (LPAPPLICATION_DATA lpApplicationData);

    STDMETHOD_(DWORD, GetDeviceIndex) (const DWORD dwVolumeSerial);
    STDMETHOD (AddDeviceWithIndex) (const DWORD dwDeviceIndex);
    STDMETHOD (RemoveDeviceWithIndex) (const DWORD dwDeviceIndex);
    STDMETHOD (UpdateDeviceInfoWithIndex) (const DWORD dwDeviceIndex);
    STDMETHOD (ScanDevices) (void);
    STDMETHOD (ScanDevices) (const DWORD dwDeviceIndex);
    STDMETHOD (GetDeviceInfo) (LPDEVICE_RECORD lpDeviceRecord);
    STDMETHOD (GetDeviceInfoWithIndex) (const DWORD dwDeviceIndex, LPDEVICE_RECORD lpDeviceRecord);
    STDMETHOD (SetDeviceInfoWithIndex) (const DWORD dwDeviceIndex, LPDEVICE_RECORD lpDeviceRecord);
    STDMETHOD (GetDeviceSpaceInfoWithIndex) (const DWORD dwDeviceIndex, LPDEVICE_SPACE_INFO lpDeviceSpaceInfo);
    STDMETHOD (GetDeviceOptimalSpaceWithIndex) (const DWORD dwDeviceIndex, LPDWORD lpdwKilobytes);
    STDMETHOD (GetDeviceMaximumSpaceWithIndex) (const DWORD dwDeviceIndex, LPDWORD lpdwKilobytes);
    STDMETHOD (FreeSpaceOnDeviceWithIndex) (const DWORD dwDeviceIndex, const DWORD dwRequiredKilobytes);
    STDMETHOD_(DWORD, GetAgingCount) (LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (GetOldestApplicationDataByDeviceWithIndex) (const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (GetNextOldestApplicationDataByDeviceWithIndex) (const DWORD dwDeviceIndex, LPAPPLICATION_DATA lpApplicationData);
    STDMETHOD (AddTempSpace) (LPTEMP_SPACE_RECORD lpTempSpaceRecord);
    STDMETHOD (RemoveTempSpace) (LPTEMP_SPACE_RECORD lpTempSpaceRecord);
    STDMETHOD (EnumTempSpace) (const DWORD dwIndex, LPTEMP_SPACE_RECORD lpTempSpaceRecord);
    STDMETHOD (AddAssociation) (LPASSOCIATION_INFO lpAssociationInfo);
    STDMETHOD (RemoveAssociation) (LPASSOCIATION_INFO lpAssociationInfo);
    STDMETHOD (EnumAssociations) (const DWORD dwIndex, LPASSOCIATION_INFO lpAssociationInfo);

  private :

    STDMETHOD_(DWORD, GetExtraWaitEventEntryTime) (void);
    STDMETHOD_(DWORD, GetExtraWaitEventExitTime) (void);

    //
    // Private data members
    //

    LONG              m_lInitializationIndex;
    CWin32API         m_Win32API;
    CCriticalSection  m_CriticalSection;
};

//////////////////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif  // __INFORMATIONMANAGER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\registrykey.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// RegistryKey.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//   This is the definition of the CRegistryKey class. This class was created in order to
//   support automatic destruction of C++ object when an exception is thrown.
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if !defined(__REGISTRYKEY_)
#define __REGISTRYKEY_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <objbase.h>
#include <stdio.h>

class CRegistryKey
{
  public :

    CRegistryKey(void);
    ~CRegistryKey(void);

    STDMETHOD (EnumKeys) (const DWORD dwIndex, LPSTR lpszSubKeyName, LPDWORD lpdwSubKeyNameLen);
    STDMETHOD (CheckForExistingKey) (HKEY hKey, LPCSTR lpszSubKeyName);
    STDMETHOD (CreateKey) (HKEY hKey, LPCSTR lpszSubKeyName, const DWORD dwOptions, const REGSAM samDesired, BOOL bSpecifySecurityAttributes, LPDWORD lpdwDisposition);
    STDMETHOD (OpenKey) (HKEY hKey, LPCSTR lpszSubKeyName, const REGSAM samDesired);
    STDMETHOD (CloseKey) (void);
    STDMETHOD (DeleteKey) (HKEY hKey, LPCSTR lpszSubKeyName);
 
    STDMETHOD (EnumValues) (const DWORD dwIndex, LPSTR lpszValueName, LPDWORD lpdwValueNameLen, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen);
    STDMETHOD (CheckForExistingValue) (LPCSTR lpszValueName);
    STDMETHOD (GetValue) (LPCSTR lpszValueName, LPDWORD lpdwType, LPBYTE lpData, LPDWORD lpdwDataLen);
    STDMETHOD (SetValue) (LPCSTR lpszValueName, const DWORD dwType, const BYTE * lpData, const DWORD dwDataLen);
    STDMETHOD (DeleteValue) (LPCSTR lpszValueName);

  private :

    BOOL    m_fKeyOpen;
    HKEY    m_hRegistryKey;
};

#ifdef __cplusplus
}
#endif

#endif  // __REGISTRYKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppMan.rc
//
#define IDS_STRING1                     1
#define IDS_PROGRAMFILES                1
#define IDS_STRING2                     2
#define IDS_GAMES                       2
#define IDS_ENTERTAINMENT               2
#define IDS_STRING3                     3
#define IDS_APPMAN                      3
#define IDS_STRING4                     4
#define IDS_PRODUCTIVITY                4
#define IDS_STRING5                     5
#define IDS_PUBLISHING                  5
#define IDS_STRING6                     6
#define IDS_SCIENTIFIC                  6
#define IDS_STRING7                     7
#define IDS_AUTHORING                   7
#define IDS_STRING8                     8
#define IDS_MEDICAL                     8
#define IDS_STRING9                     9
#define IDS_BUSINESS                    9
#define IDS_STRING10                    10
#define IDS_FINANCIAL                   10
#define IDS_STRING11                    11
#define IDS_EDUCATIONAL                 11
#define IDS_STRING12                    12
#define IDS_REFERENCE                   12
#define IDS_STRING13                    13
#define IDS_WEB                         13
#define IDS_STRING14                    14
#define IDS_DEVTOOL                     14
#define IDS_STRING15                    15
#define IDS_MULTIMEDIA                  15
#define IDS_STRING16                    16
#define IDS_VIRUSCLEANER                16
#define IDS_STRING17                    17
#define IDS_CONNECTIVITY                17
#define IDS_STRING18                    18
#define IDS_DISKCLEANERNAME1            18
#define IDS_STRING19                    19
#define IDS_DISKCLEANERNAME2            19
#define IDS_STRING20                    20
#define IDS_DISKCLEANERDESC1            20
#define IDS_STRING21                    21
#define IDS_DISKCLEANERDESC2            21
#define IDS_STRING22                    22
#define IDS_APPMANNT                    22
#define IDS_STRING23                    23
#define IDS_APPMAN9x                    23
#define IDI_ICON1                       112

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\structidentifiers.h ===
#ifndef __STRUCT_IDENTIFIERS_
#define __STRUCT_IDENTIFIERS_

#ifndef __cplusplus
extern "C" {
#endif

#define AGING_STRUCT                0x00000001
#define BASIC_APPINFO_STRUCT        0x00000002
#define TEMP_SPACE_STRUCT           0x00000003
#define APPLICATION_MANAGER_STRUCT  0x00000004
#define ASSOCIATION_STRUCT          0x00000005
#define LOCK_STRUCT                 0x00000006
#define WAIT_STRUCT                 0x00000007

#ifndef __cplusplus
}
#endif

#endif  // __STRUCT_IDENTIFIERS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\sources.inc ===
MAJORCOMP=ApplicationManager
MINORCOMP=AppManDLL

#
#  The build environment sets the FREEBUILD macro to 1 when it is a free build
#  so you can change the name of the built binary to be different in that case.
#  side effects:
#             need 2 entries in placefil.txt (one for each name)
#             if a lib is published it will be called the new name; depending on your
#                viewpoint this could be a good thing or not
#
TARGETNAME=AppMan

# Append a 'D' to AppMan if we are doing a debug (checked) build.

!if !$(FREEBUILD)
!ifdef DIRECTX_REDIST
TARGETNAME=$(TARGETNAME)d
!endif
!endif

TARGETTYPE=DYNLINK
TARGETEXT=dll
TARGETPATH=Obj
UMTYPE=windows

#  4/09/2000(RichGr): Specify the DX SDK PlaceFil.txt instead of the Win2K one.
BINPLACE_PLACEFILE=$(DXROOT)\public\sdk\lib\placefil.txt

DLLENTRY=_DllMainCRTStartup

#  4/12/2000(RichGr): USE_LIBCMT causes libcmt(d).lib to be selected for the link.
USE_LIBCMT=1

#  4/08/2000(RichGr): Instead of adding /GX to the command-line options, specify USE_NATIVE_EH (Exception Handling).
USE_NATIVE_EH=1

!IF "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
USE_MAPSYM = 1
RC_DEFINES=$(RC_DEFINES) -DDEBUG=1
C_DEFINES=$(C_DEFINES) /D"WIN32" /D"_DEBUG" /D"_WINDOWS" /D"MBCS" /D"_USERDLL" 

#  4/12/2000(RichGr): DEBUG_CRTS causes 'd' to be appended to libcmt, etc.
#     Note: DEBUG_CRTS defines _DEBUG (if it's not already defined).
DEBUG_CRTS=1
!ELSE
C_DEFINES=$(C_DEFINES) /D"WIN32" /D"NDEBUG" /D"_WINDOWS" /D"MBCS" /D"_USERDLL"
!ENDIF

# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
#  4/12/2000(RichGr): Remove msvcrtd.lib from the debug list of libs - most machines don't have msvcrtd.dll installed.
#
TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\kernel32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\user32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\winspool.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\comdlg32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\advapi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\shell32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\ole32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\uuid.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\shlwapi.lib


INCLUDES=$(DXROOT)\Inc; \
         $(DXROOT)\ApplicationManager\Include; \
         $(SDXROOT)\public\sdk\inc\mfc42;

SOURCES= \
..\AppMan.rc \
..\ApplicationEntry.cpp \
..\ApplicationManager.cpp \
..\ApplicationManagerAdmin.cpp \
..\ApplicationManagerRoot.cpp \
..\AppManDebug.cpp \
..\AppPropertyRules.cpp \
..\CriticalSection.cpp \
..\EmptyVolumeCache.cpp \
..\ExceptionHandler.cpp \
..\FApplicationManager.cpp \
..\Global.cpp \
..\Guids.cpp \
..\InformationManager.cpp \
..\Lock.cpp \
..\RegistryKey.cpp \
..\Win32API.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\daytona\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif


$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\AppMan.h: ..\..\Include\AppMan.h
	-binplace  $(SDK_INC_PATH)\AppMan.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\win32api.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Win32Unicode.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if !defined(__WIN32API_)
#define __WIN32API_

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <stdio.h>

#define OS_VERSION_WIN32S           0x00000000
#define OS_VERSION_WIN95            0x00000001
#define OS_VERSION_WIN95_OSR1       0x00000002
#define OS_VERSION_WIN95_OSR2       0x00000004
#define OS_VERSION_WIN95_OSR3       0x00000008
#define OS_VERSION_WIN95_OSR4       0x00000010
#define OS_VERSION_WIN98            0x00000020
#define OS_VERSION_WIN98_OSR1       0x00000040
#define OS_VERSION_WIN98_OSR2       0x00000080
#define OS_VERSION_WIN98_OSR3       0x00000100
#define OS_VERSION_WIN98_OSR4       0x00000200
#define OS_VERSION_WINNT            0x00000400

#define OS_VERSION_9x               (OS_VERSION_WIN95 | OS_VERSION_WIN95_OSR1 | OS_VERSION_WIN95_OSR2 | OS_VERSION_WIN95_OSR3 | OS_VERSION_WIN95_OSR4 | OS_VERSION_WIN98 | OS_VERSION_WIN98_OSR1 | OS_VERSION_WIN98_OSR2 | OS_VERSION_WIN98_OSR3 | OS_VERSION_WIN98_OSR4)
#define OS_VERSION_NT               (OS_VERSION_WINNT)

#define KILOBYTES(a)                ((((a).HighPart & 0x3ff) << 22)||(((a).LowPart) >> 10))

class CWin32API
{
  public :

    CWin32API(void);
    ~CWin32API(void);

    static DWORD   WideCharToMultiByte(LPCWSTR wszSourceString, const DWORD dwSourceLen, LPSTR szDestinationString, const DWORD dwDestinationLen);
    static DWORD   MultiByteToWideChar(LPCSTR szSourceString, const DWORD dwSourceLen, LPWSTR wszDestinationString, const DWORD dwDestinationLen);

    DWORD   GetOSVersion(void);
    DWORD   GetDriveType(LPCSTR lpRootPathName);
    DWORD   GetDriveType(LPCWSTR lpRootPathName);
    BOOL    IsDriveFormatted(LPCSTR lpRootPathName);
    BOOL    IsDriveFormatted(LPCWSTR lpRootPathName);
    DWORD   GetDriveSize(LPCSTR lpRootPathName);
    DWORD   GetDriveSize(LPCWSTR lpRootPathName);
    DWORD   GetDriveFreeSpace(LPCSTR lpRootPathName);
    DWORD   GetDriveFreeSpace(LPCWSTR lpRootPathName);
    DWORD   GetDriveUserFreeSpace(LPCSTR lpRootPathName);
    DWORD   GetDriveUserFreeSpace(LPCWSTR lpRootPathName);
    BOOL    GetVolumeInformation(LPCSTR lpRootPathName, LPSTR lpVolumeLabel, const DWORD dwVolumeLabelSize, LPDWORD lpdwVolumeSerialNumber);
    BOOL    GetVolumeInformation(LPCWSTR lpRootPathName, LPSTR lpVolumeLabel, const DWORD dwVolumeLabelSize, LPDWORD lpdwVolumeSerialNumber);
    BOOL    CreateProcess(LPSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo);
    BOOL    CreateProcess(LPWSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo);
    BOOL    CreateProcess(LPSTR lpApplication, LPSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo);
    BOOL    CreateProcess(LPWSTR lpApplication, LPWSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo);
    BOOL    CreateDirectory(LPCSTR lpPathName, const BOOL fInitAppManRoot);
    BOOL    CreateDirectory(LPCWSTR lpPathName, const BOOL fInitAppManRoot);
    BOOL    RemoveDirectory(LPCSTR lpPathName);
    BOOL    RemoveDirectory(LPCWSTR lpPathName);
    DWORD   GetDirectorySize(LPCSTR lpPathName);
    DWORD   GetDirectorySize(LPCWSTR lpPathName);
    BOOL    IsValidFilename(LPCSTR lpFilename);
    BOOL    IsValidFilename(LPCWSTR lpFilename);
    BOOL    FileExists(LPCSTR lpFileName);
    BOOL    FileExists(LPCWSTR lpFileName);
    DWORD   FileAttributes(LPCSTR lpFilename);
    DWORD   FileAttributes(LPCWSTR lpFilename);
    DWORD   GetFileSize(LPCSTR lpFileName);
    DWORD   GetFileSize(LPCWSTR lpFileName);
    HANDLE  CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes);
    HANDLE  CreateFile(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes);
    BOOL    DeleteFile(LPCSTR lpFileName);
    BOOL    DeleteFile(LPCWSTR lpFileName);
    HANDLE  CreateFileMapping(HANDLE hFile, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
    HANDLE  CreateFileMapping(HANDLE hFile, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
    BOOL    CopyFile(LPCSTR lpSourceFileName, LPCSTR lpDestinationFileName, BOOL bFailIfExists);
    BOOL    CopyFile(LPCWSTR lpSourceFileName, LPCWSTR lpDestinationFileName, BOOL bFailIfExists);
    BOOL    SetFileAttributes(LPCSTR lpFileName, const DWORD dwFileAttributes);
    BOOL    SetFileAttributes(LPCWSTR lpFileName, const DWORD dwFileAttributes);

  private :

    DWORD   m_dwOSVersion;
};

#ifdef __cplusplus
}
#endif

#endif  // __WIN32API_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\win32api.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Win32Unicode.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
// History :
//
//   05/06/1999 luish     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "Win32API.h"
#include "AppManDebug.h"
#include "Global.h"
#include "AppMan.h"
#include "Resource.h"

//To flag as DBG_WIN32
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_WIN32

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CWin32API::CWin32API(void)
{
  FUNCTION("CWin32API::CWin32API (void)");

  OSVERSIONINFO   sVersionInfo;

  //
  // Default down to OS_VERSION_WIN32S in case the call to GetVersionEx() fails
  //

  m_dwOSVersion = OS_VERSION_WIN32S;
  sVersionInfo.dwOSVersionInfoSize = sizeof(sVersionInfo);
  if (GetVersionEx(&sVersionInfo))
  {
    switch (sVersionInfo.dwPlatformId) 
    {
      case VER_PLATFORM_WIN32_NT
      : m_dwOSVersion = OS_VERSION_WINNT;
        break;
      case VER_PLATFORM_WIN32_WINDOWS
      : if ((sVersionInfo.dwMajorVersion > 4)||((sVersionInfo.dwMajorVersion == 4)&&(sVersionInfo.dwMinorVersion > 0)))
        {
          m_dwOSVersion = OS_VERSION_WIN98;
        }
        else
        {
          if (1111 <= sVersionInfo.dwBuildNumber)
          {
            m_dwOSVersion = OS_VERSION_WIN95_OSR2;
          }
          else
          {
            m_dwOSVersion = OS_VERSION_WIN95;
          }
        }
        break;
      case VER_PLATFORM_WIN32s
      : m_dwOSVersion = OS_VERSION_WIN32S;
        break;
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CWin32API::~CWin32API(void)
{
  FUNCTION("CWin32API::~CWin32API (void)");
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::WideCharToMultiByte(LPCWSTR wszSourceString, const DWORD dwSourceLen, LPSTR szDestinationString, const DWORD dwDestinationLen)
{
  FUNCTION("CWin32API::WideCharToMultiByte ()");

  DWORD dwCount;

  dwCount = 0;

  //
  // Check to make sure that the basic incoming parameters are valid
  //

  if ((NULL == wszSourceString)||(0 == dwSourceLen))
  {
    return 0;
  }

  //
  // If the dwDestinationLen parameter is set to 0, then the user is just fishing for the strlen of wszSourceString.
  // Otherwise the user wants to copy some stuff.
  //

  if (0 == dwDestinationLen)
  {
    while ((dwCount < dwSourceLen)&&(0 != wszSourceString[dwCount]))
    {
      dwCount++;
    }
  }
  else
  {
    //
    // Check some additional parameters for validity
    //

    if (NULL == szDestinationString)
    {
      return 0;
    }

    while ((dwCount < dwSourceLen)&&(0 != wszSourceString[dwCount]))
    {
      szDestinationString[dwCount] = (CHAR) wszSourceString[dwCount];
      dwCount++;
    }

    szDestinationString[dwCount] = 0;

    //dwCount = ::WideCharToMultiByte(CP_ACP, 0, wszSourceString, dwSourceLen, szDestinationString, dwDestinationLen, NULL, NULL);
  }

  return dwCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::MultiByteToWideChar(LPCSTR szSourceString, const DWORD dwSourceLen, LPWSTR wszDestinationString, const DWORD dwDestinationLen)
{
  FUNCTION("CWin32API::MultiByteToWideChar()");

  DWORD   dwCount = 0;

  //
  // Check to make sure that the basic incoming parameters are valid
  //

  if ((NULL == szSourceString)||(0 == dwSourceLen))
  {
    return 0;
  }

  //
  // If the dwDestinationLen parameter is set to 0, then the user is just fishing for the strlen of wszSourceString.
  // Otherwise the user wants to copy some stuff.
  //

  if (0 == dwDestinationLen)
  {
    while ((dwCount < dwSourceLen)&&(0 != szSourceString[dwCount]))
    {
      dwCount++;
    }
  }
  else
  {
    //
    // Check some additional parameters for validity
    //

    if (NULL == wszDestinationString)
    {
      return 0;
    }

    while ((dwCount < dwSourceLen)&&(0 != szSourceString[dwCount]))
    {
      wszDestinationString[dwCount] = (WCHAR) szSourceString[dwCount];
      dwCount++;
    }

    wszDestinationString[dwCount] = 0;

    //dwCount = ::MultiByteToWideChar(CP_ACP, 0, szSourceString, dwSourceLen, wszDestinationString, dwDestinationLen);
  }

  return dwCount;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetOSVersion(void)
{
  FUNCTION("CWin32API::GetOSVersion ()");

  return m_dwOSVersion;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveType(LPCSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveType ()");

  return ::GetDriveType(lpRootPathName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveType(LPCWSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveType ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetDriveType(szString);
  }

  return DRIVE_NO_ROOT_DIR;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::IsDriveFormatted(LPCSTR lpRootPathName)
{
  FUNCTION("CWin32API::IsDriveFormatted()");

  BOOL  fReturnValue = FALSE;
  DWORD dwVolumeSerial;

  if (GetVolumeInformation(lpRootPathName, NULL, 0, &(dwVolumeSerial)))
  {
    fReturnValue = TRUE;
  }

  return fReturnValue;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::IsDriveFormatted(LPCWSTR lpRootPathName)
{
  FUNCTION("CWin32API::IsDriveFormatted()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return IsDriveFormatted(szString);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// We want to make sure to create all the directories in the lpPathName tree
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateDirectory(LPCSTR lpPathName, const BOOL fInitAppManRoot)
{
  FUNCTION("CWin32API::CreateDirectory ()");

  CHAR  szString[MAX_PATH_CHARCOUNT+1];
  DWORD dwIndex;
  BOOL  fSuccess = TRUE;

  //
  // Does the directory already exist
  //

  if (!FileExists(lpPathName))
  {
    //
    // Make sure the Application Manager root paths are build if required
    //

    if (fInitAppManRoot)
    {
      WCHAR   wszAppManRoot[MAX_PATH_CHARCOUNT+1];
      WCHAR   wszAppManSetup[MAX_PATH_CHARCOUNT+1];
      WCHAR   wszString[MAX_PATH_CHARCOUNT+1];
      DWORD   dwDeviceIndex;

      //
      // Create the root AppMan directory on the device if it doesn't already exist BUG BUG
      //

      dwDeviceIndex = (DWORD) lpPathName[0];
      (OS_VERSION_9x & GetOSVersion()) ? GetResourceStringW(IDS_APPMAN9x, wszAppManRoot, MAX_PATH_CHARCOUNT): GetResourceStringW(IDS_APPMANNT, wszAppManRoot, MAX_PATH_CHARCOUNT);
      swprintf(wszString, L"%c:\\%s", dwDeviceIndex, wszAppManRoot);
      if (FALSE == FileExists(wszString))
      {
        CreateDirectory(wszString, FALSE);
        SetFileAttributes(wszString, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY);
      }

      //
      // Now create the root AppMan system directory on the device if it doesn't already exist
      //

      GetResourceStringW(IDS_APPMAN, wszAppManSetup, MAX_PATH_CHARCOUNT);
      swprintf(wszString, L"%c:\\%s\\%s", dwDeviceIndex, wszAppManRoot, wszAppManSetup);
      if (FALSE == FileExists(wszString))
      {
        CreateDirectory(wszString, FALSE);
        SetFileAttributes(wszString, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY);
      }
    }

    //
    // Copy the first three bytes from lpPathName to szString (i.e. "C:\x")
    //

    dwIndex = 4;
    memcpy(szString, lpPathName, dwIndex);
    szString[dwIndex] = 0;

    //
    // Continue copying the lpPathName string to szString and everytime the '\' character is
    // detected, try to create that directory
    //

    while ((MAX_PATH_CHARCOUNT > dwIndex)&&(fSuccess)&&(0 != lpPathName[dwIndex]))
    {
      if (('\\' == lpPathName[dwIndex])&&(!FileExists(szString)))
      {
        fSuccess = ::CreateDirectoryA(szString, NULL);
      }
      szString[dwIndex] = lpPathName[dwIndex];
      szString[dwIndex+1] = 0;
      dwIndex++;
    }

    fSuccess = ::CreateDirectoryA(szString, NULL);
  }

  return fSuccess;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateDirectory(LPCWSTR lpPathName, const BOOL fInitAppManRoot)
{
  FUNCTION("CWin32API::CreateDirectory ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return CreateDirectory(szString, fInitAppManRoot);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::RemoveDirectory(LPCSTR lpszPathName)
{
  FUNCTION("CWin32API::RemoveDirectory ()");

  WIN32_FIND_DATA		FindData;
	HANDLE						hFindFile;
	BOOL							fContinue;
	char							szFileMask[MAX_PATH_CHARCOUNT], szFilename[MAX_PATH_CHARCOUNT];

	//
	// Define the file mask
	//

	wsprintfA(szFileMask, "%s\\*.*", lpszPathName);

	//
	// For each file in the file mask, delete it if it has the archive bit on
	//

	(INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szFileMask, &FindData))) ? fContinue = FALSE : fContinue = TRUE;
	while (TRUE == fContinue)
	{
		//
		// Check to see whether we need to step into a directory
		//

		if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			//
			// This is a directory, so lets delete it
			//

			if (FindData.cFileName[0] != '.')
			{
				wsprintfA(szFilename, "%s\\%s", lpszPathName, FindData.cFileName);
				RemoveDirectory(szFilename);
				::RemoveDirectory(szFilename);
			}
		}
		else
		{
			wsprintfA(szFilename, "%s\\%s", lpszPathName, FindData.cFileName);
      SetFileAttributes(szFilename, FILE_ATTRIBUTE_NORMAL);
			DeleteFile(szFilename);
		}

		fContinue = FindNextFile(hFindFile, &FindData);
	}

	FindClose(hFindFile);

  return ::RemoveDirectory(lpszPathName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::RemoveDirectory(LPCWSTR lpPathName)
{
  FUNCTION("CWin32API::RemoveDirectory ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return RemoveDirectory(szString);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDirectorySize(LPCSTR lpPathName)
{
  FUNCTION("CWin32API::GetDirectorySize ()");

  WIN32_FIND_DATA		FindData;
	HANDLE						hFindFile;
	BOOL							fContinue;
  DWORD             dwKilobytes;
	char							szFileMask[MAX_PATH_CHARCOUNT], szFilename[MAX_PATH_CHARCOUNT];

  //
  // Start at 0
  //

  dwKilobytes = 0;

	//
	// Define the file mask
	//

	wsprintfA(szFileMask, "%s\\*.*", lpPathName);

	//
	// For each file in the file mask, delete it if it has the archive bit on
	//

	(INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szFileMask, &FindData))) ? fContinue = FALSE : fContinue = TRUE;
	while (TRUE == fContinue)
	{
		//
		// Check to see whether we need to step into a directory
		//

		if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			if (FindData.cFileName[0] != '.')
			{
				wsprintfA(szFilename, "%s\\%s", lpPathName, FindData.cFileName);
				dwKilobytes += GetDirectorySize(szFilename);
			}
		}
		else
		{
      dwKilobytes += FindData.nFileSizeLow >> 10;
      dwKilobytes += FindData.nFileSizeHigh << 22;
		}
		fContinue = FindNextFile(hFindFile, &FindData);
	}

	FindClose(hFindFile);

  return dwKilobytes;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDirectorySize(LPCWSTR lpPathName)
{
  FUNCTION("CWin32API::GetDirectorySize ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetDirectorySize(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateProcess(LPSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo)
{
  FUNCTION("CWin32API::CreateProcess ()");

  STARTUPINFO sStartupInfo;

  ZeroMemory(&sStartupInfo, sizeof(sStartupInfo));
  sStartupInfo.cb = sizeof(sStartupInfo);
  ZeroMemory(lpProcessInfo, sizeof(PROCESS_INFORMATION));
  return ::CreateProcess(NULL, lpCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &sStartupInfo, lpProcessInfo);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateProcess(LPWSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo)
{
  FUNCTION("CWin32API::CreateProcess ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpCommandLine, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return CreateProcess(szString, lpProcessInfo);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateProcess(LPSTR lpApplication, LPSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo)
{
  FUNCTION("CWin32API::CreateProcess ()");

  STARTUPINFO sStartupInfo;

  ZeroMemory(&sStartupInfo, sizeof(sStartupInfo));
  sStartupInfo.cb = sizeof(sStartupInfo);
  ZeroMemory(lpProcessInfo, sizeof(PROCESS_INFORMATION));
  return ::CreateProcess(lpApplication, lpCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &sStartupInfo, lpProcessInfo);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CreateProcess(LPWSTR /*lpApplication*/, LPWSTR lpCommandLine, PROCESS_INFORMATION * lpProcessInfo)  // Get rid of /W4 warning.
{
  FUNCTION("CWin32API::CreateProcess ()");

  CHAR  szApplicationString[MAX_PATH_CHARCOUNT];
  CHAR  szCommandLineString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szCommandLineString, sizeof(szCommandLineString));
  if (WideCharToMultiByte(lpCommandLine, MAX_PATH_CHARCOUNT, szCommandLineString, MAX_PATH_CHARCOUNT))
  {
    ZeroMemory(szApplicationString, sizeof(szApplicationString));
    if (WideCharToMultiByte(lpCommandLine, MAX_PATH_CHARCOUNT, szApplicationString, MAX_PATH_CHARCOUNT))
    {
      return CreateProcess(szApplicationString, szCommandLineString, lpProcessInfo);
    }
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::IsValidFilename(LPCSTR lpFilename)
{
  FUNCTION("CWin32API::IsValidFilename ()");

  BOOL  fValid = TRUE;
  DWORD dwStringLen, dwIndex;

  dwStringLen = StrLenA(lpFilename);
  dwIndex = strcspn(lpFilename, "\\/<>:|*?\"\x0\x1\x2\x3\x4\x5\x6\x7\x8\x9\xa\xb\xc\xd\xe\xf\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e") + 1;
  if (255 < dwStringLen)
  {
    fValid = FALSE;
  }
  else if (1 == dwStringLen)
  {
    fValid = FALSE;
  }
  else if ((0 == _strnicmp(lpFilename, ".", 1))||(0 == _strnicmp(lpFilename, "..", 2)))
  {
    fValid = FALSE;
  }
  else if ((dwStringLen > dwIndex)&&(0 < dwIndex))
  {
    fValid = FALSE;
  }

  return fValid;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::IsValidFilename(LPCWSTR lpFilename)
{
  FUNCTION("CWin32API::IsValidFilename ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return IsValidFilename(szString);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::FileExists(LPCSTR lpFilename)
{
  FUNCTION("CWin32API::FileExists ()");

  WIN32_FIND_DATA   sFindFileInfo;
  HANDLE            hFindFileHandle;

  hFindFileHandle = FindFirstFile(lpFilename, &sFindFileInfo);
  if (INVALID_HANDLE_VALUE == hFindFileHandle)
  {
    return FALSE;
  }

  FindClose(hFindFileHandle);
  return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::FileExists(LPCWSTR lpFilename)
{
  FUNCTION("CWin32API::FileExists ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return FileExists(szString);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::FileAttributes(LPCSTR lpFilename)
{
  FUNCTION("CWin32API::FileAttributes()");

  WIN32_FIND_DATA   sFindFileInfo;
  HANDLE            hFindFileHandle;

  hFindFileHandle = FindFirstFile(lpFilename, &sFindFileInfo);
  if (INVALID_HANDLE_VALUE == hFindFileHandle)
  {
    return 0;
  }

  FindClose(hFindFileHandle);

  return sFindFileInfo.dwFileAttributes;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::FileAttributes(LPCWSTR lpFilename)
{
  FUNCTION("CWin32API::FileAttributes()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return FileAttributes(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetFileSize(LPCSTR lpFilename)
{
  FUNCTION("CWin32API::GetFileSize()");

  HANDLE  hFileHandle;
  DWORD   dwFileSize;

  dwFileSize = 0;
  hFileHandle = CreateFile(lpFilename, GENERIC_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL);
  if (INVALID_HANDLE_VALUE != hFileHandle)
  {
    dwFileSize = (::GetFileSize(hFileHandle, NULL)) / 1024;
    CloseHandle(hFileHandle);
  }

  return dwFileSize;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetFileSize(LPCWSTR lpFilename)
{
  FUNCTION("CWin32API::GetFileSize()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetFileSize(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HANDLE CWin32API::CreateFile(LPCSTR lpFilename, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes)
{
  FUNCTION("CWin32API::CreateFile ()");

  return ::CreateFile(lpFilename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HANDLE CWin32API::CreateFile(LPCWSTR lpFilename, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes)
{
  FUNCTION("CWin32API::CreateFile ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return CreateFile(szString, dwDesiredAccess, dwShareMode, dwCreationDisposition, dwFlagsAndAttributes);
  }

  return INVALID_HANDLE_VALUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::DeleteFile(LPCSTR lpFilename)
{
  FUNCTION("CWin32API::DeleteFile ()");

  return ::DeleteFile(lpFilename);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::DeleteFile(LPCWSTR lpFilename)
{
  FUNCTION("CWin32API::DeleteFile ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return DeleteFile(szString);
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HANDLE CWin32API::CreateFileMapping(HANDLE hFile, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
{
  FUNCTION("CWin32API::CreateFileMapping ()");

  return ::CreateFileMapping(hFile, NULL, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

HANDLE CWin32API::CreateFileMapping(HANDLE hFile, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
{
  FUNCTION("CWin32API::CreateFileMapping ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return CreateFileMapping(hFile, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, szString);
  }

  return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CopyFile(LPCSTR lpSourceFileName, LPCSTR lpDestinationFileName, BOOL bFailIfExists)
{
  FUNCTION("CWin32API::CopyFile ()");

  return ::CopyFile(lpSourceFileName, lpDestinationFileName, bFailIfExists);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::CopyFile(LPCWSTR lpSourceFileName, LPCWSTR lpDestinationFileName, BOOL bFailIfExists)
{
  FUNCTION("CWin32API::CopyFile ()");

  CHAR  szSource[MAX_PATH_CHARCOUNT];
  CHAR  szDestination[MAX_PATH_CHARCOUNT];

  ZeroMemory(szSource, sizeof(szSource));
  if (WideCharToMultiByte(lpSourceFileName, MAX_PATH_CHARCOUNT, szSource, MAX_PATH_CHARCOUNT))
  {
    ZeroMemory(szDestination, sizeof(szDestination));
    if (WideCharToMultiByte(lpDestinationFileName, MAX_PATH_CHARCOUNT, szDestination, MAX_PATH_CHARCOUNT))
    {
      return CopyFile(szSource, szDestination, bFailIfExists);
    }
  }

  return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveSize(LPCSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveSize ()");

  ULARGE_INTEGER  lFreeBytesAvailableToCaller, lTotalSize, lTotalFreeBytes;
  DWORD           dwTotalNumberOfClusters, dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters;
  DWORD           dwReturnValue = 0;

  if (OS_VERSION_WIN95_OSR2 <= GetOSVersion())
  {
    //
    // Excellent, we can use the better GetDiskFreeSpaceEx function
    //

    if (GetDiskFreeSpaceEx(lpRootPathName, &lFreeBytesAvailableToCaller, &lTotalSize, &lTotalFreeBytes))
    {
      dwReturnValue = lTotalSize.LowPart >> 10;
      dwReturnValue += lTotalSize.HighPart << 22;
    }
  }
  else
  {
    //
    // Bummer we must make use of the GetDiskFreeSpace function
    //

    if (GetDiskFreeSpace(lpRootPathName, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
      dwReturnValue = ((dwTotalNumberOfClusters * dwSectorsPerCluster * dwBytesPerSector) / 1024);
    }
  }

  return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveSize(LPCWSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveSize ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetDriveSize(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveFreeSpace(LPCSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveFreeSpace ()");

  ULARGE_INTEGER  lFreeBytesAvailableToCaller, lTotalSize, lTotalFreeBytes;
  DWORD           dwTotalNumberOfClusters, dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters;
  DWORD           dwReturnValue = 0;

  if (OS_VERSION_WIN95_OSR2 <= GetOSVersion())
  {
    //
    // Excellent, we can use the better GetDiskFreeSpaceEx function
    //

    if (GetDiskFreeSpaceEx(lpRootPathName, &lFreeBytesAvailableToCaller, &lTotalSize, &lTotalFreeBytes))
    {
      dwReturnValue = lTotalFreeBytes.LowPart >> 10;
      dwReturnValue += lTotalFreeBytes.HighPart << 22;
    }
  }
  else
  {
    //
    // Bummer we must make use of the GetDiskFreeSpace function
    //

    if (GetDiskFreeSpace(lpRootPathName, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
      dwReturnValue = ((dwNumberOfFreeClusters * dwSectorsPerCluster * dwBytesPerSector) / 1024);
    }
  }

  return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveFreeSpace(LPCWSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveFreeSpace ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetDriveFreeSpace(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveUserFreeSpace(LPCSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveUserFreeSpace ()");

  ULARGE_INTEGER  lFreeBytesAvailableToCaller, lTotalSize, lTotalFreeBytes;
  DWORD           dwTotalNumberOfClusters, dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters;
  DWORD           dwReturnValue = 0;

  if (OS_VERSION_WIN95_OSR2 <= GetOSVersion())
  {
    //
    // Excellent, we can use the better GetDiskFreeSpaceEx function
    //

    if (GetDiskFreeSpaceEx(lpRootPathName, &lFreeBytesAvailableToCaller, &lTotalSize, &lTotalFreeBytes))
    {
      dwReturnValue = lFreeBytesAvailableToCaller.LowPart >> 10;
      dwReturnValue += lFreeBytesAvailableToCaller.HighPart << 22;
    }
  }
  else
  {
    //
    // Bummer we must make use of the GetDiskFreeSpace function
    //

    if (GetDiskFreeSpace(lpRootPathName, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
      dwReturnValue = ((dwNumberOfFreeClusters * dwSectorsPerCluster * dwBytesPerSector) / 1024);
    }
  }

  return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD CWin32API::GetDriveUserFreeSpace(LPCWSTR lpRootPathName)
{
  FUNCTION("CWin32API::GetDriveUserFreeSpace ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetDriveUserFreeSpace(szString);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::GetVolumeInformation(LPCSTR lpRootPathName, LPSTR lpVolumeLabel, const DWORD dwVolumeLabelSize, LPDWORD lpdwVolumeSerialNumber)
{
  FUNCTION("CWin32API::GetVolumeInformation ()");

  return ::GetVolumeInformation(lpRootPathName, lpVolumeLabel, dwVolumeLabelSize, lpdwVolumeSerialNumber, NULL, NULL, NULL, 0);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::GetVolumeInformation(LPCWSTR lpRootPathName, LPSTR lpVolumeLabel, const DWORD dwVolumeLabelSize, LPDWORD lpdwVolumeSerialNumber)
{
  FUNCTION("CWin32API::GetVolumeInformation ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpRootPathName, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return GetVolumeInformation(szString, lpVolumeLabel, dwVolumeLabelSize, lpdwVolumeSerialNumber);
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::SetFileAttributes(LPCSTR lpFilename, const DWORD dwFileAttributes)
{
  FUNCTION("CWin32API::SetFileAttributes ()");

  return ::SetFileAttributes(lpFilename, dwFileAttributes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

BOOL CWin32API::SetFileAttributes(LPCWSTR lpFilename, const DWORD dwFileAttributes)
{
  FUNCTION("CWin32API::SetFileAttributes ()");

  CHAR  szString[MAX_PATH_CHARCOUNT];

  ZeroMemory(szString, sizeof(szString));
  if (WideCharToMultiByte(lpFilename, MAX_PATH_CHARCOUNT, szString, MAX_PATH_CHARCOUNT))
  {
    return SetFileAttributes(szString, dwFileAttributes);
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\cominterface\win9x\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif


$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\AppMan.h: ..\..\Include\AppMan.h
	-binplace  $(SDK_INC_PATH)\AppMan.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\include\makefile.inc ===
#
#  Copy the appman heads to the public
#

# The following line places the DX8 header for AppMan
$(SDK_INC_PATH)\appman.h: appman.h
        copy appman.h $(SDK_INC_PATH)\appman.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\include\appmanadmin.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// IAppManAdmin
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __IAPPMANADMIN_
#define __IAPPMANADMIN_

#ifdef __cplusplus
extern "C" {
#endif

#include "AppMan.h"

//
// GUID definition for the IApplicationManagerAdmin interface
//
//    IID_ApplicationManagerAdmin = {8AE0897A-923A-4a1e-AA50-79E508281DAB}
//

DEFINE_GUID(IID_ApplicationManagerAdmin, 0x8ae0897a, 0x923a, 0x4a1e, 0xaa, 0x50, 0x79, 0xe5, 0x8, 0x28, 0x1d, 0xab);

//
// Device indexes go from 0-25 (A: through Z:). The MAX_DEVICES define should be used
// as an upper limit (exclusive)
//

#define MAX_DEVICES                                       26

//
// Defines used with GetProperty method
//

#define DEVICE_PROPERTY_TOTALKILOBYTES                    0x00000001 
#define DEVICE_PROPERTY_TOTALFREEKILOBYTES                0x00000002
#define DEVICE_PROPERTY_TOTALAVAILABLEKILOBYTES           0x00000004
#define DEVICE_PROPERTY_OPTIMALAVAILABLEKILOBYTES         0x00000008
#define DEVICE_PROPERTY_REMOVABLEKILOBYTES                0x00000010
#define DEVICE_PROPERTY_NONREMOVABLEKILOBYTES             0x00000020
#define DEVICE_PROPERTY_RESERVEDKILOBYTES                 0x00000040
#define DEVICE_PROPERTY_TOTALTEMPORARYKILOBYTES           0x00000080
#define DEVICE_PROPERTY_USEDTEMPORARYKILOBYTES            0x00000100
#define DEVICE_PROPERTY_PERCENTCACHESIZE                  0x00000200
#define DEVICE_PROPERTY_PERCENTMINIMUMFREESIZE            0x00000400
#define DEVICE_PROPERTY_EXCLUSIONMASK                     0x00000800

#define APPMAN_PROPERTY_TOTALKILOBYTES                    0x10000000
#define APPMAN_PROPERTY_OPTIMALKILOBYTES                  0x20000000
#define APPMAN_PROPERTY_ADVANCEDMODE                      0x40000000

//
// Defines used to define device exclusion mask
//

#define DEVICE_EXCLUDE_ALL                                0xffffffff
#define DEVICE_EXCLUSION_MASK                             DEVICE_EXCLUDE_ALL

//
// Defines used with the DoAction method
//

#define ACTION_APP_DOWNSIZE                               0x00000008
#define ACTION_APP_REINSTALL                              0x00000010
#define ACTION_APP_UNINSTALL                              0x00000020
#define ACTION_APP_SELFTEST                               0x00000040
#define ACTION_APP_RUN_BLOCK                              0x00000080
#define ACTION_APP_RUN_NOBLOCK                            0x00000100
#define ACTION_APP_PIN                                    0x00000200
#define ACTION_APP_UNINSTALLBLOCK                         0x00000400

#define SORT_APP_LASTUSEDDATE                             0x00000001
#define SORT_APP_SIGNATURE                                0x00000002
#define SORT_APP_COMPANYNAME                              0x00000004
#define SORT_APP_SIZE                                     0x00000008
#define SORT_APP_ASCENDING                                0x40000000
#define SORT_APP_DESCENDING                               0x80000000

//
// These defines are used in conjunction with the APP_PROPERTY_CATEGORY and the 
// IApplicationEntry->SetProperty() and IApplicationEntry->GetProperty() methods
//

#define APP_CATEGORY_PRODUCTIVITY                 0x00000002
#define APP_CATEGORY_PUBLISHING                   0x00000004
#define APP_CATEGORY_SCIENTIFIC                   0x00000008
#define APP_CATEGORY_AUTHORING                    0x00000010
#define APP_CATEGORY_MEDICAL                      0x00000020
#define APP_CATEGORY_BUSINESS                     0x00000040
#define APP_CATEGORY_FINANCIAL                    0x00000080
#define APP_CATEGORY_EDUCATIONAL                  0x00000100
#define APP_CATEGORY_REFERENCE                    0x00000200
#define APP_CATEGORY_WEB                          0x00000400
#define APP_CATEGORY_DEVELOPMENTTOOL              0x00000800
#define APP_CATEGORY_MULTIMEDIA                   0x00001000
#define APP_CATEGORY_VIRUSCLEANER                 0x00002000
#define APP_CATEGORY_CONNECTIVITY                 0x00004000
#define APP_CATEGORY_MISC                         0x00008000

//
// Old retired properties that still require support
//

#define APP_PROPERTY_REMOVABLEKILOBYTES                   0x0000000b
#define APP_PROPERTY_NONREMOVABLEKILOBYTES                0x0000000a

//
// Misc defines
//

#define APP_PROPERTY_PIN                                  0x00000018
#define APP_CATEGORY_LEGACY                               0x80000000

//
// Error defines
//

#define APPMANADMIN_E_INVALIDPROPERTY                     0x85680001
#define APPMANADMIN_E_READONLYPROPERTY                    0x85680002
#define APPMANADMIN_E_INVALIDPARAMETERS                   0x85680003

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface definitions
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if defined( _WIN32 ) && !defined( _NO_COM )

//
// IApplicationManager Interface
//

#undef INTERFACE
#define INTERFACE IApplicationManagerAdmin
DECLARE_INTERFACE_( IApplicationManagerAdmin, IUnknown )
{
  //
	// IUnknown Interfaces
	//

  STDMETHOD (QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
	STDMETHOD_(ULONG, Release) (THIS) PURE;

  //
  // IApplicationManager interface methods
  //

  STDMETHOD (EnumerateDevices) (THIS_ const DWORD, GUID *) PURE;
  STDMETHOD (GetDeviceProperty) (THIS_ const DWORD, const GUID *, LPVOID, const DWORD) PURE;
  STDMETHOD (SetDeviceProperty) (THIS_ const DWORD, const GUID *, LPVOID, const DWORD) PURE;
  STDMETHOD (GetAppManProperty) (THIS_ const DWORD, LPVOID, const DWORD) PURE;
  STDMETHOD (SetAppManProperty) (THIS_ const DWORD, LPCVOID, const DWORD) PURE;
  STDMETHOD (CreateApplicationEntry) (THIS_ IApplicationEntry **) PURE;
  STDMETHOD (GetApplicationInfo) (IApplicationEntry *) PURE;
  STDMETHOD (EnumApplications) (THIS_ const DWORD, IApplicationEntry *) PURE;
  STDMETHOD (DoApplicationAction) (THIS_ const DWORD, const GUID *, const DWORD, LPVOID, const DWORD) PURE;
};

#endif  // defined( _WIN32 ) && !defined( _NO_COM )

#ifdef __cplusplus
}
#endif

#endif  // __IAPPMANADMIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\include\appman.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 1998, 1999, 2000 Microsoft Corporation. All rights reserved.
//
// File :     AppMan.h
//
// Content :  Include file containing the IApplicationManager and IApplicationEntry 
//            interfaces needed to use the Windows Application Manager
// 
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __IAPPMAN_
#define __IAPPMAN_

#ifdef __cplusplus
extern "C" {
#endif  // _cplusplus

//
// Get a few important things defined properly before proceeding
//

#undef EXPORT
#ifdef  WIN32
#define EXPORT __declspec(dllexport)
#else   // WIN32
#define EXPORT __export
#endif  // WIN32

#if defined( _WIN32 ) && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else   // defined( _WIN32 )  && !defined( _NO_COM )
#include "windows.h"
#include "ole2.h"
#define IUnknown	    void
#endif  // defined( _WIN32 )  && !defined( _NO_COM )

//
// GUID definition for the IApplicationManager interface
//
//    CLSID_ApplicationManager = {553C75D7-C0B6-480d-92CC-F936D75FD87C}
//    IID_ApplicationManager = {6084A2E8-3FB7-4d1c-B14B-6ADBAAF7CECE}
//    IID_ApplicationEntry = {7BA2201F-4DE7-4ef7-BBA3-C69A716B8CD9}
//

DEFINE_GUID(CLSID_ApplicationManager, 0x553c75d7, 0xc0b6, 0x480d, 0x92, 0xcc, 0xf9, 0x36, 0xd7, 0x5f, 0xd8, 0x7c);
DEFINE_GUID(IID_ApplicationManager, 0x6084a2e8, 0x3fb7, 0x4d1c, 0xb1, 0x4b, 0x6a, 0xdb, 0xaa, 0xf7, 0xce, 0xce);
DEFINE_GUID(IID_ApplicationEntry, 0x7ba2201f, 0x4de7, 0x4ef7, 0xbb, 0xa3, 0xc6, 0x9a, 0x71, 0x6b, 0x8c, 0xd9);

//
// These defines are used in conjunction with the APP_PROPERTY_STATE and the 
// IApplicationEntry->SetProperty() and IApplicationEntry->GetProperty() methods
//

#define APP_STATE_INSTALLING                      0x00000001
#define APP_STATE_READY                           0x00000002
#define APP_STATE_DOWNSIZING                      0x00000004
#define APP_STATE_DOWNSIZED                       0x00000008
#define APP_STATE_REINSTALLING                    0x00000010
#define APP_STATE_UNINSTALLING                    0x00000020
#define APP_STATE_UNINSTALLED                     0x00000040
#define APP_STATE_SELFTESTING                     0x00000080
#define APP_STATE_UNSTABLE                        0x00000100

#define APP_STATE_MASK                            0x000001ff

//
// These defines are used in conjunction with the APP_PROPERTY_CATEGORY and the 
// IApplicationEntry->SetProperty() and IApplicationEntry->GetProperty() methods. More
// categories will be supported in version 2.
//

#define APP_CATEGORY_NONE                         0x00000000
#define APP_CATEGORY_ENTERTAINMENT                0x00000001

#define APP_CATEGORY_DEMO                         0x01000000
#define APP_CATEGORY_PATCH                        0x02000000
#define APP_CATEGORY_DATA                         0x04000000

#define APP_CATEGORY_ALL                          0x0700ffff
  
//
// These defines are used as the dwPropertyDefine parameter of the
// IApplicationEntry->SetProperty() and IApplicationEntry->GetProperty() methods
//

#define APP_PROPERTY_GUID                         0x00000001
#define APP_PROPERTY_COMPANYNAME                  0x00000002
#define APP_PROPERTY_SIGNATURE                    0x00000003
#define APP_PROPERTY_VERSIONSTRING                0x00000004
#define APP_PROPERTY_ROOTPATH                     0x00000005
#define APP_PROPERTY_SETUPROOTPATH                0x00000006
#define APP_PROPERTY_STATE                        0x00000007
#define APP_PROPERTY_CATEGORY                     0x00000008
#define APP_PROPERTY_ESTIMATEDINSTALLKILOBYTES    0x00000009
#define APP_PROPERTY_EXECUTECMDLINE               0x0000000c
#define APP_PROPERTY_DEFAULTSETUPEXECMDLINE       0x0000001a
#define APP_PROPERTY_DOWNSIZECMDLINE              0x0000000d
#define APP_PROPERTY_REINSTALLCMDLINE             0x0000000e
#define APP_PROPERTY_UNINSTALLCMDLINE             0x0000000f
#define APP_PROPERTY_SELFTESTCMDLINE              0x00000010
#define APP_PROPERTY_INSTALLDATE                  0x00000013
#define APP_PROPERTY_LASTUSEDDATE                 0x00000014
#define APP_PROPERTY_TITLEURL                     0x00000015
#define APP_PROPERTY_PUBLISHERURL                 0x00000016
#define APP_PROPERTY_DEVELOPERURL                 0x00000017
#define APP_PROPERTY_XMLINFOFILE                  0x00000019

//
// Defines used as OR mask modifiers for the APP_PROPERTY_xxx string based properties.
// The default is APP_PROPERTY_STR_UNICODE. 
//
//  Used as OR masks for the dwPropertyDefines parameter of:
//        IApplicationEntry->GetProperty()
//        IApplicationEntry->SetProperty()
//
//  Used alone for the dwStringDefine parameters of:
//        IApplicationManager->EnumDevices()
//        IApplicationEntry->GetTemporarySpace()
//        IApplicationEntry->RemoveTemporarySpace()
//        IApplicationEntry->EnumTemporarySpaces()
//

#define APP_PROPERTY_STR_ANSI                     0x40000000
#define APP_PROPERTY_STR_UNICODE                  0x80000000

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#define APP_PROPERTY_TSTR                         APP_PROPERTY_STR_UNICODE
#else   // _UNICODE
#define APP_PROPERTY_TSTR                         APP_PROPERTY_STR_ANSI
#endif  // _UNICODE

//
// Association specific defines. Associations are used to inherit root paths from 
// existing applications.
//
//  APP_ASSOCIATION_CHILD :                 OR mask used only in the dwAssociationType
//                                          parameter of the
//                                          IApplicationEntry->EnumAssociations(...) method.
//                                          This bit means that the IApplicationEntry object
//                                          is a child in the relationship
//  APP_ASSOCIATION_PARENT :                OR mask used obly in the dwAssociationType
//                                          parameter of the
//                                          IApplicationEntry->EnumAssociations(...) method.
//                                          This bit means that the IApplicationEntry object
//                                          is the parent in the relationship
//  APP_ASSOCIATION_INHERITBOTHPATHS :      Inherit both the APP_PROPERTY_ROOTPATH and
//                                          APP_PROPERTYSETUPROOTPATH of the parent
//                                          application.
//  APP_ASSOCIATION_INHERITAPPROOTPATH :    Inherit the APP_PROPERTY_ROOTPATH of the parent
//                                          application. Get a unique
//                                          APP_PROPERTY_SETUPROOTPATH.
//  APP_ASSOCIATION_INHERITSETUPROOTPATH :  Inherit the APP_PROPERTY_SETUPROOTPATH of the
//                                          parent application. Get a unique
//                                          APP_PROPERTY_ROOTPATH.
//

#define APP_ASSOCIATION_CHILD                     0x40000000
#define APP_ASSOCIATION_PARENT                    0x80000000
#define APP_ASSOCIATION_INHERITBOTHPATHS          0x00000001
#define APP_ASSOCIATION_INHERITAPPROOTPATH        0x00000002
#define APP_ASSOCIATION_INHERITSETUPROOTPATH      0x00000004

//
// Defines used for the dwRunFlags parameter of the IApplicationEntry->Run(...) method. These
// defines determine whether the Run(...) method should wait for the application to terminate
// before returning.
//

#define APP_RUN_NOBLOCK                           0x00000000
#define APP_RUN_BLOCK                             0x00000001

//
// String length defines (in characters, not bytes)
//
//    MAX_COMPANYNAME_CHARCOUNT --> APP_PROPERTY_COMPANYNAME
//    MAX_SIGNATURE_CHARCOUNT --> APP_PROPERTY_SIGNATURE
//    MAX_VERSIONSTRING_CHARCOUNT --> APP_PROPERTY_VERSIONSTRING
//    MAX_PATH_CHARCOUNT --> APP_PROPERTY_ROOTPATH
//                           APP_PROPERTY_SETUPROOTPATH
//                           APP_PROPERTY_XMLINFOFILE
//                           APP_PROPERTY_TITLEURL
//                           APP_PROPERTY_PUBLISHERURL
//                           APP_PROPERTY_DEVELOPERURL
//    MAX_CMDLINE_CHARCOUNT --> APP_PROPERTY_EXECUTECMDLINE
//                              APP_PROPERTY_DEFAULTSETUPEXECMDLINE
//                              APP_PROPERTY_DOWNSIZECMDLINE
//                              APP_PROPERTY_REINSTALLCMDLINE
//                              APP_PROPERTY_UNINSTALLCMDLINE
//                              APP_PROPERTY_SELFTESTCMDLINE
//
//

#define MAX_COMPANYNAME_CHARCOUNT                 64
#define MAX_SIGNATURE_CHARCOUNT                   64
#define MAX_VERSIONSTRING_CHARCOUNT               16
#define MAX_PATH_CHARCOUNT                        255
#define MAX_CMDLINE_CHARCOUNT                     255

//
// Application Manager specific COM error codes
//

#define APPMAN_E_NOTINITIALIZED                   0x85670001
#define APPMAN_E_INVALIDPROPERTYSIZE              0x85670005
#define APPMAN_E_INVALIDDATA                      0x85670006
#define APPMAN_E_INVALIDPROPERTY                  0x85670007
#define APPMAN_E_READONLYPROPERTY                 0x85670008
#define APPMAN_E_PROPERTYNOTSET                   0x85670009
#define APPMAN_E_OVERFLOW                         0x8567000a
#define APPMAN_E_INVALIDPROPERTYVALUE             0x8567000c
#define APPMAN_E_ACTIONINPROGRESS                 0x8567000d
#define APPMAN_E_ACTIONNOTINITIALIZED             0x8567000e
#define APPMAN_E_REQUIREDPROPERTIESMISSING        0x8567000f
#define APPMAN_E_APPLICATIONALREADYEXISTS         0x85670010
#define APPMAN_E_APPLICATIONALREADYLOCKED         0x85670011
#define APPMAN_E_NODISKSPACEAVAILABLE             0x85670012
#define APPMAN_E_UNKNOWNAPPLICATION               0x85670014
#define APPMAN_E_INVALIDPARAMETERS                0x85670015
#define APPMAN_E_OBJECTLOCKED                     0x85670017
#define APPMAN_E_INVALIDINDEX                     0x85670018
#define APPMAN_E_REGISTRYCORRUPT                  0x85670019
#define APPMAN_E_CANNOTASSOCIATE                  0x8567001a
#define APPMAN_E_INVALIDASSOCIATION               0x8567001b
#define APPMAN_E_ALREADYASSOCIATED                0x8567001c
#define APPMAN_E_APPLICATIONREQUIRED              0x8567001d
#define APPMAN_E_INVALIDEXECUTECMDLINE            0x8567001e
#define APPMAN_E_INVALIDDOWNSIZECMDLINE           0x8567001f
#define APPMAN_E_INVALIDREINSTALLCMDLINE          0x85670020
#define APPMAN_E_INVALIDUNINSTALLCMDLINE          0x85670021
#define APPMAN_E_INVALIDSELFTESTCMDLINE           0x85670022
#define APPMAN_E_PARENTAPPNOTREADY                0x85670023
#define APPMAN_E_INVALIDSTATE                     0x85670024
#define APPMAN_E_INVALIDROOTPATH                  0x85670025
#define APPMAN_E_CACHEOVERRUN                     0x85670026
#define APPMAN_E_REINSTALLDX                      0x85670028
#define APPMAN_E_APPNOTEXECUTABLE                 0x85670029

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface definitions
//
//////////////////////////////////////////////////////////////////////////////////////////////

#if defined( _WIN32 ) && !defined( _NO_COM )

//
// IApplicationEntry Interface
//
//    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
//    STDMETHOD_(ULONG, AddRef) (void);
//    STDMETHOD_(ULONG, Release) (void);
//    STDMETHOD (Clear) (void);
//    STDMETHOD (GetProperty) (const DWORD dwPropertyDefine, LPVOID lpData, const DWORD dwDataLenInBytes);
//    STDMETHOD (SetProperty) (const DWORD dwPropertyDefine, LPCVOID lpData, const DWORD dwDataLenInBytes);
//    STDMETHOD (InitializeInstall) (void);
//    STDMETHOD (FinalizeInstall) (void);
//    STDMETHOD (InitializeDownsize) (void);
//    STDMETHOD (FinalizeDownsize) (void);
//    STDMETHOD (InitializeReInstall) (void);
//    STDMETHOD (FinalizeReInstall) (void);
//    STDMETHOD (InitializeUnInstall) (void);
//    STDMETHOD (FinalizeUnInstall) (void);
//    STDMETHOD (InitializeSelfTest) (void);
//    STDMETHOD (FinalizeSelfTest) (void);
//    STDMETHOD (Abort) (void);
//    STDMETHOD (Run) (const DWORD dwRunFlags, const DWORD dwStringMask, LPVOID lpData, const DWORD dwDataLenInBytes);
//    STDMETHOD (AddAssociation) (const DWORD dwAssociationDefine, const IApplicationEntry * lpApplicationEntry);
//    STDMETHOD (RemoveAssociation) (const DWORD dwAssociationDefine, const IApplicationEntry * lpApplicationEntry);
//    STDMETHOD (EnumAssociations) (const DWORD dwZeroBasedIndex, LPDWORD lpdwAssociationDefineMask, IApplicationEntry * lpApplicationEntry);
//    STDMETHOD (GetTemporarySpace) (const DWORD dwSpaceInKilobytes, const DWORD dwStringDefine, LPVOID lpData, const DWORD dwDataLen);
//    STDMETHOD (RemoveTemporarySpace) (const DWORD dwStringDefine, LPVOID lpData, const DWORD dwDataLen);
//    STDMETHOD (EnumTemporarySpaces) (const DWORD dwZeroBasedIndex, LPDWORD lpdwSpaceInKilobytes, const DWORD dwStringDefine, LPVOID lpData, const DWORD dwDataLen);
//

#undef INTERFACE
#define INTERFACE IApplicationEntry
DECLARE_INTERFACE_( IApplicationEntry, IUnknown )
{
  //
  // IUnknown interfaces
  //

  STDMETHOD (QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
  STDMETHOD_(ULONG, AddRef) (THIS) PURE;
  STDMETHOD_(ULONG, Release) (THIS) PURE;

  //
  // IApplicationEntry interface methods
  //

  STDMETHOD (Clear) (THIS) PURE;
  STDMETHOD (GetProperty) (THIS_ const DWORD, LPVOID, const DWORD) PURE;
  STDMETHOD (SetProperty) (THIS_ const DWORD, LPCVOID, const DWORD) PURE;
  STDMETHOD (InitializeInstall) (THIS) PURE;
  STDMETHOD (FinalizeInstall) (THIS) PURE;
  STDMETHOD (InitializeDownsize) (THIS) PURE;
  STDMETHOD (FinalizeDownsize) (THIS) PURE;
  STDMETHOD (InitializeReInstall) (THIS) PURE;
  STDMETHOD (FinalizeReInstall) (THIS) PURE;
  STDMETHOD (InitializeUnInstall) (THIS) PURE;
  STDMETHOD (FinalizeUnInstall) (THIS) PURE;
  STDMETHOD (InitializeSelfTest) (THIS) PURE;
  STDMETHOD (FinalizeSelfTest) (THIS) PURE;
  STDMETHOD (Abort) (THIS) PURE;
  STDMETHOD (Run) (THIS_ const DWORD, const DWORD, LPVOID, const DWORD) PURE;
  STDMETHOD (AddAssociation) (THIS_ const DWORD, const IApplicationEntry *) PURE;
  STDMETHOD (RemoveAssociation) (THIS_ const DWORD, const IApplicationEntry *) PURE;
  STDMETHOD (EnumAssociations) (THIS_ const DWORD, LPDWORD, IApplicationEntry *) PURE;
  STDMETHOD (GetTemporarySpace) (THIS_ const DWORD, const DWORD, LPVOID, const DWORD) PURE;
  STDMETHOD (RemoveTemporarySpace) (THIS_ const DWORD, LPVOID, const DWORD) PURE;
  STDMETHOD (EnumTemporarySpaces) (THIS_ const DWORD, LPDWORD, const DWORD, LPVOID, const DWORD ) PURE;
};

//
// IApplicationManager Interface
//
//    STDMETHOD (QueryInterface) (REFIID RefIID, LPVOID * lppVoidObject);
//    STDMETHOD_(ULONG, AddRef) (void);
//    STDMETHOD_(ULONG, Release) (void);
//    STDMETHOD (GetAdvancedMode) (LPDWORD lpdwAdvancedMode);
//    STDMETHOD (GetAvailableSpace) (const DWORD dwCategoryDefine, LPDWORD lpdwMaximumSpaceInKilobytes, LPDWORD lpdwOptimalSpaceInKilobytes);
//    STDMETHOD (CreateApplicationEntry) (IApplicationEntry ** lppObject);
//    STDMETHOD (GetApplicationInfo) (IApplicationEntry * lpObject);
//    STDMETHOD (EnumApplications) (const DWORD dwZeroBasedIndex, IApplicationEntry * lpObject);
//    STDMETHOD (EnumDevices) (const DWORD dwZeroBasedIndex, LPDWORD lpdwAvailableSpaceInKilobytes, LPDWORD lpdwCategoryDefineExclusionMask, const DWORD dwStringDefine, LPVOID lpData, const DWORD dwDataLen);
//

#undef INTERFACE
#define INTERFACE IApplicationManager
DECLARE_INTERFACE_( IApplicationManager, IUnknown )
{
  //
  // IUnknown Interfaces
  //

  STDMETHOD (QueryInterface) (THIS_ REFIID, LPVOID *) PURE;
  STDMETHOD_(ULONG, AddRef) (THIS) PURE;
  STDMETHOD_(ULONG, Release) (THIS) PURE;

  //
  // IApplicationManager interface methods
  //

  STDMETHOD (GetAdvancedMode) (THIS_ LPDWORD) PURE;
  STDMETHOD (GetAvailableSpace) (THIS_ const DWORD, LPDWORD, LPDWORD) PURE;
  STDMETHOD (CreateApplicationEntry) (THIS_ IApplicationEntry **) PURE;
  STDMETHOD (GetApplicationInfo) (THIS_ IApplicationEntry *) PURE;
  STDMETHOD (EnumApplications) (THIS_ const DWORD, IApplicationEntry *) PURE;
  STDMETHOD (EnumDevices) (THIS_ const DWORD, LPDWORD, LPDWORD, const DWORD, LPVOID, const DWORD) PURE;

};

#endif  // defined( _WIN32 ) && !defined( _NO_COM )

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif // __IAPPMAN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\include\emptyvc.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// Module:  IEmptyVolumeCache and IEmptyVolumeCacheCallBack interfaces
// File:    emptyvc.h
//
// Purpose: Defines IEmptyVolumeCache and IEmptyVolumeCacheCallBack
//          interface
// Notes:
// Mod Log: Created by Jason Cobb (2/97)
//
// Copyright (c)1997 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __EMPTYVC_H
#define __EMPTYVC_H

//
// GUID definition for the IApplicationManager interface
//
//    IID_IEmptyVolumeCacheCallBack = {6E793361-73C6-11D0-8469-00AA00442901}
//    IID_IEmptyVolumeCache = {8FCE5227-04DA-11d1-A004-00805F8ABE06}

DEFINE_GUID (IID_IEmptyVolumeCacheCallBack, 0x6E793361, 0x73C6, 0x11D0, 0x84, 0x69, 0x00, 0xAA, 0x00, 0x44, 0x29, 0x01);
DEFINE_GUID (IID_IEmptyVolumeCache, 0x8fce5227, 0x4da, 0x11d1, 0xa0, 0x4, 0x0, 0x80, 0x5f, 0x8a, 0xbe, 0x6);

//
// IEmptyVolumeCache global Flags
//

#define EVCF_HASSETTINGS            0x00000001
#define EVCF_ENABLEBYDEFAULT        0x00000002
#define EVCF_REMOVEFROMLIST         0x00000004
#define EVCF_ENABLEBYDEFAULT_AUTO   0x00000008
#define EVCF_DONTSHOWIFZERO         0x00000010
#define EVCF_SETTINGSMODE           0x00000020
#define EVCF_OUTOFDISKSPACE         0x00000040

//
// IEmptyVolumeCacheCallBack global Flags
//

#define EVCCBF_LASTNOTIFICATION     0x00000001

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Class:   CLISD_IEmptyVolumeCacheCallBack
// Purpose: This is the CLISD_IEmptyVolumeCacheCallBack interface
// Notes:   
// Mod Log: Created by Jason Cobb (2/97)
//
//////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IEmptyVolumeCacheCallBack
interface IEmptyVolumeCacheCallBack : IUnknown
{
  //
  // CLISD_IEmptyVolumeCacheCallBack interface members
  //

  STDMETHOD (ScanProgress) (THIS_ DWORDLONG, DWORD, LPCWSTR) PURE;
  STDMETHOD (PurgeProgress) (THIS_ DWORDLONG, DWORDLONG, DWORD, LPCWSTR) PURE;                         
};

typedef IEmptyVolumeCacheCallBack *LPIEMPTYVOLUMECACHECALLBACK;

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Class:   IEmptyVolumeCache
// Purpose: This is the IEmptyVolumeCache interface
// Notes:   
// Mod Log: Created by Jason Cobb (2/97)
//
//////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IEmptyVolumeCache
interface IEmptyVolumeCache : IUnknown
{
    //
    // IEmptyVolumeCache interface members
    //

    STDMETHOD (Initialize) (THIS_ HKEY, LPCWSTR, LPWSTR *, LPWSTR *, DWORD *) PURE;
    STDMETHOD (GetSpaceUsed) (THIS_ DWORDLONG *, IEmptyVolumeCacheCallBack *) PURE;
    STDMETHOD (Purge) (THIS_ DWORDLONG, IEmptyVolumeCacheCallBack *) PURE;
    STDMETHOD (ShowProperties) (THIS_ HWND) PURE;
    STDMETHOD (Deactivate)(THIS_ DWORD *) PURE;                                                                                                                    
};

typedef IEmptyVolumeCache *LPIEMPTYVOLUMECACHE;

#endif // __EMPTYVC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appentry.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// AppEntry.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
// Abstract :
//
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include <comdef.h>
#include "stdafx.h"
#include "AppManDispatch.h"
#include "AppEntry.h"
#include "AppMan.h"
#include "AppManAdmin.h"
#include "AppManDebug.h"

//To flag as DBG_APPMANDP
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMANDP

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

#define JANUARY     1
#define FEBRUARY    2
#define MARCH       3
#define APRIL       4
#define MAY         5
#define JUNE        6
#define JULY        7
#define AUGUST      8
#define SEPTEMBER   9
#define OCTOBER     10
#define NOVEMBER    11
#define DECEMBER    12

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

void  SystemTimeToDate(SYSTEMTIME * lpSystemTime, DATE * lpDate)
{
  FUNCTION(" SystemTimeToDate()");

  DOUBLE  dDouble;
  DWORD   dwIndex;

  //
  // How many days have elapsed between 1900 and January 1 of this year.
  //

  dDouble = 1.0;
  dwIndex = 1900;
  while (dwIndex < lpSystemTime->wYear)
  {
    if (!(dwIndex % 4))
    {
      dDouble += 366.0;
    }
    else
    {
      dDouble += 365.0;
    }
    dwIndex++;
  }

  //
  // Is this a bicentile year
  //

  if ((!(lpSystemTime->wYear % 4))&&(MARCH <= lpSystemTime->wMonth))
  {
    dDouble += 1.0;
  }

  //
  // How many days have elapsed since the beginning of the year
  //

  switch(lpSystemTime->wMonth)
  {
    case 1
    : dDouble += 0.0;
      break;
    case 2
    : dDouble += 31.0;
      break;
    case 3
    : dDouble += 59.0;
      break;
    case 4
    : dDouble += 90.0;
      break;
    case 5
    : dDouble += 120.0;
      break;
    case 6
    : dDouble += 151.0;
      break;
    case 7
    : dDouble += 181.0;
      break;
    case 8
    : dDouble += 212.0;
      break;
    case 9
    : dDouble += 243.0;
      break;
    case 10
    : dDouble += 273.0;
      break;
    case 11
    : dDouble += 304.0;
      break;
    case 12
    : dDouble += 334.0;
      break;
  }

  //
  // How many days have elapsed since the beginning of the month
  //

  dDouble += ((DOUBLE)lpSystemTime->wDay) - 1.0;

  //
  // How many hours have elapsed since the beginning of the day
  //

  dDouble += ((DOUBLE) lpSystemTime->wHour) / 24;

  //
  // Save the dDouble value
  //

  *lpDate = dDouble;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD StrLen(LPCWSTR wszStr)
{
  FUNCTION(" StrLen(LPCWSTR wszStr)");

  DWORD dwIndex;

  dwIndex = 0;
  while (wszStr[dwIndex] != 0)
  {
    dwIndex++;
  }

  return dwIndex;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

DWORD StrLen(BSTR strStr)
{
  FUNCTION(" StrLen(BSTR strStr)");

  return SysStringLen(strStr);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppEntry::CAppEntry(void)
{
  DPFCONSTRUCTOR("CAppEntry()");

  m_fInitialized = FALSE;

  if (SUCCEEDED(CoInitialize(NULL)))
	{
		if (SUCCEEDED(CoCreateInstance(CLSID_ApplicationManager, NULL, CLSCTX_INPROC_SERVER, IID_ApplicationManager, (LPVOID *) &m_IApplicationManager)))
    {
      if (SUCCEEDED(m_IApplicationManager->CreateApplicationEntry(&m_IApplicationEntry)))
      {
        m_fInitialized = TRUE;
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppEntry::~CAppEntry(void)
{
  DPFDESTRUCTOR("~CAppEntry()");

  m_IApplicationEntry->Release();
  m_IApplicationManager->Release();
  m_fInitialized = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::SetPropertyGUID(DWORD dwProperty, BSTR strGuid)
{
  FUNCTION("CAppEntry::SetPropertyGUID()");

  HRESULT hResult = APPMAN_E_NOTINITIALIZED;
  GUID    sGuid;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    hResult = CLSIDFromString(strGuid, &sGuid);
    if (SUCCEEDED(hResult))
    {
      hResult = m_IApplicationEntry->SetProperty(dwProperty, &sGuid, sizeof(sGuid));
    }
  }

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::GetPropertyGUID(DWORD dwProperty, BSTR * lpstrGuid)
{
  FUNCTION("CAppEntry::GetPropertyGUID()");

  HRESULT   hResult = APPMAN_E_NOTINITIALIZED;
  OLECHAR * lpszString;
  GUID      sGuid;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->GetProperty(dwProperty, &sGuid, sizeof(sGuid));
    if (SUCCEEDED(hResult))
    {
      hResult = StringFromCLSID(sGuid, &lpszString);
      if (SUCCEEDED(hResult))
      {
        *lpstrGuid = SysAllocString(lpszString);
        CoTaskMemFree((LPVOID) lpszString);

        //
        // Make sure *lpstrGuid is not NULL
        //

        if (NULL == *lpstrGuid)
        {
          hResult = E_OUTOFMEMORY;
        }
      }
    }
  }

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::SetPropertyDWORD(DWORD dwProperty, long lDword)
{
  FUNCTION("CAppEntry::SetPropertyDWORD()");

  HRESULT hResult = APPMAN_E_NOTINITIALIZED;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->SetProperty(dwProperty, &lDword, sizeof(lDword));
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::GetPropertyDWORD(DWORD dwProperty, long * lplDword)
{
  FUNCTION("CAppEntry::GetPropertyDWORD()");

  HRESULT hResult = APPMAN_E_NOTINITIALIZED;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->GetProperty(dwProperty, lplDword, sizeof(long));
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::SetPropertyWSTR(DWORD dwProperty, BSTR strString)
{
  FUNCTION("CAppEntry::SetPropertyWSTR()");

  HRESULT hResult = APPMAN_E_NOTINITIALIZED;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->SetProperty(dwProperty | APP_PROPERTY_STR_UNICODE, strString, StrLen(strString) * 2);
  }

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::GetPropertyWSTR(DWORD dwProperty, BSTR * lpstrString)
{
  FUNCTION("CAppEntry::GetPropertyWSTR()");

  HRESULT hResult = APPMAN_E_NOTINITIALIZED;
  OLECHAR lpszString[MAX_PATH+1];

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    ZeroMemory(lpszString, sizeof(lpszString));
    hResult = m_IApplicationEntry->GetProperty(dwProperty | APP_PROPERTY_STR_UNICODE, lpszString, sizeof(lpszString));
    if (SUCCEEDED(hResult))
    {
      *lpstrString = SysAllocString(lpszString);
    }
  }

	return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_Guid(BSTR * lpstrGuid)
{
  FUNCTION("CAppEntry::get_Guid()");

  return GetPropertyGUID(APP_PROPERTY_GUID, lpstrGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_Guid(BSTR strGuid)
{
  FUNCTION("CAppEntry::put_Guid()");

  return SetPropertyGUID(APP_PROPERTY_GUID, strGuid);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_CompanyName(BSTR * lpstrCompanyName)
{
  FUNCTION("CAppEntry::get_CompanyName()");

  return GetPropertyWSTR(APP_PROPERTY_COMPANYNAME, lpstrCompanyName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_CompanyName(BSTR strCompanyName)
{
  FUNCTION("CAppEntry::put_CompanyName()");

  return SetPropertyWSTR(APP_PROPERTY_COMPANYNAME, strCompanyName);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_Signature(BSTR * lpstrSignature)
{
  FUNCTION("CAppEntry::get_Signature()");

  return GetPropertyWSTR(APP_PROPERTY_SIGNATURE, lpstrSignature);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_Signature(BSTR strSignature)
{
  FUNCTION("CAppEntry::put_Signature()");

  return SetPropertyWSTR(APP_PROPERTY_SIGNATURE, strSignature);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_VersionString(BSTR * lpstrVersionString)
{
  FUNCTION("CAppEntry::get_VersionString()");

  return GetPropertyWSTR(APP_PROPERTY_VERSIONSTRING, lpstrVersionString);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_VersionString(BSTR strVersionString)
{
  FUNCTION("CAppEntry::put_VersionString()");

  return SetPropertyWSTR(APP_PROPERTY_VERSIONSTRING, strVersionString);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_LastUsedDate(DATE * lpDate)
{
  FUNCTION("CAppEntry::get_LastUsedDate()");

  SYSTEMTIME  sSystemTime;
  HRESULT     hResult;

  hResult = m_IApplicationEntry->GetProperty(APP_PROPERTY_LASTUSEDDATE, &sSystemTime, sizeof(sSystemTime));
  if (SUCCEEDED(hResult))
  {
    SystemTimeToDate(&sSystemTime, lpDate);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_InstallDate(DATE * lpDate)
{
  FUNCTION("CAppEntry::get_InstallDate()");

  SYSTEMTIME  sSystemTime;
  HRESULT     hResult;

  hResult = m_IApplicationEntry->GetProperty(APP_PROPERTY_INSTALLDATE, &sSystemTime, sizeof(sSystemTime));
  if (SUCCEEDED(hResult))
  {
    SystemTimeToDate(&sSystemTime, lpDate);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_Category(long * lplCategory)
{
  FUNCTION("CAppEntry::get_Category()");

  return GetPropertyDWORD(APP_PROPERTY_CATEGORY, lplCategory);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_Category(long lCategory)
{
  FUNCTION("CAppEntry::put_Category()");

  return SetPropertyDWORD(APP_PROPERTY_CATEGORY, lCategory);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_State(long * lplState)
{
  FUNCTION("CAppEntry::get_State()");

  return GetPropertyDWORD(APP_PROPERTY_STATE, lplState);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_State(long lState)
{
  FUNCTION("CAppEntry::put_State()");

  return SetPropertyDWORD(APP_PROPERTY_STATE, lState);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_SetupRootPath(BSTR * lpstrSetupRootPath)
{
  FUNCTION("CAppEntry::get_SetupRootPath()");

  return GetPropertyWSTR(APP_PROPERTY_SETUPROOTPATH, lpstrSetupRootPath);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_ApplicationRootPath(BSTR * lpstrApplicationRootPath)
{
  FUNCTION("CAppEntry::get_ApplicationRootPath()");

  return GetPropertyWSTR(APP_PROPERTY_ROOTPATH, lpstrApplicationRootPath);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_ApplicationRootPath(BSTR strApplicationRootPath)
{
  FUNCTION("CAppEntry::put_ApplicationRootPath()");

  return SetPropertyWSTR(APP_PROPERTY_ROOTPATH, strApplicationRootPath);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_EstimatedInstallKilobytes(long * lplKilobytes)
{
  FUNCTION("CAppEntry::get_EstimatedInstallKilobytes()");

  return GetPropertyDWORD(APP_PROPERTY_ESTIMATEDINSTALLKILOBYTES, lplKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_EstimatedInstallKilobytes(long lKilobytes)
{
  FUNCTION("CAppEntry::put_EstimatedInstallKilobytes()");

  return SetPropertyDWORD(APP_PROPERTY_ESTIMATEDINSTALLKILOBYTES, lKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_ExecuteCmdLine(BSTR * lpstrExecuteCmdLine)
{
  FUNCTION("CAppEntry::get_ExecuteCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_EXECUTECMDLINE, lpstrExecuteCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_ExecuteCmdLine(BSTR strExecuteCmdLine)
{
  FUNCTION("CAppEntry::put_ExecuteCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_EXECUTECMDLINE, strExecuteCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_DefaultSetupExeCmdLine(BSTR * lpstrDefaultSetupExeCmdLine)
{
  FUNCTION("CAppEntry::get_DefaultSetupExeCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_DEFAULTSETUPEXECMDLINE, lpstrDefaultSetupExeCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_DefaultSetupExeCmdLine(BSTR strDefaultSetupExeCmdLine)
{
  FUNCTION("CAppEntry::put_DefaultSetupExeCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_DEFAULTSETUPEXECMDLINE, strDefaultSetupExeCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_DownsizeCmdLine(BSTR * lpstrDownsizeCmdLine)
{
  FUNCTION("CAppEntry::get_DownsizeCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_DOWNSIZECMDLINE, lpstrDownsizeCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_DownsizeCmdLine(BSTR strDownsizeCmdLine)
{
  FUNCTION("CAppEntry::put_DownsizeCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_DOWNSIZECMDLINE, strDownsizeCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_ReInstallCmdLine(BSTR * lpstrReInstallCmdLine)
{
  FUNCTION("CAppEntry::get_ReInstallCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_REINSTALLCMDLINE, lpstrReInstallCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_ReInstallCmdLine(BSTR strReInstallCmdLine)
{
  FUNCTION("CAppEntry::put_ReInstallCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_REINSTALLCMDLINE, strReInstallCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_UnInstallCmdLine(BSTR * lpstrUnInstallCmdLine)
{
  FUNCTION("CAppEntry::get_UnInstallCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_UNINSTALLCMDLINE, lpstrUnInstallCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_UnInstallCmdLine(BSTR strUnInstallCmdLine)
{
  FUNCTION("CAppEntry::put_UnInstallCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_UNINSTALLCMDLINE, strUnInstallCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_SelfTestCmdLine(BSTR * lpstrSelfTestCmdLine)
{
  FUNCTION("CAppEntry::get_SelfTestCmdLine()");

  return GetPropertyWSTR(APP_PROPERTY_SELFTESTCMDLINE, lpstrSelfTestCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_SelfTestCmdLine(BSTR strSelfTestCmdLine)
{
  FUNCTION("CAppEntry::put_SelfTestCmdLine()");

  return SetPropertyWSTR(APP_PROPERTY_SELFTESTCMDLINE, strSelfTestCmdLine);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_TitleURL(BSTR * lpstrTitleURL)
{
  FUNCTION("CAppEntry::get_TitleURL()");

  return GetPropertyWSTR(APP_PROPERTY_TITLEURL, lpstrTitleURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_TitleURL(BSTR strTitleURL)
{
  FUNCTION("CAppEntry::put_TitleURL()");

  return SetPropertyWSTR(APP_PROPERTY_TITLEURL, strTitleURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_DeveloperURL(BSTR * lpstrDeveloperURL)
{
  FUNCTION("CAppEntry::get_DeveloperURL()");

  return GetPropertyWSTR(APP_PROPERTY_DEVELOPERURL, lpstrDeveloperURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_DeveloperURL(BSTR strDeveloperURL)
{
  FUNCTION("CAppEntry::put_DeveloperURL()");

  return SetPropertyWSTR(APP_PROPERTY_DEVELOPERURL, strDeveloperURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_PublisherURL(BSTR * lpstrPublisherURL)
{
  FUNCTION("CAppEntry::get_PublisherURL()");

  return GetPropertyWSTR(APP_PROPERTY_PUBLISHERURL, lpstrPublisherURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_PublisherURL(BSTR strPublisherURL)
{
  FUNCTION("CAppEntry::put_PublisherURL()");

  return SetPropertyWSTR(APP_PROPERTY_PUBLISHERURL, strPublisherURL);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_XMLInfoFile(BSTR * lpstrXMLInfoFile)
{
  FUNCTION("CAppEntry::get_XMLInfoFile()");

  return GetPropertyWSTR(APP_PROPERTY_XMLINFOFILE, lpstrXMLInfoFile);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_XMLInfoFile(BSTR strXMLInfoFile)
{
  FUNCTION("CAppEntry::put_XMLInfoFile()");

  return SetPropertyWSTR(APP_PROPERTY_XMLINFOFILE, strXMLInfoFile);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::Clear()
{
  FUNCTION("CAppEntry::Clear()");

  return m_IApplicationEntry->Clear();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::InitializeInstall(void)
{
  FUNCTION("CAppEntry::InitializeInstall()");

  return m_IApplicationEntry->InitializeInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::FinalizeInstall(void)
{
  FUNCTION("CAppEntry::FinalizeInstall()");

  return m_IApplicationEntry->FinalizeInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::InitializeDownsize(void)
{
  FUNCTION("CAppEntry::InitializeDownsize()");

  return m_IApplicationEntry->InitializeDownsize();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::FinalizeDownsize(void)
{
  FUNCTION("CAppEntry::FinalizeDownsize()");

  return m_IApplicationEntry->FinalizeDownsize();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::InitializeReInstall(void)
{
  FUNCTION("CAppEntry::InitializeReInstall()");

  return m_IApplicationEntry->InitializeReInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::FinalizeReInstall(void)
{
  FUNCTION("CAppEntry::FinalizeReInstall()");

  return m_IApplicationEntry->FinalizeReInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::InitializeUnInstall(void)
{
  FUNCTION("CAppEntry::InitializeUnInstall()");

  return m_IApplicationEntry->InitializeUnInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::FinalizeUnInstall(void)
{
  FUNCTION("CAppEntry::FinalizeUnUnInstall()");

  return m_IApplicationEntry->FinalizeUnInstall();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::InitializeSelfTest(void)
{
  FUNCTION("CAppEntry::InitializeSelfTest()");

  return m_IApplicationEntry->InitializeSelfTest();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::FinalizeSelfTest(void)
{
  FUNCTION("CAppEntry::FinalizeSelfTest()");

  return m_IApplicationEntry->FinalizeSelfTest();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::Abort(void)
{
  FUNCTION("CAppEntry::Abort()");

  return m_IApplicationEntry->Abort();
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::Run(long lRunFlags, BSTR strCmdLineParameters)
{
  FUNCTION("CAppEntry::Run()");

  return m_IApplicationEntry->Run((const DWORD) lRunFlags, APP_PROPERTY_STR_UNICODE, (LPVOID) strCmdLineParameters, StrLen(strCmdLineParameters));
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::AddAssociation(long lAssociationType, IAppEntry * lpAppEntry)
{
  FUNCTION("CAppEntry::AddAssociation()");

  IApplicationEntry * lpApplicationEntry;
  HRESULT             hResult = APPMAN_E_NOTINITIALIZED;

  if (TRUE == m_fInitialized)
  {
    ((CAppEntry *)lpAppEntry)->GetApplicationEntryPtr(&lpApplicationEntry);
    hResult = m_IApplicationEntry->AddAssociation(lAssociationType, lpApplicationEntry);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::RemoveAssociation(long lAssociationType, IAppEntry * lpAppEntry)
{
  FUNCTION("CAppEntry::RemoveAssociation()");

  IApplicationEntry * lpApplicationEntry;
  HRESULT             hResult = APPMAN_E_NOTINITIALIZED;

  if (TRUE == m_fInitialized)
  {
    ((CAppEntry *)lpAppEntry)->GetApplicationEntryPtr(&lpApplicationEntry);
    hResult = m_IApplicationEntry->RemoveAssociation(lAssociationType, lpApplicationEntry);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::EnumAssociationTypes(long lAssociationIndex, long * lAssociationType)
{
  FUNCTION("CAppEntry::EnumAssociationTypes()");

  IApplicationEntry * lpApplicationEntry;
  HRESULT             hResult = APPMAN_E_NOTINITIALIZED;

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationManager->CreateApplicationEntry(&lpApplicationEntry);
    if (SUCCEEDED(hResult))
    {
      hResult = m_IApplicationEntry->EnumAssociations(lAssociationIndex, (LPDWORD) lAssociationType, lpApplicationEntry);
      lpApplicationEntry->Release();
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::EnumAssociationObjects(long lAssociationIndex, IAppEntry * lpAppEntry)
{
  FUNCTION("CAppEntry::EnumAssociationObjects()");

  IApplicationEntry * lpApplicationEntry;
  HRESULT             hResult = APPMAN_E_NOTINITIALIZED;
  DWORD               dwAssociationType;

  if (TRUE == m_fInitialized)
  {
    ((CAppEntry *)lpAppEntry)->GetApplicationEntryPtr(&lpApplicationEntry);
    hResult = m_IApplicationEntry->EnumAssociations(lAssociationIndex, &dwAssociationType, lpApplicationEntry);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::GetTemporarySpace(long lKilobytesRequired, BSTR * lpstrRootPath)
{
  FUNCTION("CAppEntry::GetTemporarySpace()");

  HRESULT   hResult = E_FAIL;
  OLECHAR   szString[MAX_PATH+1];

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    ZeroMemory(szString, sizeof(szString));
    hResult = m_IApplicationEntry->GetTemporarySpace(lKilobytesRequired, APP_PROPERTY_STR_UNICODE, (LPVOID) szString, sizeof(szString));
    if (SUCCEEDED(hResult))
    {
      *lpstrRootPath = SysAllocString(szString);
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::RemoveTemporarySpace(BSTR strRootPath)
{
  FUNCTION("CAppEntry::RemoveTemporarySpace()");

  HRESULT   hResult = APPMAN_E_NOTINITIALIZED;

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->RemoveTemporarySpace(APP_PROPERTY_STR_UNICODE, (LPVOID) strRootPath, StrLen(strRootPath));
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::EnumTemporarySpacePaths(long lTempSpaceIndex, BSTR * lpstrRootPath)
{
  FUNCTION("CAppEntry::EnumTemporarySpacePaths()");

  HRESULT   hResult = APPMAN_E_NOTINITIALIZED;
  OLECHAR   szString[MAX_PATH+1];
  DWORD     dwKilobytes;

  if (TRUE == m_fInitialized)
  {
    ZeroMemory(szString, sizeof(szString));
    hResult = m_IApplicationEntry->EnumTemporarySpaces(lTempSpaceIndex, &dwKilobytes, APP_PROPERTY_STR_UNICODE, (LPVOID) szString, sizeof(szString));
    if (SUCCEEDED(hResult))
    {
      *lpstrRootPath = SysAllocString(szString);
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::EnumTemporarySpaceAllocations(long lTempSpaceIndex, long * lTempSpaceKilobytes)
{
  FUNCTION("CAppEntry::EnumTemporarySpaceAllocations()");

  HRESULT   hResult = APPMAN_E_NOTINITIALIZED;
  OLECHAR   szString[MAX_PATH+1];

  if (TRUE == m_fInitialized)
  {
    hResult = m_IApplicationEntry->EnumTemporarySpaces(lTempSpaceIndex, (LPDWORD) lTempSpaceKilobytes, APP_PROPERTY_STR_UNICODE, (LPVOID) szString, sizeof(szString));
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_RemovableKilobytes(long * lplKilobytes)
{
  FUNCTION("CAppEntry::get_RemovableKilobytes()");

  return GetPropertyDWORD(APP_PROPERTY_REMOVABLEKILOBYTES, lplKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_RemovableKilobytes(long lKilobytes)
{
  FUNCTION("CAppEntry::put_RemovableKilobytes()");

  return SetPropertyDWORD(APP_PROPERTY_REMOVABLEKILOBYTES, lKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::get_NonRemovableKilobytes(long * lplKilobytes)
{
  FUNCTION("CAppEntry::get_NonRemovableKilobytes()");

  return GetPropertyDWORD(APP_PROPERTY_NONREMOVABLEKILOBYTES, lplKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::put_NonRemovableKilobytes(long lKilobytes)
{
  FUNCTION("CAppEntry::put_NonRemovableKilobytes()");

  return SetPropertyDWORD(APP_PROPERTY_NONREMOVABLEKILOBYTES, lKilobytes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::Initialize(void)
{
  FUNCTION("CAppEntry::Initialize()");

  if (m_fInitialized)
  {
    return S_OK;
  }

  return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppEntry::GetApplicationEntryPtr(IApplicationEntry ** lppApplicationEntry)
{
  FUNCTION("CAppEntry::GetApplicationEntryPtr()");

  if (!m_fInitialized)
  {
    return E_FAIL;
  }

  *lppApplicationEntry = m_IApplicationEntry;
  
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appentry.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// AppManager.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __APPENTRY_H_
#define __APPENTRY_H_

#include "resource.h"
#include "AppMan.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CAppEntry : 
      public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAppEntry, &CLSID_AppEntry>,
      public IDispatchImpl<IAppEntry, &IID_IAppEntry, &LIBID_APPMANDISPATCHLib>
{
  public:

    CAppEntry(void);
    virtual ~CAppEntry(void);

    DECLARE_REGISTRY_RESOURCEID(IDR_APPENTRY)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAppEntry)
      COM_INTERFACE_ENTRY(IAppEntry)
      COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    STDMETHOD (get_NonRemovableKilobytes) (/*[out, retval]*/ long *pVal);
    STDMETHOD (put_NonRemovableKilobytes) (/*[in]*/ long newVal);
    STDMETHOD (get_RemovableKilobytes) (/*[out, retval]*/ long *pVal);
    STDMETHOD (put_RemovableKilobytes) (/*[in]*/ long newVal);
    STDMETHOD (EnumTemporarySpaceAllocations) (/*[in]*/ long lTempSpaceIndex, /*[out, retval]*/ long * lTempSpaceKilobytes);
    STDMETHOD (EnumTemporarySpacePaths) (/*[in]*/ long lTempSpaceIndex, /*[out, retval]*/ BSTR * strRootPath);
    STDMETHOD (RemoveTemporarySpace) (/*[in]*/ BSTR strRootPath);
    STDMETHOD (GetTemporarySpace) (/*[in]*/ long lKilobytesRequired, /*[out, retval]*/ BSTR * strRootPath);
    STDMETHOD (EnumAssociationObjects) (/*[in]*/ long lAssociationIndex, /*[in]*/ IAppEntry * lpAppEntry);
    STDMETHOD (EnumAssociationTypes) (/*[in]*/ long lAssociationIndex, /*[out, retval]*/ long * lpAssociationType);
    STDMETHOD (RemoveAssociation) (/*[in]*/ long lAssociationType, /*[in]*/ IAppEntry * lpAppEntry);
    STDMETHOD (AddAssociation) (/*[in]*/ long AssociationType, /*[in]*/ IAppEntry * lpAppEntry);
    STDMETHOD (Run) (/*[in]*/ long lRunFlags, /*[in]*/ BSTR newVal);
    STDMETHOD (Abort) (void);
    STDMETHOD (FinalizeSelfTest) (void);
    STDMETHOD (InitializeSelfTest) (void);
    STDMETHOD (FinalizeUnInstall) (void);
    STDMETHOD (InitializeUnInstall) (void);
    STDMETHOD (FinalizeReInstall) (void);
    STDMETHOD (InitializeReInstall) (void);
    STDMETHOD (FinalizeDownsize) (void);
    STDMETHOD (InitializeDownsize) (void);
    STDMETHOD (FinalizeInstall) (void);
    STDMETHOD (InitializeInstall) (void);
    STDMETHOD (Clear) (void);
    STDMETHOD (get_XMLInfoFile) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_XMLInfoFile) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_PublisherURL) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_PublisherURL) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_DeveloperURL) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_DeveloperURL) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_TitleURL) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_TitleURL) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_SelfTestCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_SelfTestCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_UnInstallCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_UnInstallCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_ReInstallCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_ReInstallCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_DownsizeCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_DownsizeCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_DefaultSetupExeCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_DefaultSetupExeCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_ExecuteCmdLine) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_ExecuteCmdLine) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_EstimatedInstallKilobytes) (/*[out, retval]*/ long *pVal);
    STDMETHOD (put_EstimatedInstallKilobytes) (/*[in]*/ long newVal);
    STDMETHOD (get_ApplicationRootPath) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_ApplicationRootPath) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_SetupRootPath) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (get_State) (/*[out, retval]*/ long *pVal);
    STDMETHOD (put_State) (/*[in]*/ long newVal);
    STDMETHOD (get_Category) (/*[out, retval]*/ long *pVal);
    STDMETHOD (put_Category) (/*[in]*/ long newVal);
    STDMETHOD (get_InstallDate) (/*[out, retval]*/ DATE *pVal);
    STDMETHOD (get_LastUsedDate) (/*[out, retval]*/ DATE *pVal);
    STDMETHOD (get_VersionString) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_VersionString) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_Signature) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_Signature) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_CompanyName) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_CompanyName) (/*[in]*/ BSTR newVal);
    STDMETHOD (get_Guid) (/*[out, retval]*/ BSTR *pVal);
    STDMETHOD (put_Guid) (/*[in]*/ BSTR newVal);

    //
    // These methods are not part of the interface
    //

    STDMETHOD (Initialize) (void);
    STDMETHOD (GetApplicationEntryPtr) (IApplicationEntry ** lpApplicationEntry);

  private:

    STDMETHOD (SetPropertyGUID) (DWORD dwProperty, BSTR strGuid);
    STDMETHOD (GetPropertyGUID) (DWORD dwProperty, BSTR * lpstrGuid);
    STDMETHOD (SetPropertyDWORD) (DWORD dwProperty, long lDword);
    STDMETHOD (GetPropertyDWORD) (DWORD dwProperty, long * lplDword);
    STDMETHOD (SetPropertyWSTR) (DWORD dwProperty, BSTR strString);
    STDMETHOD (GetPropertyWSTR) (DWORD dwProperty, BSTR * lpstrString);

    BOOL                  m_fInitialized;
    IApplicationManager * m_IApplicationManager;
    IApplicationEntry   * m_IApplicationEntry;
};

#endif //__APPENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appmanager.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// AppManager.h
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __APPMANAGER_H_
#define __APPMANAGER_H_

#include "resource.h"
#include "AppMan.h"


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CAppManager : 
      public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CAppManager, &CLSID_AppManager>,
      public IDispatchImpl<IAppManager, &IID_IAppManager, &LIBID_APPMANDISPATCHLib>
{
  public:

    CAppManager(void);
    virtual ~CAppManager(void);

    DECLARE_REGISTRY_RESOURCEID(IDR_APPMANAGER)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAppManager)
      COM_INTERFACE_ENTRY(IAppManager)
      COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    STDMETHOD (get_AdvancedMode)(/*[out, retval]*/ long *pVal);
    STDMETHOD (get_OptimalAvailableKilobytes)(/*[in]*/ long lSpaceCategory, /*[out, retval]*/ long *pVal);
    STDMETHOD (get_MaximumAvailableKilobytes)(/*[in]*/ long lSpaceCategory, /*[out, retval]*/ long *pVal);
    STDMETHOD (get_ApplicationCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD (CreateApplicationEntry)(/*[out, retval]*/ IAppEntry ** lppAppEntry);
    STDMETHOD (GetApplicationInfo)(/*[in]*/ IAppEntry * lpAppEntry);
    STDMETHOD (EnumDeviceExclusionMask)(/*[in]*/ long lDeviceIndex, /*[out, retval]*/ long * lExclusionMask);
    STDMETHOD (EnumDeviceRootPaths)(/*[in]*/ long lDeviceIndex, /*[out, retval]*/ BSTR * strRootPath);
    STDMETHOD (EnumDeviceAvailableKilobytes)(/*[in]*/ long lDeviceIndex, /*[out, retval]*/ long * lKilobytes);
    STDMETHOD (EnumApplications)(/*[in]*/ long lApplicationIndex, /*[in]*/ IAppEntry * lpAppEntry);

  private:

    BOOL                    m_fInitialized;
    IApplicationManager   * m_IApplicationManager;
};

#endif //__APPMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appmandispatch.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// AppManDispatch.cpp : Implementation of DLL Exports.
//
// History :
//
//   05/06/1999 luish     Created
//    4/19/2000 RichGr    LoadDebugRuntime Registry setting delegates calls to Debug dll. 
//
//////////////////////////////////////////////////////////////////////////////////////////////


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AppManDispatchps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AppManDispatch.h"
#include "AppManDispatch_i.c"
#include "AppEntry.h"
#include "AppManager.h"
#include "AppManDebug.h"

//
// To flag as DBG_APPMANDP
//

#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMANDP

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AppEntry, CAppEntry)
OBJECT_ENTRY(CLSID_AppManager, CAppManager)
END_OBJECT_MAP()

//////////////////////////////////////////////////////////////////////////////////////////////
//
// DLL Entry Point
//
//////////////////////////////////////////////////////////////////////////////////////////////

extern "C" BOOL WINAPI  DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
  FUNCTION(" DllMain()");

  if (dwReason == DLL_PROCESS_ATTACH)
  {
    _Module.Init(ObjectMap, hInstance, &LIBID_APPMANDISPATCHLib);
    DisableThreadLibraryCalls(hInstance);
  }
  else
  if (dwReason == DLL_PROCESS_DETACH)
  {
      _Module.Term();
  }

  return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Used to determine whether the DLL can be unloaded by OLE
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
  FUNCTION(" DllCanUnloadNow()");

  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a class factory to create an object of the requested type
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  FUNCTION(" DllGetClassObject()");

  return _Module.GetClassObject(rclsid, riid, ppv);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer - Adds entries to the system registry
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI  DllRegisterServer(void)
{
  FUNCTION(" DllRegisterServer()");

  return _Module.RegisterServer(TRUE);
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer - Removes entries from the system registry
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDAPI  DllUnregisterServer(void)
{
  FUNCTION(" DllUnregisterServer()");

  return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appmanager.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// AppManager.cpp
// 
// Copyright (C) 1998, 1999 Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AppManDispatch.h"
#include "AppManager.h"
#include "AppEntry.h"
#include "AppMan.h"
#include "AppManDebug.h"

//To flag as DBG_APPMANDP
#ifdef DBG_MODULE
#undef DBG_MODULE
#endif

#define DBG_MODULE  DBG_APPMANDP


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManager::CAppManager(void)
{
  DPFCONSTRUCTOR("CAppManager()");

  m_fInitialized = FALSE;

  //
  // Get the required interfaces
  //

  if (SUCCEEDED(CoInitialize(NULL)))
  {
    if (SUCCEEDED(CoCreateInstance(CLSID_ApplicationManager, NULL, CLSCTX_INPROC_SERVER, IID_ApplicationManager, (LPVOID *) &m_IApplicationManager)))
    {
      m_fInitialized = TRUE;
    }
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

CAppManager::~CAppManager(void)
{
  DPFDESTRUCTOR("~CAppManager()");

  m_IApplicationManager->Release();
  m_fInitialized = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::get_AdvancedMode(long * lpAdvancedModeMask)
{
  FUNCTION("CAppManager::get_AdvancedMode()");

  HRESULT   hResult = E_FAIL;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Get the advanced mode
    //

    hResult = m_IApplicationManager->GetAdvancedMode((DWORD *)lpAdvancedModeMask);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::get_MaximumAvailableKilobytes(long lSpaceCategory, long * lplKilobytes)
{
  FUNCTION("CAppManager::get_MaximumAvailableKilobytes()");

  HRESULT   hResult = E_FAIL;
  DWORD     dwMaximumKilobytes, dwOptimalKilobytes;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Get the space information
    //

    hResult = m_IApplicationManager->GetAvailableSpace((const DWORD) lSpaceCategory, &dwMaximumKilobytes, &dwOptimalKilobytes);
    if (SUCCEEDED(hResult))
    {
      *lplKilobytes = (long) dwMaximumKilobytes;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::get_OptimalAvailableKilobytes(long lSpaceCategory, long * lplKilobytes)
{
  FUNCTION("CAppManager::get_OptimalAvailableKilobytes()");

  HRESULT   hResult = E_FAIL;
  DWORD     dwMaximumKilobytes, dwOptimalKilobytes;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Get the space information
    //

    hResult = m_IApplicationManager->GetAvailableSpace((const DWORD) lSpaceCategory, &dwMaximumKilobytes, &dwOptimalKilobytes);
    if (SUCCEEDED(hResult))
    {
      *lplKilobytes = (long) dwOptimalKilobytes;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::get_ApplicationCount(long * lpVal)
{
  FUNCTION("CAppManager::get_ApplicationCount()");

  HRESULT               hResult = E_FAIL;
  IApplicationEntry   * lpApplicationEntry;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // By default there are 0 applications
    //

    *lpVal = 0;

    //
    // Create an application entry instance
    //

    if (SUCCEEDED(m_IApplicationManager->CreateApplicationEntry(&lpApplicationEntry)))
    {
      //
      // Enumerate all the applications and count them
      //

      while (SUCCEEDED(m_IApplicationManager->EnumApplications((DWORD) *lpVal, lpApplicationEntry)))
      {
        (*lpVal)++;
      }

      hResult = S_OK;
    }
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::CreateApplicationEntry(IAppEntry ** lppAppEntry)
{
  FUNCTION("CAppManager::CreateApplicationEntry()");

  HRESULT     hResult = E_FAIL;
  CAppEntry * lpAppEntry;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Create an IAppEntry instance
    //

    if (SUCCEEDED(CoCreateInstance(CLSID_AppEntry, NULL, CLSCTX_INPROC_SERVER, IID_IAppEntry, (LPVOID *) &lpAppEntry)))
    {
      if (NULL != lpAppEntry)
      {
        hResult = lpAppEntry->Initialize();
        if (SUCCEEDED(hResult))
        {
          *lppAppEntry = (IAppEntry *) lpAppEntry;
        }
        else
        {
          delete lpAppEntry;
          *lppAppEntry = NULL;
        }
      }
    }
  }
  
  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::GetApplicationInfo(IAppEntry * lpAppEntry)
{
  FUNCTION("CAppManager::GetApplicationInfo()");

  HRESULT             hResult = E_FAIL;
  CAppEntry         * lpCAppEntry;
  IApplicationEntry * lpApplicationEntry;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Cast lpAppEntry to lpCAppEntry
    //

    lpCAppEntry = (CAppEntry *) lpAppEntry;
    lpCAppEntry->GetApplicationEntryPtr(&lpApplicationEntry);

    //
    // Get the application info
    //

    hResult = m_IApplicationManager->GetApplicationInfo(lpApplicationEntry);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::EnumApplications(long lApplicationIndex, IAppEntry * lpAppEntry)
{
  FUNCTION("CAppManager::EnumApplications()");

  HRESULT             hResult = E_FAIL;
  CAppEntry         * lpCAppEntry;
  IApplicationEntry * lpApplicationEntry;

  //
  // Make sure the IApplicationManager interface was successfully instantiated
  //

  if (TRUE == m_fInitialized)
  {
    //
    // Cast lpAppEntry to lpCAppEntry
    //

    lpCAppEntry = (CAppEntry *) lpAppEntry;
    lpCAppEntry->GetApplicationEntryPtr(&lpApplicationEntry);

    //
    // Get the application info
    //

    hResult = m_IApplicationManager->EnumApplications(lApplicationIndex, lpApplicationEntry);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::EnumDeviceAvailableKilobytes(long lTempSpaceIndex, long * lTempSpaceKilobytes)
{
  FUNCTION("CAppManager::EnumDeviceAvailableKilobytes()");

  HRESULT hResult = E_FAIL;
  DWORD   dwExclusionMask;
  CHAR    szString[MAX_PATH];

  hResult = m_IApplicationManager->EnumDevices((DWORD) lTempSpaceIndex, (LPDWORD) lTempSpaceKilobytes, &dwExclusionMask, APP_PROPERTY_STR_ANSI, szString, sizeof(szString));

  return hResult;
}


//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::EnumDeviceRootPaths(long lTempSpaceIndex, BSTR * lpstrRootPath)
{
  FUNCTION("CAppManager::EnumDeviceRootPaths()");

  HRESULT hResult = E_FAIL;
  DWORD   dwKilobytes, dwExclusionMask;
  OLECHAR wszString[MAX_PATH];

  hResult = m_IApplicationManager->EnumDevices((DWORD) lTempSpaceIndex, &dwKilobytes, &dwExclusionMask, APP_PROPERTY_STR_UNICODE, wszString, sizeof(wszString));
  if (SUCCEEDED(hResult))
  {
    *lpstrRootPath = SysAllocString(wszString);
  }

  return hResult;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CAppManager::EnumDeviceExclusionMask(long lTempSpaceIndex, long * lExclusionMask)
{
  FUNCTION("CAppManager::EnumDeviceExclusionMask()");

  HRESULT hResult = E_FAIL;
  DWORD   dwKilobytes;
  CHAR    szString[MAX_PATH];

  hResult = m_IApplicationManager->EnumDevices((DWORD) lTempSpaceIndex, &dwKilobytes, (LPDWORD) lExclusionMask, APP_PROPERTY_STR_ANSI, szString, sizeof(szString));

  return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\incappmandebug.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// IncAppManDebug.cpp
// 
//        Use this to build the \ComInterface\AppManDebug.cpp source file.
//
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
//
// History :
//
//    4/19/2000 RichGr     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AppManDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\incglobal.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// IncGlobal.cpp
// 
//        Use this to build the \ComInterface\Global.cpp source file.
//
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
//
// History :
//
//    4/19/2000 RichGr     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Global.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\appmandispatch.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Apr 19 15:32:13 2000
 */
/* Compiler settings for D:\NT\multimedia\Directx\ApplicationManager\ScriptInterface\AppManDispatch.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __AppManDispatch_h__
#define __AppManDispatch_h__

/* Forward Declarations */ 

#ifndef __IAppEntry_FWD_DEFINED__
#define __IAppEntry_FWD_DEFINED__
typedef interface IAppEntry IAppEntry;
#endif 	/* __IAppEntry_FWD_DEFINED__ */


#ifndef __IAppManager_FWD_DEFINED__
#define __IAppManager_FWD_DEFINED__
typedef interface IAppManager IAppManager;
#endif 	/* __IAppManager_FWD_DEFINED__ */


#ifndef __AppEntry_FWD_DEFINED__
#define __AppEntry_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppEntry AppEntry;
#else
typedef struct AppEntry AppEntry;
#endif /* __cplusplus */

#endif 	/* __AppEntry_FWD_DEFINED__ */


#ifndef __AppManager_FWD_DEFINED__
#define __AppManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppManager AppManager;
#else
typedef struct AppManager AppManager;
#endif /* __cplusplus */

#endif 	/* __AppManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAppEntry_INTERFACE_DEFINED__
#define __IAppEntry_INTERFACE_DEFINED__

/* interface IAppEntry */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E5065E80-0228-4469-9FAD-DE1F352A27FE")
    IAppEntry : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Guid( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CompanyName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CompanyName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Signature( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Signature( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VersionString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VersionString( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastUsedDate( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InstallDate( 
            /* [retval][out] */ DATE __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Category( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SetupRootPath( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationRootPath( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ApplicationRootPath( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EstimatedInstallKilobytes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EstimatedInstallKilobytes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExecuteCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ExecuteCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultSetupExeCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultSetupExeCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownsizeCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DownsizeCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReInstallCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReInstallCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UnInstallCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UnInstallCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SelfTestCmdLine( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SelfTestCmdLine( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TitleURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TitleURL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeveloperURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DeveloperURL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PublisherURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PublisherURL( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLInfoFile( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLInfoFile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FinalizeInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeDownsize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FinalizeDownsize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeReInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FinalizeReInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeUnInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FinalizeUnInstall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeSelfTest( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FinalizeSelfTest( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lRunFlags,
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddAssociation( 
            /* [in] */ long AssociationType,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveAssociation( 
            /* [in] */ long lAssociationType,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumAssociationTypes( 
            /* [in] */ long lAssociationIndex,
            /* [retval][out] */ long __RPC_FAR *lpAssociationType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumAssociationObjects( 
            /* [in] */ long lAssociationIndex,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTemporarySpace( 
            /* [in] */ long lKilobytesRequired,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTemporarySpace( 
            /* [in] */ BSTR strRootPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumTemporarySpacePaths( 
            /* [in] */ long lTempSpaceIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumTemporarySpaceAllocations( 
            /* [in] */ long lTempSpaceIndex,
            /* [retval][out] */ long __RPC_FAR *lTempSpaceKilobytes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemovableKilobytes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RemovableKilobytes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NonRemovableKilobytes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NonRemovableKilobytes( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAppEntry __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Guid )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Guid )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CompanyName )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CompanyName )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Signature )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Signature )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VersionString )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VersionString )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastUsedDate )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InstallDate )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Category )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Category )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_State )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SetupRootPath )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ApplicationRootPath )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ApplicationRootPath )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EstimatedInstallKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EstimatedInstallKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExecuteCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExecuteCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultSetupExeCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultSetupExeCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DownsizeCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DownsizeCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReInstallCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReInstallCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UnInstallCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UnInstallCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelfTestCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelfTestCmdLine )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TitleURL )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TitleURL )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DeveloperURL )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DeveloperURL )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PublisherURL )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PublisherURL )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMLInfoFile )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMLInfoFile )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinalizeInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeDownsize )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinalizeDownsize )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeReInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinalizeReInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeUnInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinalizeUnInstall )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeSelfTest )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FinalizeSelfTest )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IAppEntry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lRunFlags,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddAssociation )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long AssociationType,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAssociation )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lAssociationType,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAssociationTypes )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lAssociationIndex,
            /* [retval][out] */ long __RPC_FAR *lpAssociationType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAssociationObjects )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lAssociationIndex,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTemporarySpace )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lKilobytesRequired,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveTemporarySpace )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ BSTR strRootPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTemporarySpacePaths )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lTempSpaceIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTemporarySpaceAllocations )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long lTempSpaceIndex,
            /* [retval][out] */ long __RPC_FAR *lTempSpaceKilobytes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RemovableKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_RemovableKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NonRemovableKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NonRemovableKilobytes )( 
            IAppEntry __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IAppEntryVtbl;

    interface IAppEntry
    {
        CONST_VTBL struct IAppEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppEntry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppEntry_get_Guid(This,pVal)	\
    (This)->lpVtbl -> get_Guid(This,pVal)

#define IAppEntry_put_Guid(This,newVal)	\
    (This)->lpVtbl -> put_Guid(This,newVal)

#define IAppEntry_get_CompanyName(This,pVal)	\
    (This)->lpVtbl -> get_CompanyName(This,pVal)

#define IAppEntry_put_CompanyName(This,newVal)	\
    (This)->lpVtbl -> put_CompanyName(This,newVal)

#define IAppEntry_get_Signature(This,pVal)	\
    (This)->lpVtbl -> get_Signature(This,pVal)

#define IAppEntry_put_Signature(This,newVal)	\
    (This)->lpVtbl -> put_Signature(This,newVal)

#define IAppEntry_get_VersionString(This,pVal)	\
    (This)->lpVtbl -> get_VersionString(This,pVal)

#define IAppEntry_put_VersionString(This,newVal)	\
    (This)->lpVtbl -> put_VersionString(This,newVal)

#define IAppEntry_get_LastUsedDate(This,pVal)	\
    (This)->lpVtbl -> get_LastUsedDate(This,pVal)

#define IAppEntry_get_InstallDate(This,pVal)	\
    (This)->lpVtbl -> get_InstallDate(This,pVal)

#define IAppEntry_get_Category(This,pVal)	\
    (This)->lpVtbl -> get_Category(This,pVal)

#define IAppEntry_put_Category(This,newVal)	\
    (This)->lpVtbl -> put_Category(This,newVal)

#define IAppEntry_get_State(This,pVal)	\
    (This)->lpVtbl -> get_State(This,pVal)

#define IAppEntry_put_State(This,newVal)	\
    (This)->lpVtbl -> put_State(This,newVal)

#define IAppEntry_get_SetupRootPath(This,pVal)	\
    (This)->lpVtbl -> get_SetupRootPath(This,pVal)

#define IAppEntry_get_ApplicationRootPath(This,pVal)	\
    (This)->lpVtbl -> get_ApplicationRootPath(This,pVal)

#define IAppEntry_put_ApplicationRootPath(This,newVal)	\
    (This)->lpVtbl -> put_ApplicationRootPath(This,newVal)

#define IAppEntry_get_EstimatedInstallKilobytes(This,pVal)	\
    (This)->lpVtbl -> get_EstimatedInstallKilobytes(This,pVal)

#define IAppEntry_put_EstimatedInstallKilobytes(This,newVal)	\
    (This)->lpVtbl -> put_EstimatedInstallKilobytes(This,newVal)

#define IAppEntry_get_ExecuteCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_ExecuteCmdLine(This,pVal)

#define IAppEntry_put_ExecuteCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_ExecuteCmdLine(This,newVal)

#define IAppEntry_get_DefaultSetupExeCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_DefaultSetupExeCmdLine(This,pVal)

#define IAppEntry_put_DefaultSetupExeCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_DefaultSetupExeCmdLine(This,newVal)

#define IAppEntry_get_DownsizeCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_DownsizeCmdLine(This,pVal)

#define IAppEntry_put_DownsizeCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_DownsizeCmdLine(This,newVal)

#define IAppEntry_get_ReInstallCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_ReInstallCmdLine(This,pVal)

#define IAppEntry_put_ReInstallCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_ReInstallCmdLine(This,newVal)

#define IAppEntry_get_UnInstallCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_UnInstallCmdLine(This,pVal)

#define IAppEntry_put_UnInstallCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_UnInstallCmdLine(This,newVal)

#define IAppEntry_get_SelfTestCmdLine(This,pVal)	\
    (This)->lpVtbl -> get_SelfTestCmdLine(This,pVal)

#define IAppEntry_put_SelfTestCmdLine(This,newVal)	\
    (This)->lpVtbl -> put_SelfTestCmdLine(This,newVal)

#define IAppEntry_get_TitleURL(This,pVal)	\
    (This)->lpVtbl -> get_TitleURL(This,pVal)

#define IAppEntry_put_TitleURL(This,newVal)	\
    (This)->lpVtbl -> put_TitleURL(This,newVal)

#define IAppEntry_get_DeveloperURL(This,pVal)	\
    (This)->lpVtbl -> get_DeveloperURL(This,pVal)

#define IAppEntry_put_DeveloperURL(This,newVal)	\
    (This)->lpVtbl -> put_DeveloperURL(This,newVal)

#define IAppEntry_get_PublisherURL(This,pVal)	\
    (This)->lpVtbl -> get_PublisherURL(This,pVal)

#define IAppEntry_put_PublisherURL(This,newVal)	\
    (This)->lpVtbl -> put_PublisherURL(This,newVal)

#define IAppEntry_get_XMLInfoFile(This,pVal)	\
    (This)->lpVtbl -> get_XMLInfoFile(This,pVal)

#define IAppEntry_put_XMLInfoFile(This,newVal)	\
    (This)->lpVtbl -> put_XMLInfoFile(This,newVal)

#define IAppEntry_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IAppEntry_InitializeInstall(This)	\
    (This)->lpVtbl -> InitializeInstall(This)

#define IAppEntry_FinalizeInstall(This)	\
    (This)->lpVtbl -> FinalizeInstall(This)

#define IAppEntry_InitializeDownsize(This)	\
    (This)->lpVtbl -> InitializeDownsize(This)

#define IAppEntry_FinalizeDownsize(This)	\
    (This)->lpVtbl -> FinalizeDownsize(This)

#define IAppEntry_InitializeReInstall(This)	\
    (This)->lpVtbl -> InitializeReInstall(This)

#define IAppEntry_FinalizeReInstall(This)	\
    (This)->lpVtbl -> FinalizeReInstall(This)

#define IAppEntry_InitializeUnInstall(This)	\
    (This)->lpVtbl -> InitializeUnInstall(This)

#define IAppEntry_FinalizeUnInstall(This)	\
    (This)->lpVtbl -> FinalizeUnInstall(This)

#define IAppEntry_InitializeSelfTest(This)	\
    (This)->lpVtbl -> InitializeSelfTest(This)

#define IAppEntry_FinalizeSelfTest(This)	\
    (This)->lpVtbl -> FinalizeSelfTest(This)

#define IAppEntry_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IAppEntry_Run(This,lRunFlags,newVal)	\
    (This)->lpVtbl -> Run(This,lRunFlags,newVal)

#define IAppEntry_AddAssociation(This,AssociationType,lpAppEntry)	\
    (This)->lpVtbl -> AddAssociation(This,AssociationType,lpAppEntry)

#define IAppEntry_RemoveAssociation(This,lAssociationType,lpAppEntry)	\
    (This)->lpVtbl -> RemoveAssociation(This,lAssociationType,lpAppEntry)

#define IAppEntry_EnumAssociationTypes(This,lAssociationIndex,lpAssociationType)	\
    (This)->lpVtbl -> EnumAssociationTypes(This,lAssociationIndex,lpAssociationType)

#define IAppEntry_EnumAssociationObjects(This,lAssociationIndex,lpAppEntry)	\
    (This)->lpVtbl -> EnumAssociationObjects(This,lAssociationIndex,lpAppEntry)

#define IAppEntry_GetTemporarySpace(This,lKilobytesRequired,strRootPath)	\
    (This)->lpVtbl -> GetTemporarySpace(This,lKilobytesRequired,strRootPath)

#define IAppEntry_RemoveTemporarySpace(This,strRootPath)	\
    (This)->lpVtbl -> RemoveTemporarySpace(This,strRootPath)

#define IAppEntry_EnumTemporarySpacePaths(This,lTempSpaceIndex,strRootPath)	\
    (This)->lpVtbl -> EnumTemporarySpacePaths(This,lTempSpaceIndex,strRootPath)

#define IAppEntry_EnumTemporarySpaceAllocations(This,lTempSpaceIndex,lTempSpaceKilobytes)	\
    (This)->lpVtbl -> EnumTemporarySpaceAllocations(This,lTempSpaceIndex,lTempSpaceKilobytes)

#define IAppEntry_get_RemovableKilobytes(This,pVal)	\
    (This)->lpVtbl -> get_RemovableKilobytes(This,pVal)

#define IAppEntry_put_RemovableKilobytes(This,newVal)	\
    (This)->lpVtbl -> put_RemovableKilobytes(This,newVal)

#define IAppEntry_get_NonRemovableKilobytes(This,pVal)	\
    (This)->lpVtbl -> get_NonRemovableKilobytes(This,pVal)

#define IAppEntry_put_NonRemovableKilobytes(This,newVal)	\
    (This)->lpVtbl -> put_NonRemovableKilobytes(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_Guid_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_Guid_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_Guid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_CompanyName_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_CompanyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_CompanyName_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_CompanyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_Signature_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_Signature_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_Signature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_VersionString_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_VersionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_VersionString_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_VersionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_LastUsedDate_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_LastUsedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_InstallDate_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_InstallDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_Category_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_Category_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppEntry_put_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_State_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_State_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppEntry_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_SetupRootPath_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_SetupRootPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_ApplicationRootPath_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_ApplicationRootPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_ApplicationRootPath_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_ApplicationRootPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_EstimatedInstallKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_EstimatedInstallKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_EstimatedInstallKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppEntry_put_EstimatedInstallKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_ExecuteCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_ExecuteCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_ExecuteCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_ExecuteCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_DefaultSetupExeCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_DefaultSetupExeCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_DefaultSetupExeCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_DefaultSetupExeCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_DownsizeCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_DownsizeCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_DownsizeCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_DownsizeCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_ReInstallCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_ReInstallCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_ReInstallCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_ReInstallCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_UnInstallCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_UnInstallCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_UnInstallCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_UnInstallCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_SelfTestCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_SelfTestCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_SelfTestCmdLine_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_SelfTestCmdLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_TitleURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_TitleURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_TitleURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_TitleURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_DeveloperURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_DeveloperURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_DeveloperURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_DeveloperURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_PublisherURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_PublisherURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_PublisherURL_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_PublisherURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_XMLInfoFile_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_XMLInfoFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_XMLInfoFile_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_put_XMLInfoFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_Clear_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_InitializeInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_InitializeInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_FinalizeInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_FinalizeInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_InitializeDownsize_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_InitializeDownsize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_FinalizeDownsize_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_FinalizeDownsize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_InitializeReInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_InitializeReInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_FinalizeReInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_FinalizeReInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_InitializeUnInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_InitializeUnInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_FinalizeUnInstall_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_FinalizeUnInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_InitializeSelfTest_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_InitializeSelfTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_FinalizeSelfTest_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_FinalizeSelfTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_Abort_Proxy( 
    IAppEntry __RPC_FAR * This);


void __RPC_STUB IAppEntry_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_Run_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lRunFlags,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppEntry_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_AddAssociation_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long AssociationType,
    /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);


void __RPC_STUB IAppEntry_AddAssociation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_RemoveAssociation_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lAssociationType,
    /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);


void __RPC_STUB IAppEntry_RemoveAssociation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_EnumAssociationTypes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lAssociationIndex,
    /* [retval][out] */ long __RPC_FAR *lpAssociationType);


void __RPC_STUB IAppEntry_EnumAssociationTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_EnumAssociationObjects_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lAssociationIndex,
    /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);


void __RPC_STUB IAppEntry_EnumAssociationObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_GetTemporarySpace_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lKilobytesRequired,
    /* [retval][out] */ BSTR __RPC_FAR *strRootPath);


void __RPC_STUB IAppEntry_GetTemporarySpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_RemoveTemporarySpace_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ BSTR strRootPath);


void __RPC_STUB IAppEntry_RemoveTemporarySpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_EnumTemporarySpacePaths_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lTempSpaceIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strRootPath);


void __RPC_STUB IAppEntry_EnumTemporarySpacePaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppEntry_EnumTemporarySpaceAllocations_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long lTempSpaceIndex,
    /* [retval][out] */ long __RPC_FAR *lTempSpaceKilobytes);


void __RPC_STUB IAppEntry_EnumTemporarySpaceAllocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_RemovableKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_RemovableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_RemovableKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppEntry_put_RemovableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppEntry_get_NonRemovableKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppEntry_get_NonRemovableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppEntry_put_NonRemovableKilobytes_Proxy( 
    IAppEntry __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppEntry_put_NonRemovableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppEntry_INTERFACE_DEFINED__ */


#ifndef __IAppManager_INTERFACE_DEFINED__
#define __IAppManager_INTERFACE_DEFINED__

/* interface IAppManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D051768-5370-40AF-B149-2B265F39CCA2")
    IAppManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdvancedMode( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaximumAvailableKilobytes( 
            long lSpaceCategory,
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OptimalAvailableKilobytes( 
            long lSpaceCategory,
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationCount( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateApplicationEntry( 
            /* [retval][out] */ IAppEntry __RPC_FAR *__RPC_FAR *lppAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetApplicationInfo( 
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [in] */ long lApplicationIndex,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumDeviceAvailableKilobytes( 
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ long __RPC_FAR *lKilobytes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumDeviceRootPaths( 
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumDeviceExclusionMask( 
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ long __RPC_FAR *lExclusionMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAppManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAppManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAppManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AdvancedMode )( 
            IAppManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaximumAvailableKilobytes )( 
            IAppManager __RPC_FAR * This,
            long lSpaceCategory,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OptimalAvailableKilobytes )( 
            IAppManager __RPC_FAR * This,
            long lSpaceCategory,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ApplicationCount )( 
            IAppManager __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateApplicationEntry )( 
            IAppManager __RPC_FAR * This,
            /* [retval][out] */ IAppEntry __RPC_FAR *__RPC_FAR *lppAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplicationInfo )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumApplications )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ long lApplicationIndex,
            /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDeviceAvailableKilobytes )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ long __RPC_FAR *lKilobytes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDeviceRootPaths )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strRootPath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDeviceExclusionMask )( 
            IAppManager __RPC_FAR * This,
            /* [in] */ long lDeviceIndex,
            /* [retval][out] */ long __RPC_FAR *lExclusionMask);
        
        END_INTERFACE
    } IAppManagerVtbl;

    interface IAppManager
    {
        CONST_VTBL struct IAppManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppManager_get_AdvancedMode(This,pVal)	\
    (This)->lpVtbl -> get_AdvancedMode(This,pVal)

#define IAppManager_get_MaximumAvailableKilobytes(This,lSpaceCategory,pVal)	\
    (This)->lpVtbl -> get_MaximumAvailableKilobytes(This,lSpaceCategory,pVal)

#define IAppManager_get_OptimalAvailableKilobytes(This,lSpaceCategory,pVal)	\
    (This)->lpVtbl -> get_OptimalAvailableKilobytes(This,lSpaceCategory,pVal)

#define IAppManager_get_ApplicationCount(This,pVal)	\
    (This)->lpVtbl -> get_ApplicationCount(This,pVal)

#define IAppManager_CreateApplicationEntry(This,lppAppEntry)	\
    (This)->lpVtbl -> CreateApplicationEntry(This,lppAppEntry)

#define IAppManager_GetApplicationInfo(This,lpAppEntry)	\
    (This)->lpVtbl -> GetApplicationInfo(This,lpAppEntry)

#define IAppManager_EnumApplications(This,lApplicationIndex,lpAppEntry)	\
    (This)->lpVtbl -> EnumApplications(This,lApplicationIndex,lpAppEntry)

#define IAppManager_EnumDeviceAvailableKilobytes(This,lDeviceIndex,lKilobytes)	\
    (This)->lpVtbl -> EnumDeviceAvailableKilobytes(This,lDeviceIndex,lKilobytes)

#define IAppManager_EnumDeviceRootPaths(This,lDeviceIndex,strRootPath)	\
    (This)->lpVtbl -> EnumDeviceRootPaths(This,lDeviceIndex,strRootPath)

#define IAppManager_EnumDeviceExclusionMask(This,lDeviceIndex,lExclusionMask)	\
    (This)->lpVtbl -> EnumDeviceExclusionMask(This,lDeviceIndex,lExclusionMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppManager_get_AdvancedMode_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppManager_get_AdvancedMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppManager_get_MaximumAvailableKilobytes_Proxy( 
    IAppManager __RPC_FAR * This,
    long lSpaceCategory,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppManager_get_MaximumAvailableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppManager_get_OptimalAvailableKilobytes_Proxy( 
    IAppManager __RPC_FAR * This,
    long lSpaceCategory,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppManager_get_OptimalAvailableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppManager_get_ApplicationCount_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IAppManager_get_ApplicationCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_CreateApplicationEntry_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [retval][out] */ IAppEntry __RPC_FAR *__RPC_FAR *lppAppEntry);


void __RPC_STUB IAppManager_CreateApplicationEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_GetApplicationInfo_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);


void __RPC_STUB IAppManager_GetApplicationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_EnumApplications_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [in] */ long lApplicationIndex,
    /* [in] */ IAppEntry __RPC_FAR *lpAppEntry);


void __RPC_STUB IAppManager_EnumApplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_EnumDeviceAvailableKilobytes_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [in] */ long lDeviceIndex,
    /* [retval][out] */ long __RPC_FAR *lKilobytes);


void __RPC_STUB IAppManager_EnumDeviceAvailableKilobytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_EnumDeviceRootPaths_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [in] */ long lDeviceIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strRootPath);


void __RPC_STUB IAppManager_EnumDeviceRootPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppManager_EnumDeviceExclusionMask_Proxy( 
    IAppManager __RPC_FAR * This,
    /* [in] */ long lDeviceIndex,
    /* [retval][out] */ long __RPC_FAR *lExclusionMask);


void __RPC_STUB IAppManager_EnumDeviceExclusionMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppManager_INTERFACE_DEFINED__ */



#ifndef __APPMANDISPATCHLib_LIBRARY_DEFINED__
#define __APPMANDISPATCHLib_LIBRARY_DEFINED__

/* library APPMANDISPATCHLib */
/* [helpstring][version][uuid] */ 

typedef 
enum CONST_APP_STATES
    {	APP_STATE_INSTALLING	= 0x1,
	APP_STATE_READY	= 0x2,
	APP_STATE_DOWNSIZING	= 0x4,
	APP_STATE_DOWNSIZED	= 0x8,
	APP_STATE_REINSTALLING	= 0x10,
	APP_STATE_UNINSTALLING	= 0x20,
	APP_STATE_UNINSTALLED	= 0x40,
	APP_STATE_SELFTESTING	= 0x80,
	APP_STATE_UNSTABLE	= 0x100,
	APP_STATE_MASK	= 0x1ff
    }	APPSTATES;

typedef 
enum CONST_APP_CATEGORIES
    {	APP_CATEGORY_NONE	= 0,
	APP_CATEGORY_ENTERTAINMENT	= 0x1,
	APP_CATEGORY_PRODUCTIVITY	= 0x2,
	APP_CATEGORY_PUBLISHING	= 0x4,
	APP_CATEGORY_SCIENTIFIC	= 0x8,
	APP_CATEGORY_AUTHORING	= 0x10,
	APP_CATEGORY_MEDICAL	= 0x20,
	APP_CATEGORY_BUSINESS	= 0x40,
	APP_CATEGORY_FINANCIAL	= 0x80,
	APP_CATEGORY_EDUCATIONAL	= 0x100,
	APP_CATEGORY_REFERENCE	= 0x200,
	APP_CATEGORY_WEB	= 0x400,
	APP_CATEGORY_DEVELOPMENTTOOL	= 0x800,
	APP_CATEGORY_MULTIMEDIA	= 0x1000,
	APP_CATEGORY_VIRUSCLEANER	= 0x2000,
	APP_CATEGORY_CONNECTIVITY	= 0x4000,
	APP_CATEGORY_MISC	= 0x8000,
	APP_CATEGORY_DEMO	= 0x1000000,
	APP_CATEGORY_ALL	= 0x100ffff
    }	APP_CATEGORIES;

typedef 
enum CONST_APP_ASSOCIATION_TYPES
    {	APP_ASSOCIATION_CHILD	= 0x40000000,
	APP_ASSOCIATION_PARENT	= 0x80000000,
	APP_ASSOCIATION_UPGRADE	= 0x1,
	APP_ASSOCIATION_ADDITION	= 0x2,
	APP_ASSOCIATION_COMPONENT	= 0x4
    }	APP_ASSOCIATION_TYPES;

typedef 
enum CONST_MISC_DEFINES
    {	MAX_COMPANYNAME_CHARCOUNT	= 64,
	MAX_SIGNATURE_CHARCOUNT	= 64,
	MAX_VERSIONSTRING_CHARCOUNT	= 16,
	MAX_CMDLINE_CHARCOUNT	= 255,
	MAX_PATH_CHARCOUNT	= 255
    }	MISC_DEFINES;

typedef 
enum CONST_ERROR_CODES
    {	APPMAN_E_NOTINITIALIZED	= 0x85670001,
	APPMAN_E_INVALIDPROPERTYSIZE	= 0x85670005,
	APPMAN_E_INVALIDDATA	= 0x85670006,
	APPMAN_E_INVALIDPROPERTY	= 0x85670007,
	APPMAN_E_READONLYPROPERTY	= 0x85670008,
	APPMAN_E_PROPERTYNOTSET	= 0x85670009,
	APPMAN_E_OVERFLOW	= 0x8567000a,
	APPMAN_E_INVALIDPROPERTYVALUE	= 0x8567000c,
	APPMAN_E_ACTIONINPROGRESS	= 0x8567000d,
	APPMAN_E_ACTIONNOTINITIALIZED	= 0x8567000e,
	APPMAN_E_REQUIREDPROPERTIESMISSING	= 0x8567000f,
	APPMAN_E_APPLICATIONALREADYEXISTS	= 0x85670010,
	APPMAN_E_APPLICATIONALREADYLOCKED	= 0x85670011,
	APPMAN_E_NODISKSPACEAVAILABLE	= 0x85670012,
	APPMAN_E_UNKNOWNAPPLICATION	= 0x85670014,
	APPMAN_E_INVALIDPARAMETERS	= 0x85670015,
	APPMAN_E_OBJECTLOCKED	= 0x85670017,
	APPMAN_E_INVALIDINDEX	= 0x85670018,
	APPMAN_E_REGISTRYCORRUPT	= 0x85670019,
	APPMAN_E_CANNOTASSOCIATE	= 0x8567001a,
	APPMAN_E_INVALIDASSOCIATION	= 0x8567001b,
	APPMAN_E_ALREADYASSOCIATED	= 0x8567001c,
	APPMAN_E_APPLICATIONREQUIRED	= 0x8567001d,
	APPMAN_E_INVALIDEXECUTECMDLINE	= 0x8567001e,
	APPMAN_E_INVALIDDOWNSIZECMDLINE	= 0x8567001f,
	APPMAN_E_INVALIDREINSTALLCMDLINE	= 0x85670020,
	APPMAN_E_INVALIDUNINSTALLCMDLINE	= 0x85670021,
	APPMAN_E_INVALIDSELFTESTCMDLINE	= 0x85670022,
	APPMAN_E_PARENTAPPNOTREADY	= 0x85670023,
	APPMAN_E_INVALIDSTATE	= 0x85670024,
	APPMAN_E_INVALIDROOTPATH	= 0x85670025,
	APPMAN_E_CACHEOVERRUN	= 0x85670026
    }	ERROR_CODES;


EXTERN_C const IID LIBID_APPMANDISPATCHLib;

EXTERN_C const CLSID CLSID_AppEntry;

#ifdef __cplusplus

class DECLSPEC_UUID("9D4BD41C-508B-4D49-894E-F09242B68AF8")
AppEntry;
#endif

EXTERN_C const CLSID CLSID_AppManager;

#ifdef __cplusplus

class DECLSPEC_UUID("09A0E8F4-3C5D-4EA3-B56A-4E0731EE861A")
AppManager;
#endif
#endif /* __APPMANDISPATCHLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\incwin32api.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////
//
// IncWin32API.cpp
// 
//        Use this to build the \ComInterface\Win32API.cpp source file.
//
// Copyright (C) 2000 Microsoft Corporation. All rights reserved.
//
// History :
//
//    4/19/2000 RichGr     Created
//
//////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Win32API.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\sources.inc ===
MAJORCOMP=ApplicationManager
MINORCOMP=AppManDpDLL

#
#  The build environment sets the FREEBUILD macro to 1 when it is a free build
#  so you can change the name of the built binary to be different in that case.
#  side effects:
#             need 2 entries in placefil.txt (one for each name)
#             if a lib is published it will be called the new name; depending on your
#                viewpoint this could be a good thing or not
#

TARGETTYPE=DYNLINK
TARGETEXT=dll
TARGETPATH=Obj
UMTYPE=windows
TARGETNAME=AppManDp

!if !$(FREEBUILD)
!ifdef DIRECTX_REDIST
TARGETNAME=$(TARGETNAME)d
!endif
!endif

BINPLACE_PLACEFILE=$(DXROOT)\public\sdk\lib\placefil.txt

DLLENTRY=_DllMainCRTStartup

USE_LIBCMT=1

PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_SOURCEFILE=..\stdafx.cpp
PRECOMPILED_CXX=1

!IF "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

USE_MAPSYM = 1
DEBUG_CRTS=1
RC_DEFINES=$(RC_DEFINES) -DDEBUG=1
C_DEFINES=$(C_DEFINES) /D"WIN32" /D"_DEBUG" /D"_WINDOWS" /D"MBCS" /D"_USERDLL" /D"_ATL_STATIC_REGISTRY"

!ELSE

C_DEFINES=$(C_DEFINES) /D"WIN32" /D"NDEBUG" /D"_WINDOWS" /D"MBCS" /D"_USERDLL" /D"_ATL_STATIC_REGISTRY"

!ENDIF

TARGETLIBS=$(TARGETLIBS) \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\kernel32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\user32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\gdi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\winspool.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\comdlg32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\advapi32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\shell32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\ole32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\oleaut32.lib \
    $(_NTDRIVE)\$(_NTROOT)\public\sdk\lib\*\uuid.lib 


INCLUDES=$(DXROOT)\Inc; \
         $(DXROOT)\ApplicationManager\Include; \
         $(DXROOT)\ApplicationManager\ComInterface; \
         $(SDXROOT)\public\sdk\inc\mfc42; \
         $(SDXROOT)\public\sdk\inc\atl30;

SOURCES= \
..\AppManDispatch.idl \
..\AppManDispatch.rc \
..\AppEntry.cpp \
..\AppManager.cpp \
..\AppManDispatch.cpp \
..\IncAppManDebug.cpp \
..\IncGlobal.cpp \
..\IncWin32API.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5A5DF586_1D79_41D1_B319_2B5A2829A523__INCLUDED_)
#define AFX_STDAFX_H__5A5DF586_1D79_41D1_B319_2B5A2829A523__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5A5DF586_1D79_41D1_B319_2B5A2829A523__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppManDispatch.rc
//
#define IDS_PROJNAME                    100
#define IDR_APPENTRY                    101
#define IDR_APPMANAGER                  102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddraw\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-jun-95	craige	initial implementation
 *   18-jun-95	craige	pitch in VidMemInit
 *   17-jul-95	craige	added VidMemLargestFree
 *   29-nov-95  colinmc added VidMemAmountAllocated
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *@@END_MSINTERNAL
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * pointer to video meory
 */
typedef unsigned long	FLATPTR;


/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

#ifdef NT_KERNEL_HEAPS
typedef void VMEMHEAP;
#else
typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
} VMEMHEAP;
#endif

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * These legacy DLL exports don't handle nonlocal heaps
 */
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

/*
 * This DLL export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DDRAW.DLL. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned( 
                struct _VIDMEM* lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );


//@@BEGIN_MSINTERNAL
extern FLATPTR WINAPI HeapVidMemAlloc( struct _VIDMEM* lpVidMem, DWORD x, DWORD y, HANDLE hdev , LPSURFACEALIGNMENT lpAlignment , LPLONG lpNewPitch );
extern LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width, DWORD height, DWORD pitch );
extern void WINAPI VidMemFini( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
extern DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );
extern LPVMEMHEAP WINAPI HeapVidMemInit( struct _VIDMEM* lpVidMem, DWORD pitch, HANDLE hdev, LPHEAPALIGNMENT phad);
extern void WINAPI HeapVidMemFini( struct _VIDMEM* lpVidMem, HANDLE hdev );
//@@END_MSINTERNAL

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\win9x\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\comdll.h ===
#ifndef _INC_COMDLL
#define _INC_COMDLL

#include <windows.h>
#include <objbase.h>

// helper macros...
#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))

// standard DLL goo...
extern HANDLE g_hinst;
STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

// Functions to create standard objects
STDAPI DirectDrawFactory_CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\applicationmanager\scriptinterface\daytona\makefile.inc ===
!if $(AXP64)
GUID_CPL_OPTIONS=/cpl_opt:" /qap64"
!else
GUID_CPL_OPTIONS=
!endif

$(O)\guids.obj: guids.cpp
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\bfid.c ===
#include <windows.h>
#include <objbase.h>
#include <initguid.h>


DEFINE_GUID(BFID_MONOCHROME,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb79-524f-11ce-9f53-0020af0ba770            BFID_RGB4
DEFINE_GUID(BFID_RGB_4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7a-524f-11ce-9f53-0020af0ba770            BFID_RGB8
DEFINE_GUID(BFID_RGB_8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7b-524f-11ce-9f53-0020af0ba770            BFID_RGB565
DEFINE_GUID(BFID_RGB_565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7c-524f-11ce-9f53-0020af0ba770            BFID_RGB555
DEFINE_GUID(BFID_RGB_555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7d-524f-11ce-9f53-0020af0ba770            BFID_RGB24
DEFINE_GUID(BFID_RGB_24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

// e436eb7e-524f-11ce-9f53-0020af0ba770            BFID_RGB32
DEFINE_GUID(BFID_RGB_32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\ddfactry.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddfactry.h
 *  Content:	DirectDraw factory class header
 *		includes defns for CDDFactory, CDirectDrawEx,
 *		and CDDSurface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   03-mar-97	craige	added IRGBColorTable support
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      D3D Interface support
 *                      Linked list of surfaces real/internal interfaces kept
 *                      Complex surface/Attach list handleing
 *                      Handle for palettes added
 *                      Add/GetAttachedSurface, Flip, and Blit are aggregated
 *
 *   04-apr-97  jeffort TRIDENT ifdef's removed.
 *                      IDirectDraw3 Class implementation
 *   09-apr-97  jeffort Added #defines for version and member function for OWNDC stuff
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   02-may-97  jeffort Removed commented code, added GetDDInterface function wrapping
 *   06-may-97  jeffort DeleteAttachedSurface wrapping added
 *   20-may-97  jeffort Added fields in surface object for NT4.0 gold
 *   02-jul-97  jeffort Added m_bSaveDC boolean if a DX5 surface with OWNDC set
 *                      we need to not NULL out the DC when ReleaseDC is called
 *                      so that a call to GetSurfaceFromDC will work
 *   07-jul-97  jeffort Added GetSurfaceDesc internal function for wrapping
 *   10-jul-97  jeffort Added m_hBMOld to store old bitmap handle to reset at destruction
 *   18-jul-97  jeffort Added D3D MMX Device support
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 *   02-aug-97  jeffort New structure added to surface object to store attached
 *                      surfaces created with a different ddrawex object
 *   20-feb-98  stevela Added Chrome rasterizers
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "crtfree.h"
#include "ddraw.h"
#include "d3d.h"
#include "ddrawex.h"
#include "ddraw3i.h"
#include "comdll.h"
#ifdef INITGUID
#include <initguid.h>
#endif

/*
 * reminder
 */
#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

class CDirectDrawEx;
class CDDSurface;
class CDDPalette;

#ifndef CINTERFACE
#define IDirectDrawVtbl void
#define IDirectDraw2Vtbl void
#define IDirectDraw4Vtbl void
#define IDirectDrawSurfaceVtbl void
#define IDirectDrawSurface2Vtbl void
#define IDirectDrawSurface3Vtbl void
#define IDirectDrawPaletteVtbl void
#define IDirectDrawSurface4Vtbl void
#endif


#ifndef DIRECTDRAW_VERSION
//these are not included in DX3 include files, define them here
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DChrmDevice,    0x2f4d2045,0x9764,0x11d1,0x91,0xf2,0x0,0x0,0xf8,0x75,0x8e,0x66 );
#endif

#ifndef IID_IDirect3DChrmDevice
DEFINE_GUID( IID_IDirect3DChrmDevice,    0x2f4d2045,0x9764,0x11d1,0x91,0xf2,0x0,0x0,0xf8,0x75,0x8e,0x66 );
#endif


#define SURFACE_DATAEXCHANGE 0x00000001

//defines for our version information
#define WIN95_DX2   0x00000001
#define WIN95_DX3   0x00000002
#define WIN95_DX5   0x00000003
#define WINNT_DX2   0x00000004
#define WINNT_DX3   0x00000005
#define WINNT_DX5   0x00000006

extern "C" {
void WINAPI AcquireDDThreadLock(void);
void WINAPI ReleaseDDThreadLock(void);
};

#define ENTER_DDEX() AcquireDDThreadLock();
#define LEAVE_DDEX() ReleaseDDThreadLock();

/*
 * ddraw's internal interface structure
 */
typedef struct _REALDDINTSTRUC
{
    void	*lpVtbl;
    void	*pDDInternal1;
    void	*pDDInternal2;
    void	*pDDInternal3;
} REALDDINTSTRUC;

/*
 * Our version of the IDirectDraw interface internal structure
 */
typedef struct _DDINTSTRUC
{
    IDirectDrawVtbl 	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw		*m_pRealInterface;
} INTSTRUC_IDirectDraw;

/*
 * Our version of the IDirectDraw2 interface internal structure
 */
typedef struct _DD2INTSTRUC
{
    IDirectDraw2Vtbl	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw2	*m_pRealInterface;
} INTSTRUC_IDirectDraw2;

typedef struct _DD4INTSTRUC
{
    IDirectDraw4Vtbl	*lpVtbl;
    void		*pDDInternal1;
    void		*pDDInternal2;
    void		*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDirectDrawEx	*m_pDirectDrawEx;
    IDirectDraw4	*m_pRealInterface;
} INTSTRUC_IDirectDraw4;



/*
 * Our version of the IDirectDrawSurface interface internal structure
 */
typedef struct _DDSURFINTSTRUC
{
    IDirectDrawSurfaceVtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface;

/*
 * Our version of the IDirectDrawSurface2 interface internal structure
 */
typedef struct _DDSURF2INTSTRUC
{
    IDirectDrawSurface2Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface2		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface2;


/*
 * Our version of the IDirectDrawSurface3 interface internal structure
 */
typedef struct _DDSURF3INTSTRUC
{
    IDirectDrawSurface3Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface3		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface3;


typedef struct _DDSURF4INTSTRUC
{
    IDirectDrawSurface4Vtbl	*lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    // ONLY ADD STUFF AFTER THESE 4 ENTRIES!!!
    CDDSurface			*m_pSimpleSurface;
    IDirectDrawSurface4		*m_pRealInterface;
} INTSTRUC_IDirectDrawSurface4;



/*
 * Our version of IDirectDrawPalette interface internal structure
 */

typedef struct _DDPALINTSTRUC
{
    IDirectDrawPaletteVtbl      *lpVtbl;
    void			*pDDInternal1;
    void			*pDDInternal2;
    void			*pDDInternal3;
    CDDPalette                  *m_pSimplePalette;
    IDirectDrawPalette          *m_pRealInterface;
} INTSTRUC_IDirectDrawPalette;


typedef struct tagDDAttachSurface
{
    CDDSurface *     pSurface;
    struct tagDDAttachSurface  *     pNext;
}DDAttachSurface;



/*
 * Non Delegating IUnknown interface
 */
interface INonDelegatingUnknown
{
    virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) = 0;
    virtual STDMETHODIMP_(ULONG) NonDelegatingAddRef(void) = 0;
    virtual STDMETHODIMP_(ULONG) NonDelegatingRelease(void) = 0;
};


#pragma warning (disable:4355)
#define CAST_TO_IUNKNOWN(object) (reinterpret_cast<IUnknown *>(static_cast<INonDelegatingUnknown *>(object)))

typedef HRESULT (WINAPI *LPDIRECTDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
typedef HRESULT (WINAPI *LPDIRECTDRAWENUMW)( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
typedef HRESULT (WINAPI *LPDIRECTDRAWENUMA)( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );

/*
 * DDFactor class definition
 */
class CDDFactory : public INonDelegatingUnknown, public IDirectDrawFactory
{
public:
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDirectDrawFactory
    STDMETHODIMP CreateDirectDraw(GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw);
    STDMETHODIMP DirectDrawEnumerate(LPDDENUMCALLBACK lpCallback, LPVOID lpContext);

    CDDFactory(IUnknown *pUnkOuter);
    
public:
    LONG		m_cRef;
    IUnknown		*m_pUnkOuter;
    HANDLE		m_hDDrawDLL;
    DWORD		m_dwDDVerMS;
    LPDIRECTDRAWCREATE	m_pDirectDrawCreate;
    LPDIRECTDRAWENUMW	m_pDirectDrawEnumerateW;
    LPDIRECTDRAWENUMA	m_pDirectDrawEnumerateA;
};

/*
 * DirectDrawEx class definition
 */
 
class CDirectDrawEx : public INonDelegatingUnknown, public IDirectDraw3
{
public:
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

 
    // IDirectDraw3
    STDMETHODIMP Compact();
    STDMETHODIMP CreateClipper(DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * );
    STDMETHODIMP DuplicateSurface(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * );
    STDMETHODIMP EnumDisplayModes(DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK );
    STDMETHODIMP EnumSurfaces(DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK );
    STDMETHODIMP FlipToGDISurface();
    STDMETHODIMP GetCaps(LPDDCAPS, LPDDCAPS);
    STDMETHODIMP GetDisplayMode(LPDDSURFACEDESC);
    STDMETHODIMP GetFourCCCodes(LPDWORD, LPDWORD );
    STDMETHODIMP GetGDISurface(LPDIRECTDRAWSURFACE FAR *);
    STDMETHODIMP GetMonitorFrequency(LPDWORD);
    STDMETHODIMP GetScanLine(LPDWORD);
    STDMETHODIMP GetVerticalBlankStatus(LPBOOL );
    STDMETHODIMP Initialize(GUID FAR *);
    STDMETHODIMP RestoreDisplayMode();
    STDMETHODIMP SetDisplayMode(DWORD, DWORD,DWORD, DWORD, DWORD);
    STDMETHODIMP WaitForVerticalBlank(DWORD, HANDLE );
    STDMETHODIMP GetAvailableVidMem(LPDDSCAPS, LPDWORD, LPDWORD);
    STDMETHODIMP GetSurfaceFromDC(HDC, IDirectDrawSurface **);      

    
    // Internal goop
    CDirectDrawEx(IUnknown *pUnkOuter);
    ~CDirectDrawEx();
    HRESULT Init(GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, LPDIRECTDRAWCREATE pDirectDrawCreate );
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC pSurfaceDesc, IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
    STDMETHODIMP CreateSurface(LPDDSURFACEDESC2 pSurfaceDesc, IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter);
    STDMETHODIMP CreatePalette(DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter);
    STDMETHODIMP SetCooperativeLevel(HWND hwnd, DWORD dwFlags);


    void AddSurfaceToList(CDDSurface *pSurface);
    void RemoveSurfaceFromList(CDDSurface *pSurface);
    void AddSurfaceToPrimaryList(CDDSurface *pSurface);
    void RemoveSurfaceFromPrimaryList(CDDSurface *pSurface);
    void AddPaletteToList(CDDPalette *pPalette);
    void RemovePaletteFromList(CDDPalette *pPalette);
    HRESULT HandleAttachList(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter,IDirectDrawSurface **ppNewSurface, IDirectDrawSurface * pOrigSurf, DWORD dwFlags); 
    HRESULT CreateSimpleSurface(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter, IDirectDrawSurface * pSurface, IDirectDrawSurface **ppNewSurface, DWORD dwFlags);
public:
    INTSTRUC_IDirectDraw	m_DDInt;
    INTSTRUC_IDirectDraw2 	m_DD2Int;
    INTSTRUC_IDirectDraw4       m_DD4Int;

    LONG			        m_cRef;
    IUnknown			    *m_pUnkOuter;
    CDDSurface			    *m_pFirstSurface;       // list of surfaces (NOT ADDREF'd!)
    CDDSurface              *m_pPrimaryPaletteList;
    CDDPalette              *m_pFirstPalette;
    BOOL                    m_bExclusive;
    DWORD			        m_dwDDVer;
};


/*
 * DirectDraw simple surface class definition
 */
 
class CDDSurface : public INonDelegatingUnknown
{
friend CDirectDrawEx;

public:
    CDDSurface				*m_pPrev;               // Used by DirectDrawEx to insert in list
    CDDSurface				*m_pNext;
    CDDSurface                          *m_pPrevPalette;
    CDDSurface                          *m_pNextPalette;
    CDDSurface                          *m_pDestroyList;
    CDDPalette                          *m_pCurrentPalette;
    IUnknown				*m_pUnkOuter;
    //this member will be a linked list of explicitly attached surfaces
    //that were not created with the same ddrawex object that this surface
    //was created with
    DDAttachSurface                     *m_pAttach;
    LONG				m_cRef;
    CDirectDrawEx			*m_pDirectDrawEx;
    INTSTRUC_IDirectDrawSurface		m_DDSInt;
    INTSTRUC_IDirectDrawSurface2	m_DDS2Int;
    INTSTRUC_IDirectDrawSurface3	m_DDS3Int;
    INTSTRUC_IDirectDrawSurface4        m_DDS4Int;
    IDirect3DDevice *                   m_D3DDeviceRAMPInt;
    IDirect3DDevice *                   m_D3DDeviceHALInt;
    IDirect3DDevice *                   m_D3DDeviceRGBInt;
    IDirect3DDevice *                   m_D3DDeviceChrmInt;
    IDirect3DDevice *                   m_D3DDeviceMMXInt;
    IDirect3DTexture *                  m_D3DTextureInt;                         
    HDC					m_HDC;
    DWORD				m_dwCaps;
    HDC					m_hDCDib;
    HBITMAP				m_hBMDib;
    HBITMAP                             m_hBMOld;
    LPVOID				m_pBitsDib;
    IDirectDrawPalette		        *m_pDDPal;
    IDirectDrawPalette		        *m_pDDPalOurs;
    WORD				m_dwPalSize;
    WORD				m_dwPalEntries;
    BOOL				m_bOwnDC; //boolean set if we are spoofing ddraw to support owndc
    BOOL                                m_bSaveDC;//boolean to store if DX5 and OWNDC set
    BOOL                                m_bPrimaryPalette;
    BOOL                                m_bIsPrimary;
    ULONG_PTR                           m_pSaveBits;
    DWORD                               m_pSaveHDC;
#ifdef DEBUG
    DWORD                               m_DebugCheckDC;
#endif
    DWORD                               m_pSaveHBM;

public:
    CDDSurface(	DDSURFACEDESC *pSurfaceDesc,
		IDirectDrawSurface *pDDSurface,
		IDirectDrawSurface2 *pDDSurface2,
		IDirectDrawSurface3 *pDDSurface3,
		IDirectDrawSurface4 *pDDSurface4,
		IUnknown *pUnkOuter, CDirectDrawEx *pDirectDrawEx);
    ~CDDSurface();
    HRESULT Init();
    HRESULT MakeDIBSection();
    HRESULT MakeDibInfo( LPDDSURFACEDESC pddsd, LPBITMAPINFO pbmi );
    HRESULT SupportOwnDC();
    static HRESULT CreateSimpleSurface(
    			LPDDSURFACEDESC pSurfaceDesc,
			IDirectDrawSurface *pSurface,
		        IDirectDrawSurface2 *pSurface2,
		        IDirectDrawSurface3 *pSurface3,
                        IDirectDrawSurface4 *pSurface4,
			IUnknown *pUnkOuter,
			CDirectDrawEx *pDirectDrawEx,
			IDirectDrawSurface **ppNewDDSurf,
                        DWORD dwFlags);
    HRESULT InternalGetDC(HDC *);
    HRESULT InternalReleaseDC(HDC);
    HRESULT InternalLock(LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
    HRESULT InternalUnlock(LPVOID lpSurfaceData);
    HRESULT InternalSetSurfaceDesc(LPDDSURFACEDESC pddsd, DWORD dwFlags);
    HRESULT InternalGetAttachedSurface(LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS, DWORD dwSurfaceType);
    HRESULT InternalGetAttachedSurface4(LPDDSCAPS2 lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS);
    HRESULT InternalAddAttachedSurface(LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType);
    HRESULT InternalDeleteAttachedSurface(DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType);
    HRESULT InternalFlip(LPDIRECTDRAWSURFACE lpDDS, DWORD dw, DWORD dwSurfaceType);
    HRESULT InternalBlt(LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx, DWORD dwSurfaceType);
    HRESULT InternalGetPalette(LPDIRECTDRAWPALETTE FAR * ppPal, DWORD dwSurfaceType);
    HRESULT InternalSetPalette(LPDIRECTDRAWPALETTE pPal, DWORD dwSurfaceType);
    HRESULT InternalGetDDInterface(LPVOID FAR * ppInt);
    HRESULT InternalGetSurfaceDesc(LPDDSURFACEDESC pDesc, DWORD dwSurfaceType);
    HRESULT InternalGetSurfaceDesc4(LPDDSURFACEDESC2 pDesc);
    HRESULT CheckDDPalette();
    void DeleteAttachment(IDirectDrawSurface * pOrigSurf, CDDSurface * pFirst);
    void CleanUpSurface();
    void ReleaseRealInterfaces();
    void AddSurfaceToDestroyList(CDDSurface *pSurface);
    void DeleteAttachNode(CDDSurface * Surface);



    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

};


class CDDPalette : public INonDelegatingUnknown
{
friend CDirectDrawEx;
friend CDDSurface;

public:
    CDDPalette				*m_pPrev;               // Used by DirectDrawEx to insert in list
    CDDPalette				*m_pNext;
    CDDSurface                          *m_pFirstSurface;
    IUnknown				*m_pUnkOuter;
    INTSTRUC_IDirectDrawPalette		m_DDPInt;
    LONG				m_cRef;
    CDirectDrawEx			*m_pDirectDrawEx;
    BOOL                                m_bIsPrimary;

    CDDPalette( IDirectDrawPalette * pDDPalette,IUnknown *pUnkOuter,CDirectDrawEx *pDirectDrawEx);
    ~CDDPalette();
    static HRESULT CreateSimplePalette(LPPALETTEENTRY pEntries, 
                                       IDirectDrawPalette *pDDPalette, 
                                       LPDIRECTDRAWPALETTE FAR * ppPal, 
                                       IUnknown FAR * pUnkOuter, 
                                       CDirectDrawEx *pDirectDrawEx);
    HRESULT SetColorTable (CDDSurface * pSurface, LPPALETTEENTRY pEntries, DWORD dwNumEntries, DWORD dwBase);
    void AddSurfaceToList(CDDSurface *pSurface);
    void RemoveSurfaceFromList(CDDSurface *pSurface);
    STDMETHODIMP InternalSetEntries(DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpe); 
    // Non-Delegating versions of IUnknown
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef(void);
    STDMETHODIMP_(ULONG) NonDelegatingRelease(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
};

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"


#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFIID              riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFIID              riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter);

/*
 * some helper functions...
 */

void __stdcall InitDirectDrawInterfaces(IDirectDraw *pDD, INTSTRUC_IDirectDraw *pDDInt, 
                                        IDirectDraw2  *pDD2, INTSTRUC_IDirectDraw2 *pDD2Int,
                                        IDirectDraw4  *pDD4, INTSTRUC_IDirectDraw4 *pDD4Int);
void __stdcall InitSurfaceInterfaces(IDirectDrawSurface *pDDSurface,
	                             INTSTRUC_IDirectDrawSurface *pDDSInt,
                               	     IDirectDrawSurface2 *pDDSurface2,
                            	     INTSTRUC_IDirectDrawSurface2 *pDDS2Int,
                		     IDirectDrawSurface3 *pDDSurface3,
		                     INTSTRUC_IDirectDrawSurface3 *pDDS3Int,
                		     IDirectDrawSurface4 *pDDSurface4,
		                     INTSTRUC_IDirectDrawSurface4 *pDDS4Int );
                                   
void __stdcall InitDirectDrawPaletteInterfaces(IDirectDrawPalette *pDDPalette, 
                                               INTSTRUC_IDirectDrawPalette *pDDInt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//


#if defined(__cplusplus) && defined(CPP_FUNCTIONS)

void *  __cdecl operator new(size_t nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }

extern "C" int __cdecl _purecall(void) {return 0;}

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#ifndef _M_PPC
#pragma intrinsic(memcpy)
#pragma intrinsic(memcmp)
#pragma intrinsic(memset)
#endif

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\comdll.c ===
#include <windows.h>
#include "comdll.h"
#include "ddraw.h"
#include "ddrawex.h"




UINT g_cRefDll = 0;     // reference count for this DLL
HANDLE g_hinst = NULL;  // HMODULE for this DLL



typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnCreate)(IUnknown *, REFIID, void **);
    HRESULT (STDMETHODCALLTYPE *pfnRegUnReg)(BOOL bReg, HKEY hkCLSID, LPCSTR pszCLSID, LPCSTR pszModule);
} OBJ_ENTRY;

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
const OBJ_ENTRY c_clsmap[] = {
    {&c_CFVtbl, &CLSID_DirectDrawFactory, DirectDrawFactory_CreateInstance, NULL},
    // add more entries here
    { NULL, NULL, NULL, NULL }
};

// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();    // Class Factory keeps dll in memory
                return NOERROR;
            }
        }
    }
    // failure
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}

STDAPI_(BOOL) DllEntryPoint(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hDll;
        DisableThreadLibraryCalls(hDll);
    }

    return TRUE;
}

STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf)
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), pguid->Data1,
            pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1], pguid->Data4[2],
            pguid->Data4[3], pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]);
}

#ifndef UNICODE
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf)
{
    char szAnsi[40];
    TStringFromGUID(pguid, szAnsi);
    MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszBuf, sizeof(szAnsi));
}
#endif


BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS)
        return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS)
            break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

#define INPROCSERVER32  TEXT("InProcServer32")
#define CLSID           TEXT("CLSID")
#define THREADINGMODEL  TEXT("ThreadingModel")
#define TMBOTH          TEXT("Both")

STDAPI DllRegisterServer(void)
{
    const OBJ_ENTRY *pcls;
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));  // get path to this DLL

    for (pcls = c_clsmap; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS)
        {
            HKEY hkOurs;
            LONG err;
            TCHAR szGUID[80];

            TStringFromGUID(pcls->pclsid, szGUID);

            err = RegCreateKey(hkCLSID, szGUID, &hkOurs);
            if (err == ERROR_SUCCESS)
            {
                HKEY hkInproc;
                err = RegCreateKey(hkOurs, INPROCSERVER32, &hkInproc);
                if (err == ERROR_SUCCESS)
                {
                    err = RegSetValueEx(hkInproc, NULL, 0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueEx(hkInproc, THREADINGMODEL, 0, REG_SZ, (LPBYTE)TMBOTH, sizeof(TMBOTH));
                    }
                    RegCloseKey(hkInproc);
                }

                if (pcls->pfnRegUnReg)
                    pcls->pfnRegUnReg(TRUE, hkOurs, szGUID, szPath);

                RegCloseKey(hkOurs);
            }
            RegCloseKey(hkCLSID);

            if (err != ERROR_SUCCESS)
                return HRESULT_FROM_WIN32(err);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    const OBJ_ENTRY *pcls;
    for (pcls = c_clsmap; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS)
        {
            TCHAR szGUID[80];

            TStringFromGUID(pcls->pclsid, szGUID);

            DeleteKeyAndSubKeys(hkCLSID, szGUID);

            RegCloseKey(hkCLSID);

            if (pcls->pfnRegUnReg)
                pcls->pfnRegUnReg(FALSE, NULL, szGUID, NULL);

        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\ddrawex.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995-1997               **
//*********************************************************************
//
//	DDRAWEX.H 
//
//	Header file for DirectDrawEx functionality

#ifndef __DDRAWEXH__
#define __DDRAWEXH__

#ifdef __cplusplus
extern "C" {
#endif

#include <ddraw.h>

// {4FD2A832-86C8-11d0-8FCA-00C04FD9189D}
DEFINE_GUID(CLSID_DirectDrawFactory, 
0x4fd2a832, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

DEFINE_GUID(IID_IDirectDrawFactory, 
0x4fd2a833, 0x86c8, 0x11d0, 0x8f, 0xca, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

#ifndef DIRECTDRAW_VERSION

//Functionality supported by DDrawex but not DX3
#define DDSD_LPSURFACE		0x00000800l

DEFINE_GUID( IID_IDirectDrawSurface3,
0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );

typedef struct IDirectDrawSurface3		FAR *LPDIRECTDRAWSURFACE3;

#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD ) PURE;
};
#endif




#define	DDSCAPS_DATAEXCHANGE	(DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)

#undef	INTERFACE
#define INTERFACE IDirectDrawFactory

DECLARE_INTERFACE_(IDirectDrawFactory, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, IDirectDraw **ppDirectDraw) PURE;
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK lpCallback, LPVOID lpContext) PURE;
};


 
// {618F8AD4-8B7A-11d0-8FCC-00C04FD9189D}
DEFINE_GUID(IID_IDirectDraw3, 
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

typedef struct IDirectDraw3		FAR *LPDIRECTDRAW3;

#undef	INTERFACE
#define INTERFACE IDirectDraw3

DECLARE_INTERFACE_(IDirectDraw3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
    /*** IDirectDraw3 methods ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, IDirectDrawSurface **) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw3_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw3_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw3_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw3_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw3_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw3_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw3_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw3_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw3_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw3_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw3_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw3_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw3_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw3_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw3_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw3_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw3_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw3_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw3_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw3_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw3_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw3_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw3_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw3_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw3_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#endif

 

/*===========================================================================
 *
 *
 * DIRECTDRAWEX RETURN CODES
 *
 * The return values from DirectDrawEx Commands and Surface that return an
 * HRESULT are codes from DirectDrawEx concerning the results of the action
 * requested by DirectDrawEx.
 *
 *==========================================================================*/

/*
 * An attempt was made to load ddraw.dll
 */
#define DDERR_LOADFAILED                        MAKE_DDHRESULT( 901 )

/*
 * Unable to determine module/os version number
 */
#define DDERR_BADVERSIONINFO                    MAKE_DDHRESULT( 902 )

/*
 * Unable to determine address of ddraw.dll exported symbol (DirectDrawCreate or
 * DirectDrawEnumerate).
 */
#define DDERR_BADPROCADDRESS                    MAKE_DDHRESULT( 903 )

/*
 * Legacy usage: do not use QI() to create D3D device objects from surface objects.  
 * Use IDirect3D2::CreateDevice()
 */
#define DDERR_LEGACYUSAGE                       MAKE_DDHRESULT( 904 )

#ifdef __cplusplus
}
#endif


#endif // __DDRAWEXH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\factory.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       factory.cpp
 *  Content:	DirectDraw Factory support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin
 *   14-mar-97  jeffort version checking changed to support DX3 and above
 *   09-apr-97  jeffort version checking added for DX2 and NT
 *   30-apr-97  jeffort version >DX5 treated as DX5
 *   10-jul-97  jeffort made OSVersion a static variable
 *   09-sep-97  mikear  QI for IUnknown when aggregating
 ***************************************************************************/
#include "ddfactry.h"

//#defines for registry lookup
#define REGSTR_PATH_DDRAW 		"Software\\Microsoft\\DirectDraw"
#define	REGSTR_VAL_DDRAW_OWNDC  	"OWNDC"



CDDFactory::CDDFactory(IUnknown *pUnkOuter) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this))
{
    m_hDDrawDLL = NULL;
    DllAddRef();
}


STDAPI DirectDrawFactory_CreateInstance(
				IUnknown * pUnkOuter,
				REFIID riid,
				void ** ppv)
{
    HRESULT hr;
    CDDFactory *pFactory = new CDDFactory(pUnkOuter);

    if( !pFactory )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pFactory->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : riid, ppv);
        pFactory->NonDelegatingRelease();
    }
    return hr;
}


STDMETHODIMP CDDFactory::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;


    if (IID_IUnknown==riid)
    {
	*ppv=(INonDelegatingUnknown *)this;
    }
    else
    {
	if (IID_IDirectDrawFactory==riid)
	{
            *ppv=(IDirectDrawFactory *)this;
	}
	else
	{
	    return E_NOINTERFACE;
        }
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CDDFactory::NonDelegatingAddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDDFactory::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if( lRefCount )
    {
	return lRefCount;
    }
    delete this;
    DllRelease();
    return 0;
}


// Standard IUnknown
STDMETHODIMP CDDFactory::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) CDDFactory::AddRef(void)
{
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CDDFactory::Release(void)
{
    return m_pUnkOuter->Release();
}

/*
 * CDDFactory::CreateDirectDraw
 */
STDMETHODIMP CDDFactory::CreateDirectDraw(
				GUID * pGUID,
				HWND hWnd,
				DWORD dwCoopLevelFlags,
				DWORD dwReserved,
				IUnknown *pUnkOuter,
				IDirectDraw **ppDirectDraw )
{
    static OSVERSIONINFO osVer;
    CDirectDrawEx *pDirectDrawEx;
    HRESULT	hr = S_OK;
    BOOL fDDrawDllVerFound = FALSE;

    *ppDirectDraw = NULL;
    /*
     * first, see if we can get at DirectDraw or not!
     */
    if( m_hDDrawDLL == NULL )
    {
 		char		path[_MAX_PATH];
        char        DllName[25];
        DWORD       dwRet;

	//	m_hDDrawDLL = LoadLibrary( "ddraw.dll" );
        dwRet = GetProfileString("ddrawex","realdll","ddraw.dll",DllName,25);
        if( dwRet == 0 )
        {
            return DDERR_GENERIC;
        }
		m_hDDrawDLL = LoadLibrary( DllName );
		if( m_hDDrawDLL == NULL )
        {
            return DDERR_LOADFAILED;
        }

		/*
		 * get ddraw.dll version number
		 */
		if( GetModuleFileName( (HINSTANCE)m_hDDrawDLL, path, sizeof( path ) ) )
		{
			int		size;
			DWORD	tmp;
			size = (int) GetFileVersionInfoSize( path, (LPDWORD) &tmp );
			if( size != 0 )
			{
				LPVOID	vinfo;
    
				vinfo = (LPVOID) LocalAlloc( LPTR, size );
                if(vinfo == NULL)
                {
                    hr = DDERR_OUTOFMEMORY;
                    goto CleanUp;
                }

				if( GetFileVersionInfo( path, 0, size, vinfo ) )
				{
					VS_FIXEDFILEINFO *ver=NULL;
					UINT cb;

					if( VerQueryValue(vinfo, "\\", (LPVOID *)&ver, &cb) )
					{
						if( ver != NULL )
						{
							/*
							 * we only need the most significant dword,
							 * the LS dword contains the build number only...
							 * Hack: The '|5' forces recognition of DX6+ 
							 */
							m_dwDDVerMS = ver->dwFileVersionMS | 5;
                            fDDrawDllVerFound = TRUE;
						}
					}
				}
				LocalFree( vinfo );
			}
		}

        osVer.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if ( !fDDrawDllVerFound || !GetVersionEx(&osVer) )
        {
            hr = DDERR_BADVERSIONINFO;
            goto CleanUp;
        }

        //if we are on NT4.0 Gold, the DLL version will be 4.00
        if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT && LOWORD( m_dwDDVerMS) == 0) 
        {
            //boost the LOWORD up so we will not fail the next check below
            m_dwDDVerMS += 3;
        }

		/*
		 * don't work on anything but  DX2 DX 3 or DX 5.
		 */
		if( !((HIWORD( m_dwDDVerMS ) >= 4) && (LOWORD( m_dwDDVerMS) >= 3)) )
		{
            hr = DDERR_UNSUPPORTED;
            goto CleanUp;
		}

		if( LOWORD( m_dwDDVerMS) > 5)
		{
			//we will assume that any version >= DX5 will support what we need, so we
			//will mark anything greater than 5 as DX5
			m_dwDDVerMS = 5;
		}

		/*
		 * get the various entry points we need
		 */
		m_pDirectDrawCreate = (LPDIRECTDRAWCREATE) GetProcAddress((HINSTANCE) m_hDDrawDLL, "DirectDrawCreate" );
		if( m_pDirectDrawCreate == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
		}

		m_pDirectDrawEnumerateW = (LPDIRECTDRAWENUMW) GetProcAddress( (HINSTANCE)m_hDDrawDLL, "DirectDrawEnumerateW" );
		if( m_pDirectDrawEnumerateW == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
		}

		m_pDirectDrawEnumerateA = (LPDIRECTDRAWENUMA) GetProcAddress((HINSTANCE) m_hDDrawDLL, "DirectDrawEnumerateA" );
		if( m_pDirectDrawEnumerateA == NULL )
		{
            hr = DDERR_BADPROCADDRESS;
            goto CleanUp;
        }

    } // m_hDDrawDLL = NULL

    /*
     * create and initialize the ddrawex object
     */
    pDirectDrawEx = new CDirectDrawEx(pUnkOuter);
    if( !pDirectDrawEx )
    {
        hr = DDERR_OUTOFMEMORY;
        goto CleanUp;
    }
    else
    {
        hr = pDirectDrawEx->Init( pGUID, hWnd, dwCoopLevelFlags, dwReserved, m_pDirectDrawCreate );

        if( SUCCEEDED(hr) )
        {
            hr = pDirectDrawEx->NonDelegatingQueryInterface(IID_IDirectDraw, (void **)ppDirectDraw);
            /*
             * save the ddraw version number...
             */
            if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
    	        if( LOWORD( m_dwDDVerMS ) == 5 )
    	        {
    	            DWORD	type;
                    DWORD	value;
					DWORD	cb;
                    HKEY	hkey;

                    //DX5 is busted with OwnDC for StretchBlt
                    //check a registry key to see if we are
                    //using dx5 style or dx3 style.
                    //default is dx3
                    pDirectDrawEx->m_dwDDVer = WINNT_DX5;

                    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
                    {
    	                cb = sizeof( value );
            	        if( ERROR_SUCCESS == RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_OWNDC, NULL, &type, (CONST LPBYTE)&value, &cb ) )
                        {
                            pDirectDrawEx->m_dwDDVer = WINNT_DX5;
                        }
                        RegCloseKey(hkey);
                    }
                }
                else if (LOWORD (m_dwDDVerMS) == 4 )
                {
                    pDirectDrawEx->m_dwDDVer = WINNT_DX3;
                }
                else if (LOWORD (m_dwDDVerMS) == 3 )
                {
                    pDirectDrawEx->m_dwDDVer = WINNT_DX2;
                }
                //should never get here, alread checked above, but be a bit anal
                else
                {
                    hr = DDERR_UNSUPPORTED;
                    goto CleanUp;
                }
            }
            else
            {
    	        if( LOWORD( m_dwDDVerMS ) == 5 )
    	        {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX5;
        	}
                else if (LOWORD (m_dwDDVerMS) == 4 )
                {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX3;
                }
                else if (LOWORD (m_dwDDVerMS) == 3 )
                {
                    pDirectDrawEx->m_dwDDVer = WIN95_DX2;
                }
                //should never get here, alread checked above, but be a bit anal
                else
                {
                    hr = DDERR_UNSUPPORTED;
                    goto CleanUp;
                }
            }
        }
        pDirectDrawEx->NonDelegatingRelease();
    }

CleanUp:

    if( hr != S_OK && m_hDDrawDLL != NULL )
    {
        FreeLibrary((HINSTANCE) m_hDDrawDLL );
        m_hDDrawDLL = NULL;
    }

    return hr;
} /* CDDFactory::CreateDirectDraw */

/*
 * CDDFactory::DirectDrawEnumerate
 *
 * implements ddraw enumerate.
 */
STDMETHODIMP CDDFactory::DirectDrawEnumerate(LPDDENUMCALLBACK lpCallback, LPVOID lpContext)
{
    #pragma message( REMIND( "DDFactory::DirectDrawEnumerate assumes ANSI" ))
    return m_pDirectDrawEnumerateA(lpCallback, lpContext);

} /* CDDFactory::DirectDrawEnumerate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=ddrawex
TARGETTYPE=DYNLINK

INCLUDES= ..\dx6;..\dx3inc;..\..\inc;

USE_MAPSYM = 1

TARGETPATH = obj

TARGETLIBS=$(SDK_LIB_PATH)\user32.lib \
	   $(SDK_LIB_PATH)\kernel32.lib \
	   $(SDK_LIB_PATH)\advapi32.lib \
	   $(SDK_LIB_PATH)\gdi32.lib \
	   $(SDK_LIB_PATH)\version.lib \
	   $(PROJECT_LIB_PATH)\ddrawp.lib \
       $(SDK_LIB_PATH)\uuid.lib

DLLENTRY=DllEntryPoint
!if $(ALPHA)
USE_NTDLL=1
!else
USE_NOLIB=1
!endif

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES = $(C_DEFINES) -DIS_32 -D_NO_ENUM -D_NOCSECT_TYPE -D_WIN32 -DUSE_GDI_HDC -DMSBUILD

SOURCES= \
	..\comdll.c \
	..\ddrawex.cpp \
	..\vtable.cpp \
	..\surface.cpp \
	..\factory.cpp \
	..\palette.cpp\
	..\ddrawex.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\ddraw3i.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw3i.h
 *  Content:	DirectDraw 3 internal data structures
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-feb-97	craige	initial implementation
 *
 ***************************************************************************/

#define DDRAWISURFGBL_MEMFREE		0x00000001L	// memory has been freed
#define DDRAWISURFGBL_SYSMEMREQUESTED	0x00000002L	// surface is in system memory at request of user

#define DDRAWISURF_HASPIXELFORMAT	0x00002000L	// surface structure has pixel format data

typedef ULONG_PTR FLATPTR;

typedef struct _DDRAWI_DDRAWSURFACE_GBL FAR  *LPDDRAWI_DDRAWSURFACE_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_MORE FAR *LPDDRAWI_DDRAWSURFACE_MORE;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR  *LPDDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_INT FAR  *LPDDRAWI_DDRAWSURFACE_INT;

/*
 * DBLNODE - a node in a doubly-linked list of surface interfaces
 */
typedef struct _DBLNODE
{
    struct  _DBLNODE                    FAR *next;  // link to next node
    struct  _DBLNODE                    FAR *prev;  // link to previous node
    LPDDRAWI_DDRAWSURFACE_LCL           object;     // link to object
    LPDDRAWI_DDRAWSURFACE_INT		object_int; // object interface
} DBLNODE;
typedef DBLNODE FAR *LPDBLNODE;

/*
 * DDRAW surface interface struct
 */
typedef struct _DDRAWI_DDRAWSURFACE_INT
{
    LPVOID				lpVtbl;		// pointer to array of interface methods
    LPDDRAWI_DDRAWSURFACE_LCL		lpLcl;		// pointer to interface data
    LPDDRAWI_DDRAWSURFACE_INT		lpLink;		// link to next interface
    DWORD				dwIntRefCnt;	// interface reference count
} DDRAWI_DDRAWSURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL
{
    DWORD			dwRefCnt;	// reference count
    DWORD			dwGlobalFlags;	// global flags
    union
    {
	LPVOID			lpRectList;	// list of accesses
	DWORD			dwBlockSizeY;	// block size that display driver requested (return)
    };
    union
    {
	LPVOID			lpVidMemHeap;	// heap vidmem was alloc'ed from
	DWORD			dwBlockSizeX;	// block size that display driver requested (return)
    };
    union
    {
	LPVOID			lpDD; 		// internal DIRECTDRAW object
	LPVOID			lpDDHandle; 	// handle to internal DIRECTDRAW object
						// for use by display driver
						// when calling fns in DDRAW16.DLL
    };
    FLATPTR			fpVidMem;	// pointer to video memory
    union
    {
	LONG			lPitch;		// pitch of surface
	DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    WORD			wHeight;	// height of surface
    WORD			wWidth;		// width of surface
    DWORD			dwUsageCount;	// number of access to this surface
    DWORD			dwReserved1;	// reserved for use by display driver
    //
    // NOTE: this part of the structure is ONLY allocated if the pixel
    //	     format differs from that of the primary display
    //
    DDPIXELFORMAT		ddpfSurface;	// pixel format of surface

} DDRAWI_DDRAWSURFACE_GBL;

/*
 * a structure holding additional LCL surface information (can't simply be appended
 * to the LCL structure as that structure is of variable size).
 */
typedef struct _DDRAWI_DDRAWSURFACE_MORE
{
    DWORD			dwSize;
    VOID			FAR *lpIUnknowns;   // IUnknowns aggregated by this surface
    LPVOID			lpDD_lcl;	    // Pointer to the DirectDraw local object
    DWORD			dwPageLockCount;    // count of pagelocks
    DWORD			dwBytesAllocated;   // size of sys mem allocated
    LPVOID			lpDD_int;	    // Pointer to the DirectDraw interface
    DWORD                       dwMipMapCount;      // Number of mip-map levels in the chain
    LPVOID			lpDDIClipper;	    // Interface to attached clipper object
} DDRAWI_DDRAWSURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
struct _DDRAWI_DDRAWSURFACE_LCL
{
    LPDDRAWI_DDRAWSURFACE_MORE		lpSurfMore;	// pointer to additional local data
    LPDDRAWI_DDRAWSURFACE_GBL		lpGbl;		// pointer to surface shared data
    DWORD                               hDDSurface;     // NT Kernel-mode handle was dwUnused0
    LPVOID				lpAttachList;	// link to surfaces we attached to
    LPVOID				lpAttachListFrom;// link to surfaces that attached to this one
    DWORD				dwLocalRefCnt;	// object refcnt
    DWORD				dwProcessId;	// owning process
    DWORD				dwFlags;	// flags
    DDSCAPS				ddsCaps;	// capabilities of surface
    union
    {
	LPVOID			 	lpDDPalette; 	// associated palette
	LPVOID			 	lp16DDPalette; 	// 16-bit ptr to associated palette
    };
    union
    {
	LPVOID			 	lpDDClipper; 	// associated clipper
	LPVOID			 	lp16DDClipper; 	// 16-bit ptr to associated clipper
    };
    DWORD				dwModeCreatedIn;
    DWORD				dwBackBufferCount; // number of back buffers created
    DDCOLORKEY				ddckCKDestBlt;	// color key for destination blt use
    DDCOLORKEY				ddckCKSrcBlt;	// color key for source blt use
//    IUnknown				FAR *pUnkOuter;	// outer IUnknown
    DWORD				hDC;		// owned dc
    DWORD				dwReserved1;	// reserved for use by display driver

    /*
     * NOTE: this part of the structure is ONLY allocated if the surface
     *	     can be used for overlays.  ddckCKSrcOverlay MUST NOT BE MOVED
     *	     from the start of this area.
     */
    DDCOLORKEY				ddckCKSrcOverlay;// color key for source overlay use
    DDCOLORKEY				ddckCKDestOverlay;// color key for destination overlay use
    LPDDRAWI_DDRAWSURFACE_INT		lpSurfaceOverlaying; // surface we are overlaying
    DBLNODE				dbnOverlayNode;
    /*
     * overlay rectangle, used by DDHEL
     */
    RECT				rcOverlaySrc;
    RECT				rcOverlayDest;
    /*
     * the below values are kept here for ddhel. they're set by UpdateOverlay,
     * they're used whenever the overlays are redrawn.
     */
    DWORD				dwClrXparent; 	// the *actual* color key (override, colorkey, or CLR_INVALID)
    DWORD				dwAlpha; 	// the per surface alpha
    /*
     * overlay position
     */
    LONG				lOverlayX;	// current x position
    LONG				lOverlayY;	// current y position
};
typedef struct _DDRAWI_DDRAWSURFACE_LCL DDRAWI_DDRAWSURFACE_LCL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\ddrawex.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawex.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   03-mar-97	craige	added palettes to CreateCompatibleBitmapSurface
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   01-apr-97  jeffort Following changes checked in:
 *                      Attachlist structure added (from ddrawi.h)
 *                      Surface linked list handled
 *                      D3D interfaces added to QueryInterface
 *                      Complex surfaces are handled at CreateSurface calls
 *                      CreatCompatibleBitmap changed to handle > 8bpp bitmaps
 *                      Changed the call to GetPaletteEntries to use a handle to a palette
 *
 *   04-apr-97  jeffort Trident ifdef's removed
 *                      IDirectDraw3 class implemntation
 *                      paramter changed in recursive handling of attach lists
 *   10-apr-97  jeffort Release of pSurface2 in creating a simple surface was incorrect
 *                      this was already being done in surface.cpp
 *
 *   21-apr-97  jeffort Version Check for DX5 for QI of IDirectDrawSurface3
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   28-apr-97  jeffort Palette wrapping if CreatePalette fails in our internal
 *                      function, cleanup code added
 *   30-apr-97  jeffort No longer addref when querying for IDirect3D (done in ddraw QI)
 *                      AddRef attached surfaces (release done in releasing the surface)
 *   02-may-97  jeffort local variable changed from DWORD to WORD
 *
 *   08-may-97  jeffort Better parameter checking
 *   09-may-97  jeffort If GetTransparentIndex has nothing set return OK/COLOR_NO_TRANSPARENT
 *   16-may-97  jeffort A surface failing to be created is already released.  The release here
 *                      was removed.
 *   20-may-97  jeffort GetFormatFromDC checks if this is a surface DC and gets the
 *                      format from the surface instead of GetDeviceCaps
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   12-jun-97  jeffort reversed R and B fields in 32bpp PIXELFORMAT array
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *   27-jun-97  jeffort IDirectDrawSurface3 interface support for DX3 was not
 *                      added.  We now use an IDirectDrawSurface2 to spoof it
 *                      so we can support SetSurfaceDesc
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 ***************************************************************************/
#define INITGUID
#define CPP_FUNCTIONS
#include "ddfactry.h"

#define m_pDirectDraw (m_DDInt.m_pRealInterface)
#define m_pDirectDraw2 (m_DD2Int.m_pRealInterface)
#define m_pDirectDraw4 (m_DD4Int.m_pRealInterface)



typedef struct _ATTACHLIST
{
    DWORD 	dwFlags;
    struct _ATTACHLIST			FAR *lpLink; 	  // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL	FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT	FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;

/*
 * CDirectDrawEx::CDirectDrawEx
 *
 * Constructor for the new DirectDrawEx class
 */
CDirectDrawEx::CDirectDrawEx(IUnknown *pUnkOuter) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pFirstSurface(NULL),
    m_pFirstPalette(NULL),
    m_pPrimaryPaletteList(NULL)
{

    DllAddRef();
    m_pDirectDraw = NULL;
    m_pDirectDraw2 = NULL;
    m_pDirectDraw4 = NULL;
    m_DDInt.m_pDirectDrawEx = this;
    m_DD2Int.m_pDirectDrawEx = this;
    m_DD4Int.m_pDirectDrawEx = this;
} /* CDirectDrawEx::CDirectDrawEx */


/*
 * CDirectDrawEx::Init
 */
HRESULT CDirectDrawEx::Init(
			GUID * pGUID,
			HWND hWnd,
			DWORD dwCoopLevelFlags,
			DWORD dwReserved,
			LPDIRECTDRAWCREATE pDirectDrawCreate )
{
    HRESULT hr;
    if( dwReserved )
    {
	hr = DDERR_INVALIDPARAMS;
    }
    else
    {
        //DDraw will pop a dialog complaining about 4bpp modes, so we need to
        //tell it not to. DDraw will sniff SEM and not pop the dialog if
        //SEM_FAILCRITICALERRORS is set.
        DWORD dw = SetErrorMode(SEM_FAILCRITICALERRORS);
        SetErrorMode(dw | SEM_FAILCRITICALERRORS); // retain old flags too
	hr = pDirectDrawCreate( pGUID, &m_pDirectDraw, NULL );
        SetErrorMode(dw);
	if( SUCCEEDED(hr) )
	{
	    hr = m_pDirectDraw->SetCooperativeLevel(hWnd, dwCoopLevelFlags);
	    if( SUCCEEDED(hr) )
	    {
                if (dwCoopLevelFlags & DDSCL_EXCLUSIVE)
                    m_bExclusive = TRUE;
                else
                    m_bExclusive = FALSE;
		hr = m_pDirectDraw->QueryInterface(IID_IDirectDraw2, (void **)&m_pDirectDraw2);
		if( SUCCEEDED(hr) )
		{
                    m_pDirectDraw->QueryInterface(IID_IDirectDraw4, (void **)&m_pDirectDraw4);
                    InitDirectDrawInterfaces(m_pDirectDraw, &m_DDInt, m_pDirectDraw2, &m_DD2Int, m_pDirectDraw4, &m_DD4Int);
                }
	    }
	}
    }
    return hr;

} /* CDirectDrawEx::Init */

/*
 * CDirectDrawEx::~CDirectDrawEx
 *
 * destructor
 */
CDirectDrawEx::~CDirectDrawEx()
{
    if( m_pDirectDraw )
    {
	m_pDirectDraw->Release();
    }
    if( m_pDirectDraw2 )
    {
	m_pDirectDraw2->Release();
    }
    if (m_pDirectDraw4)
    {
        m_pDirectDraw4->Release();
    }

#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDirectDrawEx) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif

    DllRelease();

} /* CDirectDrawEx::~CDirectDrawEx */

/*
 * CDirectDrawEx::NonDelegatingQueryInterface
 * 		  NonDelegatingAddRef
 * 		  NonDelegatingRelease
 *
 * The base IUnknown interface (non-delegating)
 */

STDMETHODIMP CDirectDrawEx::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    *ppv=NULL;

    if( IID_IUnknown == riid )
    {
	*ppv=(INonDelegatingUnknown *)this;
    }
    else if (IID_IDirectDraw3 == riid)
    {
        *ppv=(IDirectDraw3 *)this;
    }

    else if( IID_IDirectDraw==riid )
    {
	*ppv=&m_DDInt;
    }
    else if( IID_IDirectDraw2==riid )
    {
	*ppv=&m_DD2Int;
    }
    else if (IID_IDirectDraw4==riid && m_pDirectDraw4)
    {
        *ppv=&m_DD4Int;
    }
    else if (IID_IDirect3D == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else if (IID_IDirect3D2 == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else if (IID_IDirect3D3 == riid)
    {
	IUnknown* pUnk;

        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDirectDraw;
        hr = lpFunc(&(m_DDInt.lpVtbl), riid, (void **)&pUnk);
        if( SUCCEEDED(hr) )
        {
            *ppv=pUnk;
        }
        else
	{
            *ppv = NULL;
	}
	return hr;
    }
    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;

} /* CDirectDrawEx::NonDelegatingQueryInterface */


STDMETHODIMP_(ULONG) CDirectDrawEx::NonDelegatingAddRef()
{
    m_pDirectDraw->AddRef();
    return InterlockedIncrement(&m_cRef);

} /* CDirectDrawEx::NonDelegatingAddRef */


STDMETHODIMP_(ULONG) CDirectDrawEx::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount)
    {
        m_pDirectDraw->Release();
	return lRefCount;
    }
    delete this;
    return 0;

} /* CDirectDrawEx::NonDelegatingRelease */

/*
 * CDirectDrawEx::QueryInterface
 *                AddRef
 *                Release
 *
 * The standard IUnknown that delegates...
 */
STDMETHODIMP CDirectDrawEx::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDirectDrawEx::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDirectDrawEx::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */


/*
 * CDirectDrawEx::GetSurfaceFromDC
 *
 * Run the list of surfaces and find which one has this DC.
 * Works with OWNDC surfaces only for now.
 */
STDMETHODIMP CDirectDrawEx::GetSurfaceFromDC(HDC hdc, IDirectDrawSurface **ppSurface)
{
    HRESULT hr = DDERR_NOTFOUND;
    if( !ppSurface )
    {
	hr = E_POINTER;
    }
    else
    {
	*ppSurface = NULL;
	ENTER_DDEX();
	CDDSurface *pSurface = m_pFirstSurface;
	while( pSurface )
	{
	    if( (pSurface->m_HDC == hdc) || (pSurface->m_hDCDib == hdc) )
	    {
		hr = pSurface->m_pUnkOuter->QueryInterface(IID_IDirectDrawSurface, (void **)ppSurface);
		break;
	    }
	    pSurface = pSurface->m_pNext;
	}
	LEAVE_DDEX();
    }
    return hr;

} /* CDirectDrawEx::GetSurfaceFromDC */


/*
 * CDirectDrawEx::AddSurfaceToList
 *
 * Adds a surface to our doubly-linked surface list
 */
void CDirectDrawEx::AddSurfaceToList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pFirstSurface )
    {
	m_pFirstSurface->m_pPrev = pSurface;
    }
    pSurface->m_pPrev = NULL;
    pSurface->m_pNext = m_pFirstSurface;
    m_pFirstSurface = pSurface;
    LEAVE_DDEX();

} /* CDirectDrawEx::AddSurfaceToList */

/*
 * CDirectDrawEx::RemoveSurfaceToList
 *
 * Removes a surface to our doubly-linked surface list
 */
void CDirectDrawEx::RemoveSurfaceFromList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrev )
    {
	pSurface->m_pPrev->m_pNext = pSurface->m_pNext;
    }
    else
    {
	m_pFirstSurface = pSurface->m_pNext;
    }
    if( pSurface->m_pNext )
    {
	pSurface->m_pNext->m_pPrev = pSurface->m_pPrev;
    }
    LEAVE_DDEX();

} /* CDirectDrawEx::RemoveSurfaceToList */


/*
 * CDirectDrawEx::AddSurfaceToPrimarList
 *
 * Adds a surface to our doubly-linked surface list which use the primary palette
 */
void CDirectDrawEx::AddSurfaceToPrimaryList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pPrimaryPaletteList )
    {
	m_pPrimaryPaletteList->m_pPrevPalette = pSurface;
    }
    pSurface->m_pPrevPalette = NULL;
    pSurface->m_pNextPalette = m_pPrimaryPaletteList;
    m_pPrimaryPaletteList = pSurface;
    pSurface->m_bPrimaryPalette = TRUE;
    LEAVE_DDEX();

} /* CDirectDrawEx::AddSurfaceToList */


/*
 * CDirectDrawEx::RemoveSurfaceFromPrimaryList
 *
 * Removes a surface to our doubly-linked surface list which use the primary palette
 */
void CDirectDrawEx::RemoveSurfaceFromPrimaryList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrevPalette )
    {
	pSurface->m_pPrevPalette->m_pNextPalette = pSurface->m_pNextPalette;
    }
    else
    {
	m_pPrimaryPaletteList = pSurface->m_pNextPalette;
    }
    if( pSurface->m_pNextPalette )
    {
	pSurface->m_pNextPalette->m_pPrevPalette = pSurface->m_pPrevPalette;
    }
    pSurface->m_bPrimaryPalette = FALSE;
    LEAVE_DDEX();

} /* CDirectDrawEx::RemoveSurfaceToList */



/*
 * CDirectDrawEx::AddPaletteToList
 *
 * Adds a palette to our doubly-linked palette list
 */
void CDirectDrawEx::AddPaletteToList(CDDPalette *pPalette)
{
    ENTER_DDEX();
    if( m_pFirstPalette )
    {
	m_pFirstPalette->m_pPrev = pPalette;
    }
    pPalette->m_pPrev = NULL;
    pPalette->m_pNext = m_pFirstPalette;
    m_pFirstPalette = pPalette;
    LEAVE_DDEX();

}

/*
 * CDirectDrawEx::RemovePaletteToList
 *
 * Removes a palette to our doubly-linked palette list
 */
void CDirectDrawEx::RemovePaletteFromList(CDDPalette *pPalette)
{
    ENTER_DDEX();
    if( pPalette->m_pPrev )
    {
	pPalette->m_pPrev->m_pNext = pPalette->m_pNext;
    }
    else
    {
	m_pFirstPalette = pPalette->m_pNext;
    }
    if( pPalette->m_pNext )
    {
	pPalette->m_pNext->m_pPrev = pPalette->m_pPrev;
    }
    LEAVE_DDEX();

}




HRESULT CDirectDrawEx::CreateSimpleSurface(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter, IDirectDrawSurface * pSurface, IDirectDrawSurface **ppNewSurface, DWORD dwFlags)
{
    IDirectDrawSurface2     *pSurface2 = NULL;
    IDirectDrawSurface3     *pSurface3 = NULL;
    HRESULT		    hr;

    hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface2);
    if (FAILED(hr))
        return hr;
    //we only want to do this Query if we are on DX5 or above.  On DX3, this is not supported,
    //and this call will cause D3D to be loaded
    pSurface3 = NULL;
    if (m_dwDDVer == WIN95_DX5 || m_dwDDVer == WINNT_DX5)
    {
        hr = pSurface->QueryInterface(IID_IDirectDrawSurface3, (void **)&pSurface3);
        if( FAILED( hr ) )
        {
            pSurface3 = NULL;
        }
    }
    if (pSurface3 == NULL)
        hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface3);
    if (FAILED(hr))
        return hr;

    IDirectDrawSurface4 *pSurface4 = NULL;
    //
    //  It's fine if this does not work...  Just ignore return code.
    //
    pSurface->QueryInterface(IID_IDirectDrawSurface4, (void **)&pSurface4);

    hr = CDDSurface::CreateSimpleSurface(
                        pSurfaceDesc,
  			pSurface,
 			pSurface2,
 			pSurface3,
                        pSurface4,
			pUnkOuter,
  			this,
                        ppNewSurface,
                        dwFlags);
    return hr;
}

HRESULT CDirectDrawEx::HandleAttachList(LPDDSURFACEDESC pSurfaceDesc, IUnknown *pUnkOuter,IDirectDrawSurface **ppNewSurface, IDirectDrawSurface * pOrigSurf, DWORD dwFlags)
{
    IDirectDrawSurface      *pSurface;
    IDirectDrawSurface      *pSurfaceReturn;
    DDSURFACEDESC           SurfaceDesc;
    HRESULT		    hr;

    //create the necessary SurfaceData here
    pSurface = *ppNewSurface;

    SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
    //add ref the attached surface here
    pSurface->AddRef();
    hr = pSurface->GetSurfaceDesc(&SurfaceDesc);
    if (!SUCCEEDED(hr))
        return hr;
    hr = CreateSimpleSurface(&SurfaceDesc, pUnkOuter, pSurface, (IDirectDrawSurface **)&pSurfaceReturn, dwFlags);

    if (!SUCCEEDED(hr))
        return hr;
    //we got here via an attachlist, so we need to recurse into the structure more
    LPATTACHLIST lpAttach;

    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
    while (lpAttach != NULL){
        pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
        lpAttach = lpAttach->lpLink;
        if (pSurface != pOrigSurf){
            hr = HandleAttachList(pSurfaceDesc, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
                return hr;
        }
    }
    return hr;
}



/*
 * CDirectDrawEx::CreateSurface
 *
 * Create a DirectDraw surface that supports OWNDC
 */
STDMETHODIMP CDirectDrawEx::CreateSurface(LPDDSURFACEDESC pSurfaceDesc, IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{
    DWORD 		origcaps;
    DWORD		newcaps;
    DWORD               dwFlags;
    IDirectDrawSurface	*pSurface;

    if (pSurfaceDesc == NULL)
        return DDERR_INVALIDPARAMS;
    if (ppNewSurface == NULL)
        return DDERR_INVALIDPARAMS;
    origcaps = pSurfaceDesc->ddsCaps.dwCaps;
    newcaps = origcaps;

    /*
     * If OWNDC is specified, it must be a system memory surface
     */
    if ((origcaps & (DDSCAPS_OWNDC | DDSCAPS_SYSTEMMEMORY)) == DDSCAPS_OWNDC)
    {
	return DDERR_INVALIDCAPS;
    }

    /*
     * DATAEXCHANGE has some magic...
     */
    if( (origcaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        dwFlags = SURFACE_DATAEXCHANGE;
        //Do not allow the primary surface with these caps!!!!
        if (origcaps & DDSCAPS_PRIMARYSURFACE)
            return DDERR_INVALIDCAPS;
	newcaps &= ~DDSCAPS_DATAEXCHANGE;
	newcaps |= DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC  | DDSCAPS_TEXTURE;
        if (newcaps & DDSCAPS_OFFSCREENPLAIN)
            newcaps &= ~DDSCAPS_OFFSCREENPLAIN;
    }
    else
        dwFlags = 0;

    /*
     * turn off OWNDC when going to DirectDraw 3
     */
    if (m_dwDDVer != WIN95_DX5 && m_dwDDVer != WINNT_DX5)
        newcaps &= ~DDSCAPS_OWNDC;

    /*
     * go create the surface (without the OWNDC attribute)
     */
    pSurfaceDesc->ddsCaps.dwCaps = newcaps;
    HRESULT hr = m_pDirectDraw->CreateSurface(pSurfaceDesc, &pSurface, NULL);
    pSurfaceDesc->ddsCaps.dwCaps = origcaps;
   /*
     * once we have the object, get any additional interfaces we need
     * to support and then create our surface object
     */
    if( SUCCEEDED(hr) )
    {
        hr = CreateSimpleSurface(pSurfaceDesc, pUnkOuter, pSurface, ppNewSurface, dwFlags);
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
        //we need to worry about attached surfaces, do so here
        LPATTACHLIST lpAttach;
        //add the current surface to our list of surfaces
        IDirectDrawSurface * pOrigSurf = pSurface;
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
        while (lpAttach != NULL)
        {
            lpAttach = lpAttach->lpLink;
            pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            hr = HandleAttachList(pSurfaceDesc, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
            {
                //we need to drop out of the loop and clean up
                lpAttach = NULL;
            }
        }
        if (!SUCCEEDED(hr))
        {
         //   pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pOrigSurf))->lpLcl->lpAttachList))->lpIAttached;
         //   lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
            while (lpAttach != NULL)
            {
                //clean up these surfaces
                lpAttach = lpAttach->lpLink;
            }
        }
    }
    return hr;
} /* CDirectDrawEX::CreateSurface */


//
//  This is a modified copy of the above except using surfacedesc2 and surface4
//
STDMETHODIMP CDirectDrawEx::CreateSurface(LPDDSURFACEDESC2 pSurfaceDesc2, IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter)
{
    DWORD 		origcaps;
    DWORD		newcaps;
    DWORD               dwFlags;
    IDirectDrawSurface4	*pSurface4;

    if (pSurfaceDesc2 == NULL)
        return DDERR_INVALIDPARAMS;
    if (ppNewSurface4 == NULL)
        return DDERR_INVALIDPARAMS;
    origcaps = pSurfaceDesc2->ddsCaps.dwCaps;
    newcaps = origcaps;

    /*
     * If OWNDC is specified, it must be a system memory surface
     */
    if ((origcaps & (DDSCAPS_OWNDC | DDSCAPS_SYSTEMMEMORY)) == DDSCAPS_OWNDC)
    {
	return DDERR_INVALIDCAPS;
    }

    /*
     * DATAEXCHANGE has some magic...
     */
    if( (origcaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        dwFlags = SURFACE_DATAEXCHANGE;
        //Do not allow the primary surface with these caps!!!!
        if (origcaps & DDSCAPS_PRIMARYSURFACE)
            return DDERR_INVALIDCAPS;
	newcaps &= ~DDSCAPS_DATAEXCHANGE;
	newcaps |= DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC  | DDSCAPS_TEXTURE;
        if (newcaps & DDSCAPS_OFFSCREENPLAIN)
            newcaps &= ~DDSCAPS_OFFSCREENPLAIN;
    }
    else
        dwFlags = 0;

    /*
     * turn off OWNDC when going to DirectDraw 3
     */
    if (m_dwDDVer != WIN95_DX5 && m_dwDDVer != WINNT_DX5)
        newcaps &= ~DDSCAPS_OWNDC;

    /*
     * go create the surface (without the OWNDC attribute)
     */
    pSurfaceDesc2->ddsCaps.dwCaps = newcaps;
    HRESULT hr = m_pDirectDraw4->CreateSurface(pSurfaceDesc2, &pSurface4, NULL);
    pSurfaceDesc2->ddsCaps.dwCaps = origcaps;
   /*
     * once we have the object, get any additional interfaces we need
     * to support and then create our surface object
     */
    if( SUCCEEDED(hr) )
    {
        IDirectDrawSurface * pSurface;
        pSurface4->QueryInterface(IID_IDirectDrawSurface, (void **)&pSurface);
        pSurface4->Release();
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        pSurface->GetSurfaceDesc(&ddsd);
        ddsd.ddsCaps.dwCaps = origcaps;
        IDirectDrawSurface *pNewSurf1;
        hr = CreateSimpleSurface(&ddsd, pUnkOuter, pSurface, &pNewSurf1, dwFlags);
        if (!SUCCEEDED(hr))
        {
            return hr;
        }
        pNewSurf1->QueryInterface(IID_IDirectDrawSurface4, (void **)ppNewSurface4);
        pNewSurf1->Release();
        //we need to worry about attached surfaces, do so here
        LPATTACHLIST lpAttach;
        //add the current surface to our list of surfaces
        IDirectDrawSurface * pOrigSurf = pSurface;
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
        while (lpAttach != NULL)
        {
            lpAttach = lpAttach->lpLink;
            pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            hr = HandleAttachList(&ddsd, pUnkOuter, &pSurface, pOrigSurf, dwFlags);
            if (!SUCCEEDED(hr))
            {
                //we need to drop out of the loop and clean up
                lpAttach = NULL;
            }
        }
        if (!SUCCEEDED(hr))
        {
         //   pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pOrigSurf))->lpLcl->lpAttachList))->lpIAttached;
         //   lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList);
            while (lpAttach != NULL)
            {
                //clean up these surfaces
                lpAttach = lpAttach->lpLink;
            }
        }
    }
    return hr;
} /* CDirectDrawEX::CreateSurface */


STDMETHODIMP CDirectDrawEx::CreatePalette(DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    IDirectDrawPalette	*pPalette;


    HRESULT hr = m_pDirectDraw->CreatePalette(dwFlags, pEntries, &pPalette, NULL);
    if (SUCCEEDED(hr))
    {
        hr = CDDPalette::CreateSimplePalette(pEntries, pPalette, ppPal, pUnkOuter, this);
        if (FAILED(hr))
        {
            //we were unable to create our palette structure, so we must delete the palette
            //we created here and fail
            pPalette->Release();
            *ppPal = NULL;
        }
    }

    return hr;
}


STDMETHODIMP CDirectDrawEx::SetCooperativeLevel(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = m_pDirectDraw->SetCooperativeLevel(hwnd, dwFlags);
    //check for exclusive mode here
    if (dwFlags & DDSCL_EXCLUSIVE)
        m_bExclusive = TRUE;
    else
        m_bExclusive = FALSE;
    return hr;
}


/*
 * some quicky inline fns to get at our object data
 */
_inline CDirectDrawEx * PARENTOF(IDirectDraw * pDD)
{
    return ((INTSTRUC_IDirectDraw *)pDD)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw2 * pDD2)
{
    return ((INTSTRUC_IDirectDraw2 *)pDD2)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw4 * pDD4)
{
    return ((INTSTRUC_IDirectDraw4 *)pDD4)->m_pDirectDrawEx;
}


/*
 * the implementation of the functions in IDirectDraw that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDrawAggAddRef(IDirectDraw *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawAggRelease(IDirectDraw *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDrawAggCreateSurface(IDirectDraw *pDD, LPDDSURFACEDESC pSurfaceDesc,
				         IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc, ppNewSurface, pUnkOuter);
}

STDMETHODIMP IDirectDrawAggCreatePalette(IDirectDraw *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDrawAggSetCooperativeLevel(IDirectDraw * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}
/*
 * the implementation of the functions in IDirectDraw2 that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDraw2AggAddRef(IDirectDraw2 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDraw2AggRelease(IDirectDraw2 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDraw2AggCreateSurface(IDirectDraw2 *pDD, LPDDSURFACEDESC pSurfaceDesc,
					  IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter)
{						
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc, ppNewSurface, pUnkOuter);
}

STDMETHODIMP IDirectDraw2AggCreatePalette(IDirectDraw2 *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDraw2AggSetCooperativeLevel(IDirectDraw2 * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}


/***************************************************************************
 *
 *
 * IDirectDraw3 stuff follows
 *
 *
 ***************************************************************************/
STDMETHODIMP CDirectDrawEx::Compact()
{
    return m_pDirectDraw2->Compact();
}

STDMETHODIMP CDirectDrawEx::CreateClipper(DWORD dwParam, LPDIRECTDRAWCLIPPER FAR* pClip, IUnknown FAR * pIUnk )
{
    return m_pDirectDraw2->CreateClipper(dwParam, pClip, pIUnk);
}

STDMETHODIMP CDirectDrawEx::DuplicateSurface(LPDIRECTDRAWSURFACE pSurf, LPDIRECTDRAWSURFACE FAR * ppSurf2)
{
    return m_pDirectDraw2->DuplicateSurface(pSurf, ppSurf2);
}


STDMETHODIMP CDirectDrawEx::EnumDisplayModes(DWORD dwParam, LPDDSURFACEDESC pSurfDesc, LPVOID pPtr, LPDDENUMMODESCALLBACK pCallback )
{
    return m_pDirectDraw2->EnumDisplayModes(dwParam, pSurfDesc, pPtr, pCallback);
}

STDMETHODIMP CDirectDrawEx::EnumSurfaces(DWORD dwParam, LPDDSURFACEDESC pSurfDesc, LPVOID pPtr,LPDDENUMSURFACESCALLBACK pCallback)
{
    return m_pDirectDraw2->EnumSurfaces(dwParam, pSurfDesc, pPtr, pCallback);
}

STDMETHODIMP CDirectDrawEx::FlipToGDISurface()
{
    return m_pDirectDraw2->FlipToGDISurface();
}

STDMETHODIMP CDirectDrawEx::GetCaps(LPDDCAPS pDDCaps1, LPDDCAPS pDDCaps2)
{
    return m_pDirectDraw2->GetCaps(pDDCaps1, pDDCaps2);
}

STDMETHODIMP CDirectDrawEx::GetDisplayMode(LPDDSURFACEDESC pSurfDesc)
{
    return m_pDirectDraw2->GetDisplayMode(pSurfDesc);
}

STDMETHODIMP CDirectDrawEx::GetFourCCCodes(LPDWORD pDW1, LPDWORD pDW2 )
{
    return m_pDirectDraw2->GetFourCCCodes(pDW1, pDW2);
}

STDMETHODIMP CDirectDrawEx::GetGDISurface(LPDIRECTDRAWSURFACE FAR * ppSurf)
{
    return m_pDirectDraw2->GetGDISurface(ppSurf);
}

STDMETHODIMP CDirectDrawEx::GetMonitorFrequency(LPDWORD pParam)
{
    return m_pDirectDraw2->GetMonitorFrequency(pParam);
}

STDMETHODIMP CDirectDrawEx::GetScanLine(LPDWORD pParam)
{
    return m_pDirectDraw2->GetScanLine(pParam);
}


STDMETHODIMP CDirectDrawEx::GetVerticalBlankStatus(LPBOOL lpParam )
{
    return m_pDirectDraw2->GetVerticalBlankStatus(lpParam);
}

STDMETHODIMP CDirectDrawEx::Initialize(GUID FAR * pGUID)
{
    return m_pDirectDraw2->Initialize(pGUID);
}

STDMETHODIMP CDirectDrawEx::RestoreDisplayMode()
{
    return m_pDirectDraw2->RestoreDisplayMode();
}

STDMETHODIMP CDirectDrawEx::SetDisplayMode(DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5)
{
    return m_pDirectDraw2->SetDisplayMode(dw1, dw2, dw3, dw4, dw5);
}

STDMETHODIMP CDirectDrawEx::WaitForVerticalBlank(DWORD dw1, HANDLE hdl)
{
    return m_pDirectDraw2->WaitForVerticalBlank(dw1, hdl);
}

STDMETHODIMP CDirectDrawEx::GetAvailableVidMem(LPDDSCAPS pDDSCaps, LPDWORD pParam1, LPDWORD pParam2)
{
    return m_pDirectDraw2->GetAvailableVidMem(pDDSCaps, pParam1, pParam2);
}




/*
 * the implementation of the functions in IDirectDraw4 that we are overriding
 * (IUnknown and CreateSurface)
 */
STDMETHODIMP_(ULONG) IDirectDraw4AggAddRef(IDirectDraw4 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDraw4AggRelease(IDirectDraw4 *pDD)
{
    return PARENTOF(pDD)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDraw4AggCreateSurface(IDirectDraw4 *pDD, LPDDSURFACEDESC2 pSurfaceDesc2,
					  IDirectDrawSurface4 **ppNewSurface4, IUnknown *pUnkOuter)
{						
    return PARENTOF(pDD)->CreateSurface(pSurfaceDesc2, ppNewSurface4, pUnkOuter);
}

STDMETHODIMP IDirectDraw4AggCreatePalette(IDirectDraw4 *pDD,DWORD dwFlags, LPPALETTEENTRY pEntries, LPDIRECTDRAWPALETTE FAR * ppPal, IUnknown FAR * pUnkOuter)
{
    return PARENTOF(pDD)->CreatePalette( dwFlags, pEntries, ppPal, pUnkOuter);
}

STDMETHODIMP IDirectDraw4AggSetCooperativeLevel(IDirectDraw4 * pDD, HWND hwnd, DWORD dwFlags)
{
    return PARENTOF(pDD)->SetCooperativeLevel(hwnd, dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\surface.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawex.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin; integrated IBitmapSurface
 *			stuff
 *   27-feb-97	craige	use DIBSections for surface memory ddraw 3 surfaces
 *			(icky icky icky)
 *   03-mar-97	craige	IRGBColorTable support
 *   06-mar-97	craige	support for IDirectDrawSurface3::SetBits
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      D3DDevice and Texture interfaces supported in QueryInterface
 *                      MakeDibInfo fills in a dummy pixel mask for Z Buffers
 *                      Aligned freeing handled
 *                      Does not init (MakeDibSection) of primary surfaces
 *                      A palette is mapped in at GetDC calls
 *
 *   04-apr-97  jeffort LocalFree of bitmap info added
 *                      Addref and release added for D3D interfaces
 *
 *   09-apr-97  jeffort Added call to SetDIBColorTable at GetDC time
 *                      Support for WinNT4.0 Gold added by not creating a DIB section
 *                      and not supporting SetSurfaceDesc calls
 *                      Added support for halftone palette if no palette is
 *                      selected in at init time
 *                      Added support for proper handling of 1,2,and 4 bpp surface palettes
 *                      IBitmapSurface creation needs to set OWNDC flag
 *
 *   10-apr-97  jeffort Correct number of entries used in palette creation at GetDC time
 *
 *   16-apr-97  jeffort Check for OWNDC when creating a DibSection.  palette handling
 *                      change in GetDC of setting flags
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *   30-apr-97  jeffort Critical section shared from ddrawex object
 *                      Attach list deleted at surface destruction time
 *                      AddAttachedSurfaces now passes in real interfaces
 *                      Palette functions pass in real interfaces to ddraw
 *                      AddRef removed from D3D interface QI's
 *   02-may-97  jeffort Deletion of implicit attached surface handled
 *                      wrapping of GetDDInterface returns our ddrawex interface
 *   06-may-97  jeffort Parameter checking, SetPalette handles null parameter
 *                      wrapping of DeleteAttachedSurface
 *
 *   08-may-97  jeffort SetPalette fixes (release should have been addref)
 *                      Better parameter checking
 *   20-may-97  jeffort NT4.0 Gold handles OWNDC as SP3 does by creating a dib
 *                      section and resets a few ddraw internal structures
 *                      These are reset at surface release time
 *   22-may-97  jeffort If a surface is being destroyed, detach any attached palette
 *                      If a SetPalette is called with NULL, and a palette
 *                      was previously attached, the member variable storing the
 *                      palette is set to NULL
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   02-jun-97  jeffort Temporary fix for SP3 memory leak.  Handle SP3 as NT Gold
 *                      by storing off pointer values and restoring at free
 *   17-jun-97  jeffort If releasing a surface that has explicitly attached surfaces
 *                      we now addref the inner surface (which will be released when
 *                      the inner surface we are releasing is released), and release
 *                      our outer interface so ref counting models ddraw.
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *                      when creating the primary surface, this is now added to the primary
 *                      surface list regardles if OWNDC is set or not
 *   27-jun-97  jeffort IDirectDrawSurface3 interface support for DX3 was not
 *                      added.  We now use an IDirectDrawSurface2 to spoof it
 *                      so we can support SetSurfaceDesc
 *   02-jul-97  jeffort Use m_bSaveDC boolean if a DX5 surface with OWNDC set
 *                      we need to not NULL out the DC when ReleaseDC is called
 *                      so that a call to GetSurfaceFromDC will work
 *   07-jul-97  jeffort Releasing DDrawEx object moved in destructor function to last step
 *   07-jul-97  jeffort Wrapped GetSurfaceDesc so correct caps bits are set
 *   10-jul-97  jeffort Added m_BMOld to reset the bitmap after releasing the one
 *                      we create
 *                      Do not add a surface to a palette list if it is already in this list
 *   18-jul-97  jeffort Added D3D MMX Device support
 *   22-jul-97  jeffort Removed IBitmapSurface and associated interfaces
 *                      Fixed problem with attach lists, and releasing implicit created surfaces
 *   02-aug-97  jeffort Added code to GetPalette to return a palette if the palette that
 *                      was set was not created with the same ddrawex object that the surface was
 *                      Added code to handle attaching surfaces that were created with different
 *                      ddrawex objects
 *   20-feb-98  stevela Added support for DX6 MMX rasterizers
 ***************************************************************************/
#include "ddfactry.h"
#include "d3d.h"

#define m_pDDSurface (m_DDSInt.m_pRealInterface)
#define m_pDDSurface2 (m_DDS2Int.m_pRealInterface)
#define m_pDDSurface3 (m_DDS3Int.m_pRealInterface)
#define m_pDDSurface4 (m_DDS4Int.m_pRealInterface)

#define DDSURFACETYPE_1 1
#define DDSURFACETYPE_2 2
#define DDSURFACETYPE_3 3
#define DDSURFACETYPE_4 4


typedef struct _ATTACHLIST
{
    DWORD 	dwFlags;
    struct _ATTACHLIST			FAR *lpLink; 	  // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL	FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT	FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;

#define DDAL_IMPLICIT 0x00000001l

/*
 * CDDSurface::CDDSurface
 *
 * Constructor for simple surface object
 */
CDDSurface::CDDSurface(
		DDSURFACEDESC *pSurfaceDesc,
		IDirectDrawSurface *pDDSurface,
		IDirectDrawSurface2 *pDDSurface2,
		IDirectDrawSurface3 *pDDSurface3,
                IDirectDrawSurface4 *pDDSurface4,
		IUnknown *pUnkOuter,
		CDirectDrawEx *pDirectDrawEx) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pDirectDrawEx(pDirectDrawEx),
    m_bOwnDC((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OWNDC) != 0),
    m_HDC(NULL)
{
    m_pDDSurface = pDDSurface;
    m_pDDSurface2 = pDDSurface2;
    m_pDDSurface3 = pDDSurface3;
    m_pDDSurface4 = pDDSurface4;
    m_DDSInt.m_pSimpleSurface = this;
    m_DDS2Int.m_pSimpleSurface = this;
    m_DDS3Int.m_pSimpleSurface = this;
    m_DDS4Int.m_pSimpleSurface = this;
    m_D3DDeviceRAMPInt = NULL;
    m_D3DDeviceRGBInt = NULL;
    m_D3DDeviceChrmInt = NULL;
    m_D3DDeviceHALInt = NULL;
    m_D3DDeviceMMXInt = NULL;
    m_D3DTextureInt = NULL;
    m_pCurrentPalette = NULL;
    m_pPrevPalette = NULL;
    m_pNextPalette = NULL;
    m_pSaveBits = NULL;
    m_bSaveDC = FALSE;
    m_pAttach = NULL;
    if (m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX5)
        InitSurfaceInterfaces( pDDSurface, &m_DDSInt, pDDSurface2, &m_DDS2Int, pDDSurface3, &m_DDS3Int, pDDSurface4, &m_DDS4Int );
    else
        InitSurfaceInterfaces( pDDSurface, &m_DDSInt, pDDSurface2, &m_DDS2Int, NULL, &m_DDS3Int, pDDSurface4, &m_DDS4Int );



    m_dwCaps = pSurfaceDesc->ddsCaps.dwCaps;
    m_hDCDib = NULL;
    m_hBMDib = NULL;
    m_pBitsDib = NULL;
    m_pDDPal = NULL;
    m_pDDPalOurs = NULL;
    m_bPrimaryPalette = FALSE;
    pDirectDrawEx->AddRef();
    pDirectDrawEx->AddSurfaceToList(this);
    //we want to know if this is the primary surface or not
    if (pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        m_bIsPrimary = TRUE;
    else
        m_bIsPrimary = FALSE;

    //if we created the DIBSection, and it is palettized, we need to add this to
    //the list of surfaces using the primary surface's palette
    if ( (m_bOwnDC && (pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED1 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED2 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED4 ||
        pSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)) || m_bIsPrimary)
    {
        pDirectDrawEx->AddSurfaceToPrimaryList(this);
    }
#ifdef DEBUG
    m_DebugCheckDC = NULL;
#endif
    DllAddRef();

} /* CDDSurface::CDDSurface */

/*
 * CDDSurface::MakeDibInfo
 *
 * create a dib info structure based on the surface desc + palette
 */
HRESULT CDDSurface::MakeDibInfo( LPDDSURFACEDESC pddsd, LPBITMAPINFO pbmi )
{
    DWORD                       bitcnt;

    /*
     * fill in basic values
     */
    pbmi->bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biSizeImage = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    bitcnt = pddsd->ddpfPixelFormat.dwRGBBitCount;
    pbmi->bmiHeader.biBitCount = (WORD) bitcnt;
    /*
     * fill out width, clrused, and compression fields based on bit depth
     */
    switch( bitcnt )
    {
      case 1:
        pbmi->bmiHeader.biWidth = pddsd->lPitch << 3;
        pbmi->bmiHeader.biClrUsed = 2;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

      case 4:
        pbmi->bmiHeader.biWidth = pddsd->lPitch << 1;
        pbmi->bmiHeader.biClrUsed = 16;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

      case 8:
        pbmi->bmiHeader.biWidth = pddsd->lPitch;
        if(pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            pbmi->bmiHeader.biClrUsed = 256;
            pbmi->bmiHeader.biCompression = BI_RGB;
        }
        else
        {
            pbmi->bmiHeader.biClrUsed = 0;
            pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        }
        break;

      case 16:
        pbmi->bmiHeader.biWidth = pddsd->lPitch >> 1;
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biCompression = BI_BITFIELDS;
        break;


      case 24:
        // NOTE: we're assuming RGB format.  This is okay since we
        // don't do color conversion and neither does GDI at 24-bpp.
        pbmi->bmiHeader.biWidth = pddsd->lPitch / 3;
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biCompression = BI_RGB;
        break;

    case 32:
	pbmi->bmiHeader.biWidth = pddsd->lPitch >> 2;
	pbmi->bmiHeader.biClrUsed = 0;
	pbmi->bmiHeader.biCompression = BI_RGB;
	break;
    default:
    	{
	    char	str[256];
	    wsprintf( str, "bitcnt = %ld", bitcnt );
	    MessageBox( NULL, str, "WHAT THE HECK, PIXEL DEPTH IS BAD BAD BAD", MB_OK );
	}
    }

    /*
     * set the color masks if we need to...
     */
    if( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
    {
	DWORD	*p;
	p = (DWORD *) &pbmi->bmiColors[0];
	p[0] = pddsd->ddpfPixelFormat.dwRBitMask;
	p[1] = pddsd->ddpfPixelFormat.dwGBitMask;
	p[2] = pddsd->ddpfPixelFormat.dwBBitMask;
        //check for no masks.  Z-buffers don't have masks
        //so set a dummy value for this function call
        if (p[0] == 0 && p[1] == 0 && p[2] == 0){
            p[0]=0xF800;
            p[1]=0x07E0;
            p[2]=0x001F;
        }

	/*
	 * set the image size too
	 */
	pbmi->bmiHeader.biSizeImage = pddsd->lPitch * (int) pddsd->dwHeight;

    }

    /*
     * height is easy
     */
    pbmi->bmiHeader.biHeight= -1*(int)pddsd->dwHeight;
    /*
     * fill in the color table...
     */
    if( bitcnt <= 8 )
    {
	PALETTEENTRY		pe[256];
	int			i;
	LPDIRECTDRAWPALETTE	pddpal;
	HRESULT			hr;

	/*
	 * is there an attached palette?
	 */
	hr = m_pDDSurface->GetPalette( &pddpal );

	if( SUCCEEDED( hr ) )
	{
            //need to figure out how many entries are in here
            DWORD dwCaps;
            hr = pddpal->GetCaps(&dwCaps);
            if (SUCCEEDED(hr))
            {
                DWORD dwNumEntries;
                if (dwCaps & DDPCAPS_1BIT)
                    dwNumEntries = 1;
                else if (dwCaps & DDPCAPS_2BIT)
                    dwNumEntries = 4;
                else if (dwCaps & DDPCAPS_4BIT)
                    dwNumEntries = 16;
                else if (dwCaps & DDPCAPS_8BIT)
                    dwNumEntries = 256;
                else
                    dwNumEntries = 0;
    	        hr = pddpal->GetEntries( 0, 0, dwNumEntries, pe );
            }
	    pddpal->Release();
	}
        //if we created the DIBSection, and we are in EXCLUSIVE mode
        //then use the primary surface's palette if it exisits yet.
        else if (m_pDirectDrawEx->m_bExclusive)
        {
            //try and find the primary surface palette
            CDDPalette *pPal;

            pPal = m_pDirectDrawEx->m_pFirstPalette;
            while (pPal != NULL && pPal->m_bIsPrimary != TRUE)
                pPal = pPal->m_pNext;
            if (pPal != NULL)
            {
                DWORD dwCaps;
                hr = pPal->m_DDPInt.m_pRealInterface->GetCaps(&dwCaps);
                if (SUCCEEDED(hr))
                {
                    DWORD dwNumEntries;
                    if (dwCaps & DDPCAPS_1BIT)
                        dwNumEntries = 1;
                    else if (dwCaps & DDPCAPS_2BIT)
                        dwNumEntries = 4;
                    else if (dwCaps & DDPCAPS_4BIT)
                        dwNumEntries = 16;
                    else if (dwCaps & DDPCAPS_8BIT)
                        dwNumEntries = 256;
                    else
                        dwNumEntries = 0;
    	            hr = pPal->m_DDPInt.m_pRealInterface->GetEntries( 0, 0, dwNumEntries, pe );

                }
            }
        }

        /*
	 * nope, so use the system palette
	 */
	if( FAILED( hr ) )
	{
            HDC	hdc;
	    hdc = ::GetDC( NULL );
	    GetSystemPaletteEntries(hdc, 0, 256, pe);
	    ::ReleaseDC(NULL, hdc);
	}

	/*
	 * now copy the color table
	 */

        int iNumEntries;
        switch (bitcnt)
        {
        case 1:
            iNumEntries = 1;
            break;
        case 2:
            iNumEntries = 4;
            break;
        case 4:
            iNumEntries = 16;
            break;
        case 8:
            iNumEntries = 256;
            break;
        default:
            iNumEntries = 0;
            break;
        }

	for(i=0;i < iNumEntries;i++)
	{
	    pbmi->bmiColors[i].rgbRed = pe[i].peRed;
	    pbmi->bmiColors[i].rgbGreen = pe[i].peGreen;
	    pbmi->bmiColors[i].rgbBlue= pe[i].peBlue;
	}
    }

    return DD_OK;

} /* CDDSurface::MakeDibInfo */

/*
 * CDDSurface::MakeDIBSection()
 */
HRESULT CDDSurface::MakeDIBSection()
{
    DDSURFACEDESC	ddsd;
    DWORD		size;
    DWORD		bitcnt;
    LPBITMAPINFO	pbmi;

    /*
     * don't need to bother if the DirectDraw version isn't 3 or if it
     * isn't a system memory surface
     */
    #pragma message( REMIND( "Should we use a DIB unless the surface really is in video memory?" ))

    if( m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX5 || !(m_dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
 	return 1;
    }

    /*
     * so we need to make a dib section that is identical to this surface
     * first, get the surface desc
     */
    ddsd.dwSize = sizeof( ddsd );
    m_pDDSurface->GetSurfaceDesc( &ddsd );

    /*
     * allocate a pixel format structure
     */
    size = sizeof(BITMAPINFOHEADER);
    bitcnt = ddsd.ddpfPixelFormat.dwRGBBitCount;
    if( bitcnt <= 8)
    {
	size += (1<<bitcnt)*sizeof(RGBQUAD);
    }
    else
    {
	size += sizeof(DWORD)*3;
    }
    pbmi = (LPBITMAPINFO) LocalAlloc( LPTR, size );
    if( pbmi == NULL )
    {
	return DDERR_OUTOFMEMORY;
    }

    /*
     * flesh out the bitmap info header
     */
    MakeDibInfo( &ddsd, pbmi );

    /*
     * make the DIB section
     */
    m_hDCDib = CreateCompatibleDC(NULL);
    if( m_hDCDib != NULL )
    {
	m_hBMDib = CreateDIBSection(
		    m_hDCDib,	// the HDC
		    pbmi,		// bitmap info
		    DIB_RGB_COLORS,	// use color table in bitmap info
		    &m_pBitsDib,	// dib bits
		    NULL,		// no file handle
		    0 );		// offset into file (irrelevant)
        //free up our bitmap info struct
        LocalFree(pbmi);
	if( m_hBMDib == NULL )
	{
	    DeleteDC( m_hDCDib );
	    return DDERR_OUTOFMEMORY;
	}
	/*
	 * select our bitmap into our new DC
	 */
	m_hBMOld = (HBITMAP)SelectObject( m_hDCDib, (void *)m_hBMDib );
#ifdef DEBUG
        ASSERT(m_hBMOld != NULL);
#endif
    }
    else
    {
        //free up our local bitmap structure
        LocalFree(pbmi);
	return DDERR_OUTOFMEMORY;
    }

    return DD_OK;

} /* CDDSurface::MakeDIBSection */


HRESULT CDDSurface::SupportOwnDC()
{
    /*
     * if we want our own DC, then create one
     */
    HRESULT hr = DD_OK;
    if( m_bOwnDC )
    {
        HRESULT hrGotSurface, hrGotDC;
        IDirectDrawSurface *pTempSurface;
        HDC hdcTemp = NULL;

        /*
	 * Eat the cached HDC so owned DC surfaces won't use it.
	 */
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
	ddsd.ddsCaps.dwCaps = DDSCAPS_SYSTEMMEMORY;
	ddsd.dwHeight = ddsd.dwWidth = 1;
        hrGotSurface = m_pDirectDrawEx->m_DDInt.m_pRealInterface->CreateSurface(&ddsd, &pTempSurface, NULL);
        if( SUCCEEDED(hrGotSurface) )
	{
            hrGotDC = pTempSurface->GetDC(&hdcTemp);
        }

    	/*
	 * get the DC and then unlock the surface
	 * we know that GetDC does a Lock, so the Unlock will allow the
	 * DC to be used and Lock/Unlock to be used together...
	 */
	hr = m_pDDSurface->GetDC(&m_HDC);
	if( SUCCEEDED(hr) )
	{
	    m_pDDSurface->Unlock(NULL);
	}
	else
	{
	    m_bOwnDC = FALSE;	    // To prevent destructor from doing unlock trick
	    m_HDC = NULL;	    // Just to make sure...
	}
	/*
	 * clean up the extra surface/dc
	 */
        if( SUCCEEDED(hrGotSurface) )
	{
            if( SUCCEEDED(hrGotDC) )
	    {
                pTempSurface->ReleaseDC(hdcTemp);
            }
            pTempSurface->Release();
        }
    }
    return hr;
}//CDDSurface::SupportOwnDC


/*
 * CDDSurface::Init
 *
 * Initialize the surface
 */
HRESULT CDDSurface::Init()
{
    HRESULT hr = S_OK;

    hr = MakeDIBSection();
    if( FAILED( hr ) )
    {
	return hr;
    }

    /*
     * if we made the DIB section, then we need to tweak the internal
     * direct draw surface stucture (only allowed for direct draw 3)
     */
    if( hr == DD_OK )
    {
	LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;
	/*
	 * mark the surface memory as freed, and replace the memory with
	 * our dib section memory
	 */
	psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;


        DWORD   dwOffset;
        LPVOID  lpMem;

        lpMem= (LPVOID) psurf_int->lpLcl->lpGbl->fpVidMem;
        //probably don't need this check, but it can't hurt
        if( NULL != lpMem )
        {
            if (m_pDirectDrawEx->m_dwDDVer != WINNT_DX2 && m_pDirectDrawEx->m_dwDDVer != WINNT_DX3)
            {
                //check to see if this surface has been aligned and reset the pointer if so
                if(psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ||
                  psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE ||
                   psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
                {
                   dwOffset = *( (LPDWORD) ( ( (LPBYTE)lpMem ) - sizeof(DWORD) ) );
                   lpMem = (LPVOID) ( ( (LPBYTE) lpMem) - dwOffset );
                }
                //free the memory
                LocalFree(lpMem);
            }
            else
            {
                //store this value off so we can use it when we destroy the surface
                m_pSaveBits = (ULONG_PTR)lpMem;
                m_pSaveHDC = psurf_int->lpLcl->hDC;
                m_pSaveHBM = psurf_int->lpLcl->dwReserved1;
            }
        }
	psurf_int->lpLcl->lpGbl->fpVidMem = (ULONG_PTR) m_pBitsDib;
        return hr;
    }
    hr = SupportOwnDC();
    return hr;
} /* CDDSurface::Init */


void CDDSurface::CleanUpSurface()
{
    if( m_bOwnDC && m_HDC != NULL )
    {
	DDSURFACEDESC ddsd;
	ddsd.dwSize = sizeof(ddsd);
	m_pDDSurface->Lock(NULL, &ddsd, DDLOCK_WAIT, NULL);
    }	
    if( m_HDC != NULL )
    {
	m_pDDSurface->ReleaseDC(m_HDC);
    }
    if( m_hBMDib != NULL )
    {
	/* un-select our bitmap from the DC */
	SelectObject(m_hDCDib, m_hBMOld);
	DeleteObject( m_hBMDib );
    }
    if( m_hDCDib != NULL )
    {
	DeleteDC( m_hDCDib );
    }

    /*
     * clean up...
     */
    //if a palette is attached to this surface, detach it here
    if (m_pCurrentPalette != NULL)
        InternalSetPalette(NULL, 1);

    m_pDirectDrawEx->RemoveSurfaceFromList(this);
    if (m_pCurrentPalette)
        m_pCurrentPalette->RemoveSurfaceFromList(this);
    else if (m_bPrimaryPalette)
        m_pDirectDrawEx->RemoveSurfaceFromPrimaryList(this);
    //if we are running under NT4 Gold, we need to see if we modified the surface
    if ((m_pDirectDrawEx->m_dwDDVer == WINNT_DX2 || m_pDirectDrawEx->m_dwDDVer == WINNT_DX3) && m_pSaveBits != NULL)
    {
	LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;

	psurf_int->lpLcl->lpGbl->dwGlobalFlags &= ~(DDRAWISURFGBL_MEMFREE);
 	psurf_int->lpLcl->lpGbl->fpVidMem = (FLATPTR) m_pSaveBits;
        psurf_int->lpLcl->hDC = m_pSaveHDC;
        psurf_int->lpLcl->dwReserved1 = m_pSaveHBM;
    }

}

void CDDSurface::ReleaseRealInterfaces()
{
    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    m_pDDSurface2->Release();
    m_pDDSurface->Release();
    m_pDirectDrawEx->Release();

#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
    DllRelease();
}



void CDDSurface::AddSurfaceToDestroyList(CDDSurface * pSurface)
{
#ifdef DEBUG
    ASSERT(pSurface != NULL);
#endif

    ENTER_DDEX();
    if( m_pDestroyList )
    {
#ifdef DEBUG
        ASSERT(m_pDestroyList->m_pPrev == NULL);
#endif
	m_pDestroyList->m_pPrev = pSurface;
    }
    pSurface->m_pPrev = NULL;
    pSurface->m_pNext = m_pDestroyList;
    m_pDestroyList = pSurface;
    LEAVE_DDEX();
}

void CDDSurface::DeleteAttachment(IDirectDrawSurface * pOrigSurf, CDDSurface * pFirst)
{


    LPATTACHLIST lpAttach;
    IDirectDrawSurface * pSurface;
    CDDSurface * pSurfaceOuter;

    CleanUpSurface();
    //check for attached surface here
    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
    pSurface = m_pDDSurface;
    while (lpAttach != NULL && pSurface != NULL)
    {
        if (lpAttach->dwFlags & DDAL_IMPLICIT)
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                pSurfaceOuter->DeleteAttachment(pOrigSurf, pFirst);
                //and add this to our list to be deleted at the end
                pFirst->AddSurfaceToDestroyList(pSurfaceOuter);
            }
            else
                lpAttach = NULL;
        }
        else
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                //when the release of the surface is done, it will do a Release on the real interface
                //of this surface, so we need to AddRef the real interface, but Release our interface here
                pSurface->AddRef();
                pSurfaceOuter->Release();

            }
        }
    }
    //we need to do the same thing for the m_pDDAttach list if it still remains
    //all of these surface were not found in the code above.  They are explicitly attached surfaces
    //that were not create with the same ddrawex object that this surface was created with
    while (m_pAttach != NULL)
    {
        DDAttachSurface * pDelete;

        pDelete = m_pAttach;
        m_pAttach = m_pAttach->pNext;
        pDelete->pSurface->m_DDSInt.m_pRealInterface->AddRef();
        pDelete->pSurface->Release();
        delete pDelete;
    }

    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    HRESULT hr;
    hr = m_pDDSurface2->Release();
#ifdef DEBUG
    ASSERT(hr == 0);
#endif
    hr = m_pDDSurface->Release();
    m_pDirectDrawEx->Release();
    DllRelease();
}

/*
 * CDDSurface::~CDDSurface
*
 * Destructor
 */
CDDSurface::~CDDSurface()
{
    /*
     * if we have an OwnDC, then Lock the surface so ReleaseDC will work right...
     */

    LPATTACHLIST lpAttach;
    IDirectDrawSurface * pSurface;
    IDirectDrawSurface * pOrigSurf;
    CDDSurface * pSurfaceOuter;

    m_pDestroyList = NULL;
    CleanUpSurface();
    //check for attached surface here
    lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
    pOrigSurf = pSurface = m_pDDSurface;
    while (lpAttach != NULL && pSurface != NULL)
    {
        if (lpAttach->dwFlags & DDAL_IMPLICIT)
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL)
            {
                pSurfaceOuter->DeleteAttachment(pOrigSurf, this);
                AddSurfaceToDestroyList(pSurfaceOuter);
            }
            else
                lpAttach = NULL;
        }
        else
        {
            lpAttach = lpAttach->lpLink;
            if (((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList)) != NULL)
                pSurface =  (IDirectDrawSurface *)((LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(pSurface))->lpLcl->lpAttachList))->lpIAttached;
            else
                pSurface = NULL;
            //scan our list of surfaces for the outer surface here
            pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
            while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != pSurface)
                pSurfaceOuter = pSurfaceOuter->m_pNext;
            if (pSurface != pOrigSurf && pSurfaceOuter != NULL){
                //when the release of the surface is done, it will do a Release on the real interface
                //of this surface, so we need to AddRef the real interface, but Release our interface here
                pSurface->AddRef();
                pSurfaceOuter->Release();

            }
        }
    }
    //we need to do the same thing for the m_pDDAttach list if it still remains
    //all of these surface were not found in the code above.  They are explicitly attached surfaces
    //that were not create with the same ddrawex object that this surface was created with
    while (m_pAttach != NULL)
    {
        DDAttachSurface * pDelete;

        pDelete = m_pAttach;
        m_pAttach = m_pAttach->pNext;
        pDelete->pSurface->m_DDSInt.m_pRealInterface->AddRef();
        pDelete->pSurface->Release();
        delete pDelete;
    }

    if (m_pDDSurface4)
    {
        m_pDDSurface4->Release();
    }
    if( m_pDDSurface3 != NULL )
    {
   	m_pDDSurface3->Release();
    }
    HRESULT hr;

    hr = m_pDDSurface2->Release();
#ifdef DEBUG
    ASSERT(hr == 0);
#endif
    hr = m_pDDSurface->Release();
    //if we had implicit attached surface, we need to delete those here
    if (m_pDestroyList != NULL)
    {
        CDDSurface * pDelete;
        CDDSurface * pNext;
        pDelete = m_pDestroyList;
        while (pDelete != NULL)
        {
           pNext = pDelete->m_pNext;
#ifdef DEBUG
           DWORD * ptr;
           ptr = (DWORD *)pDelete;
           for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
                *ptr++ = 0xDEADBEEF;
#endif
           delete (void *)pDelete;
           pDelete = pNext;
        }
        m_pDestroyList = NULL;
    }
    m_pDirectDrawEx->Release();
#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDSurface) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
    DllRelease();

} /* CDDSurface::~CDDSurface */

/*
 * CDDSurface::CreateSimpleSurface
 *
 */
HRESULT CDDSurface::CreateSimpleSurface(
			LPDDSURFACEDESC pSurfaceDesc,
			IDirectDrawSurface *pDDSurface,
		        IDirectDrawSurface2 *pDDSurface2,
		        IDirectDrawSurface3 *pDDSurface3,
                        IDirectDrawSurface4 *pDDSurface4,
			IUnknown *pUnkOuter,
		        CDirectDrawEx *pDirectDrawEx,
			IDirectDrawSurface **ppNewDDSurf,
                        DWORD   dwFlags)
{
    HRESULT hr;
    CDDSurface *pSurface = new CDDSurface(pSurfaceDesc,
    					  pDDSurface,
					  pDDSurface2,
					  pDDSurface3,
                                          pDDSurface4,
					  pUnkOuter,
					  pDirectDrawEx);
    if( !pSurface)
    {
	return E_OUTOFMEMORY;
    }
    else
    {
        //If we are running DX5, we can turn of the m_bOwnDC if it is on
        if( pSurface->m_pDirectDrawEx->m_dwDDVer == WIN95_DX5 || pSurface->m_pDirectDrawEx->m_dwDDVer == WINNT_DX5)
        {
            pSurface->m_bOwnDC = FALSE;
            //if OWNDC is set, we need to store the DC around after a ReleasDC, check that here
            if (pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_OWNDC || ((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE))
                pSurface->m_bSaveDC = TRUE;
        }
        if ((pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
            !(pSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
        {
            //we do not want to do this if we are running under WindowsNT4.0 gold
            //but we have to because of palette problems, so call for anything. . .
            if (pSurface->m_bOwnDC)
                hr = pSurface->Init();
            else
                hr = DD_OK;
        }
        else
            hr = DD_OK;
	if( SUCCEEDED(hr) )
	{
            pSurface->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : IID_IDirectDrawSurface, (void **)ppNewDDSurf);
        }
        //if creating our own_dc/dib section failed, then this will release the surface
        pSurface->NonDelegatingRelease();
    }
    return hr;
} /* CDDSurface::CreateSimpleSurface */



/*
 * CDDSurface::InternalGetDC
 *
 * Simple surface GetDC implementation
 */
HRESULT CDDSurface::InternalGetDC(HDC *pHDC)
{
    //palette handling was removed because we now wrap the palette functions and handle
    //setting the DIB Color table when SetEntries or SetPallette is called.
    //this will speed up the GetDc call signifigantly: JGO
    HRESULT hr = DD_OK;

    if (pHDC == NULL)
        return DDERR_INVALIDPARAMS;

    if( m_hDCDib )
    {
	*pHDC = m_hDCDib;
    }
    else if( m_bOwnDC )
    {
	*pHDC = m_HDC;
    }
    else
    {
	hr = m_pDDSurface->GetDC(pHDC);
        if (SUCCEEDED(hr))
            m_HDC = *pHDC;
    }
#ifdef DEBUG
    if ( m_DebugCheckDC)
    {
        //should we get the same DC?  We should if OWNDC is set or DATAEXCHANGE is set
        if (m_dwCaps & DDSCAPS_OWNDC || (m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
            ASSERT((DWORD)*pHDC == m_DebugCheckDC);
    }
    m_DebugCheckDC = (DWORD)*pHDC;
#endif

    return hr;
} /* CDDSurface::InternalGetDC */

/*
 * CDDSurface::InternalReleaseDC
 *
 * Simple surface ReleaseDC implementation
 */
HRESULT CDDSurface::InternalReleaseDC(HDC hdc)
{

    HRESULT hr = DD_OK;

    /*
     * if we have a DIB section DC, do nothing
     */
    if( m_hDCDib != NULL )
    {
	if( hdc != m_hDCDib )
	{
	    hr = DDERR_INVALIDPARAMS;
	}
    }
    /*
     * if this is an OwnDC, do nothing
     */
    else if( m_bOwnDC )
    {
	if( hdc != m_HDC )
	{
	    hr = DDERR_INVALIDPARAMS;
	}
    }
    /*
     * allow ddraw to release the dc
     */
    else
    {
	hr = m_pDDSurface->ReleaseDC(hdc);
	if( SUCCEEDED(hr) )
	{
            if (!m_bSaveDC)
    	        m_HDC = NULL;
	}
    }
    return hr;

} /* CDDSurface::InternalReleaseDC */


/*
 * CDDSurface::InternalAddAttachedSurface
 *
 * Simple surface AddAttachedSurface implementation
 */
HRESULT CDDSurface::InternalFlip (LPDIRECTDRAWSURFACE lpDDS, DWORD dw, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        INTSTRUC_IDirectDrawSurface *lpIDDS;
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        if (lpIDDS == NULL)
            hr = m_pDDSurface->Flip(NULL, dw);
        else
            hr = m_pDDSurface->Flip(lpIDDS->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_2:
        INTSTRUC_IDirectDrawSurface2 *lpIDDS2;
        lpIDDS2 = ((INTSTRUC_IDirectDrawSurface2 *)(lpDDS));
        if (lpIDDS2 == NULL)
            hr = m_pDDSurface2->Flip(NULL, dw);
        else
            hr = m_pDDSurface2->Flip(lpIDDS2->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_3:
        INTSTRUC_IDirectDrawSurface3 *lpIDDS3;
        lpIDDS3 = ((INTSTRUC_IDirectDrawSurface3 *)(lpDDS));
        if (lpIDDS3 == NULL)
            hr = m_pDDSurface3->Flip(NULL, dw);
        else
            hr = m_pDDSurface3->Flip(lpIDDS3->m_pRealInterface, dw);
        break;
    case DDSURFACETYPE_4:
        INTSTRUC_IDirectDrawSurface4 *lpIDDS4;
        lpIDDS4 = ((INTSTRUC_IDirectDrawSurface4 *)(lpDDS));
        if (lpIDDS4 == NULL)
            hr = m_pDDSurface4->Flip(NULL, dw);
        else
            hr = m_pDDSurface4->Flip(lpIDDS4->m_pRealInterface, dw);
        break;
    }
    return hr;
}



HRESULT CDDSurface::InternalBlt (LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        INTSTRUC_IDirectDrawSurface *lpIDDS;
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        if (lpDDS != NULL)
           hr = m_pDDSurface->Blt(lpRect1, lpIDDS->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_2:
        INTSTRUC_IDirectDrawSurface2 *lpIDDS2;
        lpIDDS2 = ((INTSTRUC_IDirectDrawSurface2 *)(lpDDS));
        if (lpDDS != NULL)
           hr = m_pDDSurface2->Blt(lpRect1, lpIDDS2->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface2->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_3:
       INTSTRUC_IDirectDrawSurface3 *lpIDDS3;
       lpIDDS3 = ((INTSTRUC_IDirectDrawSurface3 *)(lpDDS));
       if (lpDDS != NULL)
           hr = m_pDDSurface3->Blt(lpRect1, lpIDDS3->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface3->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    case DDSURFACETYPE_4:
       INTSTRUC_IDirectDrawSurface4 *lpIDDS4;
       lpIDDS4 = ((INTSTRUC_IDirectDrawSurface4 *)(lpDDS));
       if (lpDDS != NULL)
           hr = m_pDDSurface4->Blt(lpRect1, lpIDDS4->m_pRealInterface, lpRect2,dw, lpfx);
        else
            hr = m_pDDSurface4->Blt(lpRect1, NULL, lpRect2,dw, lpfx);
        break;
    }
    return hr;
}



HRESULT CDDSurface::InternalAddAttachedSurface (LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType)
{
    HRESULT hr;
    INTSTRUC_IDirectDrawSurface *lpIDDS;
    CDDSurface * pSurface;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
    pSurface = lpIDDS->m_pSimpleSurface;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->AddAttachedSurface(pSurface->m_DDSInt.m_pRealInterface);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->AddAttachedSurface(pSurface->m_DDS2Int.m_pRealInterface);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->AddAttachedSurface(pSurface->m_DDS3Int.m_pRealInterface);
        break;
    case DDSURFACETYPE_4:
        hr = m_pDDSurface4->AddAttachedSurface(pSurface->m_DDS4Int.m_pRealInterface);
        break;
    }
    //if we succeeded we must do some fix up
    if (!FAILED( hr ) && lpDDS != NULL){
        //ddraw will addref the real interface
        //release that here, and addref our fake interface
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        lpIDDS->m_pRealInterface->Release();
        ((INTSTRUC_IDirectDrawSurface *)(lpDDS))->m_pSimpleSurface->AddRef();
        //we need to make sure that this surface is in the ddrawex context of this surface,
        //if it is not, then we need to add it to a list
        if (m_pDirectDrawEx != lpIDDS->m_pSimpleSurface->m_pDirectDrawEx)
        {
            //this attached surface is not in the ddrawex object of this one, so add it to the attachlist
            DDAttachSurface * pAttList = new DDAttachSurface;
            if (pAttList == NULL)
                return DDERR_OUTOFMEMORY;
            //add this to the list of attached surfaces
            pAttList->pNext = m_pAttach;
            pAttList->pSurface = lpIDDS->m_pSimpleSurface;
            m_pAttach = pAttList;
        }
    }
    return hr;
}


void CDDSurface::DeleteAttachNode(CDDSurface * Surface)
{

    DDAttachSurface *pDelete;
    DDAttachSurface * pList = m_pAttach;
    //special case first in the list
    //ASSERT this!!
    if (pList != NULL)
    {
        if (pList->pSurface == Surface)
        {
            m_pAttach = m_pAttach->pNext;
            delete pList;
        }
        else
        {
            while (pList->pNext != NULL && (pList->pNext->pSurface != Surface))
            {
                pList = pList->pNext;
            }
#ifdef DEBUG
            ASSERT(pList->pNext != NULL);
#endif
            if (pList->pNext != NULL)
            {
                pDelete = pList->pNext;
                pList->pNext = pList->pNext->pNext;
                delete pDelete;
            }
        }
    }
}

HRESULT CDDSurface::InternalDeleteAttachedSurface (DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS, DWORD dwSurfaceType)
{
    HRESULT hr;
    INTSTRUC_IDirectDrawSurface *lpIDDS;
    CDDSurface * pCallSurface;
    ULONG_PTR * pSaveSurfaces;
    DWORD dwCount;


    pSaveSurfaces = NULL;
    if (lpDDS)
    {
        //just one attachment, addref the surface before it is released if it is not an
        //implicit attached surface
        lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
        lpIDDS->m_pRealInterface->AddRef();
    }
    else
    {
        LPATTACHLIST lpAttach;
        IDirectDrawSurface * pOrigSurf;
        CDDSurface * pSurfaceOuter;
        //all attached surfaces are going to be released, addref them here
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
        pOrigSurf = m_pDDSurface;
        dwCount = 0;
        while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
        {
            if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
            {
                //we need to save these surfaces to be released later
                //so count how many we need in here
                dwCount++;
            }
            lpAttach = lpAttach->lpLink;
        }
        //we now need to save an array of surfaces to be Released if we succeed
        pSaveSurfaces = (ULONG_PTR *)LocalAlloc(LPTR, dwCount*sizeof(ULONG_PTR));
        if (pSaveSurfaces == NULL)
            return DDERR_OUTOFMEMORY;
        //now run the list again, call AddRef on the real interface, so that
        //the release called by ddraw will not affect anything
        //and save off the outer interfaces in our allocated array
        lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
        pOrigSurf = m_pDDSurface;
        dwCount = 0;
        while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
        {
            if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
            {
                //we must addref the surface pointed to here
                ((IDirectDrawSurface *)(lpAttach->lpIAttached))->AddRef();
                pSurfaceOuter = m_pDirectDrawEx->m_pFirstSurface;
                while (pSurfaceOuter != NULL && pSurfaceOuter->m_DDSInt.m_pRealInterface != (IDirectDrawSurface *)(lpAttach->lpIAttached))
                    pSurfaceOuter = pSurfaceOuter->m_pNext;
                if (pSurfaceOuter != NULL)
                    pSaveSurfaces[dwCount++]= ((ULONG_PTR)(pSurfaceOuter));
            }
            lpAttach = lpAttach->lpLink;
        }
        //do the same addref for surfaces not in this ddrawex object
        DDAttachSurface * pList = m_pAttach;
        while (pList != NULL)
        {
            pList->pSurface->m_DDSInt.m_pRealInterface->AddRef();
            pList = pList->pNext;
        }
    }
    lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
    if (lpIDDS != NULL)
        pCallSurface = lpIDDS->m_pSimpleSurface;
    else
        pCallSurface = NULL;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        if (pCallSurface != NULL)
            hr = m_pDDSurface->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDSInt.m_pRealInterface);
        else
            hr = m_pDDSurface->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_2:
        if (pCallSurface != NULL)
            hr = m_pDDSurface2->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS2Int.m_pRealInterface);
        else
            hr = m_pDDSurface2->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_3:
        if (pCallSurface != NULL)
            hr = m_pDDSurface3->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS3Int.m_pRealInterface);
        else
            hr = m_pDDSurface3->DeleteAttachedSurface(dwFlags, NULL);
        break;
    case DDSURFACETYPE_4:
        if (pCallSurface != NULL)
            hr = m_pDDSurface4->DeleteAttachedSurface(dwFlags, pCallSurface->m_DDS4Int.m_pRealInterface);
        else
            hr = m_pDDSurface4->DeleteAttachedSurface(dwFlags, NULL);
        break;
    }
    //if we succeeded we must do some fix up
    if (SUCCEEDED( hr ))
    {
        if (lpDDS)
        {
            //just one attachment, release the outer surface here
            //if this is not in the same ddrawex object, then delete it from the list
            if (m_pDirectDrawEx != lpIDDS->m_pSimpleSurface->m_pDirectDrawEx)
            {
                DeleteAttachNode(lpIDDS->m_pSimpleSurface);
            }
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
            lpIDDS->m_pSimpleSurface->Release();

        }
        else
        {
            CDDSurface * pSurface;
            for ( DWORD i = 0; i < dwCount; i++)
            {
                pSurface = (CDDSurface *)(pSaveSurfaces[i]);
                pSurface->Release();
            }
            //do the same for any surfaces attached, not in this ddrawex object
            DDAttachSurface * pList = m_pAttach;
            while (m_pAttach != NULL)
            {
                pList = m_pAttach;
                m_pAttach = m_pAttach->pNext;
                pList->pSurface->Release();
                delete pList;
            }

        }
    }
    else
    {
        if (lpDDS)
        {
            //just one attachment, addref the surface before it is released if it is not an
            //implicit attached surface
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(lpDDS));
            lpIDDS->m_pRealInterface->Release();
        }
        else
        {
            LPATTACHLIST lpAttach;
            IDirectDrawSurface * pOrigSurf;

            //all attached surfaces are going to be released, addref them here
            lpAttach = (LPATTACHLIST)(((LPDDRAWI_DDRAWSURFACE_INT)(m_pDDSurface))->lpLcl->lpAttachList);
            pOrigSurf = m_pDDSurface;
            while (lpAttach != NULL && (IDirectDrawSurface *)(lpAttach->lpIAttached) != pOrigSurf)
            {
                if (!(lpAttach->dwFlags & DDAL_IMPLICIT))
                {
                    //we must release the surface pointed to here that we addref'ed above
                    ((IDirectDrawSurface *)(lpAttach->lpIAttached))->Release();
                }
                lpAttach = lpAttach->lpLink;
            }
            //do the same for any surfaces attached, not in this ddrawex object
            DDAttachSurface * pList = m_pAttach;
            while (pList != NULL)
            {
                pList->pSurface->m_DDSInt.m_pRealInterface->Release();
                pList = pList->pNext;
            }
        }
    }
    if (pSaveSurfaces != NULL)
        LocalFree(pSaveSurfaces);
    return hr;
}




/*
 * CDDSurface::InternalGetAttachedSurface
 *
 * Simple surface GetAttachedSurface implementation
 */
HRESULT CDDSurface::InternalGetAttachedSurface(LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS, DWORD dwSurfaceType)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawSurface* lpIDDS;
    DDSCAPS ddsCaps;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    ddsCaps = *lpDDSCaps;
    //mask off owndc
    ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
    if ((ddsCaps.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
        ddsCaps.dwCaps &= ~DDSCAPS_DATAEXCHANGE;
    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->GetAttachedSurface(&ddsCaps, lpDDS);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetAttachedSurface(&ddsCaps, (LPDIRECTDRAWSURFACE2 *)lpDDS);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetAttachedSurface(&ddsCaps, (LPDIRECTDRAWSURFACE3 *)lpDDS);
        break;
        // Case 4 taken care of below...
    }    //make the call to the actual DDraw function
    //if we succeeded we must do some fix up
    CDDSurface * lpSurfaceList;
    if (!FAILED( hr ) && lpDDS != NULL)
    {
         //we need to scan our list to pass back our interface
        lpSurfaceList = m_pDirectDrawEx->m_pFirstSurface;
        switch (dwSurfaceType)
        {
        case DDSURFACETYPE_1:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDSInt.m_pRealInterface != *lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDSInt.m_pRealInterface != *lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }
            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDSInt);
            break;
        case DDSURFACETYPE_2:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDS2Int.m_pRealInterface != (LPDIRECTDRAWSURFACE2)*lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDS2Int.m_pRealInterface != (LPDIRECTDRAWSURFACE2)*lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }

            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS2Int);
            break;
        case DDSURFACETYPE_3:
            while (lpSurfaceList != NULL && lpSurfaceList->m_DDS3Int.m_pRealInterface != (LPDIRECTDRAWSURFACE3)*lpDDS)
                lpSurfaceList = lpSurfaceList->m_pNext;
            if (lpSurfaceList == NULL)
            {
                //check our AttachList
                DDAttachSurface * pList = m_pAttach;
                while (pList != NULL && pList->pSurface->m_DDS3Int.m_pRealInterface != (LPDIRECTDRAWSURFACE3)*lpDDS)
                {
                   pList = pList->pNext;
                }
                if (pList != NULL)
                    lpSurfaceList = pList->pSurface;
            }

            if (lpSurfaceList != NULL)
                *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS3Int);
            break;
            // Case 4 taken care of below...
        }
        //ddraw will addref the obtained surface's real interface
        //release that here and addref our fake interface
        if (lpSurfaceList != NULL)
        {
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(*lpDDS));
            lpIDDS->m_pRealInterface->Release();
            ((INTSTRUC_IDirectDrawSurface *)(*lpDDS))->m_pSimpleSurface->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetAttachedSurface4(LPDDSCAPS2 lpDDSCaps2, LPDIRECTDRAWSURFACE FAR * lpDDS)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawSurface* lpIDDS;
    DDSCAPS2 ddsCaps2;

    if (lpDDS == NULL)
        return DDERR_INVALIDPARAMS;

    ddsCaps2 = *lpDDSCaps2;
    //mask off owndc
    ddsCaps2.dwCaps &= ~DDSCAPS_OWNDC;
    if ((ddsCaps2.dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE)
        ddsCaps2.dwCaps &= ~DDSCAPS_DATAEXCHANGE;
    hr = m_pDDSurface4->GetAttachedSurface(&ddsCaps2, (LPDIRECTDRAWSURFACE4 *)lpDDS);

    //if we succeeded we must do some fix up
    CDDSurface * lpSurfaceList;
    if (!FAILED( hr ) && lpDDS != NULL)
    {
         //we need to scan our list to pass back our interface
        lpSurfaceList = m_pDirectDrawEx->m_pFirstSurface;
        while (lpSurfaceList != NULL && lpSurfaceList->m_DDS4Int.m_pRealInterface != (LPDIRECTDRAWSURFACE4)*lpDDS)
            lpSurfaceList = lpSurfaceList->m_pNext;
        if (lpSurfaceList == NULL)
        {
            //check our AttachList
            DDAttachSurface * pList = m_pAttach;
            while (pList != NULL && pList->pSurface->m_DDS4Int.m_pRealInterface != (LPDIRECTDRAWSURFACE4)*lpDDS)
            {
               pList = pList->pNext;
            }
            if (pList != NULL)
                lpSurfaceList = pList->pSurface;
        }

        //ddraw will addref the obtained surface's real interface
        //release that here and addref our fake interface
        if (lpSurfaceList != NULL)
        {
            *lpDDS = (IDirectDrawSurface *)(&lpSurfaceList->m_DDS4Int);
            lpIDDS = ((INTSTRUC_IDirectDrawSurface *)(*lpDDS));
            lpIDDS->m_pRealInterface->Release();
            ((INTSTRUC_IDirectDrawSurface *)(*lpDDS))->m_pSimpleSurface->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetPalette(LPDIRECTDRAWPALETTE FAR * ppPal, DWORD dwSurfaceType)
{
    HRESULT hr;

    if (ppPal == NULL)
        return DDERR_INVALIDPARAMS;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        hr = m_pDDSurface->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetPalette(ppPal);
        break;
    case DDSURFACETYPE_4:
        hr = m_pDDSurface4->GetPalette(ppPal);
        break;
    }
    //if this succeeded, we need to return OUR interface to the palette, so scan our
    //list and return the correct palette.
    if (SUCCEEDED(hr))
    {
        INTSTRUC_IDirectDrawPalette* pIDDP;

         //we need to scan our list to pass back our interface
        CDDPalette * lpPaletteList;
        lpPaletteList = m_pDirectDrawEx->m_pFirstPalette;
        while (lpPaletteList != NULL && lpPaletteList->m_DDPInt.m_pRealInterface != *ppPal)
            lpPaletteList = lpPaletteList->m_pNext;
        if (lpPaletteList == NULL)
        {
            //this is a palette possibly, that is not in the same ddraw object as the surface
            // handle that here
            // TODO in the future, this code should be the default!

            //the returned palette should equal the real interface of the m_pCurrentPalette
#ifdef DEBUG
            ASSERT(m_pCurrentPalette != NULL);
            ASSERT(m_pCurrentPalette->m_DDPInt.m_pRealInterface == *ppPal);
#endif
            lpPaletteList = m_pCurrentPalette;
        }

        if (lpPaletteList != NULL)
        {
            *ppPal = (IDirectDrawPalette *)(&lpPaletteList->m_DDPInt);
            pIDDP = ((INTSTRUC_IDirectDrawPalette *)(*ppPal));
            pIDDP->m_pRealInterface->Release();
            pIDDP->m_pSimplePalette->AddRef();
        }
    }
    return hr;
}


HRESULT CDDSurface::InternalGetSurfaceDesc(LPDDSURFACEDESC pDesc, DWORD dwSurfaceType)
{
    HRESULT hr;

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        hr = m_pDDSurface->GetSurfaceDesc(pDesc);
        break;
    case DDSURFACETYPE_2:
        hr = m_pDDSurface2->GetSurfaceDesc(pDesc);
        break;
    case DDSURFACETYPE_3:
        hr = m_pDDSurface3->GetSurfaceDesc(pDesc);
        break;
        // Case 4 handled below...
    }
    if (FAILED(hr))
        return hr;
    //if m_bOwnDC is set, we need to set this in the caps field
    if (m_dwCaps & DDSCAPS_OWNDC)
        //set the caps bit here
        pDesc->ddsCaps.dwCaps |= DDSCAPS_OWNDC;
    //see if data exchange was origianlly on
    if ((m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        pDesc->ddsCaps.dwCaps |= DDSCAPS_DATAEXCHANGE;
        //see if OWNDC was really on
        if (!(m_dwCaps & DDSCAPS_OWNDC))
            //turn it off here
            pDesc->ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
        //see if offscreen plain was originally on
        if (m_dwCaps & DDSCAPS_OFFSCREENPLAIN)
            pDesc->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        //we might have turned on texture, turn it off if so
        if (!(m_dwCaps & DDSCAPS_TEXTURE))
            pDesc->ddsCaps.dwCaps &= ~DDSCAPS_TEXTURE;
    }


    return hr;
}


HRESULT CDDSurface::InternalGetSurfaceDesc4(LPDDSURFACEDESC2 pDesc2)
{
    HRESULT hr;

    hr = m_pDDSurface4->GetSurfaceDesc(pDesc2);
    if (FAILED(hr))
        return hr;
    //if m_bOwnDC is set, we need to set this in the caps field
    if (m_dwCaps & DDSCAPS_OWNDC)
        //set the caps bit here
        pDesc2->ddsCaps.dwCaps |= DDSCAPS_OWNDC;
    //see if data exchange was origianlly on
    if ((m_dwCaps & DDSCAPS_DATAEXCHANGE) == DDSCAPS_DATAEXCHANGE )
    {
        pDesc2->ddsCaps.dwCaps |= DDSCAPS_DATAEXCHANGE;
        //see if OWNDC was really on
        if (!(m_dwCaps & DDSCAPS_OWNDC))
            //turn it off here
            pDesc2->ddsCaps.dwCaps &= ~DDSCAPS_OWNDC;
        //see if offscreen plain was originally on
        if (m_dwCaps & DDSCAPS_OFFSCREENPLAIN)
            pDesc2->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        //we might have turned on texture, turn it off if so
        if (!(m_dwCaps & DDSCAPS_TEXTURE))
            pDesc2->ddsCaps.dwCaps &= ~DDSCAPS_TEXTURE;
    }


    return hr;
}


HRESULT CDDSurface::InternalSetPalette(LPDIRECTDRAWPALETTE pPal, DWORD dwSurfaceType)
{

    HRESULT hr;
    INTSTRUC_IDirectDrawPalette* pIDDP;


    pIDDP = ((INTSTRUC_IDirectDrawPalette *)(pPal));

    //a bit of ugliness herein regards to reference counting.  If this palette is
    //different from the current palette, then it will release the current palette.
    //we must protect for that before we call setpalette
    if (m_pCurrentPalette && (pPal == NULL || m_pCurrentPalette != pIDDP->m_pSimplePalette))
    {
        m_pCurrentPalette->m_DDPInt.m_pRealInterface->AddRef();
    }

    switch (dwSurfaceType)
    {
    case DDSURFACETYPE_1:
        //make the call to the actual DDraw function
        if (pPal != NULL)
            hr = m_pDDSurface->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface->SetPalette(NULL);
        break;
    case DDSURFACETYPE_2:
        if (pPal != NULL)
            hr = m_pDDSurface2->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface2->SetPalette(NULL);
        break;
    case DDSURFACETYPE_3:
        if (pPal != NULL)
            hr = m_pDDSurface3->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface3->SetPalette(NULL);
        break;
    case DDSURFACETYPE_4:
        if (pPal != NULL)
            hr = m_pDDSurface4->SetPalette(pIDDP->m_pRealInterface);
        else
            hr = m_pDDSurface4->SetPalette(NULL);
        break;
    }
    if (SUCCEEDED(hr))
    {
        //we must take care of reference counting here
        //if there was an old palette not equal to the current, then do a release on the old palette
        if (m_pCurrentPalette && (pPal == NULL || m_pCurrentPalette != pIDDP->m_pSimplePalette))
        {
            //release the old palette
            m_pCurrentPalette->Release();
            //if this release caused the palette to be destroyed, the palette destructor function
            //will change m_pCurrentPalette to NULL.  No worries below.
        }
        //if the new palette is NULL, we can return here
        if (pPal == NULL)
        {
            if (m_pCurrentPalette)
            {
                m_pCurrentPalette->RemoveSurfaceFromList(this);
                m_pCurrentPalette = NULL;
            }
            return hr;
        }
        //if the new palette is not equal to the old palette, then an addref was done on the
        //real interface, as above
        if (m_pCurrentPalette != pIDDP->m_pSimplePalette)
        {
            pIDDP->m_pRealInterface->Release();
            pIDDP->m_pSimplePalette->AddRef();
        }


        DWORD dwNumEntries;
        DWORD dwCaps;
        PALETTEENTRY    pe[256];
        hr = pIDDP->m_pRealInterface->GetCaps(&dwCaps);
        if (FAILED(hr))
            return hr;
        if (dwCaps & DDPCAPS_1BIT)
            dwNumEntries = 1;
        else if (dwCaps & DDPCAPS_2BIT)
            dwNumEntries = 4;
        else if (dwCaps & DDPCAPS_4BIT)
            dwNumEntries = 16;
        else if (dwCaps & DDPCAPS_8BIT)
            dwNumEntries = 256;
        else
            dwNumEntries = 0;
        hr = pIDDP->m_pRealInterface->GetEntries( 0, 0, dwNumEntries, pe);
        if (FAILED(hr))
            return hr;
        if (m_bIsPrimary)
        {
            CDDSurface *pSurface = m_pDirectDrawEx->m_pPrimaryPaletteList;
            while (pSurface != NULL)
            {
                //update the DIB COlor Table here
                pIDDP->m_pSimplePalette->SetColorTable(pSurface, pe, dwNumEntries, 0);
                pSurface = pSurface->m_pNextPalette;
            }
            //and mark this palette as being the primary
            pIDDP->m_pSimplePalette->m_bIsPrimary = TRUE;
            m_pCurrentPalette = pIDDP->m_pSimplePalette;
        }
        else
        {

            //if this surface already has a palette attached to it, then we need to remove it
            if (m_pCurrentPalette && m_pCurrentPalette != pIDDP->m_pSimplePalette)
                m_pCurrentPalette->RemoveSurfaceFromList(this);
            else if (m_bPrimaryPalette)
                //this surface will be in the list of surfaces which feed of the primary surface
                //remove it from that list
                m_pDirectDrawEx->RemoveSurfaceFromPrimaryList(this);

            //now add this surface to the palette list if already is not in the list
            if (m_pCurrentPalette != pIDDP->m_pSimplePalette)
                pIDDP->m_pSimplePalette->AddSurfaceToList(this);
            //and update this surface's DIB ColorTable
            pIDDP->m_pSimplePalette->SetColorTable(this, pe, dwNumEntries, 0);
            pIDDP->m_pSimplePalette->m_bIsPrimary = FALSE;
            m_pCurrentPalette = pIDDP->m_pSimplePalette;
        }
    }
    return hr;
}


#pragma message( REMIND( "What Lock of a rect bug in DirectDraw v3 is Ralph referring to?" ))

/*
 * CDDSurface::InternalLock
 *
 * Simple surface Lock implementation
 */
HRESULT CDDSurface::InternalLock(LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{

    return m_pDDSurface->Lock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);

} /* CDDSurface::InternalLock */

/*
 * CDDSurface::InternalUnlock
 *
 * Simple surface Unlock implementation
 */
HRESULT CDDSurface::InternalUnlock(LPVOID lpSurfaceData)
{
    return m_pDDSurface->Unlock(lpSurfaceData);

} /* CDDSurface::InternalUnlock */

#define DEFINEPF(flags, fourcc, bpp, rMask, gMask, bMask, aMask) \
    { sizeof(DDPIXELFORMAT), (flags), (fourcc), (bpp), (rMask), (gMask), (bMask), (aMask) }

static DDPIXELFORMAT ddpfSupportedTexPFs[] =
{
/*           Type                              FOURCC BPP   Red Mask      Green Mask    Blue Mask     Alpha Mask                   */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1,  0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2,  0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4,  0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4 |
             DDPF_PALETTEINDEXEDTO8,           0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED8,  0UL,    8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB,                         0UL,    8UL, 0x000000E0UL, 0x0000001CUL, 0x00000003UL, 0x00000000UL), /*  332 (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   16UL, 0x00000F00UL, 0x000000F0UL, 0x0000000FUL, 0x0000F000UL), /* 4444 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000F800UL, 0x000007E0UL, 0x0000001FUL, 0x00000000UL), /*  565 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000001FUL, 0x000007E0UL, 0x0000F800UL, 0x00000000UL), /*  565 (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00000000UL), /*  555 (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00008000UL), /* 1555 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /*  FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /*  FFF (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /* 0FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /* 0FFF (BGR) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0xFF000000UL), /* FFFF (RGB) */
    DEFINEPF(DDPF_RGB | DDPF_ALPHAPIXELS,      0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0xFF000000UL)  /* FFFF (BGR) */
};
#define NUM_SUPPORTED_TEX_PFS (sizeof(ddpfSupportedTexPFs) / sizeof(ddpfSupportedTexPFs[0]))

static DDPIXELFORMAT ddpfSupportedOffScrnPFs[] =
{
/*           Type                              FOURCC BPP   Red Mask      Green Mask    Blue Mask     Alpha Mask                   */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED1,  0UL,    1UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED2,  0UL,    2UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED4,  0UL,    4UL, 0x00000000UL, 0x00000000Ul, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB | DDPF_PALETTEINDEXED8,  0UL,    8UL, 0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000000UL), /* Pal.       */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x0000F800UL, 0x000007E0UL, 0x0000001FUL, 0x00000000UL), /*  565 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   16UL, 0x00007C00UL, 0x000003E0UL, 0x0000001FUL, 0x00000000UL), /*  555 (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /*  FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   24UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /*  FFF (BGR) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x00FF0000UL, 0x0000FF00UL, 0x000000FFUL, 0x00000000UL), /* 0FFF (RGB) */
    DEFINEPF(DDPF_RGB,                         0UL,   32UL, 0x000000FFUL, 0x0000FF00UL, 0x00FF0000UL, 0x00000000UL), /* 0FFF (BGR) */
};
#define NUM_SUPPORTED_OFFSCRN_PFS (sizeof(ddpfSupportedOffScrnPFs) / sizeof(ddpfSupportedOffScrnPFs[0]))

/*
 * doPixelFormatsMatch
 */
BOOL doPixelFormatsMatch(LPDDPIXELFORMAT lpddpf1, LPDDPIXELFORMAT lpddpf2)
{

    if( lpddpf1->dwFlags != lpddpf2->dwFlags )
    {
        return FALSE;
    }

    if( lpddpf1->dwFlags & DDPF_RGB )
    {
    	if( lpddpf1->dwRGBBitCount != lpddpf2->dwRGBBitCount )
	{
            return FALSE;
	}
    	if( lpddpf1->dwRBitMask != lpddpf2->dwRBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwGBitMask != lpddpf2->dwGBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwBBitMask != lpddpf2->dwBBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwFlags & DDPF_ALPHAPIXELS )
    	{
    	    if( lpddpf1->dwRGBAlphaBitMask != lpddpf2->dwRGBAlphaBitMask )
	    {
	    	return FALSE;
	    }
    	}
    }
    else if( lpddpf1->dwFlags & DDPF_YUV )
    {
        /*
         * (CMcC) Yes, I know that all these fields are in a
         * union with the RGB ones so I could just use the same
         * bit of checking code but just in case someone messes
         * with DDPIXELFORMAT I'm going to do this explicitly.
         */
        if( lpddpf1->dwFourCC != lpddpf2->dwFourCC )
	{
            return FALSE;
	}
    	if( lpddpf1->dwYUVBitCount != lpddpf2->dwYUVBitCount )
	{
            return FALSE;
	}
    	if( lpddpf1->dwYBitMask != lpddpf2->dwYBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwUBitMask != lpddpf2->dwUBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwVBitMask != lpddpf2->dwVBitMask )
	{
	    return FALSE;
	}
    	if( lpddpf1->dwFlags & DDPF_ALPHAPIXELS )
    	{
    	    if( lpddpf1->dwYUVAlphaBitMask != lpddpf2->dwYUVAlphaBitMask )
	    {
	    	return FALSE;
	    }
    	}
    }
    return TRUE;

} /* doPixelFormatsMatch */

/*
 * isSupportedPixelFormat
 */
BOOL isSupportedPixelFormat(LPDDPIXELFORMAT lpddpf,
			    LPDDPIXELFORMAT lpddpfTable,
			    int             cNumEntries)
{
    int 		n;
    LPDDPIXELFORMAT	lpddCandidatePF;

    n = cNumEntries;
    lpddCandidatePF = lpddpfTable;
    while( n > 0 )
    {
    	if( doPixelFormatsMatch(lpddpf, lpddCandidatePF) )
	{
	    return TRUE;
	}
	lpddCandidatePF++;
	n--;
    }
    return FALSE;

} /* isSupportedPixelFormat */

/*
 * checkPixelFormat
 *    bitdepth != screen bitdepth
 */
HRESULT checkPixelFormat( DWORD dwscaps, LPDDPIXELFORMAT lpDDPixelFormat )
{

    if( dwscaps & DDSCAPS_TEXTURE )
    {
	if( !isSupportedPixelFormat(lpDDPixelFormat, ddpfSupportedTexPFs, NUM_SUPPORTED_TEX_PFS) )
	{
            return DDERR_INVALIDPIXELFORMAT;
	}
    }
    else if( dwscaps & DDSCAPS_OFFSCREENPLAIN )
    {
	if( !isSupportedPixelFormat(lpDDPixelFormat, ddpfSupportedOffScrnPFs, NUM_SUPPORTED_OFFSCRN_PFS) )
	{

            return DDERR_INVALIDPIXELFORMAT;
	}
    }
    return DD_OK;

} /* checkPixelFormat */

/*
 * CDDSurface::InternalSetSurfaceDesc
 *
 * Simple surface change the bits
 */
HRESULT CDDSurface::InternalSetSurfaceDesc(
		    LPDDSURFACEDESC pddsd,
		    DWORD dwFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	psurf_gbl;
    DWORD			sdflags;

    if( dwFlags )
    {
	return DDERR_INVALIDPARAMS;
    }

    //do not work on DDraw2 on WindowsNT4.0Gold
    if (m_pDirectDrawEx->m_dwDDVer == WINNT_DX2)
    {
        return DDERR_UNSUPPORTED;
    }

    psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) m_pDDSurface;
    psurf_lcl = psurf_int->lpLcl;
    psurf_gbl = psurf_lcl->lpGbl;

    sdflags = pddsd->dwFlags;

    /*
     * don't allow anything but bits, height, width, pitch, and pixel format
     * to change
     */
    if( !(sdflags & (DDSD_LPSURFACE | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_PITCH )) )
    {
	return DDERR_INVALIDPARAMS;
    }

    /*
     * don't work if it wasn't put in sysmem in the first place...
     */
    if( !(psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED ) )
    {
	return DDERR_UNSUPPORTED;
    }

    /*
     * gotta have a pixel format to work...
     */
    if( !(psurf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    	 (sdflags & DDSD_PIXELFORMAT) )
    {
	return DDERR_INVALIDSURFACETYPE;
    }

    /*
     * verify the new pixel format...
     */
    if( sdflags & DDSD_PIXELFORMAT )
    {
	DWORD	dwscaps;
	HRESULT	hr;

	/*
	 * only allow changes for textures and offscreen plain...
	 */
	dwscaps = psurf_lcl->ddsCaps.dwCaps;
	if( !(dwscaps & (DDSCAPS_TEXTURE|DDSCAPS_OFFSCREENPLAIN)) )
	{
	    return DDERR_INVALIDSURFACETYPE;
	}

	hr = checkPixelFormat( dwscaps, &pddsd->ddpfPixelFormat );
	if( FAILED( hr ) )
	{
	    return hr;
	}
    }

    /*
     * replace bits ptr...
     */
    if( sdflags & DDSD_LPSURFACE )
    {
	/*
	 * mark the surface memory as freed, and replace the memory with
	 * new user specified memory
	 */
	if( !(psurf_gbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE ) )
	{

	    DWORD   dwOffset;
	    LPVOID  lpMem;

	    lpMem= (LPVOID) psurf_int->lpLcl->lpGbl->fpVidMem;
	    //probably don't need this check, but it can't hurt
	    if( NULL != lpMem )
	    {
                if (m_pDirectDrawEx->m_dwDDVer != WINNT_DX3)
                {
                    //check to see if this surface has been aligned and reset the pointer if so
                    if(psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER ||
                      psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE ||
                       psurf_int->lpLcl->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
                    {
                       dwOffset = *( (LPDWORD) ( ( (LPBYTE)lpMem ) - sizeof(DWORD) ) );
                       lpMem = (LPVOID) ( ( (LPBYTE) lpMem) - dwOffset );
                    }
                    //free the memory
                    LocalFree(lpMem);
                }
                else
                {
                    //store this value off so we can use it when we destroy the surface
                    m_pSaveBits = (ULONG_PTR)lpMem;
                    m_pSaveHDC = psurf_int->lpLcl->hDC;
                    m_pSaveHBM = psurf_int->lpLcl->dwReserved1;
                }
            }
            psurf_gbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
	}
	psurf_gbl->fpVidMem = (ULONG_PTR) pddsd->lpSurface;
    }

    /*
     * replace other things
     */
    if( sdflags & DDSD_PITCH )
    {
	psurf_gbl->lPitch = pddsd->lPitch;
    }
    if( sdflags & DDSD_WIDTH )
    {
	psurf_gbl->wWidth = (WORD) pddsd->dwWidth;
    }
    if( sdflags & DDSD_HEIGHT )
    {
	psurf_gbl->wHeight = (WORD) pddsd->dwHeight;
    }
    if( sdflags & DDSD_PIXELFORMAT )
    {
	psurf_gbl->ddpfSurface = pddsd->ddpfPixelFormat;
    }
    return DD_OK;

} /* CDDSurface::InternalSetBites */


HRESULT CDDSurface::InternalGetDDInterface(LPVOID FAR *ppInt)
{
    //this is a simple function, simply addref on the m_pDirectDrawEx and return it's simple interface
    return m_pDirectDrawEx->QueryInterface(IID_IDirectDraw, ppInt);
}


/*
 * CDDSurface::QueryInterface
 *                AddRef
 *                Release
 *
 * The standard IUnknown that delegates...
 */
STDMETHODIMP CDDSurface::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDDSurface::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDDSurface::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */

/*
 * NonDelegating IUnknown for simple surface follows...
 */

STDMETHODIMP CDDSurface::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    if (ppv == NULL)
        return E_POINTER;
    *ppv=NULL;

    if( IID_IUnknown==riid )
    {
        *ppv=(INonDelegatingUnknown *)this;
    }
    else if( IID_IDirectDrawSurface==riid )
    {
	*ppv=&m_DDSInt;
    }
    else if( IID_IDirectDrawSurface2==riid )
    {
	*ppv=&m_DDS2Int;
    }
    else if( IID_IDirectDrawSurface3==riid )
    {
	*ppv=&m_DDS3Int;
    }
    else if (IID_IDirectDrawSurface4==riid )
    {
	if (m_DDS4Int.lpVtbl)
	{
            *ppv=&m_DDS4Int;
	}
	else
	{
	    return (E_NOINTERFACE);
	}
    }
    else if (IID_IDirect3DRampDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceRAMPInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceRAMPInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if (IID_IDirect3DRGBDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceRGBInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceRGBInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if (IID_IDirect3DChrmDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceChrmInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceChrmInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;

    }
    else if(IID_IDirect3DHALDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceHALInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceHALInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;
    }
    else if(IID_IDirect3DMMXDevice == riid)
    {
//#ifdef DBG
//        hr = DDERR_LEGACYUSAGE;
//#else
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DDeviceMMXInt);
        if( SUCCEEDED(hr) )
        {
            *ppv=m_D3DDeviceMMXInt;
        }
        else
            *ppv = NULL;
//#endif
        return hr;
    }
    else if (IID_IDirect3DTexture == riid)
    {
        HRESULT (__stdcall *lpFunc)(IDirectDrawVtbl **,REFIID, void **);

        *(DWORD *)(&lpFunc) = *(DWORD *)*(DWORD **)m_pDDSurface;
        hr = lpFunc(&(m_DDSInt.lpVtbl), riid, (void **)&m_D3DTextureInt);
        if( SUCCEEDED(hr) )
        {
     	    *ppv=m_D3DTextureInt;
        }
        else
            *ppv = NULL;
        return hr;

    }
    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CDDSurface::NonDelegatingAddRef()
{
    m_pDDSurface->AddRef();
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDDSurface::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount) {
        m_pDDSurface->Release();
        return lRefCount;
    }
    delete this;
    return 0;
}

/*
 * Quick inline fns to get at our internal data...
 */
_inline CDDSurface * SURFACEOF(IDirectDrawSurface * pDDS)
{
    return ((INTSTRUC_IDirectDrawSurface *)pDDS)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface2 * pDDS2)
{
    return ((INTSTRUC_IDirectDrawSurface2 *)pDDS2)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface3 * pDDS3)
{
    return ((INTSTRUC_IDirectDrawSurface3 *)pDDS3)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface4 * pDDS4)
{
    return ((INTSTRUC_IDirectDrawSurface4 *)pDDS4)->m_pSimpleSurface;
}


/*
 * the implementation of the functions in IDirectDrawSurface that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggAddRef(IDirectDrawSurface *pDDS)
{
    return SURFACEOF(pDDS)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggRelease(IDirectDrawSurface *pDDS)
{
    return SURFACEOF(pDDS)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurfaceAggGetDC(IDirectDrawSurface *pDDS, HDC * pHDC)
{
    return SURFACEOF(pDDS)->InternalGetDC(pHDC);
}


STDMETHODIMP IDirectDrawSurfaceAggGetAttachedSurface(IDirectDrawSurface *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, lpDDS, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggAddAttachedSurface(IDirectDrawSurface *pDDS, LPDIRECTDRAWSURFACE lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface(lpDDS, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggDeleteAttachedSurface(IDirectDrawSurface *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, lpDDS, DDSURFACETYPE_1);
}


STDMETHODIMP IDirectDrawSurfaceAggReleaseDC(IDirectDrawSurface *pDDS, HDC hdc)
{
    return SURFACEOF(pDDS)->InternalReleaseDC(hdc);
}


STDMETHODIMP IDirectDrawSurfaceAggLock(IDirectDrawSurface *pDDS, LPRECT lpDestRect,
				       LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurfaceAggUnlock(IDirectDrawSurface *pDDS, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurfaceAggFlip(IDirectDrawSurface *pDDS, LPDIRECTDRAWSURFACE lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip(lpSurf, dw, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggBlt(IDirectDrawSurface *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggGetPalette(IDirectDrawSurface *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggSetPalette(IDirectDrawSurface *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_1);
}

STDMETHODIMP IDirectDrawSurfaceAggGetSurfaceDesc(IDirectDrawSurface *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_1);
}



/*
 * the implementation of the functions in IDirectDrawSurface2 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggAddRef(IDirectDrawSurface2 *pDDS2)
{
    return SURFACEOF(pDDS2)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface2AggRelease(IDirectDrawSurface2 *pDDS2)
{
    return SURFACEOF(pDDS2)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurface2AggGetDC(IDirectDrawSurface2 *pDDS2, HDC * pHDC)
{
    return SURFACEOF(pDDS2)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface2AggReleaseDC(IDirectDrawSurface2 *pDDS2, HDC hdc)
{
    return SURFACEOF(pDDS2)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface2AggLock(IDirectDrawSurface2 *pDDS2, LPRECT lpDestRect,
				        LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS2)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface2AggUnlock(IDirectDrawSurface2 *pDDS2, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS2)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurface2AggGetAttachedSurface(IDirectDrawSurface2 *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE2 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, (IDirectDrawSurface **)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggAddAttachedSurface(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWSURFACE2 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggDeleteAttachedSurface(IDirectDrawSurface2 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE2 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggFlip(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWSURFACE2 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggBlt(IDirectDrawSurface2 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE2 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggGetPalette(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggSetPalette(IDirectDrawSurface2 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_2);
}

STDMETHODIMP IDirectDrawSurface2AggGetDDInterface(IDirectDrawSurface2 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}

STDMETHODIMP IDirectDrawSurface2AggGetSurfaceDesc(IDirectDrawSurface2 *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_2);
}


/*
 * the implementation of the functions in IDirectDrawSurface3 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock, SetSurfaceDesc)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggAddRef(IDirectDrawSurface3 *pDDS3)
{
    return SURFACEOF(pDDS3)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface3AggRelease(IDirectDrawSurface3 *pDDS3)
{
    return SURFACEOF(pDDS3)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawSurface3AggGetDC(IDirectDrawSurface3 *pDDS3, HDC * pHDC)
{
    return SURFACEOF(pDDS3)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface3AggReleaseDC(IDirectDrawSurface3 *pDDS3, HDC hdc)
{
    return SURFACEOF(pDDS3)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface3AggLock(IDirectDrawSurface3 *pDDS3, LPRECT lpDestRect,
				        LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    return SURFACEOF(pDDS3)->InternalLock(lpDestRect, lpDDSurfaceDesc, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface3AggUnlock(IDirectDrawSurface3 *pDDS3, LPVOID lpSurfaceData)
{
    return SURFACEOF(pDDS3)->InternalUnlock(lpSurfaceData);
}

STDMETHODIMP IDirectDrawSurface3AggSetSurfaceDesc(IDirectDrawSurface3 *pDDS3, LPDDSURFACEDESC pddsd, DWORD dwFlags)
{
    return SURFACEOF(pDDS3)->InternalSetSurfaceDesc(pddsd, dwFlags);
}

STDMETHODIMP IDirectDrawSurface3AggGetAttachedSurface(IDirectDrawSurface3 *pDDS, LPDDSCAPS lpDDSCaps, LPDIRECTDRAWSURFACE3 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface(lpDDSCaps, (IDirectDrawSurface**)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggAddAttachedSurface(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWSURFACE3 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggDeleteAttachedSurface(IDirectDrawSurface3 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE3 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggFlip(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWSURFACE3 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggBlt(IDirectDrawSurface3 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE3 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggGetPalette(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggSetPalette(IDirectDrawSurface3 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_3);
}

STDMETHODIMP IDirectDrawSurface3AggGetDDInterface(IDirectDrawSurface3 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}


STDMETHODIMP IDirectDrawSurface3AggGetSurfaceDesc(IDirectDrawSurface3 *pDDS, LPDDSURFACEDESC lpDesc)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc(lpDesc, DDSURFACETYPE_3);
}


/*
 * the implementation of the functions in IDirectDrawSurface4 that we are
 * overriding (IUnknown and GetDC, ReleaseDC, Lock, Unlock, SetSurfaceDesc)
 */
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggAddRef(IDirectDrawSurface4 *pDDS4)
{
    return SURFACEOF(pDDS4)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawSurface4AggRelease(IDirectDrawSurface4 *pDDS4)
{
    return SURFACEOF(pDDS4)->m_pUnkOuter->Release();
}

STDMETHODIMP IDirectDrawSurface4AggGetDC(IDirectDrawSurface4 *pDDS4, HDC * pHDC)
{
    return SURFACEOF(pDDS4)->InternalGetDC(pHDC);
}

STDMETHODIMP IDirectDrawSurface4AggReleaseDC(IDirectDrawSurface4 *pDDS4, HDC hdc)
{
    return SURFACEOF(pDDS4)->InternalReleaseDC(hdc);
}

STDMETHODIMP IDirectDrawSurface4AggLock(IDirectDrawSurface4 *pDDS4, LPRECT lpDestRect,
				        LPDDSURFACEDESC2 lpDDSurfaceDesc2, DWORD dwFlags, HANDLE hEvent)
{
    INTSTRUC_IDirectDrawSurface4 * pdd4 = (INTSTRUC_IDirectDrawSurface4 *)pDDS4;
    return pdd4->m_pRealInterface->Lock(lpDestRect, lpDDSurfaceDesc2, dwFlags, hEvent);
}

STDMETHODIMP IDirectDrawSurface4AggUnlock(IDirectDrawSurface4 *pDDS4, LPRECT lpRect)
{
    INTSTRUC_IDirectDrawSurface4 * pdd4 = (INTSTRUC_IDirectDrawSurface4 *)pDDS4;
    return pdd4->m_pRealInterface->Unlock(lpRect);
}

STDMETHODIMP IDirectDrawSurface4AggSetSurfaceDesc(IDirectDrawSurface4 *pDDS4, LPDDSURFACEDESC pddsd, DWORD dwFlags)
{
    return SURFACEOF(pDDS4)->InternalSetSurfaceDesc(pddsd, dwFlags);
}

STDMETHODIMP IDirectDrawSurface4AggGetAttachedSurface(IDirectDrawSurface4 *pDDS, LPDDSCAPS2 lpDDSCaps, LPDIRECTDRAWSURFACE4 FAR * lpDDS)
{
    return SURFACEOF(pDDS)->InternalGetAttachedSurface4(lpDDSCaps, (IDirectDrawSurface**)lpDDS);
}

STDMETHODIMP IDirectDrawSurface4AggAddAttachedSurface(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWSURFACE4 lpDDS)
{
    return SURFACEOF(pDDS)->InternalAddAttachedSurface((IDirectDrawSurface *)lpDDS, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggDeleteAttachedSurface(IDirectDrawSurface4 *pDDS, DWORD dwFlags, LPDIRECTDRAWSURFACE4 lpDDS)
{
    return SURFACEOF(pDDS)->InternalDeleteAttachedSurface(dwFlags, (IDirectDrawSurface *)lpDDS, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggFlip(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWSURFACE4 lpSurf, DWORD dw)
{
    return SURFACEOF(pDDS)->InternalFlip((LPDIRECTDRAWSURFACE)lpSurf, dw, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggBlt(IDirectDrawSurface4 *pDDS, LPRECT lpRect1,LPDIRECTDRAWSURFACE4 lpDDS, LPRECT lpRect2,DWORD dw, LPDDBLTFX lpfx)
{
    return SURFACEOF(pDDS)->InternalBlt(lpRect1, (LPDIRECTDRAWSURFACE)lpDDS, lpRect2, dw, lpfx, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggGetPalette(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWPALETTE FAR * ppPal)
{
    return SURFACEOF(pDDS)->InternalGetPalette(ppPal, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggSetPalette(IDirectDrawSurface4 *pDDS, LPDIRECTDRAWPALETTE pPal)
{
    return SURFACEOF(pDDS)->InternalSetPalette(pPal, DDSURFACETYPE_4);
}

STDMETHODIMP IDirectDrawSurface4AggGetDDInterface(IDirectDrawSurface4 *pDDS, LPVOID FAR * ppInt)
{
    return SURFACEOF(pDDS)->InternalGetDDInterface(ppInt);
}

STDMETHODIMP IDirectDrawSurface4AggGetSurfaceDesc(IDirectDrawSurface4 *pDDS, LPDDSURFACEDESC2 lpDesc2)
{
    return SURFACEOF(pDDS)->InternalGetSurfaceDesc4(lpDesc2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\palette.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       palette.cpp
 *  Content:	new DirectDraw object support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-apr-97	jeffort	initial implementation
 *   30-apr-97  jeffort critical section shared from ddrawex object
 *   27-may-97  jeffort keep ref count on internal object eual to outer object
 *   18-jun-97  jeffort linked list fix, we were using m_pNext instead of m_pNextPalette
 *   20-jun-97  jeffort added debug code to invaliudate objects when freed
 *   08-jul-97  jeffort switched order of releasing real palette interface BEFORE ddrawex release
 *                      due to the fact if ddraw is released before hand we will GP fault
 ***************************************************************************/
#include "ddfactry.h"

#define m_pDDPalette (m_DDPInt.m_pRealInterface)



CDDPalette::CDDPalette( IDirectDrawPalette * pDDPalette,
		IUnknown *pUnkOuter,
		CDirectDrawEx *pDirectDrawEx) :
    m_cRef(1),
    m_pUnkOuter(pUnkOuter != 0 ? pUnkOuter : CAST_TO_IUNKNOWN(this)),
    m_pDirectDrawEx(pDirectDrawEx)
{

    m_DDPInt.m_pSimplePalette = this;
    m_pDDPalette = pDDPalette;
    m_pFirstSurface = NULL;
    InitDirectDrawPaletteInterfaces( pDDPalette, &m_DDPInt);
    pDirectDrawEx->AddRef();
    pDirectDrawEx->AddPaletteToList(this);
    DllAddRef();

}



CDDPalette::~CDDPalette()
{
    /*
     * clean up...
     */
    //we must mark any surfaces in our list as having no palette
    //we are running this list, must bracket by critical section

    CDDSurface *pSurface = m_pFirstSurface;

    ENTER_DDEX();
    while (pSurface != NULL)
    {
        pSurface->m_pCurrentPalette = NULL;
        pSurface = pSurface->m_pNextPalette;
    }
    //if this is the primary surface, go down the primary list and mark the current palette as null
    if (m_bIsPrimary)
    {
        CDDSurface *pSurface = m_pDirectDrawEx->m_pPrimaryPaletteList;
        while (pSurface != NULL)
        {
            pSurface->m_pCurrentPalette = NULL;
            pSurface = pSurface->m_pNextPalette;
        }
    }
    LEAVE_DDEX();
    m_pDirectDrawEx->RemovePaletteFromList(this);
    m_pDDPalette->Release();
    m_pDirectDrawEx->Release();
    DllRelease();
#ifdef DEBUG
    DWORD * ptr;
    ptr = (DWORD *)this;
    for (int i = 0; i < sizeof(CDDPalette) / sizeof(DWORD);i++)
        *ptr++ = 0xDEADBEEF;
#endif
} /* CDDSurface::~CDDSurface */




/*
 * CDirectDrawEx::AddSurfaceToList
 *
 * Adds a surface to our doubly-linked list of surfaces conatining this palette
 */
void CDDPalette::AddSurfaceToList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( m_pFirstSurface )
    {
	m_pFirstSurface->m_pPrevPalette = pSurface;
    }
    pSurface->m_pPrevPalette = NULL;
    pSurface->m_pNextPalette = m_pFirstSurface;
    m_pFirstSurface = pSurface;
    LEAVE_DDEX();

}

/*
 * CDirectDrawEx::RemoveSurfaceFromList
 *
 * Removes a surface from our doubly-linked surface list
 */
void CDDPalette::RemoveSurfaceFromList(CDDSurface *pSurface)
{
    ENTER_DDEX();
    if( pSurface->m_pPrevPalette )
    {
	pSurface->m_pPrevPalette->m_pNextPalette = pSurface->m_pNextPalette;
    }
    else
    {
	m_pFirstSurface = pSurface->m_pNextPalette;
    }
    if( pSurface->m_pNextPalette )
    {
	pSurface->m_pNextPalette->m_pPrevPalette = pSurface->m_pPrevPalette;
    }
    LEAVE_DDEX();

}




HRESULT CDDPalette::CreateSimplePalette(LPPALETTEENTRY pEntries,
                                       IDirectDrawPalette *pDDPalette,
                                       LPDIRECTDRAWPALETTE FAR * ppPal,
                                       IUnknown FAR * pUnkOuter,
                                       CDirectDrawEx *pDirectDrawEx)
{
    HRESULT hr = DD_OK;
    CDDPalette *pPalette = new CDDPalette(pDDPalette,
					  pUnkOuter,
					  pDirectDrawEx);
    if( !pPalette)
    {
	return E_OUTOFMEMORY;
    }
    else
    {
        pPalette->NonDelegatingQueryInterface(pUnkOuter ? IID_IUnknown : IID_IDirectDrawPalette, (void **)ppPal);
        pPalette->NonDelegatingRelease();
    }

    return hr;

}


HRESULT CDDPalette::SetColorTable (CDDSurface * pSurface, LPPALETTEENTRY pEntries, DWORD dwNumEntries, DWORD dwBase)
{
    //cal SetDIBColorTable here
    RGBQUAD rgbq[256];
    HDC hdc;
    HRESULT hr;

    hr = DD_OK;
    if (pSurface->m_bOwnDC)
    {
        if( pSurface->m_hDCDib )
        {
	    hdc = pSurface->m_hDCDib;
        }
        else if( pSurface->m_bOwnDC )
        {
	    hdc = pSurface->m_HDC;
        }
        else
        {
            return DD_OK;
        }
        // we need to copy the entries here for
        // a logical palette
        // we need to ues the struct as a LogPal struct
        for( int i=0;i<(int) dwNumEntries;i++ )
	{
            rgbq[i].rgbBlue = pEntries[i].peBlue;
            rgbq[i].rgbGreen = pEntries[i].peGreen;
            rgbq[i].rgbRed = pEntries[i].peRed;
            rgbq[i].rgbReserved = 0;
        }
        SetDIBColorTable(hdc, dwBase, dwNumEntries, rgbq);
    }
    return hr;
}


STDMETHODIMP CDDPalette::InternalSetEntries(DWORD dwFlags, DWORD dwBase, DWORD dwNumEntries, LPPALETTEENTRY lpe)
{
    HRESULT hr;
    CDDSurface *pSurfaceList;

    hr = m_pDDPalette->SetEntries(dwFlags, dwBase, dwNumEntries, lpe);
    //now we need to traverse the list of Surfaces and if OWNDC is set, set the DibSection ColorTable
    if (m_bIsPrimary)
        pSurfaceList = m_pDirectDrawEx->m_pPrimaryPaletteList;
    else
        pSurfaceList = m_pFirstSurface;

    while (pSurfaceList != NULL)
    {
        SetColorTable(pSurfaceList, lpe, dwNumEntries, dwBase);
        pSurfaceList = pSurfaceList->m_pNextPalette;
    }
    return hr;
}


STDMETHODIMP CDDPalette::QueryInterface(REFIID riid, void ** ppv)
{
    return m_pUnkOuter->QueryInterface(riid, ppv);

} /* CDirectDrawEx::QueryInterface */

STDMETHODIMP_(ULONG) CDDPalette::AddRef(void)
{
    return m_pUnkOuter->AddRef();

} /* CDirectDrawEx::AddRef */

STDMETHODIMP_(ULONG) CDDPalette::Release(void)
{
    return m_pUnkOuter->Release();

} /* CDirectDrawEx::Release */

/*
 * NonDelegating IUnknown for simple surface follows...
 */

STDMETHODIMP CDDPalette::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
//    HRESULT hr;

    *ppv=NULL;

    if( IID_IUnknown==riid )
    {
        *ppv=(INonDelegatingUnknown *)this;
    }
    else if( IID_IDirectDrawPalette==riid )
    {
	*ppv=&m_DDPInt;
    }

    else
    {
	   return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CDDPalette::NonDelegatingAddRef()
{
    //addref the internal palette interface
    m_pDDPalette->AddRef();
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDDPalette::NonDelegatingRelease()
{
    LONG lRefCount = InterlockedDecrement(&m_cRef);
    if (lRefCount) {
        //we need to release the internal interface as well
        m_pDDPalette->Release();
        return lRefCount;
    }
    delete this;
    return 0;
}

/*
 * Quick inline fns to get at our internal data...
 */
_inline CDDPalette * PALETTEOF(IDirectDrawPalette * pDDP)
{
    return ((INTSTRUC_IDirectDrawPalette *)pDDP)->m_pSimplePalette;
}



STDMETHODIMP_(ULONG) IDirectDrawPaletteAggAddRef(IDirectDrawPalette *pDDP)
{
    return PALETTEOF(pDDP)->m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) IDirectDrawPaletteAggRelease(IDirectDrawPalette *pDDP)
{
    return PALETTEOF(pDDP)->m_pUnkOuter->Release();
}


STDMETHODIMP IDirectDrawPaletteAggSetEntries(IDirectDrawPalette *pDDP, DWORD dw1, DWORD dw2, DWORD dw3, LPPALETTEENTRY lpe)
{
    return PALETTEOF(pDDP)->InternalSetEntries(dw1, dw2, dw3, lpe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\vtable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vtable.cpp
 *  Content:	declaration of vtables for the various interfaces
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-feb-97	ralphl	initial implementation
 *   25-feb-97	craige	minor tweaks for dx checkin
 *   06-mar-97	craige	IDirectDrawSurface3 support
 *   14-mar-97  jeffort SetBits changed to reflect DX5 as SetSurfaceDesc
 *   01-apr-97  jeffort Following changes checked in:
 *                      Aggregation of Add/GetAttachedSurface
 *                      Aggregation of Flip/Blt
 *   28-apr-97  jeffort Palette wrapping added/DX5 support
 *
 *   02-may-97  jeffort GetDDInterface wrapping added
 *   06-may-97  jeffort DeleteAttachedSurface wrapping added
 *   07-jul-97  jeffort GetSurfaceDesc wrapping added
 ***************************************************************************/
#define CINTERFACE
#include "ddfactry.h"

#define FORWARD0(Interface, Name) \
STDMETHODIMP Interface##Name(Interface *pIntStruc) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal); }

#define FORWARD1(Interface, Name, p1) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a); }

#define FORWARD2(Interface, Name, p1, p2) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b); }

#define FORWARD3(Interface, Name, p1, p2, p3) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c); }

#define FORWARD4(Interface, Name, p1, p2, p3, p4) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c, p4 d) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c, d); }

#define FORWARD5(Interface, Name, p1, p2, p3, p4, p5) \
STDMETHODIMP Interface##Name(Interface *pIntStruc, p1 a, p2 b, p3 c, p4 d, p5 e) \
{	Interface * pReal = ((INTSTRUC_##Interface *)pIntStruc)->m_pRealInterface; \
	return pReal->lpVtbl->Name(pReal, a, b, c, d, e); }

#define __QI(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)

_inline CDirectDrawEx * PARENTOF(IDirectDraw * pDD)
{
    return ((INTSTRUC_IDirectDraw *)pDD)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw2 * pDD2)
{
    return ((INTSTRUC_IDirectDraw2 *)pDD2)->m_pDirectDrawEx;
}

_inline CDirectDrawEx * PARENTOF(IDirectDraw4 * pDD4)
{
    return ((INTSTRUC_IDirectDraw4 *)pDD4)->m_pDirectDrawEx;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface * pDDS)
{
    return ((INTSTRUC_IDirectDrawSurface *)pDDS)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface2 * pDDS2)
{
    return ((INTSTRUC_IDirectDrawSurface2 *)pDDS2)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface3 * pDDS3)
{
    return ((INTSTRUC_IDirectDrawSurface3 *)pDDS3)->m_pSimpleSurface;
}

_inline CDDSurface * SURFACEOF(IDirectDrawSurface4 * pDDS4)
{
    return ((INTSTRUC_IDirectDrawSurface4 *)pDDS4)->m_pSimpleSurface;
}

_inline CDDPalette * PALETTEOF(IDirectDrawPalette * pDDP)
{
    return ((INTSTRUC_IDirectDrawPalette *)pDDP)->m_pSimplePalette;
}


/*
 * IDirectDraw
 */

STDMETHODIMP IDirectDrawAggQueryInterface(IDirectDraw *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawAggAddRef(IDirectDraw *);
STDMETHODIMP_(ULONG) IDirectDrawAggRelease(IDirectDraw *);
STDMETHODIMP IDirectDrawAggCreateSurface(IDirectDraw *, LPDDSURFACEDESC pSurfaceDesc,
				         IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDrawAggCreatePalette(IDirectDraw *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDrawAggSetCooperativeLevel(IDirectDraw *, HWND, DWORD);

FORWARD0(IDirectDraw, Compact)
FORWARD3(IDirectDraw, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw, DuplicateSurface,		LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR *)
FORWARD4(IDirectDraw, EnumDisplayModes,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK)
FORWARD4(IDirectDraw, EnumSurfaces,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK)
FORWARD0(IDirectDraw, FlipToGDISurface)
FORWARD2(IDirectDraw, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw, GetDisplayMode,		LPDDSURFACEDESC)
FORWARD2(IDirectDraw, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw, GetGDISurface,		LPDIRECTDRAWSURFACE FAR *)
FORWARD1(IDirectDraw, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw, Initialize,		GUID *)
FORWARD1(IDirectDraw, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw, RestoreDisplayMode)
FORWARD2(IDirectDraw, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw, SetDisplayMode,		DWORD, DWORD, DWORD)


IDirectDrawVtbl g_DirectDrawVtbl =
{
    IDirectDrawAggQueryInterface,
    IDirectDrawAggAddRef,
    IDirectDrawAggRelease,
    IDirectDrawCompact,
    IDirectDrawCreateClipper,
    IDirectDrawAggCreatePalette,
    IDirectDrawAggCreateSurface,
    IDirectDrawDuplicateSurface,
    IDirectDrawEnumDisplayModes,
    IDirectDrawEnumSurfaces,
    IDirectDrawFlipToGDISurface,
    IDirectDrawGetCaps,
    IDirectDrawGetDisplayMode,
    IDirectDrawGetFourCCCodes,
    IDirectDrawGetGDISurface,
    IDirectDrawGetMonitorFrequency,
    IDirectDrawGetScanLine,
    IDirectDrawGetVerticalBlankStatus,
    IDirectDrawInitialize,
    IDirectDrawRestoreDisplayMode,
    IDirectDrawAggSetCooperativeLevel,
    IDirectDrawSetDisplayMode,
    IDirectDrawWaitForVerticalBlank
};

/*
 * IDirectDraw2
 */
STDMETHODIMP IDirectDraw2AggQueryInterface(IDirectDraw2 *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDraw2AggAddRef(IDirectDraw2 *);
STDMETHODIMP_(ULONG) IDirectDraw2AggRelease(IDirectDraw2 *);
STDMETHODIMP IDirectDraw2AggCreateSurface(IDirectDraw2 *, LPDDSURFACEDESC pSurfaceDesc,
					  IDirectDrawSurface **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDraw2AggCreatePalette(IDirectDraw2 *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDraw2AggSetCooperativeLevel(IDirectDraw2 *, HWND, DWORD);



FORWARD0(IDirectDraw2, Compact)
FORWARD3(IDirectDraw2, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw2, DuplicateSurface,	LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR *)
FORWARD4(IDirectDraw2, EnumDisplayModes,	DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK)
FORWARD4(IDirectDraw2, EnumSurfaces,		DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK)
FORWARD0(IDirectDraw2, FlipToGDISurface)
FORWARD2(IDirectDraw2, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw2, GetDisplayMode,		LPDDSURFACEDESC)
FORWARD2(IDirectDraw2, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw2, GetGDISurface,		LPDIRECTDRAWSURFACE FAR *)
FORWARD1(IDirectDraw2, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw2, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw2, Initialize,		GUID *)
FORWARD1(IDirectDraw2, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw2, RestoreDisplayMode)
FORWARD2(IDirectDraw2, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw2, GetAvailableVidMem,	LPDDSCAPS, LPDWORD, LPDWORD)
FORWARD5(IDirectDraw2, SetDisplayMode,		DWORD, DWORD, DWORD, DWORD, DWORD)

IDirectDraw2Vtbl g_DirectDraw2Vtbl =
{
    IDirectDraw2AggQueryInterface,
    IDirectDraw2AggAddRef,
    IDirectDraw2AggRelease,
    IDirectDraw2Compact,
    IDirectDraw2CreateClipper,
    IDirectDraw2AggCreatePalette,
    IDirectDraw2AggCreateSurface,
    IDirectDraw2DuplicateSurface,
    IDirectDraw2EnumDisplayModes,
    IDirectDraw2EnumSurfaces,
    IDirectDraw2FlipToGDISurface,
    IDirectDraw2GetCaps,
    IDirectDraw2GetDisplayMode,
    IDirectDraw2GetFourCCCodes,
    IDirectDraw2GetGDISurface,
    IDirectDraw2GetMonitorFrequency,
    IDirectDraw2GetScanLine,
    IDirectDraw2GetVerticalBlankStatus,
    IDirectDraw2Initialize,
    IDirectDraw2RestoreDisplayMode,
    IDirectDraw2AggSetCooperativeLevel,
    IDirectDraw2SetDisplayMode,
    IDirectDraw2WaitForVerticalBlank,
    IDirectDraw2GetAvailableVidMem
};


STDMETHODIMP IDirectDraw4AggQueryInterface(IDirectDraw4 *pDD, REFIID riid, void ** ppv)
{
    return __QI(PARENTOF(pDD)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDraw4AggAddRef(IDirectDraw4 *);
STDMETHODIMP_(ULONG) IDirectDraw4AggRelease(IDirectDraw4 *);
STDMETHODIMP IDirectDraw4AggCreateSurface(IDirectDraw4 *, LPDDSURFACEDESC2 pSurfaceDesc2,
				         IDirectDrawSurface4 **ppNewSurface, IUnknown *pUnkOuter);
STDMETHODIMP IDirectDraw4AggCreatePalette(IDirectDraw4 *,DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR *, IUnknown FAR *);
STDMETHODIMP IDirectDraw4AggSetCooperativeLevel(IDirectDraw4 *, HWND, DWORD);


FORWARD0(IDirectDraw4, Compact)
FORWARD3(IDirectDraw4, CreateClipper,		DWORD, LPDIRECTDRAWCLIPPER FAR *, IUnknown *)
FORWARD2(IDirectDraw4, DuplicateSurface,	LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR *)
FORWARD4(IDirectDraw4, EnumDisplayModes,	DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2)
FORWARD4(IDirectDraw4, EnumSurfaces,		DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMSURFACESCALLBACK2)
FORWARD0(IDirectDraw4, FlipToGDISurface)
FORWARD2(IDirectDraw4, GetCaps,			LPDDCAPS, LPDDCAPS)
FORWARD1(IDirectDraw4, GetDisplayMode,		LPDDSURFACEDESC2)
FORWARD2(IDirectDraw4, GetFourCCCodes,		LPDWORD, LPDWORD)
FORWARD1(IDirectDraw4, GetGDISurface,		LPDIRECTDRAWSURFACE4 FAR *)
FORWARD1(IDirectDraw4, GetMonitorFrequency,	LPDWORD)
FORWARD1(IDirectDraw4, GetScanLine,		LPDWORD)
FORWARD1(IDirectDraw4, Initialize,		GUID *)
FORWARD1(IDirectDraw4, GetVerticalBlankStatus,	LPBOOL)
FORWARD0(IDirectDraw4, RestoreDisplayMode)
FORWARD2(IDirectDraw4, WaitForVerticalBlank,	DWORD, HANDLE)
FORWARD3(IDirectDraw4, GetAvailableVidMem,	LPDDSCAPS2, LPDWORD, LPDWORD)
FORWARD5(IDirectDraw4, SetDisplayMode,		DWORD, DWORD, DWORD, DWORD, DWORD)
FORWARD2(IDirectDraw4, GetSurfaceFromDC,        HDC, LPDIRECTDRAWSURFACE4 *)
FORWARD0(IDirectDraw4, RestoreAllSurfaces)
FORWARD0(IDirectDraw4, TestCooperativeLevel)

IDirectDraw4Vtbl g_DirectDraw4Vtbl =
{
    IDirectDraw4AggQueryInterface,
    IDirectDraw4AggAddRef,
    IDirectDraw4AggRelease,
    IDirectDraw4Compact,
    IDirectDraw4CreateClipper,
    IDirectDraw4AggCreatePalette,
    IDirectDraw4AggCreateSurface,
    IDirectDraw4DuplicateSurface,
    IDirectDraw4EnumDisplayModes,
    IDirectDraw4EnumSurfaces,
    IDirectDraw4FlipToGDISurface,
    IDirectDraw4GetCaps,
    IDirectDraw4GetDisplayMode,
    IDirectDraw4GetFourCCCodes,
    IDirectDraw4GetGDISurface,
    IDirectDraw4GetMonitorFrequency,
    IDirectDraw4GetScanLine,
    IDirectDraw4GetVerticalBlankStatus,
    IDirectDraw4Initialize,
    IDirectDraw4RestoreDisplayMode,
    IDirectDraw4AggSetCooperativeLevel,
    IDirectDraw4SetDisplayMode,
    IDirectDraw4WaitForVerticalBlank,
    IDirectDraw4GetAvailableVidMem,
    IDirectDraw4GetSurfaceFromDC,
    IDirectDraw4RestoreAllSurfaces,
    IDirectDraw4TestCooperativeLevel
};


/*
 * IDirectDrawSurface
 */
STDMETHODIMP IDirectDrawSurfaceAggQueryInterface(IDirectDrawSurface *pDDS, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggAddRef(IDirectDrawSurface *);
STDMETHODIMP_(ULONG) IDirectDrawSurfaceAggRelease(IDirectDrawSurface *);
STDMETHODIMP IDirectDrawSurfaceAggGetDC(IDirectDrawSurface *, HDC *);
STDMETHODIMP IDirectDrawSurfaceAggReleaseDC(IDirectDrawSurface *, HDC);
STDMETHODIMP IDirectDrawSurfaceAggLock(IDirectDrawSurface *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurfaceAggUnlock(IDirectDrawSurface *, LPVOID);
STDMETHODIMP IDirectDrawSurfaceAggSetSurfaceDesc(IDirectDrawSurface *, LPVOID);
STDMETHODIMP IDirectDrawSurfaceAggGetAttachedSurface( IDirectDrawSurface *, LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *);
STDMETHODIMP IDirectDrawSurfaceAggAddAttachedSurface( IDirectDrawSurface *, LPDIRECTDRAWSURFACE);
STDMETHODIMP IDirectDrawSurfaceAggDeleteAttachedSurface( IDirectDrawSurface *,DWORD, LPDIRECTDRAWSURFACE);
STDMETHODIMP IDirectDrawSurfaceAggFlip(IDirectDrawSurface *, LPDIRECTDRAWSURFACE, DWORD);
STDMETHODIMP IDirectDrawSurfaceAggBlt(IDirectDrawSurface *,LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurfaceAggGetPalette(IDirectDrawSurface *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurfaceAggSetPalette(IDirectDrawSurface *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurfaceAggGetSurfaceDesc(IDirectDrawSurface *, LPDDSURFACEDESC);

/*** IDirectDrawSurface methods ***/
FORWARD1(IDirectDrawSurface, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD1(IDirectDrawSurface, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface, IsLost)
FORWARD0(IDirectDrawSurface, Restore)
FORWARD1(IDirectDrawSurface, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE)

IDirectDrawSurfaceVtbl g_DirectDrawSurfaceVtbl =
{
    IDirectDrawSurfaceAggQueryInterface,
    IDirectDrawSurfaceAggAddRef,
    IDirectDrawSurfaceAggRelease,
    IDirectDrawSurfaceAggAddAttachedSurface,
    IDirectDrawSurfaceAddOverlayDirtyRect,
    IDirectDrawSurfaceAggBlt,
    IDirectDrawSurfaceBltBatch,
    IDirectDrawSurfaceBltFast,
    IDirectDrawSurfaceAggDeleteAttachedSurface,
    IDirectDrawSurfaceEnumAttachedSurfaces,
    IDirectDrawSurfaceEnumOverlayZOrders,
    IDirectDrawSurfaceAggFlip,
    IDirectDrawSurfaceAggGetAttachedSurface,
    IDirectDrawSurfaceGetBltStatus,
    IDirectDrawSurfaceGetCaps,
    IDirectDrawSurfaceGetClipper,
    IDirectDrawSurfaceGetColorKey,
    IDirectDrawSurfaceAggGetDC,
    IDirectDrawSurfaceGetFlipStatus,
    IDirectDrawSurfaceGetOverlayPosition,
    IDirectDrawSurfaceAggGetPalette,
    IDirectDrawSurfaceGetPixelFormat,
    IDirectDrawSurfaceAggGetSurfaceDesc,
    IDirectDrawSurfaceInitialize,
    IDirectDrawSurfaceIsLost,
    IDirectDrawSurfaceAggLock,
    IDirectDrawSurfaceAggReleaseDC,
    IDirectDrawSurfaceRestore,
    IDirectDrawSurfaceSetClipper,
    IDirectDrawSurfaceSetColorKey,
    IDirectDrawSurfaceSetOverlayPosition,
    IDirectDrawSurfaceAggSetPalette,
    IDirectDrawSurfaceAggUnlock,
    IDirectDrawSurfaceUpdateOverlay,
    IDirectDrawSurfaceUpdateOverlayDisplay,
    IDirectDrawSurfaceUpdateOverlayZOrder
};

/*
 * IDirectDrawSurface2
 */
STDMETHODIMP IDirectDrawSurface2AggQueryInterface(IDirectDrawSurface2 *pDDS2, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS2)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggAddRef(IDirectDrawSurface2 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface2AggRelease(IDirectDrawSurface2 *);
STDMETHODIMP IDirectDrawSurface2AggGetDC(IDirectDrawSurface2 *, HDC *);
STDMETHODIMP IDirectDrawSurface2AggReleaseDC(IDirectDrawSurface2 *, HDC);
STDMETHODIMP IDirectDrawSurface2AggLock(IDirectDrawSurface2 *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface2AggUnlock(IDirectDrawSurface2 *, LPVOID);
STDMETHODIMP IDirectDrawSurface2AggGetAttachedSurface( IDirectDrawSurface2 *, LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *);
STDMETHODIMP IDirectDrawSurface2AggAddAttachedSurface( IDirectDrawSurface2 *, LPDIRECTDRAWSURFACE2);
STDMETHODIMP IDirectDrawSurface2AggDeleteAttachedSurface( IDirectDrawSurface2 *,DWORD, LPDIRECTDRAWSURFACE2);
STDMETHODIMP IDirectDrawSurface2AggFlip(IDirectDrawSurface2 *, LPDIRECTDRAWSURFACE2, DWORD);
STDMETHODIMP IDirectDrawSurface2AggBlt(IDirectDrawSurface2 *,LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface2AggGetPalette(IDirectDrawSurface2 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface2AggSetPalette(IDirectDrawSurface2 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface2AggGetDDInterface(IDirectDrawSurface2 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface2AggGetSurfaceDesc(IDirectDrawSurface2 *, LPDDSURFACEDESC);




/*** IDirectDrawSurface2 methods ***/
FORWARD1(IDirectDrawSurface2, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface2, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface2, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface2, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface2, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD1(IDirectDrawSurface2, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface2, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface2, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface2, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface2, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface2, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface2, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface2, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface2, IsLost)
FORWARD0(IDirectDrawSurface2, Restore)
FORWARD1(IDirectDrawSurface2, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface2, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface2, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface2, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface2, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface2, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE2)
FORWARD1(IDirectDrawSurface2, PageLock, DWORD)
FORWARD1(IDirectDrawSurface2, PageUnlock, DWORD)

IDirectDrawSurface2Vtbl g_DirectDrawSurface2Vtbl =
{
    IDirectDrawSurface2AggQueryInterface,
    IDirectDrawSurface2AggAddRef,
    IDirectDrawSurface2AggRelease,
    IDirectDrawSurface2AggAddAttachedSurface,
    IDirectDrawSurface2AddOverlayDirtyRect,
    IDirectDrawSurface2AggBlt,
    IDirectDrawSurface2BltBatch,
    IDirectDrawSurface2BltFast,
    IDirectDrawSurface2AggDeleteAttachedSurface,
    IDirectDrawSurface2EnumAttachedSurfaces,
    IDirectDrawSurface2EnumOverlayZOrders,
    IDirectDrawSurface2AggFlip,
    IDirectDrawSurface2AggGetAttachedSurface,
    IDirectDrawSurface2GetBltStatus,
    IDirectDrawSurface2GetCaps,
    IDirectDrawSurface2GetClipper,
    IDirectDrawSurface2GetColorKey,
    IDirectDrawSurface2AggGetDC,
    IDirectDrawSurface2GetFlipStatus,
    IDirectDrawSurface2GetOverlayPosition,
    IDirectDrawSurface2AggGetPalette,
    IDirectDrawSurface2GetPixelFormat,
    IDirectDrawSurface2AggGetSurfaceDesc,
    IDirectDrawSurface2Initialize,
    IDirectDrawSurface2IsLost,
    IDirectDrawSurface2AggLock,
    IDirectDrawSurface2AggReleaseDC,
    IDirectDrawSurface2Restore,
    IDirectDrawSurface2SetClipper,
    IDirectDrawSurface2SetColorKey,
    IDirectDrawSurface2SetOverlayPosition,
    IDirectDrawSurface2AggSetPalette,
    IDirectDrawSurface2AggUnlock,
    IDirectDrawSurface2UpdateOverlay,
    IDirectDrawSurface2UpdateOverlayDisplay,
    IDirectDrawSurface2UpdateOverlayZOrder,
    IDirectDrawSurface2AggGetDDInterface,
    IDirectDrawSurface2PageLock,
    IDirectDrawSurface2PageUnlock
};

/*
 * IDirectDrawSurface3
 */
STDMETHODIMP IDirectDrawSurface3AggQueryInterface(IDirectDrawSurface3 *pDDS3, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS3)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggAddRef(IDirectDrawSurface3 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface3AggRelease(IDirectDrawSurface3 *);
STDMETHODIMP IDirectDrawSurface3AggGetDC(IDirectDrawSurface3 *, HDC *);
STDMETHODIMP IDirectDrawSurface3AggReleaseDC(IDirectDrawSurface3 *, HDC);
STDMETHODIMP IDirectDrawSurface3AggLock(IDirectDrawSurface3 *, LPRECT,LPDDSURFACEDESC,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface3AggUnlock(IDirectDrawSurface3 *, LPVOID);
STDMETHODIMP IDirectDrawSurface3AggSetSurfaceDesc(IDirectDrawSurface3 *, LPDDSURFACEDESC, DWORD);
STDMETHODIMP IDirectDrawSurface3AggGetAttachedSurface( IDirectDrawSurface3 *, LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *);
STDMETHODIMP IDirectDrawSurface3AggAddAttachedSurface( IDirectDrawSurface3 *, LPDIRECTDRAWSURFACE3);
STDMETHODIMP IDirectDrawSurface3AggDeleteAttachedSurface( IDirectDrawSurface3 *,DWORD, LPDIRECTDRAWSURFACE3);
STDMETHODIMP IDirectDrawSurface3AggFlip(IDirectDrawSurface3 *, LPDIRECTDRAWSURFACE3, DWORD);
STDMETHODIMP IDirectDrawSurface3AggBlt(IDirectDrawSurface3 *,LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface3AggGetPalette(IDirectDrawSurface3 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface3AggSetPalette(IDirectDrawSurface3 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface3AggGetDDInterface(IDirectDrawSurface3 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface3AggGetSurfaceDesc(IDirectDrawSurface3 *, LPDDSURFACEDESC);







/*** IDirectDrawSurface3 methods ***/
FORWARD1(IDirectDrawSurface3, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface3, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface3, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface3, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD3(IDirectDrawSurface3, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK)
FORWARD2(IDirectDrawSurface3, Flip, LPDIRECTDRAWSURFACE3, DWORD)
FORWARD1(IDirectDrawSurface3, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface3, GetCaps, LPDDSCAPS)
FORWARD1(IDirectDrawSurface3, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface3, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface3, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface3, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface3, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface3, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC)
FORWARD0(IDirectDrawSurface3, IsLost)
FORWARD0(IDirectDrawSurface3, Restore)
FORWARD1(IDirectDrawSurface3, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface3, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface3, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface3, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface3, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface3, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE3)
FORWARD1(IDirectDrawSurface3, PageLock, DWORD)
FORWARD1(IDirectDrawSurface3, PageUnlock, DWORD)
FORWARD2(IDirectDrawSurface3, SetSurfaceDesc, LPDDSURFACEDESC, DWORD )

IDirectDrawSurface3Vtbl g_DirectDrawSurface3Vtbl_DX3 =
{
    IDirectDrawSurface3AggQueryInterface,
    IDirectDrawSurface3AggAddRef,
    IDirectDrawSurface3AggRelease,
    IDirectDrawSurface3AggAddAttachedSurface,
    IDirectDrawSurface3AddOverlayDirtyRect,
    IDirectDrawSurface3AggBlt,
    IDirectDrawSurface3BltBatch,
    IDirectDrawSurface3BltFast,
    IDirectDrawSurface3AggDeleteAttachedSurface,
    IDirectDrawSurface3EnumAttachedSurfaces,
    IDirectDrawSurface3EnumOverlayZOrders,
    IDirectDrawSurface3AggFlip,
    IDirectDrawSurface3AggGetAttachedSurface,
    IDirectDrawSurface3GetBltStatus,
    IDirectDrawSurface3GetCaps,
    IDirectDrawSurface3GetClipper,
    IDirectDrawSurface3GetColorKey,
    IDirectDrawSurface3AggGetDC,
    IDirectDrawSurface3GetFlipStatus,
    IDirectDrawSurface3GetOverlayPosition,
    IDirectDrawSurface3AggGetPalette,
    IDirectDrawSurface3GetPixelFormat,
    IDirectDrawSurface3AggGetSurfaceDesc,
    IDirectDrawSurface3Initialize,
    IDirectDrawSurface3IsLost,
    IDirectDrawSurface3AggLock,
    IDirectDrawSurface3AggReleaseDC,
    IDirectDrawSurface3Restore,
    IDirectDrawSurface3SetClipper,
    IDirectDrawSurface3SetColorKey,
    IDirectDrawSurface3SetOverlayPosition,
    IDirectDrawSurface3AggSetPalette,
    IDirectDrawSurface3AggUnlock,
    IDirectDrawSurface3UpdateOverlay,
    IDirectDrawSurface3UpdateOverlayDisplay,
    IDirectDrawSurface3UpdateOverlayZOrder,
    IDirectDrawSurface3AggGetDDInterface,
    IDirectDrawSurface3PageLock,
    IDirectDrawSurface3PageUnlock,
    IDirectDrawSurface3AggSetSurfaceDesc
};

IDirectDrawSurface3Vtbl g_DirectDrawSurface3Vtbl_DX5 =
{
    IDirectDrawSurface3AggQueryInterface,
    IDirectDrawSurface3AggAddRef,
    IDirectDrawSurface3AggRelease,
    IDirectDrawSurface3AggAddAttachedSurface,
    IDirectDrawSurface3AddOverlayDirtyRect,
    IDirectDrawSurface3AggBlt,
    IDirectDrawSurface3BltBatch,
    IDirectDrawSurface3BltFast,
    IDirectDrawSurface3AggDeleteAttachedSurface,
    IDirectDrawSurface3EnumAttachedSurfaces,
    IDirectDrawSurface3EnumOverlayZOrders,
    IDirectDrawSurface3AggFlip,
    IDirectDrawSurface3AggGetAttachedSurface,
    IDirectDrawSurface3GetBltStatus,
    IDirectDrawSurface3GetCaps,
    IDirectDrawSurface3GetClipper,
    IDirectDrawSurface3GetColorKey,
    IDirectDrawSurface3AggGetDC,
    IDirectDrawSurface3GetFlipStatus,
    IDirectDrawSurface3GetOverlayPosition,
    IDirectDrawSurface3AggGetPalette,
    IDirectDrawSurface3GetPixelFormat,
    IDirectDrawSurface3AggGetSurfaceDesc,
    IDirectDrawSurface3Initialize,
    IDirectDrawSurface3IsLost,
    IDirectDrawSurface3AggLock,
    IDirectDrawSurface3AggReleaseDC,
    IDirectDrawSurface3Restore,
    IDirectDrawSurface3SetClipper,
    IDirectDrawSurface3SetColorKey,
    IDirectDrawSurface3SetOverlayPosition,
    IDirectDrawSurface3AggSetPalette,
    IDirectDrawSurface3AggUnlock,
    IDirectDrawSurface3UpdateOverlay,
    IDirectDrawSurface3UpdateOverlayDisplay,
    IDirectDrawSurface3UpdateOverlayZOrder,
    IDirectDrawSurface3AggGetDDInterface,
    IDirectDrawSurface3PageLock,
    IDirectDrawSurface3PageUnlock,
    IDirectDrawSurface3SetSurfaceDesc
};

/*
 * IDirectDrawSurface4
 */
STDMETHODIMP IDirectDrawSurface4AggQueryInterface(IDirectDrawSurface4 *pDDS4, REFIID riid, void ** ppv)
{
    return __QI(SURFACEOF(pDDS4)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggAddRef(IDirectDrawSurface4 *);
STDMETHODIMP_(ULONG) IDirectDrawSurface4AggRelease(IDirectDrawSurface4 *);
STDMETHODIMP IDirectDrawSurface4AggGetDC(IDirectDrawSurface4 *, HDC *);
STDMETHODIMP IDirectDrawSurface4AggReleaseDC(IDirectDrawSurface4 *, HDC);
STDMETHODIMP IDirectDrawSurface4AggLock(IDirectDrawSurface4 *, LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE);
STDMETHODIMP IDirectDrawSurface4AggUnlock(IDirectDrawSurface4 *, LPRECT);
STDMETHODIMP IDirectDrawSurface4AggSetSurfaceDesc(IDirectDrawSurface4 *, LPDDSURFACEDESC, DWORD);
STDMETHODIMP IDirectDrawSurface4AggGetAttachedSurface( IDirectDrawSurface4 *, LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *);
STDMETHODIMP IDirectDrawSurface4AggAddAttachedSurface( IDirectDrawSurface4 *, LPDIRECTDRAWSURFACE4);
STDMETHODIMP IDirectDrawSurface4AggDeleteAttachedSurface( IDirectDrawSurface4 *,DWORD, LPDIRECTDRAWSURFACE4);
STDMETHODIMP IDirectDrawSurface4AggFlip(IDirectDrawSurface4 *, LPDIRECTDRAWSURFACE4, DWORD);
STDMETHODIMP IDirectDrawSurface4AggBlt(IDirectDrawSurface4 *,LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX);
STDMETHODIMP IDirectDrawSurface4AggGetPalette(IDirectDrawSurface4 *, LPDIRECTDRAWPALETTE FAR *);
STDMETHODIMP IDirectDrawSurface4AggSetPalette(IDirectDrawSurface4 *, LPDIRECTDRAWPALETTE);
STDMETHODIMP IDirectDrawSurface4AggGetDDInterface(IDirectDrawSurface4 *, LPVOID FAR *);
STDMETHODIMP IDirectDrawSurface4AggGetSurfaceDesc(IDirectDrawSurface4 *, LPDDSURFACEDESC2);







/*** IDirectDrawSurface4 methods ***/
FORWARD1(IDirectDrawSurface4, AddOverlayDirtyRect, LPRECT)
FORWARD3(IDirectDrawSurface4, BltBatch, LPDDBLTBATCH, DWORD, DWORD )
FORWARD5(IDirectDrawSurface4, BltFast, DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD)
FORWARD2(IDirectDrawSurface4, EnumAttachedSurfaces, LPVOID,LPDDENUMSURFACESCALLBACK2)
FORWARD3(IDirectDrawSurface4, EnumOverlayZOrders, DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2)
FORWARD2(IDirectDrawSurface4, Flip, LPDIRECTDRAWSURFACE4, DWORD)
FORWARD1(IDirectDrawSurface4, GetBltStatus, DWORD)
FORWARD1(IDirectDrawSurface4, GetCaps, LPDDSCAPS2)
FORWARD1(IDirectDrawSurface4, GetClipper, LPDIRECTDRAWCLIPPER FAR*)
FORWARD2(IDirectDrawSurface4, GetColorKey, DWORD, LPDDCOLORKEY)
FORWARD1(IDirectDrawSurface4, GetFlipStatus, DWORD)
FORWARD2(IDirectDrawSurface4, GetOverlayPosition, LPLONG, LPLONG )
FORWARD1(IDirectDrawSurface4, GetPixelFormat, LPDDPIXELFORMAT)
FORWARD2(IDirectDrawSurface4, Initialize, LPDIRECTDRAW, LPDDSURFACEDESC2)
FORWARD0(IDirectDrawSurface4, IsLost)
FORWARD0(IDirectDrawSurface4, Restore)
FORWARD1(IDirectDrawSurface4, SetClipper, LPDIRECTDRAWCLIPPER)
FORWARD2(IDirectDrawSurface4, SetColorKey, DWORD, LPDDCOLORKEY)
FORWARD2(IDirectDrawSurface4, SetOverlayPosition, LONG, LONG )
FORWARD5(IDirectDrawSurface4, UpdateOverlay, LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX)
FORWARD1(IDirectDrawSurface4, UpdateOverlayDisplay, DWORD)
FORWARD2(IDirectDrawSurface4, UpdateOverlayZOrder, DWORD, LPDIRECTDRAWSURFACE4)
FORWARD1(IDirectDrawSurface4, PageLock, DWORD)
FORWARD1(IDirectDrawSurface4, PageUnlock, DWORD)
FORWARD2(IDirectDrawSurface4, SetSurfaceDesc, LPDDSURFACEDESC2, DWORD )
FORWARD4(IDirectDrawSurface4, SetPrivateData, REFGUID, LPVOID, DWORD, DWORD )
FORWARD3(IDirectDrawSurface4, GetPrivateData, REFGUID, LPVOID, LPDWORD)
FORWARD1(IDirectDrawSurface4, FreePrivateData, REFGUID )
FORWARD1(IDirectDrawSurface4, GetUniquenessValue, LPDWORD )
FORWARD0(IDirectDrawSurface4, ChangeUniquenessValue )


IDirectDrawSurface4Vtbl g_DirectDrawSurface4Vtbl =
{
    IDirectDrawSurface4AggQueryInterface,
    IDirectDrawSurface4AggAddRef,
    IDirectDrawSurface4AggRelease,
    IDirectDrawSurface4AggAddAttachedSurface,
    IDirectDrawSurface4AddOverlayDirtyRect,
    IDirectDrawSurface4AggBlt,
    IDirectDrawSurface4BltBatch,
    IDirectDrawSurface4BltFast,
    IDirectDrawSurface4AggDeleteAttachedSurface,
    IDirectDrawSurface4EnumAttachedSurfaces,
    IDirectDrawSurface4EnumOverlayZOrders,
    IDirectDrawSurface4AggFlip,
    IDirectDrawSurface4AggGetAttachedSurface,
    IDirectDrawSurface4GetBltStatus,
    IDirectDrawSurface4GetCaps,
    IDirectDrawSurface4GetClipper,
    IDirectDrawSurface4GetColorKey,
    IDirectDrawSurface4AggGetDC,
    IDirectDrawSurface4GetFlipStatus,
    IDirectDrawSurface4GetOverlayPosition,
    IDirectDrawSurface4AggGetPalette,
    IDirectDrawSurface4GetPixelFormat,
    IDirectDrawSurface4AggGetSurfaceDesc,
    IDirectDrawSurface4Initialize,
    IDirectDrawSurface4IsLost,
    IDirectDrawSurface4AggLock,
    IDirectDrawSurface4AggReleaseDC,
    IDirectDrawSurface4Restore,
    IDirectDrawSurface4SetClipper,
    IDirectDrawSurface4SetColorKey,
    IDirectDrawSurface4SetOverlayPosition,
    IDirectDrawSurface4AggSetPalette,
    IDirectDrawSurface4AggUnlock,
    IDirectDrawSurface4UpdateOverlay,
    IDirectDrawSurface4UpdateOverlayDisplay,
    IDirectDrawSurface4UpdateOverlayZOrder,
    IDirectDrawSurface4AggGetDDInterface,
    IDirectDrawSurface4PageLock,
    IDirectDrawSurface4PageUnlock,
    IDirectDrawSurface4SetSurfaceDesc,
    IDirectDrawSurface4SetPrivateData,
    IDirectDrawSurface4GetPrivateData,
    IDirectDrawSurface4FreePrivateData,
    IDirectDrawSurface4GetUniquenessValue,
    IDirectDrawSurface4ChangeUniquenessValue
};



/*
 * IDirectDrawPalette
 */
STDMETHODIMP IDirectDrawPaletteAggQueryInterface(IDirectDrawPalette *pDDP, REFIID riid, void ** ppv)
{
    return __QI(PALETTEOF(pDDP)->m_pUnkOuter, riid, ppv);
}
STDMETHODIMP_(ULONG) IDirectDrawPaletteAggAddRef(IDirectDrawPalette *);
STDMETHODIMP_(ULONG) IDirectDrawPaletteAggRelease(IDirectDrawPalette *);
STDMETHODIMP IDirectDrawPaletteAggSetEntries(IDirectDrawPalette *,DWORD,DWORD,DWORD,LPPALETTEENTRY);

/*** IDirectDrawPalette methods ***/
FORWARD1(IDirectDrawPalette, GetCaps, LPDWORD);
FORWARD4(IDirectDrawPalette, GetEntries, DWORD,DWORD,DWORD,LPPALETTEENTRY);
FORWARD3(IDirectDrawPalette, Initialize, LPDIRECTDRAW, DWORD, LPPALETTEENTRY);

IDirectDrawPaletteVtbl g_DirectDrawPaletteVtbl =
{
    IDirectDrawPaletteAggQueryInterface,
    IDirectDrawPaletteAggAddRef,
    IDirectDrawPaletteAggRelease,
    IDirectDrawPaletteGetCaps,
    IDirectDrawPaletteGetEntries,
    IDirectDrawPaletteInitialize,
    IDirectDrawPaletteAggSetEntries
};


/*
 * InitDirectDrawInterfaces
 *
 * set up our ddraw interface data
 */
void __stdcall InitDirectDrawInterfaces(
	IDirectDraw *pDD,
	INTSTRUC_IDirectDraw *pDDInt,
	IDirectDraw2 *pDD2,
	INTSTRUC_IDirectDraw2 *pDD2Int,
        IDirectDraw4 *pDD4,
        INTSTRUC_IDirectDraw4 *pDD4Int)

{
    memcpy(pDDInt,  pDD,  sizeof(REALDDINTSTRUC));
    memcpy(pDD2Int, pDD2, sizeof(REALDDINTSTRUC));
    pDDInt->lpVtbl = &g_DirectDrawVtbl;
    pDD2Int->lpVtbl = &g_DirectDraw2Vtbl;
    if (pDD4)
    {
        memcpy(pDD4Int, pDD4, sizeof(REALDDINTSTRUC));
        pDD4Int->lpVtbl = &g_DirectDraw4Vtbl;
    }
    else
    {
        memset(pDD4Int, 0, sizeof(*pDD4Int));
    }
} /* InitDirectDrawInterfaces */


void __stdcall InitDirectDrawPaletteInterfaces(
	IDirectDrawPalette *pDDPalette,
	INTSTRUC_IDirectDrawPalette *pDDInt)

{
    memcpy(pDDInt,  pDDPalette,  sizeof(REALDDINTSTRUC));
    pDDInt->lpVtbl = &g_DirectDrawPaletteVtbl;
}

/*
 * InitSurfaceInterfaces
 *
 * set up our ddraw surface interface data
 */
void __stdcall InitSurfaceInterfaces(
			IDirectDrawSurface *pDDSurface,
			INTSTRUC_IDirectDrawSurface *pDDSInt,
			IDirectDrawSurface2 *pDDSurface2,
			INTSTRUC_IDirectDrawSurface2 *pDDS2Int,
			IDirectDrawSurface3 *pDDSurface3,
			INTSTRUC_IDirectDrawSurface3 *pDDS3Int,
			IDirectDrawSurface4 *pDDSurface4,
			INTSTRUC_IDirectDrawSurface4 *pDDS4Int
                        )
{
    memcpy(pDDSInt,  pDDSurface,  sizeof(REALDDINTSTRUC));
    pDDSInt->lpVtbl = &g_DirectDrawSurfaceVtbl;

    memcpy(pDDS2Int, pDDSurface2, sizeof(REALDDINTSTRUC));
    pDDS2Int->lpVtbl = &g_DirectDrawSurface2Vtbl;

    #pragma message( REMIND( "Would it be better to have 1 table and change the SetSurfaceDesc member?" ))
    if( pDDSurface3 != NULL )
    {
	memcpy(pDDS3Int, pDDSurface3, sizeof(REALDDINTSTRUC));
	pDDS3Int->lpVtbl = &g_DirectDrawSurface3Vtbl_DX5;
    }
    else
    {
	memcpy(pDDS3Int, pDDSurface2, sizeof(REALDDINTSTRUC));
	pDDS3Int->lpVtbl = &g_DirectDrawSurface3Vtbl_DX3;
    }

    if (pDDSurface4)
    {
        memcpy(pDDS4Int, pDDSurface4, sizeof(REALDDINTSTRUC));
        pDDS4Int->lpVtbl = &g_DirectDrawSurface4Vtbl;
    }
    else
    {
        memset(pDDS4Int, 0, sizeof(*pDDS4Int));
    }

} /* InitSurfaceInterfaces */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\32to16.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 20 10:27:33 1997

;Command Line: thunk -P2 -NC ddraw -t thk3216 ..\32to16.thk -o 32to16.asm 

	TITLE	$32to16.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapSL	PROTO NEAR STDCALL p32:DWORD



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public thk3216_ThunkData32	;This symbol must be exported.
thk3216_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	0210141h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_thk3216 - offset thk3216_ThunkData32
	dd	offset FT_Prolog_thk3216 - offset thk3216_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public thk3216_ThunkConnect32@16
thk3216_ThunkConnect32@16:
	pop	edx
	push	offset thk3216_ThkData16
	push	offset thk3216_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
thk3216_ThkData16 label byte
	db	"thk3216_ThunkData16",0


		


pfnQT_Thunk_thk3216	dd offset QT_Thunk_thk3216
pfnFT_Prolog_thk3216	dd offset FT_Prolog_thk3216
	.data
QT_Thunk_thk3216 label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_thk3216 label byte
	db	32 dup(0cch)	;Patch space.


	.code 





;************************ START OF THUNK BODIES************************




;
public DD16_GetMonitorMaxSize@4
DD16_GetMonitorMaxSize@4:
	mov	cl,54
; DD16_GetMonitorMaxSize(16) = DD16_GetMonitorMaxSize(32) {}
;
; dword ptr [ebp+8]:  dev
;
public IIDD16_GetMonitorMaxSize@4
IIDD16_GetMonitorMaxSize@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dev: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	4





;
public DD16_GetMonitorRefreshRateRanges@20
DD16_GetMonitorRefreshRateRanges@20:
	mov	cx, (5 SHL 10) + (0 SHL 8) + 53
; DD16_GetMonitorRefreshRateRanges(16) = DD16_GetMonitorRefreshRateRanges(32) {}
;
; dword ptr [ebp+8]:  dev
; dword ptr [ebp+12]:  xres
; dword ptr [ebp+16]:  yres
; dword ptr [ebp+20]:  pmin
; dword ptr [ebp+24]:  pmax
;
public IIDD16_GetMonitorRefreshRateRanges@20
IIDD16_GetMonitorRefreshRateRanges@20:
	call	dword ptr [pfnFT_Prolog_thk3216]
	xor	eax,eax
	push	eax
	push	eax
	mov	edx, dword ptr [ebp+20]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	@F
	or	dword ptr [edx], 0
@@:
	push	dword ptr [ebp+8]	;dev: dword->dword
	push	word ptr [ebp+12]	;xres: dword->word
	push	word ptr [ebp+16]	;yres: dword->word
	mov	eax, dword ptr [ebp+20]
	call	SMapLS
	mov	[ebp-68],edx
	push	eax
	mov	eax, dword ptr [ebp+24]
	call	SMapLS
	mov	[ebp-72],edx
	push	eax
	call	FT_Thunk
	movsx	ebx,ax
	mov	edx, dword ptr [ebp+20]
	or	edx,edx
	jz	L0
	movsx	ecx, word ptr [edx]
	mov	dword ptr [edx], ecx
L0:
	mov	ecx, dword ptr [ebp-68]
	call	SUnMapLS
	mov	edx, dword ptr [ebp+24]
	or	edx,edx
	jz	L1
	movsx	ecx, word ptr [edx]
	mov	dword ptr [edx], ecx
L1:
	mov	ecx, dword ptr [ebp-72]
	call	SUnMapLS
	jmp	FT_Exit20





;
public DD16_IsWin95MiniDriver@0
DD16_IsWin95MiniDriver@0:
	mov	cl,51
; DD16_IsWin95MiniDriver(16) = DD16_IsWin95MiniDriver(32) {}
;
;
public IIDD16_IsWin95MiniDriver@0
IIDD16_IsWin95MiniDriver@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn





;
public ModeX_SetPaletteEntries@12
ModeX_SetPaletteEntries@12:
	mov	cl,50
; ModeX_SetPaletteEntries(16) = ModeX_SetPaletteEntries(32) {}
;
; dword ptr [ebp+8]:  wBase
; dword ptr [ebp+12]:  wNum
; dword ptr [ebp+16]:  lpPaletteEntries
;
public IIModeX_SetPaletteEntries@12
IIModeX_SetPaletteEntries@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wBase: dword->word
	push	word ptr [ebp+12]	;wNum: dword->word
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public ModeX_SetMode@8
ModeX_SetMode@8:
	mov	cl,49
; ModeX_SetMode(16) = ModeX_SetMode(32) {}
;
; dword ptr [ebp+8]:  wWidth
; dword ptr [ebp+12]:  wHeight
;
public IIModeX_SetMode@8
IIModeX_SetMode@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;wWidth: dword->word
	push	word ptr [ebp+12]	;wHeight: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	8





;
public ModeX_RestoreMode@0
ModeX_RestoreMode@0:
	mov	cl,48
; ModeX_RestoreMode(16) = ModeX_RestoreMode(32) {}
;
;
public IIModeX_RestoreMode@0
IIModeX_RestoreMode@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn





;
public ModeX_Flip@4
ModeX_Flip@4:
	mov	cl,47
; ModeX_Flip(16) = ModeX_Flip(32) {}
;
; dword ptr [ebp+8]:  lpBackBuffer
;
public IIModeX_Flip@4
IIModeX_Flip@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;lpBackBuffer: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	leave
	retn	4





;
public DD16_SetEventHandle@8
DD16_SetEventHandle@8:
	mov	cl,46
; DD16_SetEventHandle(16) = DD16_SetEventHandle(32) {}
;
; dword ptr [ebp+8]:  hInstance
; dword ptr [ebp+12]:  dwEvent
;
public IIDD16_SetEventHandle@8
IIDD16_SetEventHandle@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;hInstance: dword->dword
	push	dword ptr [ebp+12]	;dwEvent: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	8





;
public DD16_ChangeDisplaySettings@8
DD16_ChangeDisplaySettings@8:
	mov	cl,42
; DD16_ChangeDisplaySettings(16) = DD16_ChangeDisplaySettings(32) {}
;
; dword ptr [ebp+8]:  pdm
; dword ptr [ebp+12]:  flags
;
public IIDD16_ChangeDisplaySettings@8
IIDD16_ChangeDisplaySettings@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	dword ptr [ebp+12]	;flags: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_8
	leave
	retn	8





;
public DD16_SafeMode@8
DD16_SafeMode@8:
	mov	cl,41
; DD16_SafeMode(16) = DD16_SafeMode(32) {}
;
; dword ptr [ebp+8]:  hdc
; dword ptr [ebp+12]:  fSafeMode
;
public IIDD16_SafeMode@8
IIDD16_SafeMode@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	push	word ptr [ebp+12]	;fSafeMode: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	8





;
public DD16_GetDC@4
DD16_GetDC@4:
	mov	cl,40
; DD16_GetDC(16) = DD16_GetDC(32) {}
;
; dword ptr [ebp+8]:  pddsd
;
public IIDD16_GetDC@4
IIDD16_GetDC@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DD16_Exclude@8
DD16_Exclude@8:
	mov	cl,38
; DD16_Exclude(16) = DD16_Exclude(32) {}
;
; dword ptr [ebp+8]:  dwPDevice
; dword ptr [ebp+12]:  prcl
;
public IIDD16_Exclude@8
IIDD16_Exclude@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwPDevice: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public DD16_Unexclude@4
DD16_Unexclude@4:
	mov	cl,37
	jmp	IIDD16_Unexclude@4
public DD16_DoneDriver@4
DD16_DoneDriver@4:
	mov	cl,45
; DD16_Unexclude(16) = DD16_Unexclude(32) {}
;
; dword ptr [ebp+8]:  dwPDevice
;
public IIDD16_Unexclude@4
IIDD16_Unexclude@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwPDevice: dword->dword
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	4





;
public DD16_Stretch@56
DD16_Stretch@56:
	mov	cl,36
; DD16_Stretch(16) = DD16_Stretch(32) {}
;
; dword ptr [ebp+8]:  DstPtr
; dword ptr [ebp+12]:  DstPitch
; dword ptr [ebp+16]:  DstBPP
; dword ptr [ebp+20]:  DstX
; dword ptr [ebp+24]:  DstY
; dword ptr [ebp+28]:  DstDX
; dword ptr [ebp+32]:  DstDY
; dword ptr [ebp+36]:  SrcPtr
; dword ptr [ebp+40]:  SrcPitch
; dword ptr [ebp+44]:  SrcBPP
; dword ptr [ebp+48]:  SrcX
; dword ptr [ebp+52]:  SrcY
; dword ptr [ebp+56]:  SrcDX
; dword ptr [ebp+60]:  SrcDY
;
public IIDD16_Stretch@56
IIDD16_Stretch@56:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;DstPtr: dword->dword
	push	word ptr [ebp+12]	;DstPitch: dword->word
	push	word ptr [ebp+16]	;DstBPP: dword->word
	push	word ptr [ebp+20]	;DstX: dword->word
	push	word ptr [ebp+24]	;DstY: dword->word
	push	word ptr [ebp+28]	;DstDX: dword->word
	push	word ptr [ebp+32]	;DstDY: dword->word
	push	dword ptr [ebp+36]	;SrcPtr: dword->dword
	push	word ptr [ebp+40]	;SrcPitch: dword->word
	push	word ptr [ebp+44]	;SrcBPP: dword->word
	push	word ptr [ebp+48]	;SrcX: dword->word
	push	word ptr [ebp+52]	;SrcY: dword->word
	push	word ptr [ebp+56]	;SrcDX: dword->word
	push	word ptr [ebp+60]	;SrcDY: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	56





;
public DD16_SelectPalette@12
DD16_SelectPalette@12:
	mov	cl,35
; DD16_SelectPalette(16) = DD16_SelectPalette(32) {}
;
; dword ptr [ebp+8]:  hDC
; dword ptr [ebp+12]:  hPalette
; dword ptr [ebp+16]:  f
;
public IIDD16_SelectPalette@12
IIDD16_SelectPalette@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hDC: dword->word
	push	word ptr [ebp+12]	;hPalette: dword->word
	push	word ptr [ebp+16]	;f: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	12





;
public DD16_InquireVisRgn@4
DD16_InquireVisRgn@4:
	mov	cl,34
; DD16_InquireVisRgn(16) = DD16_InquireVisRgn(32) {}
;
; dword ptr [ebp+8]:  hDC
;
public IIDD16_InquireVisRgn@4
IIDD16_InquireVisRgn@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hDC: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	leave
	retn	4





;
public DD16_GetPaletteEntries@12
DD16_GetPaletteEntries@12:
	mov	cl,31
	jmp	IIDD16_GetPaletteEntries@12
public DD16_SetPaletteEntries@12
DD16_SetPaletteEntries@12:
	mov	cl,32
; DD16_GetPaletteEntries(16) = DD16_GetPaletteEntries(32) {}
;
; dword ptr [ebp+8]:  dwBase
; dword ptr [ebp+12]:  dwNum
; dword ptr [ebp+16]:  lpPaletteEntries
;
public IIDD16_GetPaletteEntries@12
IIDD16_GetPaletteEntries@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwBase: dword->dword
	push	dword ptr [ebp+12]	;dwNum: dword->dword
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public DDThunk16_SetEntries@4
DDThunk16_SetEntries@4:
	mov	cx, (1 SHL 10) + (0 SHL 8) + 20
; DDThunk16_SetEntries(16) = DDThunk16_SetEntries(32) {}
;
; dword ptr [ebp+8]:  lpSetEntriesData
;
public IIDDThunk16_SetEntries@4
IIDDThunk16_SetEntries@4:
	call	dword ptr [pfnFT_Prolog_thk3216]
	xor	eax,eax
	push	eax
	sub	esp,28
	mov	esi,[ebp+8]
	or	esi,esi
	jz	@F
	or	byte ptr [esi], 0
	or	byte ptr [esi + 27], 0
@@:
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L2
	push	esi
	jmp	L3
L2:
	lea	edi,[ebp-96]
	push	edi	;lpSetEntriesData: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,4
	rep	movsd
	lodsd	;lpEntries  near32->far16
	call	SMapLS
	mov	[ebp-68],edx
	stosd
	movsd
	movsd
L3:
	call	FT_Thunk
	shrd	ebx,edx,16
	mov	bx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L4
	lea	esi,[ebp-96]	;lpSetEntriesData  Struct16->Struct32
	mov	ecx,4
	rep	movsd
	lodsd	;lpEntries   far16->near32
	push	eax
	call	MapSL
	stosd
	movsd
	movsd
L4:
	mov	ecx, [ebp-68]	;lpEntries
	call	SUnMapLS
	jmp	FT_Exit4





;
public DDThunk16_GetFlipStatus@4
DDThunk16_GetFlipStatus@4:
	mov	cl,7
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CreatePalette@4
DDThunk16_CreatePalette@4:
	mov	cl,30
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CreateSurface@4
DDThunk16_CreateSurface@4:
	mov	cl,29
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_CanCreateSurface@4
DDThunk16_CanCreateSurface@4:
	mov	cl,28
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_WaitForVerticalBlank@4
DDThunk16_WaitForVerticalBlank@4:
	mov	cl,27
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroyDriver@4
DDThunk16_DestroyDriver@4:
	mov	cl,26
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetMode@4
DDThunk16_SetMode@4:
	mov	cl,25
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_GetScanLine@4
DDThunk16_GetScanLine@4:
	mov	cl,24
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetExclusiveMode@4
DDThunk16_SetExclusiveMode@4:
	mov	cl,23
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_FlipToGDISurface@4
DDThunk16_FlipToGDISurface@4:
	mov	cl,22
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroyPalette@4
DDThunk16_DestroyPalette@4:
	mov	cl,21
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_DestroySurface@4
DDThunk16_DestroySurface@4:
	mov	cl,19
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Flip@4
DDThunk16_Flip@4:
	mov	cl,18
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Blt@4
DDThunk16_Blt@4:
	mov	cl,17
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Lock@4
DDThunk16_Lock@4:
	mov	cl,16
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_Unlock@4
DDThunk16_Unlock@4:
	mov	cl,15
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_AddAttachedSurface@4
DDThunk16_AddAttachedSurface@4:
	mov	cl,14
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetColorKey@4
DDThunk16_SetColorKey@4:
	mov	cl,13
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetClipList@4
DDThunk16_SetClipList@4:
	mov	cl,12
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_UpdateOverlay@4
DDThunk16_UpdateOverlay@4:
	mov	cl,11
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetOverlayPosition@4
DDThunk16_SetOverlayPosition@4:
	mov	cl,10
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_SetPalette@4
DDThunk16_SetPalette@4:
	mov	cl,9
	jmp	IIDDThunk16_GetFlipStatus@4
public DDThunk16_GetBltStatus@4
DDThunk16_GetBltStatus@4:
	mov	cl,8
; DDThunk16_GetFlipStatus(16) = DDThunk16_GetFlipStatus(32) {}
;
; dword ptr [ebp+8]:  lpGetFlipStatusData
;
public IIDDThunk16_GetFlipStatus@4
IIDDThunk16_GetFlipStatus@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	shl	eax,16
	shrd	eax,edx,16
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DCIIsBanked@4
DCIIsBanked@4:
	mov	cl,6
; DCIIsBanked(16) = DCIIsBanked(32) {}
;
; dword ptr [ebp+8]:  hdc
;
public IIDCIIsBanked@4
IIDCIIsBanked@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	leave
	retn	4





;
public DCIOpenProvider@0
DCIOpenProvider@0:
	mov	cl,5
; DCIOpenProvider(16) = DCIOpenProvider(32) {}
;
;
public IIDCIOpenProvider@0
IIDCIOpenProvider@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk3216]
	movzx	eax,ax
	leave
	retn





;
public DCICloseProvider@4
DCICloseProvider@4:
	mov	cl,4
	jmp	IIDCICloseProvider@4
public DD16_SetCertified@4
DD16_SetCertified@4:
	mov	cl,52
	jmp	IIDCICloseProvider@4
public DD16_ReleaseDC@4
DD16_ReleaseDC@4:
	mov	cl,39
	jmp	IIDCICloseProvider@4
public DD16_EnableReboot@4
DD16_EnableReboot@4:
	mov	cl,33
; DCICloseProvider(16) = DCICloseProvider(32) {}
;
; dword ptr [ebp+8]:  hdc
;
public IIDCICloseProvider@4
IIDCICloseProvider@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	leave
	retn	4





;
public DCICreatePrimary32@8
DCICreatePrimary32@8:
	mov	cl,3
; DCICreatePrimary32(16) = DCICreatePrimary32(32) {}
;
; dword ptr [ebp+8]:  hdc
; dword ptr [ebp+12]:  lpSurface
;
public IIDCICreatePrimary32@8
IIDCICreatePrimary32@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hdc: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public DCIEndAccess@4
DCIEndAccess@4:
	mov	cl,1
	jmp	IIDCIEndAccess@4
public DD16_GetDriverFns@4
DD16_GetDriverFns@4:
	mov	cl,44
	jmp	IIDCIEndAccess@4
public DD16_GetHALInfo@4
DD16_GetHALInfo@4:
	mov	cl,43
	jmp	IIDCIEndAccess@4
public DCIDestroy32@4
DCIDestroy32@4:
	mov	cl,2
; DCIEndAccess(16) = DCIEndAccess(32) {}
;
; dword ptr [ebp+8]:  pdci
;
public IIDCIEndAccess@4
IIDCIEndAccess@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk3216]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public DCIBeginAccess@20
DCIBeginAccess@20:
	mov	cl,0
; DCIBeginAccess(16) = DCIBeginAccess(32) {}
;
; dword ptr [ebp+8]:  pdci
; dword ptr [ebp+12]:  x
; dword ptr [ebp+16]:  y
; dword ptr [ebp+20]:  dx
; dword ptr [ebp+24]:  dy
;
public IIDCIBeginAccess@20
IIDCIBeginAccess@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;x: dword->word
	push	word ptr [ebp+16]	;y: dword->word
	push	word ptr [ebp+20]	;dx: dword->word
	push	word ptr [ebp+24]	;dy: dword->word
	call	dword ptr [pfnQT_Thunk_thk3216]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	20




ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	ddraw



externDef DCIBeginAccess:far16
externDef DCIEndAccess:far16
externDef DCIDestroy:far16
externDef DCICreatePrimary32:far16
externDef DCICloseProvider:far16
externDef DCIOpenProvider:far16
externDef DCIIsBanked:far16
externDef DDThunk16_GetFlipStatus:far16
externDef DDThunk16_GetBltStatus:far16
externDef DDThunk16_SetPalette:far16
externDef DDThunk16_SetOverlayPosition:far16
externDef DDThunk16_UpdateOverlay:far16
externDef DDThunk16_SetClipList:far16
externDef DDThunk16_SetColorKey:far16
externDef DDThunk16_AddAttachedSurface:far16
externDef DDThunk16_Unlock:far16
externDef DDThunk16_Lock:far16
externDef DDThunk16_Blt:far16
externDef DDThunk16_Flip:far16
externDef DDThunk16_DestroySurface:far16
externDef DDThunk16_SetEntries:far16
externDef DDThunk16_DestroyPalette:far16
externDef DDThunk16_FlipToGDISurface:far16
externDef DDThunk16_SetExclusiveMode:far16
externDef DDThunk16_GetScanLine:far16
externDef DDThunk16_SetMode:far16
externDef DDThunk16_DestroyDriver:far16
externDef DDThunk16_WaitForVerticalBlank:far16
externDef DDThunk16_CanCreateSurface:far16
externDef DDThunk16_CreateSurface:far16
externDef DDThunk16_CreatePalette:far16
externDef DD16_GetPaletteEntries:far16
externDef DD16_SetPaletteEntries:far16
externDef DD16_EnableReboot:far16
externDef DD16_InquireVisRgn:far16
externDef DD16_SelectPalette:far16
externDef DD16_Stretch:far16
externDef DD16_Unexclude:far16
externDef DD16_Exclude:far16
externDef DD16_ReleaseDC:far16
externDef DD16_GetDC:far16
externDef DD16_SafeMode:far16
externDef DD16_ChangeDisplaySettings:far16
externDef DD16_GetHALInfo:far16
externDef DD16_GetDriverFns:far16
externDef DD16_DoneDriver:far16
externDef DD16_SetEventHandle:far16
externDef ModeX_Flip:far16
externDef ModeX_RestoreMode:far16
externDef ModeX_SetMode:far16
externDef ModeX_SetPaletteEntries:far16
externDef DD16_IsWin95MiniDriver:far16
externDef DD16_SetCertified:far16
externDef DD16_GetMonitorRefreshRateRanges:far16
externDef DD16_GetMonitorMaxSize:far16


FT_thk3216TargetTable label word
	dw	offset DCIBeginAccess
	dw	   seg DCIBeginAccess
	dw	offset DCIEndAccess
	dw	   seg DCIEndAccess
	dw	offset DCIDestroy
	dw	   seg DCIDestroy
	dw	offset DCICreatePrimary32
	dw	   seg DCICreatePrimary32
	dw	offset DCICloseProvider
	dw	   seg DCICloseProvider
	dw	offset DCIOpenProvider
	dw	   seg DCIOpenProvider
	dw	offset DCIIsBanked
	dw	   seg DCIIsBanked
	dw	offset DDThunk16_GetFlipStatus
	dw	   seg DDThunk16_GetFlipStatus
	dw	offset DDThunk16_GetBltStatus
	dw	   seg DDThunk16_GetBltStatus
	dw	offset DDThunk16_SetPalette
	dw	   seg DDThunk16_SetPalette
	dw	offset DDThunk16_SetOverlayPosition
	dw	   seg DDThunk16_SetOverlayPosition
	dw	offset DDThunk16_UpdateOverlay
	dw	   seg DDThunk16_UpdateOverlay
	dw	offset DDThunk16_SetClipList
	dw	   seg DDThunk16_SetClipList
	dw	offset DDThunk16_SetColorKey
	dw	   seg DDThunk16_SetColorKey
	dw	offset DDThunk16_AddAttachedSurface
	dw	   seg DDThunk16_AddAttachedSurface
	dw	offset DDThunk16_Unlock
	dw	   seg DDThunk16_Unlock
	dw	offset DDThunk16_Lock
	dw	   seg DDThunk16_Lock
	dw	offset DDThunk16_Blt
	dw	   seg DDThunk16_Blt
	dw	offset DDThunk16_Flip
	dw	   seg DDThunk16_Flip
	dw	offset DDThunk16_DestroySurface
	dw	   seg DDThunk16_DestroySurface
	dw	offset DDThunk16_SetEntries
	dw	   seg DDThunk16_SetEntries
	dw	offset DDThunk16_DestroyPalette
	dw	   seg DDThunk16_DestroyPalette
	dw	offset DDThunk16_FlipToGDISurface
	dw	   seg DDThunk16_FlipToGDISurface
	dw	offset DDThunk16_SetExclusiveMode
	dw	   seg DDThunk16_SetExclusiveMode
	dw	offset DDThunk16_GetScanLine
	dw	   seg DDThunk16_GetScanLine
	dw	offset DDThunk16_SetMode
	dw	   seg DDThunk16_SetMode
	dw	offset DDThunk16_DestroyDriver
	dw	   seg DDThunk16_DestroyDriver
	dw	offset DDThunk16_WaitForVerticalBlank
	dw	   seg DDThunk16_WaitForVerticalBlank
	dw	offset DDThunk16_CanCreateSurface
	dw	   seg DDThunk16_CanCreateSurface
	dw	offset DDThunk16_CreateSurface
	dw	   seg DDThunk16_CreateSurface
	dw	offset DDThunk16_CreatePalette
	dw	   seg DDThunk16_CreatePalette
	dw	offset DD16_GetPaletteEntries
	dw	   seg DD16_GetPaletteEntries
	dw	offset DD16_SetPaletteEntries
	dw	   seg DD16_SetPaletteEntries
	dw	offset DD16_EnableReboot
	dw	   seg DD16_EnableReboot
	dw	offset DD16_InquireVisRgn
	dw	   seg DD16_InquireVisRgn
	dw	offset DD16_SelectPalette
	dw	   seg DD16_SelectPalette
	dw	offset DD16_Stretch
	dw	   seg DD16_Stretch
	dw	offset DD16_Unexclude
	dw	   seg DD16_Unexclude
	dw	offset DD16_Exclude
	dw	   seg DD16_Exclude
	dw	offset DD16_ReleaseDC
	dw	   seg DD16_ReleaseDC
	dw	offset DD16_GetDC
	dw	   seg DD16_GetDC
	dw	offset DD16_SafeMode
	dw	   seg DD16_SafeMode
	dw	offset DD16_ChangeDisplaySettings
	dw	   seg DD16_ChangeDisplaySettings
	dw	offset DD16_GetHALInfo
	dw	   seg DD16_GetHALInfo
	dw	offset DD16_GetDriverFns
	dw	   seg DD16_GetDriverFns
	dw	offset DD16_DoneDriver
	dw	   seg DD16_DoneDriver
	dw	offset DD16_SetEventHandle
	dw	   seg DD16_SetEventHandle
	dw	offset ModeX_Flip
	dw	   seg ModeX_Flip
	dw	offset ModeX_RestoreMode
	dw	   seg ModeX_RestoreMode
	dw	offset ModeX_SetMode
	dw	   seg ModeX_SetMode
	dw	offset ModeX_SetPaletteEntries
	dw	   seg ModeX_SetPaletteEntries
	dw	offset DD16_IsWin95MiniDriver
	dw	   seg DD16_IsWin95MiniDriver
	dw	offset DD16_SetCertified
	dw	   seg DD16_SetCertified
	dw	offset DD16_GetMonitorRefreshRateRanges
	dw	   seg DD16_GetMonitorRefreshRateRanges
	dw	offset DD16_GetMonitorMaxSize
	dw	   seg DD16_GetMonitorMaxSize




	.data

public thk3216_ThunkData16	;This symbol must be exported.
thk3216_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	0210141h	;Checksum
	dw	offset FT_thk3216TargetTable
	dw	seg    FT_thk3216TargetTable
	dd	0	;First-time flag.



	.code ddraw


externDef ThunkConnect16:far16

public thk3216_ThunkConnect16
thk3216_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk3216_ThunkData16
	push	offset thk3216_ThunkData16
	push	seg    thk3216_ThkData32
	push	offset thk3216_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk3216_ThkData32 label byte
	db	"thk3216_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\16to32.asm ===
page	,132
	.listall

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 20 10:27:33 1997

;Command Line: thunk -P2 -NC ddraw -t thk1632 ..\16to32.thk -o 16to32.asm 

	TITLE	$16to32.asm

	.386
	OPTION READONLY


IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16 -DIS_32
.err
ENDIF
ENDIF
IFDEF IS_16
IFDEF IS_32
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF

	OPTION SEGMENT:USE16
	.model LARGE,PASCAL

f32ptr  typedef ptr far32

externDef DDHAL32_VidMemFree:far16
externDef DDHAL32_VidMemAlloc:far16

externDef C16ThkSL01:far16
externDef __FLATCS:ABS
externDef __FLATDS:ABS


	.data

public thk1632_ThunkData16	;This symbol must be exported.
thk1632_ThunkData16	dd	31304c53h	;Protocol 'SL01'
	dd	0fa1h	;Checksum
	dd	0		;Flags.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	0		;RESERVED. MUST BE ZERO.
	dd	3130424ch	;Late-binding signature 'LB01'
	dd	080000000h		;More flags.
	dd	0		;RESERVED. MUST BE ZERO.
	dw	offset thk1632_ThunkData16ApiDatabase
	dw	   seg thk1632_ThunkData16ApiDatabase


;; Api database. Each entry == 8 bytes:
;;  byte  0:     # of argument bytes.
;;  byte  1,2,3: Reserved: Must initialize to 0.
;;  dword 4:	 error return value.
public thk1632_ThunkData16ApiDatabase
thk1632_ThunkData16ApiDatabase	label	dword
	db	10
	db	0,0,0
	dd	-1
	db	14
	db	0,0,0
	dd	0




	.code ddraw


externDef ThunkConnect16:far16

public thk1632_ThunkConnect16
thk1632_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    thk1632_ThunkData16
	push	offset thk1632_ThunkData16
	push	seg    thk1632_TD32Label
	push	offset thk1632_TD32Label
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
thk1632_TD32Label label byte
	db	"thk1632_ThunkData32",0


DDHAL32_VidMemFree label far16
	mov	cx,0			; offset in jump table
	jmp	thk1632EntryCommon

DDHAL32_VidMemAlloc label far16
	mov	cx,4			; offset in jump table
	jmp	thk1632EntryCommon

;===========================================================================
; This is the common setup code for 16=>32 thunks.
;
; Entry:  cx  = offset in flat jump table
;
; Don't optimize this code: C16ThkSL01 overwrites it
; after each discard.

align
thk1632EntryCommon:
	db	0ebh, 030	;Jump short forward 30 bytes.
;;; Leave at least 30 bytes for C16ThkSL01's code patching.
	db	30 dup(0cch)	;Patch space.
	push	seg    thk1632_ThunkData16
	push	offset thk1632_ThunkData16
	pop	edx
	push	cs
	push	offset thk1632EntryCommon
	pop	eax
	jmp	C16ThkSL01

ELSE	; IS_32
	.model FLAT,STDCALL

include thk.inc
include 16to32.inc

externDef STDCALL DDHAL32_VidMemFree@12:near32
externDef STDCALL DDHAL32_VidMemAlloc@16:near32

externDef C DebugPrintf:near32

MapSLFix		proto	STDCALL  :DWORD
MapSL		proto	STDCALL  :DWORD
UnMapSLFixArray		proto	STDCALL  :DWORD, :DWORD
LocalAlloc	proto	STDCALL  :DWORD, :DWORD
LocalFree	proto	STDCALL  :DWORD

externDef	MapHInstSL:near32
externDef	MapHInstSL_PN:near32
externDef	MapHInstLS:near32
externDef	MapHInstLS_PN:near32
externDef T_DDHAL32_VIDMEMFREE:near32
externDef T_DDHAL32_VIDMEMALLOC:near32

;===========================================================================
	.code 


; This is a jump table to API-specific flat thunk code.

align
thk1632_JumpTable label dword
	dd	offset FLAT:T_DDHAL32_VIDMEMFREE
	dd	offset FLAT:T_DDHAL32_VIDMEMALLOC

thk1632_ThunkDataName label byte
	db	"thk1632_ThunkData16",0

	.data

public thk1632_ThunkData32	;This symbol must be exported.
thk1632_ThunkData32	dd	31304c53h	;Protocol 'SL01'
	dd	0fa1h	;Checksum
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Flat address of ThunkData16
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset thk1632_JumpTable - offset thk1632_ThunkDataName



	.code 


externDef ThunkConnect32@24:near32

public thk1632_ThunkConnect32@16
thk1632_ThunkConnect32@16:
	pop	edx
	push	offset thk1632_ThunkDataName
	push	offset thk1632_ThunkData32
	push	edx
	jmp	ThunkConnect32@24


;===========================================================================
; Common routines to restore the stack and registers
; and return to 16-bit code.  There is one for each
; size of 16-bit parameter list in this script.

align
ExitFlat_10:
	mov	cl,10		; parameter byte count
	mov	esp,ebp		; point to return address
	retn			; return to dispatcher

align
ExitFlat_14:
	mov	cl,14		; parameter byte count
	mov	esp,ebp		; point to return address
	retn			; return to dispatcher

;===========================================================================
T_DDHAL32_VIDMEMFREE label near32

; ebx+28   this
; ebx+26   heap
; ebx+22   ptr
	APILOGSL	DDHAL32_VidMemFree

;-------------------------------------
; create new call frame and make the call

; ptr  from: unsigned long
	push	dword ptr [ebx+22]	; to unsigned long

; heap  from: short
	movsx	eax,word ptr [ebx+26]
	push	eax			; to: long

; this  from: unsigned long
	push	dword ptr [ebx+28]	; to unsigned long

	call	DDHAL32_VidMemFree@12		; call 32-bit version
; return code unsigned long --> unsigned long
	mov	edx,eax
	rol	edx,16

;-------------------------------------
	jmp	ExitFlat_10

;===========================================================================
T_DDHAL32_VIDMEMALLOC label near32

; ebx+32   this
; ebx+30   heap
; ebx+26   width
; ebx+22   height
	APILOGSL	DDHAL32_VidMemAlloc

;-------------------------------------
; create new call frame and make the call

; height  from: unsigned long
	push	dword ptr [ebx+22]	; to unsigned long

; width  from: unsigned long
	push	dword ptr [ebx+26]	; to unsigned long

; heap  from: short
	movsx	eax,word ptr [ebx+30]
	push	eax			; to: long

; this  from: unsigned long
	push	dword ptr [ebx+32]	; to unsigned long

	call	DDHAL32_VidMemAlloc@16		; call 32-bit version
; return code unsigned long --> unsigned long
	mov	edx,eax
	rol	edx,16

;-------------------------------------
	jmp	ExitFlat_14

ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3dhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3dhal.h
 *  Content:	Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03/11/95	stevela Initial revision.
 *		servank
 *   04/11/95   stevela	Context added to call blocks.
 *			Materials added. Required as lighting references
 *			handles.
 *			SetViewportData HAL function added.
 *   10/11/95	stevela	Pack structures for driver -p4 option...
 *   11/11/95	stevela Remove definition of D3DHALCreateDriver.
 *			Add lpDDSZ to D3DHAL_CONTEXTCREATEDATA.
 *			Definition of lpLocalVertexBuffer changed to
 *			LPD3DTLVERTEX.
 *   07/12/95	stevela Added texture swapping.
 *   18/12/95	stevela	Added GetState and GetMatrix.
 *   17/02/95	stevela Use execute buffers for tl and h vertex buffers
 *   23/02/95	dougrab Change all handles to DWORD
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DHAL_H_
#define _D3DHAL_H_

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3dtypes.h"
#include "d3dcaps.h"
#include "ddrawi.h"

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DHAL_NUMCLIPVERTICES	20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM	((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM	((32 * 1024) / sizeof (D3DHVERTEX))

/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 */
typedef struct _D3DHAL_GLOBALDRIVERDATA {
    DWORD		dwSize;			// Size of this structure
    D3DDEVICEDESC	hwCaps;			// Capabilities of the hardware
    DWORD		dwNumVertices;		// see following comment
    DWORD		dwNumClipVertices;	// see following comment
    DWORD		dwNumTextureFormats;	// Number of texture formats
    LPDDSURFACEDESC	lpTextureFormats;	// Pointer to texture formats
} D3DHAL_GLOBALDRIVERDATA;
typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;

/*
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *	retcode = HalCall(HalCallData* lpData);
 */
 
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTCREATECB)	(LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTDESTROYCB)	(LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_CONTEXTDESTROYALLCB) (LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD	(__stdcall *LPD3DHAL_SCENECAPTURECB)	(LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECB)		(LPD3DHAL_EXECUTEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECLIPPEDCB)	(LPD3DHAL_EXECUTECLIPPEDDATA);
typedef DWORD	(__stdcall *LPD3DHAL_RENDERSTATECB)	(LPD3DHAL_RENDERSTATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_RENDERPRIMITIVECB)	(LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_EXECUTECLIPPEDCB)	(LPD3DHAL_EXECUTECLIPPEDDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTURECREATECB)	(LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTUREDESTROYCB)	(LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTURESWAPCB)	(LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD	(__stdcall *LPD3DHAL_TEXTUREGETSURFCB)	(LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXCREATECB)	(LPD3DHAL_MATRIXCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXDESTROYCB)	(LPD3DHAL_MATRIXDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXSETDATACB)	(LPD3DHAL_MATRIXSETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATRIXGETDATACB)	(LPD3DHAL_MATRIXGETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_SETVIEWPORTDATACB)	(LPD3DHAL_SETVIEWPORTDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_LIGHTSETCB)	(LPD3DHAL_LIGHTSETDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALCREATECB)	(LPD3DHAL_MATERIALCREATEDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALDESTROYCB)	(LPD3DHAL_MATERIALDESTROYDATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALSETDATACB)	(LPD3DHAL_MATERIALSETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_MATERIALGETDATACB)	(LPD3DHAL_MATERIALGETDATADATA);
typedef DWORD	(__stdcall *LPD3DHAL_GETSTATECB)	(LPD3DHAL_GETSTATEDATA);

typedef struct _D3DHAL_CALLBACKS {
    DWORD			dwSize;
    
    // Device context
    LPD3DHAL_CONTEXTCREATECB	ContextCreate;
    LPD3DHAL_CONTEXTDESTROYCB	ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DHAL_SCENECAPTURECB	SceneCapture;
    
    // Execution
    LPD3DHAL_EXECUTECB		Execute;
    LPD3DHAL_EXECUTECLIPPEDCB	ExecuteClipped;
    LPD3DHAL_RENDERSTATECB	RenderState;
    LPD3DHAL_RENDERPRIMITIVECB	RenderPrimitive;
    
    DWORD			dwReserved;		// Must be zero

    // Textures
    LPD3DHAL_TEXTURECREATECB	TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB	TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB	TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB	TextureGetSurf;
    
    // Transform
    LPD3DHAL_MATRIXCREATECB	MatrixCreate;
    LPD3DHAL_MATRIXDESTROYCB	MatrixDestroy;
    LPD3DHAL_MATRIXSETDATACB	MatrixSetData;
    LPD3DHAL_MATRIXGETDATACB	MatrixGetData;
    LPD3DHAL_SETVIEWPORTDATACB	SetViewportData;
    
    // Lighting
    LPD3DHAL_LIGHTSETCB		LightSet;
    LPD3DHAL_MATERIALCREATECB	MaterialCreate;
    LPD3DHAL_MATERIALDESTROYCB	MaterialDestroy;
    LPD3DHAL_MATERIALSETDATACB	MaterialSetData;
    LPD3DHAL_MATERIALGETDATACB	MaterialGetData;

    // Pipeline state
    LPD3DHAL_GETSTATECB		GetState;

    DWORD			dwReserved0;		// Must be zero
    DWORD			dwReserved1;		// Must be zero
    DWORD			dwReserved2;		// Must be zero
    DWORD			dwReserved3;		// Must be zero
    DWORD			dwReserved4;		// Must be zero
    DWORD			dwReserved5;		// Must be zero
    DWORD			dwReserved6;		// Must be zero
    DWORD			dwReserved7;		// Must be zero
    DWORD			dwReserved8;		// Must be zero
    DWORD			dwReserved9;		// Must be zero

} D3DHAL_CALLBACKS;
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;

#define D3DHAL_SIZE_V1 sizeof( D3DHAL_CALLBACKS )

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

#include "d3di.h"
 
typedef struct _D3DHAL_CONTEXTCREATEDATA {
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;	// in:  Driver struct
    LPDIRECTDRAWSURFACE	lpDDS;		// in:  Surface to be used as target
    LPDIRECTDRAWSURFACE	lpDDSZ;		// in:  Surface to be used as Z
    DWORD		dwPID;		// in:  Current process id
    DWORD		dwhContext;	// out: Context handle
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTCREATEDATA;
typedef D3DHAL_CONTEXTCREATEDATA *LPD3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTDESTROYDATA;
typedef D3DHAL_CONTEXTDESTROYDATA *LPD3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA {
    DWORD		dwPID;		// in:  Process id to destroy contexts for
    HRESULT		ddrval;		// out: Return value
} D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DHAL_CONTEXTDESTROYALLDATA *LPD3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwFlag;		// in:  Indicates beginning or end
    HRESULT		ddrval;		// out: Return value
} D3DHAL_SCENECAPTUREDATA;
typedef D3DHAL_SCENECAPTUREDATA *LPD3DHAL_SCENECAPTUREDATA;

typedef struct _D3DHAL_EXECUTEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in/out: Where to start/error occured
    DWORD		dwFlags;	// in:  Flags for this execute
    DWORD		dwStatus;	// in/out: Condition branch status
    D3DI_EXECUTEDATA	deExData;	// in:  Execute data describing buffer
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    					//	Only provided if HEL performing transform
    D3DINSTRUCTION	diInstruction;	// in:  Optional one off instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_EXECUTEDATA;
typedef D3DHAL_EXECUTEDATA *LPD3DHAL_EXECUTEDATA;

typedef struct _D3DHAL_EXECUTECLIPPEDDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in/out: Where to start/error occured
    DWORD		dwFlags;	// in:  Flags for this execute
    DWORD		dwStatus;	// in/out: Condition branch status
    D3DI_EXECUTEDATA	deExData;	// in:  Execute data describing buffer
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    					//	Only provided if HEL performing transform
    LPDIRECTDRAWSURFACE	lpHBuf;		// in:  Execute buffer containing HVertex data
    					//	Only provided if HEL performing transform
    D3DINSTRUCTION	diInstruction;	// in:  Optional one off instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_EXECUTECLIPPEDDATA;
typedef D3DHAL_EXECUTECLIPPEDDATA *LPD3DHAL_EXECUTECLIPPEDDATA;

typedef struct _D3DHAL_RENDERSTATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in:  Where to find states in buffer
    DWORD		dwCount;	// in:  How many states to process
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_RENDERSTATEDATA;
typedef D3DHAL_RENDERSTATEDATA *LPD3DHAL_RENDERSTATEDATA;

typedef struct _D3DHAL_RENDERPRIMITIVEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwOffset;	// in:  Where to find primitive data in buffer
    DWORD		dwStatus;	// in/out: Condition branch status
    LPDIRECTDRAWSURFACE	lpExeBuf;	// in:  Execute buffer containing data
    DWORD		dwTLOffset;	// in:  Byte offset in lpTLBuf for start of vertex data
    LPDIRECTDRAWSURFACE	lpTLBuf;	// in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION	diInstruction;	// in:  Primitive instruction
    HRESULT		ddrval;		// out: Return value
} D3DHAL_RENDERPRIMITIVEDATA;
typedef D3DHAL_RENDERPRIMITIVEDATA *LPD3DHAL_RENDERPRIMITIVEDATA;

typedef struct _D3DHAL_TEXTURECREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    LPDIRECTDRAWSURFACE	lpDDS;		// in:  Pointer to surface object
    DWORD		dwHandle;	// out: Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTURECREATEDATA;
typedef D3DHAL_TEXTURECREATEDATA *LPD3DHAL_TEXTURECREATEDATA;

typedef struct _D3DHAL_TEXTUREDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTUREDESTROYDATA;
typedef D3DHAL_TEXTUREDESTROYDATA *LPD3DHAL_TEXTUREDESTROYDATA;

typedef struct _D3DHAL_TEXTURESWAPDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle1;	// in:  Handle to texture 1
    DWORD		dwHandle2;	// in:  Handle to texture 2
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTURESWAPDATA;
typedef D3DHAL_TEXTURESWAPDATA *LPD3DHAL_TEXTURESWAPDATA;

typedef struct _D3DHAL_TEXTUREGETSURFDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		lpDDS;		// out: Pointer to surface object
    DWORD		dwHandle;	// in:  Handle to texture
    HRESULT		ddrval;		// out: Return value
} D3DHAL_TEXTUREGETSURFDATA;
typedef D3DHAL_TEXTUREGETSURFDATA *LPD3DHAL_TEXTUREGETSURFDATA;

typedef struct _D3DHAL_MATRIXCREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// out: Handle to matrix
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXCREATEDATA;
typedef D3DHAL_MATRIXCREATEDATA *LPD3DHAL_MATRIXCREATEDATA;

typedef struct _D3DHAL_MATRIXDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXDESTROYDATA;
typedef D3DHAL_MATRIXDESTROYDATA *LPD3DHAL_MATRIXDESTROYDATA;

typedef struct _D3DHAL_MATRIXSETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    D3DMATRIX		dmMatrix;	// in:  Matrix data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXSETDATADATA;
typedef D3DHAL_MATRIXSETDATADATA *LPD3DHAL_MATRIXSETDATADATA;

typedef struct _D3DHAL_MATRIXGETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to matrix
    D3DMATRIX		dmMatrix;	// out: Matrix data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATRIXGETDATADATA;
typedef D3DHAL_MATRIXGETDATADATA *LPD3DHAL_MATRIXGETDATADATA;

typedef struct _D3DHAL_SETVIEWPORTDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwViewportID;	// in:	ID of viewport
    D3DVIEWPORT		dvViewData;	// in:  Viewport data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_SETVIEWPORTDATADATA;
typedef D3DHAL_SETVIEWPORTDATADATA *LPD3DHAL_SETVIEWPORTDATADATA;

typedef struct _D3DHAL_LIGHTSETDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwLight;	// in:  Which light to set
    D3DI_LIGHT		dlLight;	// in:  Light data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_LIGHTSETDATA;
typedef D3DHAL_LIGHTSETDATA *LPD3DHAL_LIGHTSETDATA;

typedef struct _D3DHAL_MATERIALCREATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// out: Handle to material
    D3DMATERIAL		dmMaterial;	// in:  Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALCREATEDATA;
typedef D3DHAL_MATERIALCREATEDATA *LPD3DHAL_MATERIALCREATEDATA;

typedef struct _D3DHAL_MATERIALDESTROYDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALDESTROYDATA;
typedef D3DHAL_MATERIALDESTROYDATA *LPD3DHAL_MATERIALDESTROYDATA;

typedef struct _D3DHAL_MATERIALSETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    D3DMATERIAL		dmMaterial;	// in:  Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALSETDATADATA;
typedef D3DHAL_MATERIALSETDATADATA *LPD3DHAL_MATERIALSETDATADATA;

typedef struct _D3DHAL_MATERIALGETDATADATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwHandle;	// in:  Handle to material
    D3DMATERIAL		dmMaterial;	// out: Material data
    HRESULT		ddrval;		// out: Return value
} D3DHAL_MATERIALGETDATADATA;
typedef D3DHAL_MATERIALGETDATADATA *LPD3DHAL_MATERIALGETDATADATA;

typedef struct _D3DHAL_GETSTATEDATA {
    DWORD		dwhContext;	// in:  Context handle
    DWORD		dwWhich;	// in:  Transform, lighting or render?
    D3DSTATE		ddState;	// in/out: State.
    HRESULT		ddrval;		// out: Return value
} D3DHAL_GETSTATEDATA;
typedef D3DHAL_GETSTATEDATA *LPD3DHAL_GETSTATEDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DHAL_SCENE_CAPTURE_START	0x00000000L
#define D3DHAL_SCENE_CAPTURE_END	0x00000001L
 
/*
 * Execute()
 */
 
/*
 * Use the instruction stream starting at dwOffset.
 */
#define D3DHAL_EXECUTE_NORMAL		0x00000000L

/*
 * Use the optional instruction override (diInstruction) and return
 * after completion.  dwOffset is the offset to the first primitive.
 */
#define D3DHAL_EXECUTE_OVERRIDE		0x00000001L
 
/*
 * GetState()
 * The driver will get passed a flag in dwWhich specifying which module
 * the state must come from.  The driver then fills in ulArg[1] with the
 * appropriate value depending on the state type given in ddState.
 */

/*
 * The following are used to get the state of a particular stage of the
 * pipeline.
 */
#define D3DHALSTATE_GET_TRANSFORM	0x00000001L
#define D3DHALSTATE_GET_LIGHT		0x00000002L
#define D3DHALSTATE_GET_RENDER		0x00000004L


/* --------------------------------------------------------------
 * Return values from HAL functions.
 */
 
/*
 * The context passed in was bad.
 */
#define D3DHAL_CONTEXT_BAD		0x000000200L

/*
 * No more contexts left.
 */
#define D3DHAL_OUTOFCONTEXTS		0x000000201L

/*
 * Execute() and ExecuteClipped()
 */
 
/*
 * Executed to completion via early out.
 * 	(e.g. totally clipped)
 */
#define D3DHAL_EXECUTE_ABORT		0x00000210L

/*
 * An unhandled instruction code was found (e.g. D3DOP_TRANSFORM).
 * The dwOffset parameter must be set to the offset of the unhandled
 * instruction.
 *
 * Only valid from Execute()
 */
#define D3DHAL_EXECUTE_UNHANDLED	0x00000211L

#endif /* _D3DHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3dcaps.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/* 
 *  Pull in DirectDraw include file automatically:
 */
#include <ddraw.h>

#pragma pack(4)

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_ROP2             0x00000002L
#define D3DPRASTERCAPS_XOR              0x00000004L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL         0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX        0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_STIPPLE          0x00000200L

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L
#define D3DPTEXTURECAPS_POW2            0x00000002L
#define D3DPTEXTURECAPS_ALPHA           0x00000004L
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L
#define D3DPTEXTURECAPS_BORDER          0x00000010L
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

typedef HRESULT (FAR PASCAL * LPD3DENUMDEVICESCALLBACK)(LPGUID lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z*/
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z*/
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */

#define D3DFDS_COLORMODEL        0x00000001L /* Match color model */
#define D3DFDS_GUID              0x00000002L /* Match guid */
#define D3DFDS_HARDWARE          0x00000004L /* Match hardware/software */
#define D3DFDS_TRIANGLES         0x00000008L /* Match in triCaps */
#define D3DFDS_LINES             0x00000010L /* Match in lineCaps  */
#define D3DFDS_MISCCAPS          0x00000020L /* Match primCaps.dwMiscCaps */
#define D3DFDS_RASTERCAPS        0x00000040L /* Match primCaps.dwRasterCaps */
#define D3DFDS_ZCMPCAPS          0x00000080L /* Match primCaps.dwZCmpCaps */
#define D3DFDS_ALPHACMPCAPS      0x00000100L /* Match primCaps.dwAlphaCmpCaps */
#define D3DFDS_SRCBLENDCAPS      0x00000200L /* Match primCaps.dwSourceBlendCaps */
#define D3DFDS_DSTBLENDCAPS      0x00000400L /* Match primCaps.dwDestBlendCaps */
#define D3DFDS_SHADECAPS         0x00000800L /* Match primCaps.dwShadeCaps */
#define D3DFDS_TEXTURECAPS       0x00001000L /* Match primCaps.dwTextureCaps */
#define D3DFDS_TEXTUREFILTERCAPS 0x00002000L /* Match primCaps.dwTextureFilterCaps */
#define D3DFDS_TEXTUREBLENDCAPS  0x00004000L /* Match primCaps.dwTextureBlendCaps */
#define D3DFDS_TEXTUREADDRESSCAPS  0x00008000L /* Match primCaps.dwTextureBlendCaps */

/*
 * FindDevice arguments
 */
typedef struct _D3DFINDDEVICESEARCH {
    DWORD               dwSize;
    DWORD               dwFlags;
    BOOL                bHardware;
    D3DCOLORMODEL       dcmColorModel;
    GUID                guid;
    DWORD               dwCaps;
    D3DPRIMCAPS         dpcPrimCaps;
} D3DFINDDEVICESEARCH, *LPD3DFINDDEVICESEARCH;

typedef struct _D3DFINDDEVICERESULT {
    DWORD               dwSize;
    GUID                guid;           /* guid which matched */
    D3DDEVICEDESC       ddHwDesc;               /* hardware D3DDEVICEDESC */
    D3DDEVICEDESC       ddSwDesc;       /* software D3DDEVICEDESC */
} D3DFINDDEVICERESULT, *LPD3DFINDDEVICERESULT;

/*
 * Description of execute buffer.
 */
typedef struct _D3DExecuteBufferDesc {
    DWORD               dwSize;         /* size of this structure */
    DWORD               dwFlags;        /* flags indicating which fields are valid */
    DWORD               dwCaps;         /* capabilities of execute buffer */
    DWORD               dwBufferSize;   /* size of execute buffer data */
    LPVOID              lpData;         /* pointer to actual data */
} D3DEXECUTEBUFFERDESC, *LPD3DEXECUTEBUFFERDESC;

/* D3DEXECUTEBUFFER dwFlags indicating valid fields */

#define D3DDEB_BUFSIZE          0x00000001l     /* buffer size valid */
#define D3DDEB_CAPS             0x00000002l     /* caps valid */
#define D3DDEB_LPDATA           0x00000004l     /* lpData valid */

/* D3DEXECUTEBUFFER dwCaps */

#define D3DDEBCAPS_SYSTEMMEMORY 0x00000001l     /* buffer in system memory */
#define D3DDEBCAPS_VIDEOMEMORY  0x00000002l     /* buffer in device memory */
#define D3DDEBCAPS_MEM (D3DDEBCAPS_SYSTEMMEMORY|D3DDEBCAPS_VIDEOMEMORY)

#pragma pack()

#endif /* _D3DCAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3di.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3di.h
 *  Content:	Direct3D internal include file
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: d3di.h,v 1.26 1995/12/04 11:29:44 sjl Exp $
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05/11/95   stevela	Initial rev with this header.
 *   11/11/95	stevela	Light code changed.
 *   21/11/95   colinmc Made Direct3D aggregatable
 *                      (so it can be QI'd off DirectDraw).
 *   23/11/95   colinmc Made Direct3D textures and devices aggregatable
 *                      (QI'd off DirectDrawSurfaces).
 *   07/12/95	stevela Merged in Colin's changes.
 *   10/12/95	stevela	Removed AGGREGATE_D3D.
 *			Removed Validate macros from here. Now in d3dpr.h
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3d.h"

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#include "ddrawi.h"
#include "rlreg.h"
#include "queue.h"
#include "object.h"
/*
typedef D3DCOLORMODEL D3DCOLORMODEL;

#define D3DCOLOR_RAMP D3DCOLOR_RAMP
#define D3DCOLOR_RGB D3DCOLOR_RGB
#define D3D_COLORMODEL D3D_COLORMODEL
*/
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;		/* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;		/* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata
 */
typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE	type;
    BOOL		valid;
    D3DVALUE		red, green, blue, shade;
    D3DVECTOR		position;
    D3DVECTOR		model_position;
    D3DVECTOR		direction;
    D3DVECTOR		model_direction;
    D3DVECTOR		halfway;
    D3DVALUE		range;
    D3DVALUE		range_squared;
    D3DVALUE		falloff;
    D3DVALUE		attenuation0;
    D3DVALUE		attenuation1;
    D3DVALUE		attenuation2;
    D3DVALUE		cos_theta_by_2;
    D3DVALUE		cos_phi_by_2;
} D3DI_LIGHT, *LPD3DI_LIGHT;

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#ifndef BUILD_HEL
#ifdef BUILD_D3D_LAYER
#include "driver.h"
#endif

typedef struct ID3DObjectVtbl D3DOBJECTVTBL, *LPD3DOBJECTVTBL;
typedef struct IDirect3DVtbl DIRECT3DCALLBACKS, *LPDIRECT3DCALLBACKS;
typedef struct IDirect3DDeviceVtbl DIRECT3DDEVICECALLBACKS, *LPDIRECT3DDEVICECALLBACKS;
typedef struct IDirect3DExecuteBufferVtbl DIRECT3DEXECUTEBUFFERCALLBACKS, *LPDIRECT3DEXECUTEBUFFERCALLBACKS;
typedef struct IDirect3DLightVtbl DIRECT3DLIGHTCALLBACKS, *LPDIRECT3DLIGHTCALLBACKS;
typedef struct IDirect3DMaterialVtbl DIRECT3DMATERIALCALLBACKS, *LPDIRECT3DMATERIALCALLBACKS;
typedef struct IDirect3DTextureVtbl DIRECT3DTEXTURECALLBACKS, *LPDIRECT3DTEXTURECALLBACKS;
typedef struct IDirect3DViewportVtbl DIRECT3DVIEWPORTCALLBACKS, *LPDIRECT3DVIEWPORTCALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DIRECT3DI *LPDIRECT3DI;
typedef struct _DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef struct _DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef struct _DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef struct _DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef struct _DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef struct _DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;

/*
 * If we have an aggreate Direct3D we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DUNKNOWNI
{
    LPDIRECT3DCALLBACKS         lpVtbl;
    LPDIRECT3DI                 lpObj;
} DIRECT3DUNKNOWNI;
typedef struct _DIRECT3DUNKNOWNI *LPDIRECT3DUNKNOWNI;

/*
 * Internal version of Direct3D object; it has data after the vtable
 */
typedef struct _DIRECT3DI
{
    /*** Object Interface ***/
    LPDIRECT3DCALLBACKS		lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count object */

    /*** Object Relations ***/
    /* Devices */
    int				numDevs;/* Number of devices */
    LIST_HEAD(_devices, _DIRECT3DDEVICEI) devices;
    					/* Associated IDirect3DDevices */

    /* Viewports */
    int				numViewports; /* Number of viewports */
    LIST_HEAD(_viewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Created IDirect3DViewports */
					
    /* Lights */
    int				numLights; /* Number of lights */
    LIST_HEAD(_lights, _DIRECT3DLIGHTI) lights;
    					/* Created IDirect3DLights */

    /* Materials */
    int				numMaterials; /* Number of materials */
    LIST_HEAD(_materials, _DIRECT3DMATERIALI) materials;
    					/* Created IDirect3DMaterials */

    /*** Object Data ***/
    unsigned long		v_next;	/* id of next viewport to be created */
    RLDDIRegistry*		lpReg;	/* Registry */

    /*
     * DirectDraw Interface
     */
    LPDDRAWI_DIRECTDRAW_INT	lpDDInt;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DUNKNOWNI            lpThisIUnknown;   /* Our IUnknown interface */

} DIRECT3DI;

/*
 * If we have an aggreate Direct3DDevice we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DDEVICEUNKNOWNI
{
    LPDIRECT3DDEVICECALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEUNKNOWNI;
typedef struct _DIRECT3DDEVICEUNKNOWNI *LPDIRECT3DDEVICEUNKNOWNI;

/*
 * Internal version of Direct3DDevice object; it has data after the vtable
 */

#include "d3dhal.h"

typedef RLDDIDriver*  (*RLDDIDDrawCreateDriverFn)(
					LPDDRAWI_DIRECTDRAW_INT lpDDInt,
					LPDIRECTDRAWSURFACE lpDDS,
					LPDIRECTDRAWSURFACE lpZ,
					LPDIRECTDRAWPALETTE lpPal,
					LPDIRECT3DDEVICEI);

typedef HRESULT (*RLDDIGetCapsFn)(LPD3DDEVICEDESC*, LPD3DDEVICEDESC*);
typedef void (*RLDDIInitFn)(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
typedef void (*RLDDIPushDriverFn)(RLDDIDriverStack*, RLDDIDriver*);
typedef void (*RLDDIPopDriverFn)(RLDDIDriverStack*);

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_ENTRY(_D3DI_TEXTUREBLOCK)	list;
    					/* Next block in IDirect3DTexture */
    LIST_ENTRY(_D3DI_TEXTUREBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DTEXTUREI			lpD3DTextureI;
    D3DTEXTUREHANDLE			hTex;
    					/* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_ENTRY(_D3DI_MATERIALBLOCK)	list;
    					/* Next block in IDirect3DMaterial */
    LIST_ENTRY(_D3DI_MATERIALBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DMATERIALI			lpD3DMaterialI;
    D3DMATERIALHANDLE			hMat;
    					/* material handle */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

typedef struct _DIRECT3DDEVICEI
{
    /*** Object Interface ***/
    LPDIRECT3DDEVICECALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* parent */
    LIST_ENTRY(_DIRECT3DDEVICEI)list;	/* Next device IDirect3D */

    /* Textures */
    LIST_HEAD(_textures, _D3DI_TEXTUREBLOCK) texBlocks;
    					/* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_HEAD(_buffers, _DIRECT3DEXECUTEBUFFERI) buffers;
    					/* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int				numViewports;
    CIRCLEQ_HEAD(_dviewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Associated IDirect3DViewports */

    /* Materials */
    LIST_HEAD(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    					/* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    /* Private interfaces */
    LPD3DOBJECTVTBL		lpClassVtbl; /* Private Vtbl */
    LPD3DOBJECTVTBL		lpObjVtbl; /* Private Vtbl */

    LPD3DHAL_CALLBACKS		lpD3DHALCallbacks;
    LPD3DHAL_GLOBALDRIVERDATA	lpD3DHALGlobalDriverData;

    /* Viewports */
    unsigned long		v_id;	/* ID of last viewport rendered */

    /* Lights */
    int				numLights;
    					/* This indicates the maximum number
					   of lights that have been set in
					   the device. */

    /* Device characteristics */
    int				age;
    int				width;
    int				height;
    int				depth;
    unsigned long		red_mask, green_mask, blue_mask;

    int				dither;
    int				ramp_size;
    D3DCOLORMODEL		color_model;
    int				wireframe_options;
    D3DTEXTUREFILTER		texture_quality;
    D3DVALUE			gamma;
    unsigned char		gamma_table[256];
    int				aspectx, aspecty;
    D3DVALUE			perspective_tolerance;

    /* Library information */
#ifdef WIN32
    HINSTANCE		hDrvDll;
    char		dllname[MAXPATH];
    char		base[256];
#endif
#ifdef SHLIB
    void*		so;
#endif

    /* Are we in a scene? */
    BOOL		bInScene;

    /* Our Device type */
    GUID		guid;

    /* GetCaps function from the library */
    RLDDIGetCapsFn	GetCapsFn;

    /* Functions required to build driver */
    RLDDIInitFn		RLDDIInit;
    RLDDIPushDriverFn	RLDDIPushDriver;
    RLDDIPopDriverFn	RLDDIPopDriver;
    RLDDIDDrawCreateDriverFn	RLDDIDDrawCreateDriver;

    /* Device description */
    D3DDEVICEDESC	d3dHWDevDesc;
    D3DDEVICEDESC	d3dHELDevDesc;

    /* Driver stack */
    RLDDIDriverStack*	stack;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DDEVICEUNKNOWNI      lpThisIUnknown;   /* Our IUnknown interface */

} DIRECT3DDEVICEI;

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DEXECUTEBUFFERI
{
    /*** Object Interface ***/
    LPDIRECT3DEXECUTEBUFFERCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Parent */
    LIST_ENTRY(_DIRECT3DEXECUTEBUFFERI)list;
    					/* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD			pid;	/* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC	debDesc;
    					/* Description of the buffer */
    D3DEXECUTEDATA		exData;	/* Execute Data */
    BOOL			locked;	/* Is the buffer locked */

    D3DI_BUFFERHANDLE		hBuf;
    					/* Execute buffer handle */
} DIRECT3DEXECUTEBUFFERI;

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DLIGHTI
{
    /*** Object Interface ***/
    LPDIRECT3DLIGHTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DLIGHTI)list;
    					/* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI		lpD3DViewportI; /* Guardian */
    CIRCLEQ_ENTRY(_DIRECT3DLIGHTI)light_list;
    					/* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT			dlLight;/* Data describing light */
    D3DI_LIGHT			diLightData;
    					/* Internal representation of light */
} DIRECT3DLIGHTI;

/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DMATERIALI
{
    /*** Object Interface ***/
    LPDIRECT3DMATERIALCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DMATERIALI)list;
    					/* Next MATERIAL in IDirect3D */

    LIST_HEAD(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    					/* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL			dmMaterial; /* Data describing material */
    BOOL			bRes;	/* Is this material reserved in the driver */
} DIRECT3DMATERIALI;

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DTEXTUREUNKNOWNI
{
    LPDIRECT3DTEXTURECALLBACKS  lpVtbl;
    LPDIRECT3DTEXTUREI          lpObj;
} DIRECT3DTEXTUREUNKNOWNI;
typedef struct _DIRECT3DTEXTUREUNKNOWNI *LPDIRECT3DTEXTUREUNKNOWNI;

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
typedef struct _DIRECT3DTEXTUREI
{
    /*** Object Interface ***/
    LPDIRECT3DTEXTURECALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */


    /*** Object Relations ***/
    LIST_HEAD(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    					/* Devices we're associated with */

    /*** Object Data ***/
    LPDIRECTDRAWSURFACE		lpDDS;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DTEXTUREUNKNOWNI     lpThisIUnknown;   /* Our IUnknown interface */
    BOOL			bIsPalettized;

} DIRECT3DTEXTUREI;

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
typedef struct _DIRECT3DVIEWPORTI
{
    /*** Object Interface ***/
    LPDIRECT3DVIEWPORTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations */
    LPDIRECT3DI			lpDirect3DI; /* Parent */
    LIST_ENTRY(_DIRECT3DVIEWPORTI)list;
    					/* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Guardian */
    CIRCLEQ_ENTRY(_DIRECT3DVIEWPORTI)vw_list;
    					/* Next viewport in IDirect3DDevice */
					
    /* Lights */
    int				numLights;
    CIRCLEQ_HEAD(_dlights, _DIRECT3DLIGHTI) lights;
    					/* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long		v_id;	/* Id for this viewport */
    D3DVIEWPORT			v_data;

    BOOL			have_background;
    D3DMATERIALHANDLE		background;
    					/* Background material */
    BOOL			have_depth;
    LPDIRECTDRAWSURFACE		depth;	/* Background depth */
    
    BOOL			bLightsChanged;
    					/* Have the lights changed since they
					   were last collected? */
    DWORD			clrCount; /* Number of rects allocated */
    LPD3DRECT			clrRects; /* Rects used for clearing */
} DIRECT3DVIEWPORTI;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA {
    D3DI_EXECUTEDATA*	exe;
    D3DPICKRECORD*	records;
    int			pick_count;
    D3DRECT		pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

/*
 * Direct3D memory allocation
 */

/*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI 		D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI 		D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI		D3DFree(LPVOID p);

/*
 * Used for raising errors from the driver.
 */
HRESULT D3DAPI D3DRaise(HRESULT);

/*
 * Convert RLDDI error codes to D3D error codes
 */
#define RLDDITOD3DERR(_errcode) (RLDDIToD3DErrors[_errcode])
extern HRESULT RLDDIToD3DErrors[];

/*
 * maths
 */
#if 1 /* defined(STACK_CALL) && defined(__WATCOMC__) */
D3DVALUE D3DIPow(D3DVALUE, D3DVALUE);
#else
#define D3DIPow(v,p)	DTOVAL(pow(VALTOD(v), VALTOD(p)))
#endif

/*
 * Light utils
 */
void D3DI_DeviceMarkLightEnd(LPDIRECT3DDEVICEI, int);
void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI);
void D3DI_VectorNormalise12(LPD3DVECTOR v);
D3DTEXTUREHANDLE D3DI_FindTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI);
void D3DI_SetTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE);
void D3DI_RemoveTextureBlock(LPD3DI_TEXTUREBLOCK);
void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS);

#ifdef BUILD_D3D_LAYER
extern RLDDIValue* RLDDIFInvSqrtTable;
#endif

#ifdef __cplusplus
};
#endif

#endif /* BUILD_HEL */
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d.h
 *  Content:    Direct3D include file
 *
 ***************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef _WIN32
#define D3DAPI WINAPI
#else
#define D3DAPI
#endif

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct IDirect3D;
struct IDirect3DDevice;
struct IDirect3DExecuteBuffer;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DTexture;
struct IDirect3DViewport;
typedef struct IDirect3D                *LPDIRECT3D;
typedef struct IDirect3DDevice          *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight           *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial        *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture         *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport        *LPDIRECT3DVIEWPORT;

#else

typedef struct IDirect3D                *LPDIRECT3D;
typedef struct IDirect3DDevice          *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight           *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial        *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture         *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport        *LPDIRECT3DVIEWPORT;

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"

/*
 * IDirect3D
 */
#undef INTERFACE
#define INTERFACE IDirect3D
DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3D methods ***/
    STDMETHOD(Initialize) (THIS_ REFIID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK, LPVOID) PURE;
    STDMETHOD(CreateLight) (THIS_ LPDIRECT3DLIGHT*, IUnknown*) PURE;
    STDMETHOD(CreateMaterial) (THIS_ LPDIRECT3DMATERIAL*, IUnknown*) PURE;
    STDMETHOD(CreateViewport) (THIS_ LPDIRECT3DVIEWPORT*, IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3D_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirect3D_EnumDevices(p, a, b)            (p)->lpVtbl->EnumDevices(p, a, b)
#define IDirect3D_CreateLight(p, a, b)            (p)->lpVtbl->CreateLight(p, a, b)
#define IDirect3D_CreateMaterial(p, a, b)         (p)->lpVtbl->CreateMaterial(p, a, b)
#define IDirect3D_CreateViewport(p, a, b)         (p)->lpVtbl->CreateViewport(p, a, b)
#define IDirect3D_FindDevice(p, a, b)             (p)->lpVtbl->FindDevice(p, a, b)
#endif

/*
 * IDirect3DDevice
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice
DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D, LPGUID, LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps) (THIS_ LPD3DDEVICEDESC, LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles) (THIS_ LPDIRECT3DTEXTURE, LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer) (THIS_ LPD3DEXECUTEBUFFERDESC, LPDIRECT3DEXECUTEBUFFER*, IUnknown*) PURE;
    STDMETHOD(GetStats) (THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute) (THIS_ LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD) PURE;
    STDMETHOD(AddViewport) (THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport) (THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport) (THIS_ LPDIRECT3DVIEWPORT, LPDIRECT3DVIEWPORT*, DWORD) PURE;
    STDMETHOD(Pick) (THIS_ LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD, LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD, LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats) (THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK, LPVOID) PURE;
    STDMETHOD(CreateMatrix) (THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix) (THIS_ D3DMATRIXHANDLE, LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix) (THIS_ D3DMATRIXHANDLE, LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix) (THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD_(HRESULT, BeginScene) (THIS) PURE;
    STDMETHOD_(HRESULT, EndScene) (THIS) PURE;
    STDMETHOD(GetDirect3D) (THIS_ LPDIRECT3D*) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DDevice_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p, a, b, c)          (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirect3DDevice_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirect3DDevice_SwapTextureHandles(p, a, b)     (p)->lpVtbl->SwapTextureHandles(p, a, b)
#define IDirect3DDevice_CreateExecuteBuffer(p, a, b, c) (p)->lpVtbl->CreateExecuteBuffer(p, a, b, c)
#define IDirect3DDevice_GetStats(p, a)                  (p)->lpVtbl->CreateViewport(p, a)
#define IDirect3DDevice_Execute(p, a, b, c)             (p)->lpVtbl->Execute(p, a, b, c)
#define IDirect3DDevice_AddViewport(p, a)               (p)->lpVtbl->AddViewport(p, a)
#define IDirect3DDevice_DeleteViewport(p, a)            (p)->lpVtbl->DeleteViewport(p, a)
#define IDirect3DDevice_NextViewport(p, a, b)           (p)->lpVtbl->NextViewport(p, a, b)
#define IDirect3DDevice_Pick(p, a, b, c, d)             (p)->lpVtbl->Pick(p, a, b, c, d)
#define IDirect3DDevice_GetPickRecords(p, a, b)         (p)->lpVtbl->GetPickRecords(p, a, b)
#define IDirect3DDevice_EnumTextureFormats(p, a, b)     (p)->lpVtbl->EnumTextureFormats(p, a, b)
#define IDirect3DDevice_CreateMatrix(p, a)              (p)->lpVtbl->CreateMatrix(p, a)
#define IDirect3DDevice_SetMatrix(p, a, b)              (p)->lpVtbl->SetMatrix(p, a, b)
#define IDirect3DDevice_GetMatrix(p, a, b)              (p)->lpVtbl->GetMatrix(p, a, b)
#define IDirect3DDevice_DeleteMatrix(p, a)              (p)->lpVtbl->DeleteMatrix(p, a)
#define IDirect3DDevice_BeginScene(p)                   (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p)                     (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p, a)               (p)->lpVtbl->GetDirect3D(p, a)
#endif

/*
 * IDirect3DExecuteBuffer
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer
DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3DDEVICE, LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock) (THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD_(HRESULT, Unlock) (THIS) PURE;
    STDMETHOD(SetExecuteData) (THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData) (THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate) (THIS_ LPDWORD, LPD3DVALIDATECALLBACK, LPVOID, DWORD) PURE;
    STDMETHOD(Optimize) (THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DExecuteBuffer_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p, a, b)     (p)->lpVtbl->Initialize(p, a, b)
#define IDirect3DExecuteBuffer_Lock(p, a)              (p)->lpVtbl->Lock(p, a)
#define IDirect3DExecuteBuffer_Unlock(p)               (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p, a)    (p)->lpVtbl->SetExecuteData(p, a)
#define IDirect3DExecuteBuffer_Validate(p, a, b, c, d) (p)->lpVtbl->Validata(p, a, b, c, d)
#endif

/*
 * Flags for execute buffer calls
 */
#define D3DNEXT_NEXT    0x00000001l
#define D3DNEXT_HEAD    0x00000002l
#define D3DNEXT_TAIL    0x00000004l

/*
 * IDirect3DLight
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight
DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight) (THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight) (THIS_ LPD3DLIGHT) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DLight_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p, a)        (p)->lpVtbl->Initialize(p, a)
#define IDirect3DLight_SetLight(p, a)          (p)->lpVtbl->SetLight(p, a)
#define IDirect3DLight_GetLight(p, a)          (p)->lpVtbl->GetLight(p, a)
#endif

/*
 * IDirect3DMaterial
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial
DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial) (THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial) (THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle) (THIS_ LPDIRECT3DDEVICE, LPD3DMATERIALHANDLE) PURE;
    STDMETHOD_(HRESULT, Reserve) (THIS) PURE;
    STDMETHOD_(HRESULT, Unreserve) (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DMaterial_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p, a)        (p)->lpVtbl->Initialize(p, a)
#define IDirect3DMaterial_SetMaterial(p, a)       (p)->lpVtbl->SetMaterial(p, a)
#define IDirect3DMaterial_GetMaterial(p, a)       (p)->lpVtbl->GetMaterial(p, a)
#define IDirect3DMaterial_GetHandle(p, a, b)      (p)->lpVtbl->GetHandle(p, a, b)
#define IDirect3DMaterial_Reserve(p)              (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p)            (p)->lpVtbl->Unreserve(p)
#endif

/*
 * IDirect3DTexture
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture
DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3DDEVICE, LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle) (THIS_ LPDIRECT3DDEVICE, LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged) (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(Load) (THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD_(HRESULT, Unload) (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p, a, b) (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DTexture_AddRef(p)               (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p)              (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p, a, b)     (p)->lpVtbl->Initialize(p, a, b)
#define IDirect3DTexture_GetHandle(p, a, b)      (p)->lpVtbl->GetHandle(p, a, b)
#define IDirect3DTexture_PaletteChanged(p, a, b) (p)->lpVtbl->PaletteChanged(p, a, b)
#define IDirect3DTexture_Load(p, a)              (p)->lpVtbl->Load(p, a)
#define IDirect3DTexture_Unload(p)               (p)->lpVtbl->Unload(p)
#endif

/*
 * IDirect3DViewport
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport
DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize) (THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport) (THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport) (THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices) (THIS_ DWORD, LPD3DTRANSFORMDATA, DWORD, LPDWORD) PURE;
    STDMETHOD(LightElements) (THIS_ DWORD, LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground) (THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground) (THIS_ LPD3DMATERIALHANDLE, LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth) (THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth) (THIS_ LPDIRECTDRAWSURFACE*, LPBOOL) PURE;
    STDMETHOD(Clear) (THIS_ DWORD, LPD3DRECT, DWORD) PURE;
    STDMETHOD(AddLight) (THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight) (THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight) (THIS_ LPDIRECT3DLIGHT, LPDIRECT3DLIGHT*, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p, a, b)          (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirect3DViewport_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p, a)                 (p)->lpVtbl->Initialize(p, a)
#define IDirect3DViewport_GetViewport(p, a)                (p)->lpVtbl->GetViewport(p, a)
#define IDirect3DViewport_SetViewport(p, a)                (p)->lpVtbl->SetViewport(p, a)
#define IDirect3DViewport_TransformVertices(p, a, b, c, d) (p)->lpVtbl->TransformVertices(p, a, b, c, d)
#define IDirect3DViewport_LightElements(p, a, b)           (p)->lpVtbl->LightElements(p, a, b)
#define IDirect3DViewport_SetBackground(p, a)              (p)->lpVtbl->SetBackground(p, a)
#define IDirect3DViewport_GetBackground(p, a, b)           (p)->lpVtbl->GetBackground(p, a, b)
#define IDirect3DViewport_Clear(p, a, b, c)                (p)->lpVtbl->Clear(p, a, b, c)
#define IDirect3DViewport_AddLight(p, a)                   (p)->lpVtbl->AddLight(p, a)
#define IDirect3DViewport_DeleteLight(p, a)                (p)->lpVtbl->DeleteLight(p, a)
#define IDirect3DViewport_NextLight(p, a, b, c)            (p)->lpVtbl->NextLight(p, a, b, c)
#endif

/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK                          DD_OK
#define D3DERR_BADMAJORVERSION          MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION          MAKE_DDHRESULT(701)

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED      MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED           MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED       MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED           MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT       MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED      MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED      MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED      MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED           MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED       MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED     MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#define D3DERR_LIGHT_SET_FAILED         MAKE_DDHRESULT(750)

#define D3DERR_SCENE_IN_SCENE           MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE       MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED       MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED         MAKE_DDHRESULT(763)

#ifdef __cplusplus
};
#endif

#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3drm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"
#include "d3drmobj.h"

#ifdef __cplusplus
extern "C" {
struct IDirect3DRM;
#endif


typedef void (CDECL *D3DRMDEVICEPALETTECALLBACK)
    (LPDIRECT3DRMDEVICE lpDirect3DRMDev, LPVOID lpArg, DWORD dwIndex, LONG red, LONG green, LONG blue);

DEFINE_GUID(IID_IDirect3DRM,    0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);


/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
        (THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)      (THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)       (THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)       (THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)  (THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)    (THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)      (THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
        (THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)   (THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)     (THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (   THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
        LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (   THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
        LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (   THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
        int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (   THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
        D3DVALUE px, D3DVALUE py, D3DVALUE pz,
        D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
        LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (   THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
        DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (   THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
        D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
        D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
        D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
        D3DVALUE ou, D3DVALUE ov,
        D3DVALUE su, D3DVALUE sv,
        LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)      (THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)  (THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)    (THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)    (THIS_ DWORD *size_return, LPSTR path_return);
    //STDMETHOD(GetSearchPath)  (THIS_ int *return_count, char ***return_path) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)       (THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)   (THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects) (THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)             
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
        D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
        LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)             (THIS_ D3DVALUE) PURE;
};

#define D3DRM_OK                        DD_OK
#define D3DRMERR_BADOBJECT              MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE                MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC               MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED               MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND               MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET             MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND           MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE                MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE              MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE               MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION        MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION        MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE        MAKE_DDHRESULT(793)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3drmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT     = 0,
    D3DRMSHADE_GOURAUD  = 1,
    D3DRMSHADE_PHONG    = 2,

    D3DRMSHADE_MASK     = 7,
    D3DRMSHADE_MAX      = 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF      = 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON       = 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK     = 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX      = 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS    = 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME = 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID     = 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK      = 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX       = 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT   (D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT        (D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD     (D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG       (D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,               /* choose nearest texel */
    D3DRMTEXTURE_LINEAR,                /* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,            /* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,             /* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,      /* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR        /* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,                  /* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,              /* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED               /* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;          /* 0 .. 255 */
    unsigned char green;        /* 0 .. 255 */
    unsigned char blue;         /* 0 .. 255 */
    unsigned char flags;        /* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;          /* width and height in pixels */
    int aspectx, aspecty;       /* aspect ratio for non-square pixels */
    int depth;                  /* bits per pixel */
    int rgb;                    /* if false, pixels are indices into a
                                   palette otherwise, pixels encode
                                   RGB values. */
    int bytes_per_line;         /* number of bytes of memory for a
                                   scanline. This must be a multiple
                                   of 4. */
    void* buffer1;              /* memory to render into (first buffer). */
    void* buffer2;              /* second rendering buffer for double
                                   buffering, set to NULL for single
                                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;   /* if rgb is true, these are masks for
                                   the red, green and blue parts of a
                                   pixel.  Otherwise, these are masks
                                   for the significant bits of the
                                   red, green and blue elements in the
                                   palette.  For instance, most SVGA
                                   displays use 64 intensities of red,
                                   green and blue, so the masks should
                                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette; /* description of the palette (only if
                                   rgb is false).  Must be (1<<depth)
                                   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL             1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE       2 /* lines are obscured by closer objects */

typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,           /* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,           /* use only X and Z rotations */
    D3DRMCONSTRAIN_X            /* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,            /* linear between start and end */
    D3DRMFOG_EXPONENTIAL,       /* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED /* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,    /* default */
    D3DRMZBUFFER_ENABLE,        /* enable zbuffering */
    D3DRMZBUFFER_DISABLE        /* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,       /* default */
    D3DRMSORT_NONE,             /* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,      /* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT       /* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR       position;
    D3DVECTOR       normal;
    D3DVALUE        tu, tv;
    D3DCOLOR        color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGB(D3DVALUE red,
                                          D3DVALUE green,
                                          D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI        D3DRMCreateColorRGBA(D3DVALUE red,
                                                 D3DVALUE green,
                                                 D3DVALUE blue,
                                                 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE                 D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
                                          LPD3DVECTOR s1,
                                          LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
                                               LPD3DVECTOR s1,
                                               LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
                                              LPD3DVECTOR ray,
                                              LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
                                                   LPD3DVECTOR s1,
                                                   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
                                                 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE                 D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR      D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
                                                              LPD3DVECTOR v,
                                                              D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
                                                          LPD3DRMQUATERNION a,
                                                          LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
                                                       LPD3DRMQUATERNION a,
                                                       LPD3DRMQUATERNION b,
                                                       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void             D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);


#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3drmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

#include "d3drm.h"
#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\ddrawex\dx3inc\d3drmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3drm.h
 *  Content:    Direct3DRM include file
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

#include <objbase.h> /* Use Windows header files */
#define VIRTUAL

#include "d3drmdef.h"
#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)           (THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)           (THIS) kind; \
    STDMETHOD_(ULONG, Release)          (THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)                    (THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)       (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)    (THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)               (THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)       (THIS) kind; \
    STDMETHOD(SetName)                  (THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)                  (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)             (THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,        0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,      0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,         0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,          0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,          0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,         0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,       0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,          0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,      0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,     0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,        0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac,