       // If fFirstLine is true, it means that the first line of the element
        // is within the clipping range (accounted for by cpStart).
        fFirstLine = cpElementStart >= cpStart - rp.GetIch();

        // Assert( cpStart != cpFinish );
        // Update 12/09/98: It is valid for cpStart == cpFinish
        // under some circumstances!  When a hyperlink jump is made to
        // a local anchor (#) that's empty (e.g. <A name="foo"></A>, 
        // the clipping range passed in is empty! (HOT bug 60358)
        // If the element has no content then return the null rectangle
        if(cpStart == cpFinish)
        {
            me._li = *Elem(rp);
            
            yPos = YposFromLine(&CI, rp, NULL);

            rcLine.top = yPos + me._li.GetYTop();
            rcLine.bottom = yPos + me._li.GetYBottom();

            rcLine.left = me._li.GetTextLeft();

            if(rp.GetIch())
            {
                me.SetCp(cpStart - rp.GetIch(), NULL);
                rcLine.left +=  me.MeasureText(rp.RpGetIch(), me._li._cch);
            }
            rcLine.right = rcLine.left;

            AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                    ptTrans,
                                    cpStart, cpClipStart, cpClipFinish
                                    );
            return;
        }
    
        iCurLine = iFirstLine = rp;
    
        // Now that we know what line contains the cp, let's try to compute the
        // bounding rectangle.
    
        // If the line has aligned images in it and if they are at the begining of the
        // the line, back up all the frame lines that are before text and contained
        // within the element of interest.  This only necessary when doing selection
        // and hit testing, since the region for borders/backgrounds ignores aligned
        // and floated stuff.
    
        // (recall rp is like a smart ptr that points to a particular cp by
        // holding a line index (ili) AND an offset into the line's chars
        // (ich), and that we called CLinePtr::RpSetCp() some time back.
    
        // (recall frame lines are those that were created expressly for
        // aligned elems; they are the result of "breaking" a line, which
        // we had to do when we were measuring and saw it had aligned elems)
        
        if ( fIncludeAlignedElements  && rp->HasAligned() )
        {
            LONG diLine = -1;
            CLineCore * pli;
    
            // rp[x] means "Given that rp is indexing line y, return the
            // line indexed by y - x".
    
            // A line is "blank" if it's "clear" or "frame".  Here we
            // walk backwards through the line array until all consecutive
            // frame lines before text are passed.
            while((iCurLine + diLine >= 0) && (pli = &rp[diLine]) && pli->IsBlankLine())
            {
                // Stop walking back if we've found a frame line that _isn't_ "before text",
                // or one whose ending cp is prior to the beginning of our clipping range
                // (which means it's not contained in the element of interest)
                // Consider: <div><img align=left><b><img align=left>text</b>
                // The region for the bold element includes the 2nd image but
                // not the 1st, but both frame lines will show up in front of the bold line.
                // The logic below notes that the last cp of the 1st img is before the cpStart
                // of the bold element, and breaks so we don't include it.
                if (pli->IsFrame())
                {
                    CLineOtherInfo *ploi = pli->oi();
                    LONG cpLine;

                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(rp + diLine);
                    else
                        cpLine = -1;
                        
                    if  (   !pli->_fFrameBeforeText
                         ||  pli->AO_GetLastCp(ploi, cpLine) < cpStart
                        )
                    {
                        break;
                    }
                }
    
                diLine--;
            }
            iFirstLine = iCurLine + diLine + 1;
        }
    
        // compute the ypos for the first line
        yTop = yPos = YposFromLine(&CI, iFirstLine, NULL);
    
        // For calls other than backgrounds/borders, add all the frame lines
        // before the current line under the influence of
        // the element to the region.
    
        if ( fIncludeAlignedElements )
        {
            for ( ; iFirstLine < iCurLine; iFirstLine++)
            {
                CLineCore * pli = Elem(iFirstLine);
                // If the element of interest is block level, find out
                // how much it's indented (left and right) in from its
                // parent layout.
                if (fBlockElement)
                {
                    CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory(ptpStart->GetBranch(), pElement);
                    if (pNodeTemp)
                    {
                        //Assert(pNodeTemp);
                        ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                      &xParentLeftIndent,
                                                      &xParentRightIndent);
                    }
                }
    
                // If it's a frame line, add the line's rc to the region.
                if (pli->IsFrame())
                {
                    LONG cpLine;
                    CLineOtherInfo *ploi = pli->oi();
                    
                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(iFirstLine);
                    else
                        cpLine = -1;
                    long cpLayoutStart  = pli->AO_GetFirstCp(ploi, cpLine);
                    long cpLayoutFinish = pli->AO_GetLastCp(ploi, cpLine);
    
                    if (cpLayoutStart >= cpStart && cpLayoutFinish <= cpFinish)
                    {
                        RcFromAlignedLine(&rcLine, pli, ploi, yPos,
                                            fBlockElement, fFirstLine, IsRTLDisplay(),
                                            xParentLeftIndent, xParentRightIndent);
    
                        AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                               ptTrans,
                                               cpFinish, cpClipStart, cpClipFinish
                                               );
                    }
                }
                // if it's not a frame line, it MUST be a clear line (since we
                // only walked by while seeing blank lines).  All clear lines
                // force a new physical line, so account for change in yPos.
                else
                {
                    Assert( pli->IsClear() && pli->_fForceNewLine );
                    yPos += pli->_yHeight;
                }
            }
        }
    
        // now add all the lines that are contained by the range
        for ( cp = cpStart; cp <= cpFinish; iCurLine++ )
        {
            BOOL    fRTLLine;
            LONG    xStart = 0;
            LONG    xEnd = 0;
            long    yTop, yBottom;
            CLineCore * pli;
            CLineOtherInfo *ploi;
            LONG    i;
            LONG    cChunk;
            CPoint  ptTempForPtTrans = ptTrans;
                    
            Assert(!fRestorePtTrans);

            //---------------------------------------------------------------------------
            //
            // HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK!
            //
            //
            // Originally, the loop used to be of the form:
            //  for (cp = cpStart; cp < cpFinish; iCurLine++)
            //  { ....
            // What this meant was that the line containing the last character would
            // *never* get processed! While this might be desired behaviour under
            // certain circumstances, in a lot of cases it is a bad thing to do.
            // We have such a case when we have a bottom border on a block element,
            // and we have another block element nested inside it. What ends up
            // happening is that we have a single line which contains the end ptp
            // of the block element which has the border. If the current hack were
            // not there then the border will not have the correct height, since the
            // last line (containing the end ptp and the bottom border width) will
            // not get accounted for.
            //
            // To get around this problem, I changed the loop to be *cp <= cpFinish*
            // so now we get a chance to look at the line containing the last
            // character. Howerver, we do not want to do this in all situations,
            // hence there are some qualifying conditions for us to include the last
            // line in the computations:
            //
            // Qualifying condition (QC1): We should be at the last character.
            if (cp == cpFinish)
            {
                // QC2: There should be more lines which we can look at
                // QC3: That line should be a special line -- one which should be
                //      considered for inclusion. We marked the line as such when
                //      we created the line
                // QC4: We should be at the beginning of the line. We are not at BOL
                //      in cases where the end splay is on the same line as the rest
                //      of the characters (happens when the end block element has
                //      no nested block elements). In this situation, rp is positioned
                //      just before the last ptp.
                // QC5: If we had consecutive lines which were marked _fIsPadBordLine,
                //      then we should consume only one. Lets say we consumed the
                //      the first one (when cp == cpFinish). During attempting to
                //      advance to the next positon, the code below will notice that
                //      it is already at cpFinish and hence will not advance, giving
                //      cchAdvance==0.
                //
                // Any problems with the QCs? Please talk with either SujalP or KTam.
                //
                if(   iCurLine >= LineCount()
                   || !Elem(iCurLine)->oi()->_fIsPadBordLine
                   || rp.GetIch() != 0
                   || cchAdvance == 0
                  )
                {
                    break;
                }
            }
            else
                
            //
            // HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! 
            //---------------------------------------------------------------------------
                
            {
                if ( iCurLine >= LineCount() )
                {
                    // (srinib) - please check with one of the text
                    // team members if anyone hits this assert. We want
                    // to investigate. We shoud never be here unless
                    // we run out of memory.
                    AssertSz(FALSE, "WaitForRecalc failed to measure lines till cpFinish");
                    break;
                }
            }
            
            cchAdvance = min(rp.GetCchRemaining(), cpFinish - cp);
            pli = Elem(iCurLine);
            ploi = pli->oi();
            
            // When drawing backgrounds, we skip frame lines contained
            // within the element (since aligned stuff doesn't affect our borders/background)
            // but for hit testing and selection we need to account for them.
            if ( !fIncludeAlignedElements  && pli->IsFrame() )
            {
                goto AdvanceToNextLineInRange;
            }

            // If we are drawing background, and we hit a line which was
            // created only for drawing the block borders, then skip its
            // height (bug 84595).
            if (fOnlyBackground && ploi->_fIsPadBordLine)
            {
                // We do this only for the first line (see bug 100949).
                if (fFirstLine)
                    goto AdvanceToNextLineInRange;

                // Really the right thing to do here to fix bothe 84595 and 100949
                // correctly is to create a dummy line for empty divs with
                // background.
            }
                
            // If line is relative then add in the relative offset
            // In the case of Wigglys we ignore the line's relative positioning, but want any nested
            // elements to be handled CLineServices::CalcRectsOfRangeOnLine
            if (   fNestedRel 
                && pli->_fRelative
               )
            {
                CPoint ptTemp;
                CTreeNode *pNodeNested = pMarkup->TreePosAtCp(cp, &ich)->GetBranch();

                // We only want to adjust for nested elements that do not have layouts. The pElement
                // we passed in is handled by the fIgnoreRel flag. Layout elements are handled in
                // CalcRectsOfRegionOnLine
                if(    pNodeNested->Element() != pElement 
                   && !pNodeNested->ShouldHaveLayout()
                  )
                {
                    pNodeNested->GetRelTopLeft(pElementFL, &CI, &ptTemp.x, &ptTemp.y);
                    ptTempForPtTrans = ptTrans;
                    if(!fIgnoreRel)
                    {
                        ptTrans.x = ptTemp.x - ptTrans.x;
                        ptTrans.y = ptTemp.y - ptTrans.y;
                    }
                    else
                    {
                        // We were told to ignore the pElement's relative positioning. Therefore
                        // we only want to adjust by the amount of the nested element's relative
                        // offset from pElement
                        long xElemRelLeft = 0, yElemRelTop = 0;
                        pNode->GetRelTopLeft(pElementFL, &CI, &xElemRelLeft, &yElemRelTop);
                        ptTrans.x = ptTemp.x - xElemRelLeft;
                        ptTrans.y = ptTemp.y - yElemRelTop;
                    }
                    fRestorePtTrans = TRUE;
                }
            }
            
            fRTLLine = pli->_fRTLLn;
    
            // If the element of interest is block level, find out
            // how much it's indented (left and right) in from its
            // parent layout.
            if ( fBlockElement )
            {
                if ( cp != cpStart )
                {
                    ptpStart = pMarkup->TreePosAtCp(cp, &ich);
                }
    
                CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory(ptpStart->GetBranch(), pElement);
                // (fix this for IE5:RTM, #46824) srinib - if we are in the inclusion, we
                // wont find the node.
                if ( pNodeTemp )
                {
                    //Assert(pNodeTemp);
                    ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                  &xParentLeftIndent,
                                                  &xParentRightIndent);
                }
            }
    
            // For RTL lines, we will work from the right side. LTR lines work
            // from the left, of course.
            if ( fBlockElement )
            {
                // Block elems, except when processing selection:
                
                // _fFirstFragInLine means it's the first logical line (chunk) in the physical line.
                // If that is the case, the starting edge is just the indent from the parent
                // (margin due to floats is ignored).
                // If it's not the first logical line, then treat element as though it were inline.
                xStart = (!fRTLLine)
                         ? /*LTR*/ (IsLogicalFirstFrag(iCurLine) ? xParentLeftIndent  : ploi->_xLeftMargin  + ploi->_xLeft)
                         : /*RTL*/ (IsLogicalFirstFrag(iCurLine) ? xParentRightIndent : ploi->_xRightMargin + pli->_xRight);
                         
                // _fForceNewLine means it's the last logical line (chunk) in a physical line.
                // If that is the case, the line or view width includes the parent's right indent,
                // so we need to subtract it out.  We also do this for dummy lines (actually,
                // we should think about whether it's possible to skip processing of dummy lines altogether!)
                // Otherwise, xLeftMargin+xLineWidth doesn't already include parent's right indent
                // (because there's at least 1 other line to the right of this one), so we don't
                // need to subtract it out, UNLESS the line is right aligned, in which case
                // it WILL include it so we DO need to subtract it (wheee..).
                xEnd = (!fRTLLine)
                       ? /*LTR*/ 
                         ( ( pli->_fForceNewLine || pli->_fDummyLine )
                         ? max(pli->_xLineWidth, GetViewWidth() ) - xParentRightIndent
                         : ploi->_xLeftMargin  + pli->_xLineWidth - (pli->IsRightAligned() ? xParentRightIndent : 0))
                       : /*RTL*/ 
                         ( ( pli->_fForceNewLine || pli->_fDummyLine )
                         ? max(pli->_xLineWidth, GetViewWidth() ) - xParentLeftIndent
                         : ploi->_xRightMargin + pli->_xLineWidth - (pli->IsLeftAligned()  ? xParentLeftIndent  : 0));
            }
            else
            {
                // Inline elems, and all selections begin at the text of
                // the element, which is affected by margin.
                xStart = (!fRTLLine)
                         ? ploi->_xLeftMargin  + ploi->_xLeft
                         : ploi->_xRightMargin + pli->_xRight;
                         
                // GetTextRight() tells us where the text ends, which is
                // just what we want.
                xEnd = (!fRTLLine)
                       ? pli->GetTextRight(ploi, iCurLine == LineCount() - 1)
                       : pli->GetRTLTextLeft(ploi);
                // Only include whitespace for selection
                if ( fIgnoreBlockness )
                {
                    xEnd += ploi->_xWhite;
                }
            }
    
            if (xEnd < xStart)
            {
                // Only clear lines can have a _xLineWidth < _xWidth + _xLeft + _xRight ...

                // (grzegorz) In case of negative letter spacing we may assert here.
                // Since there is no easy way to get letter spacing information for the line
                // this assert is disabled.
                // Assert(pli->IsClear());

                xEnd = xStart;
            }
    
            // Set the top and bottom
            if (fBlockElement)
            {
                LONG yLIBottom = pli->_yHeight;
                LONG yLITopOff = 0;
                LONG yLITop = 0;

                if (!fNoExtent)
                {
                    yLIBottom = pli->GetYBottom(ploi);
                    yLITopOff = pli->GetYHeightTopOff(ploi);
                    yLITop    = pli->GetYTop(ploi);
                }
                
                yTop = yPos;
                yBottom = yPos + max(pli->_yHeight, yLIBottom);
    
                if (fFirstLine)
                {
                    yTop += ploi->_yBeforeSpace + min(0L, yLITopOff);
                    Assert(fNoExtent || yBottom >= yTop);
                }
                else
                {
                    yTop += min(0L, yLITop);
                }
            }
            else
            {
                yTop = yPos + pli->GetYTop(ploi);
                yBottom = yPos + pli->GetYBottom(ploi);

                // 66677: Let ScrollIntoView scroll to top of yBeforeSpace on first line.
                if (fScrollIntoView && yPos==0)
                    yTop = 0;
            }
    
            aryChunks.DeleteAll();
            cChunk = 0;
    
            // At this point we've found the bounds (xStart, xEnd, yTop, yBottom)
            // for a line that is part of the range.  Under certain circumstances,
            // this is insufficient, and we need to actually do measurement.  These
            // circumstances are:
            // 1.) If we're doing selection, we only need to measure partially
            // selected lines (i.e. at most we need to measure 2 lines -- the
            // first and the last).  For completely selected lines, we'll
            // just use the line bounds.  NOTE: this MAY introduce selection
            // turds, since LS uses tight-rects to draw the selection, and
            // our line bounds may not be as wide as LS tight-rects measurement
            // (recall that LS measurement catches whitespace that we sometimes
            // omit -- this may be fixable by adjusting our treatment of xWhite
            // and/or cchWhite).
            // Determination of partially selected lines is done as follows:
            // rp.GetIch() != 0 implies it starts mid-line,
            // rp.GetCchRemaining() != 0 implies it ends mid-line (the - _cchWhite
            // makes us ignore whitespace chars at the end of the line)
            // 2.) For all other situations, we're choosing to measure all
            // non-block elements.  This means that situations specifying
            // tight-rects (backgrounds, focus rects) will get them for
            // non-block elements (which is what we want), and hit-testing
            // will get the right rect if the element is inline and doesn't
            // span the entire line.  NOTE: there is a possible perf
            // improvement here; for hit-testing we really only need to
            // measure when the inline element doesn't span the entire line
            // (right now we measure when hittesting all inline elements);
            // this condition is the same as that for selecting partial lines,
            // however there may be subtler issues here that need investigation.
            if ( (dwFlags & RFE_SELECTION) == RFE_SELECTION )
            {
                fNeedToMeasureLine =    !rp->IsBlankLine()
                                     && (   rp.GetIch()
                                         || max(0L, (LONG)(rp.GetCchRemaining() - (fBlockElement ? rp->oi()->_cchWhite : 0))) > cchAdvance );
                // In case of drawing ellipsis turn off this mode.
                // We need to invalidate more then selection area only.
                if (fNeedToMeasureLine)
                {
                    fNeedToMeasureLine = !GetFlowLayout()->GetFirstBranch()->HasEllipsis();
                }
            }
            else
            {
                fNeedToMeasureLine = !fBlockElement;
            }


            if ( fNeedToMeasureLine )
            {
                // (KTam) why do we need to set the measurer's cp to the 
                // beginning of the line? (cp - rp.GetIch() is beg. of line)
                Assert(!rp.GetIch() || cp == cpStart);
                ptpStart = pMarkup->TreePosAtCp(cp - rp.GetIch(), &ich);
                me.SetCp(cp - rp.GetIch(), ptpStart);
                me._li = *pli;
                // Get chunk info for the (possibly partial) line.
                // Chunk info is returned in aryChunks.
                cChunk = me.MeasureRangeOnLine(pElement, rp.GetIch(), cchAdvance, *pli, yPos, &aryChunks, dwFlags);
                if (cChunk == 0)
                {
                    xEnd = xStart;
                }
            }

            // cChunk == 0 if we didn't need to measure the line, or if we tried
            // to measure it and MeasureRangeOnLine() failed.
            if ( cChunk == 0 )
            {
                rcLine.top = yTop;
                rcLine.bottom = yBottom; 
    
                // Adjust xStart and xEnd for RTL line rectangle alignment
                pli->AdjustChunkForRtlAndEnsurePositiveWidth(ploi, xStart, xEnd,
                                                             &rcLine.left, &rcLine.right);
                
                // If we're clipping to the visible area, check whether this
                // line comes after the visible area.
                if (   fClipToVisible
                    && rcLine.top + ptTrans.y + _yMostNeg >= rcClipWork.bottom   // And we have gone past the bottom
                   )
                {
                    goto Cleanup;                          // then stop
                }

                AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                       ptTrans,
                                       cp, cpClipStart, cpClipFinish
                                       );
    
            }
            else
            {
                Assert(aryChunks.Size() > 0);
    
                i = 0;
                while (i < aryChunks.Size())
                {
                    RECT rcChunk = aryChunks[i++];
                    LONG xStartChunk = xStart + rcChunk.left;
                    LONG xEndChunk;
    
                    // if it is the first or the last chunk, use xStart & xEnd
                    if (fBlockElement && (i == 1 || i == aryChunks.Size()))
                    {
                        if (i == 1)
                            xStartChunk = xStart;

                        if(i == aryChunks.Size())
                            xEndChunk = xEnd;
                        else
                            xEndChunk = xStart + rcChunk.right;
                    }
                    else
                    {
                         xEndChunk = xStart + rcChunk.right;
                    }
    
                    // Adjust xStart and xEnd for RTL line rectangle alignment
                    pli->AdjustChunkForRtlAndEnsurePositiveWidth(ploi, xStartChunk, xEndChunk,
                                                                 &rcLine.left, &rcLine.right);
    
                    if(!fTightRects)
                    {
                        rcLine.top = yTop;
                        rcLine.bottom = yBottom; 
                    }
                    else
                    {
                        rcLine.top = rcChunk.top;
                        rcLine.bottom = rcChunk.bottom; 
                    }
    
                    if (   fClipToVisible                                    // If we are clipping to visible
                        && rcLine.top + ptTrans.y + _yMostNeg >= rcClipWork.bottom   // And we have gone past the bottom
                       )
                    {
                        goto Cleanup;                          // then stop
                    }

                    AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                           ptTrans,
                                           cp, cpClipStart, cpClipFinish
                                           );
                }
            }
    
        AdvanceToNextLineInRange:

            if (fRestorePtTrans)
            {
                ptTrans = ptTempForPtTrans;
                fRestorePtTrans = FALSE;
            }
            
            cp += cchAdvance;
    
            if(cchAdvance)
            {
                rp.RpAdvanceCp(cchAdvance, FALSE);
            }
            else
                rp.AdjustForward(); // frame lines or clear lines
    
            if(pli->_fForceNewLine)
            {
                yPos += pli->_yHeight;
                fFirstLine = FALSE;
            }
        }
    
        // For calls for selection or hittesting (but not background/borders),
        // if the last line contains any aligned images, check to see if
        // there are any aligned lines following the current line that come
        // under the scope of the element
        if ( fIncludeAlignedElements )
        {
            if(!rp.GetIch())
                rp.AdjustBackward();
    
            iCurLine = rp;
    
            if(rp->HasAligned())
            {
                LONG diLine = 1;
                CLineCore * pli;
                CLineOtherInfo *ploi;
                
                // we dont have to worry about clear lines because, all the aligned lines that
                // follow should be consecutive.
                while((iCurLine + diLine < LineCount()) &&
                        (pli = &rp[diLine]) && pli->IsFrame() && !pli->_fFrameBeforeText)
                {
                    ploi = pli->oi();
                    LONG cpLine;

                    if (ploi->_fHasFloatedFL)
                        cpLine = CpFromLine(rp + diLine);
                    else
                        cpLine = -1;
                    
                    long cpLayoutStart  = pli->AO_GetFirstCp(ploi, cpLine);
                    long cpLayoutFinish = pli->AO_GetLastCp(ploi, cpLine);
    
                    if (fBlockElement)
                    {
                        CTreeNode * pNodeTemp = pMarkup->SearchBranchForScopeInStory (ptpFinish->GetBranch(), pElement);
                        if (pNodeTemp)
                        {
                            // Assert(pNodeTemp);
                            ComputeIndentsFromParentNode( &CI, pNodeTemp, dwFlags,
                                                          &xParentLeftIndent, 
                                                          &xParentRightIndent);
                        }
                    }
    
                    // if the current line is a frame line and if the site contained
                    // in it is contained by the current element include it other wise
                    if(cpStart <= cpLayoutStart && cpFinish >= cpLayoutFinish)
                    {
                        RcFromAlignedLine(&rcLine, pli, ploi, yPos,
                                            fBlockElement, fFirstLine, IsRTLDisplay(),
                                            xParentLeftIndent, xParentRightIndent);
    
                        AppendRectToElemRegion(paryRects, prcBound, &rcLine,
                                               ptTrans,
                                               cpFinish, cpClipStart, cpClipFinish
                                               );
                    }
                    diLine++;
                }
            }
        }
    }
Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
// Member:      RegionFromRange
//
// Synopsis:    Return the set of rectangles that encompass a range of
//              characters
//
//-----------------------------------------------------------------------------

void
CDisplay::RegionFromRange(
    CDataAry<RECT> *    paryRects,
    long                cp,
    long                cch )
{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    long            cpFirst     = pFlowLayout->GetContentFirstCp();
    CLinePtr        rp(this);
    CLineCore *     pli;
    CLineOtherInfo *ploi;
    CRect           rc;
    long            ili;
    long            yTop, yBottom;

    if (    pFlowLayout->IsRangeBeforeDirty(cp - cpFirst, cch)
        &&  rp.RpSetCp(cp, FALSE, TRUE
        ))
    {
        //
        //  First, determine the starting line
        //

        ili = rp;

        if(rp->HasAligned())
        {
            while(ili > 0)
            {
                LONG cpLine;
                
                pli = Elem(ili);
                ploi = pli->oi();

                if (   pli->IsFrame()
                    && ploi->_fHasFloatedFL
                   )
                    cpLine = CpFromLine(ili);
                else
                    cpLine = -1;
                
                if (    !pli->IsFrame()
                    ||  !pli->_fFrameBeforeText
                    ||  pli->AO_GetFirstCp(ploi, cpLine) < cp)
                    break;

                Assert(pli->_cch == 0);
                ili--;
            }
        }

        //
        //  Start with an empty rectangle (whose width is that of the client rectangle)
        //

        GetFlowLayout()->GetClientRect(&rc);
            {
            rc.top    =
            rc.bottom = YposFromLine(NULL, rp, NULL);

            //
            // 1) There is no guarantee that cp passed in will be at the beginning of a line
            // 2) In the loop below we decrement cch by the count of chars in the line
            //
            // This would be correct if the cp passed in was the beginning of the line
            // but since it is not, we need to bump up the char count by the offset
            // of cp within the line. If at BOL then this would be 0. (bug 47687 fix 2)
            //
            cch += rp.RpGetIch();

            //
            //  Extend the rectangle over the affected lines
            //
            
            for (; cch > 0 && ili < LineCount(); ili++)
            {
                pli = Elem(ili);
                ploi = pli->oi();

                yTop    = rc.top + pli->GetYLineTop(ploi);
                yBottom = rc.bottom + pli->GetYLineBottom(ploi);

                rc.top    = min(rc.top, yTop);
                rc.bottom = max(rc.bottom, yBottom);

                // TODO: (dmitryt, track bug 112037) we need to get the right pNode.. how?
                // If the line is relative, apply its relative offset
                // to the rect
                /*
                if ( pli->_fRelative )
                {
                    long xRelOffset, yRelOffset;
                    CCalcInfo CI( pFlowLayout );

                    Assert( pNode );
                    pNode->GetRelTopLeft( pFlowLayout->ElementOwner(), &CI, &xRelOffset, &yRelOffset );

                    rc.top += yRelOffset;
                    rc.bottom += yRelOffset;
                }
                */

                Assert( !pli->IsFrame()
                    ||  !pli->_cch);
                cch -= pli->_cch;
            }
        }
        //
        //  Save the invalid rectangle
        //

        if (rc.top != rc.bottom)
        {
            paryRects->AppendIndirect(&rc);
        }
    }
}


//+----------------------------------------------------------------------------
//
// Member:      RenderedPointFromTp
//
// Synopsis:    Find the rendered position of a given cp. For cp that corresponds
//              normal text return its position in the line. For cp that points
//              to an aligned site find the aligned line rather than its poition
//              in the text flow. This function also takes care of relatively
//              positioned lines. Returns point relative to the display
//
//-----------------------------------------------------------------------------

LONG
CDisplay::RenderedPointFromTp(
    LONG        cp,         // point for the cp to be computed
    CTreePos *  ptp,        // tree pos for the cp passed in, can be NULL
    BOOL        fAtEnd,     // Return end of previous line for ambiguous cp
    POINT &     pt,         // Returns point at cp in client coords
    CLinePtr * const prp,   // Returns line pointer at tp (may be null)
    UINT taMode,            // Text Align mode: top, baseline, bottom
    CCalcInfo * pci,
    BOOL *pfRTLFlow)
{
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CLayout     * pLayout = NULL;
    CElement    * pElementLayout = NULL;
    CLinePtr    rp(this);
    LONG        ili;
    BOOL        fAlignedSite = FALSE;
    CCalcInfo   CI;
    CTreeNode * pNode;

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    // initialize flow with current layout direction
    if (pfRTLFlow)
        *pfRTLFlow = IsRTLDisplay();

    if (pFlowLayout->IsDisplayNone() || !WaitForRecalc(cp, -1, pci))
        return -1;

    // now position the line array point to the cp in the rtp.
    // Skip frames, let us worry about them latter.
    if(!rp.RpSetCp(cp, FALSE))
        return -1;

    if(!ptp)
    {
        LONG ich;
        ptp = pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &ich, TRUE);
    }

    pNode   = ptp->GetBranch();
    pLayout = pNode->GetUpdatedNearestLayout(pFlowLayout->LayoutContext());

    if(pLayout != pFlowLayout)
    {
        pElementLayout = pLayout ? pLayout->ElementOwner() : NULL;

        // is the current run owner the txtsite, if not get the runowner
        if(rp->_fHasNestedRunOwner)
        {
            CLayout *   pRunOwner = pFlowLayout->GetContentMarkup()->GetRunOwner(pNode, pFlowLayout);

            if(pRunOwner != pFlowLayout)
            {
                pLayout = pRunOwner;
                pElementLayout = pLayout->ElementOwner();
            }
        }

        // if the site is left or right aligned and not a hr
        if (    !pElementLayout->IsInlinedElement()
            &&  !pElementLayout->IsAbsolute())
        {
            long    iDLine = -1;
            BOOL    fFound = FALSE;

            fAlignedSite = TRUE;

            // run back and forth in the line array and figure out
            // which line belongs to the current site

            // first pass let's go back, look at lines before the current line
            while(rp + iDLine >= 0 && !fFound)
            {
                CLineCore *pLine = &rp[iDLine];
                
                if(pLine->IsClear() || (pLine->IsFrame() && pLine->_fFrameBeforeText))
                {
                    if(pLine->IsFrame() && pElementLayout == pLine->AO_Element(NULL))
                    {
                        fFound = TRUE;

                        // now back up the linePtr to point to this line
                        rp.SetRun(rp + iDLine, 0);
                        break;
                    }
                }
                else
                {
                    break;
                }
                iDLine--;
            }

            // second pass let's go forward, look at lines after the current line.
            if(!fFound)
            {
                iDLine = 1;
                while(rp + iDLine < LineCount())
                {
                    CLineCore *pLine = &rp[iDLine];

                    // If it is a frame line
                    if(pLine->IsFrame() && !pLine->_fFrameBeforeText)
                    {
                        if(pElementLayout == pLine->AO_Element(NULL))
                        {
                            fFound = TRUE;

                            // now adjust the linePtr to point to this line
                            rp.SetRun(rp + iDLine, 0);
                            break;
                        }
                    }
                    else
                        break;
                    iDLine++;
                }
            }

            // if we didn't find an aligned line, we are in deep trouble.
            Assert(fFound);
        }
    }

    if(!fAlignedSite)
    {
        // If it is not an aligned site then use PointFromTp
        ili = PointFromTp(cp, ptp, fAtEnd, FALSE, pt, prp, taMode, pci, NULL, pfRTLFlow);
        if(ili > 0)
            rp.SetRun(ili, 0);
    }
    else
    {
        ili = rp;

        pt.y = YposFromLine(pci, rp, NULL);
        pt.x = rp.oi()->_xLeft + rp.oi()->_xLeftMargin;

        // TODO: (dmitryt, track bug 112026) This assert replaces following code 
        // because we don't know at the moment how to make HTML that gets us here.
        // Take a look at this one later.
        AssertSz(!_fRTLDisplay || !IsTagEnabled(tagDebugRTL), "RTL site in RenderedPointFromTp");

#if 0 // old RTL code. Note that usually, when we deal with right margin, we want to check 
      // for line RTL flag, not layout. If any special code is needed for RTL, this may be a bug
        if (IsRTLDisplay())
        {
            pt.x = rp->_xRight + rp.oi()->_xRightMargin;
        }
#endif

        if (prp)
            *prp = rp;

    }

    return rp;
}

/*
 *  CDisplay::UpdateViewForLists()
 *
 *  @mfunc
 *      Invalidate the number regions for numbered list items.
 *
 *  @params
 *      prcView:   The rect for this display
 *      tpFirst:  Where the change happened -- the place where we check for
 *                parentedness by an OL.
 *      iliFirst: The first line where we start checking for a line beginning a
 *                list item. It may not necessarily be the line containing
 *                tpFirst. Could be any line after it.
 *      yPos:     The yPos for the line iliFirst.
 *      prcInval: The rect which returns the invalidation region
 *
 *  @rdesc
 *      TRUE if updated anything else FALSE
 */
BOOL
CDisplay::UpdateViewForLists(
             RECT       *prcView,
             LONG        cpFirst,
             long        iliFirst,
             long        yPos,
             RECT       *prcInval)
{
    BOOL fHasListItem = FALSE;
    CLineCore *pLine = NULL; // Keep compiler happy.
    CMarkup *pMarkup = GetMarkup();
    CTreePos *ptp;
    LONG cchNotUsed;
    Assert(prcView);
    Assert(prcInval);

    ptp = pMarkup->TreePosAtCp(cpFirst, &cchNotUsed, TRUE);
    Assert(ptp);

    // TODO (sujalp, track bug 112039): We might want to search for other interesting
    // list elements here.
    CElement *pElement = pMarkup->SearchBranchForTag(ptp->GetBranch(), ETAG_OL)->SafeElement();
    if (   pElement
        && pElement->IsBlockElement()
       )
    {
        while (iliFirst < LineCount()   &&
               yPos     < prcView->bottom
              )
        {
            pLine = Elem(iliFirst);

            if (pLine->_fHasBulletOrNum)
            {
                fHasListItem = TRUE;
                break;
            }

            if(pLine->_fForceNewLine)
                yPos += pLine->_yHeight;

            iliFirst++;
        }

        if (fHasListItem)
        {
            // Invalidate the complete strip starting at the current
            // line, right down to the bottom of the view. And only
            // invalidate the strip containing the numbers not the
            // lines themselves.
            prcInval->top    = yPos;
            prcInval->left   = prcView->left;
            prcInval->right  = pLine->oi()->_xLeft;
            prcInval->bottom = prcView->bottom;
        }
    }

    return fHasListItem;
}

// ================================  DEBUG methods  ============================================


#if DBG==1
/*
 *  CDisplay::CheckLineArray()
 *
 *  @mfunc
 *      Ensure that the total amount of text in the line array is the same as
 *      that contained in the runs under the scope of the associated CTxtSite.
 *      Additionally, verify the total height of the contained lines matches
 *      the total calculated height.
 */

VOID CDisplay::CheckLineArray()
{
#ifdef MULTI_LAYOUT
    {
        // TODO (olego, track bug 112029) : need different consistency checking code for multiple/chain case
        CFlowLayout *pFlowLayout = GetFlowLayout();
        CLayoutContext *pLayoutContext;
        
        if (pFlowLayout
            && (pLayoutContext = pFlowLayout->LayoutContext()) != NULL
            && pLayoutContext->ViewChain())
        {
            return;
        }
    }
#endif // MULTI_LAYOUT

    // If we are marked as needing a recalc or if we are in the process of a
    // background recalc, we cannot verify the line array
    if(!_fRecalcDone)
    {
        return;
    }

    LONG            yHeight  = 0;
    LONG            yHeightMax = 0;
    LONG            cchSum   = 0;
    LONG            cchTotal = GetFlowLayout()->GetContentTextLength();
    LONG            ili      = LineCount();
    CLineCore const *pli     = Elem(0);

    while(ili--)
    {
        Assert(pli->_iLOI != -1);
        if(pli->_fForceNewLine)
        {
            yHeight += pli->_yHeight;
            if(yHeightMax < yHeight)
                yHeightMax = yHeight;
        }
        cchSum += pli->_cch;
        pli++;
    }

    if(cchSum != cchTotal)
    {
        TraceTag((tagWarning, "cchSum (%d) != cchTotal (%d)", cchSum, GetFlowLayout()->GetContentTextLength()));
        AssertSz(FALSE, "cchSum != cchTotal");
    }

    if(max(0l, yHeightMax) != max(0l, _yHeight))
    {
        TraceTag((tagWarning, "sigma (*this)[]._yHeight = %ld, _yHeight = %ld", yHeight, _yHeight));
        CMarkup *pMarkup = GetMarkup();
        AssertSz(!pMarkup, "sigma (*this)[]._yHeight != _yHeight");
    }
}


/*
 *  CDisplay::CheckView()
 *
 *  @mfunc
 *      Checks coherence between _iliFirstVisible, _dcpFirstVisible
 *      and _dyFirstVisible
 */
void CDisplay::CheckView()
{
}


/*
 *  CDisplay::VerifyFirstVisible
 *
 *  @mfunc  checks the coherence between FirstVisible line and FirstVisible dCP
 *
 *  @rdesc  TRUE if things are hunky dory; FALSE otherwise
 */
BOOL CDisplay::VerifyFirstVisible()
{
    return TRUE;
}
#endif

#if DBG==1 || defined(DUMPTREE)
void CDisplay::DumpLines()
{
    CTxtPtr      tp ( GetMarkup(), GetFlowLayout()->GetContentFirstCpForBrokenLayout() );
    LONG            yHeight = 0;

    if (!InitDumpFile())
        return;

    WriteString( g_f,
        _T("\r\n------------- LineArray -------------------------------\r\n" ));


    long    nLines = Count();
    CLineCore * pLine;
    CLineOtherInfo *ploi;
    
    WriteHelp(g_f, _T("CTxtSite     : 0x<0x>\r\n"), GetFlowLayoutElement());
    WriteHelp(g_f, _T("TextLength   : <0d>\r\n"), (long)GetFlowLayout()->GetContentTextLength());
    WriteHelp(g_f, _T("Bottom margin : <0d>\r\n"), (long)_yBottomMargin);

    for(long iLine = 0; iLine < nLines; iLine++)
    {
        pLine = Elem(iLine);
        ploi = pLine->oi();
        
        WriteHelp(g_f, _T("\r\nLine: <0d> - "), (long)iLine);
        WriteHelp(g_f, _T("Cp: <0d> - "), (long)tp.GetCp());

        // Write out all the flags.
        if (pLine->_fHasBulletOrNum)
            WriteString(g_f, _T("HasBulletOrNum - "));
        if (pLine->_fHasBreak)
            WriteString(g_f, _T("HasBreak - "));
        if (pLine->_fHasEOP)
            WriteString(g_f, _T("HasEOP - "));
        if (pLine->_fFirstInPara)
            WriteString(g_f, _T("FirstInPara - "));
        if (pLine->_fForceNewLine)
            WriteString(g_f, _T("ForceNewLine - "));
        if (pLine->_fHasNestedRunOwner)
            WriteString(g_f, _T("HasNestedRunOwner - "));
        if (pLine->_fDummyLine)
            WriteString(g_f, _T("DummyLine - "));
        if (pLine->_fHidden)
            WriteString(g_f, _T("Hidden - "));
        if (pLine->_fRelative)
            WriteString(g_f, _T("IsRelative - "));
        if (pLine->_fFirstFragInLine)
            WriteString(g_f, _T("FirstFrag - "));
        if (pLine->_fPartOfRelChunk)
            WriteString(g_f, _T("PartOfRelChunk - "));
        if (pLine->_fHasBackground)
            WriteString(g_f, _T("HasBackground - "));
        if (!pLine->_fCanBlastToScreen)
            WriteString(g_f, _T("Noblast - "));
        if (pLine->_fRTLLn)
            WriteString(g_f, _T("RTL - "));
        if (pLine->_fHasTransmittedLI)
            WriteString(g_f, _T("TransmittedLI - "));
        if (ploi->_fHasFirstLine)
            WriteString(g_f, _T("FirstLine - "));
        if (ploi->_fHasFirstLetter)
            WriteString(g_f, _T("FirstLetter - "));
        if (ploi->_fIsPadBordLine)
            WriteString(g_f, _T("EmptyPadBordEnd - "));
        if (ploi->_fHasInlineBgOrBorder)
            WriteString(g_f, _T("HasInlineBgOrBorder - "));
        if (ploi->_fHasAbsoluteElt)
            WriteString(g_f, _T("HasAbsoluteElt - "));
            
        if(pLine->IsFrame())
        {
            WriteString(g_f, _T("\r\n\tFrame "));
            WriteString(g_f, pLine->_fFrameBeforeText ?
                                _T("(B) ") :
                                _T("(A) "));
        }
        else if (pLine->IsClear())
        {
            WriteString(g_f, _T("\r\n\tClear     "));
        }
        else
        {
            WriteHelp(g_f, _T("\r\n\tcch = <0d>  "), (long)pLine->_cch);
        }

        // Need to cast stuff to (long) when using <d> as Format Specifier for Win16.
        WriteHelp(g_f, _T("y-Offset = <0d>, "), (long)yHeight);
        WriteHelp(g_f, _T("left-margin = <0d>, "), (long)ploi->_xLeftMargin);
        WriteHelp(g_f, _T("right-margin = <0d>, "), (long)ploi->_xRightMargin);
        WriteHelp(g_f, _T("xWhite = <0d>, "), (long)ploi->_xWhite);
        WriteHelp(g_f, _T("cchWhite = <0d> "), (long)ploi->_cchWhite);
        WriteHelp(g_f, _T("overhang = <0d>, "), (long)ploi->_xLineOverhang);
        WriteHelp(g_f, _T("\r\n\tleft  = <0d>, "), (long)ploi->_xLeft);
        WriteHelp(g_f, _T("right = <0d>, "), (long)pLine->_xRight);
        WriteHelp(g_f, _T("line-width = <0d>, "), (long)pLine->_xLineWidth);
        WriteHelp(g_f, _T("width = <0d>, "), (long)pLine->_xWidth);
        WriteHelp(g_f, _T("height = <0d>, "), (long)pLine->_yHeight);

        WriteHelp(g_f, _T("\r\n\tbefore-space = <0d>, "), (long)ploi->_yBeforeSpace);
        WriteHelp(g_f, _T("descent = <0d>, "), (long)ploi->_yDescent);
        WriteHelp(g_f, _T("txt-descent = <0d>, "), (long)ploi->_yTxtDescent);
        WriteHelp(g_f, _T("extent = <0d>, "), (long)ploi->_yExtent);
        WriteHelp(g_f, _T("loi = <0d>, "), (long)pLine->_iLOI);
        if(pLine->_cch)
        {
            WriteString( g_f, _T("\r\n\ttext = '"));
            DumpLineText(g_f, &tp, iLine);
        }

        WriteString( g_f, _T("\'\r\n"));
        
        if (pLine->_fForceNewLine)
            yHeight += pLine->_yHeight;
    }

    if(GetFlowLayout()->_fContainsRelative)
    {
        CRelDispNodeCache * prdnc = GetRelDispNodeCache();

        if(prdnc)
        {
            WriteString( g_f, _T("   -- relative disp node cache --  \r\n"));

            for(long i = 0; i < prdnc->Size(); i++)
            {
                CRelDispNode * prdn = (*prdnc)[i];

                WriteString(g_f, _T("\tElement: "));
                WriteString(g_f, (TCHAR *)prdn->GetElement()->TagName());
                WriteHelp(g_f, _T(", SN:<0d>,"), prdn->GetElement()->SN());

                WriteHelp(g_f, _T("\t\tLine: <0d>, "), prdn->_ili);
                WriteHelp(g_f, _T("cLines: <0d>, "), prdn->_cLines);
                WriteHelp(g_f, _T("yLine: <0d>, "), prdn->_yli);
                WriteHelp(g_f, _T("ptOffset(<0d>, <1d>), "), prdn->_ptOffset.x, prdn->_ptOffset.y);
                WriteHelp(g_f, _T("xAnchor(<0d>), "), prdn->_xAnchor);
                WriteHelp(g_f, _T("DispNode: <0x>,\r\n"), prdn->_pDispNode);
            }

            WriteString(g_f, _T("\r\n"));
        }
    }

    if (IsTagEnabled(tagDumpLineCache))
    {
        CLineInfoCache * pLineInfoCache = TLS(_pLineInfoCache);
        LONG iTotalRefs = 0;
        
        for (LONG i = 0; i < pLineInfoCache->Size(); i++)
        {
            iTotalRefs += pLineInfoCache->Refs(i);
        }
        if (iTotalRefs)
        {
            WriteHelp(g_f, _T("\r\nTotal %age saving = <0d>\r\n"), 100 - ((pLineInfoCache->CelsInCache() * 100) / iTotalRefs));

            LONG memUsedBefore = (sizeof(CLineFull) - sizeof(LONG)) * iTotalRefs;
            LONG memUsedNow;

            memUsedNow = iTotalRefs * sizeof(CLineCore);
            memUsedNow += pLineInfoCache->CelsInCache() * (sizeof(CLineOtherInfo) + sizeof(CDataCacheElem));
            WriteHelp(g_f, _T("Memused before = <0d>\r\n"), memUsedBefore);
            WriteHelp(g_f, _T("Memused now = <0d>\r\n"), memUsedNow);
            WriteHelp(g_f, _T("Mem savings = <0d>%\r\n"),
                      100 - ((memUsedNow * 100) / memUsedBefore));
        }         
    }
    
    CloseDumpFile();
}

void
CDisplay::DumpLineText(HANDLE hFile, CTxtPtr* ptp, long iLine)
{
    CLineCore * pLine = Elem(iLine);
    
    if(pLine->_cch)
    {
        TCHAR   chBuff [ 100 ];
        long    cchChunk;

        cchChunk = min( pLine->_cch, long( ARRAY_SIZE( chBuff ) ) );

        ptp->GetRawText( cchChunk, chBuff );

        WriteFormattedString( hFile, chBuff, cchChunk );

        if (pLine->_cch > cchChunk)
        {
            WriteString( hFile, _T("..."));
        }
        ptp->AdvanceCp(pLine->_cch);
    }
}
#endif

//==================================  Inversion (selection)  ============================



 //+==============================================================================
 //
 // Method: ShowSelected
 //
 // Synopsis: The "Selected-ness" between the two CTreePos's has changed.
 //           We tell the renderer about it - via Invalidate.
 //
 //           We also need to set the TextSelectionNess of any "sites"
 //           on screen
 //
 //-------------------------------------------------------------------------------
#define CACHED_INVAL_RECTS 20

DeclareTag(tagDisplayShowSelected, "Selection", "Selection CDisplay::ShowSelected output")
DeclareTag(tagDisplayShowInval, "Selection", "Selection show inval rects")

VOID CDisplay::ShowSelected(
    CTreePos* ptpStart,
    CTreePos* ptpEnd,
    BOOL fSelected    ) 
{
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement * pElement = pFlowLayout->ElementContent();
    CStackDataAry < RECT, CACHED_INVAL_RECTS > aryInvalRects(Mt(CDisplayShowSelectedRange_aryInvalRects_pv));
    
    AssertSz(pFlowLayout->IsInPlace(),
        "CDisplay::ShowSelected() called when not in-place active");

    int cpClipStart = ptpStart->GetCp( WHEN_DBG(FALSE));
    int cpClipFinish = ptpEnd->GetCp( WHEN_DBG(FALSE));
    Assert( cpClipStart <= cpClipFinish);

    if ( cpClipFinish > cpClipStart) // don't bother with cpClipFinish==cpClipStart
    {

        // 
        // we make the minimum selection size 3 chars to plaster over any off-by-one
        // problems with Region-From-Element, but we don't cross layout boundaries
        // or blocks
        //
    
        CTreePos *  ptpCur = ptpStart->PreviousNonPtrTreePos();

        //
        // expand one real (non-node) character to the left
        // without crossing layout or block boundaries.
        //
        
        while( ptpCur && ptpCur->IsNode() )
        {
            CElement * pElement = ptpCur->Branch()->Element();
        
            if (    pElement->ShouldHaveLayout() 
                ||  pElement->IsBlockElement()
                ||  pElement->Tag() == ETAG_ROOT)
            {
                break;
            }
            
            // we know we can skip this one
            cpClipStart--;

            // check the previous tree pos
            ptpCur = ptpCur->PreviousNonPtrTreePos();
        }

        // We hit real text before we hit a 
        // layout or the edge of the markup
        if (ptpCur && ptpCur->IsText())
        {
            // Overshoot intentionally by 
            // one character of real text.
            cpClipStart--;
        }
        
        //
        // expand one real (non-node) character to the right
        // without crossing layout or block boundaries.
        //

        ptpCur = ptpEnd;

        if( ptpCur->IsPointer() )
            ptpCur = ptpCur->NextNonPtrTreePos();

        while( ptpCur && ptpCur->IsNode() )
        {
            CElement * pElement = ptpCur->Branch()->Element();
        
            if (    pElement->ShouldHaveLayout() 
                ||  pElement->IsBlockElement()
                ||  pElement->Tag() == ETAG_ROOT)
            {
                break;
            }

            cpClipFinish++;

            ptpCur = ptpCur->NextNonPtrTreePos();
        }
         
        // We hit real text before we hit a 
        // layout or the edge of the markup
        if (ptpCur && ptpCur->IsText())
        {
            // Overshoot intentionally by 
            // one character of real text.
            cpClipFinish++;
        }

        //
        // Make sure the recalc has caught up
        //
        
        WaitForRecalc(min(GetLastCp(), long(cpClipFinish)), -1);

        //
        // Get the actual region
        //
      
        RegionFromElement( pElement, &aryInvalRects, NULL, NULL, RFE_SELECTION, cpClipStart, cpClipFinish, NULL ); 

#if DBG == 1
        TraceTag((tagDisplayShowSelected, "cpClipStart=%d, cpClipFinish=%d fSelected:%d", cpClipStart, cpClipFinish, fSelected));

        RECT dbgRect;
        int i;
        for ( i = 0; i < aryInvalRects.Size(); i++)
        {
            dbgRect = aryInvalRects[i];
            TraceTag((tagDisplayShowInval,"InvalRect Left:%d Top:%d, Right:%d, Bottom:%d", dbgRect.left, dbgRect.top, dbgRect.right, dbgRect.bottom));
        }
#endif 

        pFlowLayout->Invalidate(&aryInvalRects[0], aryInvalRects.Size());           

    }
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::GetViewHeightAndWidthForChild
//
// Synopsis:    returns the view width/height - padding
//
//-----------------------------------------------------------------------------
void
CDisplay::GetViewWidthAndHeightForChild(
    CParentInfo *   ppri,
    long *          pxWidthParent,
    long *          pyHeightParent,
    BOOL            fMinMax)
{
    long lPadding[SIDE_MAX];

    Assert(pxWidthParent && pyHeightParent);

    GetPadding(ppri, lPadding, fMinMax);

    *pxWidthParent  = max(0L, GetViewWidth() - lPadding[SIDE_LEFT] - lPadding[SIDE_RIGHT]);
    *pyHeightParent = max(0L, GetViewHeight() - lPadding[SIDE_TOP] - lPadding[SIDE_BOTTOM]);
}

//+----------------------------------------------------------------------------
//
// Member:      CDisplay::GetPadding
//
// Synopsis:    returns the top/left/right/bottom padding of the current
//              flowlayout
//
//-----------------------------------------------------------------------------
void
CDisplay::GetPadding(
    CParentInfo *   ppri,
    long            lPadding[],
    BOOL            fMinMax)
{
    CElement  * pElementFL   = GetFlowLayout()->ElementOwner();
    CTreeNode * pNode        = pElementFL->GetFirstBranch();
    CDoc      * pDoc         = pElementFL->Doc();
    ELEMENT_TAG etag         = pElementFL->Tag();
    long        lPaddingTop, lPaddingLeft, lPaddingRight, lPaddingBottom;
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(ppri->GetLayoutContext()));
    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(ppri->GetLayoutContext())); 
    BOOL fLayoutVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    LONG lFontHeight  = pCF->GetHeightInTwips(pDoc);

    //  This flag is TRUE if layout should be calculated in CSS1 strict mode. 
    BOOL fStrictCSS1Document =      pElementFL->HasMarkupPtr() 
                                &&  pElementFL->GetMarkupPtr()->IsStrictCSS1Document();

    long lParentWidth        = (fMinMax || fStrictCSS1Document)
                                ? ppri->_sizeParent.cx
                                : GetViewWidth();
    if(     _fDefPaddingSet
         && !pElementFL->IsEditable(/*fCheckContainerOnly*/FALSE) && !pElementFL->IsPrintMedia()    )
    {
        lPaddingTop    = _defPaddingTop;
        lPaddingBottom = _defPaddingBottom;
    }
    else
    {
        lPaddingTop    = 
        lPaddingBottom = 0;
    }

    if (etag != ETAG_TC)
    {
        lPaddingTop +=
            pFF->GetLogicalPadding(SIDE_TOP, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
                                // (srinib) parent width is intentional as per css spec

        lPaddingBottom +=
            pFF->GetLogicalPadding(SIDE_BOTTOM, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
                                // (srinib) parent width is intentional as per css spec

        lPaddingLeft =
            pFF->GetLogicalPadding(SIDE_LEFT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);


        lPaddingRight =
            pFF->GetLogicalPadding(SIDE_RIGHT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);

        if (    etag == ETAG_BODY
            &&  !GetFlowLayout()->GetOwnerMarkup()->IsHtmlLayout() )
        {
            lPaddingLeft  +=
                pFF->GetLogicalMargin(SIDE_LEFT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingRight +=
                pFF->GetLogicalMargin(SIDE_RIGHT, fLayoutVertical, fWritingModeUsed).XGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingTop +=
                pFF->GetLogicalMargin(SIDE_TOP, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
            lPaddingBottom +=
                pFF->GetLogicalMargin(SIDE_BOTTOM, fLayoutVertical, fWritingModeUsed).YGetPixelValue(ppri, lParentWidth, lFontHeight);
        } 
    }
    else
    {
        lPaddingLeft = 0;
        lPaddingRight = 0; 
    }

    //
    // negative padding is not supported. What does it really mean?
    //
    lPadding[SIDE_TOP]    = lPaddingTop > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingTop < 0 ? 0 : lPaddingTop;
    lPadding[SIDE_BOTTOM] = lPaddingBottom > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingBottom < 0 ? 0 : lPaddingBottom;
    lPadding[SIDE_LEFT]   = lPaddingLeft > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingLeft < 0 ? 0 : lPaddingLeft;
    lPadding[SIDE_RIGHT]  = lPaddingRight > SHRT_MAX
                             ? SHRT_MAX
                             : lPaddingRight < 0 ? 0 : lPaddingRight;

    _fContainsVertPercentAttr |= pFF->HasLogicalPercentVertPadding(fLayoutVertical, fWritingModeUsed);
    _fContainsHorzPercentAttr |= pFF->HasLogicalPercentHorzPadding(fLayoutVertical, fWritingModeUsed);
}


//+----------------------------------------------------------------------------
//
// Member:      GetRectForChar
//
// Synopsis:    Returns the top, the bottom and the width for a character
//
//  Notes:      If pWidth is not NULL, the witdh of ch is returned in it.
//              Otherwise, ch is ignored.
//-----------------------------------------------------------------------------

void
CDisplay::GetRectForChar(
                    CCalcInfo  *pci,
                    LONG       *pTop,
                    LONG       *pBottom,
                    LONG        yTop,
                    LONG        yProposed,
                    CLineFull  *pli,
                    CTreePos   *ptp)
{
    CCcs     ccs;
    const CBaseCcs *pBaseCcs;
    CTreeNode *pNode = ptp->GetBranch();
    const CCharFormat *pcf = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    
    Assert(pci && pTop && pBottom && pli && pcf);
    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
    {
        *pTop = *pBottom = 0;
        goto Cleanup;
    }
    pBaseCcs = ccs.GetBaseCcs();
    Assert(pBaseCcs);

    *pBottom = yTop + pli->_yHeight - pli->_yDescent + pli->_yTxtDescent;
    *pTop = *pBottom - pBaseCcs->_yHeight -
            (pli->_yTxtDescent - pBaseCcs->_yDescent);

    if (yProposed != LONG_MIN)
    {
        // I need to pull this run up so that its only yDelta from the top
        LONG yDiff = *pTop - yTop;
        LONG yDelta = yDiff - yProposed;
        *pTop -= yDelta;
        *pBottom -= yDelta;
        Assert(*pTop - yTop == yProposed);
    }
    
    if (pNode->HasInlineMBP(LC_TO_FC(pci->GetLayoutContext())))
    {
        CRect rc;
        BOOL fIgnore;
        pNode->GetInlineMBPContributions(pci, GIMBPC_ALL, &rc, &fIgnore, &fIgnore);
        *pBottom += max(0l, rc.bottom);
        *pTop -= max(0l, rc.top);
    }
    
Cleanup:    
    ccs.Release();
}


//+----------------------------------------------------------------------------
//
// Member:      GetTopBottomForCharEx
//
// Synopsis:    Returns the top and the bottom for a character
//
// Params:  [pDI]:     The DI
//          [pTop]:    The top is returned in this
//          [pBottom]: The bottom is returned in this
//          [yTop]:    The top of the line containing the character
//          [pli]:     The line itself
//          [xPos]:    The xPos at which we need the top/bottom
//          [ptp]:     ptp owning the char
//
//-----------------------------------------------------------------------------
void
CDisplay::GetTopBottomForCharEx(
                             CCalcInfo     *pci,
                             LONG          *pTop,
                             LONG          *pBottom,
                             LONG           yTop,
                             CLineFull     *pli,
                             LONG           xPos,
                             LONG           yProposed,
                             CTreePos      *ptp,
                             BOOL          *pfBulletHit)
{
    //
    // If we are on a line in a list, and we are on the area occupied
    // (horizontally) by the bullet, then we want to find the height
    // of the bullet.
    //

    if (    pli->_fHasBulletOrNum
        &&  (   (   xPos >= pli->_xLeftMargin
                &&  xPos < pli->GetTextLeft()))
       )
    {
        Assert(pci && pTop && pBottom && pli);

        *pBottom = yTop + pli->_yHeight - pli->_yDescent;
        *pTop = *pBottom - pli->_yBulletHeight;
        if (pfBulletHit)
            *pfBulletHit = TRUE;
    }
    else
    {
        GetRectForChar(pci, pTop, pBottom, yTop, yProposed, pli, ptp);
    }
}


//+----------------------------------------------------------------------------
//
// Member:      GetClipRectForLine
//
// Synopsis:    Returns the clip rect for a given line
//
// Params:  [prcClip]: Returns the rect for the line
//          [pTop]:    The top is returned in this
//          [pBottom]: The bottom is returned in this
//          [yTop]:    The top of the line containing the character
//          [pli]:     The line itself
//          [pcf]:     Character format for the char
//
//-----------------------------------------------------------------------------
void
CDisplay::GetClipRectForLine(RECT *prcClip, LONG top, LONG xOrigin, CLineCore *pli, CLineOtherInfo *ploi) const
{
    Assert(prcClip && pli);

    prcClip->left   = xOrigin + ploi->GetTextLeft();
    prcClip->right  = xOrigin + pli->GetTextRight(ploi);

    if (pli->_fForceNewLine)
    {
        if (!pli->_fRTLLn)
        {
            prcClip->right += ploi->_xWhite;
        }
        else
        {
            prcClip->left -= ploi->_xWhite;
        }
    }
    prcClip->top    = top + pli->GetYTop(ploi);
    prcClip->bottom = top + pli->GetYBottom(ploi);
}


//=================================  IME support  ===================================

#ifdef DBCS

/*
 *  ConvGetRect
 *
 *  Purpose:
 *      Converts a rectangle obtained from Windows for a vertical control
 *
 *  Arguments:
 *      prc     Rectangle to convert
 */
void ConvGetRect(LPRECT prc, BOOL fVertical)
{
    RECT    rc;
    INT     xWidth;
    INT     yHeight;

    if(fVertical)
    {
        rc          = *prc;
        xWidth      = rc.right - rc.left;
        yHeight     = rc.bottom - rc.top;
        prc->left   = rc.top;
        prc->top    = rc.left;
        prc->right  = rc.top + yHeight;
        prc->bottom = rc.left + xWidth;
    }
}

/*
 *  VwUpdateIMEWindow(ped)
 *
 *  Purpose:
 *      Update position of IME candidate/composition string
 *
 *  Arguments:
 */
VOID VwUpdateIMEWindow(CPED ped)
{
    POINTL  pt;
    RECT    rc;
    SIZE    size;

    if((ped->_dwStyle & ES_NOIME) && (ped->_dwStyle & ES_SELFIME))
        return;

    ConvGetRect(ped->_fVertical, &rc);


    rc.left     = _pdp->GetViewLeft();
    rc.top      = _pdp->GetViewTop();
    rc.right    = _pdp->GetViewWidth() + _pdp->GetViewLeft();
    rc.bottom   = _pdp->GetViewHeight() + _pdp->GetViewTop();

    size.cy     = ped->_yHeightCaret;
    size.cx     = ped->_yHeightCaret;

    if(ped->_fVertical)
    {
        ConvSetRect(&rc);
        pt.y    = (INT)ped->_xCaret - size.cx;
        pt.x    = ped->_xWidth - (INT)ped->_yCaret;
    }
    else
    {
        pt.x    = (INT)ped->_xCaret;
        pt.y    = (INT)ped->_yCaret;
    }

    SetIMECandidatePos (ped->_hwnd, pt, (LPRECT)&rc, &size);
}
#endif

//+----------------------------------------------------------------------------
//
// Member:      GetWigglyFromRange
//
// Synopsis:    Gets rectangles to use for focus rects. This
//              element or range.
//
//-----------------------------------------------------------------------------
HRESULT
CDisplay::GetWigglyFromRange(CDocInfo * pdci, long cp, long cch, CShape ** ppShape)
{
    CStackDataAry<RECT, 8> aryWigglyRects(Mt(CDisplayGetWigglyFromRange_aryWigglyRect_pv));
    HRESULT         hr = S_FALSE;
    CWigglyShape *  pShape = NULL;
    CMarkup *       pMarkup = GetMarkup();
    long            ich, cRects;
    CTreePos *      ptp      = pMarkup->TreePosAtCp(cp, &ich, TRUE);
    CTreeNode *     pNode    = ptp->GetBranch();
    CElement *      pElement = pNode->Element();

    if (!cch)
    {
        goto Cleanup;
    }

    pShape = new CWigglyShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // get all of the rectangles that apply and load them into CWigglyShape's
    // array of CRectShapes.
    // RegionFromElement will give rects for any chunks within the number of
    // lines required.
    RegionFromElement( pElement, 
                       &aryWigglyRects, 
                       NULL, 
                       NULL, 
                       RFE_WIGGLY, 
                       cp,               // of lines that have different heights
                       cp + cch, 
                       NULL ); 

    for(cRects = 0; cRects < aryWigglyRects.Size(); cRects++)
    {
        CRectShape * pWiggly = NULL;

        pWiggly = new CRectShape;
        if (!pWiggly)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pWiggly->_rect = aryWigglyRects[cRects];

        // Expand the focus shape by shifting the left edges by 1 pixel.
        // This is a hack to get around the fact that the Windows
        // font rasterizer occasionally uses the leftmost pixel column of its
        // measured text area, and if we don't do this, the focus rect
        // overlaps that column.  IE bug #76378, taken for NT5 RTM (ARP).
        if (   pWiggly->_rect.left > 0
            && pWiggly->_rect.left != pWiggly->_rect.right )    // don't expand empty rects
        {
            --(pWiggly->_rect.left);
        }

        pShape->_aryWiggly.Append(pWiggly);

    }

    *ppShape = pShape;
    hr = S_OK;

Cleanup:
    if (hr && pShape)
    {
        delete pShape;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member:      GetAveCharSize
//
// Synopsis:    Gets size of average characger for the flow layout.
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar)
{
    BOOL fRet = FALSE;
    XHDC hdc = pci->_hdc;

    Assert(psizeChar);
    psizeChar->cx = psizeChar->cy = 0;

    // Get first text ptp for the flow layout
    CTreeNode * pNode = GetFlowLayoutElement()->GetFirstBranch();
    CTreePos * ptp = pNode->GetBeginPos();
    while (ptp && !ptp->IsText())
        ptp = ptp->NextTreePos();

    if (ptp)
    {
        // Get first character of the flow layout
        TCHAR ach[2];
        CTxtPtr tp(GetMarkup(), ptp->GetCp());
        ach[0] = tp.GetChar();
        ach[1] = _T('\0');

        // Create run for the first character of the flow layout
        COneRun onerun;
        memset(&onerun, 0, sizeof(onerun));
        onerun._fInnerCF = TRUE;    // same scope
        onerun._pCF = (CCharFormat* )pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
#if DBG == 1
        onerun._pCFOriginal = onerun._pCF;
#endif
        onerun._pFF = (CFancyFormat*)pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
        onerun._bConvertMode = CM_UNINITED;
        onerun._ptp = ptp;
        onerun.SetSidFromTreePos(ptp);
        onerun._lscch = 1;
        onerun._pchBase = ach;


        // Ununify sidHan script
        if (onerun._sid == sidHan)
        {
            CCcs ccsFLF;
            GetCcs(&ccsFLF, &onerun, hdc, pci, FALSE);
            const CBaseCcs * pBaseCcsFLF = ccsFLF.GetBaseCcs();
            const UINT uiFamilyCodePage = GetMarkup()->GetFamilyCodePage();

            SCRIPT_IDS sidsFace = 0;
            if (pBaseCcsFLF)
                sidsFace = fc().EnsureScriptIDsForFont(hdc, pBaseCcsFLF, FC_SIDS_USEMLANG);
            onerun._sid = fl().UnunifyHanScript(uiFamilyCodePage, 
                onerun.GetCF()->_lcid, sidsFace, onerun._pchBase, &onerun._lscch);

            ccsFLF.Release();
        }

        // Disambiguate ScriptId
        if (onerun._sid == sidAmbiguous)
        {
            onerun._sid = fl().DisambiguateScript(GetMarkup()->GetFamilyCodePage(), 
                onerun.GetCF()->_lcid, sidDefault, onerun._pchBase, &onerun._lscch);
        }

        // Get average character width, fontlink if necessary
        CCcs ccs;
        GetCcs(&ccs, &onerun, hdc, pci);
        const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
        if (pBaseCcs && !hdc.IsEmpty() && pBaseCcs->HasFont())
        {
            psizeChar->cy = pBaseCcs->_yHeight;

            FONTIDX hfontOld = ccs.PushFont(hdc);
            UINT iCharForAveWidth = g_aSidInfo[onerun._sid]._iCharForAveWidth;
            GetCharWidthHelper(hdc, iCharForAveWidth, (LPINT)&psizeChar->cx);
            if(pBaseCcs->_fScalingRequired) 
                psizeChar->cx *= pBaseCcs->_flScaleFactor;
            ccs.PopFont(hdc, hfontOld);

            if (psizeChar->cx == 0)
                psizeChar->cx = pBaseCcs->_xAveCharWidth;

            fRet = TRUE;
        }
        ccs.Release();
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
// Member:      GetCcs
//
// Synopsis:    Gets the suitable font (CCcs) for the given COneRun.
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::GetCcs(CCcs * pccs, COneRun *por, XHDC hdc, CDocInfo *pdi, BOOL fFontLink)
{
    Assert(pccs);
    
    const CCharFormat *pCF = por->GetCF();
    const BOOL fDontFontLink =    !por->_ptp
                               || !por->_ptp->IsText()
                               || !fFontLink
                               || pCF->_bCharSet == SYMBOL_CHARSET
                               || pCF->_fDownloadedFont
                               || (pdi->_pDoc->_pWindowPrimary && pdi->_pMarkup->GetCodePage() == 50000);

    BOOL fCheckAltFont;   // TRUE if _pccsCache does not have glyphs needed for sidText
    SCRIPT_ID sidAlt = 0;
    BYTE bCharSetAlt = 0;
    SCRIPT_ID sidText;

    if (fc().GetCcs(pccs, hdc, pdi, pCF))
    {
        if (CM_UNINITED != por->_bConvertMode)
        {
            pccs->SetConvertMode((CONVERTMODE)por->_bConvertMode); 
        }
    }
    else
    {
        AssertSz(0, "CCcs failed to be created.");
        goto Cleanup;
    }

    if (fDontFontLink)
        goto Cleanup;

    //
    // Check if the pccs covers the sid of the text run
    //

    sidText = por->_sid;

    AssertSz( sidText != sidMerge, "Script IDs should have been merged." );
    AssertSz( sidText != sidAmbiguous, "Script IDs should have been disambiguated." );

    {
        // sidHalfWidthKana has to be treated as sidKana
        if (sidText == sidHalfWidthKana)
            sidText = sidKana;

        const CBaseCcs * pBaseCcs = pccs->GetBaseCcs();
        Assert(pBaseCcs);

        if (sidText == sidDefault)
        {
            fCheckAltFont = FALSE; // Assume the author picked a font containing the glyph.  Don't fontlink.
        }
        else if (sidText == sidEUDC)
        {
            const UINT uiFamilyCodePage = pdi->_pMarkup->GetFamilyCodePage();
            SCRIPT_ID sidForPUA;
            
            fCheckAltFont = ShouldSwitchFontsForPUA(hdc, uiFamilyCodePage, pBaseCcs, pCF, &sidForPUA);
            if (fCheckAltFont)
            {
                sidText = sidAlt = sidAmbiguous;
                bCharSetAlt = DefaultCharSetFromScriptAndCodePage( sidForPUA, uiFamilyCodePage );
            }
        }
        else 
        {
            fCheckAltFont = (pBaseCcs->_sids & ScriptBit(sidText)) == sidsNotSet;
        }
    }

    if (!fCheckAltFont)
        goto Cleanup;

    //
    // Check to see if the _ccsAltCache covers the sid of the text run
    //
    
    if (sidText != sidAmbiguous)
    {
        SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, pccs->GetBaseCcs(), FC_SIDS_USEMLANG);

        if (IsFESid(sidText))
        {
            // 
            // To render FE characters we need to keep current font if only possible,
            // even if it is used to render non-native characters.
            // So try to pickup the most appropriate charset, because GDI prefers 
            // charset over font face during font creation.
            // In case of FE lang id, use charset appropriate for it. This is because
            // lang id has highest priority font selection in case of FE characters.
            //
            if (pCF->_lcid)
            {
                bCharSetAlt = CharSetFromLangId(LANGIDFROMLCID(pCF->_lcid));
                if (!IsFECharset(bCharSetAlt))
                {
                    bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, pdi->_pMarkup->GetFamilyCodePage());
                }
            }
            else
                bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, pdi->_pMarkup->GetFamilyCodePage());
        }
        else
            bCharSetAlt = DefaultCharSetFromScriptAndCodePage(sidText, pdi->_pMarkup->GetFamilyCodePage());

        if ((sidsFace & ScriptBit(sidText)) == sidsNotSet)
        {
            sidAlt = sidText;           // current face does not cover
        }
        else
        {
            sidAlt = sidAmbiguous;      // current face does cover
        }
    }

    //
    // Looks like we need to pick a new alternate font
    //
    {
        CCharFormat cfAlt = *pCF;

        // sidAlt of sidAmbiguous at this point implies we have the right facename,
        // but the wrong GDI charset.  Otherwise, lookup in the registry/mlang to
        // determine an appropriate font for the given script id.

        if (sidAlt != sidAmbiguous)
        {
            SelectScriptAppropriateFont(sidAlt, bCharSetAlt, pdi->_pDoc, pdi->_pMarkup, &cfAlt);
        }
        else
        {
            cfAlt._bCharSet = bCharSetAlt;
            cfAlt._bCrcFont = cfAlt.ComputeFontCrc();
        }

        CCcs ccsForFontLink = *pccs;
        if (fc().GetFontLinkCcs(pccs, hdc, pdi, &ccsForFontLink, &cfAlt))
        {
            pccs->MergeSIDs(ScriptBit(sidAlt));
        }
        ccsForFontLink.Release();
    }

Cleanup:
    Assert(!pccs->GetBaseCcs() || pccs->GetHDC() == hdc);
    return !!pccs->GetBaseCcs();
}

void
CDisplay::GetExtraClipValues(LONG *plLeftV, LONG *plRightV)
{
    *plLeftV = *plRightV = 0;
    if (_fHasNegBlockMargins)
    {
        CLineFull lif;
        LONG left = LONG_MAX;
        LONG right = LONG_MAX;
        for (LONG i = 0; i < LineCount(); i++)
        {
            lif = *Elem(i);
            left = min(left, lif._xLeft);
            right = min(right, lif._xRight);
        }
        if (left < 0)
            *plLeftV = -left;
        if (right < 0)
            *plRightV = -right;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\doc.cxx ===
/*
 *  @doc INTERNAL
 *
 *  @module DOC.C   CTxtStory and CTxtArray implementation |
 *
 *  Original Authors: <nl>
 *      Original RichEdit code: David R. Fulmer <nl>
 *      Christian Fortini   <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  Cleanup and reorganization
 *
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif


MtDefine(CTxtBlk, Tree, "CTxtBlk")
MtDefine(CTxtBlkData, CTxtBlk, "CTxtBlk data")
MtDefine(CTxtArray, Tree, "CTxtArray")
MtDefine(CTxtArray_pv, CTxtArray, "CTxtArray::_pv")
MtDefine(CRunArray, Tree, "CRunArray")
MtDefine(CRunArray_pv, CRunArray, "CRunArray::_pv")
MtDefine(CLineArray, Tree, "CLineArray")
MtDefine(CLineArray_pv, CLineArray, "CLineArray::_pv")
MtDefine(CListCache, Tree, "CListCache")
MtDefine(CListCacheInst, Tree, "CListCacheInst")
MtDefine(CListIndexArray, Tree, "CListIndexArray")
MtDefine(CListIndexArray_pv, CListIndexArray, "CListIndexArray::_pv")
MtDefine(CCharFormat, Tree, "CCharFormat")
MtDefine(CParaFormat, Tree, "CParaFormat")
MtDefine(CFancyFormat, Tree, "CFancyFormat")
MtDefine(CFancyFormat_pszFilters, CFancyFormat, "CFancyFormat::_pscFilters")
MtDefine(CPseudoElementInfo, Tree, "CPseudoElementInfo")


// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================


#if DBG==1

/*
 *  CTxtArray::Invariant
 *
 *  @mfunc  Tests CTxtArray's state
 *
 *  @rdesc  returns TRUE always; failures are indicated by Asserts
 */

BOOL
CTxtArray::Invariant(  ) const
{
    static LONG numTests = 0;
    numTests++;             // how many times we've been called.

    if ( Count() > 0 )
    {

        // make sure total characters stored in the blocks match the length
        // that is stored in _cchText.
        long  cch = 0;
        DWORD i, iMax;

        iMax = Count();

        for ( i = 0; i < iMax; i++ )
        {
            CTxtBlk *ptb = Elem(i);

            // ptb shouldn't be NULL since we're within Count elements
            Assert(ptb);

            long currCch = ptb->_cch;

            cch += currCch;

            Assert ( currCch >= 0 );
            Assert ( currCch <= long(CchOfCb(ptb->_cbBlock)) );

            // while we're here, check the range of the interblock gaps.
            Assert (ptb->_ibGap <= ptb->_cbBlock);


            DWORD cchGap = CchOfCb(ptb->_ibGap);

            Assert ( long(cchGap) <= currCch );

        }
        Assert ( cch == GetCch() );
    }

    return TRUE;
}

#endif

/*
 *  CTxtArray::CTxtArray
 *
 *  @mfunc      Text array constructor
 *
 */
CTxtArray::CTxtArray()
    : CArray<CTxtBlk>(Mt(CTxtArray_pv))
{
    AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2,
        "cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

    _cchText = 0;
}

/*
 *  CTxtArray::~CTxtArray
 *
 *  @mfunc      Text array destructor
 */
CTxtArray::~CTxtArray()
{
    DWORD itb = Count();

    while(itb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb)->FreeBlock();
    }
}

/*
 *  CTxtArray::RemoveAll
 *
 *  @mfunc      Removes all characters in the array
 */
void
CTxtArray::RemoveAll()
{
    DWORD itb = Count();

    while(itb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb)->FreeBlock();
    }

    Clear( AF_DELETEMEM );

    _cchText = 0;
}


/*
 *  CTxtArray::GetCch()
 *
 *  @mfunc      Computes and return length of text in this text array
 *
 *  @rdesc      The number of character in this text array
 *
 *  @devnote    This call may be computationally expensive; we have to
 *              sum up the character sizes of all of the text blocks in
 *              the array.
 */

long
CTxtArray::GetCch ( ) const
{
//    _TEST_INVARIANT_

    DWORD itb = Count();
    long  cch = 0;

    while (itb--)
    {
        Assert(Elem(itb) != NULL);
        cch += Elem(itb)->_cch;
    }

    return cch;
}

/*
 *  CTxtArray::AddBlock(itbNew, cb)
 *
 *  @mfunc      create new text block
 *
 *  @rdesc
 *      FALSE if block could not be added
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects:
 *      moves text block array
 */
BOOL CTxtArray::AddBlock(
    DWORD   itbNew,     //@parm index of the new block
    LONG    cb)         //@parm size of new block; if <lt>= 0, default is used
{
    _TEST_INVARIANT_

    CTxtBlk *ptb;

    if(cb <= 0)
        cb = cbBlockInitial;

    AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
    AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

    ptb = Insert(itbNew, 1);

    if( !ptb || !ptb->InitBlock(cb))
    {
        TraceTag((tagError, "TXTARRAT::AddBlock() - unable to allocate new block"));
        return FALSE;
    }

    return TRUE;
}

/*
 *  CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *
 *  @mfunc      split a text block into two
 *
 *  @rdesc
 *      FALSE if the block could not be split <nl>
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block array
 */
BOOL CTxtArray::SplitBlock(
    DWORD itb,          //@parm index of the block to split
    DWORD ichSplit,     //@parm character index within block at which to split
    DWORD cchFirst,     //@parm desired extra space in first block
    DWORD cchLast,      //@parm desired extra space in new block
    BOOL fStreaming)    //@parm TRUE if streaming in new text
{
    _TEST_INVARIANT_

    LPBYTE pbSrc;
    LPBYTE pbDst;
    CTxtBlk *ptb, *ptb1;

    AssertSz(ichSplit > 0 || cchFirst > 0, "CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");

    ptb = Elem(itb);

    // compute size for first half

    AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
        "CTxtArray::SplitBlock(): first size too large");
    cchFirst += ichSplit + cchGapInitial;
    // Does not work!, need fail to occur. jonmat cchFirst = min(cchFirst, CchOfCb(cbBlockMost));
    // because our client expects cchFirst chars.

    // NOTE (cthrash) I *think* this should work but I also *know* this
    // code needs to be revisited.  Basically, there are Asserts sprinkled
    // about the code requiring the _cbBlock < cbBlockMost.  We can of course
    // exceed that if we insist on tacking on cchGapInitial (See AssertSz
    // above).  My modifications make certain you don't.  It would seem fine
    // except for the comment by jonmat.

    // (cthrash) jonmat's comment makes no sense to me.  The new buffer size
    // *wants* to cchFirst + ichSplit + cchGapInitial; it seems to me that
    // it'll be ok as long as we give it a gap >= 0.
    cchFirst = min(cchFirst, (DWORD)CchOfCb(cbBlockMost));

    // compute size for second half

    AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
        "CTxtArray::SplitBlock(): second size too large");
    cchLast += ptb->_cch - ichSplit + cchGapInitial;
    // Does not work!, need fail to occur. jonmat cchLast = min(cchLast, CchOfCb(cbBlockMost));
    // because our client expects cchLast chars.

    // (cthrash) see comment above with cchFirst.
    cchLast = min(cchLast, (DWORD)CchOfCb(cbBlockMost));

    // allocate second block and move text to it

    // ***** moves rgtb ***** //
    // if streaming in, allocate a block that's as big as possible so that
    // subsequent additions of text are faster
    // we always fall back to smaller allocations so this won't cause
    // unneccesary errors
    // when we're done streaming we compress blocks, so this won't leave
    // a big empty gap
    if(fStreaming)
    {
        DWORD cb = cbBlockMost;
        const DWORD cbMin = CbOfCch(cchLast);

        while(cb >= cbMin && !AddBlock(itb + 1, cb))
            cb -= cbBlockCombine;
        if(cb >= cbMin)
            goto got_block;
    }
    if(!AddBlock(itb + 1, CbOfCch(cchLast)))
    {
        TraceTag((tagError, "CTxtArray::SplitBlock(): unabled to add new block"));
        return FALSE;
    }

got_block:
    ptb1 = Elem(itb+1); // recompute ptb after rgtb moves
    ptb = Elem(itb);    // recompute ptb after rgtb moves
    ptb1->_cch = ptb->_cch - ichSplit;
    ptb1->_ibGap = 0;
    pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
    ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
    pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
    CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
    ptb->_cch = ichSplit;
    ptb->_ibGap = CbOfCch(ichSplit);

    // resize the first block
    if(CbOfCch(cchFirst) != ptb->_cbBlock)
    {
//$ FUTURE: don't resize unless growing or shrinking considerably
        if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
        {
            // Review, if this fails then we need to delete all of the Added blocks, right? jonmat
            TraceTag((tagError, "TXTARRA::SplitBlock(): unabled to resize block"));
            return FALSE;
        }
    }

    return TRUE;
}


/*
 *  CTxtArray::ShrinkBlocks()
 *
 *  @mfunc      Shrink all blocks to their minimal size
 *
 *  @rdesc
 *      nothing
 *
 */
void CTxtArray::ShrinkBlocks()
{
    _TEST_INVARIANT_

    DWORD itb = Count();
    CTxtBlk *ptb;

    while(itb--)
    {
        ptb = Elem(itb);
        Assert(ptb);
        ptb->ResizeBlock(CbOfCch(ptb->_cch));
    }
}


/*
 *  CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *
 *  @mfunc      remove a range of text blocks
 *
 *  @rdesc
 *      nothing
 *
 *  @comm Side Effects: <nl>
 *      moves text block array
 */
VOID CTxtArray::RemoveBlocks(
    DWORD itbFirst,         //@parm index of first block to remove
    DWORD ctbDel)           //@parm number of blocks to remove
{
    _TEST_INVARIANT_

    DWORD itb = itbFirst;
    DWORD ctb = ctbDel;

    AssertSz(itb + ctb <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

    while(ctb--)
    {
        Assert(Elem(itb) != NULL);
        Elem(itb++)->FreeBlock();
    }

    Remove(itbFirst, ctbDel, AF_KEEPMEM);
}


/*
 *  CTxtArray::CombineBlocks(itb)
 *
 *  @mfunc      combine adjacent text blocks
 *
 *  @rdesc
 *      TRUE if blocks were combined, otherwise false
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block array
 *
 *  @devnote
 *      scans blocks from itb - 1 through itb + 1 trying to combine
 *      adjacent blocks
 */
BOOL CTxtArray::CombineBlocks(
    DWORD itb)      //@parm index of the first block modified
{
    _TEST_INVARIANT_

    DWORD ctb;
    DWORD cbT;
    CTxtBlk *ptb, *ptb1;
    BOOL  fRet = FALSE;

    if(itb > 0)
        itb--;

    ctb = min(3, int(Count() - itb));
    if(ctb <= 1)
        return FALSE;

    for(; ctb > 1; ctb--)
    {
        ptb  = Elem(itb);                       // Can we combine current
        ptb1 = Elem(itb+1);                     //  and next blocks ?
        cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
        if(cbT <= cbBlockInitial)
        {                                           // Yes
            if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
                continue;
            ptb ->MoveGap(ptb->_cch);               // Move gaps at ends of
            ptb1->MoveGap(ptb1->_cch);              //  both blocks
            CopyMemory(ptb->_pch + ptb->_cch,       // Copy next block text
                ptb1->_pch, CbOfCch(ptb1->_cch));   //  into current block
            ptb->_cch += ptb1->_cch;
            ptb->_ibGap += CbOfCch(ptb1->_cch);
            RemoveBlocks(itb+1, 1);                 // Remove next block
            fRet = TRUE;
        }
        else
            itb++;
    }

    return fRet;
}

/*
 *  CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *
 *  @mfunc
 *      Get content of text chunk in this text array into a string
 *
 *  @rdesc
 *      remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
    TCHAR **ppch,           //@parm ptr to ptr to buffer to copy text chunk into
    DWORD cch,              //@parm length of pch buffer
    TCHAR *pchChunk,        //@parm ptr to text chunk
    DWORD cchCopy) const    //@parm count of characters in chunk
{
    _TEST_INVARIANT_

    if(cch > 0 && cchCopy > 0)
    {
        if(cch < cchCopy)
            cchCopy = cch;                      // Copy less than full chunk
        CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
        *ppch   += cchCopy;                     // Adjust target buffer ptr
        cch     -= cchCopy;                     // Fewer chars to copy
    }
    return cch;                                 // Remaining count to copy
}


// ========================  CTxtBlk class  =================================


/*
 *  CTxtBlk::InitBlock(cb)
 *
 *  @mfunc
 *      Initialize this text block
 *
 *  @rdesc
 *      TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
    DWORD cb)           //@parm initial size of the text block
{
    _pch    = NULL;
    _cch    = 0;
    _ibGap  = 0;

    if (cb)
        _pch = (TCHAR*)MemAllocClear(Mt(CTxtBlkData), cb);

    MemSetName((_pch, "CTxtBlk data"));

    if (_pch)
    {
        _cbBlock = cb;
        return TRUE;
    }
    else
    {
        _cbBlock = 0;
        return FALSE;
    }
}

/*
 *  CTxtBlk::FreeBlock()
 *
 *  @mfunc
 *      Free this text block
 *
 *  @rdesc
 *      nothing
 */
VOID CTxtBlk::FreeBlock()
{
    MemFree(_pch);
    _pch    = NULL;
    _cch    = 0;
    _ibGap  = 0;
    _cbBlock= 0;
}

/*
 *  CTxtBlk::MoveGap(ichGap)
 *
 *  @mfunc
 *      move gap in this text block
 *
 *  @rdesc
 *      nothing
 */
void CTxtBlk::MoveGap(
    DWORD ichGap)           //@parm new position for the gap
{
    DWORD cbMove;
    DWORD ibGapNew = CbOfCch(ichGap);
    LPBYTE pbFrom = (LPBYTE) _pch;
    LPBYTE pbTo;

    if(ibGapNew == _ibGap)
        return;

    if(ibGapNew < _ibGap)
    {
        cbMove = _ibGap - ibGapNew;
        pbFrom += ibGapNew;
        pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
    }
    else
    {
        cbMove = ibGapNew - _ibGap;
        pbTo = pbFrom + _ibGap;
        pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
    }

    MoveMemory(pbTo, pbFrom, cbMove);
    _ibGap = ibGapNew;
}


/*
 *  CTxtBlk::ResizeBlock(cbNew)
 *
 *  @mfunc
 *      resize this text block
 *
 *  @rdesc
 *      FALSE if block could not be resized <nl>
 *      non-FALSE otherwise
 *
 *  @comm
 *  Side Effects: <nl>
 *      moves text block
 */
BOOL CTxtBlk::ResizeBlock(
    DWORD cbNew)        //@parm the new size
{
    TCHAR *pch;
    DWORD cbMove;
    HRESULT hr;

    AssertSz(cbNew > 0, "resizing block to size <= 0");

    if(cbNew < _cbBlock)
    {
        if(_ibGap != CbOfCch(_cch))
        {
            // move text after gap down so that it doesn't get dropped

            cbMove = CbOfCch(_cch) - _ibGap;
            pch = _pch + CchOfCb(_cbBlock - cbMove);
            MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
        }
        _cbBlock = cbNew;
    }
    pch = _pch;
    hr = MemRealloc(Mt(CTxtBlkData), (void **) & pch, cbNew);
    if(hr)
        return _cbBlock == cbNew;   // FALSE if grow, TRUE if shrink

    _pch = pch;
    if(cbNew > _cbBlock)
    {
        if(_ibGap != CbOfCch(_cch))     // Move text after gap to end so that
        {                               // we don't end up with two gaps
            cbMove = CbOfCch(_cch) - _ibGap;
            pch += CchOfCb(_cbBlock - cbMove);
            MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
        }
        _cbBlock = cbNew;
    }

    return TRUE;
}

HRESULT
CMarkup::CreateInitialMarkup( CRootElement * pElementRoot )
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeRoot;
    CTreePos *  ptpNew;

    // Assert that there is nothing in the splay tree currently
    Assert( FirstTreePos() == NULL );

    // If someone passes a null root in here, chances are that 
    // we are out of memory.
    if (!pElementRoot)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pNodeRoot = new CTreeNode( NULL, pElementRoot );
    if ( !pNodeRoot )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // The initial ref on the node will transfer to the tree

    ptpNew = pNodeRoot->InitBeginPos( TRUE );
    Verify( ! Append(ptpNew) );

    ptpNew = pNodeRoot->InitEndPos( TRUE );
    Verify( ! Append(ptpNew) );

    pNodeRoot->PrivateEnterTree();

    pElementRoot->SetMarkupPtr( this );
    pElementRoot->__pNodeFirstBranch = pNodeRoot;
    pElementRoot->PrivateEnterTree();

    // Insert the chars for the node poses
    if( CTxtPtr( this, 0 ).InsertRepeatingChar( 2, WCH_NODE ) != 2 )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        CNotification nf;
        nf.ElementEntertree( pElementRoot );
        pElementRoot->Notify( &nf );
    }

    UpdateMarkupTreeVersion();

    WHEN_DBG( _cchTotalDbg = 2 );
    WHEN_DBG( _cElementsTotalDbg = 1 );

Cleanup:
    RRETURN( hr );
}


#if DBG == 1
//+----------------------------------------------------------------------------
//
//  Member:     ValidateChange
//
//  Synopsis:   The markup maintains a redundant count of characters and
//              elements so that notifications can be validated.
//
//-----------------------------------------------------------------------------

void
CMarkup::ValidateChange(CNotification * pnf)
{
    switch ( pnf->Type() )
    {
    case NTYPE_CHARS_ADDED :
    {
        _cchTotalDbg += pnf->Cch(LONG_MAX);

        break;
    }
    case NTYPE_CHARS_DELETED :
    {
        _cchTotalDbg -= pnf->Cch(LONG_MAX);

        break;
    }

    case NTYPE_CHARS_RESIZE :
    case NTYPE_CHARS_INVALIDATE :
        break;

    case NTYPE_ELEMENTS_ADDED :
    {
        _cElementsTotalDbg += pnf->CElements();

        break;
    }

    case NTYPE_ELEMENTS_DELETED :
    {
        _cElementsTotalDbg -= pnf->CElements();

        break;
    }

    case NTYPE_ELEMENT_ENTERVIEW_1:
    case NTYPE_ELEMENT_EXITVIEW_1:
        break;

    case NTYPE_MARKUP_RENDER_STYLE:
        return;

    default :
        AssertSz( 0, "Unknown change kind" );
        break;
    }

    //
    // Make sure the debug count and the real doc are the same
    //

    Assert( !pnf->IsTextChange()
        ||  pnf->_fNoTextValidate
        || (    _cchTotalDbg == GetTextLength()
            &&  _cchTotalDbg == Cch() ) );
    Assert( !pnf->IsTreeChange()
        ||  pnf->_fNoElementsValidate
        ||  _cElementsTotalDbg == NumElems() );
}

//+----------------------------------------------------------------------------
//
//  Member:     AreChangesValid
//
//  Synopsis:   Return if the counds match the real situation
//
//-----------------------------------------------------------------------------

BOOL
CMarkup::AreChangesValid()
{
    return  _cchTotalDbg == GetTextLength()
        &&  _cchTotalDbg == Cch()
        &&  _cElementsTotalDbg == NumElems();
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     FindMyListContainer
//
//  Synopsis:   Searches the given branch (potentially starting above the base
//              of the branch) for the first list element above the start of
//              the search.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::FindMyListContainer ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode = pNodeStartHere;

    //
    // If we get to the CTxtSite immediately, stop searching!
    //

    if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
        return NULL;

    for ( ; ; )
    {
        CElement * pElementScope;

        pNode = pNode->Parent();

        if (!pNode)
            return NULL;

        pElementScope = pNode->Element();

        if (pElementScope->IsFlagAndBlock(TAGDESC_LIST))
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;

        if (IsGenericBlockListItem(pNode))
            return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForCriteria
//
//  Synopsis:   Searches the given branch for an element which meets
//              certain criteria starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForCriteria (
    CTreeNode * pNodeStartHere,
    BOOL (* pfnSearchCriteria ) ( CTreeNode *, void * ),
    void *pvData)
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pfnSearchCriteria( pNode, pvData ))
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForCriteriaInStory
//
//  Synopsis:   Searches the given branch for an element which meets
//              certain criteria starting from a given element.
//
//     Notes:   Does not stop searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForCriteriaInStory (
    CTreeNode * pNodeStartHere,
    BOOL (* pfnSearchCriteria) ( CTreeNode * ) )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pfnSearchCriteria( pNode ))
            return pNode;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForPreLikeNode
//
//  Synopsis:   Searches the given branch for a pre-like node
//
//-----------------------------------------------------------------------------
CTreeNode *
CMarkup::SearchBranchForPreLikeNode ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for( pNode = pNodeStartHere; pNode; pNode = pNode->Parent() )
    {
        ELEMENT_TAG eTag = pNode->Tag();
        if( eTag == ETAG_PRE || eTag == ETAG_XMP || eTag == ETAG_PLAINTEXT || eTag == ETAG_LISTING)
        {
            return pNode;
        }

        if (pNode->GetFancyFormat()->IsWhitespaceSet())
        {
            if (pNode->GetParaFormat()->_fPreInner)
                return pNode;

            return NULL;
        }

    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForAnchor
//
//  Synopsis:   Searches the given branch for an anchor element
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForAnchor ( CTreeNode * pNodeStartHere )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode = pNodeStartHere;

    for ( ; ; )
    {
        if (!pNode || pNode->HasFlowLayout( GUL_USEFIRSTLAYOUT))
            return NULL;

        if (pNode->Tag() == ETAG_A)
            break;

        pNode = pNode->Parent();
    }

    return pNode;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForAnchorLink
//
//  Synopsis:   Searches the given branch for an anchor element which
//              has a HREF starting from a given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForAnchorLink ( CTreeNode * pNodeStartHere )
{
    CTreeNode * pNodeAnchor = pNodeStartHere;

    for ( ; ; )
    {
        CAnchorElement * pAnchor;

        if (!pNodeAnchor)
            break;

        pNodeAnchor = SearchBranchForAnchor( pNodeAnchor );

        if (!pNodeAnchor)
            break;

        pAnchor = DYNCAST( CAnchorElement, pNodeAnchor->Element() );

        if (pAnchor->GetAAhref())
            break;

        pNodeAnchor = pNodeAnchor->Parent();
    }

    return pNodeAnchor;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForTag
//
//  Synopsis:   Searches the given branch for an element with a given tag.
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the tag.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForTag ( CTreeNode * pNodeStartHere, ELEMENT_TAG etag )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ;
          pNode && etag != pNode->Tag() ;
          pNode = pNode->Parent() )
    {
        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }

    return pNode;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForTagInStory
//
//  Synopsis:   Searches the given branch for an element with a given tag.
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the tag.
//
//     Notes:   Stops searching after the CTxtEdit goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForTagInStory (
    CTreeNode * pNodeStartHere, ELEMENT_TAG etag )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ;
          pNode ;
          pNode = pNode->Parent() )
    {
        if ( etag == pNode->Tag() )
            return pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForScope
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForScope (
    CTreeNode * pNodeStartHere,
    CElement *  pElementFindMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindMyScope == pElementScope)
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }

    Assert( ! pNode );

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForScopeInStory
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given element.
//
//   Returns:   Returns the element along the branch which has the same scope
//              as the given element.
//
//-----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

CTreeNode *
CMarkup::SearchBranchForScopeInStory (
    CTreeNode * pNodeStartHere,
    CElement *  pElementFindMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindMyScope == pElementScope)
            return pNode;
    }

    return NULL;
}

#pragma optimize("", on)

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNode
//
//  Synopsis:   Searches the given branch for a given element (non scope),
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNode (
    CTreeNode * pNodeStartHere, CTreeNode * pNodeFindMe )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        if (pNodeFindMe == pNode)
            return pNode;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNodeInStory
//
//  Synopsis:   Searches the given branch for a given element (non-scope),
//              starting from a given element.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNodeInStory (
    CTreeNode * pNodeStartHere, CTreeNode * pNodeFindMe )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        if (pNodeFindMe == pNode)
            return pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForChildOfScope
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given node.
//
//   Returns:   Returns the child node of the node found.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForChildOfScope (
    CTreeNode * pNodeStartHere, CElement * pElementFindChildOfMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode, * pNodeChild = NULL;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (pElementFindChildOfMyScope == pElementScope)
            return pNodeChild;

        if (pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT))
            return NULL;

        pNodeChild = pNode;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForChildOfScopeInStory
//
//  Synopsis:   Searches the given branch for the scope of a given element,
//              starting from a given node.
//
//   Returns:   Returns the child node of the node found.
//
//     Notes:   Stops searching after the CTxtEdit goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForChildOfScopeInStory (
    CTreeNode * pNodeStartHere, CElement * pElementFindChildOfMyScope )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode, * pNodeChild = NULL;

    for ( pNode = pNodeStartHere ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElementScope = pNode->Element();

        if (pElementFindChildOfMyScope == pElementScope)
            return pNodeChild;

        pNodeChild = pNode;
    }

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForBlockElement
//
//  Synopsis:   Searches the given branch for the first block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForBlockElement (
    CTreeNode * pNodeStartHere,
    CFlowLayout * pFLContext )
{
    CTreeNode * pNode;

    Assert( pNodeStartHere );

    if (!pFLContext && GetElementClient())
        pFLContext = GetElementClient()->GetFlowLayout(GUL_USEFIRSTLAYOUT);

    if (!pFLContext)
        return NULL;

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (pFLContext->IsElementBlockInContext( pElementScope ))
            return pNode;

        if (pElementScope == pFLContext->ElementContent())
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForNonBlockElement
//
//  Synopsis:   Searches the given branch for the first non block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
CMarkup::SearchBranchForNonBlockElement (
    CTreeNode * pNodeStartHere,
    CFlowLayout * pFLContext )
{
    Assert( pNodeStartHere );

    CTreeNode * pNode;

    if (!pFLContext)
        pFLContext = GetElementClient()->GetFlowLayout(GUL_USEFIRSTLAYOUT);

    for ( pNode = pNodeStartHere ; ; pNode = pNode->Parent() )
    {
        if (!pNode)
            return NULL;

        CElement * pElementScope = pNode->Element();

        if (!pFLContext->IsElementBlockInContext( pElementScope ))
        {
            return pNode;
        }

        if (pElementScope == pFLContext->ElementOwner())
            return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//    Member:   CreateInclusion
//
//  Synopsis:   Splits the branch up to but not including pNodeStop.
//              The inclusion will occur at ptpgLocation.  ptpgInclusion will
//              be set to the middle of the inclusion.
//
// Arguments:
//      pNodeStop       -   the node to split up to but not including
//      ptpgLocation    -   create the split here. IN ONLY
//      ptpgInclusion   -   return the CTreePos just before the split. OUT ONLY
//      pNodeAboveLocation - the node directly above ptpgLocation, if NULL,
//                           it will be computed
//      fFullReparent   -   if TRUE, everything will be reparented correctly
//                          if FALSE, only the new nodes will
//      ppNodeLastAdded -   return the top of the new element chain
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::CreateInclusion(
    CTreeNode *     pNodeStop,
    CTreePosGap *   ptpgLocation,
    CTreePosGap *   ptpgInclusion,
    CTreeNode *     pNodeAboveLocation /*= NULL*/,
    BOOL            fFullReparent /*= TRUE*/,
    CTreeNode **    ppNodeLastAdded /*= NULL*/)
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgInsert ( TPG_LEFT );
    CTreeNode * pNodeCurr, * pNodeNew = NULL;
    CTreeNode * pNodeLastNew = NULL;

    //
    // The passed in gap must be specified and positioned at a valid point
    // in this tree.
    //

    Assert( ptpgLocation );
    Assert( ptpgLocation->IsValid() );
    Assert( ptpgLocation->GetAttachedMarkup() == this );

    //
    // The node up to which we should split must be specified and in this tree.
    // Note that this node may not actually curently influence the gap in the
    // tree specified by ptpgLocation.  This is so because the tree may be in
    // an unstable state.
    //

    Assert( pNodeStop );
    Assert( pNodeStop->GetMarkup() == this );

    //
    // The pNodeAboveLocation, if specified, should be assumed to be the first node
    // which influences the gap specified by ptpgLocation.  Because the tree may be
    // in an unstable state, this node may not be visible to ptpgLocation.
    //
    // In any case, here we compute the node where we start the creation of the
    // inclusion.
    //

    pNodeCurr = pNodeAboveLocation ? pNodeAboveLocation : ptpgLocation->Branch();

    Assert( pNodeCurr );

    //
    // Now that we have a place to start with in the tree, make sure the stop node
    // is somewhere along the parent chain from the start node (now pNodeCurr).
    //

    Assert( pNodeCurr->SearchBranchToRootForScope( pNodeStop->Element() ) == pNodeStop );

    //
    // Set up the spot to insert
    //

    Verify( ! tpgInsert.MoveTo( ptpgLocation ) );

    while (pNodeCurr != pNodeStop)
    {
        CTreePos * ptpNew;

        //
        // Create the new node (proxy to the current element)
        //

        pNodeNew = new CTreeNode( pNodeCurr->Parent(), pNodeCurr->Element() );

        if (!pNodeNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        //
        // Insert the end pos of the new node to be just before the end pos of
        // the node we cloned it from.  It inherits edge scopeness from the end
        // of the current node.
        //

        ptpNew = pNodeNew->InitEndPos( pNodeCurr->GetEndPos()->IsEdgeScope() );

        Verify( ! Insert( ptpNew, pNodeCurr->GetEndPos(), TRUE ) );

        //
        // Based on the attach preference of the tree gap which originally
        // specified where to create the inclusion, push that gap around.
        //

        if (ptpgLocation->AttachedTreePos() == pNodeCurr->GetEndPos())
        {
            Assert( ptpgLocation->AttachDirection() == TPG_RIGHT );

            ptpgLocation->MoveTo( ptpNew, TPG_LEFT );
        }

        //
        // Insert the begin pos to the right of the point of the inclusion.  It is
        // automatically not an edge.
        //

        ptpNew = pNodeNew->InitBeginPos( FALSE );

        Verify( ! Insert( ptpNew, tpgInsert.AttachedTreePos(), FALSE ) );

        //
        // Mark this node as being in the markup
        //
        pNodeNew->PrivateEnterTree();

        //
        // Move the end pos of the current node to be to the left of the
        // location of the inclusion.
        //

        Verify( ! Move( pNodeCurr->GetEndPos(), tpgInsert.AttachedTreePos(), FALSE ) );

        //
        // The end pos of the current node is no longer an edge
        //

        // CONSIDER (JHarding): We may want to amortize these adjustments, if there's some way to do that.
        pNodeCurr->GetEndPos()->MakeNonEdge();

        //
        // Move over the end of end of the current node to get back into the
        // location of the inclusion.
        //

        Verify( ! tpgInsert.Move( TPG_RIGHT ) );

        Assert( tpgInsert.AdjacentTreePos( TPG_LEFT ) == pNodeCurr->GetEndPos() );

        //
        // Reparent the direct children in the range affected
        //

        if (fFullReparent)
        {
            hr = THR( ReparentDirectChildren( pNodeNew ) );

            if (hr)
                goto Cleanup;
        }
        else if (pNodeLastNew)
        {
            pNodeLastNew->SetParent( pNodeNew );
        }

        //
        // Finally, set up for the next time around
        //

        pNodeLastNew = pNodeNew;
        pNodeCurr = pNodeCurr->Parent();
    }


    if (ppNodeLastAdded)
        *ppNodeLastAdded = pNodeLastNew;

    if (ptpgInclusion)
        Verify( ! ptpgInclusion->MoveTo( & tpgInsert ) );

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//    Member:   CloseInclusion
//
//  Synopsis:   Close a possible empty inclusion.  It is possible that there
//              will be no inclusion at ptpgMiddle, in which case
//              CloseInclusion does nothing.  Otherwise, it removes as many
//              redundant nodes as possible.
//
// Arguments:
//      ptpgMiddle -   The middle of the inclusion to close.  Will be
//                     set to the gap where the inclusion was on exit
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::CloseInclusion (
    CTreePosGap * ptpgMiddle )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgMiddle ( TPG_LEFT );

    //
    // Note: tpgMiddle is bound to the pos which is to the left of the
    // gap because it will move to the left as we delete nodes.  This
    // way, it stays out of the way (to the left) of the removals.
    //

    //
    // The middle gap argument must be specified and positioned in this
    // tree.
    //

    Assert( ptpgMiddle );
    Assert( ptpgMiddle->IsPositioned() );
    Assert( ptpgMiddle->GetAttachedMarkup() == this );

    //
    // Copy the incomming argument to our local gap, nd unposition the argument.
    // We'll reposition it later, after we have closed the inclusion.
    //

    Verify( ! tpgMiddle.MoveTo( ptpgMiddle ) );

    ptpgMiddle->UnPosition();

    for ( ; ; )
    {
        CTreePos * ptpRightMiddle, * ptpLeftMiddle;
        CTreeNode * pNodeBefore, * pNodeAfter;

        //
        // Get the pos to the left of the gap which travels accross
        // the splays.
        //

        ptpLeftMiddle = tpgMiddle.AttachedTreePos();

        //
        // We know we're not in an inclusion anymore when the pos to the
        // left is not a ending edge.
        //
        // Note, we don't have to check to tree pointers or text because
        // they must never be seen in inclusions.
        //

        if (!ptpLeftMiddle->IsEndNode() || ptpLeftMiddle->IsEdgeScope())
            break;

        //
        // Get the tree pos to the right of the one which is to the
        // left of the gap.  This will, then, be to the right of the gap.
        //

        ptpRightMiddle = ptpLeftMiddle->NextTreePos();

        //
        // Check the right edge for non matching ptp's.  We can
        // have a non edge end node pos on the left but not a non edge begin
        // node ont he right during certain circumstances in splice.
        //

        if (!ptpRightMiddle->IsBeginNode() || ptpRightMiddle->IsEdgeScope())
            break;

        //
        // Move the gap to the left (<--) by one (not right).
        //

        Verify( ! tpgMiddle.MoveLeft() );

        //
        // If we've gotten this far, then there better be
        // an inclusion here.
        //
        // Thus, we must have a non edge beginning to our right.
        //

        Assert(
              ptpRightMiddle->IsBeginNode() &&
            ! ptpRightMiddle->IsEdgeScope() );

        //
        // Get the nodes associated with either side of the gap in question.
        //

        pNodeBefore = ptpLeftMiddle->Branch();
        pNodeAfter  = ptpRightMiddle->Branch();

        //
        // To be in an inclusion, the two adjacent nodes must refer to
        // the same element.
        //

        Assert( pNodeBefore->Element() == pNodeAfter->Element() );

        //
        // Make sure the inclusion does not refer to the root!
        //

        Assert( !pNodeBefore->Element()->IsRoot() );


        //
        // Move the end pos of the node left of the gap to be just before
        // the end pos of the node right of the gap.
        //
        // This way, the node left of the gap will subsume "ownership"
        // of all the stuff which is under the node right of the gap.
        //

        Verify( ! Move( pNodeBefore->GetEndPos(), pNodeAfter->GetEndPos(), TRUE ) );

        //
        // Now that the node right of the gap is going away, the end pos
        // of the node left of the gap needs to reflect the same edge status
        // of the end pos going away.  Because there may be yet another
        // proxy for this element to the right, we can't assume that it
        // is an edge.
        //

        pNodeBefore->GetEndPos()->SetScopeFlags(
            pNodeAfter->GetEndPos()->IsEdgeScope() );

        //
        // Here we remove the node right of the gap (and its pos's)
        //

        Verify( ! Remove( pNodeAfter->GetBeginPos() ) );

        Verify( ! Remove( pNodeAfter->GetEndPos() ) );

        //
        // Reparent the children that were pointing to the node going away.
        //
        // Now that the node to the right of the gap is gone, we must
        // make sure that all the nodes which pointed to the node which
        // we just removed now point to the node which remains.
        //
        // We start the reparent starting at the current location of the gap
        // and extending until the remaining node goes out of scope.
        //

        hr = THR( ReparentDirectChildren( pNodeBefore, & tpgMiddle ) );

        if (hr)
            goto Cleanup;

        //
        // Now, kill the node we just removed.  No one in this tree better be
        // pointing to it after the reparent operation.
        //

        // pNodeAfter is not usable after this
        pNodeAfter->PrivateExitTree();
        pNodeAfter = NULL;
    }

    //
    // Put the incomming argument back into the tree
    //

    Verify( ! ptpgMiddle->MoveTo( & tpgMiddle ) );

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//    Member:   ReparentDirectChildren
//
//  Synopsis:   This routine assumes that the begin and end node pos's for
//              pNodeParentNew are already in place.  What it does is
//              make sure all direct children (according to the runs)
//              point to pNodeParentNew.  In other words, this routine makes
//              sure the parent info implied by the runs is reflected by
//              the tree itself.
//
//              If ptpgStart and ptpgEnd are passed in, they must be under the
//              direct scope of the parent.  This allows the routine to skip
//              over all the runs of direct children.
//
// Arguments:
//      pNodeParentNew  -   the new parent
//      ptpgStart       -   where to start parenting, IN only
//      ptpgEnd         -   where to stop parenting, IN only
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::ReparentDirectChildren (
    CTreeNode *   pNodeParentNew,
    CTreePosGap * ptpgStart,
    CTreePosGap * ptpgEnd )
{
    CTreePos *  ptpCurr, * ptpEnd;

    //
    // If the start/end is specified, make sure they're sane
    //

    Assert( ! ptpgStart || ptpgStart->GetAttachedMarkup() == this );
    Assert( ! ptpgEnd   || ptpgEnd->GetAttachedMarkup()   == this );

    //
    // If the position where we should start and end the reparent operation
    // are specified, then go there, otherwise start/end at where the new
    // parent starts/ends.
    //

    ptpCurr =
        ptpgStart
            ? ptpgStart->AdjacentTreePos( TPG_RIGHT )
            : pNodeParentNew->GetBeginPos()->NextTreePos();

    ptpEnd =
        ptpgEnd
            ? ptpgEnd->AdjacentTreePos( TPG_RIGHT )
            : pNodeParentNew->GetEndPos();

    //
    // Make sure the start is to the left of the end
    //

    Assert( ptpCurr->InternalCompare( ptpEnd ) <= 0 );

    //
    // Loop and reparent.  Get to just direct children by skipping
    // over direct children.
    //

    while ( ptpCurr != ptpEnd )
    {
        switch ( ptpCurr->Type() )
        {
        case CTreePos::NodeEnd :

            //
            // We will (most) never find an end pos because we'll skip over
            // them when we encounter the begin pos for that node.
            //

            AssertSz( 0, "Found an end pos during reparent children" );

            break;

        case CTreePos::NodeBeg :

            ptpCurr->Branch()->SetParent( pNodeParentNew );

            //
            // Skip over everything under this node
            //
            ptpCurr = ptpCurr->Branch()->GetEndPos();

            break;

        case CTreePos::Pointer :

            if (ptpCurr->HasCollapsedWhitespace())
            {
                ptpCurr->SetWhitespaceParent( pNodeParentNew );
            }

            break;

        default:

            Assert( ! ptpCurr->IsUninit() );

            break;
        }

        ptpCurr = ptpCurr->NextTreePos();
    }

    RRETURN( S_OK );
}

//+----------------------------------------------------------------------------
//
//    Member:   RemoveElement
//
//  Synopsis:   Removes the influence of an element
//
//-----------------------------------------------------------------------------

static void
RemoveNodeChars ( CMarkup * pMarkup, long cp, long cch, CTreeNode * pNode )
{
    CNotification nf;

    Assert( cp >= 0 && cp < pMarkup->GetTextLength() );
    Assert( cch > 0 && cp + cch <= pMarkup->GetTextLength() );

    nf.CharsDeleted( cp, cch, pNode );

#if DBG == 1
    {
        CTxtPtr tp2 ( pMarkup, cp );

        for ( int i = 0 ; i < cch; i++, tp2.AdvanceCp( 1 ) )
            Assert( tp2.GetChar() == WCH_NODE );
    }
#endif

    CTxtPtr( pMarkup, cp ).DeleteRange( cch );

    pMarkup->Notify( & nf );
}

HRESULT
CMarkup::RemoveElementInternal (
    CElement * pElementRemove,
    DWORD      dwFlags )
{
    HRESULT            hr = S_OK;
    BOOL               fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap        tpgElementBegin ( TPG_LEFT );
    CTreePosGap        tpgEnd ( TPG_RIGHT );
    CTreeNode *        pNodeCurr, * pNodeNext;
    long               siStart;
    BOOL               fDelayRelease = FALSE, fExitTreeSc = FALSE;
    CMarkup::CLock     MarkupLock( this );
    CRemoveElementUndo Undo( this, pElementRemove, dwFlags );
    long               cpBegin = 0, cpEnd = 0;

    // TODO (EricVas): Specialcase the removal of an empty element so that
    //                   multiple notifications can be amortized

    //
    // The element to be removed must be specified and in this tree.  Also,
    // We better not be trying to remove the tree element itself!
    //

    Assert( pElementRemove );
    Assert( pElementRemove->GetMarkup() );
    Assert( pElementRemove->GetMarkup() == this );
    Assert( !pElementRemove->IsRoot() );

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        CTreePos * ptpBegin;
        CTreePos * ptpEnd;

        pElementRemove->GetTreeExtent( &ptpBegin, &ptpEnd );
        cpBegin = ptpBegin->GetCp();
        cpEnd   = ptpEnd->GetCp();

        fDelayRelease = TRUE;
        WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
    }


    //
    // Notify element it is about to exit the tree
    //

    {
        CNotification nf;

        Assert( !pElementRemove->_fExittreePending );
        pElementRemove->_fExittreePending = TRUE;

        nf.ElementExittree1( pElementRemove );

        Assert( nf.IsSecondChanceAvailable() );

        // If we are in the undo queue, we will have _ulRefs>1 by now.
        if( pElementRemove->GetObjectRefs() == 1 )
        {
            nf.SetData( EXITTREE_PASSIVATEPENDING );
            Assert( !pElementRemove->_fPassivatePending );
            WHEN_DBG( pElementRemove->_fPassivatePending = TRUE );
        }

        pElementRemove->Notify( & nf );

        if (nf.IsSecondChanceRequested())
        {
            fDelayRelease = TRUE;
            fExitTreeSc = TRUE;
            WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
        }
        else if (nf.DataAsDWORD() & EXITTREE_DELAYRELEASENEEDED)
        {
            fDelayRelease = TRUE;
            WHEN_DBG( pElementRemove->_fDelayRelease = TRUE );
        }

        pElementRemove->_fExittreePending = FALSE;
    }

    hr = THR( EmbedPointers() );

    if (hr)
        goto Cleanup;

    //
    // Remove tree pointers with cling around the edges of the element being removed
    //
    {
        CTreePosGap tpgCling;
        CTreePos * ptpBegin, * ptpEnd;

        pElementRemove->GetTreeExtent( &ptpBegin, &ptpEnd );

        Assert( ptpBegin && ptpEnd );

        // Around the beginning
        Verify( ! tpgCling.MoveTo( ptpBegin, TPG_LEFT ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_RIGHT, fDOMOperation );

        Verify( ! tpgCling.MoveTo( ptpBegin, TPG_RIGHT ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_LEFT, fDOMOperation );

        // Around the end
        Verify( ! tpgCling.MoveTo( ptpEnd, TPG_LEFT ) );
        Verify( ! tpgCling.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_RIGHT, fDOMOperation );

        Verify( ! tpgCling.MoveTo( ptpEnd, TPG_RIGHT ) );
        Verify( ! tpgCling.MoveRight( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );
        tpgCling.PartitionPointers(this, fDOMOperation);
        tpgCling.CleanCling( this, TPG_LEFT, fDOMOperation );
    }

    //
    // Record where the element begins, making sure the gap used to record this
    // points to the tree pos to the left so that stuff removed from the tree
    // does not include that.
    //

    tpgElementBegin.MoveTo( pElementRemove->GetFirstBranch()->GetBeginPos(), TPG_LEFT );

    //
    // Remember the source index of the element that we are removing
    //

    siStart = pElementRemove->GetFirstBranch()->GetBeginPos()->SourceIndex();

    //
    // Run through the context chain removing contexts in their entirety
    //

    for ( pNodeCurr = pElementRemove->GetFirstBranch() ;
          pNodeCurr ;
          pNodeCurr = pNodeNext )
    {
        CTreeNode * pNodeParent;
        CTreePosGap tpgNodeBegin ( TPG_LEFT );
        BOOL        fBeginEdge;

        //
        // Before we nuke this node, record its parent and next context
        //

        pNodeParent = pNodeCurr->Parent();
        pNodeNext = pNodeCurr->NextBranch();

        //
        // Record the gaps where the node is right now
        //

        tpgNodeBegin.MoveTo( pNodeCurr->GetBeginPos(), TPG_RIGHT );
        tpgEnd.MoveTo( pNodeCurr->GetEndPos(), TPG_LEFT );

        //
        // Make all the immediate children which were beneath this node point
        // to its parent.
        //

        hr = THR(
            ReparentDirectChildren(
                pNodeParent, & tpgNodeBegin, & tpgEnd ) );

        if (hr)
            goto Cleanup;

        //
        // Swing the pointers to the outside
        //

        tpgNodeBegin.MoveTo( pNodeCurr->GetBeginPos(), TPG_LEFT );
        tpgEnd.MoveTo( pNodeCurr->GetEndPos(), TPG_RIGHT );

        //
        // Remove the begin pos
        //

        fBeginEdge = pNodeCurr->GetBeginPos()->IsEdgeScope();

        hr = THR( Remove( pNodeCurr->GetBeginPos() ) );

        if (hr)
            goto Cleanup;

        //
        // Delete the character and send the notification
        //

        if( fBeginEdge )
        {
            RemoveNodeChars(this, tpgNodeBegin.GetCp(), 1, pNodeParent );
        }

//...        hr = THR( MergeRightText( tpgNodeBegin.AttachedTreePos() );


        //
        // Remove the end pos
        //

        {
            hr = THR( Remove( pNodeCurr->GetEndPos() ) );

            if (hr)
                goto Cleanup;

            //
            // If this is the last node in the content chain, there must be
            // an inclusion here.  Remove it.
            //

            if (!pNodeNext)
            {
                hr = THR( CloseInclusion( & tpgEnd ) );
                if (hr)
                    goto Cleanup;

                //
                // Delete the chracters and send the  notification
                //
                RemoveNodeChars(this, tpgEnd.GetCp(), 1, tpgEnd.Branch() );
            }

        }

        //
        // Kill the node
        //

        pNodeCurr->PrivateExitTree();
        pNodeCurr = NULL;
    }

    //
    // Set the Undo data
    //

    Undo.SetData( tpgElementBegin.GetCp(), tpgEnd.GetCp() );


    //
    // Release element from the tree
    //

    {
        WHEN_DBG(BOOL fPassivatePending = pElementRemove->_fPassivatePending);

        if (fDelayRelease)
        {
            pElementRemove->AddRef();
            WHEN_DBG( pElementRemove->_fPassivatePending = FALSE );
        }

        pElementRemove->__pNodeFirstBranch = NULL;

        pElementRemove->DelMarkupPtr();
        pElementRemove->PrivateExitTree( this );

#if DBG==1
        if (fDelayRelease)
            pElementRemove->_fPassivatePending = fPassivatePending;
#endif
    }

    //
    // Clear caches, etc
    //

    UpdateMarkupTreeVersion();

    if (tpgElementBegin != tpgEnd)
    {
        CTreePos * ptpLeft = tpgElementBegin.AdjacentTreePos( TPG_RIGHT );
        CTreePos * ptpRight = tpgEnd.AdjacentTreePos( TPG_LEFT );

        hr = THR( RangeAffected( ptpLeft, ptpRight ) );
    }

    tpgEnd.UnPosition();
    tpgElementBegin.UnPosition();

    //
    //  Send the ElementsDeleted notification
    //

    {
        CNotification nf;

        nf.ElementsDeleted( siStart, 1 );

        Notify( nf );
    }

    Assert( IsNodeValid() );

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertOrRemoveElement( FALSE, cpBegin, cpEnd, pElementRemove ) );
    }

    //
    // Send the ExitTreeSc notification and do the delay release
    //

    if( fExitTreeSc )
    {
        Assert( fDelayRelease );
        CNotification nf;

        nf.ElementExittree2( pElementRemove );
        pElementRemove->Notify( &nf );
    }

    if( fDelayRelease )
    {
        // Release the element
        Assert( pElementRemove->_fDelayRelease );
        WHEN_DBG( pElementRemove->_fDelayRelease = FALSE );
        Assert( !pElementRemove->_fPassivatePending || pElementRemove->GetObjectRefs() == 1 );
        pElementRemove->Release();
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//    Member:   InsertElement
//
//  Synopsis:   Inserts an element into the tree.  The element must not already
//              be in the tree when this is called.
//
// Arguments:
//      pElementInsertThis  -   The element to insert
//      ptpgBegin           -   Element will begin here.  Must be a valid gap.
//                              IN only
//      ptpgEnd             -   Element will end here. Must be a valid gap.
//                              IN only
//-----------------------------------------------------------------------------

static void
InsertNodeChars ( CMarkup * pMarkup, long cp, long cch, CTreeNode * pNode )
{
    CNotification nf;

    Assert( cp >= 0 && cp < pMarkup->GetTextLength() );

    nf.CharsAdded( cp, cch, pNode );

    CTxtPtr( pMarkup, cp ).InsertRepeatingChar( cch, WCH_NODE );

    pMarkup->Notify( & nf );
}

HRESULT
CMarkup::InsertElementInternal (
    CElement *    pElementInsertThis,
    CTreePosGap * ptpgBegin,
    CTreePosGap * ptpgEnd,
    DWORD         dwFlags )
{
    HRESULT      hr = S_OK;
    CDoc *       pDoc = Doc();
    BOOL         fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap  tpgCurr( TPG_LEFT );
    CTreeNode *  pNodeNew = NULL;
    CTreeNode *  pNodeLast = NULL;
    CTreeNode *  pNodeParent = NULL;
    CTreeNode *  pNodeAboveEnd;
    BOOL         fLast = FALSE;
    CTreePosGap  tpgBegin( TPG_LEFT ), tpgEnd( TPG_RIGHT );
    CInsertElementUndo Undo( this, dwFlags );
    long         cpBegin = 0, cpEnd = 0;

    Assert( ! HasUnembeddedPointers() );

    EnsureTotalOrder( ptpgBegin, ptpgEnd );

    Undo.SetData( pElementInsertThis );

    // TODO (EricVas) : Make insertion of unscoped element amortize notifications

    //
    // Element to insert must be specified and not in any tree
    //

    Assert( pElementInsertThis && !pElementInsertThis->GetFirstBranch() );

    //
    // The gaps specifying where to put the element must be specified and
    // in valid locations in the splay tree.  They must also both be in
    // the same tree (this tree).
    //

    if(!ptpgBegin || !ptpgEnd)
        return E_FAIL;

    Assert( ptpgBegin && ptpgBegin->IsValid() );
    Assert( ptpgEnd && ptpgEnd->IsValid() );
    Assert( ptpgBegin->AttachedTreePos()->IsInMarkup( this ) );
    Assert( ptpgEnd->AttachedTreePos()->IsInMarkup( this ) );

    //
    // Push any tree pointers at the insertion points in the correct directions
    //

    ptpgBegin->PartitionPointers(this, fDOMOperation);
    ptpgEnd->PartitionPointers(this, fDOMOperation);

    //
    // Make sure to split any text IDs
    //

    if (pDoc->_lLastTextID)
    {
        SplitTextID(
            ptpgBegin->AdjacentTreePos( TPG_LEFT ),
            ptpgBegin->AdjacentTreePos( TPG_RIGHT) );

        if (*ptpgBegin != *ptpgEnd)
        {
            SplitTextID(
                ptpgEnd->AdjacentTreePos( TPG_LEFT ),
                ptpgEnd->AdjacentTreePos( TPG_RIGHT) );
        }
    }

    //
    // Copy the endpoints to local gaps.  This way we don't muck with the
    // arguments.
    //

    Verify( ! tpgBegin.MoveTo( ptpgBegin ) );
    Verify( ! tpgEnd.MoveTo( ptpgEnd ) );

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        cpBegin = tpgBegin.AdjacentTreePos( TPG_RIGHT )->GetCp();
        cpEnd   = tpgEnd.AdjacentTreePos( TPG_RIGHT )->GetCp();
    }

    //
    // The var tpgCurr will walk through the insertionm left to right
    //

    tpgCurr.MoveTo( ptpgBegin );

    pNodeAboveEnd = ptpgEnd->Branch();

    //
    // Get the parent for the new node
    //

    pNodeParent = tpgCurr.Branch();

    while (!fLast)
    {
        //
        // Check to see if this is the last node we will have to insert
        //

        if (SearchBranchForNodeInStory( pNodeAboveEnd, pNodeParent ))
            fLast = TRUE;

        //
        // Create the new node and hook it into the context list
        //

        pNodeNew = new CTreeNode( pNodeParent, pElementInsertThis );

        if ( !pNodeNew )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }


        if (! pNodeLast)
        {
            pElementInsertThis->__pNodeFirstBranch = pNodeNew;

            pElementInsertThis->SetMarkupPtr( this );
            pElementInsertThis->PrivateEnterTree();
        }

        //
        // Insert the start node
        //

        {
            CTreePos * ptpNew;

            Assert( pNodeNew->GetBeginPos()->IsUninit() );

            ptpNew = pNodeNew->InitBeginPos( !pNodeLast );

            Verify( ! Insert( ptpNew, & tpgCurr ) );

            // The element is now in the tree so add a ref for the
            // tree
            pNodeNew->PrivateEnterTree();

            // Only the first begin node gets a node char
            if( !pNodeLast )
            {

                // Since the begin isn't part of an inclusion, we don't have to calculate
                // who to notify.
                InsertNodeChars( this, ptpNew->GetCp(), 1, pNodeParent );
            }
        }

        //
        // Insert the end node
        //
        {
            CTreePos *  ptpNew;
            long        cpInsert;
            CTreeNode * pNodeNotify = NULL;

            //
            // Create or set the insertion point
            //

            if (fLast)
            {
                //
                // Split the branch to create a spot for our end node pos
                //
                pNodeNotify = pNodeAboveEnd;

                cpInsert = tpgEnd.GetCp();

                hr = THR( CreateInclusion(  pNodeParent,
                                            & tpgEnd,
                                            & tpgCurr,
                                            pNodeAboveEnd ) );

                if (hr)
                    goto Cleanup;
            }
            else
            {
                CTreePosGap tpgNotify( TPG_RIGHT );

                Verify( !tpgCurr.MoveTo( pNodeParent->GetEndPos(), TPG_LEFT ) );

                cpInsert = tpgCurr.GetCp();

            }


            Assert( pNodeNew->GetEndPos()->IsUninit() );

            ptpNew = pNodeNew->InitEndPos( fLast );

            Verify( ! Insert( ptpNew, & tpgCurr ) );

            Verify( ! tpgCurr.MoveRight() );
            Assert( tpgCurr.AdjacentTreePos( TPG_LEFT ) == ptpNew );

            if( fLast )
                InsertNodeChars( this, cpInsert, 1, pNodeAboveEnd );
        }

        //
        // Reparent direct children to the new node
        //

        hr = THR( ReparentDirectChildren( pNodeNew ) );

        if (hr)
            goto Cleanup;

        if (!fLast)
        {
            // if we are here, it implies that we are
            // inserting the end after the end of pNodeParent
            // This _can't_ happen if pNodeParent is a ped.

            Assert( !pNodeParent->IsRoot() );

            //
            // Set up for the next new node
            //

            pNodeLast = pNodeNew;

            //
            // This sets our beginning insertion point
            // for the next node.  What we are doing here
            // is essentially threading the new element
            // through any inclusions.
            //

            Verify( ! tpgCurr.MoveRight() );

            Assert( tpgCurr.AttachedTreePos()->IsEndNode() &&
                    tpgCurr.AttachedTreePos()->Branch() == pNodeParent );

            //
            // pNodeParent is done so its parent is the new pNodeParent
            //

            if( tpgCurr.AttachedTreePos()->IsEdgeScope() )
            {
                pNodeParent = pNodeParent->Parent();
            }
            else
            {
                //
                // Find the next branch of pNodeParent
                //

                CElement *pElementParent = pNodeParent->Element();
                CTreeNode *pNodeCurr;

                do
                {
                    Verify( ! tpgCurr.MoveRight() );

                    Assert( tpgCurr.AttachedTreePos()->IsNode() );

                    pNodeCurr = tpgCurr.AttachedTreePos()->Branch();
                }
                while( pNodeCurr->Element() != pElementParent );

                Assert( tpgCurr.AttachedTreePos()->IsBeginNode() );

                pNodeParent = pNodeCurr;
            }

        }
    }

    //
    // Tell the element that it is now in the tree
    //

    {
        CNotification nf;

        nf.ElementEntertree( pElementInsertThis );
        pElementInsertThis->Notify( & nf );
    }

    if (tpgBegin != tpgEnd)
    {
        CTreePos * ptpLeft = tpgBegin.AdjacentTreePos( TPG_RIGHT );
        CTreePos * ptpRight = tpgEnd.AdjacentTreePos( TPG_LEFT );

        hr = THR( RangeAffected( ptpLeft, ptpRight ) );
    }

    // Send the element added notification
    {
        CTreePos *      ptpBegin;
        CNotification   nf;

        pElementInsertThis->GetTreeExtent( &ptpBegin, NULL );
        Assert( ptpBegin );

        nf.ElementsAdded( ptpBegin->SourceIndex(), 1 );
        Notify( nf );
    }

    //
    // Things should be valid here
    //

    Assert( IsNodeValid() );

    UpdateMarkupTreeVersion();

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertOrRemoveElement( TRUE, cpBegin, cpEnd, pElementInsertThis ) );
    }

Cleanup:

    RRETURN( hr );
}

BOOL
AreDifferentScriptIDs(SCRIPT_ID * psidFirst, SCRIPT_ID sidSecond)
{
    if(     *psidFirst == sidSecond
       ||   sidSecond == sidMerge
       ||   *psidFirst == sidAsciiLatin && sidSecond == sidAsciiSym)
    {
        return FALSE;
    }

    if (    *psidFirst == sidMerge
        ||  *psidFirst == sidAsciiSym && sidSecond == sidAsciiLatin)
    {
        *psidFirst = sidSecond;
        return FALSE;
    }

    return TRUE;
}
//+----------------------------------------------------------------------------
//
//    Member:   InsertText
//
//  Synopsis:   Inserts a chunk of text into the tree before the given TreePos
//              This does not send notifications.
//
//-----------------------------------------------------------------------------

// NOTE: we can probably share code here between this function and
// the slow loop of CHtmRootParseCtx::AddText

HRESULT
CMarkup::InsertTextInternal (
    CTreePos *    ptpAfterInsert,
    const TCHAR * pch,
    long          cch,
    DWORD         dwFlags )
{
    HRESULT         hr = S_OK;
    BOOL            fDOMOperation = dwFlags & MUS_DOMOPERATION;
    CTreePosGap     tpg( TPG_RIGHT );
    CTreePos *      ptpLeft;
    const TCHAR *   pchCurr;
    const TCHAR *   pchStart;
    long            cchLeft;
    SCRIPT_ID       sidLast = sidMerge;
    SCRIPT_ID       sidHint;
    SCRIPT_ID       sidCurr = 0;
    long            lTextIDCurr = 0;
    CNotification   nf;
    long            cpStart = ptpAfterInsert->GetCp();
    CInsertSpliceUndo Undo( Doc() );
    WHEN_DBG(long   ichAfterInsert = 0);

    Undo.Init( this, dwFlags );

    Assert( ! HasUnembeddedPointers() );

    Assert( ptpAfterInsert );
    Assert( cch >= 0 );

    if (cch <= 0)
        goto Cleanup;

    UpdateMarkupContentsVersion();

    Assert( ptpAfterInsert );
    Assert( cch >= 0 );

    // Partition the pointers to ensure gravity

    tpg.MoveTo( ptpAfterInsert, TPG_LEFT );
    tpg.PartitionPointers(this, fDOMOperation);
    ptpAfterInsert = tpg.AdjacentTreePos( TPG_RIGHT );

    Undo.SetData( cpStart, cpStart + cch );

    nf.CharsAdded( cpStart, cch, tpg.Branch() );

    //
    // Collect some information that we'll need later
    //

    // Get info about the previous pos

    ptpLeft = tpg.AdjacentTreePos( TPG_LEFT );
    Assert( ptpLeft );

    pchCurr = pchStart = pch;
    cchLeft = cch;

    // Look around for a TextID to merge with

    {
        CTreePos * ptp;

        for ( ptp = ptpLeft ; ! ptp->IsNode() ;  ptp = ptp->PreviousTreePos() )
        {
            if (ptp->IsText())
            {
                sidLast = ptp->Sid();
                lTextIDCurr = ptp->TextID();
                break;
            }
        }

        if (!lTextIDCurr)
        {
            for ( ptp = ptpAfterInsert ; ! ptp->IsNode() ; ptp = ptp->NextTreePos() )
            {
                if (ptp->IsText())
                {
                    lTextIDCurr = ptp->TextID();
                    break;
                }
            }
        }
    }

    sidHint = sidLast;

    //
    // Break up the text into chunks of compatible SIDs.
    //

    while (cchLeft)
    {
        SCRIPT_ID   sidChunk;
        ULONG       cchChunk;
        TCHAR       chCurr = *pchCurr;

        sidChunk = sidHint;

        // Find the end of this chunk of characters with the same sid

        while (cchLeft)
        {
            chCurr = *pchCurr;

            //
            // If we find an illeagal character, then simply compute a new,
            // correct, buffer and call recursively.
            //

            if (chCurr == 0 || !IsValidWideChar( chCurr ))
            {
                TCHAR * pch2;
                long i;

                AssertSz( 0, "Bad char during insert" );

                pch2 = new TCHAR [ cch ];

                if (!pch2)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                for ( i = 0 ; i < cch ; i++ )
                {
                    TCHAR ch = pch[ i ];

                    if (ch == 0 || !IsValidWideChar( ch ))
                        ch = _T('?');

                    pch2[i] = ch;
                }

                hr = THR( InsertTextInternal( ptpAfterInsert, pch2, cch, dwFlags ) );

                delete pch2;

                goto Cleanup;
            }

            sidCurr = ScriptIDFromCh(chCurr);

            if (AreDifferentScriptIDs( & sidChunk, sidCurr ))
                break;

            pchCurr++;
            cchLeft--;
        }

        cchChunk = pchCurr - pchStart;

        if(cchChunk == 0)
        {
            Assert( sidLast != sidCurr && sidCurr != sidMerge );
            sidHint = sidCurr;
            continue;
        }

        // If this is the first chunk, attempt to merge with a text pos to the left
        if(ptpLeft->IsText() && !AreDifferentScriptIDs(&sidChunk, sidLast))
        {

            Assert(pchStart == pch);
            ptpLeft->ChangeCch(cchChunk);
            ptpLeft->DataThis()->t._sid = sidChunk;
        }
        else
        {
            // If we can merge with the text pos after insertion, do so
            if(cchLeft == 0 &&
               ptpAfterInsert->IsText() &&
                !AreDifferentScriptIDs(&sidChunk, ptpAfterInsert->Sid()))
            {
                WHEN_DBG( ichAfterInsert = cchChunk );
                ptpAfterInsert->ChangeCch(cchChunk);
                ptpAfterInsert->DataThis()->t._sid = sidChunk;
            }
            else
            {
                if( sidChunk == sidMerge )
                {
                    sidChunk = sidDefault;
                }

                // No merging - we actually have to create a new text pos
                ptpLeft = NewTextPos(cchChunk, sidChunk, lTextIDCurr);
                if(!ptpLeft)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(Insert(ptpLeft, &tpg));
                if(hr)
                    goto Cleanup;

                Assert(tpg.AttachedTreePos() == ptpAfterInsert);
                Assert(tpg.AdjacentTreePos( TPG_LEFT ) == ptpLeft);
            }
        }

        pchStart  = pchCurr;
        sidLast = sidChunk;
        sidHint = sidCurr;
    }

    Assert( cch == pchCurr - pch );
    Assert( cch == ptpAfterInsert->GetCp() + ichAfterInsert - cpStart );

    //
    // Now actually stuff the characters into the story
    //

    CTxtPtr( this, cpStart).InsertRange( cch, pch );

    //
    // Send the notification
    //
    Notify( & nf );

    Undo.CreateAndSubmit();

    if( HasLogManager() && GetLogManager()->IsAnyoneListening() )
    {
        IGNORE_HR( GetLogManager()->InsertText( cpStart, cch, pch ) );
    }

    Assert( IsNodeValid() );

Cleanup:

    RRETURN(hr);
}

DeclareTag(tagTreePosNoIsNodeValid,"TreePoslist","Don't Validate Tree (in nodal sense)");

#if DBG==1
// Verify that the runs match the state of the tree
BOOL
CMarkup::IsNodeValid()
{
    BOOL        fValid = FALSE;
    CTreePos *  ptpCurr, *ptpStored;
    CTreeNode * pNodeCurr = NULL, *pNodeStored;
    CStackPtrAry<CTreeNode*, 8> aryNodes(Mt(Mem));
    CStackPtrAry<CTreePos*, 8> aryTreePosOverlap(Mt(Mem));
    CStackPtrAry<LONG_PTR, 8> aryTextIDSeen(Mt(Mem));
    long        lCurrTextID = 0;
    BOOL        fAddingOverlap = TRUE;
    CTxtPtr     tp( this, 0 );

    if (IsTagEnabled( tagTreePosNoIsNodeValid ))
        return TRUE;

    ptpCurr = FirstTreePos();

    while(ptpCurr)
    {
        if(ptpCurr->IsText() || ptpCurr->IsPointer())
        {
            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos inside inclusion"));
                goto Error;
            }

            if(aryTreePosOverlap.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos inside inclusion"));
                goto Error;
            }


            if(aryNodes.Size() == 0)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Text/Pointer pos outside of all nodes"));
                goto Error;
            }

            if(ptpCurr->IsText())
            {
                tp.AdvanceCp( ptpCurr->Cch() );

                if( ptpCurr->TextID() != lCurrTextID )
                {
                    lCurrTextID = ptpCurr->TextID();
                    if( lCurrTextID != 0 )
                    {
                        if( aryTextIDSeen.Find( ptpCurr->TextID() ) != -1 )
                        {
                            TraceTag((tagError, "CMarkup::IsNodeValid - non contiguous TextID"));
                            goto Error;
                        }

                        aryTextIDSeen.Append( lCurrTextID );
                    }
                }

            }

            goto NextLoop;
        }

        if(!ptpCurr->IsNode())
        {
            TraceTag((tagError, "CMarkup::IsNodeValid - CTreePos that isn't Text, Pointer or Node"));
            goto Error;
        }

        lCurrTextID = 0;

        if( ptpCurr->IsEdgeScope() && tp.GetChar() != WCH_NODE )
        {
            TraceTag((tagError, "CMarkup::IsNodeValid - NodePos without WCH_NODE"));
            goto Error;
        }

        if( ptpCurr->IsEdgeScope() )
            tp.AdvanceCp(1);

        if(ptpCurr->IsBeginNode())
        {
            if(ptpCurr->Branch()->IsDead())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - dead node in tree"));
                goto Error;
            }

            if( ptpCurr->Branch()->Parent() != pNodeCurr )
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - invalid parent chain"));
                goto Error;
            }
        }


        if(ptpCurr->IsBeginNode() && ptpCurr->IsEdgeScope())
        {
            if(aryTreePosOverlap.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - BeginEdge Node pos inside of inclusion"));
                goto Error;
            }

            pNodeCurr = ptpCurr->Branch();

            Assert(pNodeCurr);
            aryNodes.Append(pNodeCurr);

            if(pNodeCurr->Element()->__pNodeFirstBranch != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - wrong first branch pointer"));
                goto Error;
            }

            if(!pNodeCurr->Element()->IsInMarkup())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - element not marked as in markup"));
                goto Error;
            }

        }
        else if(ptpCurr->IsBeginNode())
        {
            Assert(!ptpCurr->IsEdgeScope());

            if(aryTreePosOverlap.Size() == 0)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - BeginNonEdge Node pos without corresponding end"));
                goto Error;
            }

            if(fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Empty inclusion, non optimal tree"));
                goto Error;
            }

            fAddingOverlap = FALSE;

            ptpStored = aryTreePosOverlap[aryTreePosOverlap.Size()-1];
            aryTreePosOverlap.Delete(aryTreePosOverlap.Size()-1);

            if(aryTreePosOverlap.Size() == 0)
                fAddingOverlap = TRUE;

            if(ptpStored->Branch()->Element() != ptpCurr->Branch()->Element())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - Unmatched/Unbalanced node pos' inside of inclusion"));
                goto Error;
            }

            Assert(ptpCurr->Branch());
            aryNodes.Append(ptpCurr->Branch());

            pNodeCurr = ptpCurr->Branch();
        }
        else if(ptpCurr->IsEdgeScope())
        {
            Assert(ptpCurr->IsEndNode());

            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos in wrong place in inclusion"));
                goto Error;
            }

            if(!aryNodes.Size())
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos without corresponding begin"));
                goto Error;
            }


            pNodeStored = aryNodes[aryNodes.Size()-1];
            aryNodes.Delete(aryNodes.Size()-1);

            pNodeCurr = ptpCurr->Branch();

            if(pNodeStored != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndEdge Node pos does not match begin"));
                goto Error;
            }

            if( aryNodes.Size() )
                pNodeCurr = aryNodes[aryNodes.Size()-1];

            if(aryTreePosOverlap.Size())
                fAddingOverlap = FALSE;
        }
        else
        {
            Assert(ptpCurr->IsEndNode() && !ptpCurr->IsEdgeScope());

            if(!fAddingOverlap)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndNonEdge Node pos in wrong place in inclusion"));
                goto Error;
            }


            pNodeStored = aryNodes[aryNodes.Size()-1];
            aryNodes.Delete(aryNodes.Size()-1);

            pNodeCurr = ptpCurr->Branch();

            if(pNodeStored != pNodeCurr)
            {
                TraceTag((tagError, "CMarkup::IsNodeValid - EndNonEdge Node pos does not match begin"));
                goto Error;
            }

            if( aryNodes.Size() )
                pNodeCurr = aryNodes[aryNodes.Size()-1];

            aryTreePosOverlap.Append(ptpCurr);
        }

NextLoop:
        ptpCurr = ptpCurr->NextTreePos();
    }

    if( !AreChangesValid() )
    {
        TraceTag((tagError, "CMarkup::IsNodeValid - Changes out of sync with markup"));
        goto Error;
    }

    if(aryNodes.Size() == 0 && aryTreePosOverlap.Size() == 0)
    {
        fValid = TRUE;
    }
    else
    {
        TraceTag((tagError, "CMarkup::IsNodeValid - unclosed nodes in CTreePosList"));
    }

Error:
    return fValid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\disp.cxx ===
/*
 *  DISP.CXX
 *
 *  Purpose:
 *      CDisplay class
 *
 *  Owner:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_DOCPRINT_HXX_
#define X_DOCPRINT_HXX_
#include "docprint.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_REGION_HXX_
#define X_REGION_HXX_
#include "region.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

EXTERN_C const GUID CLSID_HTMLCheckboxElement;
EXTERN_C const GUID CLSID_HTMLRadioElement;

// Timer tick counts for background task
#define cmsecBgndInterval   300
#define cmsecBgndBusy       100

// Lines ahead
const LONG g_cExtraBeforeLazy = 10;

PerfDbgTag(tagRecalc, "Layout Recalc Engine", "Layout recalcEngine");
DeclareTag(tagPositionObjects, "PositionObjects", "PositionObjects");
DeclareTag(tagRenderingRect, "Rendering rect", "Rendering rect");
DeclareTag(tagRelDispNodeCache, "Relative disp node cache", "Trace changes to disp node cache");
DeclareTag(tagTableCalcDontReuseMeasurer, "Tables", "Disable measurer reuse across Table cells");
DeclareTag(tagDebugRTL, "RTL:DebugBreaks", "Enable RTL Debug Breaks");
DeclareTag(tagRenderLines, "Lines", "Trace line rendering");
DeclareTag(tagDisableBackground, "Layout", "Disable Background Calc");
PerfDbgExtern(tagPaintWait);

MtDefine(CRecalcTask, Layout, "CRecalcTask")
MtDefine(CDisplay, Layout, "CDisplay")
MtDefine(CDisplay_aryRegionCollection_pv, CDisplay, "CDisplay::_aryRegionCollection::_pv")
MtDefine(CRelDispNodeCache, CDisplay, "CRelDispNodeCache::_pv")
MtDefine(CDisplayUpdateView_aryInvalRects_pv, Locals, "CDisplay::UpdateView aryInvalRects::_pv")
MtDefine(CDisplayDrawBackgroundAndBorder_aryRects_pv, Locals, "CDisplay::DrawBackgroundAndBorder aryRects::_pv")
MtDefine(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv, Locals, "CDisplay::DrawBackgroundAndBorder aryNodesWithBgOrBorder::_pv")

ExternTag(tagCalcSize);

//
// This function does exactly what IntersectRect does, except that
// if one of the rects is empty, it still returns TRUE if the rect
// is located inside the other rect. [ IntersectRect rect in such
// case returns FALSE. ]
//

BOOL
IntersectRectE (RECT * prRes, const RECT * pr1, const RECT * pr2)
{
    // nAdjust is used to control what statement do we use in conditional
    // expressions: a < b or a <= b. nAdjust can be 0 or 1;
    // when (nAdjust == 0): (a - nAdjust < b) <==> (a <  b)  (*)
    // when (nAdjust == 1): (a - nAdjust < b) <==> (a <= b)  (**)
    // When at least one of rects to intersect is empty, and the empty
    // rect lies on boundary of the other, then we consider that the
    // rects DO intersect - in this case nAdjust == 0 and we use (*).
    // If both rects are not empty, and rects touch, then we should
    // consider that they DO NOT intersect and in that case nAdjust is
    // 1 and we use (**).
    //
    int nAdjust;

    Assert (prRes && pr1 && pr2);
    Assert (pr1->left <= pr1->right && pr1->top <= pr1->bottom &&
            pr2->left <= pr2->right && pr2->top <= pr2->bottom);

    prRes->left  = max (pr1->left,  pr2->left);
    prRes->right = min (pr1->right, pr2->right);
    nAdjust = (int) ( (pr1->left != pr1->right) && (pr2->left != pr2->right) );
    if (prRes->right - nAdjust < prRes->left)
        goto NoIntersect;

    prRes->top    = max (pr1->top,  pr2->top);
    prRes->bottom = min (pr1->bottom, pr2->bottom);
    nAdjust = (int) ( (pr1->top != pr1->bottom) && (pr2->top != pr2->bottom) );
    if (prRes->bottom - nAdjust < prRes->top)
        goto NoIntersect;

    return TRUE;

NoIntersect:
    SetRect (prRes, 0,0,0,0);
    return FALSE;
}

#if DBG == 1
//
// because IntersectRectE is quite fragile on boundary cases and these
// cases are not obvious, and also because bugs on these boundary cases
// would manifest in a way difficult to debug, we use this function to
// assert (in debug build only) that the function returns results we
// expect.
//
void
AssertIntersectRectE ()
{
    struct  ASSERTSTRUCT
    {
        RECT    r1;
        RECT    r2;
        RECT    rResExpected;
        BOOL    fResExpected;
    };

    ASSERTSTRUCT ts [] =
    {
        //  r1                  r2                  rResExpected      fResExpected
        // 1st non-empty, no intersect
        { {  0,  2, 99,  8 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 22, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        // 1st non-empty, intersect
        { {  0,  2, 99, 18 }, {  0, 10, 99, 20 }, {  0, 10, 99, 18 }, TRUE  },
        { {  0, 12, 99, 28 }, {  0, 10, 99, 20 }, {  0, 12, 99, 20 }, TRUE  },
        { {  0, 12, 99, 18 }, {  0, 10, 99, 20 }, {  0, 12, 99, 18 }, TRUE  },
        { {  0,  2, 99, 28 }, {  0, 10, 99, 20 }, {  0, 10, 99, 20 }, TRUE  },
        // 1st non-empty, touch
        { {  0,  2, 99, 10 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 20, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },

        // 1st empty, no intersect
        { {  0,  2, 99,  2 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        { {  0, 28, 99, 28 }, {  0, 10, 99, 20 }, {  0,  0,  0,  0 }, FALSE },
        // 1st empty, intersect
        { {  0, 12, 99, 12 }, {  0, 10, 99, 20 }, {  0, 12, 99, 12 }, TRUE  },
        // 1st empty, touch
        { {  0, 10, 99, 10 }, {  0, 10, 99, 20 }, {  0, 10, 99, 10 }, TRUE  },
        { {  0, 20, 99, 20 }, {  0, 10, 99, 20 }, {  0, 20, 99, 20 }, TRUE  },

        // both empty
        { {  0, 10, 99, 10 }, {  0, 10, 99, 10 }, {  0, 10, 99, 10 }, TRUE  }
    };

    ASSERTSTRUCT *  pts;
    RECT            r1;
    RECT            r2;
    RECT            rResActual;
    RECT            rResExpected;
    BOOL            fResActual;
    int             c;

    for (
        c = ARRAY_SIZE(ts), pts = &ts[0];
        c;
        c--, pts++)
    {
        // test
        fResActual = IntersectRectE(&rResActual, &pts->r1, &pts->r2);
        if (!EqualRect(&rResActual, &pts->rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap rects and test
        fResActual = IntersectRectE(&rResActual, &pts->r2, &pts->r1);
        if (!EqualRect(&rResActual, &pts->rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap left<->top and right<->bottom
        //   swapped left         top           right           bottom
        SetRect (&r1, pts->r1.top, pts->r1.left, pts->r1.bottom, pts->r1.right);
        SetRect (&r2, pts->r2.top, pts->r2.left, pts->r2.bottom, pts->r2.right);
        SetRect (&rResExpected, pts->rResExpected.top, pts->rResExpected.left, pts->rResExpected.bottom, pts->rResExpected.right);

        // test
        fResActual = IntersectRectE(&rResActual, &r1, &r2);
        if (!EqualRect(&rResActual, &rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

        // now swap rects and test
        fResActual = IntersectRectE(&rResActual, &r2, &r1);
        if (!EqualRect(&rResActual, &rResExpected) || fResActual != pts->fResExpected)
            goto Failed;

    }

    return;

Failed:
    Assert (0 && "IntersectRectE returns an unexpected result");
}
#endif

// ===========================  CLed  =====================================================


void CLed::SetNoMatch()
{
    _cpMatchNew  = _cpMatchOld  =
    _iliMatchNew = _iliMatchOld =
    _yMatchNew   = _yMatchOld   = MAXLONG;
}


//-------------------- Start: Code to implement background recalc in lightwt tasks

class CRecalcTask : public CTask
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CRecalcTask))

    CRecalcTask (CDisplay *pdp, DWORD grfLayout)
    {
        _pdp = pdp ;
        _grfLayout = grfLayout;
    }

    virtual void OnRun (DWORD dwTimeOut)
    {
        _pdp->StepBackgroundRecalc (dwTimeOut, _grfLayout) ;
    }

    virtual void OnTerminate () {}

private:
    CDisplay *_pdp ;
    DWORD     _grfLayout;
} ;

//-------------------- End: Code to implement background recalc in lightwt tasks


// ===========================  CDisplay  =====================================================

CDisplay::~CDisplay()
{
    // The recalc task should have disappeared during the detach!
    Assert (!HasBgRecalcInfo() && !RecalcTask());
}

CElement *
CDisplay::GetFlowLayoutElement() const
{
    return GetFlowLayout()->ElementContent();
}

CMarkup * CDisplay::GetMarkup() const
{
    return GetFlowLayout()->GetContentMarkup();
}

CDisplay::CDisplay ()
{
#if DBG==1
    _pFL = CONTAINING_RECORD(this, CFlowLayout, _dp);
#endif

    _fRecalcDone = TRUE;

#if DBG == 1
    AssertIntersectRectE ();
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDisplay::Init
//
//  Synopsis:   Initializes CDisplay
//
//  Returns:    TRUE - initialization succeeded
//              FALSE - initalization failed
//
//+----------------------------------------------------------------------------
BOOL CDisplay::Init()
{
    CFlowLayout * pFL = GetFlowLayout();

    Assert( _yCalcMax     == 0 );        // Verify allocation zeroed memory out
    Assert( _xWidth       == 0 );
    Assert( _yHeight      == 0 );
    Assert( RecalcTask()  == NULL );

    SetWordWrap(pFL->GetWordWrap());

    _xWidthView = 0;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Do stuff before dying
//
//-------------------------------------------------------------------------
void
CDisplay::Detach()
{
    // If there's a timer on, get rid of it before we detach the
    // object. This prevents us from trying to recalc the lines
    // after the CTxtSite has gone away.
    FlushRecalc();
}

/*
 *  CDisplay::GetFirstCp
 *
 *  @mfunc
 *      Return the first cp
 */
LONG
CDisplay::GetFirstCp() const
{
    return GetFlowLayout()->GetContentFirstCp();
}

/*
 *  CDisplay::GetLastCp
 *
 *  @mfunc
 *      Return the last cp
 */
LONG
CDisplay::GetLastCp() const
{
    return GetFlowLayout()->GetContentLastCp();
}

/*
 *  CDisplay::GetMaxCpCalced
 *
 *  @mfunc
 *      Return the last cp calc'ed. Note that this is
 *      relative to the start of the site, not the story.
 */
LONG
CDisplay::GetMaxCpCalced() const
{
    return GetFlowLayout()->GetContentFirstCp() + _dcpCalcMax;
}


inline BOOL
CDisplay::AllowBackgroundRecalc(CCalcInfo * pci, BOOL fBackground)
{
    CFlowLayout * pFL = GetFlowLayout();

#ifdef SWITCHES_ENABLED
    if (IsSwitchNoBgRecalc())
        return(FALSE);
#endif

#if DBG == 1
    if(IsTagEnabled(tagDisableBackground))
        return FALSE;
#endif

    // Allow background recalc when:
    //  a) Not currently calcing in the background
    //  b) It is a SIZEMODE_NATURAL request
    //  c) The CTxtSite does not size to its contents
    //  d) The site is not part of a print document
    //  e) The site allows background recalc
    //  f) This is handled by an external layout.
    //  g) Needs background recalc (see. NeedBackgroundRecalc).
    if (    !fBackground
        && (pci->_smMode == SIZEMODE_NATURAL)
        && !(pci->_grfLayout & LAYOUT_NOBACKGROUND)
        && !pFL->_fContentsAffectSize
        && !pFL->GetAutoSize()
        && !(   pFL->_fHasMarkupPtr
             && pFL->GetOwnerMarkup()->IsPrintMedia())
        && !pFL->TestClassFlag(CElement::ELEMENTDESC_NOBKGRDRECALC) )
    {
        CTreeNode           * pNode = pFL->GetFirstBranch(); 
        const CFancyFormat  * pFF   = pNode->GetFancyFormat();
        const CCharFormat   * pCF   = pNode->GetCharFormat(); 

        return (
        // (olego IEv60 bug 30250) CalcSizeEx for vertical layouts initiates calc with 
        // LAYOUT_FORCE, this may cause infinite loop if backgorund recalc is allowed:
        //
        //         +--> background calc --> element resize --+
        //         |                                         |
        //         +------ calc size with LAYOUT_FORCE <-----+ 
        // 
                    !pCF->HasVerticalLayoutFlow() 
                &&  !(pCF->_fHasBgImage && pFF->GetBgPosY().IsPercent())    );
    }
    return FALSE;
}


/*
 *  CDisplay::FlushRecalc()
 *
 *  @mfunc
 *      Destroys the line array, therefore ensure a full recalc next time
 *      RecalcView or UpdateView is called.
 *
 */
void CDisplay::FlushRecalc()
{
    CFlowLayout * pFL = GetFlowLayout();

    StopBackgroundRecalc();
    ClearStoredRFEs();

    if (LineCount())
    {
        Forget();
        Remove(0, -1, AF_KEEPMEM);          // Remove all old lines from *this
    }

    TraceTag((tagRelDispNodeCache, "SN: (%d) FlushRecalc:: invalidating rel line cache",
                                GetFlowLayout()->SN()));

    pFL->_fContainsRelative   = FALSE;
    pFL->CancelChanges();

    VoidRelDispNodeCache();
    DestroyFlowDispNodes();

    _fRecalcDone = FALSE;
    _yCalcMax   = 0;                        // Set both maxes to start of text
    _dcpCalcMax = 0;                        // Relative to the start cp of site.
    _xWidth     = 0;
    _yHeight    = 0;
    _yHeightMax = 0;

    _fLastLineAligned = 
    _fContainsHorzPercentAttr =
    _fContainsVertPercentAttr =
    _fNavHackPossible      =
    _fHasLongLine =
    _fHasMultipleTextNodes = FALSE;
    _fHasNegBlockMargins = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     NoteMost
//
//  Purpose:    Notes if the line has anything which will need us to compute
//              information for negative lines/absolute or relative divs
//
//----------------------------------------------------------------------------
void
CDisplay::NoteMost(CLineFull *pli)
{
    Assert (pli);

    if (   !_fRecalcMost
        && (   pli->GetYMostTop() < 0
            || pli->GetYHeightBottomOff() > 0
            || pli->_fHasAbsoluteElt
           )
       )
    {
        _fRecalcMost = TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     RecalcMost
//
//  Purpose:    Calculates the most negative line and most positive/negative
//              positioned site from scratch.
//
//  NOTE (sujalp): We initially had an incremental way of computing both the
//  negative line hts info AND +/- positioned site info. However, this logic was
//  incorrect for consecutive lines with -ve line height. So we changed it so
//  that we compute this AND +/- info always. If this becomes a performance issue
//  we could go back for incremental computation for div's easily -- but would
//  have to maintain extra state information. For negative line heights we could
//  also do some incremental stuff, but it would be much much more complicated
//  than what we have now.
//
//----------------------------------------------------------------------------
void
CDisplay::RecalcMost()
{

    if (_fRecalcMost)
    {
        LONG ili;

        long yNegOffset = 0;        // offset at which the current line is drawn
                                    // as a result of a series of lines with negative
                                    // height
        long yPosOffset = 0;

        long yBottomOffset = 0;     // offset by which the current lines contents
                                    // extend beyond the yHeight of the line.
        long yTopOffset = 0;        // offset by which the current lines contents
                                    // extend before the current y position

        _yMostNeg = 0;
        _yMostPos = 0;

        for (ili = 0; ili < LineCount(); ili++)
        {
            CLineCore *pli = Elem(ili);
            CLineOtherInfo *ploi = pli->oi();
            LONG yLineBottomOffset = pli->GetYHeightBottomOff(ploi);

            // top offset of the current line
            yTopOffset = pli->GetYMostTop(ploi) + yNegOffset;

            yBottomOffset = yLineBottomOffset + yPosOffset;

            // update the most negative value if the line has negative before space
            // or line height < actual extent
            if(yTopOffset < 0 && _yMostNeg > yTopOffset)
            {
                _yMostNeg = yTopOffset;
            }

            if (yBottomOffset > 0 && _yMostPos < yBottomOffset)
            {
                _yMostPos = yBottomOffset;
            }

            // if the current line forces a new line and has negative height
            // update the negative offset at which the next line is drawn.
            if(pli->_fForceNewLine)
            {
                if(pli->_yHeight < 0)
                {
                    yNegOffset += pli->_yHeight;
                }
                else
                {
                    yNegOffset = 0;
                }

                if (yLineBottomOffset > 0)
                {
                    yPosOffset += yLineBottomOffset;
                }
                else
                {
                    yPosOffset = 0;
                }
            }
        }

        _fRecalcMost = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     RecalcPlainTextSingleLine
//
//  Purpose:    A high-performance substitute for RecalcView. Does not go
//              through Line Services. Can only be used to measure a single
//              line of plain text (i.e. no HTML).
//
//----------------------------------------------------------------------------

BOOL
CDisplay::RecalcPlainTextSingleLine(CCalcInfo * pci)
{
    CFlowLayout *       pFlowLayout = GetFlowLayout();
    CTreeNode *         pNode       = pFlowLayout->GetFirstBranch();
    TCHAR               chPassword  = pFlowLayout->GetPasswordCh();
    long                cch         = pFlowLayout->GetContentTextLength();
    const CCharFormat * pCF         = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CParaFormat * pPF         = pNode->GetParaFormat(LC_TO_FC(pci->GetLayoutContext()));
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs = NULL;
    long                lWidth;
    long                lCharWidth;
    long                xShift;
    long                xWidth, yHeight;
    long                lPadding[SIDE_MAX];
    BOOL                fViewChanged = FALSE;
    CLineFull           lif;
    CLineCore *         pli;
    UINT                uJustified;
    long                xDummy, yBottomMarginOld = _yBottomMargin;

    //There is no difference between MMWIDTH or MINWIDTH - they are the same
    //and even the max width == min width because there are no line breaks.
    //(for plain text, single line case that we are dealing with) 
    BOOL                fMinMax = (   pci->_smMode == SIZEMODE_MMWIDTH 
                                   || pci->_smMode == SIZEMODE_MINWIDTH
                                  );  

    Assert(pPF);
    Assert(pCF);
    Assert(pci);
    Assert(cch >= 0);

    if (!pPF || !pCF || !pci || cch < 0)
        return FALSE;

    // Bail out if there is anything special in the format that can not be done here
    if (    pCF->IsTextTransformNeeded()
        ||  !pCF->_cuvLineHeight.IsNullOrEnum()
        ||  !pCF->_cuvLetterSpacing.IsNullOrEnum()
        ||  !pCF->_cuvWordSpacing.IsNullOrEnum()
        ||  pCF->_fRTL)
    {
        goto HardCase;
    }


    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        return FALSE;
    pBaseCcs = ccs.GetBaseCcs();
    
    lWidth = 0;

    if (cch)
    {
        if (chPassword)
        {
            if (!ccs.Include(chPassword, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth = cch * lCharWidth;
        }
        else
        {
            CTxtPtr     tp(GetMarkup(), pFlowLayout->GetContentFirstCp());
            LONG        cchValid;
            LONG        cchRemaining = cch;

            for (;;)
            {
                const TCHAR * pchText = tp.GetPch(cchValid);
                LONG i = min(cchRemaining, cchValid);

                while (i--)
                {
                    const TCHAR ch = *pchText++;

                    // Bail out if not a simple ASCII char

                    if (!InRange( ch, 32, 127 ))
                        goto HardCase;

                    if (!ccs.Include(ch, lCharWidth))
                    {
                        Assert(0 && "Char not in font!");
                    }
                    lWidth += lCharWidth;
                }

                if (cchRemaining <= cchValid)
                {
                    break;
                }
                else
                {
                    cchRemaining -= cchValid;
                    tp.AdvanceCp(cchValid);
                }
            }
        }
    }

    GetPadding(pci, lPadding, fMinMax);
    FlushRecalc();

    pli = Add(1, NULL);
    if (!pli)
        return FALSE;

    lif.Init();
    lif._cch               = cch;
    lif._xWidth            = lWidth;
    lif._yTxtDescent       = pBaseCcs->_yDescent;
    lif._yDescent          = pBaseCcs->_yDescent;
    lif._xLineOverhang     = pBaseCcs->_xOverhang;
    lif._yExtent           = pBaseCcs->_yHeight;
    lif._yBeforeSpace      = lPadding[SIDE_TOP];
    lif._yHeight           = pBaseCcs->_yHeight + lif._yBeforeSpace;
    lif._xLeft             = lPadding[SIDE_LEFT];
    lif._xRight            = lPadding[SIDE_RIGHT];
    lif._xLeftMargin       = 0;
    lif._xRightMargin      = 0;
    lif._fForceNewLine     = TRUE;
    lif._fFirstInPara      = TRUE;
    lif._fFirstFragInLine  = TRUE;
    lif._fCanBlastToScreen = !chPassword && !pCF->_fDisabled;

    _yBottomMargin  = lPadding[SIDE_BOTTOM];
    _dcpCalcMax     = cch;

    yHeight          = lif._yHeight;
    xWidth           = lif.CalcLineWidth();

    xShift = ComputeLineShift(
                        (htmlAlign)pPF->GetBlockAlign(TRUE),
                        IsRTLDisplay(),
                        pPF->HasRTL(TRUE),
                        fMinMax,
                        _xWidthView,
                        xWidth + GetCaret(),
                        &uJustified,
                        &xDummy);

    lif._fJustified = uJustified;
    
    lif._xLeft  += xShift;
    xWidth      += xShift;

    // In RTL display, save shift if it is negative (that won't happen in LTR)
    if (IsRTLDisplay() && xShift < 0)
        lif._xNegativeShiftRTL = xShift;

    lif._xLineWidth = max(xWidth, _xWidthView);

    pli->AssignLine(lif);
    
    if(yHeight + yBottomMarginOld != _yHeight + _yBottomMargin || xWidth != _xWidth)
        fViewChanged = TRUE;

    _yCalcMax       =
    _yHeightMax     =
    _yHeight        = yHeight;
    _xWidth         = xWidth;
    _fRecalcDone    = TRUE;
    _fMinMaxCalced  = TRUE;
    _xMinWidth      =
    _xMaxWidth      = _xWidth + GetCaret();

    if ((   pci->_smMode == SIZEMODE_NATURAL 
         || pci->_smMode == SIZEMODE_NATURALMIN
        )
        && fViewChanged
       )
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        //This function is only used to calc text inside INPUT tag and 
        //only when full calc is invoked. In this case, we have to request
        //resize in parent, if parent is not calcing us at the moment 
        //(this check is inside CElement::ResizeElement()).
        //This is needed when INPUT got a change in something like font-size
        //and therefore its default size changed. this causes INPUT layout to 
        //be queued for measurement and it will receive DoLayout() call.
        //If this will cause full text recalc, we'll get here and request recalc 
        //in parent. IE6 bug 2823.
        Assert(pFlowLayout->ElementOwner()->Tag() == ETAG_INPUT);
        ElementResize(pFlowLayout, TRUE);

        pFlowLayout->NotifyMeasuredRange(pFlowLayout->GetContentFirstCp(),
                                         GetMaxCpCalced());
    }

    ccs.Release();

    return TRUE;

HardCase:

    ccs.Release();

    // Just do it the hard way
    return RecalcLines(pci);
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     RecalcPlainTextSingleLine
//
//  Purpose:    A high-performance substitute for RecalcView. Does not go
//              through Line Services. Can only be used to measure a single
//              line of plain text (i.e. no HTML).
//
//----------------------------------------------------------------------------
BOOL
CDisplay::RecalcPlainTextSingleLineEx(CCalcInfo * pci)
{
    CFlowLayout *       pFlowLayout = GetFlowLayout();
    CTreeNode *         pNode       = pFlowLayout->GetFirstBranch();
    TCHAR               chPassword  = pFlowLayout->GetPasswordCh();
    long                cch         = pFlowLayout->GetContentTextLength();
    const CCharFormat * pCF         = pNode->GetCharFormat(LC_TO_FC(pci->GetLayoutContext()));
    const CParaFormat * pPF         = pNode->GetParaFormat(LC_TO_FC(pci->GetLayoutContext()));
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs = NULL;
    long                lWidth;
    long                lCharWidth;
    long                xShift;
    long                xWidth, yHeight;
    long                lPadding[SIDE_MAX];
    BOOL                fViewChanged = FALSE;
    CLineFull           lif;
    CLineCore *         pli;
    UINT                uJustified;
    long                xDummy, yBottomMarginOld = _yBottomMargin;
    LONG                xWidthView = GetAvailableWidth();
    
    //There is no difference between MMWIDTH or MINWIDTH - they are the same
    //and even the max width == min width because there are no line breaks.
    //(for plain text, single line case that we are dealing with) 
    BOOL                fMinMax = (   pci->_smMode == SIZEMODE_MMWIDTH 
                                   || pci->_smMode == SIZEMODE_MINWIDTH
                                  );  

    Assert(pPF);
    Assert(pCF);
    Assert(pci);
    Assert(cch >= 0);

    if (!pPF || !pCF || !pci || cch < 0)
        return FALSE;

    // Bail out if there is anything special in the format that can not be done here
    if (    pCF->IsTextTransformNeeded()
        ||  !pCF->_cuvLineHeight.IsNullOrEnum()
        ||  !pCF->_cuvLetterSpacing.IsNullOrEnum()
        ||  pCF->_fRTL)
    {
        goto HardCase;
    }


    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        return FALSE;
    pBaseCcs = ccs.GetBaseCcs();

    lWidth = 0;

    if (cch)
    {
        if (chPassword)
        {
            if (!ccs.Include(chPassword, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth = cch * lCharWidth;
        }
        else
        {
            CTxtPtr     tp(GetMarkup(), pFlowLayout->GetContentFirstCp());
            LONG        cchValid;
            LONG        cchRemaining = cch;
            GetTreeExtent
            for (;;)
            {
                const TCHAR * pchText = tp.GetPch(cchValid);
                LONG i = min(cchRemaining, cchValid);

                while (i--)
                {
                    const TCHAR ch = *pchText++;

                    // Bail out if not a simple ASCII char

                    if (!InRange( ch, 32, 127 ))
                        goto HardCase;

                    if (!ccs.Include(ch, lCharWidth))
                    {
                        Assert(0 && "Char not in font!");
                    }
                    lWidth += lCharWidth;
                    if (lWidth > xWidthView)
                        goto HardCase;
                }

                if (cchRemaining <= cchValid)
                {
                    break;
                }
                else
                {
                    cchRemaining -= cchValid;
                    tp.AdvanceCp(cchValid);
                }
            }
        }
    }

    GetPadding(pci, lPadding, fMinMax);
    FlushRecalc();

    pli = Add(1, NULL);
    if (!pli)
        return FALSE;

    lif.Init();
    lif._cch               = cch;
    lif._xWidth            = lWidth;
    lif._yTxtDescent       = pBaseCcs->_yDescent;
    lif._yDescent          = pBaseCcs->_yDescent;
    lif._xLineOverhang     = pBaseCcs->_xOverhang;
    lif._yExtent           = pBaseCcs->_yHeight;
    lif._yBeforeSpace      = lPadding[SIDE_TOP];
    lif._yHeight           = pBaseCcs->_yHeight + lif._yBeforeSpace;
    lif._xLeft             = lPadding[SIDE_LEFT];
    lif._xRight            = lPadding[SIDE_RIGHT];
    lif._xLeftMargin       = 0;
    lif._xRightMargin      = 0;
    lif._fForceNewLine     = TRUE;
    lif._fFirstInPara      = TRUE;
    lif._fFirstFragInLine  = TRUE;
    lif._fCanBlastToScreen = !chPassword && !pCF->_fDisabled;

    _yBottomMargin  = lPadding[SIDE_BOTTOM];
    _dcpCalcMax     = cch;

    yHeight          = lif._yHeight;
    xWidth           = lif.CalcLineWidth();

    xShift = ComputeLineShift(
                              (htmlAlign)pPF->GetBlockAlign(TRUE),
                              IsRTLDisplay(),
                              pPF->HasRTL(TRUE),
                              fMinMax,
                              _xWidthView,
                              xWidth + GetCaret(),
                              &uJustified,
                              &xDummy);

    lif._fJustified = uJustified;

    lif._xLeft  += xShift;
    xWidth      += xShift;

    // In RTL display, save shift if it is negative (that won't happen in LTR)
    if (IsRTLDisplay() && xShift < 0)
        lif._xNegativeShiftRTL = xShift;

    lif._xLineWidth = max(xWidth, _xWidthView);

    pli->AssignLine(lif);

    if(yHeight + yBottomMarginOld != _yHeight + _yBottomMargin || xWidth != _xWidth)
        fViewChanged = TRUE;

    _yCalcMax       =
    _yHeightMax     =
    _yHeight        = yHeight;
    _xWidth         = xWidth;
    _fRecalcDone    = TRUE;
    _fMinMaxCalced  = TRUE;
    _xMinWidth      =
    _xMaxWidth      = _xWidth + GetCaret();

    if ((   pci->_smMode == SIZEMODE_NATURAL 
         || pci->_smMode == SIZEMODE_NATURALMIN
        )
        && fViewChanged
       )
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        //This function is only used to calc text inside INPUT tag and 
        //only when full calc is invoked. In this case, we have to request
        //resize in parent, if parent is not calcing us at the moment 
        //(this check is inside CElement::ResizeElement()).
        //This is needed when INPUT got a change in something like font-size
        //and therefore its default size changed. this causes INPUT layout to 
        //be queued for measurement and it will receive DoLayout() call.
        //If this will cause full text recalc, we'll get here and request recalc 
        //in parent. IE6 bug 2823.
        Assert(pFlowLayout->ElementOwner()->Tag() == ETAG_INPUT);
        ElementResize(pFlowLayout, TRUE);

        pFlowLayout->NotifyMeasuredRange(pFlowLayout->GetContentFirstCp(),
                                         GetMaxCpCalced());
    }

    ccs.Release();

    return TRUE;

HardCase:

    ccs.Release();

    // Just do it the hard way
    return RecalcLines(pci);
}
#endif

/*
 *  CDisplay::RecalcLines()
 *
 *  @mfunc
 *      Recalc all line breaks.
 *      This method does a lazy calc after the last visible line
 *      except for a bottomless control
 *
 *  @rdesc
 *      TRUE if success
 */

BOOL CDisplay::RecalcLines(CCalcInfo * pci)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    SwitchesBegTimer(SWITCHES_TIMER_RECALCLINES);

    BOOL fRet;

    if (GetFlowLayout()->ElementOwner()->IsInMarkup())
    {
        if (        pci->_fTableCalcInfo
                    && ((CTableCalcInfo *) pci)->_pme
          WHEN_DBG( && !IsTagEnabled(tagTableCalcDontReuseMeasurer) ) )
        {
            // Save calcinfo's measurer.
            CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
            CLSMeasurer * pme = ptci->_pme;

            // Reinitialize the measurer.
            pme->Reinit(this, ptci);

            // Make sure noone else uses this measurer.
            ptci->_pme = NULL;

            // Do actual RecalcLines work with this measurer.
            fRet = RecalcLinesWithMeasurer(ptci, pme);

            // Restore TableCalcInfo measurer.
            ptci->_pme = pme;
        }
        else
        {
            // Cook up measurer on the stack.
            CLSMeasurer me(this, pci);

            fRet = RecalcLinesWithMeasurer(pci, &me);
        }

        //
        // Update descent of the layout (descent of the last text line)
        //
        if (GetFlowLayout()->Tag() != ETAG_IFRAME)
        {
            LONG yLayoutDescent = 0;
            for (LONG i = Count() - 1; i >= 0; i--)
            {
                CLineCore * pli = Elem(i);

                // need to test the pli && OI() calls to prevent stress crash
                if (pli && pli->IsTextLine())
                {

                    yLayoutDescent = pli->oi() ? pli->oi()->_yDescent : 0;
                    break;
                }
            }
            GetFlowLayout()->_yDescent = yLayoutDescent;
        }
        else
        {
            GetFlowLayout()->_yDescent = 0;
        }
    }
    else
        fRet = FALSE;

    SwitchesEndTimer(SWITCHES_TIMER_RECALCLINES);

    return fRet;
}

/*
 *  CDisplay::RecalcLines()
 *
 *  @mfunc
 *      Recalc all line breaks.
 *      This method does a lazy calc after the last visible line
 *      except for a bottomless control
 *
 *  @rdesc
 *      TRUE if success
 */

BOOL CDisplay::RecalcLinesWithMeasurer(CCalcInfo * pci, CLSMeasurer * pme)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementFL  = pFlowLayout->ElementOwner();
    CElement::CLock     Lock(pElementFL, CElement::ELEMENTLOCK_RECALC);

    CRecalcLinePtr  RecalcLinePtr(this, pci);
    CLineCore *     pliNew    = NULL;
    int             iLine     = -1;
    int             iLinePrev = -1;
    long            yHeightPrev;
    UINT            uiMode;
    UINT            uiFlags;
    BOOL            fDone                   = TRUE;
    BOOL            fFirstInPara            = TRUE;
    BOOL            fWaitForCpToBeCalcedTo  = TRUE;
    LONG            cpToBeCalcedTo          = 0;
    BOOL            fAllowBackgroundRecalc;
    LONG            yHeight         = 0;
    LONG            yAlignDescent   = 0;
    LONG            yHeightView     = GetViewHeight();
    LONG            xMinLineWidth   = 0;
    LONG *          pxMinLineWidth  = NULL;
    LONG            xMaxLineWidth   = 0;
    LONG            yHeightDisplay  = 0;     // to keep track of line with top negative margins
    LONG            yHeightOld      = _yHeight;
    LONG            yHeightMaxOld   = _yHeightMax;
    LONG            xWidthOld       = _xWidth;
    LONG            yBottomMarginOld= _yBottomMargin;
    BOOL            fViewChanged    = FALSE;
    BOOL            fNormalMode     = pci->IsNaturalMode();
    CDispNode *     pDNBefore;
    long            lPadding[SIDE_MAX];
    CLayoutContext * pLayoutContext = pci->GetLayoutContext();
    BOOL             fDoBreaking =  pLayoutContext                      // tells if breaking should be applied.
                                &&  pLayoutContext->ViewChain() 
                                &&  pFlowLayout->ElementCanBeBroken() 
                                &&  pci->_smMode != SIZEMODE_MMWIDTH 
                                &&  pci->_smMode != SIZEMODE_NATURALMIN;

    // we should not be measuring hidden stuff.
    Assert(!pElementFL->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())));

    Assert(pElementFL->Tag() != ETAG_ROOT);

    if (!pme->_pLS)
        return FALSE;

    if (!pElementFL->IsInMarkup())
    {
        return TRUE;
    }

    ClearStoredRFEs();

    //  TODO: (olego, tracking bug 111963) in print preview we should take into 
    //  acount top margin only for the first page and never do so for bottom margin
    GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);
    _yBottomMargin = lPadding[SIDE_BOTTOM];

    // Set up the CCalcInfo to the correct mode and parent size
    if (pci->_smMode == SIZEMODE_SET)
    {
        pci->_smMode = SIZEMODE_NATURAL;
    }

    // Determine the mode
    uiMode = MEASURE_BREAKATWORD;

    Assert (pci);

    switch(pci->_smMode)
    {
    case SIZEMODE_MMWIDTH:
    case SIZEMODE_NATURALMIN:
        uiMode |= MEASURE_MAXWIDTH;
        _xMinWidth = 0;
        pxMinLineWidth = &xMinLineWidth;
        break;
    case SIZEMODE_MINWIDTH:
        uiMode |= MEASURE_MINWIDTH;
        pme->AdvanceToNextAlignedObject();
        break;
    }

    uiFlags = uiMode;

    // Determine if background recalc is allowed
    // (And if it is, do not calc past the visible portion)
    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci);

    if (fAllowBackgroundRecalc)
    {
        cpToBeCalcedTo = max(GetFirstVisibleCp(), CPWait());
    }
    
    // Flush all old lines
    FlushRecalc();

    pme->_pDispNodePrev = NULL;

    if (fAllowBackgroundRecalc)
    {
        if (!SUCCEEDED(EnsureBgRecalcInfo()))
        {
            fAllowBackgroundRecalc = FALSE;
            AssertSz(FALSE, "CDisplay::RecalcLinesWithMeasurer - Could not create BgRecalcInfo");
        }
    }

    RecalcLinePtr.Init((CLineArray *)this, 0, NULL);

    // recalculate margins
    RecalcLinePtr.RecalcMargins(0, 0, yHeight, 0);

    if (pElementFL->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())))
    {
        pliNew = RecalcLinePtr.AddLine();
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }
        pme->NewLine(uiFlags & MEASURE_FIRSTINPARA);
        pme->_li._cch = pElementFL->GetElementCch();

        // Finally copy the line over
        pliNew->AssignLine(pme->_li);
    }
    else
    {
        // MULTI_LAYOUT - Determine if this element has been partially measured
        LONG             cpCur   = 0;
        LONG             cpStart = -1;     // starting cp for current layout rect. May be -1 which means 
                                           // all content has been calculated previously and line loop should 
                                           // be skipped
        int             cyAvail = pci->_cyAvail - _yBottomMargin;
        BOOL            fHasContent = 0;

        LONG            xPadLeftCur = 0;
        LONG            xPadRightCur = 0;

        LAYOUT_OVERFLOWTYPE   overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW; // break type for previous break
        LAYOUT_OVERFLOWTYPE   overflowTypeCurr; // break type for current break

        CFlowLayoutBreak * pEndingBreak = NULL; //  ending (resulting) break for the calculations
        CElement         * pElementCausedPageBreakBefore = NULL;

        AssertSz(pci->_yConsumed == 0, "Improper CCalcInfo members handling ???");
        AssertSz(CHK_CALCINFO_PPV(pci), "PPV members of CCalcInfo should stay untouched in browse mode !");

        //  fDoBreaking == TRUE means that this layout is slave and is a part of a chain and is breakable. 
        //  So we need to do partial measurement.

        if (fDoBreaking)
        {
            CLayoutBreak *  pLayoutBreak; 

            // Create the ending entry and put it into break table to make it available during 
            // calculation. (RecalcLinePtr code needs it to save floating and aligned object)
            pEndingBreak = DYNCAST(CFlowLayoutBreak, pLayoutContext->CreateBreakForLayout(pFlowLayout));
            Assert(pEndingBreak && "Could not create a break !!!");

            if (pEndingBreak)
            {
                //  By default make it layout complete entry. 
                //  If we reach layout overflow we'll change it.
                pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LAYOUTCOMPLETE, LAYOUT_OVERFLOWTYPE_UNDEFINED);
                pLayoutContext->SetLayoutBreak(pElementFL, pEndingBreak);
            }

            // We need to know where to pick up measurement; GetBreak actually fetches the break entry
            // for the layout rect _before_ us (hence letting us know whether anyone before us has measured
            // part of this element already).
            //  if pLayoutBreak == NULL this is the very first container. 
            pLayoutContext->GetLayoutBreak(pElementFL, &pLayoutBreak);

            if (pLayoutBreak == NULL)
            {
                cpStart          = pme->GetCp();
                overflowTypePrev = LAYOUT_OVERFLOWTYPE_OVERFLOW;
            }
            else if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            {
                //  retrieve starting position for this container.
                CFlowLayoutBreak *pFlowLayoutBreak = DYNCAST(CFlowLayoutBreak, pLayoutBreak);

                cpStart = pFlowLayoutBreak->GetMarkupPointer()->GetCp();
                pme->Advance(cpStart - pFlowLayout->GetContentFirstCp());
                overflowTypePrev = pLayoutBreak->OverflowType();
                pElementCausedPageBreakBefore = pFlowLayoutBreak->_pElementPBB;

                RecalcLinePtr._xPadLeft  = pFlowLayoutBreak->GetPadLeft();
                RecalcLinePtr._xPadRight = pFlowLayoutBreak->GetPadRight();

                if (   !pFlowLayoutBreak->HasSiteTasks()
                    && RecalcLinePtr._marginInfo._xLeftMargin < pFlowLayoutBreak->GetLeftMargin()  )
                {
                    RecalcLinePtr._marginInfo._xLeftMargin = pFlowLayoutBreak->GetLeftMargin();
                    RecalcLinePtr._marginInfo._yLeftMargin = 1;
                    RecalcLinePtr._marginInfo._yBottomLeftMargin = 0;
                }

                if (   !pFlowLayoutBreak->HasSiteTasks()
                    && RecalcLinePtr._marginInfo._xRightMargin < pFlowLayoutBreak->GetRightMargin()  )
                {
                    RecalcLinePtr._marginInfo._xRightMargin = pFlowLayoutBreak->GetRightMargin();
                    RecalcLinePtr._marginInfo._yRightMargin = 1;
                    RecalcLinePtr._marginInfo._yBottomRightMargin = 0;
                }
            }

            //  cpStart == -1 only if content has been calculated already
            Assert(   cpStart != -1 
                   || (pLayoutBreak && pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE));
        }

        if (!fDoBreaking || -1 < cpStart)
        // The following loop generates new lines
        do
        {
            // Add one new line
            if (fDoBreaking && pEndingBreak)
            {
                // pci->_yConsumed is used by the breaking code to determine the available height in the 
                // parent in order to determine where to break;
                // yHeight : accumulates the height of the currently measured lines
                // _yBottomMargin  : is unusable space so count it as part of the current Height
                //
                pci->_yConsumed = yHeight + _yBottomMargin;

                // remember current cp
                cpCur = pme->GetCp();

                // and padding 
                xPadLeftCur  = RecalcLinePtr._xPadLeft;
                xPadRightCur = RecalcLinePtr._xPadRight;

                //  and if there is a content
                fHasContent = pci->_fHasContent;
            }

            pliNew = RecalcLinePtr.AddLine();
            if (!pliNew)
            {
                Assert(FALSE);
                goto err;
            }

            uiFlags &= ~MEASURE_FIRSTINPARA;
            uiFlags |= (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

            PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", pme->GetCp());

            iLine = LineCount() - 1;

            if (long(pme->GetCp()) == pme->GetLastCp())
            {
                uiFlags |= MEASURE_EMPTYLASTLINE;
            }

            //
            // Cache the previous dispnode to insert a new content node
            // if the next line measured has negative margins(offset) which
            // causes the next line on top of the previous lines.
            //
            pDNBefore = pme->_pDispNodePrev;
            iLinePrev = iLine;
            yHeightPrev = yHeight;

            if(!RecalcLinePtr.MeasureLine(*pme, uiFlags,
                                            &iLine, &yHeight, &yAlignDescent,
                                            pxMinLineWidth, &xMaxLineWidth))
            {
                goto err;
            }

            //
            // iLine returned is the last text line inserted. There may be
            // aligned lines and clear lines added before and after the
            // text line
            //
            pliNew = iLine >=0 ? RecalcLinePtr[iLine] : NULL;
            Assert(pliNew ? pme->_li == *pliNew : TRUE);
            _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);

            if (fDoBreaking && pEndingBreak)
            {
                if (
                    // page-break-before condition
                       (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKBEFORE, 
                           pliNew
                        && pliNew->_fPageBreakBefore
                        && pElementCausedPageBreakBefore != pEndingBreak->_pElementPBB 
                        )
                    // overflow condition
                    || (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_OVERFLOW, 
                        //  TODO: (olego,tracking bug 111963) : what is our vertical restriction here ? 
                        //  In CFlowLayout::MeasureSize CDisplay::GetViewWidthAndHeightForChild 
                        //  counts top and bottom padding while calc height available for child. 
                        //  If the whole _yHeightView counts here so available height for child 
                        //  in MeasureSite could be negative !!! 
                        //  Should we count top and bottom padding's for very first and very 
                        //  last layout rect only ???
                       yHeight > cyAvail 
                        //  Do break only if there is at least one line in this rect.
                       && fHasContent 
                        //  this means our child consumed all available height
                       || pci->_fLayoutOverflow)
                    // page-break-after condition
                    || (overflowTypeCurr = LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER, 
                           pliNew
                        && pliNew->_fPageBreakAfter
                        //  (bug #100239)
                        /*&& pme->GetCp() < pme->GetLastCp()*/)
                    )
                {   
                    //
                    // We have finished with this block, do breaking here
                    //
                    {
                        Assert(pEndingBreak && "Ending break must be created at this point !!!");

                        CMarkupPointer  * pmkpPtr;
                        // Create a new markup pointer at this cp.
                        pmkpPtr = new CMarkupPointer(GetFlowLayout()->Doc());
                        if (pmkpPtr)
                        {
                            pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, overflowTypeCurr);
                            
                            if (overflowTypeCurr == LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER)
                            {
                                pmkpPtr->MoveToCp(pme->GetCp(), GetMarkup());
                                pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 0, 0, 
                                    RecalcLinePtr._xPadLeft, RecalcLinePtr._xPadRight);
                            }
                            else 
                            {
                                pmkpPtr->MoveToCp(cpCur, GetMarkup());
                                pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 
                                    cpCur == cpStart ? 0 : RecalcLinePtr._marginInfo._xLeftMargin, 
                                    cpCur == cpStart ? 0 : RecalcLinePtr._marginInfo._xRightMargin, 
                                    xPadLeftCur, 
                                    xPadRightCur);

                                if (    0 < iLinePrev 
                                    &&  pEndingBreak->HasSiteTasks()    ) 
                                {
                                    Assert(Elem(iLinePrev - 1));
                                    CLineCore *pLine = Elem(iLinePrev - 1);

                                    if (pLine->IsClear())
                                    {
                                        CLineOtherInfo *ploi = pLine->oi(); 

                                        pEndingBreak->_fClearLeft   = ploi->_fClearLeft;
                                        pEndingBreak->_fClearRight  = ploi->_fClearRight;
                                        pEndingBreak->_fAutoClear   = ploi->_fAutoClear;
                                    }
                                }
                            }
                        }
                    }

                    if (    overflowTypeCurr != LAYOUT_OVERFLOWTYPE_PAGEBREAKAFTER 
                        //  this means our child consumed all available height
                        && (    overflowTypeCurr != LAYOUT_OVERFLOWTYPE_OVERFLOW 
                            || !pci->_fLayoutOverflow)   )
                    {
                        // TODO: (olego, text team, tracking bug 111968): Make RecalcLine transactional
                        // This is kind of HACK because of CRecalcLinePtr::MeasureLine also adds 
                        // current line into array by default.
                        // This means we need to undo the effects of measuring that
                        // line, and remove it from the line array so when the next
                        // layout measures it, it will be the only one referring to
                        // this content.
                        UndoMeasure( pci->GetLayoutContext(), cpCur, pme->GetCp() );
                        pme->_pDispNodePrev = pDNBefore;

                        // iLinePrev contains the starting line's index from 
                        // which lines should be removed from the array
                        while (iLine >= iLinePrev)
                        {
                            Assert(Elem(iLine));
                            Forget(iLine, 1);
                            Remove(iLine, 1, AF_DELETEMEM);
                            --iLine;
                        }
                        Assert(iLine == (iLinePrev - 1));
                        Assert(iLine >= 0 || LineCount() == 0);

                        yHeight = yHeightPrev;

                        pme->Advance(cpCur - pme->GetCp());

                        if (LineCount() == 0)
                        {
                            // if there is no lines in the array set _fNoContent
                            _fNoContent = TRUE;
                            pliNew      = NULL;
                        }
                        else 
                        {
                            pliNew = Elem(iLine);
                        }
                    }
                    else 
                    {
                        pci->_fHasContent = TRUE;
                    }

                    pci->_fLayoutOverflow = TRUE;
                    break;
                }
                //  TODO: (olego, tracking bug 111984) the check below should be placed out of the loop. 
                //  But because of measurer implementation if a layout has a child and child did break 
                //  (which means only part of content was calced) we will return with 
                //  pme->GetCp() == pme->GetLastCp(). 
                else if (pme->GetCp() == pme->GetLastCp())
                {
                    Assert(pEndingBreak && "Ending break must be created at this point !!!");
                    if (pEndingBreak->HasSiteTasks())
                    {
                        //  We do not have our own content but there are site tasks (floating objets)
                        CMarkupPointer  * pmkpPtr;
                        // Create a new markup pointer at this cp.
                        pmkpPtr = new CMarkupPointer(GetFlowLayout()->Doc());
                        if (pmkpPtr)
                        {
                            // Set the markup to point to this cp:
                            pmkpPtr->MoveToCp(pme->GetCp(), GetMarkup());

                            pEndingBreak->SetLayoutBreak(LAYOUT_BREAKTYPE_LINKEDOVERFLOW, LAYOUT_OVERFLOWTYPE_OVERFLOW);
                            pEndingBreak->SetFlowLayoutBreak(pmkpPtr, 0, 0, 0, 0);
                        }

                        pci->_fLayoutOverflow = TRUE;
                    }
                }

                //  only layouts that are allowed to break may set this flag
                pci->_fHasContent = TRUE;
            }
            // end MULTI_LAYOUT - break determination

            // fix for bug 16519 (srinib)
            // Keep track of the line that contributes to the max height, ex: if the
            // last lines top margin is negative.
            if(yHeightDisplay < yHeight)
                yHeightDisplay = yHeight;

            fFirstInPara = (iLine >= 0)
                                ? pme->_li.IsNextLineFirstInPara()
                                : TRUE;

            if (fNormalMode && iLine >= 0)
            {
                HandleNegativelyPositionedContent(&pme->_li, pme, pDNBefore, iLinePrev, yHeightPrev);
            }

            if (fAllowBackgroundRecalc)
            {
                Assert(HasBgRecalcInfo());

                if (fWaitForCpToBeCalcedTo)
                {
                    if ((LONG)pme->GetCp() > cpToBeCalcedTo)
                    {
                        BgRecalcInfo()->_yWait  = yHeight + yHeightView;
                        fWaitForCpToBeCalcedTo = FALSE;
                    }
                }

                else if (yHeightDisplay > YWait())
                {
                    fDone = FALSE;
                    break;
                }
            }

            // When doing a full min pass, just calculate the islands around aligned
            // objects. Note that this still calc's the lines around right aligned
            // images, which isn't really necessary because they are willing to
            // overlap text. Fix it next time.
            if ((uiMode & MEASURE_MINWIDTH) &&
                !RecalcLinePtr._marginInfo._xLeftMargin &&
                !RecalcLinePtr._marginInfo._xRightMargin )
                pme->AdvanceToNextAlignedObject();

        } while( pme->GetCp() < pme->GetLastCp());
    }

    _fRecalcDone = fDone;

    if(fDone && pliNew)
    {
        // This assert doesn't hold when page breaking so avoid it in that case.
        Assert(fDoBreaking ||  pme->_li == *pliNew);

        if (   GetFlowLayout()->IsEditable() // if we are in design mode
            && (   pme->_li._fHasEOP
                || pme->_li._fHasBreak
                || pme->_li._fSingleSite
               )
           )
        {
            Assert(pliNew == RecalcLinePtr[iLine]);
            CreateEmptyLine(pme, &RecalcLinePtr, &yHeight, pme->_li._fHasEOP );

            // Creating the line could have reallocated the memory to which pliNew points,
            // so we need to refresh the pointer just in case.
            pliNew = RecalcLinePtr[iLine];
        }

        // fix for bug 16519
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        // In table cells, Netscape actually adds the interparagraph spacing
        // for any closed tags to the height of the table cell.
        // NOTE: This actually applies the spacing to all nested text containers, not just
        //         table cells. Is this correct? (brendand).
        // It's not correct to add the spacing at all, but given that Netscape
        // has done so, and that they will probably do so for floating block
        // elements. Arye.
        else if (!pLayoutContext)   //  check for !pLayoutContext added (bug # 91086; # 102747) 
                                    //  Do Netscape compatibility dances only in browse mode. 
        {
            int iLineLast = iLine;
            
            // we need to force scrolling when bottom-margin is set on the last block tag
            // in body. (20400)

            while (iLineLast-- > 0 &&   // Lines available
                   !pliNew->_fForceNewLine)   // Just a dummy line.
                --pliNew;
            if (iLineLast > 0 || pliNew->_fForceNewLine)
                _yBottomMargin += RecalcLinePtr.NetscapeBottomMargin(pme);
        }
    }

    if (!(uiMode & MEASURE_MAXWIDTH))
    {
        xMaxLineWidth = CalcDisplayWidth();
    }

    _dcpCalcMax = (LONG)pme->GetCp() - GetFirstCp();
    _yCalcMax   = 
    _yHeight    = yHeightDisplay;
    _yHeightMax = max(yHeightDisplay, yAlignDescent);
    _xWidth     = xMaxLineWidth;

    //
    // Fire a resize notification if the content size changed
    //  
    // fix for 52305, change to margin bottom affects the content size,
    // so we should fire a resize.
    //
    if(     _yHeight    != yHeightOld
        ||  _yHeightMax + _yBottomMargin != yHeightMaxOld + yBottomMarginOld
        ||  _xWidth     != xWidthOld)
    {
        fViewChanged = TRUE;
    }

    {
        BOOL fAlignedLayouts =    RecalcLinePtr._cLeftAlignedLayouts
                               || (RecalcLinePtr._cRightAlignedLayouts > 1);
        if(pxMinLineWidth)
        {
            // We don't need min pass during calcsize in case of vertical layout flow.
            pFlowLayout->MarkHasAlignedLayouts(fAlignedLayouts && !GetFlowLayout()->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow());
        }
        if (fAlignedLayouts)
            _fNoContent = FALSE;
    }

    // If the view or size changed, re-size or update scrollbars as appropriate
    if ( fViewChanged || _fHasMultipleTextNodes || pci->_fNeedToSizeContentDispNode)
    {
        if (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        {
            pci->_fNeedToSizeContentDispNode = FALSE;
            pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

            // If our contents affects our size, ask our parent to initiate a re-size
            if ( fViewChanged )
                ElementResize(pFlowLayout, FALSE);
        }
        else if ( pci->_smMode == SIZEMODE_MMWIDTH )
        {
            // We don't resize dispnodes in minmax mode, but we want to
            // do it next time, so light up a flag (ugh..).  (IE6 #73601)
            // (dmitryt): this hack actually workarounds the fact that CFlowLayout::CalcTextSize
            // sets the display width (calling SetViewSize) but sometimes skips to update the
            // size of content dispnode - if it choose the codepath with RecalcLineShift.
            // This was happening when after minmax pass (no optimization, go through RecalcLines)
            // we failed to update dispnode on normal pass (optimization, just call to 
            // RecalcLineShift) so someone invented this flag in pci to trigger updating on the 
            // next Normal pass. How it should be done: we should update content dispnode in 
            // the end of CalcTextSize instead of in text calc code and also after each 
            // CDisplay::SetViewSize()/Recalc...() pair. then this falg can be thrown away.
            // Not doing this before shipping Whistler because of risk involved.
            pci->_fNeedToSizeContentDispNode = TRUE;
        }
    }

    if (fNormalMode)
    {
        // Update display nodes for affected relative positioned lines
        if (pFlowLayout->_fContainsRelative)
            UpdateRelDispNodeCache(NULL);

        pFlowLayout->NotifyMeasuredRange(GetFlowLayoutElement()->GetFirstCp(), GetMaxCpCalced());
    }

    if (    !pci->_fCloneDispNode 
        ||  fNormalMode )
    {
        AdjustDispNodes(NULL /*pdnLastUnchanged*/, pme->_pDispNodePrev, NULL/*pled*/);
    }

    PerfDbgLog1(tagRecalc, this, "CDisplay::RecalcLine() - Done. Recalced down to line #%d", LineCount());

    if(!fDone)                      // if not done, do rest in background
    {
        StartBackgroundRecalc(pci->_grfLayout);
    }
    else if (fAllowBackgroundRecalc)
    {
        Assert((!CanHaveBgRecalcInfo() || BgRecalcInfo()) && "Should have a BgRecalcInfo");
        if (HasBgRecalcInfo())
        {
            CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
            pBgRecalcInfo->_yWait = -1;
            pBgRecalcInfo->_cpWait = -1;
        }
#if DBG==1
        if (!(uiMode & MEASURE_MINWIDTH))
            CheckLineArray();
#endif
        _fLineRecalcErr = FALSE;

        RecalcMost();
    }

    // cache min/max only if there are no sites inside !
    if (pxMinLineWidth)
    {
        Assert(!!pme->_fHasNestedLayouts == !!pFlowLayout->ContainsNonHiddenChildLayout());
        if (!pme->_fHasNestedLayouts)
        {
            _xMaxWidth      = _xWidth + GetCaret();
            _fMinMaxCalced  = TRUE;
        }
    }

    // adjust for caret only when are calculating for MMWIDTH or MINWIDTH
    if (pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH)
    {
        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _xMinWidth = max(_xMinWidth, RecalcLinePtr._xMaxRightAlign);
            _xWidth = max(_xWidth, RecalcLinePtr._xMaxRightAlign);
        }
        _xMinWidth      += GetCaret();  // adjust for caret only when are calculating for MMWIDTH
    }

    // NETSCAPE: If there is no text or special characters, treat the site as
    //           empty. For example, with an empty BLOCKQUOTE tag, _xWidth will
    //           not be zero while the site should be considered empty.
    if(_fNoContent)
    {
        _xWidth =
        _xMinWidth = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
    }

    return TRUE;

err:
    TraceTag((tagError, "CDisplay::RecalcLines() failed"));

    if(!_fLineRecalcErr)
    {
        _dcpCalcMax   = pme->GetCp() - GetFirstCp();
        _yCalcMax = yHeightDisplay;
    }

    return FALSE;
}

/*
 *  CDisplay::RecalcLines(cpFirst, cchOld, cchNew, fBackground, pled)
 *
 *  @mfunc
 *      Recompute line breaks after text modification
 *
 *  @rdesc
 *      TRUE if success
 */


BOOL CDisplay::RecalcLines (
    CCalcInfo * pci,
    LONG cpFirst,               //@parm Where change happened
    LONG cchOld,                //@parm Count of chars deleted
    LONG cchNew,                //@parm Count of chars added
    BOOL fBackground,           //@parm This method called as background process
    CLed *pled,                 //@parm Records & returns impact of edit on lines (can be NULL)
    BOOL fHack)                 //@parm This comes from WaitForRecalc ... don't mess with BgRecalcInfo
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRecalcLines())
        return FALSE;
#endif

    AssertSz(   pci->GetLayoutContext() == NULL 
            ||  pci->GetLayoutContext()->ViewChain() == NULL
            ||  !GetFlowLayout()->ElementCanBeBroken(), 
        "This function should not be called for pagination");

    CSaveCalcInfo       sci(pci);
    CElement::CLock     Lock(GetFlowLayoutElement(), CElement::ELEMENTLOCK_RECALC);

    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementContent  = pFlowLayout->ElementContent();

    LONG        cchEdit;
    LONG        cchSkip = 0;
    INT         cliBackedUp = 0;
    LONG        cliWait = g_cExtraBeforeLazy;
    BOOL        fDone = TRUE;
    BOOL        fFirstInPara = TRUE;
    BOOL        fAllowBackgroundRecalc;
    CLed        led;
    LONG        lT = 0;         // long Temporary
    
    CLineCore * pliNew;
    CLinePtr    rpOld(this);
    CLineCore * pliCur;
    
    LONG        xWidth;
    LONG        yHeight, yAlignDescent=0;
    LONG        cpLast = GetLastCp();
    long        cpLayoutFirst = GetFirstCp();
    UINT        uiFlags = MEASURE_BREAKATWORD;
    BOOL        fReplaceResult = TRUE;
    BOOL        fTryForMatch = TRUE;
    BOOL        fNeedToBackUp = TRUE;
    int         diNonBlankLine = -1;
    int         iOldLine;
    int         iNewLine;
    int         iLinePrev = -1;
    int         iMinimumLinesToRecalc = 4;   // Guarantee some progress
    LONG        yHeightDisplay = 0;
    LONG        yHeightMax;
    CLineArray  aryNewLines;
    CDispNode * pDNBefore;
    CDispNode * pdnLastUnchanged = NULL;
    long        yHeightPrev;
    long        yBottomMarginOld = _yBottomMargin;
    BOOL        fLayoutDescentChanged = FALSE;
    BOOL        yLayoutDescent;

#if DBG==1
    LONG        cp;
#endif

    if (!pFlowLayout->ElementOwner()->IsInMarkup())
    {
        return TRUE;
    }

    SwitchesBegTimer(SWITCHES_TIMER_RECALCLINES);

    // we should not be measuring hidden stuff.
    Assert(!pFlowLayout->ElementOwner()->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext())));

    // If no lines, this routine should not be called
    // Call the other RecalcLines above instead !
    Assert(LineCount() > 0);

    ClearStoredRFEs();

    // Set up the CCalcInfo to the correct mode and parent size
    if (pci->_smMode == SIZEMODE_SET)
    {
        pci->_smMode = SIZEMODE_NATURAL;
    }

    // Init measurer at cpFirst
    CLSMeasurer     me(this, cpFirst, pci);

    CRecalcLinePtr  RecalcLinePtr(this, pci);

    if (!me._pLS)
        goto err;

    if (!pled)
        pled = &led;

#if DBG==1
    if(cpFirst > GetMaxCpCalced())
        TraceTag((tagError, "cpFirst %ld, CalcMax %ld", cpFirst, GetMaxCpCalced()));

    AssertSz(cpFirst <= GetMaxCpCalced(),
        "CDisplay::RecalcLines Caller didn't setup RecalcLines()");
#endif

    // Determine if background recalc is allowed
    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci, fBackground);

    Assert(!fBackground || HasBgRecalcInfo());
    if (    !fBackground
        &&  !fHack
        &&  fAllowBackgroundRecalc)
    {
        if (SUCCEEDED(EnsureBgRecalcInfo()))
        {
            BgRecalcInfo()->_yWait  = pFlowLayout->GetClientBottom();
            BgRecalcInfo()->_cpWait = -1;
        }
        else
        {
            fAllowBackgroundRecalc = FALSE;
            AssertSz(FALSE, "CDisplay::RecalcLines - Could not create BgRecalcInfo");
        }
    }

    // Init line pointer on old CLineArray
    rpOld.RpSetCp(cpFirst, FALSE, FALSE);

    pliCur = rpOld.CurLine();

    while(pliCur->IsClear() ||
          (pliCur->IsFrame() && !pliCur->_fFrameBeforeText))
    {
        if(!rpOld.AdjustBackward())
            break;

        pliCur = rpOld.CurLine();
    }

    // If the current line has single site
    if(pliCur->_fSingleSite)
    {
        // If we are in the middle of the current line (some thing changed
        // in a table cell or 1d-div, or marquee)
        if(rpOld.RpGetIch() && rpOld.GetCchRemaining() != 0)
        {
            // we dont need to back up
            if(rpOld > 0 && rpOld[-1]._fForceNewLine)
            {
                fNeedToBackUp = FALSE;
                cchSkip = rpOld.RpGetIch();
            }
        }
    }

    iOldLine = rpOld;

    if(fNeedToBackUp)
    {
        if(!rpOld->IsBlankLine())
        {
            cchSkip = rpOld.RpGetIch();
            if(cchSkip)
                rpOld.RpAdvanceCp(-cchSkip);
        }

        // find the first previous non blank line, if the first non blank line
        // is a single site line or a line with EOP, we don't need to skip.
        while(rpOld + diNonBlankLine >= 0 &&
                rpOld[diNonBlankLine].IsBlankLine())
            diNonBlankLine--;

        // (srinib) - if the non text line does not have a line break or EOP, or
        // a force newline or is single site line and the cp at which the characters changed is
        // ambiguous, we need to back up.

        // if the single site line does not force a new line, we do need to
        // back up. (bug #44346)
        while(fNeedToBackUp)
        {
            LONG rpAtStartOfLoop;
            
            if (rpOld + diNonBlankLine >= 0)
            {
                pliCur = &rpOld[diNonBlankLine];
                if(!pliCur->_fSingleSite || !pliCur->_fForceNewLine || cchSkip == 0)
                {
                    // Skip past all the non text lines
                    while(diNonBlankLine++ < 0)
                        rpOld.AdjustBackward();

                    //TODO: (dmitryt, tracking bug 111969) 
                    //This whole loop should be cleaned up sometimes.
                    //The purpose of it is to go back as needed to find a point where to start
                    //recalc. It menas to skip all aligned sites, blank lines etc until we 
                    //find a normal text line. The code here is mostly historic and needs to
                    //be cleaned significantly (after 5.5)
                    
                    while(rpOld->IsClear() ||
                          (rpOld->IsFrame() && !rpOld->_fFrameBeforeText))
                    {
                        if(!rpOld.AdjustBackward())
                            break;
                    }

                    //Skip to the begining of the line
                    //(dmitryt) Check for 0 because RpAdvanceCp gets confused on Frame lines when cch==0
                    //that happens because it tries to skip those Frame lines but tries to guess
                    //direction of skipping looking at sign of cch, and this is ambiguous when cch==0
                    //and plain wrong here. 
                    cchSkip += rpOld.RpGetIch();
                    if(cchSkip != 0)    
                        rpOld.RpAdvanceCp(-rpOld.RpGetIch());
                    
                    rpAtStartOfLoop = rpOld;

                    // we want to skip all the lines that do not force a
                    // newline, so find the last line that does not force a new line.

                    //
                    // Also, back up in the following case:
                    // If we have moved the bullet down from the previous lines, then
                    // we should go calc those lines since they will cause us to have
                    // a bullet. (Bullets are transferred via a bit on the
                    // recalclineptr, so if we do not calc the previous lines then
                    // we will not light up the bit). Also, all the lines which
                    // transmitted the bullet bit down have to have the trasmit bit on.
                    //
                    long diTmpLine = -1;
                    long cchSkipTemp = 0;
                    while(   rpOld + diTmpLine >=0
                          && ((pliCur = &rpOld[diTmpLine]) != 0)
                          && (  !pliCur->_fForceNewLine
                              || pliCur->_fHasTransmittedLI
                             )
                         )
                    {
                        if(  !pliCur->IsBlankLine()
                           || pliCur->_fHasTransmittedLI
                          )
                        {
                            cchSkipTemp += pliCur->_cch;
                        }
                        diTmpLine--;
                    }

                    if(cchSkipTemp)
                    {
                        cchSkip += cchSkipTemp;
                        rpOld.RpAdvanceCp(-cchSkipTemp);
                    }
                }
                else
                    rpAtStartOfLoop = rpOld;
            }
            else
                rpAtStartOfLoop = rpOld;

            // back up further if the previous lines are either frames inserted
            // by aligned sites at the beginning of the line or auto clear lines
            while(   rpOld
                  && ((pliCur = &rpOld[-1]) != 0)
                  && (   pliCur->_fClearBefore          // frame line before the actual text or
                      || (   pliCur->IsFrame()
                          && pliCur->_fFrameBeforeText
                         )
                     )
                  && rpOld.AdjustBackward()
                 );

            // Setup ourselvs for the next pass thru this.
            diNonBlankLine = -1;
            fNeedToBackUp = rpAtStartOfLoop > rpOld;
        }
    }

    cliBackedUp = iOldLine - rpOld;

    // Need to get a running start.
    me.Advance(-cchSkip);
    RecalcLinePtr.InitPrevAfter(&me._fLastWasBreak, rpOld);

    cchEdit = cchNew + cchSkip;         // Number of chars affected by edit

    Assert(cchEdit <= GetLastCp() - long(me.GetCp()) );
    if (cchEdit > GetLastCp() - long(me.GetCp()))
    {
        // NOTE: (istvanc) this of course shouldn't happen (see assert above)!!!!!!!!
        cchEdit = GetLastCp() - me.GetCp();
    }

    // Determine whether we're on first line of paragraph
    if(rpOld > 0)
    {
        int iLastNonFrame = -1;

        // frames do not hold any info, so go back past all frames.
        while(rpOld + iLastNonFrame && (rpOld[iLastNonFrame].IsFrame() || rpOld[iLastNonFrame].IsClear()))
            iLastNonFrame--;
        if(rpOld + iLastNonFrame >= 0)
        {
            CLineCore *pliNew = &rpOld[iLastNonFrame];

            fFirstInPara = pliNew->IsNextLineFirstInPara();
        }
        else
        {
            // we are at the Beginning of a document
            fFirstInPara = TRUE;
        }
    }

    yHeight = YposFromLine(pci, rpOld, &yHeightDisplay);
    yAlignDescent = 0;

    // Update first-affected and pre-edit-match lines in pled
    pled->_iliFirst = rpOld;
    pled->_cpFirst  = pled->_cpMatchOld = me.GetCp();
    pled->_yFirst   = pled->_yMatchOld  = yHeight;

    //
    // In the presence of negative margins and negative line heights, its no
    // longer possible to verify the following statement (bug 28255).
    // I have also verified that it being negative does not cause any other
    // problems in the code that utilizes its value (SujalP).
    //
    // AssertSz(pled->_yFirst >= 0, "CDisplay::RecalcLines _yFirst < 0");

    PerfDbgLog2(tagRecalc, this, "Start recalcing from line #%d, cp=%d",
              pled->_iliFirst, pled->_cpFirst);

    // In case of error, set both maxes to where we are now
    _yCalcMax   = yHeight;
    _dcpCalcMax = me.GetCp() - cpLayoutFirst;

    //
    // find the display node the corresponds to cpStart
    //
    me._pDispNodePrev = pled->_iliFirst
                            ? GetPreviousDispNode(pled->_cpFirst, pled->_iliFirst)
                            : 0;
    pdnLastUnchanged = me._pDispNodePrev;


    // If we are past the requested area to recalc and background recalc is
    // allowed, then just go directly to background recalc.
    if (    fAllowBackgroundRecalc
        &&  yHeight > YWait()
        &&  (LONG) me.GetCp() > CPWait())
    {
        // Remove all old lines from here on
        Forget(rpOld.GetIRun(), -1);
        rpOld.RemoveRel(-1, AF_KEEPMEM);

        // Start up the background recalc
        StartBackgroundRecalc(pci->_grfLayout);
        pled->SetNoMatch();

        // Update the relative line cache.
        if (pFlowLayout->_fContainsRelative)
            UpdateRelDispNodeCache(NULL);

        // Adjust display nodes
        AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled);

        goto cleanup;
    }

    aryNewLines.Forget();
    aryNewLines.Clear(AF_KEEPMEM);
    pliNew = NULL;

    iOldLine = rpOld;
    RecalcLinePtr.Init((CLineArray *)this, iOldLine, &aryNewLines);

    // recalculate margins
    RecalcLinePtr.RecalcMargins(iOldLine, iOldLine, yHeight, 0);

    Assert ( cchEdit <= GetLastCp() - long(me.GetCp()) );

    if(iOldLine)
        RecalcLinePtr.SetupMeasurerForBeforeSpace(&me, yHeight);

    // The following loop generates new lines for each line we backed
    // up over and for lines directly affected by edit
    while(cchEdit > 0)
    {
        LONG iTLine;
        LONG cpTemp;
        pliNew = RecalcLinePtr.AddLine();       // Add one new line
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }

        // Stuff text into new line
        uiFlags &= ~MEASURE_FIRSTINPARA;
        uiFlags |= (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

        PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", me.GetCp());

        // measure can add lines for aligned sites
        iNewLine = iOldLine + aryNewLines.Count() - 1;

        // save the index of the new line to added
        iTLine = iNewLine;

#if DBG==1
        {
            // Just so we can see the  text.
            const TCHAR *pch;
            long cchInStory = (long)GetFlowLayout()->GetContentTextLength();
            long cp = (long)me.GetCp();
            long cchRemaining =  cchInStory - cp;
            CTxtPtr tp(GetMarkup(), cp);
            pch = tp.GetPch(cchRemaining);
#endif

        cpTemp = me.GetCp();

        if (cpTemp == pFlowLayout->GetContentLastCp() - 1)
        {
            uiFlags |= MEASURE_EMPTYLASTLINE;
        }

        //
        // Cache the previous dispnode to insert a new content node
        // if the next line measured has negative margins(offset) which
        // causes the next line on top of the previous lines.
        //
        pDNBefore = me._pDispNodePrev;
        iLinePrev = iNewLine;
        yHeightPrev = yHeight;

        if (!RecalcLinePtr.MeasureLine(me, uiFlags,
                                       &iNewLine, &yHeight, &yAlignDescent,
                                       NULL, NULL
                                       ))
        {
            goto err;
        }

        //
        // iNewLine returned is the last text line inserted. There ay be
        // aligned lines and clear lines added before and after the
        // text line
        //
        pliNew = iNewLine >=0 ? RecalcLinePtr[iNewLine] : NULL;
        Assert(me._li == *pliNew);
        fFirstInPara = (iNewLine >= 0)
                            ? me._li.IsNextLineFirstInPara()
                            : TRUE;
        _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);

#if DBG==1
        }
#endif
        // fix for bug 16519 (srinib)
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        if (iNewLine >= 0)
        {
            HandleNegativelyPositionedContent(&me._li, &me, pDNBefore, iLinePrev, yHeightPrev);
        }

        // If we have added any clear lines, iNewLine points to a textline
        // which could be < iTLine
        if(iNewLine >= iTLine)
            cchEdit -= me.GetCp() - cpTemp;

        if(cchEdit <= 0)
            break;

        --iMinimumLinesToRecalc;
        if(iMinimumLinesToRecalc < 0 &&
           fBackground && (GetTickCount() >= BgndTickMax())) // GetQueueStatus(QS_ALLEVENTS))
        {
            fDone = FALSE;                      // took too long, stop for now
            goto no_match;
        }

        if (    fAllowBackgroundRecalc
            &&  yHeight > YWait()
            &&  (LONG) me.GetCp() > CPWait()
            &&  cliWait-- <= 0)
        {
            // Not really done, just past region we're waiting for
            // so let background recalc take it from here
            fDone = FALSE;
            goto no_match;
        }
    }                                           // while(cchEdit > 0) { }

    PerfDbgLog1(tagRecalc, this, "Done recalcing edited text. Created %d new lines", aryNewLines.Count());

    // Edit lines have been exhausted.  Continue breaking lines,
    // but try to match new & old breaks

    while( (LONG) me.GetCp() < cpLast )
    {
        // Assume there are no matches to try for
        BOOL frpOldValid = FALSE;
        BOOL fChangedLineSpacing = FALSE;

        // If we run out of runs, then there is not match possible. Therefore,
        // we only try for a match as long as we have runs.
        if (fTryForMatch)
        {
            // We are trying for a match so assume that there
            // is a match after all
            frpOldValid = TRUE;

            // Look for match in old line break CArray
            lT = me.GetCp() - cchNew + cchOld;
            while (rpOld.IsValid() && pled->_cpMatchOld < lT)
            {
                if(rpOld->_fForceNewLine)
                    pled->_yMatchOld += rpOld->_yHeight;
                pled->_cpMatchOld += rpOld->_cch;

                BOOL fDone=FALSE;
                BOOL fSuccess = TRUE;
                while (!fDone)
                {
                    if( !rpOld.NextLine(FALSE,FALSE) )     // NextRun()
                    {
                        // No more line array entries so we can give up on
                        // trying to match for good.
                        fTryForMatch = FALSE;
                        frpOldValid = FALSE;
                        fDone = TRUE;
                        fSuccess = FALSE;
                    }
                    if (!rpOld->IsFrame() ||
                            (rpOld->IsFrame() && rpOld->_fFrameBeforeText))
                        fDone = TRUE;
                }
                if (!fSuccess)
                    break;
            }
        }

        // skip frame in old line array
        if (rpOld->IsFrame() && !rpOld->_fFrameBeforeText)
        {
            BOOL fDone=FALSE;
            while (!fDone)
            {
                if (!rpOld.NextLine(FALSE,FALSE))
                {
                    // No more line array entries so we can give up on
                    // trying to match for good.
                    fTryForMatch = FALSE;
                    frpOldValid = FALSE;
                    fDone = TRUE;
                }
                if (!rpOld->IsFrame())
                    fDone = TRUE;
            }
        }

        pliNew = aryNewLines.Count() > 0 ? aryNewLines.Elem(aryNewLines.Count() - 1) : NULL;

        // If perfect match, stop
        if(   frpOldValid
           && rpOld.IsValid()
           && pled->_cpMatchOld == lT
           && rpOld->_cch != 0
           && (   !rpOld->_fPartOfRelChunk  // lines do not match if they are a part of
               || rpOld->_fFirstFragInLine  // the previous relchunk (bug 48513 SujalP)
              )
           && pliNew
           && (pliNew->_fForceNewLine || pliNew->_fDummyLine)
           && (yHeight - pliNew->_yHeight > RecalcLinePtr._marginInfo._yBottomLeftMargin)
           && (yHeight - pliNew->_yHeight > RecalcLinePtr._marginInfo._yBottomRightMargin)
           && !RecalcLinePtr._fMoveBulletToNextLine
          )
        {
            BOOL fFoundMatch = TRUE;

            if(rpOld.oi()->_xLeftMargin || rpOld.oi()->_xRightMargin)
            {
                // we might have found a match based on cp, but if an
                // aligned site is resized to a smaller size. There might
                // be lines that used to be aligned to the aligned site
                // which are not longer aligned to it. If so, recalc those lines.
                RecalcLinePtr.RecalcMargins(iOldLine, iOldLine + aryNewLines.Count(), yHeight,
                                                rpOld.oi()->_yBeforeSpace);
                if(RecalcLinePtr._marginInfo._xLeftMargin != rpOld.oi()->_xLeftMargin ||
                    (rpOld.oi()->_xLeftMargin + rpOld->_xLineWidth +
                        RecalcLinePtr._marginInfo._xRightMargin) < pFlowLayout->GetMaxLineWidth())
                {
                    fFoundMatch = FALSE;
                }
            }

            // There are cases where we've matched characters, but want to continue
            // to recalc anyways. This requires us to instantiate a new measurer.
            if (   fFoundMatch 
                && !fChangedLineSpacing 
                && rpOld < LineCount() 
                && (   rpOld->_fFirstInPara 
                    || pliNew->_fHasEOP
                   )
               )
            {
                BOOL                  fInner;
                const CParaFormat *   pPF;
                CLSMeasurer           tme(this, me.GetCp(), pci);

                if (!tme._pLS)
                    goto err;

                if(pliNew->_fHasEOP)
                {
                    rpOld->_fFirstInPara = TRUE;
                }
                else
                {
                    rpOld->_fFirstInPara = FALSE;
                    rpOld->_fHasBulletOrNum = FALSE;
                }

                // If we've got a <DL COMPACT> <DT> line. For now just check to see if
                // we're under the DL.

                pPF = tme.CurrBranch()->GetParaFormat();

                fInner = SameScope(tme.CurrBranch(), pElementContent);

                if (pPF->HasCompactDL(fInner))
                {
                    // If the line is a DT and it's the end of the paragraph, and the COMPACT
                    // attribute is set.
                    fChangedLineSpacing = TRUE;
                }

                // Check to see if the line height is the same. This is necessary
                // because there are a number of block operations that can
                // change the prespacing of the next line.
                else
                {
                    UINT uiFlags = 0;
                    CSaveRLP saveRLP(&RecalcLinePtr);
                    
                    // We'd better not be looking at a frame here.
                    Assert (!rpOld->IsFrame());

                    // Make it possible to check the line space of the
                    // current line.
                    tme.InitLineSpace (&me, rpOld);

                    RecalcLinePtr.CalcInterParaSpace (&tme,
                            pled->_iliFirst + aryNewLines.Count() - 1, &uiFlags);

                    if (   rpOld.oi()->_yBeforeSpace != tme._li._yBeforeSpace
                        || rpOld->_fHasBulletOrNum != tme._li._fHasBulletOrNum
                       )
                    {
                        rpOld->_fHasBulletOrNum = tme._li._fHasBulletOrNum;

                        fChangedLineSpacing = TRUE;
                    }
                    tme.PseudoLineDisable();
                }
            }
            else
                fChangedLineSpacing = FALSE;


            if (fFoundMatch && !fChangedLineSpacing)
            {
                PerfDbgLog1(tagRecalc, this, "Found match with old line #%d", rpOld.GetLineIndex());
                pled->_iliMatchOld = rpOld;

                // Replace old lines by new ones
                lT = rpOld - pled->_iliFirst;
                rpOld = pled->_iliFirst;

                fReplaceResult = rpOld.Replace(lT, &aryNewLines);
                if (!fReplaceResult)
                {
                    Assert(FALSE);
                    goto err;
                }

                frpOldValid =
                    rpOld.SetRun( rpOld.GetIRun() + aryNewLines.Count(), 0 );

                aryNewLines.Forget();
                aryNewLines.Clear(AF_DELETEMEM);           // Clear aux array
                iOldLine = rpOld;

                // Remember information about match after editing
                Assert((cp = rpOld.GetCp() + cpLayoutFirst) == (LONG) me.GetCp());
                pled->_yMatchNew = yHeight;
                pled->_iliMatchNew = rpOld;
                pled->_cpMatchNew = me.GetCp();

                _dcpCalcMax = me.GetCp() - cpLayoutFirst;

                // Compute height and cp after all matches
                if( frpOldValid && rpOld.IsValid() )
                {
                    do
                    {
                        if(rpOld->_fForceNewLine)
                        {
                            yHeight += rpOld->_yHeight;
                            // fix for bug 16519
                            // Keep track of the line that contributes to the max height, ex: if the
                            // last lines top margin is negative.
                            if(yHeightDisplay < yHeight)
                                yHeightDisplay = yHeight;
                        }
                        else if(rpOld->IsFrame())
                        {
                            yAlignDescent = yHeight + rpOld->_yHeight;
                        }


                        _dcpCalcMax += rpOld->_cch;
                    }
                    // AlexPf:  This continues on far beyond the end of the page!
                    // We should bail out and insert a BREAK in the break table,
                    // And mark the rest of the pages dirty.
                    while( rpOld.NextLine(FALSE,FALSE) ); // NextRun()
                }

                // Make sure _dcpCalcMax is sane after the above update
                AssertSz(GetMaxCpCalced() <= cpLast,
                    "CDisplay::RecalcLines match extends beyond EOF");

                // We stop calculating here.Note that if _dcpCalcMax < size
                // of text, this means a background recalc is in progress.
                // We will let that background recalc get the arrays
                // fully in sync.
                AssertSz(GetMaxCpCalced() <= cpLast,
                        "CDisplay::Match less but no background recalc");

                if (GetMaxCpCalced() != cpLast)
                {
                    // This is going to be finished by the background recalc
                    // so set the done flag appropriately.
                    fDone = FALSE;
                }

                goto match;
            }
        }

        // Add a new line
        pliNew = RecalcLinePtr.AddLine();
        if (!pliNew)
        {
            Assert(FALSE);
            goto err;
        }

        PerfDbgLog1(tagRecalc, this, "Measuring new line from cp = %d", me.GetCp());

        // measure can add lines for aligned sites
        iNewLine = iOldLine + aryNewLines.Count() - 1;

        uiFlags = MEASURE_BREAKATWORD |
                    (yHeight == 0 ? MEASURE_FIRSTLINE : 0) |
                    (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

        if (long(me.GetCp()) == pFlowLayout->GetContentLastCp() - 1)
        {
            uiFlags |= MEASURE_EMPTYLASTLINE;
        }

        //
        // Cache the previous dispnode to insert a new content node
        // if the next line measured has negative margins(offset) which
        // causes the next line on top of the previous lines.
        //
        pDNBefore = me._pDispNodePrev;
        iLinePrev = iNewLine;
        yHeightPrev = yHeight;

        if (!RecalcLinePtr.MeasureLine(me, uiFlags,
                                 &iNewLine, &yHeight, &yAlignDescent,
                                 NULL, NULL
                                 ))
        {
            goto err;
        }

        // fix for bug 16519
        // Keep track of the line that contributes to the max height, ex: if the
        // last lines top margin is negative.
        if(yHeightDisplay < yHeight)
            yHeightDisplay = yHeight;

        //
        // iNewLine returned is the last text line inserted. There ay be
        // aligned lines and clear lines added before and after the
        // text line
        //
        pliNew = iNewLine >=0 ? RecalcLinePtr[iNewLine] : NULL;
        Assert(me._li == *pliNew); 
        fFirstInPara = (iNewLine >= 0)
                            ? me._li.IsNextLineFirstInPara()
                            : TRUE;
        _fHasLongLine |= pliNew && (pliNew->_xWidth > SHRT_MAX);
        if (iNewLine >= 0)
        {
            HandleNegativelyPositionedContent(&me._li, &me, pDNBefore, iLinePrev, yHeightPrev);
        }

        --iMinimumLinesToRecalc;
        if(iMinimumLinesToRecalc < 0 &&
           fBackground &&  (GetTickCount() >= (DWORD)BgndTickMax())) // GetQueueStatus(QS_ALLEVENTS))
        {
            fDone = FALSE;          // Took too long, stop for now
            break;
        }

        if (    fAllowBackgroundRecalc
            &&  yHeight > YWait()
            &&  (LONG) me.GetCp() > CPWait()
            &&  cliWait-- <= 0)
        {                           // Not really done, just past region we're
            fDone = FALSE;          //  waiting for so let background recalc
            break;                  //  take it from here
        }
    }                               // while(me < cpLast ...

no_match:
    // Didn't find match: whole line array from _iliFirst needs to be changed
    // Indicate no match
    pled->SetNoMatch();

    // Update old match position with previous total height of the document so
    // that UpdateView can decide whether to invalidate past the end of the
    // document or not
    pled->_iliMatchOld = LineCount();
    pled->_cpMatchOld  = cpLast + cchOld - cchNew;
    pled->_yMatchOld   = _yHeightMax;

    // Update last recalced cp
    _dcpCalcMax = me.GetCp() - cpLayoutFirst;

    // Replace old lines by new ones
    rpOld = pled->_iliFirst;

    // We store the result from the replace because although it can fail the
    // fields used for first visible must be set to something sensible whether
    // the replace fails or not. Further, the setting up of the first visible
    // fields must happen after the Replace because the lines could have
    // changed in length which in turns means that the first visible position
    // has failed.
    fReplaceResult = rpOld.Replace(-1, &aryNewLines);
    if (!fReplaceResult)
    {
        Assert(FALSE);
        goto err;
    }
    aryNewLines.Forget();
    aryNewLines.Clear(AF_DELETEMEM);           // Clear aux array

    // Adjust first affected line if this line is gone
    // after replacing by new lines

    if(pled->_iliFirst >= LineCount() && LineCount() > 0)
    {
        Assert(pled->_iliFirst == LineCount());
        pled->_iliFirst = LineCount() - 1;
        Assert(!Elem(pled->_iliFirst)->IsFrame());
        pled->_yFirst -= Elem(pled->_iliFirst)->_yHeight;

        //
        // See comment before as to why its legal for this to be possible
        //
        //AssertSz(pled->_yFirst >= 0, "CDisplay::RecalcLines _yFirst < 0");
        pled->_cpFirst -= Elem(pled->_iliFirst)->_cch;
    }

match:
    
    pled->_yExtentAdjust = max(abs(_yMostNeg), abs(_yMostPos));

    // If there is a background on the paragraph, we have to make sure to redraw the
    // lines to the end of the paragraph.
    for (;pled->_iliMatchNew < LineCount();)
    {
        pliNew = Elem(pled->_iliMatchNew);
        if (pliNew)
        {
            if (!pliNew->_fHasBackground)
                break;

            pled->_iliMatchOld++;
            pled->_iliMatchNew++;
            pled->_cpMatchOld += pliNew->_cch;
            pled->_cpMatchNew += pliNew->_cch;
            me.Advance(pliNew->_cch);
            if (pliNew->_fForceNewLine)
            {
                pled->_yMatchOld +=  pliNew->_yHeight;
                pled->_yMatchNew +=  pliNew->_yHeight;
            }
            if (pliNew->_fHasEOP)
                break;
        }
        else
            break;
    }

    _fRecalcDone = fDone;
    _yCalcMax = yHeightDisplay;

    PerfDbgLog1(tagRecalc, this, "CDisplay::RecalcLine(tpFirst, ...) - Done. Recalced down to line #%d", LineCount() - 1);

    if (HasBgRecalcInfo())
    {
        CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
        // Clear wait fields since we want caller's to set them up.
        pBgRecalcInfo->_yWait = -1;
        pBgRecalcInfo->_cpWait = -1;
    }

    // We've measured the last line in the document. Do we want an empty lne?
    if ((LONG)me.GetCp() == cpLast)
    {
        LONG ili = LineCount() - 1;
        long lPadding[SIDE_MAX];

        //
        // Update the padding once we measure the last line
        //
        GetPadding(pci, lPadding);
        _yBottomMargin = lPadding[SIDE_BOTTOM];

        // If we haven't measured any lines (deleted an empty paragraph),
        // we need to get a pointer to the last line rather than using the
        // last line measured.
        while (ili >= 0)
        {
            pliNew = Elem(ili);
            if(pliNew->IsTextLine())
                break;
            else
                ili--;
        }

        // If the last line has a paragraph break or we don't have any
        // line any more, we need to create a empty line only if we are in design mode
        if (    LineCount() == 0
            ||  (   GetFlowLayout()->IsEditable()
                &&  pliNew
                &&  (   pliNew->_fHasEOP
                    ||  pliNew->_fHasBreak
                    ||  pliNew->_fSingleSite)))
        {
            // Only create an empty line after a table (at the end
            // of the document) if the table is completely loaded.
            if (pliNew == NULL ||
                !pliNew->_fSingleSite ||
                me._pRunOwner->Tag() != ETAG_TABLE ||
                DYNCAST(CTableLayout, me._pRunOwner)->IsCompleted())
            {
                RecalcLinePtr.Init((CLineArray *)this, 0, NULL);
                CreateEmptyLine(&me, &RecalcLinePtr, &yHeight,
                                pliNew ? pliNew->_fHasEOP : TRUE);
                // fix for bug 16519
                // Keep track of the line that contributes to the max height, ex: if the
                // last lines top margin is negative.
                if(yHeightDisplay < yHeight)
                    yHeightDisplay = yHeight;
            }
        }

        // In table cells, Netscape actually adds the interparagraph spacing
        // for any closed tags to the height of the table cell.
        // NOTE: This actually applies the spacing to all nested text containers, not just
        //         table cells. Is this correct? (brendand)
        // It's not correct to add the spacing at all, but given that Netscape
        // has done so, and that they will probably do so for floating block
        // elements. Arye.
        else
        {
            int iLineLast = ili;
            
            // we need to force scrolling when bottom-margin is set on the last block tag
            // in body. (bug 20400)

            // Only do this if we're the last line in the text site.
            // This means that the last line is a text line.
            if (iLineLast == LineCount() - 1)
            {
                while (iLineLast-- > 0 &&   // Lines available
                       !pliNew->_fForceNewLine)   // Just a dummy line.
                    --pliNew;
            }
            if (iLineLast > 0 || pliNew->_fForceNewLine)
            {
                _yBottomMargin += RecalcLinePtr.NetscapeBottomMargin(&me);
            }
        }
    }

    if (fDone)
    {
        RecalcMost();

        if(fBackground)
        {
            StopBackgroundRecalc();
        }
    }

    //
    // Update descent of the layout (descent of the last text line)
    //
    if (fDone)
    {
        if (    pFlowLayout->Tag() != ETAG_IFRAME
            && !pFlowLayout->ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
        {
            yLayoutDescent = 0;
            for (LONG i = Count() - 1; i >= 0; i--)
            {
                CLineCore * pli = Elem(i);
                if (pli && pli->IsTextLine())
                {
                    yLayoutDescent = pli->oi() ? pli->oi()->_yDescent : 0;
                    break;
                }
            }
            if (pFlowLayout->_yDescent != yLayoutDescent)
            {
                pFlowLayout->_yDescent = yLayoutDescent;
                fLayoutDescentChanged = TRUE;
            }
        }
        else
        {
            pFlowLayout->_yDescent = 0;
        }
    }

    xWidth = CalcDisplayWidth();
    yHeightMax = max(yHeightDisplay, yAlignDescent);

    Assert (pled);

    // If the size changed, re-size or update scrollbars as appropriate
    //
    // Fire a resize notification if the content size changed
    //  
    // fix for 52305, change to margin bottom affects the content size,
    // so we should fire a resize.
    //
    if (    yHeightMax + yBottomMarginOld != _yHeightMax + _yBottomMargin
        ||  yHeightDisplay != _yHeight
        ||  xWidth != _xWidth
        ||  fLayoutDescentChanged)
    {
        _xWidth       = xWidth;
        _yHeight      = yHeightDisplay;
        _yHeightMax   = yHeightMax;

        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));

        // If our contents affects our size, ask our parent to initiate a re-size
        ElementResize(pFlowLayout, fLayoutDescentChanged);
    }
    else if (_fHasMultipleTextNodes)
    {
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));
    }

    // Update the relative line cache.
    if (pFlowLayout->_fContainsRelative)
        UpdateRelDispNodeCache(pled);

    // Adjust display nodes
    AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled); 

    pFlowLayout->NotifyMeasuredRange(pled->_cpFirst, me.GetCp());

    if (pled->_cpMatchNew != MAXLONG && (pled->_yMatchNew - pled->_yMatchOld))
    {
        CSize size(0, pled->_yMatchNew - pled->_yMatchOld);

        pFlowLayout->NotifyTranslatedRange(size, pled->_cpMatchNew, cpLayoutFirst + _dcpCalcMax);
    }

    // If not done, do the rest in background
    if(!fDone && !fBackground)
        StartBackgroundRecalc(pci->_grfLayout);

    if(fDone)
    {
        CheckLineArray();
        _fLineRecalcErr = FALSE;
    }

cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_RECALCLINES);

    return TRUE;

err:
    if(!_fLineRecalcErr)
    {
        _dcpCalcMax = me.GetCp() - cpLayoutFirst;
        _yCalcMax   = yHeightDisplay;
        _fLineRecalcErr = FALSE;            //  fix up CArray & bail
    }

    TraceTag((tagError, "CDisplay::RecalcLines() failed"));

    pled->SetNoMatch();

    if(!fReplaceResult)
    {
        FlushRecalc();
    }

    // Update the relative line cache.
    if (pFlowLayout->_fContainsRelative)
        UpdateRelDispNodeCache(pled);

    // Adjust display nodes
    AdjustDispNodes(pdnLastUnchanged, me._pDispNodePrev, pled);

    return FALSE;
}

/*
 *  CDisplay::UpdateView(&tpFirst, cchOld, cchNew, fRecalc)
 *
 *  @mfunc
 *      Recalc lines and update the visible part of the display
 *      (the "view") on the screen.
 *
 *  @devnote
 *      --- Use when in-place active only ---
 *
 *  @rdesc
 *      TRUE if success
 */
BOOL CDisplay::UpdateView(
    CCalcInfo * pci,
    LONG cpFirst,   //@parm Text ptr where change happened
    LONG cchOld,    //@parm Count of chars deleted
    LONG cchNew)   //@parm No recalc need (only rendering change) = FALSE
{
    BOOL            fReturn = TRUE;
    BOOL            fNeedViewChange = FALSE;
    RECT            rcView;
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CRect           rc;
    long            xWidthParent;
    long            yHeightParent;

    BOOL fInvalAll = FALSE;
    CStackDataAry < RECT, 10 > aryInvalRects(Mt(CDisplayUpdateView_aryInvalRects_pv));

    Assert(pci);

    if (_fNoUpdateView)
        return fReturn;

    // If we have no width, don't even try to recalc, it causes
    // crashes in the scrollbar code, and is just a waste of
    // time, anyway.
    // However, since we're not sized, request sizing from the parent
    // of the ped (this will leave the necessary bread-crumb chain
    // to ensure we get sized later) - without this, not all containers
    // of text sites (e.g., 2D sites) will know to size the ped.
    // (This is easier than attempting to propagate back out that sizing
    //  did not occur.)

    if (    GetViewWidth() <= 0
        && !pFlowLayout->_fContentsAffectSize)
    {
        FlushRecalc();
        return TRUE;
    }


    pFlowLayout->GetClientRect((CRect *)&rcView);

    GetViewWidthAndHeightForChild(pci, &xWidthParent, &yHeightParent);

    pci->SizeToParent(xWidthParent, yHeightParent);

    if (!LineCount())
    {
        // No line yet, recalc everything
        RecalcView(pci, TRUE);

        // Invalidate entire view rect
        fInvalAll = TRUE;
        fNeedViewChange = TRUE;
    }
    else
    {
        CLed            led;

        if( cpFirst > GetMaxCpCalced())
        {
            // we haven't even calc'ed this far, so don't bother with updating
            // here.  Background recalc will eventually catch up to us.
            return TRUE;
        }

        AssertSz(cpFirst <= GetMaxCpCalced(),
                 "CDisplay::UpdateView(...) - cpFirst > GetMaxCpCalced()");

        if (!RecalcLines(pci, cpFirst, cchOld, cchNew, FALSE, &led))
        {
            // we're in deep trouble now, the recalc failed
            // let's try to get out of this with our head still mostly attached
            fReturn = FALSE;
            fInvalAll = TRUE;
            fNeedViewChange = TRUE;
        }

        if (!fInvalAll)
        {
            // Invalidate all the individual rectangles necessary to work around
            // any embedded images. Also, remember if this was a simple or a complex
            // operation so that we can avoid scrolling in difficult places.
            CLineCore * pLine;
            CLineOtherInfo * ploi;
            int     iLine, iLineLast;
            long    xLineLeft, xLineRight, yLineTop, yLineBottom;
            long    yTop;
            long    dy = led._yMatchNew - led._yMatchOld;
            BOOL    fNextToALeftAlignedLine = FALSE;
            BOOL    fNextToARightAlignedLine = FALSE;

            // Start out with a zero area rectangle.
            // NOTE(SujalP): _yFirst can legally be less than 0. Its OK, because
            // the rect we are constructing here is going to be used for inval purposes
            // only and that is going to clip it to the content rect of the flowlayout.
            yTop      =
            rc.bottom =
            rc.top    = led._yFirst;
            rc.left   = MAXLONG;
            rc.right  = 0;

            // Need this to adjust for negative line heights.
            // Note that this also initializes the counter for the
            // for loop just below.
            iLine = led._iliFirst;

            // Accumulate rectangles of lines and invalidate them.
            iLineLast = min(led._iliMatchNew, LineCount());

            // Invalidate only the lines that have been touched by the recalc
            for (; iLine < iLineLast; iLine++)
            {
                pLine = Elem(iLine);
                ploi = pLine->oi();
                
                if (pLine == NULL || ploi == NULL)
                    break;

                if (ploi->_xLeftMargin == 0)
                    fNextToALeftAlignedLine = FALSE;
                if (ploi->_xRightMargin == 0)
                    fNextToARightAlignedLine = FALSE;

                // Get the left and right edges of the line.
                xLineLeft  = fNextToALeftAlignedLine ? ploi->_xLeft : ploi->_xLeftMargin;
                xLineRight = xLineLeft + pLine->_xLineWidth 
                                + (fNextToALeftAlignedLine ? ploi->_xLeftMargin : 0)
                                + (fNextToARightAlignedLine ? ploi->_xRightMargin : 0);

                // Get the top and bottom edges of the line
                yLineTop    = yTop + pLine->GetYLineTop(ploi) - led._yExtentAdjust;
                yLineBottom = yTop + pLine->GetYLineBottom(ploi) + led._yExtentAdjust;

                if (pLine->IsFrame())
                {
                    //
                    // If a left algined line is in the invalidation region then the lines
                    // next to it should invalidate the left margin also, since the left
                    // aligned image could be shorter than the lines next to it. Also this
                    // is no more expensive since we do this only if the aligned line is
                    // invl'd ... i.e. if the line were next to an inval line, we will
                    // inval an already invalidated region. If the line next to the aligned
                    // image were tall and hence part of it was next to the empty space
                    // below the aligned object, then this code will serve to inval that
                    // region -- which would be the right thing to do. Note that we do not
                    // inval the margin region if the aligned line was not inval'd. Note
                    // we cleanup the flag once we are passed all align objects (when
                    // _xLeftMargin goes to 0. (See bug 101624).
                    // 
                    if (pLine->_fLeftAligned)
                        fNextToALeftAlignedLine = TRUE;
                    else if (pLine->_fRightAligned)
                        fNextToARightAlignedLine = TRUE;

                    //
                    // NOTE: (SujalP) This is necessary only if height kerning is turned on.
                    // What happens is that the line for the floated character could get shorter
                    // (character 'A' is replaced by character 'a') causing us to not invalidate
                    // enough height to erase the 'A'. This is not a problem when there are floated
                    // images which reduce in height, since *they* are smart enough to inval 
                    // their before rect. In the current scheme of things, the display never 
                    // does *any* invalidation based on their previous heights. Hence, we inval
                    // the full height of he display over here. The correct height to inval is
                    // just the pre-kerned height, but that is needlessly complex at this point.
                    //
                    if (ploi->_fHasFloatedFL)
                    {
                        yLineBottom = rcView.bottom;
                    }
                }
                
                // First line of a new rectangle
                if (rc.right < rc.left)
                {
                    rc.left  = xLineLeft;
                    rc.right = xLineRight;
                }

                // Different margins, output the old one and restart.
                else if (rc.left != xLineLeft || rc.right != xLineRight)
                {
                    // if we have multiple chunks in the same line
                    if( rc.right  == xLineLeft &&
                        rc.top    == yLineTop  &&
                        rc.bottom == yLineBottom )
                    {
                        rc.right = xLineRight;
                    }
                    else
                    {
                        IGNORE_HR(aryInvalRects.AppendIndirect(&rc));

                        fNeedViewChange = TRUE;

                        // Zero height.
                        rc.top    =
                        rc.bottom = yTop;

                        // Just the width of the given line.
                        rc.left  = xLineLeft;
                        rc.right = xLineRight;
                    }
                }

                // Negative line height.
                rc.top = min(rc.top, yLineTop);

                rc.bottom = max(rc.bottom, yLineBottom);

                // Otherwise just accumulate the height.
                if(pLine->_fForceNewLine)
                {
                    yTop  += pLine->_yHeight;

                    // Stop when reaching the bottom of the visible area
                    if (rc.bottom > rcView.bottom)
                        break;
                }
            }

// BUBUG (srinib) - This is a temporary hack to handle the
// scrolling case until the display tree provides the functionality
// to scroll an rc in view. If the new content height changed then
// scroll the content below the change by the dy. For now we are just
// to the end of the view.
            if(dy)
            {
                rc.left   = rcView.left;
                rc.right  = rcView.right;
                rc.bottom = rcView.bottom;
            }

            // Get the last one.
            if (rc.right > rc.left && rc.bottom > rc.top)
            {
                IGNORE_HR(aryInvalRects.AppendIndirect(&rc));
                fNeedViewChange = TRUE;
            }

            // There might be more stuff which has to be
            // invalidated because of lists (numbers might change etc)
            if (UpdateViewForLists(&rcView,   cpFirst,
                                   iLineLast, rc.bottom, &rc))
            {
                IGNORE_HR(aryInvalRects.AppendIndirect(&rc));
                fNeedViewChange = TRUE;
            }

            if (    led._yFirst >= rcView.top
                &&  (   led._yMatchNew <= rcView.bottom
                    ||  led._yMatchOld <= rcView.bottom))
            {
                WaitForRecalcView(pci);
            }
        }
    }

    {
        // Now do the invals
        if (fInvalAll)
        {
            pFlowLayout->Invalidate();
        }
        else
        {
            pFlowLayout->Invalidate(&aryInvalRects[0], aryInvalRects.Size());
        }
    }

    if (fNeedViewChange)
    {
        pFlowLayout->ViewChange(FALSE);
    }

    CheckView();

#ifdef DBCS
    UpdateIMEWindow();
#endif

    return fReturn;
}

/*
 *  CDisplay::CalcDisplayWidth()
 *
 *  @mfunc
 *      Computes and returns width of this display by walking line
 *      CArray and returning the widest line.  Used for
 *      horizontal scroll bar routines
 *
 *  @todo
 *      This should be done by a background thread
 */

LONG CDisplay::CalcDisplayWidth ()
{
    LONG    ili = LineCount();
    CLineCore * pli;
    CLineOtherInfo *ploi;
    LONG    xWidth = 0;
    CLineInfoCache *pLineCache = TLS(_pLineInfoCache);
    
    if(ili)
    {
        // Note: pli++ breaks array encapsulation (pli = &(*this)[ili] doesn't)
        pli = Elem(0);
        for(xWidth = 0; ili--; pli++)
        {
            ploi = pli->oi(pLineCache);
            
            // calc line width based on the direction
            LONG cx = pli->GetTextRight(ploi, ili == 0) + pli->_xRight;

            if(IsRTLDisplay())
            {
                // Negative shift means overflow. 
                // Remove the saved shift to get line's desired width.
                cx -= ploi->_xNegativeShiftRTL;
            }
            
            xWidth = max(xWidth, cx);
        }
    }

    return xWidth;
}


/*
 *  CDisplay::StartBackgroundRecalc()
 *
 *  @mfunc
 *      Starts background line recalc (at _dcpCalcMax position)
 *
 *  @todo
 *      ??? CF - Should use an idle thread
 */
void CDisplay::StartBackgroundRecalc(DWORD grfLayout)
{
    // We better be in the middle of the job here.
    Assert (LineCount() > 0);

    Assert(CanHaveBgRecalcInfo());

    // StopBack.. kills the recalc task, *if it exists*
    StopBackgroundRecalc () ;

    EnsureBgRecalcInfo();

#if DBG == 1
    _pFL->_pDocDbg->_fUsingBckgrnRecalc = TRUE;
#endif

    if(!RecalcTask() && GetMaxCpCalced() < GetLastCp())
    {
        BgRecalcInfo()->_pRecalcTask = new CRecalcTask (this, grfLayout) ;
        if (RecalcTask())
        {
            _fRecalcDone = FALSE;
        }
        // TODO: (sujalp, tracking bug 111982): what to do if we fail on mem allocation?
    }
}


/*
 *  CDisplay::StepBackgroundRecalc()
 *
 *  @mfunc
 *      Steps background line recalc (at _dcpCalcMax position)
 *      Called by timer proc
 *
 *  @todo
 *      ??? CF - Should use an idle thread
 */
VOID CDisplay::StepBackgroundRecalc (DWORD dwTimeOut, DWORD grfLayout)
{
    LONG cch = GetLastCp() - (GetMaxCpCalced());

    // don't try recalc when processing OOM or had an error doing recalc or
    // if we are asserting.
    if(_fInBkgndRecalc || _fLineRecalcErr || GetFlowLayout()->IsDirty())
    {
#if DBG==1
        if(_fInBkgndRecalc)
            PerfDbgLog(tagRecalc, this, "avoiding reentrant background recalc");
        else if (_fLineRecalcErr)
            PerfDbgLog(tagRecalc, this, "OOM: not stepping recalc");
#endif
        return;
    }

    _fInBkgndRecalc = TRUE;

    // Background recalc is over if no more characters or we are no longer
    // active.
    if(cch <= 0)
    {
        if (RecalcTask())
        {
            StopBackgroundRecalc();
        }

        CheckLineArray();

        goto Cleanup;
    }

    {
        CFlowLayout *   pFlowLayout = GetFlowLayout();
        CElement    *   pElementFL = pFlowLayout->ElementOwner();
        LONG            cp = GetMaxCpCalced();

        if (!pElementFL->IsDisplayNone(LC_TO_FC(pFlowLayout->LayoutContext())))
        {
            CFlowLayout::CScopeFlag  csfCalcing(pFlowLayout);

            CCalcInfo   CI;
            CLed        led;
            long        xParentWidth;
            long        yParentHeight;

            pFlowLayout->OpenView();

            // Setup the amount of time we have this time around
            Assert(BgRecalcInfo() && "Supposed to have a recalc info in stepbackgroundrecalc");
            BgRecalcInfo()->_dwBgndTickMax = dwTimeOut ;

            CI.Init(pFlowLayout);
            GetViewWidthAndHeightForChild(
                &CI,
                &xParentWidth,
                &yParentHeight,
                CI._smMode == SIZEMODE_MMWIDTH);
            CI.SizeToParent(xParentWidth, yParentHeight);

            CI._grfLayout = grfLayout;

            RecalcLines(&CI, cp, cch, cch, TRUE, &led);

#ifndef NO_ETW_TRACING
            // Send event to ETW if it is enabled by the shell.
            if (    g_pHtmPerfCtl 
                &&  (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) 
            {
                g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LAYOUTTASK,
                                       (TCHAR *)pFlowLayout->Doc()->GetPrimaryUrl());
            }
#endif

        }
        else
        {
            CNotification  nf;

            // Kill background recalc, if the layout is hidden
            StopBackgroundRecalc();

            // calc the rest by accumulating a dirty range.
            nf.CharsResize(GetMaxCpCalced(), cch, pElementFL->GetFirstBranch());
            GetMarkup()->Notify(&nf);
        }
    }

Cleanup:
    _fInBkgndRecalc = FALSE;

    return;
}


/*
 *  CDisplay::StopBackgroundRecalc()
 *
 *  @mfunc
 *      Steps background line recalc (at _dcpCalcMax position)
 *      Called by timer proc
 *
 */
VOID CDisplay::StopBackgroundRecalc()
{
    if (HasBgRecalcInfo())
    {
        if (RecalcTask())
        {
            RecalcTask()->Terminate () ;
            RecalcTask()->Release () ;
            _fRecalcDone = TRUE;
        }
        DeleteBgRecalcInfo();
    }
}

/*
 *  CDisplay::WaitForRecalc(cpMax, yMax, pDI)
 *
 *  @mfunc
 *      Ensures that lines are recalced until a specific character
 *      position or ypos.
 *
 *  @rdesc
 *      success
 */
BOOL CDisplay::WaitForRecalc(
    LONG cpMax,     //@parm Position recalc up to (-1 to ignore)
    LONG yMax,      //@parm ypos to recalc up to (-1 to ignore)
    CCalcInfo * pci) // @parm can be NULL.

{
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    BOOL            fReturn = TRUE;
    LONG            cch;
    CCalcInfo       CI;
 
    Assert(cpMax < 0 || (cpMax >= GetFirstCp() && cpMax <= GetLastCp()));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::WaitForRecalc cpMax=%d yMax=%d pci=%d,%d", cpMax, yMax, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0 ));

    CFlowLayout::CScopeFlag  csfCalcing(pFlowLayout);

    //
    //  Return immediately if hidden, already measured up to the correct point, or currently measuring
    //  or if there is no dispnode (ie haven't been CalcSize'd yet)

    if (pFlowLayout->IsDisplayNone())
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work done because display:none"));
        return fReturn;
    }

    if ( !pFlowLayout->GetElementDispNode() )
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work done because display:none"));
        return FALSE;
    }

    if (    yMax < 0
        &&  cpMax >= 0
        &&  cpMax <= GetMaxCpCalced()
        &&  (  !pFlowLayout->IsDirty()
            ||  pFlowLayout->IsRangeBeforeDirty(cpMax - pFlowLayout->GetContentFirstCp(), 0) ))
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - no work necessary"));
        return fReturn;
    }

    if (    pFlowLayout->TestLock(CElement::ELEMENTLOCK_RECALC)
        ||  pFlowLayout->TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS))
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc - aborting in middle of recalc/process reqs"));
        return FALSE;
    }

    //
    //  Calculate up through the request location
    //

    if(!pci)
    {
        CI.Init(pFlowLayout);
        pci = &CI;
    }

    pFlowLayout->CommitChanges(pci);

    if (    (   yMax < 0
            ||  yMax >= _yCalcMax)
        &&  (   cpMax < 0
            ||  cpMax > GetMaxCpCalced()))
    {
        cch = GetLastCp() - GetMaxCpCalced();
        if(cch > 0 || LineCount() == 0)
        {

            HCURSOR     hcur = NULL;
            CDoc *      pDoc = pFlowLayout->Doc();

            if (EnsureBgRecalcInfo() == S_OK)
            {
                CBgRecalcInfo * pBgRecalcInfo = BgRecalcInfo();
                Assert(pBgRecalcInfo && "Should have a BgRecalcInfo");
                pBgRecalcInfo->_cpWait = cpMax;
                pBgRecalcInfo->_yWait  = yMax;
            }

            if (pDoc && pDoc->State() >= OS_INPLACE)
            {
                hcur = SetCursorIDC(IDC_WAIT);
            }
            TraceTag((tagWarning, "Lazy recalc"));

            if(GetMaxCpCalced() == GetFirstCp() )
            {
                fReturn = RecalcLines(pci);
            }
            else
            {
                CLed led;

                fReturn = RecalcLines(pci, GetMaxCpCalced(), cch, cch, FALSE, &led, TRUE);
            }

            // Either we were not waiting for a cp or if we were, then we have been calcd to that cp
            Assert(cpMax < 0 || GetMaxCpCalced() >= cpMax);

            SetCursor(hcur);
        }
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::WaitForRecalc"));
    return fReturn;
}

/*
 *  CDisplay::WaitForRecalcIli
 *
 *  @mfunc
 *      Wait until line array is recalculated up to line <p ili>
 *
 *  @rdesc
 *      Returns TRUE if lines were recalc'd up to ili
 */


#pragma warning(disable:4702)   //  Ureachable code

BOOL CDisplay::WaitForRecalcIli (
    LONG ili,       //@parm Line index to recalculate line array up to
    CCalcInfo * pci)
{
    // TODO: (istvanc, dmitryt, track bug 111987) remove this function. 
    // It is used in 2 places to check if line index is less then line count (so no need
    // for actual calculation, it's a leftover)

    return ili < LineCount();
#if 0
    LONG cchGuess;

    while(!_fRecalcDone && ili >= LineCount())
    {
        cchGuess = 5 * (ili - LineCount() + 1) * Elem(0)->_cch;
        if(!WaitForRecalc(GetMaxCpCalced() + cchGuess, -1, pci))
            return FALSE;
    }
    return ili < LineCount();
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     WaitForRecalcView
//
//  Synopsis:   Calculate up through the bottom of the visible content
//
//  Arguments:  pci - CCalcInfo to use
//
//  Returns:    TRUE if all Ok, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::WaitForRecalcView(CCalcInfo * pci)
{
    return WaitForRecalc(-1, GetFlowLayout()->GetClientBottom(), pci);
}


#pragma warning(default:4702)   //  re-enable unreachable code

//===================================  View Updating  ===================================


/*
 *  CDisplay::SetViewSize(rcView)
 *
 *  Purpose:
 *      Set the view size 
 */
void CDisplay::SetViewSize(const RECT &rcView)
{
    _xWidthView  = rcView.right  - rcView.left;
    _yHeightView = rcView.bottom - rcView.top;
}

/*
 *  CDisplay::RecalcView
 *
 *  Sysnopsis:  Recalc view and update first visible line
 *
 *  Arguments:
 *      fFullRecalc - TRUE if recalc from first line needed, FALSE if enough
 *                    to start from _dcpCalcMax
 *
 *  Returns:
 *      TRUE if success
 */
BOOL CDisplay::RecalcView(CCalcInfo * pci, BOOL fFullRecalc)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::RecalcView P(%d,%d) full=%d", pci->_sizeParent.cx, pci->_sizeParent.cy, fFullRecalc ));

    CFlowLayout * pFlowLayout = GetFlowLayout();
    BOOL          fAllowBackgroundRecalc;

    // If we have no width, don't even try to recalc, it causes
    // crashes in the scrollbar code, and is just a waste of time
    if (GetViewWidth() <= 0 && !pFlowLayout->_fContentsAffectSize)
    {
        FlushRecalc();
        return TRUE;
    }

    fAllowBackgroundRecalc = AllowBackgroundRecalc(pci);

    // If a full recalc (from first line) is not needed
    // go from current _dcpCalcMax on
    if (!fFullRecalc)
    {
        return (fAllowBackgroundRecalc
                        ? WaitForRecalcView(pci)
                        : WaitForRecalc(GetLastCp(), -1, pci));
    }

    // Else do full recalc
    BOOL  fRet = TRUE;

    // If all that the element is likely to have is a single line of plain text,
    // use a faster mechanism to compute the lines. This is great for perf
    // of <INPUT>
    if (pFlowLayout->Tag() == ETAG_INPUT)
    {
        fRet = RecalcPlainTextSingleLine(pci);
    }
    else
    {
        // full recalc lines
        if(!RecalcLines(pci))
        {
            // we're in deep trouble now, the recalc failed
            // let's try to get out of this with our head still mostly attached
            fRet = FALSE;
            goto Done;
        }
    }
    CheckView();

Done:
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::RecalcView P(%d,%d) full=", pci->_sizeParent.cx, pci->_sizeParent.cy, fFullRecalc ));
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     CDisplay::RecalcLineShift
//
//  Synopsis:   Run thru line array and adjust line shift
//
//---------------------------------------------------------------


void CDisplay::RecalcLineShift(CCalcInfo * pci, DWORD grfLayout)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::RecalcLineShift P(%d,%d)", pci->_sizeParent.cx, pci->_sizeParent.cy ));

    CFlowLayout * pFlowLayout = GetFlowLayout();
    LONG        lCount = LineCount();
    LONG        ili;
    LONG        iliFirstChunk = 0;
    BOOL        fChunks = FALSE;
    CLineCore * pli;
    const CLineOtherInfo *ploi;
    CLineOtherInfo loi;
    long        xWidthMax = GetViewWidth();
    
    Assert (pFlowLayout->_fSizeToContent ||
            (_fMinMaxCalced && !pFlowLayout->ContainsNonHiddenChildLayout()));


    for(ili = 0, pli = Elem(0); ili < lCount; ili++, pli++)
    {
        ploi = pli->oi();
        
        // if the current line does not force a new line, then
        // find a line that forces the new line and distribute
        // width.

        if(!fChunks && !pli->_fForceNewLine && !pli->IsFrame())
        {
            iliFirstChunk = ili;
            fChunks = TRUE;
        }

        if(pli->_fForceNewLine)
        {
            long xShift = 0;
            long xNegativeShiftRTL = ploi->_xNegativeShiftRTL;

            if(!fChunks)
                iliFirstChunk = ili;
            else
                fChunks = FALSE;

            // calc shift if line is justified or if it is RTL 
            // (for RTL, we need to adjust _xRight and left overflow)
            long xRemainder = pli->_xRight;
            if (pli->_fJustified || pli->_fRTLLn)
            {
                // WARNING: Duplicate of the logic in ComputeLineShift.
                //          Make it a function if it gets any more complex than this!
                // NOTE: We do not want to include the width of the caret in justification
                // computation, else we will place text in the place reserved for the
                // caret. This was shown by bug #80765
                long xWidth = ploi->_xLeftMargin + CLineFull::CalcLineWidth(pli, ploi) 
                            + ploi->_xRightMargin /*+ GetCaret()*/;

                if(pli->_fJustified && long(pli->_fJustified) != JUSTIFY_FULL )
                {
                    // for pre whitespace is already include in _xWidth
                    xShift = xWidthMax - xWidth;

                    xShift = max(xShift, 0L);   // Don't allow alignment to go < 0 (unless RTL, see below)

                    if(long(pli->_fJustified) == JUSTIFY_CENTER)
                        xShift /= 2;
                }

                // In RTL display, negative shift occurs when a line is wider than display
                if (IsRTLDisplay())
                {
                    // If this line still doesn't fit, calcluate new negative shift
                    if (xWidthMax < xWidth)
                    {
                        // xShift is the different of desired effective shift and current shift
                        xShift = (xWidthMax - xWidth) - ploi->_xNegativeShiftRTL;

                        // New negative shift to be saved (it must be zero if it is not negative)
                        xNegativeShiftRTL = min(0L, xNegativeShiftRTL + xShift);
                    }
                    else if (xNegativeShiftRTL < 0)
                    {
                        // This line used to be too wide for the display, but now it fits.
                        // Increase the shift to remove current negative shift.
                        xShift -= xNegativeShiftRTL;
                        xNegativeShiftRTL = 0;
                    }
                }

                Assert((xNegativeShiftRTL == 0) || IsRTLDisplay()); //in LTR, this shift is always 0

                xRemainder = max(0L, pli->_xRight + xWidthMax - xWidth - xShift - xNegativeShiftRTL);
            }

            Assert(iliFirstChunk <= ili);
            
            while(iliFirstChunk <= ili)
            {
                pli = Elem(iliFirstChunk++);
                loi = *pli->oi();

                if (xShift)
                {
                    pli->ReleaseOtherInfo();
                    loi._xLeft += xShift;
                    loi._xNegativeShiftRTL = xNegativeShiftRTL;
                    pli->CacheOtherInfo(loi);
                }

                pli->_xRight = xRemainder;
                pli->_xLineWidth = CLineFull::CalcLineWidth(pli, &loi);
            }

            // line width will be at least xWidthMax
            if (pli->_xLineWidth < xWidthMax)
                pli->_xLineWidth = xWidthMax;
        }
    }

    // Update relative display nodes
    if (pFlowLayout->_fContainsRelative)
    {
        VoidRelDispNodeCache();
        UpdateRelDispNodeCache(NULL);
    }

    //
    // Nested layouts need to be repositioned, to account for lineshift.
    //
    if (pFlowLayout->_fSizeToContent)
    {
        RecalcLineShiftForNestedLayouts();
    }

    if ( pci->_fNeedToSizeContentDispNode )
    {
        pci->_fNeedToSizeContentDispNode = FALSE;
        pFlowLayout->SizeContentDispNode(CSize(GetMaxWidth(), GetHeight()));
    }

    //
    // NOTE(SujalP): Ideally I would like to do the NMR in all cases. However, that causes a misc perf
    // regession of about 2% on pages with a lot of small table cells. To avoid that problem I am doing
    // this only for edit mode. If you have other needs then add those cases to the if condition.
    // 
    if (pFlowLayout->IsEditable())
        pFlowLayout->NotifyMeasuredRange(GetFlowLayoutElement()->GetFirstCp(), GetMaxCpCalced());

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::RecalcLineShift P(%d,%d)", pci->_sizeParent.cx, pci->_sizeParent.cy ));
}

void
CDisplay::RecalcLineShiftForNestedLayouts()
{
    CLayout     * pLayout;
    CFlowLayout * pFL = GetFlowLayout();
    CDispNode   * pDispNode = pFL->GetFirstContentDispNode();

    if (pFL->_fAutoBelow)
    {
        DWORD_PTR dw;

        for (pLayout = pFL->GetFirstLayout(&dw); pLayout; pLayout = pFL->GetNextLayout(&dw))
        {
            CElement * pElement = pLayout->ElementOwner();
            CTreeNode * pNode   = pElement->GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));

            if (    !pFF->IsAligned()
                &&  (   pFF->IsAutoPositioned()
                    ||  pNode->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->IsRelative(FALSE)))
            {
                pElement->ZChangeElement(0, NULL, pFL->LayoutContext());
            }
        }
        pFL->ClearLayoutIterator(dw);
    }

    if (pDispNode == NULL)
        return;
    
    pDispNode = pDispNode->GetNextFlowNode();
    
    if (pDispNode)
    {
        CLinePtr rp(this);
        CLineOtherInfo *ploi;
        
        do
        {
            // if the current disp node is not a text node
            if (pDispNode->GetDispClient() != pFL)
            {
                void * pvOwner;

                pDispNode->GetDispClient()->GetOwner(pDispNode, &pvOwner);

                if (pvOwner)
                {
                    CElement * pElement = DYNCAST(CElement, (CElement *)pvOwner);

                    //
                    // aligned layouts are not affected by text-align
                    //
                    if (!pElement->IsAligned())
                    {
                        //TODO (dmitryt, track bug 111990) this can hurt perf - RpSetCp is slow.
                        //we could have a bit on CDisplay that tells us that at least 
                        //one line was RTL or right- or center-aligned. 
                        //If not, we shouldn't bother checking this.
                        BOOL fCpFound = rp.RpSetCp(pElement->GetFirstCp(), FALSE, TRUE);

                        htmlAlign  atAlign  = (htmlAlign)pElement->GetFirstBranch()->
                                                    GetParaFormat()->_bBlockAlign;

                        if (fCpFound && 
                                (    atAlign == htmlAlignRight 
                                 ||  atAlign == htmlAlignCenter 
                                 ||  rp->IsRTLLine()
                                )
                           )
                        {
                            // NOTE: (KTam) There's an assumption here that the pElement we've gotten
                            // to is in fact within this CDisplay.  I'm going to assert this.
                            Assert( pElement->GetFirstCp() >= GetFirstCp() && "Found an element beginning outside our display -- can't determine context!" );
                            Assert( pElement->GetLastCp() <= GetLastCp() && "Found an element ending outside our display -- can't determine context!" );

                            pLayout = pElement->GetUpdatedLayout( LayoutContext() );
                            Assert(pLayout);

                            ploi = rp->oi();
                            LONG lNewXPos;

                            if(!rp->IsRTLLine())
                            {
                                lNewXPos = ploi->GetTextLeft() + pLayout->GetXProposed();
                            }
                            else
                            {
                                lNewXPos =    GetViewWidth()
                                            - pLayout->GetXProposed() 
                                            - pLayout->GetApparentWidth()
                                            - ploi->_xRightMargin 
                                            - rp->_xRight;
                            }

                            pLayout->SetPosition(lNewXPos,
                                                 pLayout->GetPositionTop(), 
                                                 TRUE); // notify auto
                        }
                    }
                }
            }
            pDispNode = pDispNode->GetNextFlowNode();
        }
        while (pDispNode);
    }
}

/*
 *  CDisplay::CreateEmptyLine()
 *
 *  @mfunc
 *      Create an empty line
 *
 *  @rdesc
 *      TRUE - worked <nl>
 *      FALSE - failed
 *
 */
BOOL CDisplay::CreateEmptyLine(CLSMeasurer * pMe,
    CRecalcLinePtr * pRecalcLinePtr,
    LONG * pyHeight, BOOL fHasEOP )
{
    UINT uiFlags;
    LONG yAlignDescent;
    INT  iNewLine;

    // Make sure that this is being called appropriately
    AssertSz(!pMe || GetLastCp() == long(pMe->GetCp()),
        "CDisplay::CreateEmptyLine called inappropriately");

    // Assume failure
    BOOL    fResult = FALSE;

    // Add one new line
    CLineCore *pliNew = pRecalcLinePtr->AddLine();

    if (!pliNew)
    {
        Assert(FALSE);
        goto err;
    }

    iNewLine = pRecalcLinePtr->Count() - 1;

    Assert (iNewLine >= 0);

    uiFlags = fHasEOP ? MEASURE_BREAKATWORD |
                        MEASURE_FIRSTINPARA :
                        MEASURE_BREAKATWORD;

    uiFlags |= MEASURE_EMPTYLASTLINE;

    // If this is the first line in the document.
    if (*pyHeight == 0)
        uiFlags |= MEASURE_FIRSTLINE;

    if (!pRecalcLinePtr->MeasureLine(*pMe, uiFlags,
                                   &iNewLine, pyHeight, &yAlignDescent,
                                   NULL, NULL))
    {
        goto err;
    }

    // If we made it to here, everything worked.
    fResult = TRUE;

err:

    return fResult;
}


//====================================  Rendering  =======================================


/*
 *  CDisplay::Render(rcView, rcRender)
 *
 *  @mfunc
 *      Searches paragraph boundaries around a range
 *
 *  returns: the lowest yPos
 */
void
CDisplay::Render (
    CFormDrawInfo * pDI,
    const RECT &rcView,     // View RECT
    const RECT &rcRender,   // RECT to render (must be container in
    CDispNode * pDispNode)
{
#ifdef SWITCHES_ENABLED
    if (IsSwitchNoRenderLines())
        return;
#endif
    CFlowLayout * pFlowLayout = GetFlowLayout();
    CElement    * pElementFL  = pFlowLayout->ElementOwner();
    LONG    ili;
    LONG    iliBgDrawn = -1;
    LONG    iliForFloatedFL = LONG_MIN;
    POINT   pt;
    LONG    cp;
    LONG    yLine;
    LONG    yLi = 0;
    WHEN_DBG( long lLinesRendered = 0; )
    long    lCount;
    CLineFull lif;
    RECT    rcClip;
    BOOL    fLineIsPositioned;
    CRect   rcLocal;
    long    iliStart  = -1;
    long    iliFinish = -1;
    CPoint  ptOffset;
    CPoint* pptOffset = NULL;

#if DBG == 1
    LONG    cpLi;
#endif

    AssertSz(!pFlowLayout->IsDirty(), "Rendering when layout is dirty -- not a measurer/renderer problem!");

    if (    !pFlowLayout->ElementOwner()->IsInMarkup()
        || (!pFlowLayout->IsEditable() && pFlowLayout->IsDisplayNone())
        ||   pFlowLayout->IsDirty())   // Prevent us from crashing when we do get here in retail mode.
    {
        return;
    }

    // Create renderer
    CLSRenderer lsre(this, pDI);

    if (!lsre._pLS)
        return;

    Assert(pDI->_rc == rcView);
    Assert(((CRect&)(pDI->_rcClip)) == rcRender);

    // Calculate line and cp to start the display at
    rcLocal = rcRender;
    rcLocal.OffsetRect(-((CRect&)rcView).TopLeft().AsSize());

    //
    // if the current layout has multiple text nodes then
    // compute the range of lines the belong to the disp node
    // being rendered.
    //
    if (_fHasMultipleTextNodes && pDispNode)
    {
        GetFlowLayout()->GetTextNodeRange(pDispNode, &iliStart, &iliFinish);

        Assert(iliStart < iliFinish);

        //
        // For backgrounds, RegionFromElement is going to return the
        // rects relative to the layout. So, when we have multiple text
        // nodes pass the (0, -top) as the offset to make the rects
        // text node relative
        //
        pptOffset    = &ptOffset;
        pptOffset->x = 0;
        pptOffset->y = -pDispNode->GetPosition().y;
    }

    //
    // For multiple text node, we want to search for the point only
    // in the lines owned by the text node.
    //
    ili = LineFromPos(rcLocal, &yLine, &cp, 0, iliStart, iliFinish);

    lCount = iliFinish < 0 ? LineCount() : iliFinish;

    if(lCount <= 0 || ili < 0)
        return;

    rcClip = rcRender;

    // Prepare renderer

    if(!lsre.StartRender(rcView, rcRender, ili, cp))
        return;

    // If we're just painting the inset, don't check all the lines.
    if (rcRender.right <= rcView.left ||
        rcRender.left >= rcView.right ||
        rcRender.bottom <= rcView.top ||
        rcRender.top >= rcView.bottom)
        return;

    
    // Calculate the point where the text will start being displayed
    pt = ((CRect &)rcView).TopLeft();
    pt.y += yLine;

    // Init renderer at the start of the first line to render
    lsre.SetCurPoint(pt);
    lsre.SetCp(cp, NULL);

    WHEN_DBG(cpLi = long(lsre.GetCp());)

    yLi = pt.y;

    // Check if this line begins BEFORE the previous line ended ...
    // Would happen with negative line heights:
    //
    //           ----------------------- <-----+---------- Line 1
    //                                         |
    //           ======================= <-----|-----+---- Line 2
    //  yBeforeSpace__________^                |     |
    //                        |                |     |
    //  yLi ---> -------------+--------- <-----+     |
    //                                               |
    //                                               |
    //           ======================= <-----------+
    //
    RecalcMost();

    // Render each line in the update rectangle

    for (; ili < lCount; ili++)
    {
        // current line
        lif = *Elem(ili);
        
        // if the most negative line is out off the view from the current
        // yOffset, don't look any further, we have rendered all the lines
        // in the inval'ed region
        if (yLi + min(long(0), lif.GetYTop()) + _yMostNeg >= rcClip.bottom)
        {
            break;
        }

        fLineIsPositioned = FALSE;

        //
        // if the current line is interesting (ignore aligned, clear,
        // hidden and blank lines).
        //
        if(lif._cch && !lif._fHidden)
        {
            //
            // if the current line is relative get its y offset and
            // zIndex
            //
            if(lif._fRelative)
            {
                fLineIsPositioned = TRUE;
            }
        }

        //
        // now check to see if the current line is in view
        //
        if(   ((yLi + min(long(0), lif.GetYLineTop()))    > rcClip.bottom)
           || ((yLi + max(long(0), lif.GetYLineBottom())) < rcClip.top   )
          )
        {
            //
            // line is not in view, so skip it
            //
            lsre.SkipCurLine(&lif);
        }
        else
        {
            //
            // current line is in view, so render it
            //
            // Note: we have to render the background on a relative line,
            // the parent of the relative element might have background.(srinib)
            // fix for #51465
            //
            // if the paragraph has background or borders then compute the bounding rect
            // for the paragraph and draw the background and/or border
            if(iliBgDrawn < ili &&
               (lif._fHasParaBorder || // if we need to draw borders
                (   lif._fHasBackground 

                    && pElementFL->GetMarkupPtr()->PaintBackground())))
            {
                DrawBackgroundAndBorder(lsre.GetDrawInfo(), lsre.GetCp(), ili, lCount,
                                        &iliBgDrawn, yLi, &rcView, &rcClip, pptOffset);

                //
                // N.B. (johnv) Lines can be added by as
                // DrawBackgroundAndBorders (more precisely,
                // RegionFromElement, which it calls) waits for a
                // background recalc.  Recompute our cached line pointer.
                //
                lif = *Elem(ili);
            }

            if (   (   lif._fHasFirstLine
                    || lif._fHasFloatedFL
                   )
                && lif._fHasBackground
                && !lif.IsFrame()
                && pElementFL->GetMarkupPtr()->PaintBackground()
               )
            {
                if (lif._fHasFirstLetter && lif._fHasFloatedFL)
                    iliForFloatedFL = ili + 1;
                
                if (   (   lif._fHasFirstLetter
                        && lif._fHasFloatedFL
                       )
                    || (   lif._fHasFirstLine
                        && iliForFloatedFL + 1 != ili
                       )
                   )
                {
                    DrawBackgroundForFirstLine(lsre.GetDrawInfo(), lsre.GetCp(), ili,
                                               &rcView, &rcClip, pptOffset);
                    //
                    // N.B. (johnv) Lines can be added by as
                    // DrawBackgroundAndBorders (more precisely,
                    // RegionFromElement, which it calls) waits for a
                    // background recalc.  Recompute our cached line pointer.
                    //
                    lif = *Elem(ili);
                }
            }
            
            // if the current line has is positioned it will be taken care
            // of through the SiteDrawList and we shouldn't draw it here.
            //
            if (fLineIsPositioned)
            {
                lsre.SkipCurLine(&lif);
            }
            else
            {
                //
                // Finally, render the current line
                //
                lsre.RenderLine(lif);
                WHEN_DBG( ++ lLinesRendered; )
            }
        }

        Assert(lif == *Elem(ili));

        //
        // update the yOffset for the next line
        //
        if(lif._fForceNewLine)
            yLi += lif._yHeight;

        WHEN_DBG( cpLi += lif._cch; )

        AssertSz( long(lsre.GetCp()) == cpLi,
                  "CDisplay::Render() - cp out of sync. with line table");
        AssertSz( lsre.GetCurPoint().y == yLi,
                  "CDisplay::Render() - y out of sync. with line table");

    }

    TraceTag((tagRenderLines, "rendered %ld of %ld lines for %x (%ls %ld) at (%d %d %d %d) clip (%d %d %d %d)",
                lLinesRendered, lCount,
                pFlowLayout, pElementFL->TagName(), pElementFL->SN(),
                rcView.top, rcView.bottom, rcView.left, rcView.right,
                rcRender.top, rcRender.bottom, rcRender.left, rcRender.right
                ));

    if (lsre._lastTextOutBy != CLSRenderer::DB_LINESERV)
    {
        lsre._lastTextOutBy = CLSRenderer::DB_NONE;
        SetTextAlign(lsre._hdc, TA_TOP | TA_LEFT);
    }
}


//+---------------------------------------------------------------------------
//
// Member:      DrawBackgroundAndBorders()
//
// Purpose:     Draw background and borders for elements on the current line,
//              and all the consecutive lines that have background.
//
//----------------------------------------------------------------------------
void
CDisplay::DrawBackgroundAndBorder(
     CFormDrawInfo * pDI,
     long            cpIn,
     LONG            ili,
     LONG            lCount,
     LONG          * piliDrawn,
     LONG            yLi,
     const RECT    * prcView,
     const RECT    * prcClip,
     const CPoint  * pptOffset)
{

    const CCharFormat  * pCF;
    const CFancyFormat * pFF;
    const CParaFormat  * pPF;
    CStackPtrAry < CTreeNode *, 8 > aryNodesWithBgOrBorder(Mt(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv));
    CDataAry <RECT> aryRects(Mt(CDisplayDrawBackgroundAndBorder_aryRects_pv));
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElementFL  = pFlowLayout->ElementContent();
    CMarkup     *   pMarkup = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground = pMarkup->PaintBackground();
    CTreeNode *     pNodeCurrBranch;
    CTreeNode *     pNode;
    CTreePos  *     ptp;
    long            ich;
    long            cpClip = cpIn;
    long            cp;
    long            lSize;


    // find the consecutive set of lines that have background
    while (ili < lCount && yLi + _yMostNeg < prcClip->bottom)
    {
        CLineCore * pli = Elem(ili++);

        // if the current line has borders or background then
        // continue otherwise return.
        if (!(pli->_fHasBackground && fPaintBackground) &&
            !pli->_fHasParaBorder)
        {
            break;
        }

        if (pli->_fForceNewLine)
        {
            yLi += pli->_yHeight;
        }

        cpClip += pli->_cch;
    }

    if(cpIn != cpClip)
        *piliDrawn = ili - 1;

    // initialize the tree pos that corresponds to the begin cp of the
    // current line
    ptp = pMarkup->TreePosAtCp(cpIn, &ich, TRUE);

    cp = cpIn - ich;

    // first draw any backgrounds extending into the current region
    // from the previous line.

    pNodeCurrBranch = ptp->GetBranch();

    if(    DifferentScope(pNodeCurrBranch, pElementFL)
           && ( pElementFL->IsOverlapped() ?
                pElementFL->GetFirstCp() < pNodeCurrBranch->Element()->GetFirstCp() :
                TRUE
              ) // protect against weird overlapping (#99003)
      )
    {
        pNode = pNodeCurrBranch;

        // run up the current branch and find the ancestors with background
        // or border
        while(pNode && !SameScope(pNode, pElementFL))
        {
            if (!pNode->ShouldHaveLayout())
            {
                // push this element on to the stack
                aryNodesWithBgOrBorder.Append(pNode);
            }
#if DBG==1
            else
            {
                Assert(pNode == pNodeCurrBranch);
            }
#endif
            pNode = pNode->Parent();
        }

        Assert(pNode);

        // now that we have all the elements with background or borders
        // for the current branch render them.
        for(lSize = aryNodesWithBgOrBorder.Size(); lSize > 0; lSize--)
        {
            CTreeNode * pNode = aryNodesWithBgOrBorder[lSize - 1];

            //
            // In design mode relative elements are drawn in flow (they are treated
            // as if they are not relative). Relative elements draw their own
            // background and their children's background. So, draw only the
            // background of ancestor's if any. (#25583)
            //
            if(pNode->IsRelative() )
            {
                pNodeCurrBranch = pNode;
                break;
            }
            else
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
                {
                    BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                    BOOL fDrawBackground = fPaintBackground &&
                                           pFF->_fBlockNess &&
                                           (pFF->_lImgCtxCookie ||
                                            pFF->_ccvBackColor.IsDefined());

                    if (fDrawBackground || fDrawBorder)
                    {

                        DrawElemBgAndBorder(
                                            pNode->Element(), &aryRects,
                                            prcView, prcClip,
                                            pDI, pptOffset,
                                            fDrawBackground, fDrawBorder,
                                            cpIn, -1, !pCF->_cuvLineHeight.IsNull());
                    }
                }
            }
        }


        //
        // In design mode relative elements are drawn in flow (they are treated
        // as if they are not relative).
        //
        if(pNodeCurrBranch->ShouldHaveLayout() || pNode->IsRelative())
        {
            CTreePos * ptpBegin;

            pNodeCurrBranch->Element()->GetTreeExtent(&ptpBegin, &ptp);

            cp = ptp->GetCp();
        }

        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

    // now draw the background of all the elements comming into scope of
    // in the cpRange
    while(ptp && cpClip >= cp)
    {
        if(ptp->IsBeginElementScope())
        {
            pNode = ptp->Branch();
            pCF   = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

            // Background and border for a relative element or an element
            // with layout are drawn when the element is hit with a draw.
            if(pNode->ShouldHaveLayout() || pCF->_fRelative)
            {
                if(DifferentScope(pNode, pElementFL))
                {
                    CTreePos * ptpBegin;

                    pNode->Element()->GetTreeExtent(&ptpBegin, &ptp);
                    cp = ptp->GetCp();
                }
            }
            else
            {
                pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
                {
                    BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                    BOOL fDrawBackground = fPaintBackground &&
                                           pFF->_fBlockNess &&
                                           (pFF->_lImgCtxCookie ||
                                            pFF->_ccvBackColor.IsDefined());

                    if (fDrawBackground || fDrawBorder)
                    {
                        DrawElemBgAndBorder(
                                            pNode->Element(), &aryRects,
                                            prcView, prcClip,
                                            pDI, pptOffset,
                                            fDrawBackground, fDrawBorder,
                                            cp, -1, !pCF->_cuvLineHeight.IsNull());
                    }
                }
            }
        }

        cp += ptp->GetCch();
        ptp = ptp->NextTreePos();
    }

}

//+---------------------------------------------------------------------------
//
// Member:      DrawBackgroundAndBorders()
//
// Purpose:     Draw background and borders for elements on the current line,
//              and all the consecutive lines that have background.
//
//----------------------------------------------------------------------------
void
CDisplay::DrawBackgroundForFirstLine(
    CFormDrawInfo * pDI,
    long            cpIn,
    LONG            ili,
    const RECT    * prcView,
    const RECT    * prcClip,
    const CPoint  * pptOffset)
{
    CStackPtrAry < CTreeNode *, 8 > aryNodesWithBgOrBorder(Mt(CDisplayDrawBackgroundAndBorder_aryNodesWithBgOrBorder_pv));
    CDataAry <RECT> aryRects(Mt(CDisplayDrawBackgroundAndBorder_aryRects_pv));
    CFlowLayout *   pFlowLayout = GetFlowLayout();
    CElement    *   pElementFL  = pFlowLayout->ElementContent();
    CMarkup     *   pMarkup = pFlowLayout->GetContentMarkup();
    BOOL            fPaintBackground = pMarkup->PaintBackground();
    CTreeNode *     pNodeCurrBranch;
    CTreePos  *     ptp;
    long            ich;
    long            cchPreChars = 0;
    long            cchPreCharsInLine;
    
    Assert(cpIn == CpFromLine(ili));

    if (Elem(ili)->_fPartOfRelChunk)
        goto Cleanup;

    FormattingNodeForLine(FNFL_NONE, cpIn, NULL, Elem(ili)->_cch, &cchPreChars, NULL, NULL);
    
    cpIn += cchPreChars;
    cchPreCharsInLine = cchPreChars;
    
    // initialize the tree pos that corresponds to the begin cp of the
    // current line
    ptp = pMarkup->TreePosAtCp(cpIn, &ich, TRUE);

    // first draw any backgrounds extending into the current region
    // from the previous line.
    pNodeCurrBranch = ptp->GetBranch();

    if(    DifferentScope(pNodeCurrBranch, pElementFL)
        && ( pElementFL->IsOverlapped() ?
              pElementFL->GetFirstCp() < pNodeCurrBranch->Element()->GetFirstCp() :
              TRUE
           ) // protect against weird overlapping (#99003)
      )
    {
        {
            CTreeNode *pNode = pNodeCurrBranch;

            // run up the current branch and find the ancestors with background
            // or border
            while(pNode && !SameScope(pNode, pElementFL))
            {
                if (!pNode->ShouldHaveLayout())
                {
                    // push this element on to the stack
                    aryNodesWithBgOrBorder.Append(pNode);
                }
                pNode = pNode->Parent();
            }

            Assert(pNode);
        }
        
        // now that we have all the elements with background or borders
        // for the current branch render them.
        for(long lSize = aryNodesWithBgOrBorder.Size() - 1; lSize >= 0; lSize--)
        {
            CTreeNode * pNode = aryNodesWithBgOrBorder[lSize];

            const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            const CParaFormat  * pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
            if (!pCF->IsVisibilityHidden() && !pCF->IsDisplayNone())
            {
                CLSMeasurer me(this);
                CLinePtr rp(this);
                LONG cpLayoutStart = GetFirstCp();
                LONG cpStart;
                LONG cpStop = 0;

                rp.RpSetCp(cpIn, FALSE, TRUE, TRUE);

                cchPreCharsInLine = cchPreChars;
                if (rp->oi()->_fHasFloatedFL)
                {
                    rp.RpSetCp(cpIn - cchPreCharsInLine + rp->_cch, FALSE, TRUE, TRUE);
                    cchPreCharsInLine = 0;
                }
                
                if (pFF->_fHasFirstLine)
                {
                    LONG cpElemFirst = pNode->Element()->GetFirstCp();

                    if (cpElemFirst < (long)rp.GetCp() + cpLayoutStart + rp->_cch - cchPreCharsInLine)
                    {
                        me.PseudoLineEnable(pNode);
                        cpStart = rp.GetCp() + cpLayoutStart - cchPreCharsInLine;
                        cpStop = cpStart + rp->_cch;
                        if (rp->_cch != 0)
                            cpStop--;
                        
                        pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                        BOOL fHasPseudoBg = FALSE;
                        if (pFF->_iPEI != -1)
                        {
                            const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
                            fHasPseudoBg = pPEI->_lImgCtxCookie || pPEI->_ccvBackColor.IsDefined();
                        }

                        BOOL fDrawBackground =    fPaintBackground
                                               && pFF->_fBlockNess
                                               && fHasPseudoBg;

                        if (fDrawBackground)
                        {
                            DrawElemBgAndBorder(
                                pNode->Element(), &aryRects,
                                prcView, prcClip,
                                pDI, pptOffset,
                                TRUE, FALSE,
                                cpStart, cpStop, fHasPseudoBg || !pCF->_cuvLineHeight.IsNull(), FALSE, fHasPseudoBg);
                        }

                        me.PseudoLineDisable();

                        pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pPF = pNode->GetParaFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                        pFF = pNode->GetFancyFormat(LC_TO_FC(pFlowLayout->LayoutContext()));

                        BOOL fDrawBorder = pCF->_fPadBord  && pFF->_fBlockNess;
                        if (fDrawBorder)
                        {
                            DrawElemBgAndBorder(
                                                pNode->Element(), &aryRects,
                                                prcView, prcClip,
                                                pDI, pptOffset,
                                                FALSE, TRUE,
                                                cpIn - cchPreChars, -1, !pCF->_cuvLineHeight.IsNull());
                        }
                    }
                }
            } // if visibility ...
        } // outer for loop
    } // if different scope...

Cleanup:
    return;
}


    
//+----------------------------------------------------------------------------
//
// Function:    BoundingRectForAnArrayOfRectsWithEmptyOnes
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//              It does not ignore the rectangles that have left=right, top=bottom
//              or both. It still ignores the rects that have left=right=top=bottom=0
//
//-----------------------------------------------------------------------------

void
BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects)
{
    RECT *  prc;
    LONG    iRect;
    LONG    lSize = paryRects->Size();
    BOOL    fFirst = TRUE;

    SetRectEmpty(prcBound);

    for(iRect = 0, prc = *paryRects; iRect < lSize; iRect++, prc++)
    {
        if((prc->left <= prc->right && prc->top <= prc->bottom) &&
            (prc->left != 0 || prc->right != 0 || prc->top != 0 || prc->bottom != 0) )
        {
            if(fFirst)
            {
                *prcBound = *prc;
                fFirst = FALSE;
            }
            else
            {
                if(prcBound->left > prc->left) prcBound->left = prc->left;
                if(prcBound->top > prc->top) prcBound->top = prc->top;
                if(prcBound->right < prc->right) prcBound->right = prc->right;
                if(prcBound->bottom < prc->bottom) prcBound->bottom = prc->bottom;
            }
        }
    }
}


//+----------------------------------------------------------------------------
//
// Function:    BoundingRectForAnArrayOfRects
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//
//-----------------------------------------------------------------------------

void
BoundingRectForAnArrayOfRects(RECT *prcBound, CDataAry<RECT> * paryRects)
{
    RECT *  prc;
    LONG    iRect;
    LONG    lSize = paryRects->Size();

    SetRectEmpty(prcBound);

    for(iRect = 0, prc = *paryRects; iRect < lSize; iRect++, prc++)
    {
        if(!IsRectEmpty(prc))
        {
            UnionRect(prcBound, prcBound, prc);
        }
    }
}


//+----------------------------------------------------------------------------
//
// Member:      DrawElementBackground
//
// Synopsis:    Draw the background for a an element, given the region it
//              occupies in the display
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElementBackground(CTreeNode * pNodeContext,
                                CDataAry <RECT> * paryRects, RECT * prcBound,
                                const RECT * prcView, const RECT * prcClip,
                                CFormDrawInfo * pDI, BOOL fPseudo)
{
    RECT    rcDraw;
    RECT    rcBound = { 0 };
    RECT *  prc;
    LONG    lSize;
    LONG    iRect;
    SIZE    sizeImg;
    CPoint  ptBackOrg;
    CBackgroundInfo bginfo;
    CColorValue    ccvBackColor;
    const CFancyFormat * pFF = pNodeContext->GetFancyFormat(LC_TO_FC(GetFlowLayout()->LayoutContext()));
    BOOL  fBlockElement = pNodeContext->Element()->IsBlockElement();

    Assert(pFF->_lImgCtxCookie || pFF->_ccvBackColor.IsDefined() || fPseudo);

    CDoc *    pDoc    = GetFlowLayout()->Doc();
    CImgCtx * pImgCtx;
    LONG lImgCtxCookie;
    
    if (fPseudo)
    {
        Assert(pFF->_iPEI >= 0);
        const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        lImgCtxCookie = pPEI->_lImgCtxCookie;
        ccvBackColor = pPEI->_ccvBackColor;
    }
    else
    {
        lImgCtxCookie = pFF->_lImgCtxCookie;
        ccvBackColor = pFF->_ccvBackColor;
    }
    
    pImgCtx = lImgCtxCookie ? pDoc->GetUrlImgCtx(lImgCtxCookie) : 0;

    if (pImgCtx && !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        pImgCtx = NULL;

    // if the background image is not loaded yet and there is no background color
    // return (we dont have anything to draw)
    if(!pImgCtx && !ccvBackColor.IsDefined())
        return;

    // now given the rects for a given element
    // draw its background

    // if we have a background image, we need to compute its origin

    lSize = paryRects->Size();

    if(lSize == 0)
        return;

    memset(&bginfo, 0, sizeof(bginfo));

    bginfo.pImgCtx       = pImgCtx;
    bginfo.lImgCtxCookie = lImgCtxCookie;
    bginfo.crTrans       = COLORREF_NONE;
    bginfo.crBack        = ccvBackColor.IsDefined()
        ? ccvBackColor.GetColorRef()
        : COLORREF_NONE;

    if (pImgCtx || fBlockElement)
    {
        if(!prcBound)
        {
            // compute the bounding rect for the element.
            BoundingRectForAnArrayOfRects(&rcBound, paryRects);
        }
        else
            rcBound = *prcBound;
    }

    if (pImgCtx)
    {
        if(!IsRectEmpty(&rcBound))
        {
            SIZE sizeBound;

            sizeBound.cx = rcBound.right - rcBound.left;
            sizeBound.cy = rcBound.bottom - rcBound.top;

            GetBgImgSettings(pFF, &bginfo);
            CalcBgImgRect(pNodeContext, pDI, &sizeBound, &sizeImg, &ptBackOrg, &bginfo);

            OffsetRect(&bginfo.rcImg, rcBound.left, rcBound.top);

            ptBackOrg.x += rcBound.left - prcView->left;
            ptBackOrg.y += rcBound.top - prcView->top;

            bginfo.ptBackOrg = ptBackOrg;
        }
    }

    prc = *paryRects;
    rcDraw = *prc++;

    //
    // Background for block element needs to extend for the
    // left to right of rcBound.
    //
    if (fBlockElement)
    {
        rcDraw.left  = rcBound.left;
        rcDraw.right = rcBound.right;
    }

    for(iRect = 1; iRect <= lSize; iRect++, prc++)
    {
        if(iRect == lSize || !IsRectEmpty(prc))
        {
            if (iRect != lSize)
            {
                if (fBlockElement)
                {
                    if (prc->top < rcDraw.top)
                        rcDraw.top = prc->top;
                    if (prc->bottom > rcDraw.bottom)
                        rcDraw.bottom = prc->bottom;
                    continue;
                }
                else if (   prc->left == rcDraw.left
                        &&  prc->right == rcDraw.right
                        &&  prc->top == rcDraw.bottom)
                {
                    // add the current rect
                    rcDraw.bottom = prc->bottom;
                    continue;
                }
            }

            {
                IntersectRect(&rcDraw, prcClip, &rcDraw);

                if(!IsRectEmpty(&rcDraw))
                {
                    IntersectRect(&bginfo.rcImg, &bginfo.rcImg, &rcDraw);
                    GetFlowLayout()->DrawBackground(pDI, &bginfo, &rcDraw);
                }

                if(iRect != lSize)
                    rcDraw = *prc;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:    DrawElementBorder
//
// Synopsis:    Find the bounding rect that contains a given set of rectangles
//
//-----------------------------------------------------------------------------

void
CDisplay::DrawElementBorder(CTreeNode * pNodeContext,
                                CDataAry <RECT> * paryRects, RECT * prcBound,
                                const RECT * prcView, const RECT * prcClip,
                                CFormDrawInfo * pDI)
{
    CBorderInfo borderInfo;
    CElement *  pElement = pNodeContext->Element();

    if (pNodeContext->GetCharFormat(LC_TO_FC(GetFlowLayout()->LayoutContext()))->IsVisibilityHidden())
        return;

    if ( !pElement->_fDefinitelyNoBorders &&
         FALSE == (pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNodeContext, pDI, &borderInfo, GBIH_ALL ) ) )
    {
        RECT rcBound;

        if(!prcBound)
        {
            if(paryRects->Size() == 0)
                return;

            // compute the bounding rect for the element.
            BoundingRectForAnArrayOfRects(&rcBound, paryRects);
        }
        else
            rcBound = *prcBound;

        // If we're a broken layout, we may only be displaying part of
        // pElement, so we might not want to draw the top or bottom border.
        CFlowLayout *pFL = GetFlowLayout();
        if ( pFL->LayoutContext() )
        {
            // We're a broken layout.
            // Does pElement begin before us?
            if ( pElement->GetFirstCp() < pFL->GetContentFirstCpForBrokenLayout() )
                borderInfo.wEdges &= ~BF_TOP; // yes, turn off top border if it's on.

            // Does pElement end after us?
            if ( pElement->GetLastCp() > pFL->GetContentLastCpForBrokenLayout() )
                borderInfo.wEdges &= ~BF_BOTTOM; // yes, turn off bottom border if it's on.
        }

        DrawBorder(pDI, &rcBound, &borderInfo);
    }
}


// =============================  Misc  ===========================================

//+--------------------------------------------------------------------------------
//
// Synopsis: return true if this is the last text line in the line array
//---------------------------------------------------------------------------------
BOOL
CDisplay::IsLastTextLine(LONG ili)
{
    Assert(ili >= 0 && ili < LineCount());
    if (LineCount() == 0)
        return TRUE;
    
    for(LONG iliT = ili + 1; iliT < LineCount(); iliT++)
    {
        if(Elem(iliT)->IsTextLine())
            return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     FormattingNodeForLine
//
//  Purpose:    Returns the node which controls the formatting at the BOL. This
//              is needed because the first char on the line may not necessarily
//              be the first char in the paragraph.
//
//----------------------------------------------------------------------------
CTreeNode *
CDisplay::FormattingNodeForLine(
    DWORD        dwFlags,                   // IN
    LONG         cpForLine,                 // IN
    CTreePos    *ptp,                       // IN
    LONG         cchLine,                   // IN
    LONG        *pcch,                      // OUT
    CTreePos   **pptp,                      // OUT
    BOOL        *pfMeasureFromStart) const  // OUT
{
    CFlowLayout  *pFlowLayout = GetFlowLayout();
    BOOL          fIsEditable = pFlowLayout->IsEditable();
    CMarkup      *pMarkup     = pFlowLayout->GetContentMarkup();
    CTreeNode    *pNode       = NULL;
    CElement     *pElement;
    LONG          lNotNeeded;
    LONG          cch = cchLine;
    BOOL          fSawOpenLI  = FALSE;
    BOOL          fSeenAbsolute = FALSE;
    BOOL          fSeenBeginBlockTag = FALSE;
    BOOL          fStopAtGlyph = dwFlags & FNFL_STOPATGLYPH ? TRUE : FALSE;
    BOOL          fContinueLooking = TRUE;
    
    // AssertSz(!pFlowLayout->IsDirty(), "Called when line array dirty -- not a measurer/renderer problem!");

    AssertSz(!fStopAtGlyph || pfMeasureFromStart == NULL,
             "Cannot do both -- stopping at glyph and measuring from the start!");
    
    if (!ptp)
    {
        ptp = pMarkup->TreePosAtCp(cpForLine, &lNotNeeded, TRUE);
        Assert(ptp);
    }
    else
    {
        Assert(ptp->GetCp() <= cpForLine);
        Assert(ptp->GetCp() + ptp->GetCch() >= cpForLine);
    }
    if (pfMeasureFromStart)
        *pfMeasureFromStart = FALSE;
    while(fContinueLooking && cch > 0 && ptp) // check this in before end of milestone && ptp)
    {
        const CCharFormat *pCF;

        if (ptp->IsPointer())
        {
            ptp = ptp->NextTreePos();
            continue;
        }

        if (ptp->IsText())
        {
            if (ptp->Cch())
                break;
            else
            {
                ptp = ptp->NextTreePos();
                continue;
            }
        }

        if (   fStopAtGlyph
            && ptp->ShowTreePos()
           )
        {
            break;
        }
        
        Assert(ptp->IsNode());

        pNode = ptp->Branch();
        pElement = pNode->Element();
        pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        
        if (pfMeasureFromStart)
        {
            if (   (fIsEditable && ptp->IsNode() && ptp->ShowTreePos())
                || pNode->HasInlineMBP(LC_TO_FC(LayoutContext()))
                || (   !pFlowLayout->IsElementBlockInContext(pElement)
                    && pCF->_fHasInlineBg
                   )
               )
            {
                *pfMeasureFromStart = TRUE;
            }
        }
        
        if (ptp->IsBeginElementScope())
        {
            if (fSeenAbsolute)
                break;
            
            if (pCF->IsDisplayNone())
            {
                cch -= pFlowLayout->GetNestedElementCch(pElement, &ptp);
                cch += ptp->GetCch();
                pNode = pNode->Parent();
            }
            else if (pNode->ShouldHaveLayout(LC_TO_FC(LayoutContext())))
            {
                if (pNode->IsAbsolute(LC_TO_FC(LayoutContext())))
                {
                    cch -= pFlowLayout->GetNestedElementCch(pElement, &ptp);
                    cch += ptp->GetCch();
                    pNode = pNode->Parent();
                    fSeenAbsolute = TRUE;
                }
                else
                {
                    break;
                }
            }
            else if (pElement->Tag() == ETAG_BR)
            {
                break;
            }
            else if (   pElement->IsFlagAndBlock(TAGDESC_LIST)
                     && fSawOpenLI)
            {
                CTreePos * ptpT = ptp;

                do
                {
                    ptpT = ptpT->PreviousTreePos();
                } while (ptpT->GetCch() == 0);

                pNode = ptpT->Branch();

                break;
            }                        
            else if (pElement->IsTagAndBlock(ETAG_LI))
            {
                fSawOpenLI = TRUE;
            }
            else if (pFlowLayout->IsElementBlockInContext(pElement))
            {
                fSeenBeginBlockTag = TRUE;
                if (pCF->HasPadBord(FALSE))
                {
                    CDoc *pDoc = pFlowLayout->Doc();
                    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
                    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
                    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
                    LONG lFontHeight = pCF->GetHeightInTwips(pDoc);
                    CCalcInfo ci(pFlowLayout);
                    
                    if (!pElement->_fDefinitelyNoBorders)
                    {
                        CBorderInfo borderinfo;

                        pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, &ci, &borderinfo, GBIH_NONE );
                        if (   !pElement->_fDefinitelyNoBorders
                            && borderinfo.aiWidths[SIDE_TOP]
                           )
                        {
                            fContinueLooking = FALSE;
                        }
                    }

                    LONG yPadTop = pFF->GetLogicalPadding(SIDE_TOP, fNodeVertical, fWritingModeUsed).YGetPixelValue(
                                                    &ci,
                                                    ci._sizeParent.cx, 
                                                    lFontHeight);
                    if (yPadTop)
                    {
                        fContinueLooking = FALSE;
                    }
                }
            }
        }
        else if (ptp->IsEndNode())
        {
            if (fSeenAbsolute)
                break;
            
            //
            // If we encounter a break on empty block end tag, then we should
            // give vertical space otherwise a <X*></X> where X is a block element
            // will not produce any vertical space. (Bug 45291).
            //
            if (   fSeenBeginBlockTag 
                && pElement->_fBreakOnEmpty
                && pFlowLayout->IsElementBlockInContext(pElement)
               )
            {
                break;
            }
            
            if (   fSawOpenLI                       // Skip over the close LI, unless we saw an open LI,
                && ptp->IsEdgeScope()               // which would imply that we have an empty LI.  An
                && pElement->IsTagAndBlock(ETAG_LI) // empty LI gets a bullet, so we need to break.
               )
                break;
            pNode = pNode->Parent();
        }

        cch -= ptp->NodeCch();
        ptp = ptp->NextTreePos();

        Assert(ptp && "Null TreePos, crash protected but invalid measureing/rendering will occur");
    }

    if (pcch)
    {
        *pcch = cchLine - cch;
    }

    if (pptp)
    {
        *pptp = ptp;
    }

    if (!pNode && ptp)
    {
        pNode = ptp->GetBranch();
        if (ptp->IsEndNode())
            pNode = pNode->Parent();
    }

    return pNode;
}

//+---------------------------------------------------------------------------
//
//  Member:     EndNodeForLine
//
//  Purpose:    Returns the first node which ends this line. If the line ends
//              because of insufficient width, then the node is the node
//              above the last character in the line, else it is the node
//              which causes the line to end (like /p).
//
//----------------------------------------------------------------------------
CTreeNode *
CDisplay::EndNodeForLine(
    LONG         cpEndForLine,              // IN
    CTreePos    *ptp,                       // IN
    CCalcInfo   *pci,                       // IN
    LONG        *pcch,                      // OUT
    CTreePos   **pptp,                      // OUT
    CTreeNode  **ppNodeForAfterSpace) const // OUT
{
    CFlowLayout  *pFlowLayout = GetFlowLayout();
    BOOL          fIsEditable = pFlowLayout->IsEditable();
    CTreePos     *ptpStart, *ptpStop;
    CTreePos     *ptpNext = ptp;
    CTreePos     *ptpOriginal = ptp;
    CTreeNode    *pNode;
    CElement     *pElement;
    CTreeNode    *pNodeForAfterSpace = NULL;
    CCalcInfo     ci;
    BOOL          fSeenBlockElement = FALSE;
    BOOL          fSeenPadBord = FALSE;
    
    //
    // If we are in the middle of a text run then we do not need to
    // do anything, since this line will not be getting any para spacing
    //
    if (   ptpNext->IsText()
        && ptpNext->GetCp() < cpEndForLine
       )
        goto Cleanup;

    //
    // Construct a calc info if we do not have one already.
    //
    if (pci == NULL)
    {
        ci.Init(pFlowLayout);
        pci = &ci;
    }
    
    pFlowLayout->GetContentTreeExtent(&ptpStart, &ptpStop);

    //
    // We should never be here if we start measuring at the beginning
    // of the layout.
    //
    Assert(ptp != ptpStart);

    ptpStart = ptpStart->NextTreePos();
    while (ptp != ptpStart)
    {
        ptpNext = ptp;
        ptp = ptp->PreviousTreePos();

        if (ptp->IsPointer())
            continue;

        if (ptp->IsNode())
        {
            if (fIsEditable && ptp->ShowTreePos())
                break;

            pNode = ptp->Branch();
            pElement = pNode->Element();
            if (ptp->IsEndElementScope())
            {
                const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
                if (pCF->IsDisplayNone())
                {
                    pElement->GetTreeExtent(&ptp, NULL);
                }
                else if (pNode->ShouldHaveLayout(LC_TO_FC(pFlowLayout->LayoutContext())))
                {
                    // We need to collect after space info from the nodes which
                    // have layouts.
                    if (pElement->IsOwnLineElement(pFlowLayout))
                    {
                        pNodeForAfterSpace = pNode;
                    }
                    break;
                }
                else if (pElement->Tag() == ETAG_BR)
                    break;
                else if (pFlowLayout->IsElementBlockInContext(pElement))
                {
                    if (fSeenPadBord)
                        break;
                    else
                    {
                        const CFancyFormat *pFF = pNode->GetFancyFormat();
                        const CCharFormat  *pCF = pNode->GetCharFormat();
                        LONG lFontHeight = pCF->GetHeightInTwips(pElement->Doc());
    
                        if (pFF->GetLogicalPadding(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).YGetPixelValue(pci,
                                                                  pci->_sizeParent.cx, 
                                                                  lFontHeight))
                        {
                            fSeenPadBord = TRUE;
                            if (fSeenBlockElement)
                                break;
                        }

                        if (!pElement->_fDefinitelyNoBorders)
                        {
                            CBorderInfo borderinfo;

                            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, pci, &borderinfo, GBIH_NONE );
                            if (   !pElement->_fDefinitelyNoBorders
                                && borderinfo.aiWidths[SIDE_BOTTOM]
                               )
                            {
                                fSeenPadBord = TRUE;
                                if (fSeenBlockElement)
                                    break;
                            }
                        }
                    }
                    fSeenBlockElement = TRUE;
                }
            }
            else if (ptp->IsBeginElementScope())
            {
                if (    pFlowLayout->IsElementBlockInContext(pElement)
                    ||  !pNode->Element()->IsNoScope())
                    break;
                else if (   pElement->_fBreakOnEmpty
                         && pFlowLayout->IsElementBlockInContext(pElement)
                        )
                    break;
            }
        }
        else
        {
            Assert(ptp->IsText());
            if (ptp->Cch())
                break;
        }
    }

    Assert(ptpNext);
    
Cleanup:
    if (pptp)
        *pptp = ptpNext;
    if (pcch)
    {
        if (ptpNext == ptpOriginal)
            *pcch = 0;
        else
            *pcch = cpEndForLine - ptpNext->GetCp();
    }
    if (ppNodeForAfterSpace)
        *ppNodeForAfterSpace = pNodeForAfterSpace;
    
    return ptpNext->GetBranch();
}

long
ComputeLineShift(htmlAlign  atAlign,
                 BOOL       fRTLDisplay,
                 BOOL       fRTLLine,
                 BOOL       fMinMax,
                 long       xWidthMax,
                 long       xWidth,
                 UINT *     puJustified,
                 long *     pdxRemainder)
{
    long xShift = 0;
    long xRemainder = 0;

    switch(atAlign)
    {
    case htmlAlignNotSet:
        if(!fRTLLine)
            *puJustified = JUSTIFY_LEAD;
        else
            *puJustified = JUSTIFY_TRAIL;
        break;

    case htmlAlignLeft:
        *puJustified = JUSTIFY_LEAD;
        break;

    case htmlAlignRight:
        *puJustified = JUSTIFY_TRAIL;
        break;

    case htmlAlignCenter:
        *puJustified = JUSTIFY_CENTER;
        break;

    case htmlBlockAlignJustify:
        // This test is required so that final lines of RTL paragraphs
        // align to the correct side. We have lied to LineServices that
        // the paragraph is LSKALIGN is left. We handle measurements
        // ourselves instead of letting LS do this for us.
        if(!fRTLLine)
            *puJustified = JUSTIFY_FULL;
        else
            *puJustified = JUSTIFY_TRAIL;
        break;

    default:
        AssertSz(FALSE, "Did we introduce new type of alignment");
        break;
    }

    if (!fMinMax)
    {
        // WARNING: Duplicate of the logic in RecalcLineShift.
        //          Make it a function if it gets any more complex than this!
        if (*puJustified != JUSTIFY_FULL)
        {
            if (*puJustified != JUSTIFY_LEAD)
            {
                // for pre whitespace is already include in _xWidth
                xShift = xWidthMax - xWidth;
                xShift = max(xShift, 0L);           // Don't allow alignment to go < 0
                                                    // (need this for overflow lines)
                if (*puJustified == JUSTIFY_CENTER)
                {
                    Assert(atAlign == htmlAlignCenter);
                    xShift /= 2;
                }
            }
            xRemainder = xWidthMax - xWidth - xShift;
        } 
        
        // In RTL display, overflow lines must stretch to the left, with negative xShift
        if (fRTLDisplay && xWidthMax < xWidth)
        {
            xShift = xWidthMax - xWidth;
        }
    }

    Assert(pdxRemainder != NULL);
    *pdxRemainder = xRemainder;

    return xShift;
}

extern CDispNode * EnsureContentNode(CDispNode * pDispContainer);

HRESULT
CDisplay::InsertNewContentDispNode(CDispNode *  pDNBefore,
                                   CDispNode ** ppDispContent,
                                   long         iLine,
                                   long         yHeight)
{
    HRESULT       hr  = S_OK;
    CFlowLayout * pFlowLayout     = GetFlowLayout();
    CDispNode   * pDispContainer  = pFlowLayout->GetElementDispNode(); 
    CDispNode   * pDispNewContent = NULL;

    if (!pDispContainer)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // if a content node is not created yet, ensure that we have a content node.
    //
    if (!pDNBefore)
    {
        pDispContainer = pFlowLayout->EnsureDispNodeIsContainer();
        if (!pDispContainer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        EnsureContentNode(pDispContainer);

        pDNBefore = pFlowLayout->GetFirstContentDispNode();

        Assert(pDNBefore);

        if (!pDNBefore)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        *ppDispContent = pDNBefore;
    }

    Assert(pDispContainer->IsContainer());

    //
    // Create a new content dispNode and size the previous dispNode
    //

    pDispNewContent = CDispLeafNode::New(pFlowLayout, DISPEX_EXTRACOOKIE);

    if (!pDispNewContent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDispNewContent->SetPosition(CPoint(0, yHeight));
    pDispNewContent->SetSize(CSize(_xWidthView, 1), NULL, FALSE);

    pDispNewContent->SetVisible(pDispContainer->IsVisible());
    pDispNewContent->SetExtraCookie((void *)(DWORD_PTR)(iLine));
    pDispNewContent->SetLayerFlow();

    pDNBefore->InsertSiblingNode(pDispNewContent, CDispNode::after);

    *ppDispContent = pDispNewContent;
    
Cleanup:
    RRETURN(hr);
}

HRESULT
CDisplay::HandleNegativelyPositionedContent(CLineFull   * pliNew,
                                            CLSMeasurer * pme,
                                            CDispNode   * pDNBefore,
                                            long          iLinePrev,
                                            long          yHeight)
{
    HRESULT     hr = S_OK;
    CDispNode * pDNContent = NULL;

    Assert(pliNew);

    NoteMost(pliNew);

    if (iLinePrev > 0)
    {
        long yLineTop = pliNew->GetYTop();

        //
        // Create and insert a new content disp node, if we have negatively
        // positioned content.
        //
        
        // NOTE(SujalP): Changed from GetYTop to _yBeforeSpace. The reasons are
        // outlined in IE5 bug 62737.
        if (pliNew->_yBeforeSpace < 0 && !pliNew->_fDummyLine)
        {
            hr = InsertNewContentDispNode(pDNBefore, &pDNContent, iLinePrev, yHeight + yLineTop);
            if (hr)
                goto Cleanup;

            _fHasMultipleTextNodes = TRUE;

            if (pDNBefore == pme->_pDispNodePrev)
                pme->_pDispNodePrev = pDNContent;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------------
//
//  Member : ElementResize
//
//  Synopsis : CDisplay helper function to resize the element when the text content
//      has been remeasured and the container needs to be resized
//
//--------------------------------------------------------------------------------
void
CDisplay::ElementResize(CFlowLayout * pFlowLayout, BOOL fForceResize)
{
    if (!pFlowLayout)
        return;

    // If our contents affects our size, ask our parent to initiate a re-size
    if (    pFlowLayout->GetAutoSize()
        ||  pFlowLayout->_fContentsAffectSize
        ||  fForceResize)
    {
        pFlowLayout->ElementOwner()->ResizeElement();
    }
}

//+-------------------------------------------------------------------------------
//
//  Member : UndoMeasure
//
//--------------------------------------------------------------------------------

// TODO: (KTam, track bug 111968): 
// Currently this is really pretty much a hack; undoing measuring
// a line is a thoroughly involved process that requires rolling back state
// maintained in CLSMeasurer, CRecalcLinePtr, cached values like the rel
// dispnode cache a yMostNeg etc.  For B2, we're only going to solve the most
// problematic of measurement side-effects, which is layout/dispnode creation.

#if DBG
static BOOL
ElementHasExpectedLayouts( CLayoutContext *pLayoutContext, CElement *pElement, CMarkup *pMarkup )
{
    // CAUTION: Do not do anything in this function that causes data changes
    // (e.g. creation of layouts!).

    // Most elements needing layout who've just had their first
    // line measured should have 1 layout, but some may have 2
    // if they needed to be measured in a compatible context first.
    // (tables, % sizing).

    int nLayouts = pElement->GetLayoutAry()->Size();
    Assert(nLayouts == 1 || nLayouts == 2);

    // Should never be called with a compatible context as a param; that
    // implies we were doing line breaking in compatible mode.
    if ( pMarkup->HasCompatibleLayoutContext() )
        Assert( pMarkup->GetCompatibleLayoutContext() != pLayoutContext );

    // If an element has 2 layouts at this point, 1 of them
    // better be in the compatible context!
    if ( nLayouts == 2 )
    {
        Assert( pMarkup->HasCompatibleLayoutContext() );
        Assert( pElement->CurrentlyHasLayoutInContext( pMarkup->GetCompatibleLayoutContext() ) );
    }

    // The element better have a layout in the current context
    Assert( pElement->CurrentlyHasLayoutInContext( pLayoutContext ) );

    return TRUE;
}
#endif

void
CDisplay::UndoMeasure( CLayoutContext *pLayoutContext, long cpStart, long cpEnd )
{
    CTreePos *ptp;
    long      lOffset;
    long      cpCur;
    CTreeNode *pNode;
    CElement  *pElement;
    CLayout   *pLayout;

    Assert(pLayoutContext && "Illegal to call UndoMeasure for NULL layout context !!!");

    CMarkup *pMarkup = GetMarkup();

    cpCur = cpStart;
    ptp   = pMarkup->TreePosAtCp( cpStart, &lOffset, TRUE /* fAdjustForward */ );

    while ( cpCur < cpEnd )
    {
        if ( ptp->IsBeginElementScope() )
        {
            pNode = ptp->Branch();
            Assert( pNode );
            pElement = pNode->Element();
            Assert( !pElement->HasLayoutPtr() ); // we should only be here for paginated content, which must be measured w/in a context, so we can't have a standalone layout
            if ( pElement->HasLayoutAry() )
            {
                CLayoutAry *   pLA = pElement->GetLayoutAry();

#if DBG == 1
                // 
                //  Here we should be VERY careful. We are allowed to destroy only layouts 
                //  that are beginnings of their elements. (Destroying layout from the 
                //  middle of layout view chain is a very bad thing.) 
                //
                CLayoutBreak *pLayoutBreak;
                pLayoutContext->GetLayoutBreak(pElement, &pLayoutBreak);
                Assert(!pLayoutBreak && "Attempt to destroy layout from the middle of layout's view chain!!!");
#endif 

                // remove the layout in this context
                pLayout = pLA->RemoveLayoutWithContext( pLayoutContext );
                if (pLayout)
                {
                    // before removing layout itself destroy break entry that this layout might create
                    pLayoutContext->RemoveLayoutBreak(pElement);

                    Assert( pLA->Size() <= 1 );  // size should be 0 or 1
                    pLayout->Detach();
                    pLayout->Release();
                }

                // If the element also has a layout in the compatible context,
                // we don't want to get rid of it or the array. otherwise pLA
                // should be empty and we can toss it.
                if (!pLA->Size())
                {
                    pElement->DelLayoutAry(FALSE); // will take care of detaching/releasing its layouts
                }
            }
        }

        ptp = ptp->NextTreePos();
        if (!ptp)
            break;

        cpCur = ptp->GetCp();
    }
}


//============================================================================
//
//  CFlowLayoutBreak methods
//
//============================================================================
//----------------------------------------------------------------------------
//
//  Member: ~CFlowLayoutBreak
//
//  Note:   
//
//----------------------------------------------------------------------------
CFlowLayoutBreak::~CFlowLayoutBreak()
{
    if (_pMarkupPointer)
    {
        delete _pMarkupPointer;
        _pMarkupPointer = NULL;
    }
    
    _xLeftMargin    = 
    _xRightMargin   = 0;
}

#if DBG==1
LONG
CElement::GetLineCount()
{
    LONG lc = 0;
    CFlowLayout *pFL = GetFlowLayout();
    if (pFL)
    {
        lc = pFL->GetLineCount();
    }
    return lc;
}

HRESULT
CElement::GetFonts(long iLine, BSTR * pbstrFonts)
{
    HRESULT hr = E_UNEXPECTED;
    
    CFlowLayout *pFL = GetFlowLayout();
    if (pFL)
    {
        hr = THR(pFL->GetFonts(iLine, pbstrFonts));
    }
    else
    {
        CStr temp;
        temp.Set(_T("none"));
        hr = THR(temp.AllocBSTR(pbstrFonts));
    }
    RRETURN(hr);
}

HRESULT
CDisplay::GetFonts(long iLine, BSTR * pbstrFonts)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (iLine < 0l || iLine >= (long)Count())
    {
        _cstrFonts.Set(_T("none"));
    }
    else
    {
        LONG cpLine, yLine;
        POINT pt;
        CLinePtr rp(this);

        _cstrFonts.Set(_T(";"));
        rp.RpSet(iLine, 0);
        _fBuildFontList = TRUE;
        cpLine = CpFromLine(iLine, &yLine);
        pt.y = yLine;
        pt.x = rp.oi()->GetTextLeft() + 1;
        CpFromPointEx(iLine, yLine, cpLine, pt, NULL, NULL, NULL, CFP_IGNOREBEFOREAFTERSPACE,
                      NULL, NULL, NULL, NULL, NULL, NULL);
    }
    hr = THR(_cstrFonts.AllocBSTR(pbstrFonts));
    
    _fBuildFontList = FALSE;
    _cstrFonts.Free();
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\ebody.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ebody.cxx
//
//  Contents:   Body element class
//
//  Classes:    CBodyElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif


#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#define _cxx_
#include "body.hdl"

HRESULT InitTextSubSystem();

MtDefine(CBodyElement, Elements, "CBodyElement")


#ifndef NO_PROPERTY_PAGE
const CLSID * const CBodyElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CBackgroundPropertyPage,
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1        
    NULL
};
#endif // NO_PROPERTY_PAGE

CElement::ACCELS CBodyElement::s_AccelsBodyRun    = CElement::ACCELS (&CElement::s_AccelsElementRun,    IDR_ACCELS_BODY_RUN);

const CElement::CLASSDESC CBodyElement::s_classdesc =
{
    {
        &CLSID_HTMLBody,                // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE  |
        ELEMENTDESC_BODY      |
        ELEMENTDESC_NOTIFYENDPARSE,     // _dwFlags
        &IID_IHTMLBodyElement,          // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBodyElement,   // TearOff
    &CBodyElement::s_AccelsBodyRun          // _pAccelsRun
};

const long s_adispCommonProps[CBodyElement::NUM_COMMON_PROPS][2] =
{
    { DISPID_CDocument_bgColor,    DISPID_CBodyElement_bgColor},
    { DISPID_CDocument_linkColor,  DISPID_CBodyElement_link},
    { DISPID_CDocument_alinkColor, DISPID_CBodyElement_aLink},
    { DISPID_CDocument_vlinkColor, DISPID_CBodyElement_vLink},
    { DISPID_CDocument_fgColor,    DISPID_CBodyElement_text}
};

//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_TEAROFF(this, IHTMLBodyElement2, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

HRESULT
CBodyElement::CreateElement(CHtmTag *pht,
                            CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr;

    Assert(pht->IsBegin(ETAG_BODY));
    Assert(ppElement);

    hr = InitTextSubSystem();
    if(hr)
        goto Cleanup;

    *ppElement = new CBodyElement(pDoc);

    hr = (*ppElement) ? S_OK : E_OUTOFMEMORY;

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CBodyElement::CBodyElement
//
//---------------------------------------------------------------

CBodyElement::CBodyElement ( CDoc * pDoc )
  : CTxtSite ( ETAG_BODY, pDoc ) 
{
    _fSynthetic     = FALSE;
    _fInheritFF     = TRUE;     // Default for back compat, not CSS1Strict.
}

//+---------------------------------------------------------------
//
//  Member:     CBodyElement::Init2
//
//  Synopsis:   Final initializer
//
//---------------------------------------------------------------


HRESULT
CBodyElement::Init2(CInit2Context * pContext)
{
    HRESULT         hr;
    int             i;

    // before we do anything copy potentially initialized values
    // from the document's aa

    if (    pContext 
        &&  pContext->_pTargetMarkup 
        &&  pContext->_pTargetMarkup->HasDocument())
    {
        CDocument *     pDocument = pContext->_pTargetMarkup->Document();

        CAttrArray *pAA = *(pDocument->GetAttrArray());
        if (pAA)
        {
            CAttrValue * pAV = NULL;

            for (i = 0; i < NUM_COMMON_PROPS; i++)
            {
                pAV = pAA->Find(s_adispCommonProps[i][0]);
                if (pAV)
                {
                    // Implicit assumption that we're always dealing with I4's
                    hr = THR(AddSimple ( s_adispCommonProps[i][1], pAV->GetLong(), pAV->GetAAType() ));
                }
            }
        }
    }

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//-------------------------------------------------------------------------

void
CBodyElement::Notify ( CNotification * pNF )
{
    CDoc *  pDoc = Doc();

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYTABBABLE:
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *)pNF->DataAsPtr();
            BOOL            fInFrame    = FALSE;

            if (IsInMarkup())
            {
                CElement * pElemMaster = GetMarkup()->Root()->GetMasterPtr();

                if (pElemMaster)
                {
                    switch (pElemMaster->Tag())
                    {
                    case ETAG_FRAME:
                    case ETAG_IFRAME:
                        fInFrame = TRUE;
                        break;
                    }
                }
            }
            if (fInFrame || DocIsDeskTopItem(pDoc))
            {
                pQueryFocus->_fRetVal = TRUE;
            }
            else
            {
                pQueryFocus->_fRetVal = FALSE;
            }
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        {
            CSetFocus * pSetFocus       = (CSetFocus *)pNF->DataAsPtr();
            CMessage *  pMessage        = pSetFocus->_pMessage;

            // We want to turn on the focus rect only during certain
            // conditions:
            // 1) we are the current site
            // 2) we got here due to a tab/frametab key
            // 3) There is no selection or 0 len selection ( a Caret ! )
            Layout( GUL_USEFIRSTLAYOUT )->RequestFocusRect(
                    pDoc->_pElemCurrent == this
                &&  pMessage && pMessage->message == WM_KEYDOWN
                &&  (pDoc->HasSelection() ? ( pDoc->GetSelectionType() == SELECTION_TYPE_Caret) : TRUE));
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        {
            //
            // Alert the view that the top client element may have changed
            //

            pDoc->OpenView();

            Layout()->_fContentsAffectSize = FALSE;
            
            //
            // NOTE:
            //
            // Major hack code to simulate the setting of the top site
            //

            CMarkup *     pMarkup = GetMarkup();
            CElement *    pElemClient = pMarkup->GetElementClient();

            // If we are CSS1 compatible, we should *not* be inheriting formats
            // If we expect to run more in CSS1 compatible mode, we should change the default and turn the bit on instead of off.
            _fInheritFF = !pMarkup->IsHtmlLayout();

            // If the HTML element has had it's formats calc'd, it has made scrolling decisions without us.
            // We want it to be aware of its client before making scrolling decisions.  Let it redecide.
            if (pMarkup->IsHtmlLayout())
            {
                CElement * pHTML = pMarkup->GetHtmlElement();
                //this can happen to be NULL when DOM makes insertions
                if(pHTML)
                    pHTML->GetFirstBranch()->VoidFancyFormat();
            }


            // This could be NULL during DOM operations!
            if (pElemClient)
                pElemClient->ResizeElement(NFLAGS_SYNCHRONOUSONLY);

            if (pMarkup->IsPrimaryMarkup())
            {
                // Notify the view of a new possible top-most element
                SendNotification(NTYPE_VIEW_ATTACHELEMENT);

                if (!pDoc->_fCurrencySet)
                {
                    // EnterTree is not a good place to set currency, especially in
                    // design mode, because it could force a synchronous recalc by
                    // trying to set the caret. So, we delay setting the currency.
                    THR(GWPostMethodCall(pDoc,
                                         ONCALL_METHOD(CDoc,
                                                       DeferSetCurrency,
                                                       defersetcurrency),
                                         0, FALSE, "CDoc::DeferSetCurrency"));
                }
            }

            //
            // End hack
            //

            // Okay to display the document unless we have to scroll
            // at startup (have BookmarkTask)
            // TODO (dmitryt, track bug 112326) In some cases we still need change of load status here
            // because it doesn't happen in other places. RestartLoad and Refresh
            // both create a new markup, switch to it but don't request 
            // to go interactive before the very end then we loose opportunity to 
            // fire NavigateComplete2. 
            {

                BOOL fHasBookmarkTask = 
                       pMarkup->HasTransNavContext() 
                    && pMarkup->GetTransNavContext()->_pTaskLookForBookmark;

                BOOL fInRestartLoad = 
                       pMarkup->HasWindowPending() 
                    && pMarkup->GetWindowPending()->Window()->_fRestartLoad;

                BOOL fInRefresh = pMarkup->_fInRefresh;

                if (    pMarkup->HasWindowPending() 
                     && (fInRestartLoad || fInRefresh || !fHasBookmarkTask))
                {               
                    pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            // Notify the view that the top element may have left
            CMarkup *pMarkup = GetMarkup();
            if (pMarkup && pMarkup->IsPrimaryMarkup())
            {
                if (!(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    SendNotification(NTYPE_VIEW_DETACHELEMENT);
            }
        }
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     createTextRange
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+-------------------------------------------------------------------------
//
//  Method:     ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------


HRESULT 
CBodyElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = super::ShowTooltip(pmsg, pt);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBodyElement::GetBorderInfo, public
//
//  Synopsis:   Returns information about what borders we have.
//
//----------------------------------------------------------------------------
#define WIDTH_3DBORDER 2

inline void Set3DBorderEdgeInfo(BOOL fNeedBorderEdge, int cEdge,
                CBorderInfo * pborderinfo)
{
    if (fNeedBorderEdge)
    {
        pborderinfo->abStyles[cEdge] = fmBorderStyleSunken;
        pborderinfo->aiWidths[cEdge] = WIDTH_3DBORDER;
    }
}

BOOL
ShouldCallGetFrameOptions(CDoc * pDoc, CWindow * pWindow, CMarkup * pMarkup)
{   
    Assert(pDoc);
    Assert(pMarkup);

    if (    !pDoc->_fViewLinkedInWebOC
        ||  !pDoc->_fActiveDesktop
        ||  pWindow && !pWindow->IsPrimaryWindow()
        ||  !pMarkup->_fIsActiveDesktopComponent )
    {
        return TRUE;
    }
    return FALSE;
}

DWORD
CBodyElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (    IsInViewLinkBehavior( TRUE )
        ||  GetMarkup()->IsHtmlLayout() )
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }

    DWORD     dwRet = 0;
    CDoc    * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();
    CWindow * pWindow = pMarkup->Window() ? pMarkup->Window()->Window() : NULL;

    // if host says no border, then we have no border.
    // if the frame options say no border, we want no border. However (85696) in
    // design mode, if there are no borders, then there is no way to wysiwyg resize
    // and so VS/VID/et. al. want this turned off.  
    if (    ShouldCallGetFrameOptions(pDoc, pWindow, pMarkup)
        &&  (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0
        &&  (   (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0
              || (   pDoc->_fScriptletDoc                                   // a scriptlet doc with an iframe
                  && pMarkup->Root()->HasMasterPtr()                        //    should still have a border on the
                  && pMarkup->Root()->GetMasterPtr()->Tag() == ETAG_IFRAME  //    IFRAME (100612)
            )    )
        &&  pWindow
        &&  !   (   pMarkup->IsPrintMedia()
                &&  !pWindow->_pWindowParent
                )       
        &&  !   (   (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DOUTERBORDER) != 0 
                &&  pMarkup 
                &&  pMarkup->IsPrimaryMarkup()
        )       )
    {
        // raid 41791 3D border
        // For a (nested) frameset HTML document, Trident will draw 3D border
        // for the top-level frameset (pDocRoot->_pSiteRoot->_pElemClient is
        // a CFrameSetSite), so we don't need to draw 3D border edge(s) if
        // it (they) overlaps with top-level 3D borders.
        //
        BYTE b3DBorder;

        if (!pWindow->_pWindowParent)
        {
            pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                             | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
        }
        else
            pWindow->_pWindowParent->CheckDoc3DBorder(pWindow);

        b3DBorder = pWindow->_b3DBorder;

        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_TOP) != 0,
                SIDE_TOP,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_LEFT) != 0,
                SIDE_LEFT,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_BOTTOM) != 0,
                SIDE_BOTTOM,
                pborderinfo);
        Set3DBorderEdgeInfo(
                (b3DBorder & NEED3DBORDER_RIGHT) != 0,
                SIDE_RIGHT,
                pborderinfo);

        pborderinfo->wEdges = BF_RECT;

        // Unless we're the top, add space for the frame highlighting area
        if (pWindow->_pWindowParent)
        {
            pborderinfo->xyFlat = CFrameSetSite::iPixelFrameHighlightWidth;
            pborderinfo->aiWidths[SIDE_TOP]    += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_RIGHT]  += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_BOTTOM] += pborderinfo->xyFlat;
            pborderinfo->aiWidths[SIDE_LEFT]   += pborderinfo->xyFlat;
            pborderinfo->acrColors[SIDE_TOP][1]
                    = pborderinfo->acrColors[SIDE_RIGHT][1]
                    = pborderinfo->acrColors[SIDE_BOTTOM][1]
                    = pborderinfo->acrColors[SIDE_LEFT][1]
                    = (pDoc->_state < OS_UIACTIVE)
                            ? GetInheritedBackgroundColor()
                            : RGB(0,0,0); // black, for now
        }
    }

    dwRet = CElement::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    return dwRet;
}

//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT     hr          = S_OK;
    CElement *  pRoot       = GetMarkup()->Root();
    BOOL        fSlaveBody  = pRoot->HasMasterPtr();
    BOOL        fIsFrame    = FALSE;
    BOOL        fHtmlLayout = GetMarkup()->IsHtmlLayout();

    DWORD       dwWidth     = 0xffffffff;
    DWORD       dwHeight    = 0xffffffff;
    CDoc *      pDoc        = Doc();
 
    pCFI->PrepareFancyFormat();

    if (fSlaveBody)
    {
        CElement * pElement = pRoot->GetMasterPtr();

        // TODO: (lmollico, track bug 112336): should be more general
        if (    pElement->Tag() == ETAG_FRAME   
            ||  pElement->Tag() == ETAG_IFRAME)
        {
            fIsFrame = TRUE;

            dwWidth = DYNCAST(CFrameSite, pElement)->_dwWidth;
            dwHeight = DYNCAST(CFrameSite, pElement)->_dwHeight;
        }
    }

    //  If we are in a BackCompat (not strict CSS1 doctype) scenario,
    //  then the BODY controls the canvas 3D border, background, & scrollbar and
    //  relevant default formats need to be applied.
    if (!fHtmlLayout)
    {
        const CFancyFormat * pFFParent = NULL;
        CTreeNode * pNodeContext = pCFI->_pNodeContext;
        CTreeNode * pNode;
        BOOL        fGotMaster = FALSE;

        Assert(pNodeContext && SameScope(this, pNodeContext));

        //
        // Climb up the tree to find a background color, inherit an image url
        // from our parent.
        //
        for (pNode = pNodeContext->Parent(); pNode; pNode = pNode->Parent())
        {
            if (pNode->Element()->HasMasterPtr())
            {
                fGotMaster = TRUE;

                // Don't do this for frames or layout rects.
                CElement * pElemMaster = pNode->Element()->GetMasterPtr();

                if (   pElemMaster->TagType() == ETAG_GENERIC
                    && !pElemMaster->IsLinkedContentElement() )
                {
                    pNode = pElemMaster->GetFirstBranch();
                    if (!pNode)
                        break;
                }
            }
            pFFParent = pNode->GetFancyFormat();

            // Do NOT inherit the background-image from the containing doc
            if (!fGotMaster && !pCFI->_ff()._lImgCtxCookie)
                pCFI->_ff()._lImgCtxCookie = pFFParent->_lImgCtxCookie;

            if (pFFParent->_ccvBackColor.IsDefined())
                break;
        }

        if (pFFParent)
        {
            pCFI->_ff()._ccvBackColor = pFFParent->_ccvBackColor;
        }
        Assert(pCFI->_ff()._ccvBackColor.IsDefined());

        // Default BODY border.
        if (!fSlaveBody || fIsFrame)
        {
            pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
            pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);
            pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
            pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        }    

        // (greglett) Changing this code will affect the canvas scrollbar.
        // This code is more crusty (and erratic) than you think... be careful.
        if (    !fSlaveBody
            &&  !DocIsDeskTopItem(pDoc)
            &&  !(pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_SCROLL_NO | DOCHOSTUIFLAG_DIALOG))
           )
        {
            switch (GetAAscroll())
            {
            case bodyScrollno:
            case bodyScrollyes:
            case bodyScrollauto:
                break;

            default:
                // Body is always horizontal.
                pCFI->_ff().SetOverflowX(styleOverflowAuto);
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
                break;
            }
        }    

        if (GetAAscroll() == bodyScrollno)
        {
            pCFI->_ff().SetOverflowX(styleOverflowHidden);
            pCFI->_ff().SetOverflowY(styleOverflowHidden);
        }
    }    

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat (pCFI);
    if (hr)
        goto Cleanup;

    // Do special stuff for margins, etc.
    {
        pCFI->PrepareFancyFormat();

        // Do some of this stuff only for the main Body
        if (!fSlaveBody || fIsFrame)
        {
            CUnitValue cuvLeftMargin;
            CUnitValue cuvRightMargin;

            //
            // if the markup this body tag is on is the primary markup, then ask the container
            // for this information. Otherwise, set the values to -1. (old shdocvw default)
            //
            if (GetMarkup()->IsPrimaryMarkup())
            {
                ITargetFrame *  pTargetFrame = NULL;

                // query if the body is contained in a frame
                if (!pDoc->QueryService(IID_ITargetFrame, IID_ITargetFrame, (void **)&pTargetFrame))
                {
                    // query the frame for its margins
                    hr = THR(pTargetFrame->GetFrameMargins(&dwWidth, &dwHeight));

                    if (hr)
                    {
                        hr = S_OK;
                    }

                    pTargetFrame->Release();

                    fIsFrame = TRUE;
                }
            }

            //
            // NOTE (srinib) - for frames, if right/bottom margin is not specified and left/top
            // are specified through attributes then use left/top as default values.
            //

            //
            // If an explicit top margin is not specified, set it to the default value
            // 
            if (!pCFI->_pff->HasExplicitMargin(SIDE_TOP))
            {
                CUnitValue uv;
                if (dwHeight == 0xffffffff)
                {
                    uv.SetRawValue(s_propdescCBodyElementtopMargin.a.ulTagNotPresentDefault);
                }
                else
                {
                    uv.SetValue(long(dwHeight), CUnitValue::UNIT_PIXELS);
                }
                pCFI->_ff().SetMargin(SIDE_TOP, uv);
            }

            //
            // if an explicit bottom margin is not specified, set default bottom margin.
            //
            if (!pCFI->_pff->HasExplicitMargin(SIDE_BOTTOM))
            {
                CUnitValue uv;
                // if we are in a frame use top margin as default.
                if (fIsFrame && !pCFI->_fHasCSSTopMargin)
                {
                    uv = pCFI->_pff->GetMargin(SIDE_TOP);
                }
                else
                {
                    if (dwHeight == 0xffffffff)
                    {
                        uv.SetRawValue(s_propdescCBodyElementbottomMargin.a.ulTagNotPresentDefault);
                    }
                    else
                    {
                        uv.SetValue(long(dwHeight), CUnitValue::UNIT_PIXELS);
                    }
                }
                pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);
            }

            if (!pCFI->_pff->HasExplicitMargin(SIDE_LEFT))
            {
                CUnitValue uv;
                if (dwWidth ==  0xffffffff)  // margin specified on the frame
                {
                    uv.SetRawValue(s_propdescCBodyElementleftMargin.a.ulTagNotPresentDefault);
                }
                else
                {
                    uv.SetValue(long(dwWidth), CUnitValue::UNIT_PIXELS);
                }
                pCFI->_ff().SetMargin(SIDE_LEFT, uv);
            }

            if (!pCFI->_pff->HasExplicitMargin(SIDE_RIGHT))
            {
                CUnitValue uv;
                // if we are in a frame use left margin as default.
                if (fIsFrame && !pCFI->_fHasCSSLeftMargin)
                {
                    uv = pCFI->_pff->GetMargin(SIDE_LEFT);
                }
                else
                {
                    if (dwWidth ==  0xffffffff)  // margin specified on the frame
                    {
                        uv.SetRawValue(s_propdescCBodyElementrightMargin.a.ulTagNotPresentDefault);
                    }
                    else
                    {
                        uv.SetValue(long(dwWidth), CUnitValue::UNIT_PIXELS);
                    }
                }
                pCFI->_ff().SetMargin(SIDE_RIGHT, uv);
            }


            pCFI->_ff()._fHasMargins = TRUE;
        }

        // cache percent attribute information
        // BackCompat: BODY Margin acts like padding.  Set the Percent info if necessary.
        // CSS1Strict: BODY Margin acts like margin.
        if (    !fHtmlLayout
            &&  (   pCFI->_pff->GetMargin(SIDE_TOP).IsPercent()
                 || pCFI->_pff->GetMargin(SIDE_BOTTOM).IsPercent() ))
        {
            pCFI->_ff().SetPercentVertPadding(TRUE);
        }
        if (    !fHtmlLayout
            &&  (   pCFI->_pff->GetMargin(SIDE_LEFT).IsPercent()
                 || pCFI->_pff->GetMargin(SIDE_RIGHT).IsPercent() ))
        {
            pCFI->_ff().SetPercentHorzPadding(TRUE);
        }
        pCFI->UnprepareForDebug();
    }

    if (IsInViewLinkBehavior(FALSE))
    {
        CElement * pElemMaster = pRoot->GetMasterPtr();

        Assert(pElemMaster);
        if (    pElemMaster->IsInMarkup()
            &&  !fHtmlLayout )
        {
            CTreeNode *             pNode   = pElemMaster->GetFirstBranch();
            const CFancyFormat *    pFF     = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  *    pCF     = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            BOOL                    fVLF    = pCF->HasVerticalLayoutFlow();
            BOOL                    fWMU    = pCF->_fWritingModeUsed;

            pCFI->PrepareFancyFormat();
            if (!pFF->GetLogicalWidth(fVLF, fWMU).IsNullOrEnum())
            {
                CUnitValue uv;
                
                uv.SetPercent(100);
                pCFI->_ff().SetWidth(uv);
                pCFI->_ff().SetWidthPercent(TRUE);
            }
            if (!pFF->GetLogicalHeight(fVLF, fWMU).IsNullOrEnum())
            {
                CUnitValue uv;
                
                uv.SetPercent(100);
                pCFI->_ff().SetHeight(uv);
                pCFI->_ff().SetHeightPercent(TRUE);
            }
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
        pCFI->PrepareFancyFormat();
       
        if (!fHtmlLayout)
        {
            pCFI->_ff().SetHeightPercent(TRUE);
            pCFI->_ff().SetWidthPercent(TRUE);
        }
        //
        // if we are in print preview, and this is the contentbody of
        // a layout rect then we need to make sure scrollbars are turned 
        // off.  (110464)
        if (IsInViewLinkBehavior(TRUE))
        {
            Assert(   GetMarkup()
                   && GetMarkup()->Root()
                   && GetMarkup()->Root()->HasMasterPtr()
                   && GetMarkup()->Root()->GetMasterPtr()->IsLinkedContentElement() 
                   );

            pCFI->_ff().SetOverflowX(styleOverflowVisible);
            pCFI->_ff().SetOverflowY(styleOverflowVisible);
        }

        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBodyElement::OnPropertyChange
//
//  Synopsis:   Handles change of property on body tag
//
//  Arguments:  dispid:  id of the property changing
//              dwFlags: change flags
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBodyElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr != S_OK)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_BACKCOLOR:
    case DISPID_A_BACKGROUNDIMAGE:
        {
            CMarkup *pMarkup = GetMarkup();

            if (pMarkup && pMarkup->IsHtmlLayout())
            {
                CElement * pElement = pMarkup->GetHtmlElement();

                if (    pElement
                    &&  DYNCAST(CHtmlElement, pElement)->ShouldStealBackground())
                {
                    CLayoutInfo * pLayoutInfo = pElement->GetUpdatedNearestLayoutInfo();
                    if (pLayoutInfo)
                    {
                        pLayoutInfo->OnPropertyChange(dispid, dwFlags);   
                    }
                   
                    pElement->Invalidate();
                    break;
                }

            }

            // If we need to invalidate ourselves, do so here.
            Invalidate();
        }
        break;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBodyElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CBodyElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    RRETURN1(Layout( GUL_USEFIRSTLAYOUT )->GetFocusShape(lSubDivision, pdci, ppShape), S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member: WaitForRecalc
//
//-----------------------------------------------------------------------------

void
CBodyElement::WaitForRecalc()
{
    CFlowLayout * pFlowLayout = Layout();

    if (pFlowLayout)
    {
        pFlowLayout->WaitForRecalc(GetLastCp(), -1);
    }
}

CBase *
CBodyElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if (    CMarkup::IsTemporaryDISPID (dispID)
        &&  (   dispID != DISPID_EVPROP_ONSCROLL
            ||  !pMarkup                    
            ||  !pMarkup->IsHtmlLayout() ))
    {        
        if (!pMarkup)
            return NULL;
        else if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}

//+----------------------------------------------------------------------------
// Text subsystem initialization
//-----------------------------------------------------------------------------

void RegisterFETCs();
void ConvertDrawDCMapping(HDC);
WORD wConvScroll(WORD);

// System static variables

extern void DeInitFontCache();

HRESULT
InitTextSubSystem()
{
    static BOOL fTSInitted = FALSE;

    if (!fTSInitted)
    {
        InitUnicodeWrappers();              // Init UNICODE wrappers for Chicago
        RegisterFETCs();                    // Register new clipboard formats

        fTSInitted = TRUE;
    }

    return S_OK;
}

void
DeinitTextSubSystem ( )
{
    DeInitFontCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\dxfrobj.cxx ===
/*
 *  @doc INTERNAL
 *
 *  @module - DXFROBJ.C |
 *
 *      implementation of a generic IDataObject data transfer object.
 *      This object is suitable for use in OLE clipboard and drag drop
 *      operations
 *
 *  Author: <nl>
 *      alexgo (4/25/95)
 *
 *  Revisions: <nl>
 *      murrays (7/13/95) autodoc'd and added cf_RTF
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif


MtDefine(CTextXBag, Tree, "CTextXBag")
MtDefine(CTextXBag_prgFormats, CTextXBag, "CTextXBag::_prgFormats")

//
//  Common Data types
//

// If you change g_rgFETC[], change g_rgDOI[] and enum FETCINDEX and CFETC in
// _dxfrobj.h accordingly, and register nonstandard clipboard formats in
// RegisterFETCs(). Order entries in order of most desirable to least, e.g.,
// RTF in front of plain text.

FORMATETC g_rgFETC[] =
{
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_HTML
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTF
    {CF_UNICODETEXT,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    {CF_TEXT,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // Filename
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTFASTEXT
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORA
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORW
    {0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_FILECONTENTS
    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_SHELLIDLIST
    {0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_UNIFORMRESOURCELOCATOR
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbObject
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// EmbSource
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // ObjDesc
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // LnkSource
//    {CF_METAFILEPICT,   NULL, DVASPECT_CONTENT, -1, TYMED_MFPICT},
//    {CF_DIB,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
//    {CF_BITMAP,         NULL, DVASPECT_CONTENT, -1, TYMED_GDI},
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // RTF with no objs
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Text with objs
//    {0,                 NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE},// Richedit
};

const int CFETC = ARRAY_SIZE( g_rgFETC );



//TODO v-richa check the added members for correctness
const DWORD g_rgDOI[] =
{
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
    DOI_CANPASTEPLAIN,
//    DOI_CANPASTEOLE,
    DOI_CANPASTEPLAIN,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
    DOI_NONE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_NONE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTEOLE,
//    DOI_CANPASTERICH,
//    DOI_CANPASTERICH,
//    DOI_CANPASTERICH
};


/*
 *  RegisterFETCs()
 *
 *  @func
 *      Register nonstandard format ETCs.  Called when DLL is loaded
 *
 *  @todo
 *      Register other RTF formats (and add places for them in g_rgFETC[])
 */
void RegisterFETCs()
{
    if(!g_rgFETC[iHTML].cfFormat)
        g_rgFETC[iHTML].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("HTML Format");

    if(!g_rgFETC[iRtfFETC].cfFormat)
        g_rgFETC[iRtfFETC].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("Rich Text Format");

    if(!g_rgFETC[iRtfAsTextFETC].cfFormat)
        g_rgFETC[iRtfAsTextFETC].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormatA("RTF As Text");

    if(!g_rgFETC[iFileDescA].cfFormat)
        g_rgFETC[iFileDescA].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);

    if(!g_rgFETC[iFileDescW].cfFormat)
        g_rgFETC[iFileDescW].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);

    if(!g_rgFETC[iFileContents].cfFormat)
        g_rgFETC[iFileContents].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);

    if(!g_rgFETC[iShellIdList].cfFormat)
        g_rgFETC[iShellIdList].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);

    if(!g_rgFETC[iUniformResourceLocator].cfFormat)
        g_rgFETC[iUniformResourceLocator].cfFormat
            = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLURL);

//    if(!g_rgFETC[iRichEdit].cfFormat)
//        g_rgFETC[iRichEdit].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("RICHEDIT");

//    if(!g_rgFETC[iObtDesc].cfFormat)
//        g_rgFETC[iObtDesc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_OBJECTDESCRIPTOR);

//    if(!g_rgFETC[iEmbObj].cfFormat)
//        g_rgFETC[iEmbObj].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_EMBEDDEDOBJECT);

//    if(!g_rgFETC[iEmbSrc].cfFormat)
//        g_rgFETC[iEmbSrc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_EMBEDSOURCE);

//    if(!g_rgFETC[iLnkSrc].cfFormat)
//        g_rgFETC[iLnkSrc].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_LINKSOURCE);

//    if(!g_rgFETC[iRtfNoObjs].cfFormat)
//        g_rgFETC[iRtfNoObjs].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("Rich Text Format Without Objects");

//    if(!g_rgFETC[iTxtObj].cfFormat)
//        g_rgFETC[iTxtObj].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA("RichEdit Text and Objects");

//    if(!g_rgFETC[iFilename].cfFormat)
//        g_rgFETC[iFilename].cfFormat
//            = (CLIPFORMAT)RegisterClipboardFormatA(CF_FILENAME);
}


//
//  CTextXBag PUBLIC methods
//

/*
 *  CTextXBag::EnumFormatEtc (dwDirection, ppenumFormatEtc)
 *
 *  @mfunc
 *      returns an enumerator which lists all of the available formats in
 *      this data transfer object
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      we have no 'set' formats for this object
 */
STDMETHODIMP CTextXBag::EnumFormatEtc(
    DWORD dwDirection,                  // @parm DATADIR_GET/SET
    IEnumFORMATETC **ppenumFormatEtc)   // @parm out parm for enum FETC interface
{
    HRESULT hr = NOERROR;
    FORMATETC*      paryFETC = NULL;
    IEnumFORMATETC* pIEFC = NULL;

    *ppenumFormatEtc = NULL;

    if (_pLinkDataObj && (_cTotal < _cFormatMax))
    {
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileDescA];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileDescW];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFileContents];
        _prgFormats[ _cTotal++ ] = g_rgFETC[iUniformResourceLocator];
    }

    if (dwDirection == DATADIR_GET)
    {
        if ( _pGenDO )
        {
            //
            // We have a generic dataobject.
            // We create a new array that contains the PEFTC's from both our stuff
            // and that of the generic dataobject
            //
             FORMATETC* pcurFETC = NULL;
             
            int size = _pGenDO->Size();
            int i = 0;
#if DBG == 1
            ULONG ctActual; 
#endif            
            paryFETC = new FORMATETC[ _cTotal + size ];
            if ( ! paryFETC )
                goto Error;

            for ( i = 0, pcurFETC = paryFETC; i < _cTotal; i++, pcurFETC++ )
                *pcurFETC = _prgFormats[i];

            hr = THR( _pGenDO->EnumFormatEtc( dwDirection, & pIEFC ));
            if ( FAILED(hr))
                goto Cleanup;
                
#if DBG == 1
            hr = THR( pIEFC->Next( size,pcurFETC,&ctActual  ));
            Assert( ctActual == (unsigned) size );
#else
            hr = THR( pIEFC->Next( size,pcurFETC, NULL ));
#endif            
            if( FAILED( hr ))
                goto Cleanup;
                
            hr = CEnumFormatEtc::Create(paryFETC, _cTotal + size , ppenumFormatEtc);
        }
        else
        {
            hr = CEnumFormatEtc::Create(_prgFormats, _cTotal, ppenumFormatEtc);
        }
    }
    
Cleanup:    
    delete[] paryFETC;
    ReleaseInterface( pIEFC );
    
    return hr;

Error:
    return E_OUTOFMEMORY;
}

/*
 *  CTextXBag::GetData (pformatetcIn, pmedium)
 *
 *  @mfunc
 *      retrieves data of the specified format
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      The three formats currently supported are CF_UNICODETEXT on
 *      an hglobal, CF_TEXT on an hglobal, and CF_RTF on an hglobal
 *
 *  @todo (alexgo): handle all of the other formats as well
 */
STDMETHODIMP CTextXBag::GetData(
    FORMATETC *pformatetcIn,
    STGMEDIUM *pmedium )
{
    CLIPFORMAT  cf = pformatetcIn->cfFormat;
    HRESULT     hr = DV_E_FORMATETC;
    HGLOBAL     hGlobal = NULL ;
    
    if (! (pformatetcIn->tymed & TYMED_HGLOBAL) )
        goto Cleanup;

    memset(pmedium, '\0', sizeof(STGMEDIUM));
    pmedium->tymed = TYMED_NULL;

    if (cf == cf_HTML)
        hGlobal = _hCFHTMLText;

    else if (cf == CF_UNICODETEXT)
        hGlobal = _hUnicodeText;

    else if (cf == CF_TEXT)
        hGlobal = _hText;

    else if (cf == cf_RTF || cf == cf_RTFASTEXT)
    {
        if (!_fRtfConverted && _hRTFText)
        {
            HGLOBAL hRTFText;
            
            hr = THR(ConvertHTMLToRTF(_hRTFText, &hRTFText));
            if (hr)
                goto Cleanup;

            GlobalFree(_hRTFText);
            _hRTFText = hRTFText;                
            _fRtfConverted = TRUE;
        }
        hGlobal = _hRTFText;
    }
    else if ( _pGenDO )
    {
        hr = THR( _pGenDO->GetData( pformatetcIn,pmedium)) ;
        goto Cleanup;
    }
    else
        goto Cleanup;

    if (hGlobal)
    {
        pmedium->tymed   = TYMED_HGLOBAL;
        pmedium->hGlobal = DuplicateHGlobal(hGlobal);
        if (!pmedium->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = S_OK;
    }

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->GetData(pformatetcIn, pmedium);
    RRETURN(hr);
}

/*
 *  CTextXBag::QueryGetData (pformatetc)
 *
 *  @mfunc
 *      Queries whether the given format is available in this data object
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTextXBag::QueryGetData(
    FORMATETC *pformatetc )     // @parm FETC to look for
{
    DWORD   cFETC = _cTotal;
    CLIPFORMAT cf = pformatetc->cfFormat;
    HRESULT hr = DV_E_FORMATETC;
    
    while (cFETC--)             // Maybe faster to search from start
    {
        if( cf == _prgFormats[cFETC].cfFormat && 
            pformatetc->tymed & TYMED_HGLOBAL )
        {
            // Check for RTF handle even if we claim to support the format
            if (_hRTFText ||
                (cf != cf_RTF && cf != cf_RTFASTEXT))
            {
                hr = NOERROR;
                goto Cleanup;
            }
        }
    }

    if ( _pGenDO )
    {
        hr = _pGenDO->QueryGetData( pformatetc );
    }
    else if (_pLinkDataObj)
        hr = _pLinkDataObj->QueryGetData(pformatetc);

Cleanup:

    return hr;
}

STDMETHODIMP CTextXBag::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    HRESULT hr = S_OK;

    Assert(pformatetc && pmedium);
    switch (pformatetc->cfFormat)
    {
    case CF_UNICODETEXT:
        if (_hUnicodeText)
        {
            GlobalFree(_hUnicodeText);
        }
        _hUnicodeText = pmedium->hGlobal;

        //
        // We don't set to null null strings - to mimic IE5 behavior
        //
        SetTextHelper(NULL, NULL, 0, 0, 0, &_hUnicodeText, iUnicodeFETC, FALSE );
        break;
    case CF_TEXT:
        if (_hText)
        {
            GlobalFree(_hText);
        }
        _hText = pmedium->hGlobal;

        //
        // We don't set to null null strings - to mimic IE5 behavior
        //        
        SetTextHelper(NULL, NULL, 0, 0, 0, &_hText, iAnsiFETC, FALSE );
        break;

    default:
        if ( ! _pGenDO )
        {
            _pGenDO = new CGenDataObject( _pDoc );
        }

        hr = THR( _pGenDO->SetData(pformatetc,pmedium, fRelease ));
        
        break;
    }
    return hr;
}

STDMETHODIMP CTextXBag::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (    _pSelDragDropSrcInfo
        &&  (iid == IID_IUnknown))
        return _pSelDragDropSrcInfo->QueryInterface(iid, ppv);
    else
        return super::QueryInterface(iid, ppv);
}

STDMETHODIMP_(ULONG) CTextXBag::AddRef()
{
    return _pSelDragDropSrcInfo ? _pSelDragDropSrcInfo->AddRef() : super::AddRef();
}

STDMETHODIMP_(ULONG) CTextXBag::Release()
{
    return _pSelDragDropSrcInfo ? _pSelDragDropSrcInfo->Release() : super::Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::Create
//
//  Synopsis:   Static creator of text xbags
//
//  Arguments:  pMarkup         The markup that owns the selection
//              dwFlags         Flags
//              ppRange         Array of ptrs to ranges
//              cRange          Number of items in above array
//              ppTextXBag      Returned xbag.
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::Create(CMarkup *             pMarkup,
                  DWORD                 dwFlags,
                  ISegmentList *        pSegmentList,
                  BOOL                  fDragDrop,
                  CTextXBag **          ppTextXBag,
                  CSelDragDropSrcInfo * pSelDragDropSrcInfo /* = NULL */)
{
    HRESULT hr;

    CTextXBag * pTextXBag = new CTextXBag();

    if (!pTextXBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pTextXBag->_pSelDragDropSrcInfo = pSelDragDropSrcInfo;

    if (fDragDrop)
    {
        pTextXBag->_pDoc = pMarkup->Doc();
    }

    hr = THR(pTextXBag->SetKeyState());
    if (hr)
        goto Error;

    hr = THR(pTextXBag->FillWithFormats(pMarkup, dwFlags, pSegmentList));
    if (hr)
        goto Error;

Cleanup:
    *ppTextXBag = pTextXBag;

    RRETURN(hr);

Error:
    delete pTextXBag;
    pTextXBag = NULL;
    goto Cleanup;
}

//
//  CTextXBag PRIVATE methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::CTextXBag
//
//  Synopsis:   Private ctor
//
//----------------------------------------------------------------------------

CTextXBag::CTextXBag()
{
    _ulRefs       = 1;
    _cTotal       = CFETC;
    _cFormatMax   = 1;
    _prgFormats   = g_rgFETC;
    _hText        = NULL;
    _hUnicodeText = NULL;
    _hRTFText     = NULL;
    _hCFHTMLText  = NULL;
    _pLinkDataObj = NULL;
    _pGenDO       = NULL;
    _fRtfConverted = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::~CTextXBag
//
//  Synopsis:   Private dtor
//
//----------------------------------------------------------------------------

CTextXBag::~CTextXBag()
{
    if( _prgFormats && _prgFormats != g_rgFETC)
    {
        delete [] _prgFormats;
    }

    if (_hText)
        GlobalFree(_hText);

    if (_hUnicodeText)
        GlobalFree(_hUnicodeText);

    if (_hRTFText)
        GlobalFree(_hRTFText);

    if (_hCFHTMLText)
        GlobalFree(_hCFHTMLText);

    if ( _pGenDO )
        _pGenDO->Release();
}


//+------------------------------------------------------------------------/
//
//  Member:     CTextXBag::SetKeyState
//
//  Synopsis:   Sets the _dwButton member of the CTextXBag
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetKeyState()
{
    static int  vk[] =
    {
        VK_LBUTTON,     // MK_LBUTTON = 0x0001
        VK_RBUTTON,     // MK_RBUTTON = 0x0002
        VK_SHIFT,       // MK_SHIFT   = 0x0004
        VK_CONTROL,     // MK_CONTROL = 0x0008
        VK_MBUTTON,     // MK_MBUTTON = 0x0010
        VK_MENU,        // MK_ALT     = 0x0020
    };

    int     i;
    DWORD   dwKeyState = 0;

    for (i = 0; i < ARRAY_SIZE(vk); i++)
    {
        if (GetKeyState(vk[i]) & 0x8000)
        {
            dwKeyState |= (1 << i);
        }
    }

    _dwButton = dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);

    return S_OK;
}


//+------------------------------------------------------------------------/
//
//  Member:     CTextXBag::FillWithFormats
//
//  Synopsis:   Fills the text bag with the formats it supports
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::FillWithFormats(CMarkup *    pMarkup,
                           DWORD        dwFlags,
                           ISegmentList * pSegmentList )
{
    typedef HRESULT (CTextXBag::*FnSet)(CMarkup*, DWORD, ISegmentList *);

    static FnSet aFnSet[] = {
        SetText,
        SetUnicodeText,
        SetCFHTMLText,
#ifndef NO_RTF
        SetLazyRTFText
#endif // !NO_RTF
    };

    HRESULT hr = S_OK;
    int     n;

    // Allocate our _prgFormats array
    _cFormatMax = ARRAY_SIZE(aFnSet) + 3;
    _cTotal     = 0;
    _prgFormats = new(Mt(CTextXBag_prgFormats)) FORMATETC[_cFormatMax];
    if (NULL == _prgFormats)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for (n = 0; n < ARRAY_SIZE(aFnSet); ++n)
    {
        // If one format fails to copy, do not abort all formats.
        IGNORE_HR(CALL_METHOD( this, aFnSet[n], (pMarkup, dwFlags, pSegmentList)));
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT 
CTextXBag::GetDataObjectInfo(IDataObject *   pdo,        // @parm data object to get info on
                             DWORD *         pDOIFlags)  // @parm out parm for info
{
    DWORD       i;
    FORMATETC * pfetc = g_rgFETC;

    for( i = 0; i < DWORD(CFETC); i++, pfetc++ )
    {
        if( pdo->QueryGetData(pfetc) == NOERROR )
            *pDOIFlags |= g_rgDOI[i];
    }
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTextXBag::GetHTMLText
//
//  Synopsis:   Converts the SegmentList into text stored in an hglobal
//
//----------------------------------------------------------------------------


HRESULT
CTextXBag::GetHTMLText(
    HGLOBAL      *  phGlobal, 
    ISegmentList *  pSegmentList,
    CMarkup      *  pMarkup, 
    DWORD           dwSaveHtmlMode,
    CODEPAGE        codepage, 
    DWORD           dwStrWrBuffFlags )
{
    HGLOBAL                 hGlobal  = NULL;   // Global memory handle
    LPSTREAM                pIStream = NULL;   // IStream pointer
    HRESULT                 hr;
    CDoc                    *pDoc;
    ISegment                *pISegment = NULL;
    ISegmentListIterator    *pIter = NULL;

    //
    // Do the prep work
    //
    hr = THR(CreateStreamOnHGlobal(NULL, FALSE, &pIStream));
    if (hr)
        goto Error;

    pDoc = pMarkup->Doc();
    Assert( pDoc );


    //
    // Use a scope to clean up the StreamWriteBuff
    //

    {
        CMarkupPointer      mpStart( pDoc ), mpEnd( pDoc );
        CStreamWriteBuff    StreamWriteBuff(pIStream, codepage);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        StreamWriteBuff.SetFlags(dwStrWrBuffFlags);
      
        //
        // Save the segments using the range saver
        //
        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Error;

        BOOL fEmpty = FALSE;

        hr = THR( pSegmentList->IsEmpty( &fEmpty ) );
        if( hr )
            goto Error;

        if (fEmpty)
            goto Error;

        hr = THR( pIter->Current(&pISegment) );
        if( hr )
            goto Error;
        
        hr = THR( pISegment->GetPointers(&mpStart, &mpEnd) );
        if( hr )
            goto Error;

        {
            CRangeSaver rs( &mpStart, &mpEnd, dwSaveHtmlMode , &StreamWriteBuff, mpStart.Markup() );
            hr = THR( rs.SaveSegmentList(pSegmentList, pMarkup));
            if (hr)
                goto Error;
        }

        StreamWriteBuff.Terminate();    // appends a null character
    }

    //
    // Wrap it up
    //
    hr = THR(GetHGlobalFromStream(pIStream, &hGlobal));
    if (hr)
        goto Error;

Cleanup:
    ReleaseInterface( pIStream );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegment );
    *phGlobal = hGlobal;
    RRETURN(hr);

Error:
    if (hGlobal)
    {
        GlobalFree(hGlobal);
        hGlobal = NULL;
    }
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetTextHelper
//
//  Synopsis:   Gets text in a variety of formats
//
//  Argument:   pTxtSite:           The text site under which to get the text from
//              ppRanges:           Text ranges to save text from
//              cRanges:            Count of ppRanges
//              dwSaveHtmlFlags:    format to save in
//              cp:                 codepage to save in
//              dwStmWrBuffFlags:   stream write buffer flags
//              phGlobalText:       hGlobal to get back
//              iFETCIndex:         _prgFormat index, or -1 to not set it
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetTextHelper(CMarkup *      pMarkup,
                         ISegmentList * pSegmentList,
                         DWORD          dwSaveHtmlFlags,
                         CODEPAGE       cp,
                         DWORD          dwStmWrBuffFlags,
                         HGLOBAL *      phGlobalText,
                         int            iFETCIndex,
                         BOOL           fSetToNull /*=TRUE*/)                         
{
    HRESULT hr = S_OK;
    HGLOBAL hText = NULL;

    Assert(_cTotal < _cFormatMax);

    // Make sure not to crash if we are out of space for this format.
    if (_cTotal >= _cFormatMax)
        return S_OK;

    if (pSegmentList)
    {
        hr = THR(GetHTMLText( 
                    &hText, pSegmentList, pMarkup, 
                    dwSaveHtmlFlags, cp, dwStmWrBuffFlags));
        if (hr || !hText)
            goto Error;
    }
    else
    {
        Assert(!pMarkup && !dwSaveHtmlFlags && !cp && !dwStmWrBuffFlags);
        Assert(phGlobalText);
        Assert(iUnicodeFETC == iFETCIndex || iAnsiFETC == iFETCIndex);
        hText = *phGlobalText;
        // remove data from FETC array.
        if (!hText)
        {
            int i,j;
            CLIPFORMAT cfFormat = (iUnicodeFETC == iFETCIndex) ? CF_UNICODETEXT : CF_TEXT;
            for (i = 0; i < _cTotal; i++)
            {
                if (_prgFormats[i].cfFormat == cfFormat)
                {
                    Assert(_cTotal > 0);
                    _cTotal--;
                    for (j = i; j < _cTotal; j++)
                        _prgFormats[j] = _prgFormats[j+1];

                    break;
                }
            }

            goto Cleanup;
        }
    }

    // if the text length is zero, pretend as if the format is
    // unavailable (see bug #52407)
    if (iUnicodeFETC == iFETCIndex || iAnsiFETC == iFETCIndex)
    {
        BOOL    fEmpty;

        Assert(hText);

        LPVOID pText= GlobalLock(hText);
        if (pText == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        if( iAnsiFETC == iFETCIndex ) 
        {
            fEmpty= *((char *)pText) == 0;
        }
        else
        {
            // Please don't use strlen on unicode strings.
            fEmpty= *((TCHAR *)pText) == 0;
        }
        GlobalUnlock(hText);
        if (fEmpty && fSetToNull )
        {
            GlobalFree(hText);
            hText = NULL;
            goto Cleanup;
        }
    }

    if (iFETCIndex != -1)
    {
        _prgFormats[ _cTotal++ ] = g_rgFETC[iFETCIndex];
    }

Cleanup:

    *phGlobalText = hText;

    RRETURN(hr);

Error:
    if (hText)
    {
        GlobalFree(hText);
        hText = NULL;
    }

    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetText
//
//  Synopsis:   Gets ansi plaintext in CP_ACP
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetText(CMarkup *      pMarkup,
                   DWORD          dwFlags,
                   ISegmentList * pSegmentList )
{
    DWORD dwBuffFlags = WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_FORMATTED_PLAINTEXT;
    DWORD dwHTMLFlags = RSF_SELECTION|RSF_NO_ENTITIZE_UNKNOWN;

    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
    {
        dwBuffFlags |= WBF_KEEP_BREAKS;
    }
    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    RRETURN( SetTextHelper( pMarkup, pSegmentList,
                            dwHTMLFlags,
                            g_cpDefault, dwBuffFlags, &_hText, iAnsiFETC ) );
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetUnicodeText
//
//  Synopsis:   Gets unicode plaintext
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetUnicodeText(CMarkup *      pMarkup,
                          DWORD          dwFlags,
                          ISegmentList * pSegmentList )
{
    DWORD dwBuffFlags = WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_FORMATTED_PLAINTEXT;
    DWORD dwHTMLFlags = RSF_SELECTION;

    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
    {
        dwBuffFlags |= WBF_KEEP_BREAKS;
    }
    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    RRETURN(SetTextHelper(pMarkup, pSegmentList,
                          dwHTMLFlags, CP_UCS_2,
                          dwBuffFlags, &_hUnicodeText, iUnicodeFETC));
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetCFHTMLText
//
//  Synopsis:   Gets HTML with CF_HTML header in UTF-8
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::SetCFHTMLText(CMarkup *      pMarkup,
                         DWORD          dwFlags,
                         ISegmentList * pSegmentList )
{
    HRESULT hr = S_OK;
    DWORD dwHTMLFlags = RSF_CFHTML;

    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    if (dwFlags & CREATE_FLAGS_SupportsHtml)
    {
        hr = THR(SetTextHelper(pMarkup, pSegmentList,
            dwHTMLFlags, CP_UTF_8, WBF_NO_NAMED_ENTITIES, &_hCFHTMLText, iHTML));
    }

    RRETURN(hr);
}

#ifndef NO_RTF
//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::SetLazyRTFText
//
//  Synopsis:   Gets RTF from the HTML
//
//-------------------------------------------------------------------------
HRESULT
CTextXBag::SetLazyRTFText(CMarkup *     pMarkup,
                          DWORD          dwFlags,
                          ISegmentList * pSegmentList )
{
#ifdef WINCE
    return S_OK;
#else
    if (!pMarkup->Doc()->RtfConverterEnabled())
        return S_OK;

    HRESULT hr = S_OK;
    HGLOBAL hHTMLText = NULL;     
    DWORD dwHTMLFlags = RSF_FOR_RTF_CONV|RSF_FRAGMENT;
    
    Assert(_cTotal < _cFormatMax);

    // Do not dump out RTF for intrinsics
    if (!(dwFlags & CREATE_FLAGS_SupportsHtml))
        return S_OK;

    // Make sure not to crash if we are out of space for this format.
    if (_cTotal >= _cFormatMax)
        return S_OK;

    if( dwFlags & CREATE_FLAGS_NoIE4SelCompat )
    {
        dwHTMLFlags |= RSF_NO_IE4_COMPAT_SEL;
    }

    //
    //  For the RTF converter, do not use name entities, since our name list
    //  can be more recent.  Save in UTF-8 so that we can at least represent
    //  the unicode for every character.
    //
    hr = THR(SetTextHelper(pMarkup, pSegmentList,
        dwHTMLFlags, CP_UTF_8,
        WBF_NO_NAMED_ENTITIES, &hHTMLText, -1));

    if (hr)
        goto Cleanup;

    // Add RTF to the clipboard formats only if conversion succeeded
    _prgFormats[ _cTotal++ ] = g_rgFETC[iRtfFETC];
    _fRtfConverted = FALSE;
    _hRTFText = hHTMLText;

Cleanup:
    RRETURN(hr);
#endif // WINCE
}

//+------------------------------------------------------------------------
//
//  Member:     CTextXBag::ConvertHTMLToRTF
//
//  Synopsis:   Calls the RTF to HTML converter
//
//-------------------------------------------------------------------------

HRESULT
CTextXBag::ConvertHTMLToRTF(HGLOBAL hHTMLText, HGLOBAL *phRTFText)
{
    HRESULT              hr = S_OK;
    HGLOBAL              hRTFText = NULL;
    LPSTR                pszHtml;

    Assert(phRTFText);

    *phRTFText = NULL;
    
    pszHtml = (LPSTR)GlobalLock(hHTMLText);
    if (!pszHtml)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(CRtfToHtmlConverter::StringHtmlToStringRtf(NULL, pszHtml, &hRTFText));

    GlobalUnlock(hHTMLText);

    if (hr)
        goto Cleanup;
    
    *phRTFText = hRTFText;

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_RTF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\flownode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       flownode.cxx
//
//  Contents:   Routines for managing display tree nodes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

extern const ZERO_STRUCTS g_Zero;

ExternTag(tagCalcSize);

//+----------------------------------------------------------------------------
//
//  Member:     AddLayoutDispNode
//
//  Synopsis:   Add, as a sibling of the passed display node,
//              the display node of passed layout
//
//  Arguments:  pTreeNode    - CTreeNode from which to obtain the layout
//              pLayout      - Layout whose display node is to be added
//              dx, dy       - Left/top offset to set on the node
//              pDispSibling - CDispNode that is the left-hand sibling
//              dwBlockIDParent - Layout block ID of this parent line array
//
//  Returns:    Node to be used as the next sibling if successful, NULL otherwise
//
//-----------------------------------------------------------------------------

CDispNode *
CDisplay::AddLayoutDispNode(
    CParentInfo *   ppi,
    CLayout *       pLayout,
    long            dx,
    long            dy,
    CDispNode *     pDispSibling
    )
{
    CDispNode   * pDispNode;
    CFlowLayout * pFL = GetFlowLayout();

    Assert(pLayout);
    Assert(!pLayout->IsDisplayNone());

    pDispNode = pLayout->GetElementDispNode();

    Assert(!pDispNode || pDispSibling != pDispNode);

    //
    //  Insert the node if it exists
    //  (Nodes will not exist for unmeasured elements, such as hidden INPUTs or
    //   layouts which have display set to none)
    //

    if (pDispNode)
    {
        Assert(pDispNode->IsFlowNode());

        //
        // If no sibling was provided, insert directly under the content containing node
        //

        if (!pDispSibling)
        {
            //
            //  Ensure the display node can contain children
            //

            if (!pFL->EnsureDispNodeIsContainer())
                goto Cleanup;

            pDispSibling = pFL->GetFirstContentDispNode();


            if (!pDispSibling)
                goto Cleanup;
        }

        pDispSibling->InsertSiblingNode(pDispNode, CDispNode::after);

        //
        //  Position the node
        //
        pLayout->SetPosition(CPoint(dx, dy), TRUE);

        pDispSibling = pDispNode;
    }
Cleanup:
    return pDispSibling;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetPreviousDispNode
//
//  Synopsis:   Given a cp, find the display node just before that which
//              would contain the cp
//
//  Arguments:  cp - cp for searching
//              dwBlockID - layout block ID
//
//  Returns:    Previous CDispNode (if found), NULL otherwise
//
//-----------------------------------------------------------------------------

CDispNode *
CDisplay::GetPreviousDispNode(
    long    cp,
    long    iLineStart
    )
{
    CFlowLayout * pFlowLayout       = GetFlowLayout();
    CDispNode   * pDispNodeOwner    = pFlowLayout->GetElementDispNode();
    CDispNode   * pDispNodeSibling  = NULL;


    Assert(pDispNodeOwner);

    if(pDispNodeOwner->IsContainer())
    {
        CDispNode * pDispNode = pFlowLayout->GetFirstContentDispNode();

        void *      pvOwner;
        CElement *  pElement;

        Assert(pDispNode);

        pDispNodeSibling = pDispNode;

        //
        // Since the first node is the flownode, we can just skip it.
        //

        for (pDispNode = pDispNode->GetNextFlowNode();
             pDispNode;
             pDispNode = pDispNode->GetNextFlowNode())
        {
            CDispClient * pDispClient = pFlowLayout;

            //
            // if the disp node corresponds to the text flow,
            // the cookie stores the line index from where the
            // current text flow node starts.
            //
            if (pDispNode->GetDispClient() == pDispClient)
            {
                if(iLineStart <= (LONG)(LONG_PTR)pDispNode->GetExtraCookie())
                    break;
            }
            else
            {
                pDispNode->GetDispClient()->GetOwner(pDispNode, &pvOwner);

                if (pvOwner)
                {
                    pElement = DYNCAST(CElement, (CElement *)pvOwner);
                    if(pElement->GetFirstCp() >= cp)
                        break;
                }
            }

            pDispNodeSibling = pDispNode;
        }
    }

    return pDispNodeSibling;
}


//+----------------------------------------------------------------------------
//
//  Member:     AdjustDispNodes
//
//  Synopsis:   Adjust display nodes after text measurement
//              * Newly added display nodes may be adjusted horizontally for RTL
//              * Display nodes following last node produced by this measrurement 
//                pass are extracted or translated
//
//  Arguments:  pdnLastUnchanged - Left-hand sibling of first display node affected by change
//                                 NULL in clean recalc
//              pdnLastChanged   - Last display node affected (added) by calculation
//                                 NULL if no new nodes added
//              pled             - Current CLed (may be NULL)
//
//-----------------------------------------------------------------------------

void
CDisplay::AdjustDispNodes(
    CDispNode * pdnLastUnchanged,
    CDispNode * pdnLastChanged,
    CLed *      pled
    )
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CDisplay::AdjustDispNodes() LU:0x%x LC:0x%x LED:0x%x", pdnLastUnchanged, pdnLastChanged, pled ));
    CDispNode * pDispNodeOwner = GetFlowLayout()->GetElementDispNode();

    if (pDispNodeOwner && pDispNodeOwner->IsContainer())
    {

        // If last changed node is NULL, it means there are no new nodes. Adjust everything.
        if (!pdnLastChanged)
        {
            pdnLastChanged = GetFlowLayout()->GetFirstContentDispNode();
            if (!pdnLastChanged)
            {
                TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::AdjustDispNodes()" ));
                return;
            }
        }

        //
        // Adjust dispay nodes following the newly calculated ones
        //
        CDispNode* pDNAdjustFrom = pdnLastChanged->GetNextFlowNode();

        if (pDNAdjustFrom)
        {
            if (    !pled
                ||  pled->_iliMatchNew == MAXLONG)
            {
                GetFlowLayout()->ExtractDispNodes(pDNAdjustFrom);
            }
            else
            {
                //
                // Update the cookie on text disp nodes and destroy
                // any that lie in the dirty line's range
                if (_fHasMultipleTextNodes)
                {
                    CDispClient * pDispClient = GetFlowLayout();
                    CDispNode * pDispNode = pDNAdjustFrom;
                    
                    while (pDispNode)
                    {
                        CDispNode * pDispNodeCur = pDispNode;

                        pDispNode = pDispNode->GetNextFlowNode();

                        if (pDispNodeCur->GetDispClient() == pDispClient)
                        {
                            long iLine = (LONG)(LONG_PTR)pDispNodeCur->GetExtraCookie();

                            if (iLine < pled->_iliMatchOld)
                            {
                                Assert(!pDispNodeCur->IsOwned());

                                if (pDNAdjustFrom == pDispNodeCur)
                                {
                                    pDNAdjustFrom = pDispNode;
                                }

                                //
                                // Extract the disp node and destroy it
                                //
                                // NOTE: (donmarsh) - do we really have to extract
                                // these from the tree?  It would probably be
                                // more efficient to just Destroy them, and then
                                // let batch processing remove them from the tree.
                                GetFlowLayout()->GetView()->ExtractDispNode(pDispNodeCur);
                                pDispNodeCur->Destroy();
                            }
                            else
                            {
                                pDispNodeCur->SetExtraCookie(
                                                (void *)(LONG_PTR)(iLine +
                                                pled->_iliMatchNew -
                                                pled->_iliMatchOld));
                            }
                        }
                    }
                }

                if (pDNAdjustFrom)
                {
                    GetFlowLayout()->TranslateDispNodes(
                                        CSize(0, pled->_yMatchNew - pled->_yMatchOld),
                                        pDNAdjustFrom,
                                        NULL,       // dispnode to stop at
                                        TRUE,       // restrict to layer
                                        TRUE
                                        );      // extract hidden
                }
            }
        }
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CDisplay::AdjustDispNodes()" ));
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyFlowDispNodes
//
//  Synopsis:   Destroy all display tree nodes created for the flow layer
//
//-----------------------------------------------------------------------------

void
CDisplay::DestroyFlowDispNodes()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\keynav.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       keynav.cxx
//
//  Contents:   Implementation of some key navigation code
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif


#define FUZZY_HIT_BORDER_WIDTH 7

//+----------------------------------------------------------------------------
//
//  Member:     MoveLineUpOrDown
//
//  Synopsis:   Given a line, will move one line up/down. If there are no lines in
//              the given direction, will find an appropriate line (if one exists)
//              in a containing txtsite.
//
//  Arguments:  [iDir]           : The dirn we are moving in
//              [rp]             : The line to navigate from
//              [xCaret]         : The desired x position of the caret
//              [pcp]            : The New cp position after line up done
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at the logical BOL?
//
//  Returns:    The txtsite where the new cp resides. Could be the same txt site.
//
//
//  HACKHACK:   Since we are using global coord. system, we need a paramter to
//              signal whether or not we are in vertical layout
//
//-----------------------------------------------------------------------------
CFlowLayout *
CDisplay::MoveLineUpOrDown(NAVIGATE_DIRECTION iDir, BOOL fVertical, CLinePtr& rp, POINT ptCaret, LONG *pcp,
                           BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout = NULL;  // The new txtsite we navigate to
    CPoint       ptGlobal;                  // The point to navigate to
    CFlowLayout *pFlowLayoutThis = GetFlowLayout();

    // Setup the desired x position in global co-ordinate system.
    ptGlobal.x = ptCaret.x;
    ptGlobal.y = ptCaret.y;
   
    if (    (   iDir == NAVIGATE_UP
            &&  !IsTopLine(rp))
        ||  (   iDir == NAVIGATE_DOWN
            &&  !IsBottomLine(rp)))
    {
        CRect   rc;
        CPoint  ptContent(ptGlobal);
        
        // We need to convert pt to client coordinate system so that line from pos can use it
        pFlowLayoutThis->TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

        ptContent.x = max(0l, ptContent.x);
        
        // Find the Y position of the line geographically before/after us
        ptContent.y = YposFromLine(NULL, rp, NULL);
        if (iDir == NAVIGATE_UP)
        {
            ptContent.y += rp->GetYLineTop(rp->oi());
            ptContent.y--;
        }
        else
            ptContent.y += rp->GetYLineBottom(rp->oi());

        // Get the rectangle of this CDisplay in block coords.
        GetFlowLayout()->GetClientRect(&rc);
        // Move the rectangle to the position of ptContent, the intersection of this rectangle with the original
        // ClientRect will be the search area for text.
        rc.MoveTo(ptContent.x, ptContent.y);

        // Find that line
        rp = LineFromPos(rc, (LFP_ZORDERSEARCH | LFP_IGNOREALIGNED | LFP_IGNORERELATIVE));
                   
        // Remember that NavigateToLine requires global coords. So transalte all of this
        // back to global coords
        ptGlobal = ptContent;
        pFlowLayoutThis->TransformPoint(&ptGlobal, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);

        if (rp >= 0)
        {
            // The line we want to navigate is found. Now navigate
            // to that line
            pFlowLayout = NavigateToLine(iDir, rp, ptGlobal, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
    }
    else
    {
        CRect rcBound;
        pFlowLayoutThis->GetRect( &rcBound, COORDSYS_GLOBAL);
        if (fVertical)
        {
            ptGlobal.x = iDir == NAVIGATE_UP ? rcBound.right : rcBound.left;
        }
        else
        {
            ptGlobal.y = iDir == NAVIGATE_UP ? rcBound.top : rcBound.bottom;
        }
    }

    if (!pFlowLayout)
    {
        pFlowLayout = pFlowLayoutThis->GetNextFlowLayout(iDir, ptGlobal, NULL, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
    }

    // Return the flowlayout we ended up in
    return pFlowLayout;
}

//+----------------------------------------------------------------------------
//
//  Member:     NavigateToLine
//
//  Synopsis:   Given a line, we will first check if it has any nested sites
//              where a caret could live. If not, then we will place the caret
//              at the desired X position.
//
//  Arguments:  [iDir]           : The dirn we are moving in
//              [rp]             : The line to navigate to
//              [pt]             : The desired position of the caret (COORDSYS_GLOBAL)
//              [pcp]            : The New cp position after line up done
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//  Returns:    The txtsite where the new cp resides. Could be the same txt site.
//
//-----------------------------------------------------------------------------
CFlowLayout *
CDisplay::NavigateToLine(NAVIGATE_DIRECTION iDir, CLinePtr& rp, POINT pt, LONG *pcp, BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CElement    *pElementFL  = GetFlowLayoutElement();
    CFlowLayout *pFlowLayout = NULL;            // The new flowlayout we want to navigate to
    CTreeNode   *pNodeLayout;                   // The layout element (if any) within the line
    CTreeNode   *pNodeElem = NULL;
    CLayout     *pLayout;

    // Find the site in the beneath it (if it exists).
    if (LineCount() != 0 && rp->_fHasNestedRunOwner)
    {
        HTC htc; // The hit test code
        CMessage msg;

        msg.pt = pt;

        if (iDir == NAVIGATE_UP)
        {
            //
            // HACK HACK HACK (SujalP + JohnBed)
            //
            // Get over the fuzzy hit test problem of it having a 7px border
            //
            msg.pt.y -= FUZZY_HIT_BORDER_WIDTH;
        }
        else
        {
            msg.pt.y += rp->GetYTop(rp->oi());
        }
        
        // Find out the site which was within this line
        htc = GetFlowLayout()->Doc()->HitTestPoint(&msg, &pNodeElem,
                                 HT_IGNORESCROLL | HT_VIRTUALHITTEST | HT_DONTIGNOREBEFOREAFTER);
        Assert (HTC_NO != htc);

        //
        // HACK HACK PREVENT CRASH TILL VIRTUAL HIT-TESTING IS BACK ON ITS FEET!
        //
        if (HTC_NO == htc)
            return NULL;
        
        if( !pNodeElem)
            return NULL;
        
        if (pNodeElem->Element()->HasMasterPtr())
        {
            Assert(pNodeElem->Element()->HasMasterPtr());
            pNodeElem = pNodeElem->Element()->GetMasterPtr()->GetFirstBranch();
            Assert(pNodeElem);
        }
            
        pLayout = pNodeElem->GetUpdatedNearestLayout();

        //  NOTE:  (GregLett, AshrafM) 
        //  Editing expects us to return the position just outside this site (DIV, &c...) unless
        //  the site is a table, in which case we need to return the character just inside the
        //  cell.  As their code is updated, this needs to be changed.
        if (!   (pLayout->TestLayoutDescFlag(LAYOUTDESC_TABLECELL)
            ||  pLayout->TestLayoutDescFlag(LAYOUTDESC_TABLELAYOUT))  )
        {
            pLayout = GetFlowLayout();
        }

        if(!pLayout)
            return NULL;

        pNodeLayout = pLayout->GetFirstBranch();
    }
    else
    {
        pLayout = GetFlowLayout();
        pNodeLayout = pElementFL->GetFirstBranch();
    }

    Assert(pLayout);

    // If a site other than the site containing this line is found AND it
    // belongs to the same ped as this, then that is the site we want to
    // navigate to.
    if (DifferentScope(pNodeLayout, pElementFL) &&
        pNodeLayout->GetContainer() == pElementFL->GetFirstBranch()->GetContainer() )
    {
        // Be sure that the point is *within* that site's *client* rect
        pLayout->RestrictPointToClientRect(&pt);
        // And find out the nearest flowlayout within that layout.
        pFlowLayout = pLayout->GetFlowLayoutAtPoint(pt);
    }

    if(!pFlowLayout)
        pFlowLayout = GetFlowLayout();

    if (pFlowLayout != GetFlowLayout())
    {
        pFlowLayout = pFlowLayout->GetPositionInFlowLayout(iDir, pt, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
    }
    else
    {
        // There are no nested txtsites in this line. So lets position ourselves
        // in the correct position and return ourself as the text site.
        CLinePtr   rpNew(this);     // The line we end up in.
        TCHAR      ch;
        CTxtPtr    tp(GetMarkup());
        LONG       cchPreChars = 0;

        // Found the txtsite, so lets get the cp
        *pcp = CpFromPointReally(pt, &rpNew, NULL, CFP_ALLOWEOL, NULL, &cchPreChars);
        if (*pcp == -1)
            return NULL;

        // In any line, we donot want to end up after a line/block/textsite break
        // characters. Be sure of that ... however, also be careful to stay in
        // the same line.
        tp.SetCp(*pcp);
        ch = tp.GetPrevChar();
        while( rpNew.GetIch() && IsASCIIEOP( ch ) )
        {
            if (!tp.AdvanceCp(-1))
                break;
            ch = tp.GetPrevChar();
            rpNew.AdvanceCp(-1);
        }

        // Finally got our cp
        *pcp = tp.GetCp();

        // and the start of BOL'ness
        *pfCaretNotAtBOL = rpNew.GetIch() != 0;

        // are we at the logical BOL
        *pfAtLogicalBOL = rpNew.GetIch() <= cchPreChars;
    }

    return pFlowLayout;
}

//+----------------------------------------------------------------------------
//
//  Member:     IsTopLine
//
//  Synopsis:   Given a line, check if it is geographically the top line
//
//  Arguments:  [rp]: The line to check
//
//-----------------------------------------------------------------------------
BOOL
CDisplay::IsTopLine(CLinePtr& rp)
{
    CLinePtr rpTravel(rp);

    while(rpTravel.PrevLine(TRUE, TRUE))
    {
        // If there is a line before this one which forces a new line,
        // then this line is not the top one.
        if (rpTravel->_fForceNewLine)
            return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     IsBottomLine
//
//  Synopsis:   Given a line, check if it is geographically the bototm line
//
//  Arguments:  [rp]: The line to check
//
//
//  Legend:
//
//  ====== the line pointed to by rp
//  ------ the lines after it
//  -----> indicates that the line forces a new line
//
//  This function returns TRUE in all these cases:
//
//  1) ======== ---------->
//  2) ======== ----------
//  3) ========>
//  4) ========
//
//  And it returns FALSE in all these cases
//  5) ======== ---------->
//     --------
//  6) ======== ---------->
//     -------->
//  7) ========>
//     --------
//-----------------------------------------------------------------------------
BOOL
CDisplay::IsBottomLine(CLinePtr& rp)
{
    CLinePtr rpTravel(rp);          // Line ptr used to traverse the line array
    LONG     cNewLinesSeen = 0;     // How many lines having force new line seen?
    BOOL     fLastWasForceNewLine;  // The last line we saw was a force-new-line line

    do
    {
        // Account for this line
        cNewLinesSeen += rpTravel->_fForceNewLine ? 1 : 0;
        fLastWasForceNewLine = !!rpTravel->_fForceNewLine;

        // We cannot decide whether we are the last line when we just
        // see one line having the _fForceNewLine bit set. This would
        // break case 1 and 3 above. If we see atleast 2 lines with
        // this bit then we are sure that this line is not the last line
        // and can return FALSE (case 6)
        if (cNewLinesSeen == 2)
            return FALSE;

    } while(rpTravel.NextLine(TRUE, TRUE));

    // If we have seen only one new line and the last line we saw
    // did not force a new line then we have case 5/7, where we have
    // to return FALSE.
    if (cNewLinesSeen && !fLastWasForceNewLine)
        return FALSE;

    // case     cNewLinesSeen  fLastWasForceNewLine
    // 1        1              TRUE
    // 2        0              FALSE
    // 3        1              TRUE
    // 4        0              TRUE
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\fontlnk.cxx ===
//+---------------------------------------------------------------------
//
//   File:      fontlnk.cxx
//
//  Contents:   Code for fontlinking.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_MULTILANG_HXX_
#define X_MULTILANG_HXX_
#include "multilang.hxx"
#endif

MtDefine(FontLinkTextOut_aryLinkFonts_pv, Locals, "FontLinkTextOut aryLinkFonts::_pv")
MtDefine(FontLinkTextOut_aryStringCopy_pv, Locals, "FontLinkTextOut aryStringCopy::_pv")

#pragma warning(disable:4706) /* assignment within conditional expression */

#define FLTO_CACHE_SIZE 32  // Number of font pointers in FontLinkTextOut stack cache
                            //     max possible, only 32 distinct script bits
#define CHUNKSIZE 32

//+----------------------------------------------------------------------------
//
//  Function:   GetLangBits
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

DWORD
GetLangBits(
    IMLangFontLink * pMLangFontLink,
    WCHAR wc )
{
    DWORD dwCodePages = 0;

    if (wc < 128 || wc == WCH_NBSP)
    {
        dwCodePages = SBITS_ALLLANGS;
    }
    else if (pMLangFontLink)
    {
#ifndef NO_UTF16
        if (!IsSurrogateChar(wc))
        {
            IGNORE_HR(pMLangFontLink->GetCharCodePages(wc, &dwCodePages));
        }
        else
        {
            if (IsLowSurrogateChar(wc))
            {
                dwCodePages = SBITS_SURROGATE_A | SBITS_SURROGATE_B;
            }
            else
            {
                const CHAR_CLASS cc = CharClassFromCh(wc);

                Assert( cc == NHS_ || cc == WHT_ );
                
                dwCodePages = (cc == NHS_) ? SBITS_SURROGATE_A : SBITS_SURROGATE_B;
            }
        }
#else
        IGNORE_HR(pMLangFontLink->GetCharCodePages(wc, &dwCodePages));
#endif
    }

    return dwCodePages;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontScriptBits
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

DWORD 
GetFontScriptBits(
    XHDC hDC, 
    const TCHAR * szFaceName, 
    LOGFONT * plf )
{
#ifndef WINCE
    HRESULT hr = E_FAIL;
    DWORD dwCodePages = 0;

    if ( 0 == StrCmpC( szFaceName, _T("MS Sans Serif") ) &&
         PRIMARYLANGID(LANGIDFROMLCID(g_lcidUserDefault)) == LANG_ENGLISH)
    {
        // NB (cthrash) MS Sans Serif is a really evil font - in spite of the
        // fact that it contains virtually none of the Latin-1 characters,
        // it claims it supports Latin-1.  Unfortunately, MS Sans Serif is
        // an extremely common font for use as DEFUAULT_GUI_FONT.  This means
        // that intrinsic controls will often use MS Sans Serif.  By setting
        // our lang bits to SBITS_ASCII, we make certain we always font link
        // for non-ASCII characters.  We should never fontlink for ASCII chars.
        // See comment in _fontlnk.h.

        dwCodePages = SBITS_ASCII;
        goto Cleanup;
    }
    else
    {
        IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();
        if (pMLangFontLink)
        {
            LOGFONT lf;
            HFONT hFont;

            lf = *plf;
            Assert(_tcsclen(szFaceName) < LF_FACESIZE);
            ::_tcsncpy(lf.lfFaceName, szFaceName, ARRAY_SIZE(lf.lfFaceName));

            hFont = ::CreateFontIndirect(&lf);
            if (hFont)
            {
                hr = pMLangFontLink->GetFontCodePages(hDC.GetFontInfoDC(), hFont, &dwCodePages);
                Verify(::DeleteObject(hFont));
            }
            else
            {
                hr = E_FAIL; // Out of GDI resource
            }
        }
    }

    if (FAILED(hr) || !dwCodePages)
    {
        CHARSETINFO csi;

        if (::TranslateCharsetInfo((LPDWORD)(LONG_PTR)MAKELONG(plf->lfCharSet, 0), &csi, TCI_SRCCHARSET))
        {
            dwCodePages = csi.fs.fsCsb[0];
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL; // Invalid plf->lfCharSet
        }
    }

    // If dwLangBits is zero, this means we would ALWAYS fontlink.  If
    // it is in fact zero, we can't really know what the font supports.
    // Here we set all the bits on, so as to NEVER fontlink.

    if (dwCodePages == 0 || FAILED(hr))
    {
        dwCodePages = SBITS_ALLLANGS;
    }

    // NB (cthrash) We've decouple the ASCII portion of Latin-1 so that
    // we may more efficiently handle bad fonts which claim to support
    // Latin-1 when only really supporting ASCII.

    dwCodePages |= SBITS_ASCII;

Cleanup:

    return dwCodePages;
#else
    return 0;
#endif // WINCE
}

//+----------------------------------------------------------------------------
//
//  Function:   CharSetFromLangBits
//
//  Synopsis:   Compute a valid GDI charset from the language bits
//
//-----------------------------------------------------------------------------

static const BYTE s_abCharSetFromLangBit[32] =
{
    SYMBOL_CHARSET,      // FS_SYMBOL               0x80000000L
    DEFAULT_CHARSET,     //                         0x40000000L
    DEFAULT_CHARSET,     //                         0x20000000L
    DEFAULT_CHARSET,     //                         0x10000000L
    DEFAULT_CHARSET,     //                         0x08000000L
    DEFAULT_CHARSET,     //                         0x04000000L
    DEFAULT_CHARSET,     //                         0x02000000L
    DEFAULT_CHARSET,     //                         0x01000000L
    DEFAULT_CHARSET,     //                         0x00800000L
    DEFAULT_CHARSET,     //                         0x00400000L
    JOHAB_CHARSET,       // FS_JOHAB                0x00200000L
    CHINESEBIG5_CHARSET, // FS_CHINESETRAD          0x00100000L
    HANGEUL_CHARSET,     // FS_WANSUNG              0x00080000L
    GB2312_CHARSET,      // FS_CHINESESIMP          0x00040000L
    SHIFTJIS_CHARSET,    // FS_JISJAPAN             0x00020000L
    THAI_CHARSET,        // FS_THAI                 0x00010000L
    DEFAULT_CHARSET,     //                         0x00008000L
    DEFAULT_CHARSET,     //                         0x00004000L
    DEFAULT_CHARSET,     //                         0x00002000L
    DEFAULT_CHARSET,     //                         0x00001000L
    DEFAULT_CHARSET,     //                         0x00000800L
    DEFAULT_CHARSET,     //                         0x00000400L
    DEFAULT_CHARSET,     //                         0x00000200L
    VIETNAMESE_CHARSET,  // FS_VIETNAMESE           0x00000100L
    BALTIC_CHARSET,      // FS_BALTIC               0x00000080L
    ARABIC_CHARSET,      // FS_ARABIC               0x00000040L
    HEBREW_CHARSET,      // FS_HEBREW               0x00000020L
    TURKISH_CHARSET,     // FS_TURKISH              0x00000010L
    GREEK_CHARSET,       // FS_GREEK                0x00000008L
    RUSSIAN_CHARSET,     // FS_CYRILLIC             0x00000004L
    EASTEUROPE_CHARSET,  // FS_LATIN2               0x00000002L
    ANSI_CHARSET         // FS_LATIN1               0x00000001L
};

BYTE
CharSetFromLangBits( DWORD dwLangBits )
{
    for (int i=32; i--; dwLangBits >>= 1)
    {
        if (dwLangBits & 1)
        {
            return s_abCharSetFromLangBit[i];
        }
    }

    return DEFAULT_CHARSET;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFontLinkFontName
//
//  Synopsis:   An appropriate facename for the script/lang input set in pcf
//
//-----------------------------------------------------------------------------

BOOL
GetFontLinkFontName(
    IMLangFontLink *pMLangFontLink, // IN
    XHDC            hdc,            // IN
    CDoc *          pDoc,           // IN                    
    DWORD           dwScriptBits,   // IN
    LCID            lcidLang,       // IN
    const LOGFONT * lplf,           // IN
    CMarkup *       pMarkup,        // IN
    CCharFormat *   pcf )           // OUT
{
    HFONT hSrcFont = ::CreateFontIndirect(lplf);
    HFONT hDestFont = NULL;
    LOGFONT lfDestFont;
    BOOL fNewlyFetchedFromRegistry = FALSE; // for surrogates

#ifndef NO_UTF16
    if (dwScriptBits & (SBITS_SURROGATE_A | SBITS_SURROGATE_B))
    {
        fNewlyFetchedFromRegistry = SelectScriptAppropriateFont( (dwScriptBits & SBITS_SURROGATE_A)
                                                                 ? sidSurrogateA
                                                                 : sidSurrogateB,
                                                                 DEFAULT_CHARSET,
                                                                 pDoc,
                                                                 pMarkup,
                                                                 pcf );

        goto Cleanup;
    }
    else
#endif
    if (hSrcFont && pMLangFontLink)
    {
        TCHAR pszCodePage[4+1];
        DWORD dwCodePages;

        if (::GetLocaleInfo(lcidLang, LOCALE_IDEFAULTANSICODEPAGE, pszCodePage, ARRAY_SIZE(pszCodePage)) &&
            SUCCEEDED(pMLangFontLink->CodePageToCodePages(StrToInt(pszCodePage), &dwCodePages)))
        {
            dwCodePages &= dwScriptBits;
            if (dwCodePages &&
                dwCodePages != dwScriptBits &&
                FAILED(pMLangFontLink->MapFont(hdc.GetFontInfoDC(), dwCodePages, hSrcFont, &hDestFont)))
            {
                hDestFont = NULL;
            }
        }

        if (!hDestFont &&
            FAILED(pMLangFontLink->MapFont(hdc.GetFontInfoDC(), dwScriptBits, hSrcFont, &hDestFont)))
        {
            hDestFont = NULL;
        }

        if (hSrcFont)
            ::DeleteObject(hSrcFont);

        if (hDestFont)
        {
            ::GetObject(hDestFont, sizeof(lfDestFont), &lfDestFont);
            pMLangFontLink->ReleaseFont(hDestFont);

            lplf = &lfDestFont;
        }
    }

    pcf->SetFaceName(lplf->lfFaceName);

    // NOTE: (cthrash) MLANG suffers from the same GDI bug that Trident does, namely
    // it calls EnumFontFamilies instead of EnumFontFamiliesEx and thus gets
    // inaccurate GDI charset information.  For now, we will assume all charset values
    // other than 0 (ANSI_CHARSET) to be valid.  This is so we don't pick the wrong
    // charset in the unified-Han scenario.  Note that WinNT has no issue with
    // the the GDI charset being DEFAULT_CHARSET

    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        pcf->_bCharSet = DEFAULT_CHARSET;
    }
    else if (lplf->lfCharSet != ANSI_CHARSET)
    {
        pcf->_bCharSet = lplf->lfCharSet;
    }
    else
    {
        pcf->_bCharSet = CharSetFromLangBits( dwScriptBits );
    }

Cleanup:

    return fNewlyFetchedFromRegistry;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetFont
//
//  Synopsis:   Returns a CCcs * with langbits matching ch. 
//              Helper function for FontLinkTextOut.
//
//-----------------------------------------------------------------------------

CCcs *
GetFont(
    IMLangFontLink * pMLangFontLink,
    TCHAR ch,
    XHDC hDC,
    CDocInfo * pdci,
    const CCharFormat *pCF,
    CCcs * pccsDefault,
    CStackDataAry<CCcs*, FLTO_CACHE_SIZE> * paryLinkFonts )
{
    CCharFormat cf;
    DWORD dwLangBits;
    CCcs *pccs;
    CCcs **ppccs;
    int i;
    const CBaseCcs *pBaseCcsDefault = pccsDefault->GetBaseCcs();

    // TODO: (cthrash, track bug 112152) Temporary hack, remove it.

    pccsDefault->EnsureLangBits();

    // check the default font first
    if (ch <= 0x7f || // perf hack: all fonts have glyphs for unicode 0 - 0x7f
        (dwLangBits = GetLangBits(pMLangFontLink, ch)) == 0 ||
        (dwLangBits & pBaseCcsDefault->_dwLangBits))
    {
        return pccsDefault;
    }

    // Search for a match in the cache we build up.
    // There's some perf improvement here because we avoid extra calls
    // to GetFontLinkFontName, but the real reason we do this is to
    // ensure the same character is always rendered with a consistent
    // glyph.
    for (i=0; i < paryLinkFonts->Size(); i++)
    {
        if (dwLangBits & (*paryLinkFonts)[i]->GetBaseCcs()->_dwLangBits)
        {
            break;
        }
    }

    if (i < paryLinkFonts->Size())
    {
        return (*paryLinkFonts)[i];
    }

    // no match, grab a new font from the global cache

    // First allocate mem for the new CCcs object
    if ((pccs = new CCcs()) == NULL)
    {
        return pccsDefault;
    }

    cf = *pCF;
    GetFontLinkFontName(pMLangFontLink, hDC, pdci->_pDoc, dwLangBits, cf._lcid, &pBaseCcsDefault->_lf, pdci->_pMarkup, &cf);
    cf._bCrcFont = cf.ComputeFontCrc();
    if (!fc().GetFontLinkCcs(pccs, hDC, pdci, pccsDefault, &cf))
    {
        delete pccs;
        return pccsDefault;
    }
    
    pccs->EnsureLangBits();

#ifndef NO_UTF16
    if (dwLangBits & (SBITS_SURROGATE_A | SBITS_SURROGATE_B))
    {
        // EnsureLangBits isn't going to set the SBITS_SURROGATE_A or _B flags.
        // Force the bits set, so that the next char can be rendered in the same font.

        pccs->MergeLangBits(dwLangBits);
    }
#endif

    if  ((pccs->GetBaseCcs()->_dwLangBits & dwLangBits) == 0 ||
         (ppccs = paryLinkFonts->Append()) == NULL)
    {
        pccs->Release();
        delete pccs;
        return pccsDefault;
    }

    *ppccs = pccs;

    return pccs;
}

//+----------------------------------------------------------------------------
//
//  Function:   FontLinkTextOut
//
//  Synopsis:   ExtTextOutW functionality with font linking thrown in.
//
//  uMode is one of
//      FLTO_BOTH           render the string and return its text extent
//      FLTO_TEXTOUTONLY    render the string, return value is pos/neg only
//      FLTO_TEXTEXTONLY    just return the text textent, render nothing
//      
//  Return value is negative on error, otherwise the text extent
//  or in any case a non-negative number.
//-----------------------------------------------------------------------------

int
FontLinkTextOut (
    XHDC hDC,
    int x, int y,
    UINT fuOptions,
    const GDIRECT * prc,
    LPCTSTR pString,
    UINT cch,
    CDocInfo * pdci,
    const CCharFormat * pCF,
    UINT uMode )
{
    CStackDataAry<CCcs*, FLTO_CACHE_SIZE> aryLinkFonts(Mt(FontLinkTextOut_aryLinkFonts_pv));
    CCcs *pccsRun;
    CCcs *pccsNextRun;
    CCcs ccsDefault;
    LPCTSTR pPastRun;
    long lCharWidth = 0;
    FONTIDX hOldFont = HFONT_INVALID;
    int iDefBaseLinePlusY;
    int xin;
    int iDx;
    int i;
    CStackDataAry <TCHAR, CHUNKSIZE> aryStringCopy(Mt(FontLinkTextOut_aryStringCopy_pv));
    CODEPAGE codepage = pdci->_pMarkup->GetFamilyCodePage();
    BOOL fBidiCodepage = (codepage == CP_1256 || codepage == CP_1255);

    if (pString == NULL || cch <= 0)
    {
        return (cch == 0) ? 0 : -1;
    }

    if (!fc().GetCcs(&ccsDefault, hDC, pdci, pCF))
        return -1;

    ccsDefault.EnsureLangBits();

    Assert(ccsDefault.GetBaseCcs() != NULL);
    if (ccsDefault.GetBaseCcs()->_dwLangBits == 0)
    {
        ccsDefault.Release();
        return -1;
    }

    xin = x;
    iDefBaseLinePlusY = ccsDefault.GetBaseCcs()->_yHeight -
                        ccsDefault.GetBaseCcs()->_yDescent + y;

    //
    // Get IMultiLanguage::IMLangFontLink
    //
    IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();

    // init for loop
    pPastRun = pString;
    pccsNextRun = GetFont(pMLangFontLink, *pString, hDC, pdci, pCF, &ccsDefault, &aryLinkFonts);

    do
    {
        // set the font for this run
        hOldFont = pccsNextRun->PushFont(hDC);

        // skip first char in run -- already checked its font
        pPastRun++;
        cch--;
        pccsRun = pccsNextRun;

        // get the length of the run and next font
        while (cch)
        {
            // May need to do the *ugly* NBSP hack.
            if (*pPastRun == WCH_NBSP)
            {
                if (ccsDefault.ConvertNBSPs(hDC, pdci->_pDoc))
                {
                    LONG cchDelta = pPastRun - pString;
                    LONG cchNew = cch + cchDelta;

                    if (aryStringCopy.Grow( cchNew ) == S_OK)
                    {
                        TCHAR * pNewString = aryStringCopy;
                        const TCHAR * pSrc = pString;
                        TCHAR * pDst = pNewString;

                        while (cchNew--)
                        {
                            TCHAR ch = *pSrc++;
                            *pDst++ = (ch == WCH_NBSP) ? _T(' ') : ch;
                        }

                        pString = pNewString;
                        pPastRun = pString + cchDelta;
                    }
                }
            }

            if(!fBidiCodepage)
            {
                pccsNextRun = GetFont(pMLangFontLink, *pPastRun, hDC, pdci, pCF, &ccsDefault, &aryLinkFonts);
            }
            else
            {
                // If we have a bidi codepage (Arabic or Hebrew) we want to try the existing font for the character first.
                // This will help us not to break in cases where we have RTL text in a LTR control - Uniscribe
                // correctly handles shaping for us in LSUniscribeTextOut if an entire run of mixed text
                // is fed in.
                pccsNextRun = GetFont(pMLangFontLink, *pPastRun, hDC, pdci, pCF, pccsRun, &aryLinkFonts);
            }

            if (pccsRun->GetBaseCcs() != pccsNextRun->GetBaseCcs())
                break;

            cch--;
            pPastRun++;
        }

        // output this run
        iDx = 0;
        if (uMode != FLTO_TEXTEXTONLY)
        {
            int yRun = iDefBaseLinePlusY - (pccsRun->GetBaseCcs()->_yHeight - pccsRun->GetBaseCcs()->_yDescent);

            if (*pString != WCH_NBSP)
            {
                VanillaTextOut(pccsRun, hDC, x, yRun, fuOptions, prc, pString, pPastRun - pString, codepage, &iDx);
            }
            else
            {
                int cch = pPastRun - pString - 1;

                VanillaTextOut(pccsRun, hDC, x, yRun, fuOptions, prc, L" ", 1, codepage, &iDx);

                if (cch)
                {
                    int xT;
                    
                    pccsRun->Include(L' ', lCharWidth);
                    if (fuOptions & ETO_RTLREADING)
                        xT = x - lCharWidth;
                    else
                        xT = x + lCharWidth;

                    VanillaTextOut(pccsRun, hDC, xT, yRun, fuOptions, prc, pString + 1, cch, codepage, &iDx);
                }                    
            }
        }

        // Handle char widths for the final run only if caller wants text extent
        // or we need the text extent to handle underline/strikeout.
        if(iDx == 0)
        {
            if (cch || uMode != FLTO_TEXTOUTONLY || pCF->_fUnderline || pCF->_fStrikeOut)
            {
                int dx = 0;

                while (pString < pPastRun)
                {
                    pccsRun->Include(*pString, lCharWidth);
                    dx += lCharWidth;
                    pString++;
                }

                x += (fuOptions & ETO_RTLREADING) ? -dx : dx;
            }
        }
        else
        {
            if(fuOptions & ETO_RTLREADING)
                x -= iDx;
            else
                x += iDx;

            pString = pPastRun;
        }

        pccsRun->PopFont(hDC, hOldFont);

    } while (cch);

    if (uMode != FLTO_TEXTEXTONLY && (pCF->_fUnderline || pCF->_fStrikeOut))
    {
        HFONT hFont;
        LOGFONT lf;

        // Fonts from the global cache never have underline/strikeout attributes
        // because CRenderer draws its own underlines/strikeouts.  So allocate
        // an appropriate font here.
        // We do the underline/strikeout in one go to ensure consistency across
        // multiple runs and to work around a win95 gdi bug.
        // perf: could have the caller pass in the new HFONT, but the tradeoff
        // is generality and the risk of the font not matching.
        lf = ccsDefault.GetBaseCcs()->_lf;
        lf.lfUnderline = pCF->_fUnderline;
        lf.lfStrikeOut = pCF->_fStrikeOut;

        if ((hFont = CreateFontIndirect(&lf)) != 0)
        {
            DrawUnderlineStrikeOut(xin, y, 
                                   fuOptions & ETO_RTLREADING ? xin - x : x - xin, 
                                   hDC, hFont, prc);
            Verify(DeleteObject(hFont));
        }
    }

    ccsDefault.Release();

    for (i=0; i < aryLinkFonts.Size(); i++)
    {
        aryLinkFonts[i]->Release();
        delete aryLinkFonts[i];
    }

    return (fuOptions & ETO_RTLREADING ? xin - x : x - xin);
}

//+----------------------------------------------------------------------------
//
//  Function:   VanillaTextOut
//
//  Synopsis:   A wrapped ExtTextOutW, accounting for a win95 china bug.
//
//-----------------------------------------------------------------------------

void 
VanillaTextOut(
    CCcs * pccs,                    
    XHDC hdc,
    int x, int y,
    UINT fuOptions,
    const GDIRECT * prc,
    LPCTSTR pString,
    UINT cch,
    UINT uCodePage,
    int * piDx )
{
    // COMPLEX TEXT.  ExtTextOutW does not work properly on foreign language versions
    //                of Win95. Additionally, we want to send all glyphable text through
    //                Uniscribe for shaping and output.

    BOOL fGlyph = FALSE;
    BOOL fEuro  = FALSE;
    BOOL fRTL   = FALSE;

    // There is an assumption that *piDx is 0 coming in. Really, we should move
    // the measurement code from FontLinkTextOut() down here and use it
    // whenever we don't go through LSUniscribeTextOut(). Then this wouldn't
    // matter.
    Assert(piDx == NULL || *piDx == 0);

    fRTL = !!(fuOptions & ETO_RTLREADING);

    if(!fRTL)
    {
        for(UINT i = 0; i < cch; i++)
        {
            WCHAR ch = pString[i];
            if(ch >= 0x300 && IsGlyphableChar(ch))
            {
                fGlyph = TRUE;
                break;
            }
            else if (ch == WCH_EURO)
            {
                fEuro = TRUE;
                break;
            }
        }
    }


    // send complex text or text layed out right-to-left
    // to be drawn through Uniscribe
    if((fGlyph || fRTL) && !g_fExtTextOutGlyphCrash)
    {
        HRESULT hr;

        extern HRESULT LSUniscribeTextOut(const XHDC& hdc, 
                                       int iX, 
                                       int iY, 
                                       UINT uOptions, 
                                       CONST RECT *prc, 
                                       LPCTSTR pString, 
                                       UINT cch,
                                       int *piDx); 
 
        hr = LSUniscribeTextOut(hdc,
                                x, 
                                y,
                                fuOptions,
                                prc,
                                pString,
                                cch,
                                piDx);

        // if we failed, let the normal path be our fallback
        if(!hr)
            return;
    }

    if (    IsExtTextOutWBuggy(uCodePage)
        ||  (fEuro && g_fExtTextOutGlyphCrash))   // FE Win95 GDI fails when rendering Euro character
    {
        extern BOOL LSReExtTextOut( CCcs *, XHDC, int, int, UINT,
                                    CONST RECT *, const WCHAR *,
                                    long cbCount, CONST INT *lpDx,
                                    CONVERTMODE cm);

        LSReExtTextOut( pccs,
                        hdc,
                        x, y,
                        fuOptions,
                        prc,
                        pString,
                        cch,
                        NULL,
                        CM_MULTIBYTE );
    }
    else
    {
        ExtTextOutW(hdc,
                    x, y,
                    fuOptions,
                    prc,
                    pString,
                    cch,
                    NULL);
    }

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   DrawUnderlineStrikeOut
//
//  Synopsis:   Draws an underline/strikeout.  This is a workaround
//              for a win95 ExtTextOutW problems with underlines.
//
//-----------------------------------------------------------------------------

void 
DrawUnderlineStrikeOut(
    int x, int y, 
    int iLength, 
    XHDC hDC, 
    HFONT hFont, 
    const GDIRECT  *prc )
{
    int iOldBkMode;
    HFONT hOldFont;

    if ((iOldBkMode = SetBkMode(hDC, TRANSPARENT)) == 0)
    {
        return;
    }
    hOldFont = SelectFontEx(hDC, hFont);

    ExtTextOutA(hDC, x, y, 0, prc, " ", 1, &iLength);

    SelectFontEx(hDC, hOldFont);
    SetBkMode(hDC, iOldBkMode);

    return;
}

//+----------------------------------------------------------------------------
//
//  Function:   NeedsFontLinking
//
//  Synopsis:   Returns TRUE iff the supplied font does not contain
//              glyphs for the entire string.
//
//-----------------------------------------------------------------------------

BOOL 
NeedsFontLinking(
    XHDC hdc, 
    CCcs * pccs, 
    LPCTSTR pString, 
    int cch, 
    CDoc * pDoc )
{
    const CBaseCcs *pBaseCcs;
    IMLangFontLink * pMLangFontLink = NULL;
    
    if (pccs == NULL ||
        pccs->GetBaseCcs() == NULL ||
        pString == NULL ||
        cch <= 0)
    {
        return FALSE;
    }

    
    pBaseCcs = pccs->GetBaseCcs();
    pccs->EnsureLangBits();

    if (pBaseCcs->_dwLangBits == 0)
    {
        return FALSE;
    }

    const DWORD dwDefLangBits = pBaseCcs->_dwLangBits;

    for (; cch; cch--)
    {
        const TCHAR ch = *pString++;

        if (ch < 0x80)
        {
            continue; // perf hack: all fonts have glyphs for unicode 0 - 0x7f
        }
        else if (ch == WCH_NBSP)
        {
            if (pccs->ConvertNBSPs(hdc, pDoc))
            {
                break;
            }
        }
        else
        {
            if (!pMLangFontLink)
            {
                pMLangFontLink = mlang().GetMLangFontLink();
            }
                
            if (!(GetLangBits(pMLangFontLink, ch) & dwDefLangBits))
                break;
        }
    }

    return cch != 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   SelectScriptAppropriateFont
//
//  Synopsis:   Populates a CCharFormat element on the fly for fontlinking
//              with script-appropriate information.
//
//  Notes:      The incomoming SCRIPT_ID (sid) should already by Han ununified,
//              This means if any CJK disamguation is necessary, it should
//              have been done before calling this function.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

const WCHAR * AlternateFontNameIfAvailable( const WCHAR * );

BOOL
SelectScriptAppropriateFont(
    SCRIPT_ID sid,          // IN
    BYTE bCharSet,          // IN
    CDoc * pDoc,            // IN
    CMarkup * pMarkup,      // IN
    CCharFormat * pcf )     // IN/OUT
{
    HRESULT hr;
    BOOL fNewlyFetched = FALSE;
    LONG latmFontFace;

    hr = THR( pDoc->UpdateFromRegistry() );
    if (hr)
        goto Cleanup;

    sid = RegistryAppropriateSidFromSid( sid );

    fNewlyFetched = ScriptAppropriateFaceNameAtom(sid, pDoc, pcf->_bPitchAndFamily & FIXED_PITCH, pcf, pMarkup, &latmFontFace );

    if (latmFontFace < 0)
        latmFontFace = 0;

    pcf->SetFaceNameAtom(latmFontFace);
    pcf->_bCharSet = bCharSet;
    pcf->_fNarrow  = IsNarrowCharSet( bCharSet );
    pcf->_bCrcFont = pcf->ComputeFontCrc();

Cleanup:

    return fNewlyFetched;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptAppropriateFaceNameAtom
//
//  Synopsis:   For given script ID we get default font face atom (fixed or
//              variable pitch). Check also if we need @font.
//
//  Returns:    TRUE if fetched from registry.
//
//-----------------------------------------------------------------------------

BOOL
ScriptAppropriateFaceNameAtom(
    SCRIPT_ID sid,                  // IN
    CDoc * pDoc,                    // IN
    BOOL fFixed,                    // IN
    const CCharFormat * const pcf,  // IN
    CMarkup * pMarkup,              // IN
    LONG *platmFontFace )           // OUT
{
    LONG latmFontFace = fFixed
                        ? pDoc->_pOptionSettings->alatmFixedPitchFonts[sid]
                        : pDoc->_pOptionSettings->alatmProporitionalFonts[sid];
    const BOOL fFetch = latmFontFace == -1;

    if (fFetch)
    {
        CODEPAGESETTINGS CS;

        CS.SetDefaults(pMarkup->GetFamilyCodePage(), pDoc->_pOptionSettings->sBaselineFontDefault );

        pDoc->_pOptionSettings->ReadCodepageSettingsFromRegistry( &CS, 0, sid );

        pDoc->_pOptionSettings->alatmFixedPitchFonts[sid] = CS.latmFixedFontFace;
        pDoc->_pOptionSettings->alatmProporitionalFonts[sid] = CS.latmPropFontFace;

        latmFontFace = fFixed
                       ? CS.latmFixedFontFace
                       : CS.latmPropFontFace;
    }

    if (pcf->NeedAtFont() && !pcf->_fExplicitAtFont)
    {
        LONG latmAtFontFace = fFixed
                              ? pDoc->_pOptionSettings->alatmFixedPitchAtFonts[sid]
                              : pDoc->_pOptionSettings->alatmProporitionalAtFonts[sid];

        if (latmAtFontFace == -1)
        {
            Assert(pDoc->_pOptionSettings->alatmFixedPitchFonts[sid] != -1);
            Assert(pDoc->_pOptionSettings->alatmProporitionalFonts[sid] != -1);

            const TCHAR * szFaceNameOriginal = fc().GetFaceNameFromAtom(latmFontFace);
            if (szFaceNameOriginal && (szFaceNameOriginal[0] != _T('@')))
            {
                TCHAR szFaceName[LF_FACESIZE];
                szFaceName[0] = _T('@');
                _tcsncpy(szFaceName + 1, szFaceNameOriginal, LF_FACESIZE - 2);
                szFaceName[LF_FACESIZE - 1] = 0;

                CCharFormat cf(*pcf);

                ApplyFontFace(&cf, szFaceName, AFF_ATFONTPASS, pDoc, pMarkup);
                latmAtFontFace = cf._latmFaceName;
            }
            if (fFixed)
                pDoc->_pOptionSettings->alatmFixedPitchAtFonts[sid] = latmAtFontFace;
            else
                pDoc->_pOptionSettings->alatmProporitionalAtFonts[sid] = latmAtFontFace;
        }
        latmFontFace = latmAtFontFace;
    }

    *platmFontFace = latmFontFace;
    
    return fFetch;
}

//-----------------------------------------------------------------------------
//
//  Function:   ShouldSwitchFontsForPUA
//
//  Synopsis:   Decide if we should switch fonts for Unicode Private Use Area
//              characters.  This is a heuristic approach.
//
//  Returns:    BOOL    - true if we should switch fonts
//              *psid   - the SCRIPT_ID to which we should switch
//
//-----------------------------------------------------------------------------

BOOL
ShouldSwitchFontsForPUA(
    XHDC hdc,                   // IN
    UINT uiFamilyCodePage,      // IN
    const CBaseCcs * pBaseCcs,  // IN
    const CCharFormat * pcf,    // IN
    SCRIPT_ID * psid )          // OUT
{
    BOOL fShouldSwitch;
    
    if (pcf->_fExplicitFace)
    {
        // Author specified a face name -- don't switch fonts on them.

        fShouldSwitch = FALSE;
    }
    else
    {
        SCRIPT_ID sid = sidDefault;

        if (pcf->_lcid)
        {
            // Author specified a LANG attribute -- see if the current font
            // covers this script

            const LANGID langid = LANGIDFROMLCID(pcf->_lcid);
            sid = ScriptIDFromLangID(langid);
        }
        else
        {
            // Check the document codepage, then the system codepage

            switch (uiFamilyCodePage)
            {
                case CP_CHN_GB:     sid = sidHan;       break;
                case CP_KOR_5601:   sid = sidHangul;    break;
                case CP_TWN:        sid = sidBopomofo;  break;
                case CP_JPN_SJ:     sid = sidKana;      break;
                default:
                {
                    switch (g_cpDefault)
                    {
                        case CP_CHN_GB:     sid = sidHan;       break;
                        case CP_KOR_5601:   sid = sidHangul;    break;
                        case CP_TWN:        sid = sidBopomofo;  break;
                        case CP_JPN_SJ:     sid = sidKana;      break;
                        default:            sid = sidDefault;   break;                        
                    }
                }
            }
        }

        if (sid != sidDefault)
        {
            SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, pBaseCcs, FC_SIDS_USEMLANG);
            fShouldSwitch = (sidsFace & ScriptBit(sid)) == sidsNotSet;
            *psid = sid;
        }
        else
        {
            fShouldSwitch = FALSE;
        }
    }

    return fShouldSwitch;            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\irange.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       irange.cxx
//
//  Contents:   Implementation of the CAutoRange and related classes
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif


#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifdef UNIX
#ifndef X_QUXCOPY_H_
#define X_QUXCOPY_H_
#include "quxcopy.hxx"
#endif
#endif

#define _cxx_
#include "range.hdl"

MtDefine(CAutoRange, ObjectModel, "CAutoRange")
MtDefine(CAutoRangeGetRangeBoundingRect_aryRects_pv, Locals, "CAutoRange::GetRangeBoudningRect aryRects::_pv")
MtDefine(CAutoRangegetClientRects_aryRects_pv, Locals, "CAutoRange::getClientRects aryRects::_pv")
MtDefine(CAutoRange_paryAdjacentRangePointers_pv, Locals , "CAutoRange::_paryAdjacentRangePointers::_pv")
MtDefine(CAutoRangeIterator, ObjectModel, "CAutoRangeIterator")
MtDefine(CAutoRangeCollection,ObjectModel,"CAutoRangeCollection")
MtDefine(CAutoRangeCollection_aryRanges_pv,ObjectModel,"CAutoRange::CAutoRangeCollection_aryRanges_pv")

extern HRESULT 
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    BOOL             fAutomation );


const CBase::CLASSDESC CAutoRange::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // property pages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    & IID_IHTMLTxtRange,            // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

// IOleCommandTarget methods

BEGIN_TEAROFF_TABLE(CAutoRange, IOleCommandTarget)
    TEAROFF_METHOD(CAutoRange, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CAutoRange, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

//+----------------------------------------------------------------------------
//
//  Constructor / Destructor
//
//-----------------------------------------------------------------------------

CAutoRange::CAutoRange ( CMarkup * pMarkup, CElement * pElemContainer )
{
    Assert(!pElemContainer || pElemContainer->GetMarkup() == pMarkup);

    CElement::SetPtr( & _pElemContainer, pElemContainer );

    _pMarkup = pMarkup;

    _pMarkup->AddRef();

    _pLeft = _pRight = NULL;

    _pNextRange = NULL;

    InitPointers();
}


CAutoRange::~CAutoRange()
{
    RemoveLookAsideEntry();

    ClearAdjacentRangePointers();

    ReleaseInterface( _pLeft );
    
    ReleaseInterface( _pRight );

    CElement::ClearPtr( & _pElemContainer );

    _EditRouter.Passivate();
    
    _pMarkup->Release();
}


//+----------------------------------------------------------------------------
//
//  Member:     RemoveLookAsideEntry
//
//  Synopsis:   The markup keeps a lookaside pointer which is a list of 
//              active CAutoRanges on the markup. This routine clears this list.
//
//-----------------------------------------------------------------------------

void
CAutoRange::RemoveLookAsideEntry()
{
    WHEN_DBG( BOOL fFound = FALSE );

    CAutoRange * pAutoRange = _pMarkup->GetTextRangeListPtr();

    Assert( pAutoRange );

    if ( pAutoRange == this )
    {
        CAutoRange * pLookAsideRange = pAutoRange->_pNextRange;

        _pMarkup->DelTextRangeListPtr();

        if ( pLookAsideRange )
        {
            IGNORE_HR( _pMarkup->SetTextRangeListPtr( pLookAsideRange ) );
        }
        WHEN_DBG( fFound = TRUE );
    }
    else
    {
        CAutoRange * pPrevRange = pAutoRange;

        pAutoRange = pAutoRange->_pNextRange;

        Assert( pAutoRange );

        while ( pAutoRange )
        {
            if ( pAutoRange == this )
            {
                Assert ( pPrevRange );
                pPrevRange->_pNextRange = pAutoRange->_pNextRange;
                WHEN_DBG( fFound = TRUE );
                break;
            }

            pPrevRange = pAutoRange;
            pAutoRange = pAutoRange->_pNextRange;
        }     
    }

    Assert( fFound );
}


//+----------------------------------------------------------------------------
//
//  Member:     AdjustRangePointerGravity
//
//  Synopsis:   This function compares the passed in pRangePointer to _pLeft.
//              if pRangePointer has right gravity and it is equal to _pLeft
//              then its gravity is temporarily set to POINTER_GRAVITY_Left, 
//              in preparation for the upcoming put_text operation. 
//              This prevents pther range pointers around _pLeft to accidently move
//              right, when InsertText() is called.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::AdjustRangePointerGravity( IMarkupPointer * pRangePointer )
{
    BOOL        fEqual;
    HRESULT     hr;
    POINTER_GRAVITY eGravity;

    hr = THR( pRangePointer->Gravity( &eGravity ) );
    if (hr)
        goto Cleanup;

    if ( eGravity == POINTER_GRAVITY_Left )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( _pLeft->IsEqualTo( pRangePointer, & fEqual ) );
    if (hr)
        goto Cleanup;

    if ( fEqual )
    {
        hr = THR( pRangePointer->SetGravity( POINTER_GRAVITY_Left ) );
        if (hr)
            goto Cleanup;

        hr = THR( StoreAdjacentRangePointer( pRangePointer ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureAdjacentRangesGravity
//
//  Synopsis:   This function calls AdjustRangePointerGravity() on all the 
//              ranges in the current markup. Please see comments under
//              AdjustRangePointerGravity for more info.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::EnsureAdjacentRangesGravity()
{
    HRESULT      hr = S_OK;
    CAutoRange * pAutoRange = _pMarkup->GetTextRangeListPtr();
    Assert( pAutoRange );

    while ( pAutoRange )
    {
        if ( pAutoRange != this )
        {
            hr = THR( AdjustRangePointerGravity( pAutoRange->_pLeft ) );
            if (hr)
                goto Cleanup;
            
            hr = THR( AdjustRangePointerGravity( pAutoRange->_pRight ) );
            if (hr)
                goto Cleanup;
        }

        pAutoRange = pAutoRange->_pNextRange;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     RestoreAdjacentRangesGravity
//
//  Synopsis:   This function restores the gravity of range pointers whose gravity
//              was temporarily set by AdjustRangePointerGravity, and clears the
//              _paryAdjacentRangePointers list.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::RestoreAdjacentRangesGravity()
{
    HRESULT      hr = S_OK;
    long         iPointer;
    IMarkupPointer * pRangePointer;

    if (! _paryAdjacentRangePointers)
    {
        // Nothing to do
        goto Cleanup;
    }

    iPointer = _paryAdjacentRangePointers->Size() - 1;

    while ( iPointer >= 0 )
    {        
        pRangePointer = _paryAdjacentRangePointers->Item( iPointer );

        Assert( pRangePointer );

        if ( pRangePointer )
        {
            hr = THR( pRangePointer->SetGravity( POINTER_GRAVITY_Right ) );
            if (hr)
                goto Cleanup;        

            pRangePointer->Release();
        }

        _paryAdjacentRangePointers->Delete( iPointer );        
        
        iPointer--;
    }

    ClearAdjacentRangePointers();

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     ClearAdjacentRangePointers
//
//  Synopsis:   Delete the list of adjacent range pointers array.
//
//-----------------------------------------------------------------------------

void
CAutoRange::ClearAdjacentRangePointers()
{
    if ( _paryAdjacentRangePointers )
    {
        delete _paryAdjacentRangePointers;
        _paryAdjacentRangePointers = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     StoreAdjacentRangePointer
//
//  Synopsis:   Append a range pointer whose gravity was set by AdjustRangePointerGravity
//              to the list of adjacent range pointers array.
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::StoreAdjacentRangePointer( IMarkupPointer * pAdjacentPointer )
{
    HRESULT hr = S_OK;

    if ( ! _paryAdjacentRangePointers )
    {
        _paryAdjacentRangePointers = new ( Mt( CAutoRange_paryAdjacentRangePointers_pv ) )  
                    CPtrAry<IMarkupPointer *> ( Mt( CAutoRange_paryAdjacentRangePointers_pv ) )  ;

        if (! _paryAdjacentRangePointers) 
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;        
        }
    }

    pAdjacentPointer->AddRef();

    hr = THR( _paryAdjacentRangePointers->Append( pAdjacentPointer ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     IsCompatibleWith
//
//  Synopsis:   Makes sure two pointers are in the same region of the tree.
//              Operations involving two pointers need to be compatible.
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::IsCompatibleWith ( IHTMLTxtRange * pIRangeThat )
{
    CAutoRange * pRangeThat;

    if (pIRangeThat->QueryInterface( CLSID_CRange, (void **) & pRangeThat ) != S_OK)
        return FALSE;

    return pRangeThat->GetContainer() == GetContainer();
}

//+----------------------------------------------------------------------------
//
//  Member:     SanityCheck
//
//  Synopsis:   Do a little self diagnosis
//
//-----------------------------------------------------------------------------

#if DBG == 1

void
CAutoRange::SanityCheck ( )
{
}

#define DO_SANITY_CHECK SanityCheck();

#else

#define DO_SANITY_CHECK

#endif


//+----------------------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   Implements IOleCommandTarget::QueryStatus() for IHTMLTxtRange
//
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::QueryStatus (GUID * pguidCmdGroup,
                         ULONG cCmds,
                         MSOCMD rgCmds[],
                         MSOCMDTEXT * pcmdtext)
{
    HRESULT     hr = S_OK;
    MSOCMD *    pCmd;
    INT         c;
    DWORD       cmdID;

    Assert( CBase::IsCmdGroupSupported( pguidCmdGroup ) );

    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
        
        switch ( cmdID )
        {
            case IDM_SIZETOCONTROL:
            case IDM_SIZETOCONTROLHEIGHT:
            case IDM_SIZETOCONTROLWIDTH:
            case IDM_DYNSRCPLAY:
            case IDM_DYNSRCSTOP:

            case IDM_BROWSEMODE:
            case IDM_EDITMODE:
            case IDM_REFRESH:
            case IDM_REDO:
            case IDM_UNDO:
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
                break;

            default:
                hr = _EditRouter.QueryStatusEditCommand(
                            pguidCmdGroup,
                            1,
                            pCmd,
                            pcmdtext,
                            (IUnknown *) (IHTMLTxtRange *)this,
                            NULL,                                   // No CMarkup ptr for Ranges
                            GetMarkup()->Doc() );
        }
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   Implements IOleCommandTarget::Exec() for IHTMLTxtRange
//
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::Exec (GUID * pguidCmdGroup,
                  DWORD nCmdID,
                  DWORD nCmdexecopt,
                  VARIANTARG * pvarargIn,
                  VARIANTARG * pvarargOut)
{
    HRESULT     hr;
    int         idm;

    idm = CBase::IDMFromCmdID( pguidCmdGroup, nCmdID );

    if ( CheckOwnerSiteOrSelection(idm) )
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    //
    // ie50 compatible paste is handled in trident, so don't route to editor    
    //

    if (nCmdID == IDM_IE50_PASTE)
    {
        CMarkupPointer * pmpLeft, * pmpRight;
        
        if (!pvarargIn || V_VT(pvarargIn) != VT_BYREF)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpLeft ) );
        if (hr)
            goto Cleanup;
            
        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( HandleIE50CompatUIPasteHTML(pmpLeft, pmpRight, HGLOBAL(V_BYREF(pvarargIn)), FALSE) );
        
        goto Cleanup;
    }

    //
    // Route command using the edit router...
    //
    hr = THR( _EditRouter.ExecEditCommand(pguidCmdGroup,
                                     nCmdID, nCmdexecopt,
                                     pvarargIn, pvarargOut,
                                     (IUnknown *) (IHTMLTxtRange *)this,
                                     GetMarkup()->Doc() ) );

    //
    // For commands that perform an insert, collapse the range 
    // after the insertion point
    //
    if (hr)
        goto Cleanup;

    switch( idm )
    {
    case IDM_IMAGE:
    case IDM_PARAGRAPH:
    case IDM_IFRAME:
    case IDM_TEXTBOX:
    case IDM_TEXTAREA:
#ifdef  NEVER
    case IDM_HTMLAREA:
#endif
    case IDM_CHECKBOX:
    case IDM_RADIOBUTTON:
    case IDM_DROPDOWNBOX:
    case IDM_LISTBOX:
    case IDM_BUTTON:
    case IDM_MARQUEE:
    case IDM_1D:
    case IDM_LINEBREAKNORMAL:
    case IDM_LINEBREAKLEFT:
    case IDM_LINEBREAKRIGHT:
    case IDM_LINEBREAKBOTH:
    case IDM_HORIZONTALLINE:
    case IDM_INSINPUTBUTTON:
    case IDM_INSINPUTIMAGE:
    case IDM_INSINPUTRESET:
    case IDM_INSINPUTSUBMIT:
    case IDM_INSINPUTUPLOAD:
    case IDM_INSFIELDSET:
    case IDM_INSINPUTHIDDEN:
    case IDM_INSINPUTPASSWORD:
    case IDM_PASTE:
        {
            BOOL fResult;

            hr = THR( _pLeft->IsRightOf( _pRight, & fResult ) );

            if ( fResult )
                hr = THR( _pRight->MoveToPointer( _pLeft ) );
            else
                hr = THR( _pLeft->MoveToPointer( _pRight ) );
        }
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    DO_SANITY_CHECK

    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTxtRange)
        QI_TEAROFF(this, IOleCommandTarget, (IHTMLTxtRange *)this)
        QI_INHERITS(this, IHTMLTxtRange)
        QI_INHERITS(this, ISegmentList)
        QI_INHERITS(this, ISegment)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IHTMLTextRangeMetrics, NULL)
        QI_TEAROFF(this, IHTMLTextRangeMetrics2, NULL)

        default:
            if (IsEqualIID(iid, CLSID_CRange))
            {
                *ppv = this;
                return S_OK;
            }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo, IHTMLTxtRange
//
//  Synopsis:   Pass the call to the form so it can return its clsid
//              instead of the object's clsid as in CBase.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::CloseErrorInfo(HRESULT hr)
{
    GetMarkup()->Doc()->CloseErrorInfo( hr );

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText, IHTMLTxtRange
//
//  Synopsis:   Gets the simple text from the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::get_text( BSTR * pText )
{
    HRESULT hr = E_POINTER;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pText)
    {
        hr = THR( KeepRangeLeftToRight() );
        if (hr)
            goto Cleanup;

        // NOTE: Work around a saver bug when range is empty
        if ( IsRangeCollapsed() )
        {
            hr = FormsAllocString(_T( "" ), pText);
        }
        else
        {
            hr = THR(GetBstrHelper(pText, RSF_SELECTION, WBF_SAVE_PLAINTEXT|WBF_NO_WRAP));  // new
        }

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CAutoRange_text ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     SetText, IHTMLTxtRange
//
//  Synopsis:   Sets the simple text in the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::put_text( BSTR Text )
{
    HRESULT hr;
    CMarkup *   pMarkup = GetMarkup();
    CDoc     *  pDoc = pMarkup->Doc();
    CParentUndo pu( pDoc );
    CElement *  pContainer;
    IHTMLEditingServices * pedserv = NULL;
    IHTMLEditor * phtmed;
    BOOL          result;

    Assert( pDoc );
    Assert( pMarkup );

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pContainer = GetCommonContainer();

    if (pContainer && pContainer->TestClassFlag(CElement::ELEMENTDESC_OMREADONLY))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if( pContainer->IsEditable(/*fCheckContainerOnly*/FALSE) )
        pu.Start( IDS_UNDOGENERICTEXT );

    if (!CheckSecurity(L"paste"))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    //
    // Get the editing services interface with which I can
    // insert sanitized text
    //

    phtmed = pDoc->GetHTMLEditor();

    if (!phtmed)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        phtmed->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pedserv ) );
    if (hr)
        goto Cleanup;

    hr = THR( EnsureAdjacentRangesGravity() );
    if (hr)
        goto Cleanup;

    hr = THR( pedserv->Paste( _pLeft, _pRight, Text ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->IsRightOf( _pRight, & result ) );
    if ( result )
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    else
        hr = THR( _pLeft->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( RestoreAdjacentRangesGravity() );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;


Cleanup:
    pu.Finish( hr );
    ReleaseInterface( pedserv );
    RRETURN( SetErrorInfoPSet( hr, DISPID_CAutoRange_text ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText, IHTMLTxtRange
//
//  Synopsis:   Gets the HTML (fragment) text from the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::get_htmlText( BSTR * ppHtmlText )
{
    HRESULT hr = S_OK;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ppHtmlText)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( GetBstrHelper(ppHtmlText, RSF_FRAGMENT, 0) );
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CAutoRange_htmlText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     parentElement, IHTMLTxtRange
//
//  Synopsis:   Get the common parent element for all chars int the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::parentElement ( IHTMLElement * * ppParent )
{
    HRESULT           hr;
    IMarkupPointer  * pCurrent = NULL;
    IMarkupPointer  * pAdjustedLeft = NULL;
    IMarkupPointer  * pPointer = NULL;
    IHTMLElement    * pOldElement = NULL;
    CMarkup         * pMarkup = GetMarkup();
    CDoc            * pDoc;
    CElement        * pElement = NULL;
    BOOL              fEqual;
    BOOL              fRangeIsCollapsed;
    BOOL              fUseRightForParent = FALSE;
    CMarkupPointer  * pointerLeft;
    CMarkupPointer  * pointerRight;
    BOOL              fBlockBreakAdjustment = FALSE;
    MARKUP_CONTEXT_TYPE context;    
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;

    Assert( pMarkup );

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Check incoming pointer
    //

    if (!ppParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppParent = NULL;
    
    pDoc = pMarkup->Doc();
    Assert( pDoc );

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pCurrent ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pAdjustedLeft ) );
    if (hr)
        goto Cleanup;

    //
    // SetRangeToElementText() adjusts the left end of the range just before a character.
    // Here we must undo the adjustment to achieve IE4 compat for parentElement()
    //

    hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->IsEqualTo(_pRight, &fRangeIsCollapsed) );
    if (hr)
        goto Cleanup;
        
    if (fRangeIsCollapsed)
    {
        hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( pCurrent->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveCharacter( pCurrent, MOVEUNIT_NEXTCHAR, pLeftBoundary, pRightBoundary, pAdjustedLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( pAdjustedLeft->IsRightOfOrEqualTo( _pRight, & fEqual ) );
        if (hr)
            goto Cleanup;

        if ( fEqual )
        {
            hr = THR( pAdjustedLeft->MoveToPointer( _pLeft ) );
            if (hr)
                goto Cleanup;
        }
        
        hr = THR( pAdjustedLeft->IsEqualTo( _pRight, & fRangeIsCollapsed ) );
        if (hr)
            goto Cleanup;
    }


    //
    // IE4 compat: If _pLeft and _pRight are around a noscope element that has layout,
    //             we want to return the noscope element as the parentElement for the range
    //
    hr = THR( pCurrent->MoveToPointer( pAdjustedLeft ) ) ;
    if (hr)
        goto Cleanup;

    hr = THR( RightOrSlave( pCurrent, TRUE, & context, ppParent , NULL, NULL ) );
    if (hr)
        goto Cleanup;

    if ( context == CONTEXT_TYPE_NoScope && *ppParent )
    {
        hr = THR( (*ppParent)->QueryInterface( CLSID_CElement, (void **) & pElement ) );
        if (hr)
            goto Cleanup;
            
        if ( pElement->ShouldHaveLayout() )
        {
            hr = THR( pCurrent->IsEqualTo( _pRight, & fEqual ) );
            if (hr)
                goto Cleanup;

            if ( fEqual )
            {
                // return ppParent as the parent element 
                // of the range
                goto Cleanup;
            }
        }
    }        
    // 
    // End IE4 compat, reset ppParent back to NULL and find the parent element
    //
    ClearInterface( ppParent ); 

    //
    // If the right end of the range is placed after a block break, we would
    // like to adjust it inside the element before detecting the parent element
    //
    {
        DWORD           dwBreaks;

        hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( LeftOrSlave(pPointer, TRUE, & context, NULL, NULL, NULL ) );
        if (hr)
            goto Cleanup;

        //
        // We're looking for cases where the right pointer
        // is immediately after the end scope of an element that has
        // a block break
        //
        if ( context == CONTEXT_TYPE_EnterScope )
        {
            // We've enter the scope of an element, now check for block breaks
            hr = THR( pDoc->QueryBreaks( pPointer, & dwBreaks, FALSE) );
            if (hr)
                goto Cleanup;

            // A Site End is almost the same as a Block Break, so handle that too
            if ( (dwBreaks & (BREAK_BLOCK_BREAK | BREAK_SITE_END)) != BREAK_NONE )
            {
                // Adjust _pRight to the left
                hr = THR( LeftOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
                if (hr)
                    goto Cleanup;
                fBlockBreakAdjustment = TRUE;
                fUseRightForParent = TRUE;
            }
        }
    }    

    if (fUseRightForParent)
        hr = THR( _pRight->CurrentScope( ppParent ) );
    else
        hr = THR( pAdjustedLeft->CurrentScope( ppParent ) );

    if (hr)
        goto Cleanup;

    if (fRangeIsCollapsed && fBlockBreakAdjustment)
    {
        fBlockBreakAdjustment = FALSE;
        hr = THR( RightOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
        if (hr)
            goto Cleanup;
    }

    //
    // CurrentScope return NULL, we must be in a slave,
    // return the master element as the parent element of the range
    //
    if ( *ppParent == NULL )
    {
        hr = THR( pAdjustedLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerLeft ) );
        if( hr )
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerRight ) );
        if( hr )
            goto Cleanup;

        if ( pointerLeft->Markup() == pointerRight->Markup() )
        {
            // If both pointers are in the same markup, return the master
            CTreeNode * pNode = pointerLeft->Branch();
            
            pElement = (pNode && pNode->Element()->HasMasterPtr()) ? pNode->Element()->GetMasterPtr() : NULL;
            if ( !pElement || pElement->Tag() != ETAG_INPUT)
                goto Cleanup;

            hr = THR( pElement->QueryInterface( IID_IHTMLElement, (void **) ppParent ) );
            // Return ppParent as the parent element
            goto Cleanup;
        }
        else
        {
            // if the range pointers are not in the same markup
            // set ppParent to the slave and find the common parent
            // in the loop below...
            ClearInterface( ppParent );
            hr = THR( pDoc->CurrentScopeOrSlave( pAdjustedLeft, ppParent ) );
            if (hr)
                goto Cleanup;
        }
    }        

    //
    // If we have a current scope and the range is collapsed, return ppParent
    //
    if ( fRangeIsCollapsed )
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    // Walk the left pointer up until the right end of the element
    // is to the right of _pRight
    //
    while ( *ppParent )
    {
        BOOL fResult;
        
        hr = THR( pCurrent->MoveAdjacentToElement( *ppParent, ELEM_ADJ_AfterEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( pCurrent->IsLeftOf( _pRight, & fResult ) );

        if (!fResult)
            break; // found common element

        pOldElement = *ppParent;                
        hr = THR( pOldElement->get_parentElement( ppParent ) );
        pOldElement->Release();
        if (hr)
            goto Cleanup;        
        Assert( *ppParent ); // we should never walk up past the root of the tree
    }
    
Cleanup:
    ReleaseInterface( pAdjustedLeft );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface(pCurrent);
    ReleaseInterface(pPointer);
    if (hr)
    {
        ClearInterface( ppParent );
    }

    if ( fBlockBreakAdjustment )
    {
        hr = THR( RightOrSlave( _pRight, TRUE, NULL, NULL, NULL, NULL ) );
    }

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     Duplicate, IHTMLTxtRange
//
//  Synopsis:   Create a duplicate range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::duplicate ( IHTMLTxtRange * * ppTheClone )
{
    HRESULT hr = S_OK;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Create the new range
    //

    hr = THR( GetMarkup()->createTextRange( ppTheClone, _pElemContainer, _pLeft, _pRight, FALSE ) );

    if (hr)
        goto Cleanup;

    Assert( *ppTheClone );

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     InRange, IHTMLTxtRange
//
//  Synopsis:   Determine whether the passed in range in within my range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::inRange ( IHTMLTxtRange * pDispRhs, VARIANT_BOOL * pfInRange )
{
    BOOL         fResult;
    HRESULT      hr = S_OK;   
    CAutoRange * pRangeRhs;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfInRange || !pDispRhs)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Make sure the two ranges belong to the same ped (story)
    //

    hr = THR( pDispRhs->QueryInterface( CLSID_CRange, (void**) & pRangeRhs ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pRangeRhs );

    if (GetMarkup() != pRangeRhs->GetMarkup() || !IsCompatibleWith( pDispRhs ))
    {
        *pfInRange = VB_FALSE;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeRhs->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Now, compare for containment
    // Ranges are ordered left to right, so the following two tests are sufficient
    //
    
    *pfInRange = VB_FALSE; // Assume the result is false

    hr = THR( pRangeRhs->_pLeft->IsLeftOf( _pLeft, & fResult ) );
    if (hr || fResult )
        goto Cleanup;

    hr = THR( _pRight->IsLeftOf( pRangeRhs->_pRight, & fResult ) );
    if (hr || fResult )
        goto Cleanup;

    *pfInRange = VB_TRUE; // Passed the tests so set the result to true

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     IsEqual, IHTMLTxtRange
//
//  Synopsis:   Is the passed in range equal to me?
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::isEqual ( IHTMLTxtRange * pDispRhs, VARIANT_BOOL * pfIsEqual )
{
    BOOL         fResult;
    HRESULT      hr = S_OK;
    CAutoRange * pRangeRhs;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfIsEqual)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Make sure the two ranges belong to the same ped (story)
    //

    hr = THR( pDispRhs->QueryInterface( CLSID_CRange, (void**) & pRangeRhs ) );
    
    if ( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
        
    Assert( pRangeRhs );

    if ( GetMarkup() != pRangeRhs->GetMarkup()  || !IsCompatibleWith( pDispRhs ) )
    {
        *pfIsEqual = VB_FALSE;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeRhs->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Now, compare the ends
    //

    *pfIsEqual = VB_FALSE; 

    hr = THR( _pLeft->IsEqualTo( pRangeRhs->_pLeft, & fResult ) );
    if (hr || !fResult)
        goto Cleanup;

    hr = THR( _pRight->IsEqualTo( pRangeRhs->_pRight, & fResult ) );
    if (hr || !fResult)
        goto Cleanup;

    *pfIsEqual = VB_TRUE;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollIntoView, IHTMLTxtRange
//
//  Synopsis:   Scroll range into view
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::scrollIntoView ( VARIANT_BOOL fStart )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;
    SCROLLPIN   sp = fStart ? SP_MINIMAL : SP_BOTTOMRIGHT;
    CMarkupPointer * pRightInternal = NULL;
    CMarkupPointer * pLeftInternal = NULL;
    LONG cpMin, cpMost;
    CFlowLayout* pFlowLayout = NULL;
    
    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Scroll the end of the selection into view
    pNode = RightNode();
    if (! pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();

    Assert( pNode->Element());
    
    if ( pFlowLayout && (
         ( pFlowLayout == pNode->GetUpdatedNearestLayout() ) || 
         ( pNode->Element()->HasMasterPtr() ) ) )
    {
        hr = THR( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **)&pLeftInternal) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **)&pRightInternal) );
        if (hr)
            goto Cleanup;

        // We are only interested in the end of the selection, so cut off the beginning of 
        // range to avoid the ScrollRangeIntoView asserts

        cpMin  = max(pLeftInternal->GetCp(), pFlowLayout->GetContentFirstCp());
        cpMost = pRightInternal->GetCp();
        
        hr = THR( pFlowLayout->ScrollRangeIntoView( cpMin, cpMost, sp, sp ) );
    }
    else
    {
        hr = THR( pNode->Element()->ScrollIntoView() );
    }

Cleanup:
    // S_FALSE can be returned if we were asked to scroll something that didn't have a 
    // display.  this is not an error but there is nothing that needs to be done.
    RRETURN1( SetErrorInfo( hr ), S_FALSE );
}


//+----------------------------------------------------------------------------
//
//  Member:     collapse, IHTMLTxtRange
//
//  Synopsis:   Collapse the range pointers at start or end
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::collapse ( VARIANT_BOOL fStart )
{
    HRESULT hr = S_OK;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    if  (fStart)
    {
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    }
    else
    {
        hr = THR( _pLeft->MoveToPointer( _pRight ) );
    }

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     Helper function MoveWithinBoundary
//
//  Synopsis:   Wrapper for CMarkupPointer::MoveUnit() which keeps the passed in 
//              pointer within the range boundary.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveWithinBoundary( IMarkupPointer *pPointerToMove, 
                               MOVEUNIT_ACTION muAction, 
                               IMarkupPointer *pBoundary,
                               BOOL            fLeftBound )
{
    IMarkupPointer *    pPointer = NULL;
    BOOL                fSuccess = FALSE;
    HRESULT             hr;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveUnit( muAction ) );
    if (hr)
        goto Cleanup;
    
    if ( fLeftBound )
    {
        BOOL fResult;
        
        hr = THR( pPointer->IsRightOfOrEqualTo( pBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        // Going left we ended up to the right of the boundry
        if ( fResult )
        {
            fSuccess = TRUE;
        }
    }
    else
    {
        BOOL fResult;
        
        hr = THR( pPointer->IsLeftOfOrEqualTo( pBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        // Going right we ended up to the left of the boundry
        if ( fResult )
        {
            fSuccess = TRUE;
        }
    }

    if ( fSuccess )
    {
        hr = THR( pPointerToMove->MoveToPointer( pPointer ) );
        if (hr)
        {
            fSuccess = FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pPointer );
    return fSuccess ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     Expand, IHTMLTxtRange
//
//  Synopsis:   Expands the range by the given unit
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::expand ( BSTR bstrUnit, VARIANT_BOOL * pfSuccess )
{
    HRESULT             hr;
    htmlUnit            Unit;
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;
    IMarkupPointer    * pPointer = NULL;
    long                nCountLeft, nCountRight;
    BOOL                fEqual;
    BOOL                fLeftWasAlreadyExpanded = FALSE;
    BOOL                fRightWasAlreadyExpanded = FALSE;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pfSuccess)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfSuccess = VB_FALSE;

    //
    // Determine what action must take place based on bstrUnit
    //

    hr = ENUMFROMSTRING ( htmlUnit, bstrUnit, (long *)&Unit );
    if ( hr )
        goto Cleanup;

    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;

    switch (Unit)
    {
    case 2: // "Word"
    {

        // Move Left to the beginning of the previous word unless if Left is at beginning of the word already
        // Check End of prev word and compare it to the start of current word
        hr = THR( 
                GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
        if (hr)
            goto Cleanup;

        hr = THR( 
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        // 
        // If the left end of the range is at the end of document
        // we cannot expand by a word.
        //
        hr = THR( pPointer->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE( MoveWithinBoundary( pPointer, MOVEUNIT_NEXTWORDEND, pRightBoundary, FALSE ) );
        if (hr)
        {
            break;
        }

        //
        // The next two MoveWord() calls will place _pLeft at the beginning of the current word,
        // note that MoveWord() unlike MoveUnit() will account for block breaks, BRs, and boundaries
        //
        hr = THR( pPointer->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_PREVWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->IsEqualTo( _pLeft, & fEqual ) );
        if ( fEqual )
        {
            fLeftWasAlreadyExpanded = TRUE;
        }
        else
        {
            hr = THR( _pLeft->MoveToPointer( pPointer ) );
            if (hr)
                goto Cleanup;
        }

        //
        // Move _pRight to the beginning of the next word to include trailing spaces.
        // If there are no trailing spaces, move it to the end of the next word.
        // As usual, check for corner cases in the end of the document.
        //

        hr = THR( pPointer->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_PREVWORDBEGIN, pLeftBoundary, pRightBoundary ) );        
        if (hr)
            goto Cleanup;

        hr = THR( MoveWord( pPointer, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointer->IsEqualTo( _pRight, & fEqual ) );
        if ( fEqual )
        {
            //
            // pRight is at the end or beginning of a word, if pRight is not equal to pLeft
            // we want to expand the word, otherwise, we're already expanded
            //
            hr = THR( _pLeft->IsEqualTo( _pRight, & fEqual ) );
            if (fEqual)
            {
                hr = THR( MoveWord( _pRight, MOVEUNIT_NEXTWORDBEGIN, pLeftBoundary, pRightBoundary ) );                
                if (hr)
                    goto Cleanup;
            }
            else
            {
                fRightWasAlreadyExpanded = TRUE;
            }
        }
        else
        {
            hr = THR( _pRight->MoveToPointer( pPointer ) );
            if (hr)
                goto Cleanup;
        }
        break;
    
    }

    case 3: // "Sentence"
    {
        nCountRight = 1;
        hr  = MoveUnitWithinRange( _pRight, MOVEUNIT_NEXTSENTENCE, & nCountRight );
        if (hr)
            goto Cleanup;

        if (! nCountRight)
        {
            hr = S_FALSE;
            break;
        }

        hr = THR( _pLeft->MoveToPointer( _pRight ) );
        if (hr)
            goto Cleanup;

        nCountLeft = -1;
        hr  = MoveUnitWithinRange( _pLeft, MOVEUNIT_PREVSENTENCE, & nCountLeft );
        if (hr)
            goto Cleanup;

        hr  = (nCountLeft == -1 && nCountRight == 1) ? S_OK : S_FALSE ;
        break;
    }

    case 1: // "Character"   
    {
        nCountRight = 1;
        hr  = MoveUnitWithinRange( _pRight, MOVEUNIT_NEXTCHAR, & nCountRight );
        if (hr)
            goto Cleanup;

        hr  = (nCountRight == 1) ? S_OK : S_FALSE ;
        break;
    }

    case 6: // "TextEdit"
    {
        //
        // Move range pointers to right/left borders to move by textedit units
        //
        hr = THR( 
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->MoveToPointer( pRightBoundary ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pLeft->MoveToPointer( pLeftBoundary ) );
        if (hr)
            goto Cleanup;
            
        break;
    }

    default:
        hr = E_NOTIMPL;
        goto Cleanup;
    }
    
    if (hr == S_OK && (!fLeftWasAlreadyExpanded || !fRightWasAlreadyExpanded) )
    {
        *pfSuccess = VB_TRUE;
    }
    else
    {
        *pfSuccess = VB_FALSE;
        hr = S_OK;
    }

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pPointer );
    hr = THR( ValidatePointers() );

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetMoveUnitAndType
//
//  Synopsis:   Expands the range by the given unit
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::GetMoveUnitAndType( BSTR bstrUnit, long Count, 
                                MOVEUNIT_ACTION     * pmuAction,
                                htmlUnit            * phtmlUnit )
{
    HRESULT     hr = S_OK;

    hr = THR( ENUMFROMSTRING( htmlUnit, bstrUnit, (long *) phtmlUnit ) );
    if (hr)
        goto Cleanup;

    switch (*phtmlUnit)
    {
    case 2: // "Word"
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTWORDBEGIN;
        else
            *pmuAction = MOVEUNIT_PREVWORDBEGIN;
        *phtmlUnit = htmlUnit_Max;
        break;

    case 3: // "Sentence"
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTSENTENCE;
        else
            *pmuAction = MOVEUNIT_PREVSENTENCE;
        *phtmlUnit = htmlUnit_Max;
        break;

    case 1: // "Character"   
        if( Count > 0 )
            *pmuAction = MOVEUNIT_NEXTCHAR; 
        else
            *pmuAction = MOVEUNIT_PREVCHAR; 
        *phtmlUnit = htmlUnit_Max;
        break;

    case 6: // "TextEdit"
        //
        // Since MoveUnit() does not handle TextEdit, this case does not set
        // pmuType, instead phtmlUnit is set properly and will be used by the caller 
        //
        break;

    default:
        hr = E_NOTIMPL;
        *phtmlUnit = htmlUnit_Max;
        break;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     moveToPoint, IHTMLTextRange
//
//  Synopsis:   Clips the point to the client rect of the ped, finds the site
//              which was hit by the point, and within that site finds the
//              cp at which the point lies.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToPoint ( long x, long y )
{
    HRESULT        hr = S_OK;        // The return value
    POINT          pt;               // The point
    POINT          ptOrigin;
    CMarkup      * pMarkup;          // The markup for the range
    CElement     * pElementClient;
    CFlowLayout  * pFlowLayout;
    CTreeNode    * pNode;
    CHitTestInfo   hti;
    HITTESTRESULTS htr;
    CDispNode    * pDisp=NULL;
    CLayout      * pElemLayout = NULL;

    DO_SANITY_CHECK;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // TODO: (dmitryt. track bug 112264) Need to revisit OM issues for multilayoutness.
    // all calls like this should actually be specifically directed to "active default" layout.
    // $$ktam: don't have layout context for pElementClient

    pMarkup = GetMarkup();
    pElementClient = pMarkup->GetElementClient();
    if (!pElementClient)
        goto Cleanup;

    pElemLayout = pElementClient->GetUpdatedLayout();
    if (!pElemLayout)
        goto Cleanup;

    //
    // Construct the point
    // in the global coordinate system
    //
    pElementClient->GetClientOrigin( &ptOrigin );

    pt.x = ptOrigin.x + x;
    pt.y = ptOrigin.y + y;

    //
    // Clip/Restrict the point to the client rect of the ped
    //
    pElemLayout->RestrictPointToClientRect(&pt);

    //
    // Wait for the ped and its parents to recalc, so that we hit test the right stuff
    //
    pElementClient->GetFlowLayout()->WaitForParentToRecalc(-1, pt.y, NULL);

    //
    // Find the site within the ped which was hit. Note that we cannot call the doc's
    // HitTestPoint() because if there are sites which are hovering above this ped,
    // then we will hit test those sites. We want to hit test within our own layout

    htr._fWantArrow = FALSE;
    htr._fRightOfCp = FALSE;
    htr._cpHit = 0;
    htr._iliHit = 0;
    htr._ichHit = 0;
    htr._cchPreChars = 0;

    hti._grfFlags = HT_VIRTUALHITTEST | HT_HTMLSCOPING;
    hti._htc = HTC_NO;
    hti._pNodeElement = NULL;
    hti._pDispNode = NULL;
    hti._ptContent.x = x;
    hti._ptContent.y = y;
    hti._phtr = &htr;
    hti._pLayoutContext = NULL;
    pDisp = pElemLayout->GetElementDispNode(pElementClient);

    if (!pDisp || !pElemLayout->HitTestContent(&pt, pDisp, &hti, FALSE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(hti._htc == HTC_YES);

    //
    // Got the site which was hit. Get the txtsite containing the site (we will always find
    // the ped)> Also be sure that the ped of txtsite we get is the same as the ped of the
    // range. (We could have a text box inside the ped and the point over it -- in this
    // case we do not want the txtsite belonging to the text box. Rather we want the parent
    // text site of the text box).
    //
    // NOTE: (SLAVE_TREE) do we need to iterate through markups? (jbeda)
    pNode = hti._pNodeElement->GetFlowLayoutNode();
    while (pNode->GetMarkup() != pMarkup)
    {
        pNode = pNode->Parent()->GetFlowLayoutNode();
        Assert(pNode);
    }

    pFlowLayout = pNode->HasFlowLayout( hti._pLayoutContext );
    Assert(pFlowLayout);

    //
    // From the display of the textsite we hit, get the cp
    //
    {
        CTreeNode         * pTreeNode =NULL;
        CLayoutContext    * pLayoutContext = NULL;
        POINT               ptContent;
        CMarkupPointer      HitMarkup(pMarkup->Doc());
        BOOL                bNotAtBOL;
        BOOL                bAtLogicalBOL;
        BOOL                bRightOfCp;

        // we need to get from the cp to a markup in order to set _pRight and _pLeft
        // we CAN'T call MoveMarkupToPoint() for these for the same reason that we
        // couldn't call cdoc's HitTestPoint above.
        //-------------------------------------------------------------------------
        // position the markup pointer at the point that we are given
        pTreeNode = pMarkup->Doc()->GetNodeFromPoint( pt, &pLayoutContext, TRUE, &ptContent );
        if( pTreeNode == NULL )
            goto Cleanup;

        // TODO (mikhaill, track bug 112270): This can be incorrect in case of relatively positioned nodes.
        //         I think that following changes shouldd be done:
        //         1) add new variable, CDispNode *pDispnode;
        //         2) pass &pDispnode as 8th argument GetNodeFromPoint();
        //         3) supply MovePointerToPointInternal() with this pDispNode as 13th arg.
        //         See accutil.cxx for example, and bugs 105942, 106131, 109587 fixes.
        //         Not fixed because of improper project stage (mikhaill 5/9/00).
        hr = THR( pMarkup->Doc()->MovePointerToPointInternal( ptContent, 
                                                            pTreeNode,
                                                            pLayoutContext,
                                                            &HitMarkup, 
                                                            &bNotAtBOL,
                                                            &bAtLogicalBOL,
                                                            &bRightOfCp, 
                                                            FALSE,
                                                            pFlowLayout));
        if (hr)
            goto Cleanup;


        hr = THR(SetLeftAndRight(&HitMarkup, &HitMarkup));

    }
Cleanup:

    //
    // MovePointerToPointInternal now returns CTL_E_INVALIDLINE when you attempt to
    // position a markup pointer in a table or TR.  Previously, this was returning
    // E_FAIL.  We want to prop the E_FAIL return code for compat.
    //
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = E_FAIL;
    }

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     setEndPoint, IHTMLTextRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::setEndPoint ( BSTR bstrHow, IHTMLTxtRange * pHTMLRangeSource )
{
    HRESULT hr = S_OK;
    htmlEndPoints how;
    CAutoRange * pRangeSource;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pHTMLRangeSource)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsCompatibleWith( pHTMLRangeSource ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( ENUMFROMSTRING( htmlEndPoints, bstrHow, (long *) & how ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pHTMLRangeSource->QueryInterface(
            CLSID_CRange, (void **) & pRangeSource ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeSource->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    switch ( how )
    {
    case htmlEndPointsStartToStart : 
        SetLeft( pRangeSource->_pLeft );
        break;

    case htmlEndPointsStartToEnd :
        SetLeft( pRangeSource->_pRight );
        break;

    case htmlEndPointsEndToStart :
        SetRight( pRangeSource->_pLeft );
        break;

    case htmlEndPointsEndToEnd :
        SetRight( pRangeSource->_pRight );
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     CompareRangePointers() 
//              helper function for compareEndPoints()
//
//  Synopsis:   Use IE4 compatible comparison for range pointers
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::CompareRangePointers( IMarkupPointer * pPointerSource, IMarkupPointer * pPointerTarget, int * piReturn )
{
    HRESULT     hr;
    BOOL        fLeft;
    CDoc      * pDoc;
    BOOL        fResult;
    CTreeNode * pNode;
    MARKUP_CONTEXT_TYPE context;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );
    CMarkupPointer  pointer( pDoc );

    hr = THR( OldCompare( pPointerSource, pPointerTarget, piReturn ) );
    if (hr)
        goto Cleanup;

    if ( *piReturn == 0 )
    {
        // If the pointers are equal we're done
        goto Cleanup;
    }

    //
    // If Source is greater than Target, the direction is going to be left to right,
    // otherwise we'll go right to left
    //
    fLeft = ( *piReturn == 1 );

    hr = THR( pointer.MoveToPointer( pPointerSource ) );
    if (hr)
        goto Cleanup;

    //
    // We're going to move  from source to target, if we don't encounter any text, 
    // block or layout when we get to target, the range pointers are equal.
    //

    for ( ; ; )
    {
        if( fLeft )
        {
            hr = THR( pointer.Left( TRUE, & context, & pNode, NULL, NULL, NULL ) );
        }
        else
        {
            hr = THR( pointer.Right( TRUE, & context, & pNode, NULL, NULL, NULL ) );
        }

        if( hr )
            goto Cleanup;

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if( pNode )
                {
                    if ( pNode->ShouldHaveLayout() || pNode->Element()->IsBlockElement() )
                    {
                        goto Cleanup;
                    }
                }
                break;

            case CONTEXT_TYPE_Text:            
            case CONTEXT_TYPE_NoScope:
            case CONTEXT_TYPE_None:
                goto Cleanup;

        }
        
        //
        // Check our situation
        //
        hr = THR( pointer.IsEqualTo( pPointerTarget, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            // We successfully moved from source to target, so consider the 
            // pointers equal, and take us outta here
            *piReturn = 0;
            goto Cleanup;
        }

        //
        // If we've gone past the Target, we're done, otherwise keep looping...
        //
        if (fLeft)
        {
            hr = THR( pointer.IsLeftOf( pPointerTarget, & fResult ) );
            if (hr)
                goto Cleanup;

            if ( fResult )
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = THR( pointer.IsRightOf( pPointerTarget, & fResult ) );
            if (hr)
                goto Cleanup;

            if ( fResult )
            {
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN( hr );
}
        

//+----------------------------------------------------------------------------
//
//  Member:     compareEndPoints, IHTMLTextRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::compareEndPoints (
    BSTR bstrHow, IHTMLTxtRange * pHTMLRangeSource, long * pReturn )
{
    HRESULT         hr = S_OK;
    htmlEndPoints   how;
    CAutoRange *    pRangeSource;
    int             iReturn;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pHTMLRangeSource || !pReturn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsCompatibleWith( pHTMLRangeSource ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pReturn = 0;

    hr = THR( ENUMFROMSTRING( htmlEndPoints, bstrHow, (long *) & how ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pHTMLRangeSource->QueryInterface(
            CLSID_CRange, (void **) & pRangeSource ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( pRangeSource->KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    switch ( how )
    {
    case htmlEndPointsStartToStart :
        hr = THR( CompareRangePointers( _pLeft, pRangeSource->_pLeft, & iReturn ) );
        break;

    case htmlEndPointsStartToEnd :
        hr = THR( CompareRangePointers( _pLeft, pRangeSource->_pRight, & iReturn ) );
        break;

    case htmlEndPointsEndToStart :
        hr = THR( CompareRangePointers( _pRight, pRangeSource->_pLeft, & iReturn ) );
        break;

    case htmlEndPointsEndToEnd :
        hr = THR( CompareRangePointers( _pRight, pRangeSource->_pRight, & iReturn ) );
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pReturn = iReturn;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member: CAutoRange::getBookmark
//
//  Synopsis: Passes through to its markup pointers, asking them for a
//            bookmark representing this range.
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::getBookmark ( BSTR * pbstrBookmark )
{
    HRESULT hr = S_OK;
    CMarkupPointer * pLeft, * pRight;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

    if (hr)
        goto Cleanup;

    hr = THR( pLeft->GetBookmark( pbstrBookmark, pRight ) );

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member: CAutoRange::moveToBookmark
//
//  Synopsis: Passes through to its markup pointers, asking them to position
//            themselves at this bookmark
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToBookmark ( BSTR bstrBookmark, VARIANT_BOOL * pvbSuccess )
{
    HRESULT hr = S_OK;
    CMarkupPointer * pLeft, * pRight;

    DO_SANITY_CHECK

    Assert( pvbSuccess );
    *pvbSuccess = VB_FALSE;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pRight ) );

    if (hr)
        goto Cleanup;

    
    hr = THR( pLeft->MoveToBookmark( bstrBookmark, pRight ) );
    
    if( S_OK == hr )
    {
        *pvbSuccess = TRUE;
    }
    else if( S_FALSE == hr )
    {
        // S_FALSE means we didn't find the bookmark, but that's not an error.
        hr = S_OK;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     moveToElementText, IHTMLTxtIRange
//
//  Synopsis:   move the range to encompass an element
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveToElementText ( IHTMLElement * element )
{
    HRESULT hr = S_OK;
    CElement * pElement;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!element)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( element->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hr = THR( SetTextRangeToElement( pElement ) );

    if (hr == S_FALSE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     IsTextInCompatiblePlace, Helper function
//
//  Synopsis:   If text found using findText() is within an OPTION tag, IE4 would
//              not have found it, used for IE4 compat.
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::IsTextInCompatiblePlace( IMarkupPointer * pmpLeft, IMarkupPointer * pmpRight )
{
    ELEMENT_TAG     eTag;
    CTreeNode *     pNode;
    CMarkupPointer* pmp = NULL;

    IGNORE_HR( pmpLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    Assert( pmp );

    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
        return FALSE;
    eTag = pNode->Tag();    
    if (eTag == ETAG_OPTION)
        return FALSE;   

    IGNORE_HR( pmpRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    
    Assert( pmp );

    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    if (!pNode)
        return FALSE;
    eTag = pNode->Tag();    
    if (eTag == ETAG_OPTION)
        return FALSE;
    
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     findText, IHTMLTxtIRange
//
//  Synopsis:   findText within range boundaries
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::findText ( BSTR String, long count, long Flags, VARIANT_BOOL * pfSuccess )
{
    HRESULT          hr = S_OK;
    IMarkupPointer * pLeftBoundary = NULL;
    IMarkupPointer * pRightBoundary = NULL;
    IMarkupPointer * pmpLeft = NULL;
    IMarkupPointer * pmpRight = NULL;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // are all the required parameters provided
    if (!String || !pfSuccess)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // did we actually get a searchstring with text in it
    if (!SysStringLen( String ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Position two temporary pointers that will be used for finding text
    //
    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pmpLeft ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pmpRight ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            pmpLeft->MoveToPointer( _pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            pmpRight->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    //
    // Position the range boundry pointers
    //
    hr = THR( 
            MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    //
    // Call FindText(), for compat reasons we do not want to find text inside an OPTION
    //

    if (count == 0)
    {
        hr = THR( pmpLeft->FindText( String, Flags, pmpRight, pmpRight ) );

        if (hr == S_FALSE)
        {
            hr = S_OK;
            *pfSuccess = VB_FALSE;
            goto Cleanup;
        }

        goto FoundIt;
    }
        
    if ( count < 0 )
        Flags = Flags | FINDTEXT_BACKWARDS;

    for ( ; ; )
    {
        if ( Flags & FINDTEXT_BACKWARDS ) 
        {
            hr = THR( pmpRight->FindText( String, Flags, pmpLeft, pLeftBoundary ) );
        }
        else
        {            
            hr = THR( pmpLeft->FindText( String, Flags, pmpRight, pRightBoundary ) );
        }

        if (hr == S_FALSE)
        {
            // not found
            hr = S_OK;
            *pfSuccess = VB_FALSE;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        if ( IsTextInCompatiblePlace( pmpLeft, pmpRight ) )
            goto FoundIt;

        long cch = 1;
            
        if ( Flags & FINDTEXT_BACKWARDS ) 
            IGNORE_HR( LeftOrSlave( pmpRight, TRUE, NULL, NULL, & cch, NULL ));
        else
            IGNORE_HR( RightOrSlave( pmpLeft, TRUE, NULL, NULL, & cch, NULL ));
    }

Cleanup:
    
    ReleaseInterface( pmpLeft );
    ReleaseInterface( pmpRight );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    
    RRETURN( SetErrorInfo( hr ) );

FoundIt:
    
    *pfSuccess = VB_TRUE;
    
    IGNORE_HR( _pLeft->MoveToPointer( pmpLeft ) );
    IGNORE_HR( _pRight->MoveToPointer( pmpRight ) );
    
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveStart, IHTMLTxtRange
//
//  Synopsis:   move the left end of the range per parameters passed
//
//-----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CAutoRange::moveStart ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Left ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     MoveEnd, IHTMLTxtRange
//
//  Synopsis:   move the right end of the range per parameters passed
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::moveEnd ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Right ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     Move, TxtIRange
//
//  Synopsis:   move the left end of the range per parameters passed, 
//              and collapse the range
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::move ( BSTR bstrUnit, long Count, long * pActualCount )
{
    return THR( moveRange( bstrUnit, Count, pActualCount, MOVERANGE_Both ) );
}


//+----------------------------------------------------------------------------
//
//  Member:     MovePointersToRangeBoundary 
//
//  Synopsis:   Position pointers around the boundry of _pElemContainer
//
//-----------------------------------------------------------------------------
HRESULT
CAutoRange::MovePointersToRangeBoundary ( IMarkupPointer ** ppLeftBoundary,
                                          IMarkupPointer ** ppRightBoundary )
{
    HRESULT             hr = S_OK;
    IHTMLElement      * pHTMLElement = NULL; 
    CDoc              * pDoc = NULL;
    CMarkup           * pMarkup = NULL;
    //
    // Set the left and right borders around _pElemContainer. 
    // Range pointers shall not move outside these boundries or else...
    // 
    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR_NOTRACE( 
            _pElemContainer->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;
    
    pMarkup = GetMarkup();     
    pDoc = pMarkup->Doc();

    Assert( pMarkup );
    Assert( pDoc );

    hr = THR( pDoc->CreateMarkupPointer( ppLeftBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( ppRightBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( (*ppLeftBoundary)->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( (*ppRightBoundary)->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    //
    // Make sure the bounderies cling to text, just like the
    // range pointers do
    //

    hr = THR( AdjustPointers( *ppLeftBoundary, *ppRightBoundary ));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveCharacter
//
//  Synopsis:   Move the range by a single character according to IE4 rules
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveCharacter ( IMarkupPointer * pPointerToMove,
                            MOVEUNIT_ACTION  muAction,
                            IMarkupPointer * pLeftBoundary,
                            IMarkupPointer * pRightBoundary,
                            IMarkupPointer * pJustBefore )
{
    HRESULT hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CTreeNode       *   pNode;
    CDoc            *   pDoc = GetMarkup()->Doc();
    DWORD               dwBreaks;
    IHTMLElement    *   pIElement = NULL;
    CMarkupPointer      pointerSource( pDoc );
    BOOL                fResult;

    extern BOOL IsIntrinsicTag( ELEMENT_TAG eTag );

    Assert ( muAction == MOVEUNIT_PREVCHAR ||  muAction == MOVEUNIT_NEXTCHAR );

    hr = THR( pointerSource.MoveToPointer( pPointerToMove ) );
    
    if (hr)
        goto Cleanup;

    if (pJustBefore)
    {
        hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

        if (hr)
            goto Cleanup;
    }

    //
    // If we are starting out at a block break
    //
    
    if (muAction == MOVEUNIT_NEXTCHAR)
    {
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        
        if (hr)
            goto Cleanup;
            
        if (dwBreaks != BREAK_NONE)
        {
            hr = THR( pointerSource.Right( TRUE, NULL, NULL, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            goto MoveIt;
        }
    }
    
    //
    // Walk pointerSource in the right direction, looking
    // for IE4 compatible text
    //    

    for ( ; ; )
    {
        long cch = 1;
        
        if (pJustBefore)
        {
            hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

            if (hr)
                goto Cleanup;
        }

        if (muAction == MOVEUNIT_PREVCHAR)
        {
            hr = THR( pointerSource.Left( TRUE, & context, & pNode , & cch, NULL, NULL ));

            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR( pointerSource.Right( TRUE, & context, & pNode , & cch, NULL, NULL ));
            
            if (hr)
                goto Cleanup;
        }

        switch( context )
        {
        //
        // Nowhere to go - we bail.
        //
            
        case CONTEXT_TYPE_None:
        case CONTEXT_TYPE_Text:
            goto MoveIt;

        case CONTEXT_TYPE_NoScope:

            if ( pNode->Tag() == ETAG_BR      ||
                 pNode->Tag() == ETAG_SCRIPT  ||
                 pNode->Element()->ShouldHaveLayout() )
            {
                // Per IE4, if we pass a BR, SCRIPT or noscope with a layout 
                // before hitting text, then we're done. 
                goto MoveIt;
            }
            break;

        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            
            Assert( pNode );

            if (IsIntrinsicTag( pNode->Tag() ))
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've traveled over text before.
                
                ClearInterface( & pIElement );
                
                hr = THR( pNode->Element()->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );
                
                if (hr)
                    goto Cleanup;

                if ( muAction == MOVEUNIT_NEXTCHAR )
                    hr = THR( pointerSource.MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterEnd ) );
                else
                    hr = THR( pointerSource.MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ) );
                
                goto MoveIt;
            }
            
            break;            
        }

        //
        // Check whether we have hit a break before reaching text
        //
        
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        
        if (hr)
            goto Cleanup;

        if (dwBreaks != BREAK_NONE)
        {
            // If I hit a break while going right, I want to be after the break
            // going left however, I want to stop right where I am.
            //
            
            if (muAction == MOVEUNIT_NEXTCHAR)
            {
                long cch = 1;
                
                hr = THR( pointerSource.Right( TRUE, & context, & pNode , &cch, NULL, NULL ));
                
                if (hr)
                    goto Cleanup;
            }

            goto MoveIt;
        }

    }

Cleanup:
    
    ReleaseInterface( pIElement );
    
    RRETURN( hr );
    
MoveIt:

    fResult = FALSE;

    if (muAction == MOVEUNIT_PREVCHAR)
    {
        hr = THR( pointerSource.IsLeftOf( pLeftBoundary, & fResult ) );

        if (hr)
            goto Cleanup;

        if (fResult)
        {
            hr = THR( pointerSource.MoveToPointer( pLeftBoundary ) );

            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR( pointerSource.IsRightOf( pRightBoundary, & fResult ) );

        if (hr)
            goto Cleanup;

        if (fResult)
        {
            hr = THR( pointerSource.MoveToPointer( pRightBoundary ) );

            if (hr)
                goto Cleanup;
        }
    }
    
    if (fResult && pJustBefore)
    {
        hr = THR( pJustBefore->MoveToPointer( & pointerSource ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( pPointerToMove->MoveToPointer( & pointerSource ) );
    
    if (hr)
        goto Cleanup;

    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveWord
//
//  Synopsis:   MoveWord() is a wrapper for MoveUnit(). It stops at IE4 word breaks
//              that MoveUnit() ignores such as:
//              <BR>, Block Break, TSB, TSE, and Intrinsics 
//              The only muActions supported are MOVEUNIT_PREVWORDBEGIN and 
//              MOVEUNIT_NEXTWORDBEGIN
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::MoveWord ( IMarkupPointer * pPointerToMove,
                       MOVEUNIT_ACTION  muAction,
                       IMarkupPointer * pLeftBoundary,
                       IMarkupPointer * pRightBoundary )
{
    HRESULT hr;
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    CTreeNode       *   pNode;
    CDoc            *   pDoc;
    DWORD               dwBreaks;
    BOOL                fResult;
    BOOL                fPassedText;
    BOOL                fPassedBlock;
    IHTMLElement    *   pIElement = NULL;

    extern BOOL IsIntrinsicTag( ELEMENT_TAG eTag );

    Assert ( muAction == MOVEUNIT_PREVWORDBEGIN || 
             muAction == MOVEUNIT_NEXTWORDBEGIN );

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    //
    // pPointerDestination is where MoveUnit() would have positioned us, however, 
    // since MoveUnit() does not account for IE4 word breaks like intrinsics,
    // Block Breaks, text site begin/ends, and Line breaks, we use another pointer
    // called pPointerSource. This pointer walks towards pPointerDestination
    // to detect IE4 word breaking characters that MoveUnit() does not catch.
    //
    CMarkupPointer  pointerSource( pDoc );
    CMarkupPointer  pointerDestination( pDoc );

    hr = THR( 
            pointerSource.MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            pointerDestination.MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR(
            pointerDestination.MoveUnit( muAction ) );
    if (hr)
        goto Cleanup;

    //
    // MoveUnit() may place the destination outside the range boundary. 
    // First make sure that the destination is within range boundaries.
    //
    if ( muAction == MOVEUNIT_PREVWORDBEGIN )
    {
        hr = THR( pointerDestination.IsLeftOf( pLeftBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            hr = THR( pointerDestination.MoveToPointer( pLeftBoundary ) );
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR( pointerDestination.IsRightOf( pRightBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            hr = THR( pointerDestination.MoveToPointer( pRightBoundary ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Walk pointerSource towards pointerDestination, looking
    // for word breaks that MoveUnit() might have missed.
    //
    
    fPassedText = FALSE;
    fPassedBlock = FALSE;

    for ( ; ; )
    {
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            hr = THR( pointerSource.Left( TRUE, & context, & pNode , NULL, NULL, NULL ));
        }
        else
        {
            hr = THR( pointerSource.Right( TRUE, & context, & pNode , NULL, NULL, NULL ));
        }
        if ( hr )
            goto Cleanup;

        switch( context )
        {
        case CONTEXT_TYPE_None:
            break;
            
        case CONTEXT_TYPE_Text:
            fPassedText = TRUE;
            break;

        case CONTEXT_TYPE_NoScope:
        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if ( !pNode )
                break;

            if ( IsIntrinsicTag( pNode->Tag() ) )
            {
                // Move over intrinsics (e.g. <BUTTON>), don't go inside them like MoveUnit() does.
                // Here the passed in pointer is set before or after the intrinsic based
                // on our direction and whether or not we've travelled over text before.
                ClearInterface( & pIElement );
                hr = THR( pNode->Element()->QueryInterface( IID_IHTMLElement, (void **) & pIElement ) );
                if (hr)
                    goto Cleanup;

                if ( muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( pIElement, 
                                fPassedText ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ) );
                }
                else
                {
                    hr = THR( pPointerToMove->MoveAdjacentToElement( pIElement, 
                                fPassedText ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                }
                //
                // We're done
                //
                goto Cleanup;
            }

            
            // <BR> is a word break 
            if ( pNode->Tag() == ETAG_BR )
            {
                if ( (fPassedText || fPassedBlock) && muAction == MOVEUNIT_NEXTWORDBEGIN )
                {
                    // If we're travelling right and have passed some text, backup
                    // before the last BR, we've gone too far.
                    hr = THR( pointerSource.Left( TRUE, NULL, NULL, NULL, NULL, NULL ));
                    goto Done;
                }
                else if ( muAction == MOVEUNIT_PREVWORDBEGIN )
                {
                    // Travelling left we are at the right place: we're at the beginning of <BR>
                    // which is a valid word break.
                    goto Done;
                }                 
                else
                {
                    fPassedText = TRUE;
                }           
            }
            else if (pNode->Element()->ShouldHaveLayout()
                     || context == CONTEXT_TYPE_NoScope)
            {
                fPassedText = TRUE;
            }
            else if ( pNode->Element()->IsBlockElement() )
            {
                fPassedBlock = TRUE;
            }
            break;
            
        }

        //
        // If we are at or beyond the destination point where MoveUnit() took us, 
        // set the passed in pointer to the destination and we're outta here
        //
        if ( muAction == MOVEUNIT_PREVWORDBEGIN )
        {            
            if ( pointerSource.IsLeftOfOrEqualTo( & pointerDestination ) )
            {                
                hr = THR( 
                        pPointerToMove->MoveToPointer( & pointerDestination ) );
                goto Cleanup;
            }
        }
        else
        {
            if ( pointerSource.IsRightOfOrEqualTo( & pointerDestination ) )
            {                
                hr = THR( 
                        pPointerToMove->MoveToPointer( & pointerDestination ) );
                goto Cleanup;
            }
        }

        //
        // Detect Block break, Text site begin or text site end
        //
        hr = THR( pointerSource.QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        // We hit a break before reaching our destination, time to stop...
        if ( dwBreaks != BREAK_NONE )
        {
            if (fPassedText || fPassedBlock)
            {
                // We're done
                goto Done;
            }
            else
            {
                fPassedText = TRUE;
            }
        }
    }

Done:
    hr = THR( 
            pPointerToMove->MoveToPointer( & pointerSource ) );
    if (hr)
        goto Cleanup;
    
Cleanup:
    ReleaseInterface( pIElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     MoveUnitWithinRange
//
//  Synopsis:   Helper function for moveRange, watches MoveUnit() to ensure 
//              that range pointers don't go outside the range boundaries
//
//-----------------------------------------------------------------------------

HRESULT 
CAutoRange::MoveUnitWithinRange( IMarkupPointer * pPointerToMove, 
                                 MOVEUNIT_ACTION  muAction,
                                 long * pnActualCount )
{
    HRESULT hr = S_OK;
    long    nRequestedCount;
    BOOL    fLeftBound;
    long    i;
    IMarkupPointer * pPointer = NULL;
    IMarkupPointer * pLeftBoundary = NULL;
    IMarkupPointer * pRightBoundary = NULL;
    BOOL             fEqual;
    
    fLeftBound = ( (*pnActualCount) < 0 );
    nRequestedCount = abs(*pnActualCount);
    *pnActualCount = 0;

    hr = THR( 
            GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr) 
        goto Cleanup;

    hr = THR( 
            pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( 
            MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    //
    // Bail if we are at range boundaries and we're going the wrong way
    //
    if (fLeftBound)
    {
        IGNORE_HR( 
                pPointer->IsEqualTo( pLeftBoundary, & fEqual ) );

        if ( fEqual )
        {
            goto Cleanup;
        }
    }
    else
    {
        IGNORE_HR( 
                pPointer->IsEqualTo( pRightBoundary, & fEqual ) );

        if ( fEqual )
        {
            goto Cleanup;
        }
    }
  
    //
    // Do the move...
    //

    for ( i=1; i <= nRequestedCount; i++ )
    {      
        if ( muAction == MOVEUNIT_NEXTCHAR ||
             muAction == MOVEUNIT_PREVCHAR )
        {
            MARKUP_CONTEXT_TYPE context;
            
            // Look left for text.  If we find text, skip over it with
            // Left/Right instead of MoveCharacter.
            //
            if (fLeftBound)
                hr = THR(LeftOrSlave(pPointer, FALSE, &context, NULL, NULL, NULL));
            else
                hr = THR(RightOrSlave(pPointer, FALSE, &context, NULL, NULL, NULL));
            if (FAILED(hr))
                goto Cleanup;
                
            if (context == CONTEXT_TYPE_Text)
            {
                LONG cCharactersLeft = nRequestedCount - i + 1;

                if (fLeftBound)
                    hr = THR(LeftOrSlave( pPointer, TRUE, NULL, NULL, &cCharactersLeft, NULL));
                else
                    hr = THR(RightOrSlave(pPointer, TRUE, NULL, NULL, &cCharactersLeft, NULL));
                if (FAILED(hr))
                    goto Cleanup;

                if (cCharactersLeft > 0)
                {
                    i += (cCharactersLeft - 1);                
                }
                else
                {
                    hr = THR( MoveCharacter( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
                }
            }
            else
            {           
                hr = THR( MoveCharacter( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
            }
        }
        else if ( muAction == MOVEUNIT_NEXTWORDBEGIN ||
                  muAction == MOVEUNIT_PREVWORDBEGIN )
        {
            hr = THR( 
                    MoveWord( pPointer, muAction, pLeftBoundary, pRightBoundary ) );
        }
        else
        {
            hr = THR( pPointer->MoveUnit( muAction ) );
        }
        
        if (hr)
        {
            if (hr == S_FALSE)
            {
                hr = S_OK;
            }
            break;
        }

        //
        // Update the count of movements made and 
        // check to see if we are within range boundaries
        //
        if (fLeftBound)
        {            
            (*pnActualCount) = -1*i;

            IGNORE_HR( pPointer->IsLeftOfOrEqualTo( pLeftBoundary, & fEqual ) );
            
            if ( fEqual )
            {
                hr = THR( 
                       pPointerToMove->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;

                // We're Done
                break;
            }            
        }
        else
        {    
            (*pnActualCount) = i;

            IGNORE_HR( pPointer->IsRightOfOrEqualTo( pRightBoundary, & fEqual ) );

            if ( fEqual )
            {
                hr = THR( 
                       pPointerToMove->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;

                // We're Done
                break;
            }            
        }

        hr = THR( 
               pPointerToMove->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     moveRange
//
//  Synopsis:   private method that implements move(), moveStart() and moveEnd()
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::moveRange ( BSTR bstrUnit, long Count, long * pActualCount, int moveWhat )
{
    HRESULT hr;
    MOVEUNIT_ACTION     muAction;
    htmlUnit            Unit;
    IMarkupPointer    * pLeftBoundary  = NULL;
    IMarkupPointer    * pRightBoundary = NULL;
    BOOL                fEqual;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!pActualCount)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Initialize actual count value to zero
    //
    *pActualCount = 0;

    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Make sure the range is positioned correctly
    //
    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    //
    // Determine what action must take place based on the bstrUnit
    //
    hr = THR( GetMoveUnitAndType( bstrUnit, Count, & muAction, & Unit ) );
    if (hr)
        goto Cleanup;

    if ( Unit != htmlUnitTextEdit )
    {
        // Use MoveUnit() to move by Character, Word, or Sentence

        Assert( Unit == htmlUnit_Max );

        *pActualCount = Count;

        if (moveWhat == MOVERANGE_Right)
        {
            hr = THR( 
                    MoveUnitWithinRange( _pRight, muAction, pActualCount ) );
        }
        else
        {
            hr = THR( 
                    MoveUnitWithinRange( _pLeft, muAction, pActualCount ) );
        }
                                 
    }
    else
    {
        //
        // Move range pointers to right/left borders to move by textedit units
        //

        if (Count == 0 || Count < -1 || Count > 1)
        {
            // Can only move textedit by -1 or 1 units
            hr = S_OK;
            goto Cleanup;
        }

        //
        // Position the left/right boundry pointers around _pElemContainer
        //
        hr = THR(
                MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
        if (hr)
            goto Cleanup;

        //
        // Move the pointers according to the values passed
        // Note that if the pointer is already where
        // it is asked to go, we don't do anything. ActualCount of
        // zero is returned in such cases to be compatible with IE4
        //
        if (Count == 1)
        {
            if (moveWhat == MOVERANGE_Right)
            {
                hr = THR( _pRight->IsEqualTo( pRightBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pRight->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = THR( _pLeft->IsEqualTo( pRightBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pLeft->MoveToPointer( pRightBoundary ) );
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            Assert( Count == -1 );

            if (moveWhat == MOVERANGE_Right)
            {
                hr = THR( _pRight->IsEqualTo( pLeftBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pRight->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = THR( _pLeft->IsEqualTo( pLeftBoundary, &fEqual ) );
                if (hr || fEqual)
                    goto Cleanup;

                hr = THR( _pLeft->MoveToPointer( pLeftBoundary ) );
                if (hr)
                    goto Cleanup;
            }            
        }
        //
        // Oh, yes don't forget to set pActualCount for textedit move
        //
        *pActualCount = Count;
    }
    
    //
    // Here we collapse the range according to IE4 behavior:
    // move() must always collapse at the Start (left)
    // moveStart and moveEnd collapse the range at start or end
    // respectively, only if start is after the end
    // 
    if (moveWhat == MOVERANGE_Both)
    {
        // Collapse the range for move()
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
        if (hr)
            goto Cleanup;
    }
    else
    {
        int result;
        
        IGNORE_HR( _pLeft->IsRightOf( _pRight, & result ) );
        
        if (result)
        {
            if (moveWhat == MOVERANGE_Left)
            {
                // Collpase the range at the start for MOVERANGE_Left
                hr = THR( _pRight->MoveToPointer( _pLeft ) );
                if (hr)
                    goto Cleanup;
            }
            else 
            {
                // Collapse the range at the end for MOVERANGE_Right case
                hr = THR( _pLeft->MoveToPointer( _pRight ) );
                if (hr)
                    goto Cleanup;
            }
        }
    }

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    RRETURN( SetErrorInfo( hr ) );
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandSupported(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandEnabled(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandState(bstrCmdId, pfRet));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(CBase::queryCommandIndeterm(bstrCmdId, pfRet));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(CBase::queryCommandText(bstrCmdId, pcmdText));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CAutoRange::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(CBase::queryCommandValue(bstrCmdId, pvarRet));
}


//+----------------------------------------------------------------------------
//
//  Member:     execCmd, IHTMLTxtRange
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT varValue, VARIANT_BOOL * pfRet )
{
    HRESULT hr = S_OK;
    BOOL fAllow;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Check for security violations

    hr = THR(GetMarkup()->AllowClipboardAccess(bstrCmdId, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;           // Fail silently

    if (!CheckSecurity((LPCWSTR) bstrCmdId))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CBase::execCommand(bstrCmdId, showUI, varValue));
    if(hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

Cleanup:

    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CheckSecurity
//
//  Synopsis:   Check for things like paste into File Input or Copy from Password
//
//-----------------------------------------------------------------------------
BOOL
CAutoRange::CheckSecurity(LPCWSTR pszCmdId)
{
    BOOL                fPaste = FALSE;
    BOOL                fCopy = FALSE;
    BOOL                fOk = TRUE;
    HRESULT             hr = S_OK;
    CMarkupPointer    * pointerLeft;
    CMarkupPointer    * pointerRight;
    CElement          * pElement;
    htmlInput           type;

    if (StrCmpICW(pszCmdId, L"paste") == 0)
        fPaste = TRUE;
    else if (StrCmpICW(pszCmdId, L"copy") == 0)
        fCopy = TRUE;
    else
        goto Cleanup;       // Nothing to do here

    // Get the element to check for being in an Input element
    hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerLeft ) );
    if( hr )
        goto Cleanup;

    hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointerRight ) );
    if( hr )
        goto Cleanup;

    if ( pointerLeft->Markup() == pointerRight->Markup() )
    {
        // If both pointers are in the same markup, return the master
        CTreeNode * pNode = pointerLeft->Branch();
        
        pElement = (pNode && pNode->Element()->HasMasterPtr()) ? pNode->Element()->GetMasterPtr() : NULL;
        if ( !pElement || (pElement->Tag() != ETAG_INPUT))
            goto Cleanup;

        type = DYNCAST(CInput, pElement)->GetType();

        if (type == htmlInputFile)
            fOk = FALSE;
    }

Cleanup:
    if (S_OK != hr)
        fOk = FALSE;
    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CAutoRange::execCommandShowHelp(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT   hr;

    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CBase::execCommandShowHelp(bstrCmdId));

Cleanup:

    if(pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}




//+----------------------------------------------------------------------------
//
//  Member:     select, IAutoRange
//
//  Synopsis:   take the given range (this), goto the markups selection and set it
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::select ( )
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup  = GetMarkup();
    CDoc *      pDoc = NULL;     
    SELECTION_TYPE eSelType  = SELECTION_TYPE_Text;
    BOOL fEqual = FALSE;
    
    if( ! pMarkup )
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );
        
    if ( ! pDoc->_pInPlace )
    {
        hr = S_OK ;
        goto Cleanup;
    }
        
    IGNORE_HR( scrollIntoView ( TRUE ) );

    //
    // IE 4.01 Compat if the 
    //
    hr = THR( _pLeft->IsEqualTo(_pRight, &fEqual) );
    if ( hr )
    {
        AssertSz(0,"Compare on pointers failed - are they in the same tree ?");
        goto Cleanup;
    }
    
    if( fEqual )
    { 
        eSelType  = SELECTION_TYPE_Caret;
    }
    hr = THR( pDoc->Select( _pLeft, _pRight , eSelType ));

Cleanup:
    RRETURN ( SetErrorInfo(hr) );   
}

//+====================================================================================
//
// Method: IsRangeEquivalentToSelection
//
// Synopsis: Is the given range "equivalent" to the selection
//
//------------------------------------------------------------------------------------


HRESULT
CAutoRange::IsRangeEquivalentToSelection ( BOOL *pfEquivalent)
{
    HRESULT             hr = S_OK;
    BOOL                fEquivalent = FALSE;
    IMarkupPointer      *pSelStart = NULL;
    IMarkupPointer      *pSelEnd = NULL;
    ISegmentList        *pSegmentList = NULL;
    CDoc                *pDoc = GetMarkup()->Doc();
    ISegment            *pSegment = NULL;
    ISegmentListIterator *pIter = NULL;
    
    if ( pDoc->GetSelectionType() == SELECTION_TYPE_Text ||
         pDoc->GetSelectionType() == SELECTION_TYPE_Control )
    {    
        hr = THR( pDoc->CreateMarkupPointer( & pSelStart ));
        if ( hr )
            goto Cleanup;

        hr = THR( pDoc->CreateMarkupPointer( & pSelEnd ));
        if ( hr )
            goto Cleanup;
            
        hr = THR( pDoc->GetCurrentSelectionSegmentList( & pSegmentList ));    
        if ( hr )
            goto Cleanup;

#if DBG
        BOOL fEmpty;
        
        hr = THR( pSegmentList->IsEmpty(&fEmpty) );
        if( hr )
            goto Cleanup;

        Assert( !fEmpty );            
#endif

        hr = THR( pSegmentList->CreateIterator( &pIter ) );
        if( hr )
            goto Cleanup;

        hr = THR( pIter->Current(&pSegment) );
        if( hr )
            goto Cleanup;
            
        hr = THR( pSegment->GetPointers( pSelStart, pSelEnd ));
        if ( hr )
            goto Cleanup;

        //
        // Now make the pointers cling to text like the range dows.
        //
        hr = AdjustPointers( pSelStart, pSelEnd );
        if ( hr )
            goto Cleanup;

        hr = THR ( pSelStart->IsEqualTo( _pLeft, &fEquivalent ));
        if ( hr )
            goto Cleanup;

        if ( fEquivalent )
        {
            hr = THR ( pSelEnd->IsEqualTo( _pRight, & fEquivalent ));
            if ( hr )
                goto Cleanup;  
        }
    }
Cleanup:
    if ( pfEquivalent )
        *pfEquivalent = fEquivalent;

    ReleaseInterface( pSegment );
    ReleaseInterface( pIter );
    ReleaseInterface( pSelStart );
    ReleaseInterface( pSelEnd );
    ReleaseInterface( pSegmentList );
    
    RRETURN( hr );        
}
//+----------------------------------------------------------------------------
//
//  Member:     pasteHTML, IAutoRange
//
//  Synopsis:   Used to be put_htmltext
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CAutoRange::pasteHTML ( BSTR htmlText )
{
    HRESULT     hr = S_OK;
    CParentUndo pu( GetMarkup()->Doc() );
    CElement *  pContainer;
    BOOL        result;
    IHTMLElement* pIFlowElement1 = NULL;
    IHTMLElement* pIFlowElement2 = NULL;
    IObjectIdentity * pIdentity = NULL;
    CMarkup *   pMarkup = GetMarkup();   
    CDoc     *  pDoc = pMarkup->Doc();
    BOOL fInSameFlow = TRUE;
    BOOL fRangeEquivalentToSelection = FALSE;
    
    DO_SANITY_CHECK

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    pContainer = GetCommonContainer();

    if (pContainer && pContainer->TestClassFlag( CElement::ELEMENTDESC_OMREADONLY ))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!FSupportsHTML())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // CHeck the pointers are both in the same flow layout. If they're not - fail.
    //
    hr = THR( pDoc->GetFlowElement( _pLeft, & pIFlowElement1));
    if ( hr )
        goto Cleanup;

    hr = THR( pDoc->GetFlowElement( _pRight, & pIFlowElement2));
    if ( hr )
        goto Cleanup;

    hr = THR( pIFlowElement1->QueryInterface( IID_IObjectIdentity, (void **) &pIdentity ) );
    if (hr)
        goto Cleanup;

    fInSameFlow = ( pIdentity->IsEqualObject( pIFlowElement2 ) == S_OK );   
    if ( ! fInSameFlow )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    //
    // See if the range and the selection are "equivalent" - ie the pointers are in the same places
    // if they are - we have to mimic the ie 4 behavior of collapsing to a caret at the end of paste.
    //

    hr = THR( IsRangeEquivalentToSelection( & fRangeEquivalentToSelection));
    if ( hr)
        goto Cleanup;
        
    if( pContainer->IsEditable(/*fCheckContainerOnly*/FALSE) )
        pu.Start( IDS_UNDOPASTE );

    //
    //
    //
    
    {
        CMarkupPointer * pmpLeft, * pmpRight;

        extern HRESULT HandleIE50CompatUIPasteHTML (
            CMarkupPointer *, CMarkupPointer *, const TCHAR *, long, BOOL );

        hr = THR( _pLeft->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpRight ) );

        if (hr)
            goto Cleanup;

        hr = THR( HandleIE50CompatUIPasteHTML( pmpLeft, pmpRight, htmlText, -1, TRUE ) );

        if (hr == S_FALSE)
        {
            hr = S_OK; 
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    
    //
    // Collapse the range after the paste
    // Note: Since _pLeft has right gravity and _pRight has left gravity
    //       after paste, _pLeft ends up to the right of _pRight.
    //       That's why we're moving _pRight to _pLeft to collapse the range.
    //
    
    hr = THR( _pLeft->IsRightOf( _pRight, & result ) );

    if ( result )
        hr = THR( _pRight->MoveToPointer( _pLeft ) );
    else
        hr = THR( _pLeft->MoveToPointer( _pRight ) );

    hr = THR( ValidatePointers() );

    if (hr)
        goto Cleanup;

    //
    // Place the caret where we just pasted.
    //
    if ( fRangeEquivalentToSelection )
    {
        hr = THR( GetMarkup()->Doc()->Select( _pRight,_pRight, SELECTION_TYPE_Caret ));
    }        

Cleanup:
    ReleaseInterface( pIFlowElement1 );
    ReleaseInterface( pIFlowElement2 );
    ReleaseInterface( pIdentity );
    
    pu.Finish( hr );

    RRETURN( SetErrorInfo( hr ) );
}


//+-------------------------------------------------------------------
//
//  function : GetRangeTopLeft()
//
//  Synopsis : just a local helper function for getting the offsetTop
//      and the offsetLeft.
//
//-------------------------------------------------------------------
HRESULT
CAutoRange::GetRangeTopLeft(POINT * pPt, BOOL fScreenCoord)
{
    HRESULT       hr = S_OK;
    CDataAry<RECT>  aryRects(Mt(CAutoRangeGetRangeBoundingRect_aryRects_pv));
    CDataAry<RECT> * paryRects = &aryRects;
    RECT *  prc;
    LONG    iRect;
    LONG    lSize;

    if (!pPt)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pPt->x = pPt->y = 0;

    // Get the bounding rectangles
    hr = THR(GetRangeBoundingRects(&aryRects, fScreenCoord));
    if(hr)
        goto Cleanup;

    lSize = paryRects->Size();

    // skip any zero rects in our search for the rect of the first line
    for(  prc = *paryRects, iRect =0 ;
          (   prc 
           && prc->left == 0 
           && prc->right == 0 
           && prc->top == 0 
           && prc->bottom == 0
           && iRect < lSize ); 
           prc++, iRect++ )
           
               ;

    // Set the Point to the left and top of the first non-zero rect
    if (prc)
    {
        pPt->y = prc->top;
        pPt->x = prc->left;
        
        if (GetContainer())
        {
            POINT ptOrg;
            GetContainer()->GetClientOrigin(&ptOrg);
            pPt->x -= ptOrg.x;
            pPt->y -= ptOrg.y;
        }

    }

 Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     offsetTop,  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the offsetTop of the start cp of the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_offsetTop( long *pLong )
{
    HRESULT    hr;
    POINT      pt;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsOrphaned())
    {
        *pLong = -1;
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetRangeTopLeft( &pt, TRUE)); 

    *pLong = (hr) ? -1 : pt.y;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     offsetLeft,  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the offsetleft of the start cp of the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_offsetLeft( long *pLong )
{
    HRESULT    hr;
    POINT      pt;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsOrphaned())
    {
        *pLong = -1;
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(GetRangeTopLeft( &pt, TRUE)); 

    *pLong = (hr) ? -1 : pt.x;

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}



//+-----------------------------------------------------------------
//
//  member : GetRangeBoundingRects()
//
//  synopsis : private helper function used by the boundingBox queries.
//               returns the array that has a rectangle for each line
//               in the range
//
//------------------------------------------------------------------

HRESULT
CAutoRange::GetRangeBoundingRects(CDataAry<RECT> * pRects, BOOL fScreenCoord)
{
    HRESULT     hr = S_FALSE;
    CTreeNode * pNode = NULL;
    CTreeNode * pNodeLeft;
    CFlowLayout * pFlowLayout = NULL;

    if (IsOrphaned())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pRects);

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    if (! IsRangeCollapsed() )
    {
        pNodeLeft = LeftNode();

        if (! pNodeLeft)
            goto Cleanup;

        pNode = pNodeLeft->GetFirstCommonAncestor( RightNode(), NULL);
    }
    else
    {
        pNode = LeftNode();
    }

    if(!pNode)
        goto Cleanup;

    pFlowLayout = pNode->GetFlowLayout();

    if(   pFlowLayout
       && !pFlowLayout->IsDisplayNone())
    {
        CNotification    nf;
        CMarkupPointer * pLeft;
        CMarkupPointer * pRight = NULL;
        int              cpClipStart; 
        int              cpClipFinish;

        hr = THR_NOTRACE( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **) & pLeft) );
        if (! hr)
            hr = THR_NOTRACE( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **) & pRight) );
        if (hr)
            goto Cleanup;

        cpClipStart = pLeft->GetCp();
        cpClipFinish = pRight->GetCp();

        Assert( cpClipStart <= cpClipFinish);

        nf.RangeEnsurerecalc(cpClipStart, cpClipFinish - cpClipStart, pNode);
        pLeft->Markup()->Notify(&nf);
    
        // OVERKILL - but the above recalc is not sufficient, EnsureView needs to be
        // called. However, we can be a little clever and only do this work if we have
        // NOT already called onload.  After this we know that we have calculated at 
        // least once and this will likely be correct
        if (   pFlowLayout->ElementOwner()->GetMarkup()
            && pFlowLayout->ElementOwner()->GetMarkup()->Window()
            && !pFlowLayout->ElementOwner()->GetMarkup()->Window()->_fFiredOnLoad )
        {
            hr = THR(pFlowLayout->ElementOwner()->EnsureRecalcNotify());
            if (hr) 
                goto Cleanup;
        }

        // We cannot pass the bounding rect to the function because in that case
        // it will ignore the cpMin and cpMost
        pFlowLayout->RegionFromElement(
                            pNode->Element(),
                            pRects,
                            NULL,
                            NULL,  
                            fScreenCoord
                                ? RFE_SCREENCOORD | RFE_SELECTION
                                : RFE_SELECTION,
                            cpClipStart, 
                            cpClipFinish); 
    }
                        
Cleanup:
    if (hr == S_FALSE)
        hr = S_OK;
    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  member : GetRangeBoundingRect()
//
//  synopsis : private helper function used by the boundingBox queries.
//
//------------------------------------------------------------------


HRESULT
CAutoRange::GetRangeBoundingRect(RECT * prcBound, BOOL fScreenCoord)
{
    HRESULT         hr;
    CDataAry<RECT>  aryRects(Mt(CAutoRangeGetRangeBoundingRect_aryRects_pv));

    Assert(prcBound);

    prcBound->left = prcBound->right = prcBound->top = prcBound->bottom = 0;

    hr = THR(GetRangeBoundingRects(&aryRects, fScreenCoord));
    if(hr)
        goto Cleanup;

    // Calculate and return the total bounding rect
    BoundingRectForAnArrayOfRectsWithEmptyOnes(prcBound, &aryRects);

    // and turn the rect into "frame" window coordinates. (5.0 compat due to Native Frames)
    // this only applies to frames.  Viewlinks are considered in the parent window and so 
    // we should not pull the ClientOrigin off.  However we need to find the nearest Windowed
    // markup and remove that origin
    if (   GetContainer()
        && GetContainer()->GetMarkup())
    {
        POINT      ptOrg;
        CMarkup  * pMarkup = GetContainer()->GetMarkup();
        CElement * pMaster = pMarkup->Root()->GetMasterPtr();

        if (   pMaster
            && pMaster->Tag() == ETAG_INPUT)
        {
            pMarkup = pMaster->GetMarkup();

        }
        
        pMarkup->GetElementTop()->GetClientOrigin(&ptOrg);

        prcBound->left   -= ptOrg.x;
        prcBound->right  -= ptOrg.x;
        prcBound->top    -= ptOrg.y;
        prcBound->bottom -= ptOrg.y;
    }

Cleanup:
    RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  member : CAutoRange::getBoundingClientRect() - External method
//
//  Synopsis:   Returns Bounding rect of the range text in client
//                coordinates
//------------------------------------------------------------------

HRESULT
CAutoRange::getBoundingClientRect(IHTMLRect **ppIRect)
{
    HRESULT       hr = S_OK;
    CRect         Rect;
    COMRect     * pOMRect = NULL;

    DO_SANITY_CHECK

    if (!ppIRect)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppIRect = NULL;

    // Get the infromation
    hr = THR(GetRangeBoundingRect(&Rect));
    if(hr)
        goto Cleanup;

    g_uiDisplay.DocPixelsFromDevice(Rect, Rect);

    // Create an instance of the rectangle object
    pOMRect = new COMRect(&Rect);
    if (!pOMRect)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppIRect = (IHTMLRect *)pOMRect;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  member : CAutoRange::getClientRects() - External method
//
//  Synopsis:   Returns the collection of rectangles for the text under
//               element's influence in client coordinates.
//              Each rectangle represents a line of text on the screen.
//------------------------------------------------------------------

HRESULT
CAutoRange::getClientRects(IHTMLRectCollection **ppIRects)
{
    HRESULT              hr;
    COMRectCollection  * pOMRectCollection;
    CDataAry<RECT>       aryRects(Mt(CAutoRangegetClientRects_aryRects_pv));

    DO_SANITY_CHECK

    if (!ppIRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIRects = NULL;

    // Get the array taht contains bounding rects for each line in the range
    hr = THR(GetRangeBoundingRects(&aryRects));
    if(hr)
        goto Cleanup;

    for (int i = 0; i < aryRects.Size(); i++)
    {
        g_uiDisplay.DocPixelsFromDevice(aryRects[i], aryRects[i]);
    }

    // Create a rectangle collection class instance
    pOMRectCollection = new COMRectCollection();
    if (!pOMRectCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the collection with values from aryRects
    hr = THR(pOMRectCollection->SetRects(&aryRects));
    if(hr)
        goto Cleanup;

        *ppIRects = (IHTMLRectCollection *) pOMRectCollection;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:    get_bounding[Width|Height|Top|Left],  IHTMLTextRangeMetrics
//
//  Synopsis:  returns the rect values for the bounding box around the range
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::get_boundingWidth( long *pLong )
{
    HRESULT    hr;
    RECT       rect;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (FAILED(hr))
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceX(rect.right-rect.left);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


HRESULT
CAutoRange::get_boundingHeight( long *pLong )
{
    HRESULT    hr;
    RECT       rect;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (FAILED(hr))
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceY(rect.bottom-rect.top);
    }
Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}



HRESULT
CAutoRange::get_boundingTop( long *pLong )
{
    HRESULT    hr;
    RECT       rect;
    LONG       lScroll;
    CElement * pContainer = NULL;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (hr)
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceY(rect.top);

        // for ie4.01sp1/2 compatability we need to subtract
        // the scrollTop in order to make this client coords
        // rather than document coords.
        pContainer = GetCommonContainer();

        if (pContainer && 
            (SUCCEEDED(pContainer->get_scrollTop( &lScroll ))))
           *pLong -= lScroll;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}


HRESULT
CAutoRange::get_boundingLeft( long *pLong )
{
    HRESULT    hr;
    RECT       rect;
    LONG       lScroll;
    CElement * pContainer = NULL;

    DO_SANITY_CHECK

    if (!pLong)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetRangeBoundingRect(&rect));

    if (hr)
    {
        *pLong = -1;
    }
    else
    {
        *pLong = g_uiDisplay.DocPixelsFromDeviceX(rect.left);

        // for ie4.01sp1/2 compatability we need to subtract
        // the scrollLeft in order to make this clientwindow coords
        // rather than document client coords.
        pContainer = GetCommonContainer();

        if (pContainer && 
            (SUCCEEDED(pContainer->get_scrollLeft( &lScroll ))))
           *pLong -= lScroll;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

// ISegmentList methods
HRESULT
CAutoRange::GetType(SELECTION_TYPE *peType)
{
    HRESULT hr = S_FALSE;

    if( peType )
    {
        *peType = SELECTION_TYPE_Text;
        hr = S_OK;
    }

    RRETURN(hr);
}

HRESULT
CAutoRange::CreateIterator(ISegmentListIterator **ppIIter)
{
    HRESULT hr = S_OK;

    CAutoRangeIterator *pListIter = new CAutoRangeIterator();

    if( pListIter == NULL )
        goto Error;

    // Initialize the iterator, and retrieve the ISegmentListIterator interface
    hr = pListIter->Init( this );
    if( FAILED(hr) )
        goto Cleanup;
    
    hr = pListIter->QueryInterface(IID_ISegmentListIterator, (void **)ppIIter);
    if( FAILED(hr) )
        goto Cleanup;
  
Cleanup:
    ReleaseInterface( pListIter );
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT
CAutoRange::IsEmpty(BOOL *pfEmpty)
{
    HRESULT hr = E_FAIL;
    
    Assert( pfEmpty );

    if( pfEmpty )
    {
        *pfEmpty = FALSE;
        hr = S_OK;
    }        

    return hr;
}

// ISegment methods
HRESULT
CAutoRange::GetPointers(IMarkupPointer *pIStart,
                        IMarkupPointer *pIEnd )
{
    return MovePointersToSegment(0, pIStart, pIEnd );
}

HRESULT 
CAutoRange::MovePointersToSegment ( 
    int iSegmentIndex, 
    IMarkupPointer * pILeft, 
    IMarkupPointer * pIRight ) 
{
    HRESULT     hr;
    POINTER_GRAVITY eGravity = POINTER_GRAVITY_Left;
    
    if ( iSegmentIndex != 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // check argument sanity
    if (! (pILeft && pIRight) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pILeft->MoveToPointer( _pLeft ) );
    
    if (!hr)
        hr = THR( pIRight->MoveToPointer( _pRight ) );
    

    //
    // copy gravity - important for commands
    //
    if ( !hr ) hr = _pLeft->Gravity( &eGravity );            // need to maintain gravity
    if ( !hr ) hr = pILeft->SetGravity( eGravity );

    if ( !hr ) hr = _pRight->Gravity( &eGravity );            // need to maintain gravity
    if ( !hr ) hr = pIRight->SetGravity( eGravity );
    
    if (hr) 
        goto Cleanup;
    
Cleanup:        
    RRETURN( hr );
}    

HRESULT
CAutoRange::MoveSegmentToPointers ( int iSegmentIndex,
                                    IMarkupPointer * pILeft, 
                                    IMarkupPointer * pIRight )  
{
    HRESULT     hr;
    BOOL        fPositioned = FALSE;
    
    // check argument sanity
    if (! (pILeft && pIRight) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pILeft->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    hr = THR( pIRight->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
   
    hr = THR( SetLeft( pILeft ) );
    if (! hr)   hr = THR( SetRight( pIRight ) );
    if (hr)
        goto Cleanup;
    
Cleanup:    
    RRETURN( hr );
}


HRESULT
CAutoRange::GetSegmentCount(
    int* piSegmentCount,
    SELECTION_TYPE *peSelectionType )
{
    HRESULT hr = S_FALSE;

    if ( piSegmentCount )
    {
        *piSegmentCount = 1;
        hr = S_OK;
    }
    if ( peSelectionType )
        *peSelectionType = SELECTION_TYPE_Text;
        
    RRETURN( hr );
}


#if DBG==1
void CAutoRange::DumpTree()
{
    GetMarkup()->DumpTree();
}
#endif


BOOL
IsIntrinsicTag( ELEMENT_TAG eTag )
{
    switch (eTag)
    {
    case ETAG_BUTTON:
    case ETAG_TEXTAREA:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_FIELDSET:
    case ETAG_LEGEND:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
        return TRUE;

    default:
        return FALSE;
    }
}


HRESULT
CAutoRange::AdjustIntoTextSite(
    IMarkupPointer *    pPointerToMove,
    MV_DIR              Dir,
    IMarkupPointer *    pBoundary )
{
    HRESULT         hr;
    IHTMLElement *  pHTMLElement = NULL;    
    IHTMLElement *  pSite = NULL;
    IMarkupPointer* pPointer = NULL;
    CDoc *          pDoc;
    BOOL            fTextSite = FALSE;
    BOOL            fResult;
    MARKUP_CONTEXT_TYPE context;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );        
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;
    
    for ( ; ; )
    {
        ClearInterface( & pHTMLElement );

        if( Dir == MV_DIR_Left )
        {
            hr = THR( LeftOrSlave( pPointer, TRUE, & context, & pHTMLElement, NULL, NULL ) );
            if (hr)
                goto Cleanup;

            hr = THR( pPointer->IsLeftOf( pBoundary, & fResult ) );
            if (hr)
                goto Cleanup;

        }
        else
        {
            hr = THR( RightOrSlave( pPointer, TRUE, & context, & pHTMLElement, NULL, NULL ) );
            if (hr)
                goto Cleanup;

            hr = THR( pPointer->IsRightOf( pBoundary, & fResult ));
            if (hr)
                goto Cleanup;
        }

        // Check Boundary
        if (fResult)
        {
            goto Cleanup;
        }

        switch( context )
        {
        case CONTEXT_TYPE_None:
            goto Cleanup;

        case CONTEXT_TYPE_EnterScope:
        case CONTEXT_TYPE_ExitScope:
            if (! pHTMLElement)
                break;

            ClearInterface( & pSite );
            hr = THR( GetSiteContainer( pHTMLElement, & pSite,  & fTextSite ) );
            if (hr)
                goto Cleanup;

            if ( fTextSite )
            {                
                goto Cleanup;
            }
        }
    }

Cleanup:
    if( SUCCEEDED( hr ) && fTextSite )
    {
        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
    }
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pSite );
    return( hr );
}    


//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::ClingToText()
//
//  Synopsis:   Move pOrigin towards pTarget while the context type is not text. 
//              The direction of the move is denoted by fLeftBound.
//              If the move causes pOrigin to pass pTarget, the pointers are
//              adjusted to move next to each other.
//
//----------------------------------------------------------------------------

CLING_RESULT
CAutoRange::ClingToText( 
    IMarkupPointer *        pInPointer, 
    IMarkupPointer *        pBoundary, 
    MV_DIR                  eDir )
{
    CLING_RESULT        cr = CR_Failed;
    HRESULT             hr = S_OK;
    BOOL                fDone = FALSE;
    BOOL                fLeft = eDir == MV_DIR_Left;
    CElement *          pElement = NULL;
    MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;

    IMarkupPointer *    pPointer = NULL;
    IHTMLElement *      pHTMLElement = NULL;
    CMarkupPointer  *   pointer = NULL;
    DWORD               dwBreaks;
    long                cch;
    CDoc                *pDoc = _pMarkup->Doc();

#if 0
    //
    // Quick Out: Check if I'm adjacent to text. If so, go nowhere.
    //

    if( fLeft )
        hr = THR( RightOrSlave( pInPointer, FALSE, & eCtxt, NULL, NULL, NULL ) );
    else
        hr = THR( LeftOrSlave( pInPointer, FALSE, & eCtxt, NULL , NULL, NULL ) );
    
    if( eCtxt == CONTEXT_TYPE_Text )
    {
        cr = CR_Text;
        goto Cleanup;   // Nothing to do!
    }
#endif // if 0

    hr = THR( GetMarkup()->Doc()->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->MoveToPointer( pInPointer ) );
    if (hr)
        goto Cleanup;

    hr = THR(
            pPointer->QueryInterface(CLSID_CMarkupPointer, (void**) & pointer ) );
    if (hr)
        goto Cleanup;

    while( ! fDone )
    {
        BOOL fResult;
        
        ClearInterface( & pHTMLElement );
        
        if ( fLeft ) 
        {
            hr = pPointer->IsLeftOf( pBoundary, & fResult ) ;
        }
        else
        {
            hr = pPointer->IsRightOf( pBoundary, & fResult ) ;
        }

        if ( fResult )
        {
            cr = CR_Boundary;
            goto Done;
        }
            
        cch = 1;
        if( fLeft )
        {
            hr = THR( LeftOrSlave( pPointer, TRUE, & eCtxt, & pHTMLElement, & cch, NULL ));
        }
        else
        {
            hr = THR( RightOrSlave(pPointer, TRUE, & eCtxt, & pHTMLElement, & cch, NULL ));
        }

        if( FAILED( hr ))
            goto Done;

        switch( eCtxt )
        {
            case CONTEXT_TYPE_EnterScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    //  We don't want to cling to text for atomic elements.  We need to keep the
                    //  end pointer outside of the atomic element.
                    if ( pDoc->IsElementAtomic(pElement) )
                    {
                        cr = CR_AtomicElement;
                        fDone = TRUE;
                    }
                    else if ( IsIntrinsicTag( pElement->Tag() ) ||
                         pElement->ShouldHaveLayout() )
                    {
                        cr = CR_Intrinsic;
                        fDone = TRUE;
                    }
                    else if ( pElement->IsBlockElement() )
                    {
                        //
                        // Check for any break characters
                        //
                        hr = THR( pointer->QueryBreaks( & dwBreaks ) );
                        if (hr)
                            goto Cleanup;

                        if ( dwBreaks == BREAK_BLOCK_BREAK )
                        {
                            // Stay after the block break, we're done
                            cr = CR_BlockBreak;
                            fDone = TRUE;
                        }
                    }
                }
                break;

            case CONTEXT_TYPE_ExitScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    if( pElement &&
                          (pElement->ShouldHaveLayout() || pElement->IsBlockElement() || pElement->Tag()==ETAG_BR))
                    {
                        cr = CR_Failed;
                        // cr = CR_Text; // this could also be CR_Failed, but this simulates a block break or tsb char
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_NoScope:
                if( pHTMLElement )
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                    if( pElement 
                        && (pElement->ShouldHaveLayout() || pElement->IsBlockElement() || pElement->Tag()==ETAG_BR ||
                           pElement->Tag()==ETAG_SCRIPT ))
                    {
                        cr = CR_NoScope;
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Failed;
                fDone = TRUE;
                break;
        }
    }

Done:

    //
    // If we found text, move our pointer
    //
    
    switch( cr )
    {
        case CR_Text:
        case CR_NoScope:
        case CR_Intrinsic:
        case CR_BlockBreak:
        case CR_AtomicElement:

            //
            // We have inevitably gone one move too far, back up one move
            //

            cch = 1;
            if( fLeft )
            {
                hr = THR( RightOrSlave( pPointer, TRUE, & eCtxt, NULL, & cch, NULL ));
            }
            else
            {
                hr = THR( LeftOrSlave( pPointer, TRUE, & eCtxt, NULL, & cch, NULL ));
            }

            if( FAILED( hr ))
                goto Cleanup;

            //
            // Now we position the pointer
            //
            
            hr = THR( pInPointer->MoveToPointer( pPointer ));
            break;
    }

Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    
    return( cr );
}

//+---------------------------------------------------------------------------
//
//  Member:     Private helper function GetSiteContainer()
//
//  Synopsis:   Returns the text site corresponding to the passed in 
//              markup pointer
//
//----------------------------------------------------------------------------

HRESULT     
CAutoRange::GetSiteContainer (
        IMarkupPointer *     pPointer,
        IHTMLElement **      ppSite,
        BOOL *               pfText )
{
    HRESULT        hr = E_FAIL;
    IHTMLElement * pHTMLElement = NULL;
    CDoc         * pDoc;

    Assert( pPointer != NULL && ppSite != NULL );
    if( pPointer == NULL || ppSite == NULL )
        goto Cleanup;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    hr = THR( pDoc->CurrentScopeOrSlave( pPointer, & pHTMLElement ));
    if (hr)
        goto Cleanup;
    
    if( pHTMLElement )
    {
        hr = THR( GetSiteContainer( pHTMLElement, ppSite, pfText ));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ReleaseInterface( pHTMLElement ); 
    RRETURN( hr );
}


HRESULT     
CAutoRange::GetSiteContainer(
        IHTMLElement *      pElementStart,
        IHTMLElement **     ppSite,
        BOOL *              pfText )
{
    HRESULT         hr = E_FAIL;
    BOOL            fSite = FALSE;
    BOOL            fText = FALSE;
    IHTMLElement *  pHTMLElement = NULL;
    CDoc         *  pDoc;
    IHTMLElement * pElementParent = NULL;

    Assert( pElementStart != NULL && ppSite != NULL );
    Assert( *ppSite == NULL );

    if( pElementStart == NULL || ppSite == NULL )
        goto Cleanup;

    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    *ppSite = NULL;
    ReplaceInterface( & pHTMLElement, pElementStart );

    while( ! fSite && pHTMLElement != NULL )
    {
        hr = THR( pDoc->IsSite( pHTMLElement, &fSite, &fText, NULL, NULL ));
        if (hr)
            goto Cleanup;

        if( fSite )
        {       
            hr = S_OK;

            ReplaceInterface( ppSite, pHTMLElement );

            if( pfText != NULL )
                *pfText = fText;
        }
        else
        {
            ClearInterface( & pElementParent );
            hr = THR( pHTMLElement->get_parentElement( & pElementParent ));
            ReplaceInterface( & pHTMLElement, pElementParent );
        }
    }
    
Cleanup:
    ReleaseInterface( pElementParent );
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     AdjustForInsert()
//
// . Set the boundary
//
// . Find a text site 
//
// . Bail if we're next to text
//
// . Adjust the boundary to the text site
//
// . Go Left looking for Text while in the text site boundary, break for anything other than phrase elements
//
// . Go right looking for Text, Line break or Block Break while in the text site boundary
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::AdjustForInsert( IMarkupPointer * pPointerToMove )
{
    CLING_RESULT        cr = CR_Failed;
    HRESULT             hr = S_OK;
    BOOL                fDone = FALSE;
    CElement *          pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    IMarkupPointer *    pPointer = NULL;
    IHTMLElement *      pHTMLElement = NULL;
    IHTMLElement *      pSite = NULL;
    CDoc  *             pDoc;
    BOOL                fResult;
    BOOL                fTextSite = FALSE;
    long                cch;
    DWORD               dwBreaks;
    CMarkupPointer *    mpPointer;
    IMarkupPointer *    pLeftBoundary = NULL;
    IMarkupPointer *    pRightBoundary = NULL;
    
    pDoc = GetMarkup()->Doc();
    Assert( pDoc );

    if (! _pElemContainer)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( pDoc->CreateMarkupPointer( & pPointer ) );
    if (hr)
        goto Cleanup;

    //
    // Set the range boundaries
    //
    hr = THR_NOTRACE( 
            _pElemContainer->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;
    
    hr = THR( pDoc->CreateMarkupPointer( & pLeftBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->CreateMarkupPointer( & pRightBoundary ) );
    if (hr)
        goto Cleanup;

    hr = THR( pLeftBoundary->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( pRightBoundary->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    ClearInterface( & pHTMLElement );

    //
    // Position pPointerToMove within a text site
    //

    hr = THR( GetSiteContainer( pPointerToMove, & pSite, & fTextSite ));
    if (hr)
        goto Cleanup;
    
    if( ! fTextSite )
    {
        hr = AdjustIntoTextSite( pPointerToMove, MV_DIR_Right, pRightBoundary );        
        if( FAILED( hr ))
        {
            hr = AdjustIntoTextSite( pPointerToMove, MV_DIR_Left, pLeftBoundary );
        }
        
        if( FAILED( hr ))
        {
            hr = E_FAIL;
            goto Cleanup;
        }        
        ClearInterface( & pSite );
        hr = THR( GetSiteContainer( pPointerToMove, & pSite, & fTextSite ));
        if (hr)
            goto Cleanup;
    }

    //
    // Adjust the boundaries to enclose the text site, if necessary
    //        
    hr = THR( pPointer->MoveAdjacentToElement( pSite, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->IsRightOf( pLeftBoundary, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    {
        hr = THR( pLeftBoundary->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

    hr = THR( pPointer->MoveAdjacentToElement( pSite, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;
    
    hr = THR( pPointer->IsLeftOf( pRightBoundary, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    {
        hr = THR( pRightBoundary->MoveToPointer( pPointer ) );
        if (hr)
            goto Cleanup;
    }

    ClearInterface( & pSite );

    //
    // Go Left looking for Text while in the text site boundary, 
    // break for anything other than phrase elements
    //
    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    while ( ! fDone )
    {
        ClearInterface( & pHTMLElement );                    
        cch = 1;

        hr = THR( LeftOrSlave( pPointer, TRUE, &context, &pHTMLElement, & cch, NULL ));
        if ( hr )
            goto Cleanup;

        hr = THR( pPointer->IsLeftOf( pLeftBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            cr = CR_Boundary;
            fDone = TRUE;
            break;
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement) );

                if ( IsIntrinsicTag( pElement->Tag() ) )
                {
                    cr = CR_Intrinsic; 
                    fDone = TRUE;
                }
                else if ( pElement->ShouldHaveLayout() ||
                          pElement->IsBlockElement() )
                {
                    cr = CR_Intrinsic; 
                    fDone = TRUE;
                }
                break;
               
            case CONTEXT_TYPE_NoScope:
                cr = CR_NoScope;

                if (pHTMLElement)
                {
                    pElement = NULL;
                    IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement) );
                    if (pElement)
                    {
                        if (pElement->ShouldHaveLayout() 
                            || pElement->Tag() == ETAG_BR)
                        {
                            goto Cleanup;
                        }
                    }
                }
                fDone = TRUE;            
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Boundary;
                fDone = TRUE;
                break;
        }
    }

    if ( cr == CR_Text )
    {
        // The only significant thing to the left is Text
        // We're done
        goto Cleanup;
    }
    
    //
    // Go right looking for Text, Line breaks or Block Breaks 
    // while in the text site boundary
    //

    hr = THR( pPointer->MoveToPointer( pPointerToMove ) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & mpPointer ) );
    if (hr)
        goto Cleanup;

    fDone = FALSE;

    while ( ! fDone )
    {
        hr = THR( mpPointer->QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        if ( dwBreaks == BREAK_BLOCK_BREAK )
        {
            cr = CR_BlockBreak; 
            break;
        }

        ClearInterface( & pHTMLElement );                    
        cch = 1;

        hr = THR( RightOrSlave(pPointer, TRUE, &context, &pHTMLElement, & cch, NULL ));
        if ( hr )
            goto Cleanup;

        hr = THR( pPointer->IsRightOf( pRightBoundary, & fResult ) );
        if (hr)
            goto Cleanup;

        if ( fResult )
        {
            cr = CR_Boundary;
            fDone = TRUE;
            break;
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if ( IsIntrinsicTag( pElement->Tag() ) || 
                     pElement->ShouldHaveLayout() )
                {
                    cr = CR_Intrinsic;
                    fDone = TRUE;
                }
                break;

            case CONTEXT_TYPE_ExitScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if( pElement->ShouldHaveLayout() || pElement->IsBlockElement() )
                {
                    cr = CR_Failed;
                    fDone = TRUE;
                }
                break;
                
            case CONTEXT_TYPE_NoScope:
                if (! pHTMLElement)
                    break;

                pElement = NULL;
                IGNORE_HR( pHTMLElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement));

                if (pElement->Tag() == ETAG_BR )
                {
                    cr = CR_LineBreak;
                    fDone = TRUE;
                }
                else if ( pElement->ShouldHaveLayout() || pElement->Tag() == ETAG_SCRIPT )
                {
                    cr = CR_NoScope; 
                    fDone = TRUE;
                }
                break;
                
            case CONTEXT_TYPE_Text:
                cr = CR_Text;
                fDone = TRUE;
                break;
                
            case CONTEXT_TYPE_None:
                cr = CR_Failed;
                fDone = TRUE;
                break;
        }
    }

    switch (cr)        
    {
    case CR_LineBreak:
    case CR_Text: 
    case CR_NoScope: 
    case CR_Intrinsic: 
        // We've gone too far, need to go left once
        hr = THR( LeftOrSlave( pPointer, TRUE, &context, NULL, & cch, NULL ));
        if ( hr )
            goto Cleanup;
        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        goto Cleanup;


    case CR_BlockBreak:
        hr = THR( AdjustLeftIntoEmptyPhrase(pPointer) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointerToMove->MoveToPointer( pPointer ));
        goto Cleanup;

    }


Cleanup:
    ReleaseInterface( pPointer );
    ReleaseInterface( pHTMLElement );
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pSite );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CTextSegment::FlipRangePointers()
//
//  Synopsis:   Wiggles pointers to appropriate position
//
//  Arguments:  none
//
//  Returns:    none
//
//----------------------------------------------------------------------------
HRESULT
CAutoRange::FlipRangePointers()
{
    IMarkupPointer *  pTemp = NULL;
    HRESULT         hr = S_OK;
    POINTER_GRAVITY eGravityLeft = POINTER_GRAVITY_Left;    // need to initialize
    POINTER_GRAVITY eGravityRight = POINTER_GRAVITY_Left;  // need to initialize
    
    GetMarkup()->Doc()->CreateMarkupPointer( & pTemp );
      
    if (! pTemp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // Remember gravity
    hr = THR(_pLeft->Gravity(&eGravityLeft));
    if ( hr )
        goto Cleanup;
        
    hr = THR(_pRight->Gravity(&eGravityRight));
    if ( hr )
        goto Cleanup;

    // Swap pointers
    hr = THR( pTemp->MoveToPointer( _pRight ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( _pRight->MoveToPointer( _pLeft ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( _pLeft->MoveToPointer( pTemp ) );
    if ( hr )
        goto Cleanup;
    
    // Swap gravity as well
    if (eGravityLeft != eGravityRight)
    {
        THR(_pLeft->SetGravity(eGravityLeft));
        THR(_pRight->SetGravity(eGravityRight));
    }

Cleanup:
    ReleaseInterface( pTemp );
    RRETURN( hr );
}

HRESULT
CAutoRange::InitPointers()
{
    HRESULT hr = S_OK;

    if ( ! GetMarkup() )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ClearInterface( & _pLeft );

    hr = THR( _pMarkup->Doc()->CreateMarkupPointer( & _pLeft ) );

    if (hr)
        goto Cleanup;

    WHEN_DBG( SetDebugName( _pLeft, _T( "Range Left" ) ) );
    
    hr = THR( _pLeft->SetGravity( POINTER_GRAVITY_Right ) );
    
    if (hr)
        goto Cleanup;

    ClearInterface( & _pRight );

    hr = THR( _pMarkup->Doc()->CreateMarkupPointer( & _pRight ) );

    if (hr)
        goto Cleanup;
    
    WHEN_DBG( SetDebugName( _pRight, _T( "Range Right" ) ) );
    
    hr = THR( _pRight->SetGravity( POINTER_GRAVITY_Left ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}


HRESULT
CAutoRange::KeepRangeLeftToRight()
{
    HRESULT     hr;
    BOOL        fResult;

    hr = THR( _pLeft->IsRightOf( _pRight, & fResult ) );
    if (hr)
        goto Cleanup;

    if ( fResult )
    { 
        hr = THR( FlipRangePointers() );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


HRESULT
CAutoRange::ValidatePointers()
{
    HRESULT         hr = S_OK;

    if (! (_pLeft && _pRight) )
        goto Cleanup;

    hr = THR( KeepRangeLeftToRight() );
    if (hr)
        goto Cleanup;

    hr = THR( AdjustPointers( _pLeft, _pRight ));

Cleanup:   
    RRETURN( hr );
}


//+====================================================================================
//
// Method: IsPhraseElement
//
// Synopsis: Is the element a phrase element
//
//------------------------------------------------------------------------------------
BOOL 
CAutoRange::IsPhraseElement( IHTMLElement *pElement )
{
    HRESULT         hr;
    BOOL            fNotPhrase = TRUE;

    // Make sure the element is not a site or block element
    hr = THR( _pMarkup->Doc()->IsSite(pElement, &fNotPhrase, NULL, NULL, NULL) );
    if (hr || fNotPhrase)
        return FALSE;
        
    hr = THR( _pMarkup->Doc()->IsBlockElement(pElement, &fNotPhrase) );
    if (hr || fNotPhrase)
        return FALSE;

    return TRUE;
}


HRESULT 
CAutoRange::AdjustLeftIntoEmptyPhrase( IMarkupPointer *pLeft )
{
    HRESULT               hr;
    MARKUP_CONTEXT_TYPE   context;
    IHTMLElement          *pElement = NULL;
    IMarkupPointer        *pmpTest = NULL;
    CDoc                  *pDoc = _pMarkup->Doc();

    hr = THR( pDoc->CreateMarkupPointer(&pmpTest) );
    if (hr)
        goto Cleanup;

    hr = THR( pmpTest->MoveToPointer(pLeft) );
    if (hr)
        goto Cleanup;

    do
    {
        ClearInterface(&pElement);
        hr = THR(LeftOrSlave(pmpTest, TRUE, &context, &pElement, NULL, NULL));
        if (hr)
            goto Cleanup;

        if (context == CONTEXT_TYPE_ExitScope && pElement && IsPhraseElement(pElement))
        {
            hr = THR(RightOrSlave(pmpTest, TRUE, NULL, NULL, NULL, NULL));
            if (hr)
                goto Cleanup;

            hr = THR( pLeft->MoveToPointer(pmpTest) );
        } 
    } 
    while (context == CONTEXT_TYPE_EnterScope && pElement && IsPhraseElement(pElement));

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pmpTest);
    RRETURN(hr);
}


//+====================================================================================
//
// Method: AdjustPointers
//
// Synopsis: Do the work of clinging for the range. Called by validatepointers
//
//------------------------------------------------------------------------------------



HRESULT
CAutoRange::AdjustPointers( IMarkupPointer *pLeft, IMarkupPointer* pRight)
{
    HRESULT hr;
    CLING_RESULT cr;
    BOOL fResult;
    
    hr = THR( AdjustForInsert( pLeft ) );
    if (hr)
        goto Cleanup;

    hr = THR( pRight->IsLeftOf( pLeft, & fResult ) );
    if (hr)
        goto Cleanup;

    if (fResult)
    {
        hr = THR( pRight->MoveToPointer( pLeft ) );
        if (hr)
            goto Cleanup;
    }

    cr = ClingToText( pRight, pLeft, MV_DIR_Left );

Cleanup:   
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::IsRangeCollpased
//
//  Synopsis:   returns true if left and right pointers are equal
//
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
CAutoRange::IsRangeCollapsed()
{
    BOOL    fEqual = FALSE;
    HRESULT hr;

    hr = THR( _pLeft->IsEqualTo( _pRight, & fEqual ) );
    if (hr)
        goto Cleanup;

Cleanup:
    return fEqual;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAutoRange::SaveHTMLToStream
//
//  Synopsis:   Saves the range text to the specified stream.
//
//----------------------------------------------------------------------------

HRESULT
CAutoRange::SaveHTMLToStream(CStreamWriteBuff * pswb, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CMarkupPointer mpLeft( GetMarkup()->Doc() );
    CMarkupPointer mpRight( GetMarkup()->Doc() );
    
    hr = THR( mpLeft.MoveToPointer( _pLeft ));
    if( FAILED( hr ))
        goto Cleanup;

    hr = THR( mpRight.MoveToPointer( _pRight ));
    if( FAILED( hr ))
        goto Cleanup;

    //
    // Now we can actually do our work
    //
    {
        CRangeSaver rs( &mpLeft, &mpRight, dwFlags, pswb, GetMarkup() );
        hr = THR( rs.Save());
    }
    
Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::GetLeft( IMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pLeft ) );
    RRETURN( hr );
}

HRESULT
CAutoRange::GetLeft( CMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pLeft  ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetRight( IMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pRight ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetRight( CMarkupPointer * ptp )
{
    HRESULT  hr = THR( ptp->MoveToPointer( _pRight ) );
    RRETURN( hr );
}

HRESULT 
CAutoRange::SetLeft( IMarkupPointer * ptp )
{
    HRESULT  hr;
    
    // NOTE: aren't we guarranteed to have _pLeft and _pRight
    if (! _pLeft )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    
    hr = THR( _pLeft->MoveToPointer( ptp ) );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::SetRight( IMarkupPointer * ptp )
{
    HRESULT  hr;
    
    if (! _pRight )
    {
        hr = E_FAIL;
        goto Cleanup;
    }


    hr = THR( _pRight->MoveToPointer( ptp ) );
    if (hr)
        goto Cleanup;

    hr = THR( ValidatePointers() );

Cleanup:
    RRETURN( hr );
}


HRESULT 
CAutoRange::SetLeftAndRight( 
                                IMarkupPointer * pLeft, 
                                IMarkupPointer * pRight, 
                                BOOL fAdjustPointers /*=TRUE*/ )
{
    HRESULT  hr;
    
    if (! _pRight || !_pLeft)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR( _pRight->MoveToPointer( pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->MoveToPointer( pLeft ) );
    if (hr)
        goto Cleanup;
            
    if ( fAdjustPointers )
    {
        hr = THR( ValidatePointers() );
    }
Cleanup:
    RRETURN( hr );
}

HRESULT 
CAutoRange::GetLeftAndRight( CMarkupPointer * pLeft, CMarkupPointer * pRight )
{
    HRESULT  hr;

    // internal function...
    Assert( pRight );
    Assert( pLeft );
   
    hr = THR( pRight->MoveToPointer( _pRight ) );
    if (hr)
        goto Cleanup;

    hr = THR( pLeft->MoveToPointer( _pLeft ) );

Cleanup:
    RRETURN( hr );
}

CTreeNode * 
CAutoRange::GetNode(BOOL fLeft)
{   
    CMarkupPointer * pmp = NULL;
    HRESULT          hr = S_OK;

    if (fLeft)
        hr = THR_NOTRACE( _pLeft->QueryInterface(CLSID_CMarkupPointer, (void **) & pmp) );
    else
        hr = THR_NOTRACE( _pRight->QueryInterface(CLSID_CMarkupPointer, (void **) & pmp) );
    
    if (hr)
    {
        return NULL;
    }
    
    return pmp ? pmp->CurrentScope(MPTR_SHOWSLAVE) : NULL;
}


CTreeNode * 
CAutoRange::LeftNode()
{   
    return ( GetNode( TRUE ) );
}


CTreeNode * 
CAutoRange::RightNode()
{   
    return ( GetNode( FALSE ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     SetTextRangeToElement
//
//  Synopsis:   Have this range select all text under the influence of the
//              given element.  
//
//  Return:     S_FALSE if the element cannot be located in the tree
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::SetTextRangeToElement ( CElement * pElement )
{
    HRESULT             hr = S_OK;
    IHTMLElement *      pHTMLElement = NULL;
    CElement     *      pElementTarget = NULL;
    CMarkupPointer      mpJustBefore ( GetMarkup()->Doc() );
    CMarkupPointer      mpTemp ( GetMarkup()->Doc() );
    IMarkupPointer *    pLeftBoundary = NULL;
    IMarkupPointer *    pRightBoundary = NULL;

    if (! pElement || ! pElement->IsInMarkup() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // First check whether the element has a slave.
    // Note that when CInputTxt::createTextRange() calls us,
    // it passes us a textslave, which does not have a slave.
    // However, if the element does have a slave, we must see 
    // if it is the same as the one that this range was created on.
    //
    if ( pElement->HasSlavePtr() )
    {
        CElement * pElementSlave;

        pElementSlave = pElement->GetSlavePtr();
        Assert( pElementSlave );

        if ( pElementSlave == _pElemContainer )
        {
            // The range was created on an INPUT and we've been 
            // asked to move to that same INPUT's text.
            pElementTarget = pElementSlave;
        }
    }

    if ( ! pElementTarget && 
         (pElement == _pElemContainer ||
          (pElement->GetFirstBranch()->Parent() &&
           pElement->GetFirstBranch()->Parent()->GetContainer() == _pElemContainer)))
    {
        pElementTarget = pElement;
    }
    else
    {
        // If the container of pElement is not the range's container 
        // we return an error. 
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    Assert( pElementTarget );

    hr = THR( pElementTarget->QueryInterface( IID_IHTMLElement, (void **) & pHTMLElement ) );
    if (hr)
        goto Cleanup;

    if ( pElementTarget->IsNoScope() )
    {
        // Place the range around the noscope element 
        hr = THR( _pLeft->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeBegin ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterEnd ) );
        if (hr)
            goto Cleanup;

    }
    else
    {
        DWORD               dwBreaks;
        CMarkupPointer  *   pointer;

        // Place the left edge inside the element
        hr = THR( _pLeft->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterBegin ) );
        if (hr)
            goto Cleanup;
        
        // Position the right edge inside the element, unless there is a block break there
        hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_BeforeEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pRight->QueryInterface( CLSID_CMarkupPointer, (void **) & pointer ) );
        if( hr )
            goto Cleanup;

        hr = THR( pointer->QueryBreaks( & dwBreaks ) );
        if (hr)
            goto Cleanup;

        if ( dwBreaks == BREAK_BLOCK_BREAK )
        {
            hr = THR( _pRight->MoveAdjacentToElement( pHTMLElement, ELEM_ADJ_AfterEnd ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // To keep IE4 compatibility, shift the left side up to the next "char".
    // Note: we do not shift the right side, since there already is code up above 
    // that positions the right end of the range AFTER the element end, 
    // passed a block break character.
    //

    hr = THR( MovePointersToRangeBoundary( & pLeftBoundary, & pRightBoundary ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( mpTemp.MoveToPointer( _pLeft ) );

    if (hr)
        goto Cleanup;

    hr = THR( MoveCharacter( & mpTemp, MOVEUNIT_PREVCHAR, pLeftBoundary, pRightBoundary, & mpJustBefore ) );

    if (hr)
        goto Cleanup;

    hr = THR( _pLeft->MoveToPointer( & mpJustBefore ) );

    if (hr)
        goto Cleanup;

    //
    //
    //
    hr = THR( ValidatePointers() );
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface( pLeftBoundary );
    ReleaseInterface( pRightBoundary );
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetBstrHelper
//
//  Synopsis:   Gets text from the range into a given bstr in a specified
//              save mode.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoRange::GetBstrHelper(BSTR * pbstr, DWORD dwSaveMode, DWORD dwStrWrBuffFlags)
{
    HRESULT  hr;
    LPSTREAM pIStream = NULL;

    *pbstr = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
    if (hr)
        goto Cleanup;

    //
    // Use a scope to clean up the StreamWriteBuff
    //
    {
        CStreamWriteBuff StreamWriteBuff(pIStream, CP_UCS_2);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        StreamWriteBuff.SetFlags(dwStrWrBuffFlags);
       
        hr = THR( SaveHTMLToStream( &StreamWriteBuff, dwSaveMode ));
        if (hr)
            goto Cleanup;

        StreamWriteBuff.Terminate();    // appends a null character
    }

    hr = GetBStrFromStream(pIStream, pbstr, TRUE);

Cleanup:

    ReleaseInterface(pIStream);

    RRETURN(hr);
}
 

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetCommonElement
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

CTreeNode *
CAutoRange::GetCommonNode()
{
    CTreeNode * ptnLeft  = LeftNode();
    CTreeNode * ptnRight = RightNode();
    
    if (ptnLeft && ptnRight)
    {
        return ptnLeft->GetFirstCommonAncestor( ptnRight, NULL);
    }
    else
    {
        return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::GetCommonContainer
//
//  Synopsis:   Find the common container of the range, if the range is inside
//              the same textsite, we return the textsite, otherwise we return
//              the ped.
//
//-----------------------------------------------------------------------------

CElement *CAutoRange::GetCommonContainer()
{
    return GetCommonNode()->GetContainer();
}

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::OwnedBySingleTxtSite
//
//  Synopsis:   Function to determine if a single txt site owns the complete
//              range.
//
//  Arguments   None
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::OwnedBySingleFlowLayout()
{
    HRESULT     hr;
    BOOL        bResult = FALSE;
    CTreeNode   *ptnLeft  = LeftNode();
    CTreeNode   *ptnRight = RightNode();
    CElement    *pElemFlowLeft;
    CElement    *pElemFlowRight;
    IObjectIdentity *pIdentLeft = NULL;
    IObjectIdentity *pUnkRight = NULL;
    
    if (ptnLeft && ptnRight)
    {
        CFlowLayout * pFlowLeft  = ptnLeft->GetFlowLayout();
        CFlowLayout * pFlowRight = ptnRight->GetFlowLayout();

        if (pFlowLeft && pFlowRight)
        {
            pElemFlowLeft = pFlowLeft->ElementOwner();
            pElemFlowRight = pFlowRight->ElementOwner();

            hr = THR(pElemFlowLeft->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdentLeft));
            if (FAILED(hr))
                goto Cleanup;

            hr = THR(pElemFlowRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnkRight));
            if (FAILED(hr))
                goto Cleanup;

            hr = THR(pIdentLeft->IsEqualObject(pUnkRight));
            bResult = (hr == S_OK);
        }
    }

Cleanup:
    ReleaseInterface(pIdentLeft);
    ReleaseInterface(pUnkRight);
    return bResult;
}

//+----------------------------------------------------------------------------
//
//  Member:     CAutoRange::SelectionInOneTxtSite
//
//  Synopsis:   Function to determine if a single txt site owns both the
//              begin and end of a selection.
//
//  Arguments   None
//
//-----------------------------------------------------------------------------

BOOL
CAutoRange::SelectionInOneFlowLayout()
{
    BOOL fRet = TRUE;
    CFlowLayout * pFromOFL;
    CFlowLayout * pToOFL;
    CTreeNode * ptnLeft  = LeftNode();
    CTreeNode * ptnRight = RightNode();
    
    if (ptnLeft && ptnRight) 
    {
        pFromOFL = ptnLeft->GetFlowLayout();
        pToOFL   = ptnRight->GetFlowLayout();

        fRet = pFromOFL == pToOFL;

    }
    return fRet;
}

#if 0
//
// These routines have been moved to MshtmlEd
//

//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareBSTRS, local helper
//
//  Synopsis:   compares 2 btrs
//
//-----------------------------------------------------------------------------

BOOL VariantCompareBSTRS(VARIANT * pvar1, VARIANT * pvar2)
{
    BOOL    fResult;
    TCHAR  *pStr1;
    TCHAR  *pStr2;

    if (V_VT(pvar1) == VT_BSTR && V_VT(pvar2) == VT_BSTR)
    {
        pStr1 = V_BSTR(pvar1) ? V_BSTR(pvar1) : g_Zero.ach;
        pStr2 = V_BSTR(pvar2) ? V_BSTR(pvar2) : g_Zero.ach;

        fResult = StrCmpC(pStr1, pStr2) == 0;
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareFontSize, local helper
//
//  Synopsis:   compares font size
//
//-----------------------------------------------------------------------------

BOOL VariantCompareFontSize(VARIANT * pvarSize1, VARIANT * pvarSize2)
{
    CVariant    convVar1;
    CVariant    convVar2;
    BOOL        fResult;

    Assert(pvarSize1);
    Assert(pvarSize2);

    if (   V_VT(pvarSize1) == VT_NULL
        || V_VT(pvarSize2) == VT_NULL
       )
    {
        fResult = V_VT(pvarSize1) == V_VT(pvarSize2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&convVar1, pvarSize1, VT_I4))
        goto Error;

    if (VariantChangeTypeSpecial(&convVar2, pvarSize2, VT_I4))
        goto Error;

    fResult = V_I4(&convVar1) == V_I4(&convVar2);

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareColor, local helper
//
//  Synopsis:   compares color
//
//-----------------------------------------------------------------------------

BOOL VariantCompareColor(VARIANT * pvarColor1, VARIANT * pvarColor2)
{
    BOOL        fResult;
    CVariant    var;
    COLORREF    color1;
    COLORREF    color2;

    if (   V_VT(pvarColor1) == VT_NULL
        || V_VT(pvarColor2) == VT_NULL
       )
    {
        fResult = V_VT(pvarColor1) == V_VT(pvarColor2);
        goto Cleanup;
    }

    if (VariantChangeTypeSpecial(&var, pvarColor1,  VT_I4))
        goto Error;

    color1 = (COLORREF)V_I4(&var);

    if (VariantChangeTypeSpecial(&var, pvarColor2, VT_I4))
        goto Error;

    color2 = (COLORREF)V_I4(&var);

    fResult = color1 == color2;

Cleanup:
    return fResult;

Error:
    fResult = FALSE;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     VariantCompareFontName, local helper
//
//  Synopsis:   compares font names
//
//-----------------------------------------------------------------------------

BOOL VariantCompareFontName(VARIANT * pvarName1, VARIANT * pvarName2)
{
    return VariantCompareBSTRS(pvarName1, pvarName2);
}

#endif // 0


//+----------------------------------------------------------------------------
//
//  Method:     CheckOwnerSiteOrSelection
//
//-----------------------------------------------------------------------------
HRESULT
CAutoRange::CheckOwnerSiteOrSelection(ULONG cmdID)
{
    HRESULT     hr = S_OK;

    switch ( cmdID )
    {
    case IDM_OVERWRITE:
        if (!OwnedBySingleFlowLayout())
        {
            hr = S_FALSE;
        }
        break;

    case IDM_IMAGE:
    case IDM_PARAGRAPH:
    case IDM_IFRAME:
    case IDM_TEXTBOX:
    case IDM_TEXTAREA:
#ifdef  NEVER
    case IDM_HTMLAREA:
#endif
    case IDM_CHECKBOX:
    case IDM_RADIOBUTTON:
    case IDM_DROPDOWNBOX:
    case IDM_LISTBOX:
    case IDM_BUTTON:
    case IDM_MARQUEE:
    case IDM_1D:
    case IDM_LINEBREAKNORMAL:
    case IDM_LINEBREAKLEFT:
    case IDM_LINEBREAKRIGHT:
    case IDM_LINEBREAKBOTH:
    case IDM_HORIZONTALLINE:
    case IDM_INSINPUTBUTTON:
    case IDM_INSINPUTIMAGE:
    case IDM_INSINPUTRESET:
    case IDM_INSINPUTSUBMIT:
    case IDM_INSINPUTUPLOAD:
    case IDM_INSFIELDSET:
    case IDM_INSINPUTHIDDEN:
    case IDM_INSINPUTPASSWORD:

    case IDM_GETBLOCKFMTS:
    case IDM_TABLE:

    case IDM_CUT:
    case IDM_PASTE:

        if (!SelectionInOneFlowLayout())
        {
            hr = S_FALSE;
        }
        break;
    }

    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Method:     FSupportsHTML
//
//-----------------------------------------------------------------------------
BOOL
CAutoRange::FSupportsHTML()
{
    CTreeNode * pNode  = GetCommonNode();

    return ( pNode && pNode->SupportsHtml() );
}

//
// Helper functions so that measurer can make empty lines
// have the same height they will have after we spring
// load them and put text in them.
// 
long
GetSpringLoadedHeight(IMarkupPointer * pmpPosition, CFlowLayout * pFlowLayout, LONG * pyDescentOut)
{
    CDoc         * pDoc = pFlowLayout->Doc();
    CTreeNode    * pNode = pFlowLayout->GetFirstBranch();
    CCcs           ccs;
    const CBaseCcs * pBaseCcs;
    CCharFormat    cfLocal = *(pNode->GetCharFormat());
    CCalcInfo      CI;
    int            yHeight = -1;
    CVariant       varIn, varOut;
    GUID           guidCmdGroup = CGID_MSHTML;
    HRESULT        hr;

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pmpPosition;

    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    V_VT(&varIn) = VT_NULL;
    if (hr || V_VT(&varOut) == VT_NULL)
        goto Cleanup;

    // We now know that we have to apply compose settings on this line.

    // Get font size.
    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IDM_FONTSIZE;
    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    if (hr)
        goto Cleanup;

    // If we got a valid font size, apply it to the local charformat.
    if (V_VT(&varOut) == VT_I4 && V_I4(&varOut) != -1)
    {
        int iFontSize = ConvertHtmlSizeToTwips(V_I4(&varOut));
        cfLocal.SetHeightInTwips(iFontSize);
    }

    // Get font name.
    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IDM_FONTNAME;
    hr = THR(pDoc->Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, &varIn, &varOut));
    if (hr)
        goto Cleanup;

    // If we got a valid font name, apply it to the local charformat.
    if (V_VT(&varOut) == VT_BSTR)
    {
        TCHAR * pstrFontName = V_BSTR(&varOut);
        cfLocal.SetFaceName(pstrFontName);
    }

    cfLocal._bCrcFont = cfLocal.ComputeFontCrc();

    CI.Init(pFlowLayout);

    if (fc().GetCcs(&ccs, CI._hdc, &CI, &cfLocal))
    {
        pBaseCcs = ccs.GetBaseCcs();
        yHeight = pBaseCcs->_yHeight;

        if (pyDescentOut)
            *pyDescentOut = pBaseCcs->_yDescent;

        ccs.Release();
    }

Cleanup:

    return yHeight;
}



long
GetSpringLoadedHeight(CCalcInfo *pci, CFlowLayout * pFlowLayout, CTreePos *ptp, long cp, long * pyDescentOut)
{
    CElement     * pElementContent = pFlowLayout->ElementContent();
    int            yHeight;

    Assert(pyDescentOut);

    if (   pElementContent
        && pElementContent->HasFlag(TAGDESC_ACCEPTHTML)
       )
    {
        CMarkup      * pMarkup = pFlowLayout->GetContentMarkup();
        CDoc         * pDoc = pMarkup->Doc();
        CMarkupPointer mpComposeFont(pDoc);
        HRESULT        hr;

        hr = THR(mpComposeFont.MoveToCp(cp, pMarkup));
        if (hr)
        {
            yHeight = -1;
            goto Cleanup;
        }

        //
        // don't ask for springloaded height - unless editor already exists !!
        //
        if ( pDoc->GetHTMLEditor( FALSE ))
        {
            yHeight = GetSpringLoadedHeight(&mpComposeFont, pFlowLayout, pyDescentOut);
        }
        else
            yHeight = -1; 
    }
    else
    {
        WHEN_DBG(CMarkup *pMarkup = pFlowLayout->GetContentMarkup());
        WHEN_DBG(LONG junk);

        Assert(ptp);
        Assert(ptp == pMarkup->TreePosAtCp(cp, &junk));
        const CCharFormat *pCF = ptp->GetBranch()->GetCharFormat();
        CCcs ccs;
        const CBaseCcs *pBaseCcs;
        
        if (!fc().GetCcs(&ccs, pci->_hdc, pci, pCF))
        {
            yHeight = -1;
            goto Cleanup;
        }
        pBaseCcs = ccs.GetBaseCcs();
        yHeight = pBaseCcs->_yHeight;
        *pyDescentOut = pBaseCcs->_yDescent;

        ccs.Release();
    }

Cleanup:

    return yHeight;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::CAutoRangeIterator
//
//  Synopsis:   Constructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoRangeIterator::CAutoRangeIterator()
{
    Assert( _pRange == NULL );
    _ulRefs = 1;
    _fDone = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::CAutoRangeIterator
//
//  Synopsis:   Destructor for our Segment list iterator.
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
CAutoRangeIterator::~CAutoRangeIterator()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Init
//
//  Synopsis:   Initializes our segment list iterator
//
//  Arguments:  pRange = Pointer to an Auto range
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::Init(CAutoRange *pRange)
{
    _pRange = pRange;

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::First
//
//  Synopsis:   Resets the iterator
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoRangeIterator::First()
{
    _fDone = FALSE;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Current
//
//  Synopsis:   Returns the current ISegment position of the iterator.
//
//  Arguments:  ppISegment = OUTPUT pointer to an ISegment which will contain
//                the current segment for this iterator.
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT 
CAutoRangeIterator::Current(ISegment **pISegment)
{
    HRESULT hr = E_FAIL;

    Assert( pISegment != NULL );
    
    if( (_pRange != NULL) && (pISegment != NULL ) )
    {
        hr = _pRange->QueryInterface(IID_ISegment, (void **)pISegment);
    }

    RRETURN(hr);        
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::IsDone
//
//  Synopsis:   Returns whether or not we have iterated past the end of our
//              list.
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = There are no more elements
//              S_FALSE = There are more elements
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::IsDone(void)
{
    return (_fDone == TRUE) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::Advance
//
//  Synopsis:   Advances the iterator by one element.  For the auto range, 
//              which only has one element, this sets fDone to TRUE
//
//  Arguments:  VOID
//
//  Returns:    S_OK    = The iterator was advanced successfully
//              S_FALSE = The advance operation failed
//
//--------------------------------------------------------------------------
HRESULT
CAutoRangeIterator::Advance(void)
{
    HRESULT hr = S_FALSE;

    if( IsDone() == S_FALSE )
    {
        _fDone = TRUE;
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CAutoRangeIterator::QueryInterface
//
//  Synopsis:   IUnknown QueryInterface implementation
//--------------------------------------------------------------------------
STDMETHODIMP
CAutoRangeIterator::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppvObj )
{
    if(!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if( iid == IID_IUnknown || iid == IID_ISegmentListIterator )
    {
        *ppvObj = (ISegmentListIterator *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+====================================================================================
//
// Method:   LeftOrSlave
//
// Synopsis: Like IMarkupPointer::Left, but doesn't hide textslave
//
//------------------------------------------------------------------------------------
HRESULT
CAutoRange::LeftOrSlave (
        IMarkupPointer * pPointer,
        BOOL fMove,
        MARKUP_CONTEXT_TYPE *pContext,
        IHTMLElement** ppElement,
        long *pcch,
        OLECHAR* pchText)
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pmp = NULL;
    DWORD            dwFlags = MPTR_SHOWSLAVE;

    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    hr = THR( pmp->There( TRUE, fMove, pContext, ppElement, pcch, pchText, & dwFlags ) );

Cleanup:

    RRETURN( hr );
}

//+====================================================================================
//
// Method:   RightOrSlave
//
// Synopsis: Like IMarkupPointer::Right, but doesn't hide textslave
//
//------------------------------------------------------------------------------------
HRESULT
CAutoRange::RightOrSlave (
        IMarkupPointer * pPointer,
        BOOL fMove,
        MARKUP_CONTEXT_TYPE *pContext,
        IHTMLElement** ppElement,
        long *pcch,
        OLECHAR* pchText)
{
    HRESULT          hr;
    CMarkupPointer * pmp = NULL;
    DWORD            dwFlags = MPTR_SHOWSLAVE;

    if (!pPointer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    hr = THR( pmp->There( FALSE, fMove, pContext, ppElement, pcch, pchText, & dwFlags ) );

Cleanup:

    RRETURN( hr );
}

//
//============================================================================
//


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::~CAutoRangeCollection
//
//----------------------------------------------------------------

CAutoRangeCollection::~CAutoRangeCollection()
{
    _aryRanges.ReleaseAll();
}


//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CAutoRangeCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLTxtRangeCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    if(!ppv)
        return E_POINTER;
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLTxtRangeCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::length
//
//  Sysnopsis : Returns number of elements in the collection
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // Simply return the array size
    *pLength = _aryRanges.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::item
//
//  Sysnopsis : Returns rect at given index
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::item(VARIANT * pvarIndex, VARIANT * pvarRet)
{
    HRESULT   hr = S_OK;
    CVariant  varArg;
    long      lIndex;

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // ECMA rule - return empty for access beyond array bounds
    V_VT(pvarRet) = VT_EMPTY;

    // first attempt ordinal access...
    hr = THR(varArg.CoerceVariantArg(pvarIndex, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&varArg);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItem(lIndex, pvarRet));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CAutoRangeCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryRanges.EnumVARIANT(VT_DISPATCH,
                                    (IEnumVARIANT**)ppEnum,
                                    FALSE,
                                    FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::FindByName
//
//  Sysnopsis : This function seraches for an item having given
//                name in the collection and returns its index.
//                It returns -1 if item is not found.
//              We do not support named items for rectangle 
//               collection so we always return a -1
//----------------------------------------------------------------
long 
CAutoRangeCollection::FindByName(LPCTSTR pszName, BOOL fCaseSensitive)
{
    return -1;
}

//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::GetName
//
//  Sysnopsis : This virtual function returns the name of given item.
//              We do not support named collection access.
//----------------------------------------------------------------

LPCTSTR 
CAutoRangeCollection::GetName(long lIdx)
{
    return NULL;
}


//+---------------------------------------------------------------
//
//  Member  : CAutoRangeCollection::GetItem
//
//  Sysnopsis : Returns the item that has given order in the collection.
//              If the index is out of range returns S_FALSE.
//              If ppDisp is NULL only checks that range and returns
//               S_OK if index is in range, S_FALSE if out
//
//----------------------------------------------------------------

HRESULT 
CAutoRangeCollection::GetItem( long lIndex, VARIANT *pvar )
{
    HRESULT hr;
    CAutoRange * pRange;

    if (lIndex < 0 || lIndex >= _aryRanges.Size())
    {
        hr = S_FALSE;
		if(pvar)
			V_DISPATCH(pvar) = NULL;
        goto Cleanup;
    }

    if(!pvar)
    {
        // No ppDisp, caller wanted only to check for correct range
        hr = S_OK;
        goto Cleanup;
    }

    V_DISPATCH(pvar) = NULL;

    pRange = _aryRanges[lIndex];
    Assert(pRange);
    hr = THR(pRange->PrivateQueryInterface(IID_IDispatch, (void **) &V_DISPATCH(pvar)));
    if (hr)
        goto Cleanup;

    V_VT(pvar) = VT_DISPATCH;
Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\linesrv.cxx ===
\/*
 *  @doc    INTERNAL
 *
 *  @module LINESRV.CXX -- line services interface
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *      Paul Parker
 *
 *  History: <nl>
 *      11/20/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_ROBJ_H_
#define X_ROBJ_H_
#include <robj.h>
#endif

#ifndef X_LSHYPH_H_
#define X_LSHYPH_H_
#include <lshyph.h>
#endif

#ifndef X_LSKYSR_H_
#define X_LSKYSR_H_
#include <lskysr.h>
#endif

#ifndef X_LSEMS_H_
#define X_LSEMS_H_
#include <lsems.h>
#endif

#ifndef X_LSPAP_H_
#define X_LSPAP_H_
#include <lspap.h>
#endif

#ifndef X_LSCHP_H_
#define X_LSCHP_H_
#include <lschp.h>
#endif

#ifndef X_LSTABS_H_
#define X_LSTABS_H_
#include <lstabs.h>
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

DeclareLSTag( tagLSCallBack, "Trace callbacks" );
DeclareLSTag( tagLSAsserts, "Show LS Asserts" );
DeclareLSTag( tagLSFetch, "Trace FetchPap/FetchRun" );
DeclareLSTag( tagLSNoBlast, "No blasting at render time" );
DeclareLSTag( tagLSIME, "Trace IME" );
DeclareLSTag( tagAssertOnHittestingWithLS, "Enable hit-testing assertions.");

MtDefine(LineServices, Mem, "LineServices")
MtDefine(LineServicesMem, LineServices, "CLineServices::NewPtr/ReallocPtr")
MtDefine(CLineServices, LineServices, "CLineServices")
MtDefine(CLineServices_arySynth_pv, CLineServices, "CLineServices::_arySynth::_pv")
MtDefine(CLineServices_aryOneRuns_pv, CLineServices, "CLineServices::_aryOneRuns::_pv")
MtDefine(CLineServices_aryLineFlags_pv,  CLineServices, "CLineServices::_aryLineFlags::_pv")
MtDefine(CLineServices_aryLineCounts_pv, CLineServices, "CLineServices::_aryLineCounts::_pv")
MtDefine(CLineServicesCalculatePositionsOfRangeOnLine_aryLsqsubinfo_pv, Locals, "CLineServices::CalculatePositionsOfRangeOnLine::aryLsqsubinfo_pv");
MtDefine(CLineServicesCalculateRectsOfRangeOnLine_aryLsqsubinfo_pv, Locals, "CLineServices::CalculateRectsOfRangeOnLine::aryLsqsubinfo_pv");
MtDefine(COneRun, LineServices, "COneRun")
MtDefine(CLineServices_SetRenHighlightScore_apRender_pv, CLineServices, "CLineServices::SetRenHighlightScore_apRender_pv");
MtDefine(CLineServices_VerticalAlignOneObjectFast, LFCCalcSize, "Calls to VerticalAlignOneObjectFast" )

extern LCID g_lcidLocalUserDefault;

enum KASHIDA_PRIORITY
{
    KASHIDA_PRIORITY1,    // SCRIPT_JUSTIFY_ARABIC_KASHIDA
    KASHIDA_PRIORITY2,    // SCRIPT_JUSTIFY_ARABIC_SEEN
    KASHIDA_PRIORITY3,    // SCRIPT_JUSTIFY_ARABIC_HA
    KASHIDA_PRIORITY4,    // SCRIPT_JUSTIFY_ARABIC_ALEF
    KASHIDA_PRIORITY5,    // SCRIPT_JUSTIFY_ARABIC_BARA
    KASHIDA_PRIORITY6,    // SCRIPT_JUSTIFY_ARABIC_RA
    KASHIDA_PRIORITY7,    // SCRIPT_JUSTIFY_ARABIC_NORMAL
    KASHIDA_PRIORITY8,    // SCRIPT_JUSTIFY_ARABIC_BA
    KASHIDA_PRIORITY9,    // Max - lowest priority
};

int const s_iKashidaPriFromScriptJustifyType[] =
    {
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_NONE
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_ARABIC_BLANK
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_CHARACTER
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED1
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_BLANK    
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED2
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED3
    KASHIDA_PRIORITY7, // SCRIPT_JUSTIFY_ARABIC_NORMAL
    KASHIDA_PRIORITY1, // SCRIPT_JUSTIFY_ARABIC_KASHIDA
    KASHIDA_PRIORITY4, // SCRIPT_JUSTIFY_ARABIC_ALEF
    KASHIDA_PRIORITY3, // SCRIPT_JUSTIFY_ARABIC_HA
    KASHIDA_PRIORITY6, // SCRIPT_JUSTIFY_ARABIC_RA
    KASHIDA_PRIORITY8, // SCRIPT_JUSTIFY_ARABIC_BA
    KASHIDA_PRIORITY5, // SCRIPT_JUSTIFY_ARABIC_BARA
    KASHIDA_PRIORITY2, // SCRIPT_JUSTIFY_ARABIC_SEEN
    KASHIDA_PRIORITY9, // SCRIPT_JUSTIFY_RESERVED4
    };

//-----------------------------------------------------------------------------
//
//  Function:   InitLineServices (global)
//
//  Synopsis:   Instantiates a instance of the CLineServices object and makes
//              the requisite calls into the LineServices DLL.
//
//  Returns:    HRESULT
//              *ppLS - pointer to newly allocated CLineServices object
//
//-----------------------------------------------------------------------------

HRESULT
InitLineServices(
    CMarkup *pMarkup,           // IN
    BOOL fStartUpLSDLL,         // IN
    CLineServices ** ppLS)      // OUT
{
    HRESULT hr = S_OK;
    CLineServices * pLS;

    // Note: this assertion will fire sometimes if you're trying to put
    // pointers to member functions into the lsimethods structure.  Note that
    // pointer to member functions are different from function pointers -- ask
    // one of the Borland guys (like ericvas) to explain.  Sometimes they will
    // be bigger than 4 bytes, causing mis-alignment between our structure and
    // LS's, and thus this assertion to fire.

#if defined(UNIX) || defined(_MAC) // IEUNIX uses 8/12 bytes Method ptrs.
    AssertSz(sizeof(CLineServices::LSIMETHODS) == sizeof(LSIMETHODS),
             "Line Services object callback struct has unexpectedly changed.");
    AssertSz(sizeof(CLineServices::LSCBK) == sizeof(LSCBK),
             "Line Services callback struct has unexpectedly changed.");
#endif
    //
    // Create our Line Services interface object
    //

    pLS = new CLineServices(pMarkup);
    if (!pLS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    WHEN_DBG(pLS->_lockRecrsionGuardFetchRun = FALSE;)
            
    pLS->_plsc = NULL;
    if (fStartUpLSDLL)
    {
        hr = THR(StartUpLSDLL(pLS, pMarkup));
        if (hr)
        {
            delete pLS;
            goto Cleanup;
        }
    }

    //
    // Return value
    //

    *ppLS = pLS;

Cleanup:
    RRETURN(hr);
}


HRESULT
StartUpLSDLL(CLineServices *pLS, CMarkup *pMarkup)
{
    LSCONTEXTINFO lsci;
    HRESULT hr = S_OK;

    if (pMarkup != pLS->GetMarkup())
        pLS->_treeInfo._tpFrontier.Reinit(pMarkup, 0);

    if (pLS->_plsc)
        goto Cleanup;

#ifndef DLOAD1
    //
    // Make sure we init all of the dynprocs for LS
    //
    hr = THR( InitializeLSDynProcs() );
    if (hr)
        goto Cleanup;
#endif

    //
    // Fetch the Far East object handlers
    //

    hr = THR( pLS->SetupObjectHandlers() );
    if (hr)
        goto Cleanup;

    //
    // Populate the LSCONTEXTINFO
    //

    lsci.version = 0;
    lsci.cInstalledHandlers = CLineServices::LSOBJID_COUNT;
#if !defined(UNIX) && !defined(_MAC)
    *(CLineServices::LSIMETHODS **)&lsci.pInstalledHandlers = pLS->g_rgLsiMethods;
#else
    {
        static BOOL fInitDone = FALSE;
        if (!fInitDone)
        {
            // Copy g_rgLsiMethods -> s_unix_rgLsiMethods
            pLS->InitLsiMethodStruct();
            fInitDone = TRUE;
        }
    }
    lsci.pInstalledHandlers = pLS->s_unix_rgLsiMethods;
#endif
    lsci.lstxtcfg = pLS->s_lstxtcfg;
    lsci.pols = (POLS)pLS;
#if !defined(UNIX) && !defined(_MAC)
    *(CLineServices::LSCBK *)&lsci.lscbk = CLineServices::s_lscbk;
#else
    CLineServices::s_lscbk.fill(&lsci.lscbk);
#endif
    lsci.fDontReleaseRuns = TRUE;

    //
    // Call in to Line Services
    //

    hr = HRFromLSERR( LsCreateContext( &lsci, &pLS->_plsc ) );
    if (hr)
        goto Cleanup;

    //
    // Set Expansion/Compression tables
    //

    hr = THR( pLS->SetModWidthPairs() );
    if (hr)
        goto Cleanup;
            
    //
    // Runtime sanity check
    //

    WHEN_DBG( pLS->InitTimeSanityCheck() );

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   DeinitLineServices (global)
//
//  Synopsis:   Frees a CLineServes object.
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
DeinitLineServices(CLineServices * pLS)
{
    HRESULT hr = S_OK;

    if (pLS->_plsc)
        hr = HRFromLSERR( LsDestroyContext( pLS->_plsc ) );

    delete pLS;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   SetupObjectHandlers (member)
//
//  Synopsis:   LineServices uses object handlers for special textual
//              representation.  There are six such objects in Trident,
//              and for five of these, the callbacks are implemented by
//              LineServices itself.  The sixth object, our handle for
//              embedded/nested objects, is implemented in lsobj.cxx.
//
//  Returns:    S_OK - Success
//              E_FAIL - A LineServices error occurred
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::SetupObjectHandlers()
{
    HRESULT hr = E_FAIL;
    ::LSIMETHODS *pLsiMethod;

#if !defined(UNIX) && !defined(_MAC)
    pLsiMethod = (::LSIMETHODS *)g_rgLsiMethods;
#else
    pLsiMethod = s_unix_rgLsiMethods;
#endif

    if (lserrNone != LsGetRubyLsimethods( pLsiMethod + LSOBJID_RUBY ))
        goto Cleanup;

    if (lserrNone != LsGetTatenakayokoLsimethods( pLsiMethod + LSOBJID_TATENAKAYOKO ))
        goto Cleanup;

    if (lserrNone != LsGetHihLsimethods( pLsiMethod + LSOBJID_HIH ))
        goto Cleanup;

    if (lserrNone != LsGetWarichuLsimethods( pLsiMethod + LSOBJID_WARICHU ))
        goto Cleanup;

    if (lserrNone != LsGetReverseLsimethods( pLsiMethod + LSOBJID_REVERSE ))
        goto Cleanup;

    hr = S_OK;

#if DBG == 1
    // Every object, which has a scope have to have a level in object hierarchy.
    // Non-scope objects have to have level set to 0.
    for (int type = SYNTHTYPE_NONE; type < SYNTHTYPE_COUNT; type++)
    {
        if (s_aSynthData[type].fObjStart || s_aSynthData[type].fObjEnd)
            Assert(s_aSynthData[type].idLevel != 0);
        else
            Assert(s_aSynthData[type].idLevel == 0);
    }
#endif

Cleanup:

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   NewPtr (member, LS callback)
//
//  Synopsis:   A client-side allocation routine for LineServices.
//
//  Returns:    Pointer to buffer allocated, or NULL if out of memory.
//
//-----------------------------------------------------------------------------

void* WINAPI
CLineServices::NewPtr(DWORD cb)
{
    void * p;

    p = MemAlloc( Mt(LineServicesMem), cb );

    MemSetName((p, "CLineServices::NewPtr"));

    return p;
}

//-----------------------------------------------------------------------------
//
//  Function:   DisposePtr (member, LS callback)
//
//  Synopsis:   A client-side 'free' routine for LineServices
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

void  WINAPI
CLineServices::DisposePtr(void* p)
{
    MemFree(p);
}

//-----------------------------------------------------------------------------
//
//  Function:   ReallocPtr (member, LS callback)
//
//  Synopsis:   A client-side reallocation routine for LineServices
//
//  Returns:    Pointer to new buffer, or NULL if out of memory
//
//-----------------------------------------------------------------------------

void* WINAPI
CLineServices::ReallocPtr(void* p, DWORD cb)
{
    void * q = p;
    HRESULT hr;

    hr = MemRealloc( Mt(LineServicesMem), &q, cb );

    return hr ? NULL : q;
}

LSERR WINAPI
CLineServices::GleanInfoFromTheRun(COneRun *por, COneRun **pporOut)
{
    LSERR         lserr = lserrNone;
    const         CCharFormat *pCF;
    WHEN_DBG(BOOL fWasTextRun = TRUE;)
    SYNTHTYPE     synthCur = SYNTHTYPE_NONE;
    LONG          cp = por->Cp();
    LONG          nDirLevel;
    LONG          nSynthDirLevel;
    COneRun     * porOut = por;
    BOOL          fLastPtp;
    BOOL          fNodeRun;
    CTreeNode   * pNodeRun;

    por->_fHidden = FALSE;
    porOut->_fNoTextMetrics = FALSE;

    if (   _pflw._fDoPostFirstLetterWork
        && _pflw._fStartedPseudoMBP
        && _pMarkup->HasCFState() // may be null in OOM
       )
    {
        BOOL fH, fV;
        CRect rcDimensions;
        CComputeFormatState * pcfState = _pMarkup->GetCFState();

        pNodeRun = pcfState->GetBlockNodeLetter();
        Verify(pNodeRun->GetInlineMBPForPseudo(_pci, GIMBPC_ALL, &rcDimensions, &fH, &fV));
        _pflw._fStartedPseudoMBP = FALSE;
        lserr = AppendSynth(por, SYNTHTYPE_MBPCLOSE, &porOut);
        if (lserr == lserrNone)
        {
            porOut->_mbpTop = _mbpTopCurrent;
            porOut->_mbpBottom = _mbpBottomCurrent;
            _mbpTopCurrent -= rcDimensions.top;
            _mbpBottomCurrent -= rcDimensions.bottom;
            porOut->_xWidth = rcDimensions.right;
            porOut->_fIsPseudoMBP = TRUE;
        }

        if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), TRUE))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
        }

        goto Done;
    }
    
    if (por->_ptp->IsNode())
    {
        fNodeRun = TRUE;
        pNodeRun = por->_ptp->Branch();
        fLastPtp = por->_ptp == _treeInfo._ptpLayoutLast;
        const      CCharFormat *pCF  = por->GetCF();

        if (    pCF->_fHasInlineBg
            && !pCF->IsDisplayNone()
           )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_INLINE_BG_OR_BORDER);
        }
        
        // if the run is
        // a) is an node pos
        // b) and needs to glyphed either for glyphs or for MBP
        // c) and has not been synthed either for editing glyphs or MBP
        // d) not the last run in the layout
        // then we want to create those synths
        if (((  _fIsEditable
              && por->_ptp->ShowTreePos()
             )
             || (   pNodeRun->HasInlineMBP(LC_TO_FC(GetLayoutContext()))
                 && !pCF->IsDisplayNone()
                )
            )
            && !por->_fSynthedForMBPOrG
            && !fLastPtp
           )
        {
            CRect rcDimensions;
            BOOL fHPercentAttr;
            BOOL fVPercentAttr;
            COneRun *porRet = NULL;

            if (por->_ptp->IsBeginNode())
            {
                // Create open glyph if it is needed
                if (   _fIsEditable
                    && por->_ptp->ShowTreePos()
                   )
                {
                    lserr = AppendSynth(por, SYNTHTYPE_GLYPH, &porRet);
                    if (lserr != lserrNone)
                        goto Done;
                    Assert(porRet);
                    porRet->_lsCharProps.idObj = LSOBJID_GLYPH;
                    SetRenderingHighlights(porRet);
                    _lineFlags.AddLineFlagForce(cp - 1, FLAG_HAS_NOBLAST | FLAG_HAS_NODUMMYLINE);
                }

                // Now create an open mbp if it is needed
                if (   pNodeRun->HasInlineMBP()
                    && pNodeRun->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fHPercentAttr, &fVPercentAttr)
                   )
                {
                    if (fHPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetHorzPercentAttrInfo(TRUE);
                    if (fVPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetVertPercentAttrInfo(TRUE);
                    _mbpTopCurrent += rcDimensions.top;
                    _mbpBottomCurrent += rcDimensions.bottom;

                    _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);

                    if (   por->_ptp->IsEdgeScope()
                        && rcDimensions.left
                       )
                    {
                        COneRun *porTemp;
                        lserr = AppendSynth(por, SYNTHTYPE_MBPOPEN, &porTemp);
                        if (lserr != lserrNone)
                            goto Done;
                        Assert(porTemp);
                        if (!porRet)
                            porRet = porTemp;
                        porTemp->_xWidth = rcDimensions.left;
                        porTemp->_fIsLTR = !(GetDirLevel(porTemp->_lscpBase) & 0x1);
                    }

                    if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), FALSE))
                    {
                        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }
                }
            }
            else
            {
                // Create a close mbp if it is needed
                if (   pNodeRun->HasInlineMBP()
                    && pNodeRun->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fHPercentAttr, &fVPercentAttr)
                    && !pCF->IsDisplayNone()
                   )
                {
                    if (fHPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetHorzPercentAttrInfo(TRUE);
                    if (fVPercentAttr)
                        ((CDisplay*)(_pMeasurer->_pdp))->SetVertPercentAttrInfo(TRUE);
                    _mbpTopCurrent -= rcDimensions.top;
                    _mbpBottomCurrent -= rcDimensions.bottom;

                    _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);

                    if (   por->_ptp->IsEdgeScope()
                        && rcDimensions.right
                       )
                    {
                        lserr = AppendSynth(por, SYNTHTYPE_MBPCLOSE, &porRet);
                        if (lserr != lserrNone)
                            goto Cleanup;
                        Assert(porRet);
                        porRet->_xWidth = rcDimensions.right;
                        porRet->_fIsLTR = !(GetDirLevel(porRet->_lscpBase) & 0x1);
                    }

                    if (HasBorders(pNodeRun->GetFancyFormat(), pNodeRun->GetCharFormat(), FALSE))
                    {
                        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }

                }

                // Create close glyph if it is needed
                if (   _fIsEditable
                    && por->_ptp->ShowTreePos()
                   )
                {
                    COneRun *porTemp;
                    lserr = AppendSynth(por, SYNTHTYPE_GLYPH, &porTemp);
                    if (lserr != lserrNone)
                        goto Done;
                    Assert(porTemp);
                    if (!porRet)
                        porRet = porTemp;
                    porTemp->_lsCharProps.idObj = LSOBJID_GLYPH;
                    SetRenderingHighlights(porTemp);
                    _lineFlags.AddLineFlagForce(cp -1, FLAG_HAS_NOBLAST | FLAG_HAS_NODUMMYLINE);
                }
            }
            if (porRet)
            {
                por->_fSynthedForMBPOrG = TRUE;
                porOut = porRet; 
                goto Done;
            }
        }
    }
    else
    {
        fNodeRun = FALSE;
        fLastPtp = FALSE;
        Assert(por->_ptp != _treeInfo._ptpLayoutLast);
        pNodeRun = NULL;
    }

    if (_pflw._fDoPostFirstLetterWork)
    {
        _pflw._fDoPostFirstLetterWork = FALSE;
        _pflw._fStartedPseudoMBP = FALSE;

        CTreeNode *pNode = por->Branch();
        _pMeasurer->PseudoLetterDisable();
        _treeInfo.SetupCFPF(TRUE, pNode FCCOMMA LC_TO_FC(GetLayoutContext()));

        if (_pflw._fTerminateLine)
        {
            _pflw._fTerminateLine = FALSE;
            lserr = TerminateLine(por, TL_ADDLBREAK, &porOut);
            goto Cleanup;
        }

        if (_pflw._fChoppedFirstLetter)
        {
            _pflw._fChoppedFirstLetter = FALSE;
            if (por->_fMustDeletePcf)
            {
                delete por->_pCF;
                por->_fMustDeletePcf = FALSE;
            }
            por->_pCF = (CCharFormat *)_treeInfo._pCF;
#if DBG==1
            por->_pCFOriginal = por->_pCF;
#endif
            por->_pPF = _treeInfo._pPF;
            por->_pFF = _treeInfo._pFF;
        }
    }
    
    if (   _pMeasurer->_fMeasureFromTheStart
        && (cp - _cpStart) < _pMeasurer->_cchPreChars
       )
    {
        WhiteAtBOL(cp, por->_lscch);
        por->MakeRunAntiSynthetic();
        goto Done;
    }

    //
    // Take care of hidden runs. We will simply anti-synth them
    //
    if (   por->GetCF()->IsDisplayNone()
        && !fLastPtp // Check for !lastptp since the formats are not setup correctly
                     // for the last ptp
       )
    {
        if (IsFirstNonWhiteOnLine(cp))
            WhiteAtBOL(cp, por->_lscch);
        // This condition will succeed only if we have overlapping display:none.
        // In that case, we do not want to overload BlastLineToScreen with checking
        // for overlapping and hence we just do not blast such lines.
        if (!por->_fCharsForNestedElement)
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        _lineCounts.AddLineCount(cp, LC_HIDDEN, por->_lscch);
        por->MakeRunAntiSynthetic();
        goto Done;
    }

    // BR with clear causes a break after the line break,
    // where as clear on phrase or block elements should clear
    // before the phrase or block element comes into scope.
    // Clear on aligned elements is handled separately, so
    // do not mark the line with clear flags for aligned layouts.
    if (   cp != _cpStart
        && fNodeRun
        && pNodeRun->Tag() != ETAG_BR
        && !por->GetFF()->_fAlignedLayout
        && por->_ptp->IsBeginNode()
        && _pMeasurer->TestForClear(_pMarginInfo, cp - 1, TRUE, por->GetFF())
       )
    {
        lserr = TerminateLine(por, TL_ADDEOS, &porOut);
        Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
        goto Cleanup;
    }
            
    if (   !por->_fCharsForNestedLayout
        && fNodeRun
       )
    {
        CElement  *pElement          = pNodeRun->Element();
        BOOL       fFirstOnLineInPre = FALSE;
        const      CCharFormat *pCF  = por->GetCF();

        // This run can never be hidden, no matter what the HTML says
        Assert(!por->_fHidden);

        if (!fLastPtp && IsFirstNonWhiteOnLine(cp))
        {
            WhiteAtBOL(cp, por->_lscch);

            //
            // If we have a <BR> inside a PRE tag then we do not want to
            // break if the <BR> is the first thing on this line. This is
            // because there should have been a \r before the <BR> which
            // caused one line break and we should not have the <BR> break
            // another line. The only execption is when the <BR> is the
            // first thing in the paragraph. In this case we *do* want to
            // break (the exception was discovered via bug 47870).
            //
            if (   _pPFFirst->HasPre(_fInnerPFFirst)
                && !(_lsMode == LSMODE_MEASURER ? _li._fFirstInPara : _pli->_fFirstInPara)
               )
            {
                fFirstOnLineInPre = TRUE;
            }
        }

        if (   por->_ptp->IsEdgeScope()
            && (   _pFlowLayout->IsElementBlockInContext(pElement)
                || fLastPtp
               )
            && (   !fFirstOnLineInPre
                || (   por->_ptp->IsEndElementScope()
                    && pElement->_fBreakOnEmpty
                    && pElement->Tag() == ETAG_PRE
                   )
               )
            && pElement->Tag() != ETAG_BR
           )
        {
#if 0            
            Assert(   fLastPtp
                   || !IsFirstNonWhiteOnLine(cp)
                   || pElement->_fBreakOnEmpty
                   || (ETAG_LI == pElement->Tag())
                  );
#endif

            if (   pCF->HasPadBord(FALSE)
                && !fLastPtp
               )
            {
                CheckForPaddingBorder(por);
            }

            // NOTE(SujalP): We are check for MBPorG while it should ideally be just
            // glyph, but since the current por is a block element it can only be
            // Glyph, since MBP is for inline elements only.
            lserr = TerminateLine(por,
                                  ((fLastPtp || por->_fSynthedForMBPOrG) ? TL_ADDEOS : TL_ADDLBREAK),
                                  &porOut);
            if (lserr != lserrNone || !porOut)
            {
                lserr = lserrOutOfMemory;
                goto Done;
            }

            // Hide the run that contains the WCH_NODE for the end
            // edge in the layout
            por->_fHidden = TRUE;

            if (fLastPtp)
            {
                if (   IsFirstNonWhiteOnLine(cp)
                    && (   _fIsEditable
                        || _pFlowLayout->GetContentTextLength() == 0
                       )
                    )
                {
                    CCcs ccs;
                    if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                        RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);

                    // This line is not a dummy line. It has a height. The
                    // code later will treat it as a dummy line. Prevent
                    // that from happening.
                    _fLineWithHeight = TRUE;
                }
                goto Done;
            }

            //
            // Bug66768: If we came here at BOL without the _fHasBulletOrNum flag being set, it means
            // that the previous line had a <BR> and we will terminate this line at the </li> so that
            // all it contains is the </li>. In this case we do infact want the line to have a height
            // so users can type there.
            //
            else if (   IsListItem(pNodeRun)
                     && por->_ptp->IsEndNode()
                     && !_li._fHasBulletOrNum
                     && IsFirstNonWhiteOnLine(cp)
                     && (  !_pMeasurer->_fEmptyLineForPadBord
                         || _fIsEditable
                        )
                    )
            {
                CCcs ccs;
                if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                    RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);
                _fLineWithHeight = TRUE;
            }
        }
        else  if (   por->_ptp->IsEndNode()
                  && pElement->Tag() == ETAG_BR
                  && !fFirstOnLineInPre
                 )
        {
            _lineFlags.AddLineFlag(cp - 1, FLAG_HAS_A_BR);
            AssertSz(por->_ptp->IsEndElementScope(), "BR's cannot be proxied!");
            Assert(por->_lscch == 1);
            Assert(por->_lscchOriginal == 1);

            lserr = TerminateLine(por, TL_ADDNONE, &porOut);
            if (lserr != lserrNone)
                goto Done;
            if (!porOut)
                porOut = por;

            por->FillSynthData(SYNTHTYPE_LINEBREAK);
            _pMeasurer->TestForClear(_pMarginInfo, cp, FALSE, por->GetFF());
            if (IsFirstNonWhiteOnLine(cp))
                _fLineWithHeight = TRUE;

            if (   _pci->GetLayoutContext() 
                && _pci->GetLayoutContext()->ViewChain() )
            {
                Assert(pNodeRun);

                // page break before / after support on br
                const CFancyFormat *pFF = pNodeRun->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

                _li._fPageBreakAfter    |= GET_PGBRK_BEFORE(pFF->_bPageBreaks) || GET_PGBRK_AFTER(pFF->_bPageBreaks);
                _pci->_fPageBreakLeft   |= (   IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft) 
                                            || IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft)   );
                _pci->_fPageBreakRight  |= (   IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight)
                                            || IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight)  );
            }
        }
        //
        // Handle premature Ruby end here
        // Example: <RUBY>some text</RUBY>
        //
        else if (   pElement->Tag() == ETAG_RUBY
                 && por->_ptp->IsEndNode()       // this is an end ruby tag
                 && _fIsRuby                     // and we currently have an open ruby
                 && !_fIsRubyText                // and we have not yet closed it off
                 && !IsFrozen())
        {
            COneRun *porTemp = NULL;
            Assert(por->_lscch == 1);
            Assert(por->_lscchOriginal == 1);

            // if we got here then we opened a ruby but never ended the main
            // text (i.e., with an RT).  Now we want to end everything, so this
            // involves first appending a synthetic to end the main text and then
            // another one to end the (nonexistent) pronunciation text.
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYMAIN, &porOut);
            Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYTEXT, &porTemp);
            Assert(lserr != lserrNone || porTemp->_synthType != SYNTHTYPE_NONE);

            // We set this to FALSE because por will eventually be marked as
            // "not processed yet", which means that the above condition will trip
            // again unless we indicate that the ruby is now closed
            _fIsRuby = FALSE;
        }
        // WBR handling - if we are currently inside NOBR, we have to close
        //and reopen NOBR, creating breaking opportunity.
        //If we are not inside NOBR, we synthesize SYNTHTYPE_WBR run that 
        //modifies breaking behavior to break the line if it doesn't fit.
        //We use _fSynthedForMBPOrG flag to ignore and antisynth the run when it
        //will come back to us next time.
        else if(   pElement->Tag() == ETAG_WBR
                && por->_ptp->IsEndNode()
                && !por->_fSynthedForMBPOrG
               )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_EMBED_OR_WBR);

            if(_fNoBreakForMeasurer)    //inside NOBR subline?
            {
                por->FillSynthData(SYNTHTYPE_ENDNOBR);
            }
            else
            {
                lserr = AppendSynth(por, SYNTHTYPE_WBR, &porOut);
                Assert(lserr != lserrNone || porOut->_synthType == SYNTHTYPE_WBR);
                if (lserr == lserrNone)
                    porOut->_xWidth = 0;
                por->_fSynthedForMBPOrG = TRUE;
            }
        }
        // NOBR handling (IE5.0 compat) - if we are currently inside NOBR object, 
        // and we see a closing tag - it's may be a tag that closes nobr.
        //If the next ptp will be an opening tag with nobr attribute, we can skip
        // a breaking opportunity. To create it, we catch every EndNode tag here 
        // and see if parent doesn't have a nobr attribute. If so, we create a breaking
        // opportunity. This works for IE5.0 case (<NOBR> tags, no overlapping or inheritance),
        // and it works for CSS attribute white-space:nowrap,
        // (this attribute is the same as NOBR but can be inherited, nested, etc)
        else if(   _fNoBreakForMeasurer 
                && por->_ptp->IsEndNode() 
                && !por->_fSynthedForMBPOrG
               )
        {
            CTreeNode *pParentNode = por->Branch()->Parent();
            const CCharFormat *pParentCF = pParentNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (!pParentCF->HasNoBreak(SameScope(pParentNode, _pFlowLayout->ElementContent())))
            {
                lserr = AppendSynth(por, SYNTHTYPE_ENDNOBR, &porOut);
                if (lserr != lserrNone)
                    goto Cleanup;
                por->_fSynthedForMBPOrG = TRUE;
            }
            else
                por->MakeRunAntiSynthetic();

        }
        else
        {
            //
            // A normal phrase element start or end run. Just make
            // it antisynth so that it is hidden from LS
            //
            por->MakeRunAntiSynthetic();
        }

        if (!por->IsAntiSyntheticRun())
        {
            //
            // Empty lines will need some height!
            //
            if (   pElement->_fBreakOnEmpty
                && (  !_pMeasurer->_fEmptyLineForPadBord
                    || _fIsEditable
                   )
                && IsFirstNonWhiteOnLine(cp)
               )
            {
                // We provide a line height only if something in our whitespace
                // is not providing some visual representation of height. So if our
                // whitespace was either aligned or abspos'd then we do NOT provide
                // any height since these sites provide some height of their own.
                if (   _lineCounts.GetLineCount(por->Cp(), LC_ALIGNEDSITES) == 0
                    && _lineCounts.GetLineCount(por->Cp(), LC_ABSOLUTESITES) == 0
                    && !_pMeasurer->_fSeenAbsolute
                   )
                {
                    CCcs ccs;
                    if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                        RecalcLineHeight(por->GetCF(), cp - 1, &ccs, &_li);
                    _fLineWithHeight = TRUE;
                }
            }

            if (   IsFrozen()                       // if we called terminate line
                && IsDummyLine(por->Cp())           // and we are a dummy line
                && (   _pMeasurer->_fSeenAbsolute   // and we have absolutes
                    || _lineCounts.GetLineCount(por->Cp(), LC_ABSOLUTESITES) != 0
                   )
               )
            {
                // then we need to replace the PF in the measurer so that alignment
                // will work per the PF of the chars in the dummy line and not
                // based on the first char in the following line. Ideally I would
                // do this for all dummy lines, except that other dummy lines
                // really do not matter since they do not have anything rendered.
                LONG cpBegin = _cpStart;

                if (!_pMeasurer->_fMeasureFromTheStart)
                    cpBegin -= _pMeasurer->_cchPreChars;
                CTreePos *ptp = _pMarkup->TreePosAtCp(cpBegin, NULL, TRUE);
                if (ptp)
                {
                    CTreeNode *pNode = ptp->GetBranch();
                    _pMeasurer->MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())),
                                             SameScope(pNode, _pFlowLayout->ElementContent()),
                                             TRUE);
                }
            }
            
            //
            // If we have already decided to give the line a height then we want
            // to get the text metrics else we do not want the text metrics. The
            // reasons are explained in the blurb below.
            //
            if (!_fLineWithHeight)
            {
                //
                // If we have not anti-synth'd the run, it means that we have terminated
                // the line -- either due to a block element or due to a BR element. In either
                // of these 2 cases, if the element did not have break on empty, then we
                // do not want any of them to induce a descent. If it did have a break
                // on empty then we have already computed the heights, so there is no
                // need to do so again.
                //
                por->_fNoTextMetrics = TRUE;
            }
        }

        if (pCF->IsRelative(por->_fInnerCF))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
        }

        // Set the flag on the line if the current pcf has a background
        // image or color
        if(pCF->HasBgImage(por->_fInnerCF) || pCF->HasBgColor(por->_fInnerCF))
        {
            //
            // NOTE(SujalP): If _cpStart has a background, and nothing else ends up
            // on the line, then too we want to draw the background. But since the
            // line is empty cpMost == _cpStart and hence GetLineFlags will not
            // find this flag. To make sure that it does, we subtract 1 from the cp.
            // (Bug  43714).
            //
            (cp == _cpStart)
                    ? _lineFlags.AddLineFlagForce(cp - 1, FLAG_HAS_BACKGROUND)
                    : _lineFlags.AddLineFlag(cp, FLAG_HAS_BACKGROUND);
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        }

        if (pCF->_fBidiEmbed && _pBidiLine == NULL && !IsFrozen())
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
            Assert(GetDirLevel(por->_lscpBase) == 0);
        }

        // Some cases here which we need to let thru for the orther glean code
        // to look at........

        goto Done;
    }

    //
    // Figure out CHP, the layout info.
    //
    pCF = IsAdornment() ? _pNodeLi->GetCharFormat() : por->GetCF();
    Assert(pCF);

    // If we've transitioned directions, begin or end a reverse object.
    if (_pBidiLine != NULL &&
        (nDirLevel = _pBidiLine->GetLevel(cp)) !=
        (nSynthDirLevel = GetDirLevel(por->_lscpBase)))
    {
        if (!IsFrozen())
        {
            // Determine the type of synthetic character to add.
            if (nDirLevel > nSynthDirLevel)
            {
                synthCur = SYNTHTYPE_REVERSE;
            }
            else
            {
                synthCur = SYNTHTYPE_ENDREVERSE;
            }

            // Add the new synthetic character.
            lserr = AppendILSControlChar(por, synthCur, &porOut);
            Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
            goto Cleanup;
        }
    }
    else
    {
        if(!IsFrozen() && CheckForSpecialObjectBoundaries(por, &porOut))
            goto Cleanup;
    }

    CHPFromCF( por, pCF );

    por->_brkopt = (pCF->_fLineBreakStrict ? fBrkStrict : 0) |
                   (pCF->_fNarrow ? 0 : fCscWide);

    // Set the flag on the line if the current pcf has a background
    // image or color
    if(pCF->HasBgImage(por->_fInnerCF) || pCF->HasBgColor(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_BACKGROUND);
    }

    if (!por->_fCharsForNestedLayout)
    {
        const TCHAR chFirst = por->_pchBase[0];

        //
        // Check for bidi line
        //
        // NOTE: (grzegorz): The correct thing to do is to check if the parent has 
        // _fBidiEmbed or _fRTL flag set to true in case of layouts. Because there 
        // is no point to creating a bidi line if only layout is RTL.
        // But, since this check is expensive at this point we don't care and we 
        // create a bidi line. This will ensure correct behavior, but can be slight
        // slower, but anyway how many real word pages have ...<img dir=rtl>...
        //
        // NOTE: We have similar case for _fCharsForNestedLayout, but we have different
        // conditions and we need to eliminate any perf regressions, so we have this code
        // in 2 different places.
        //
        if (   _pBidiLine == NULL 
            && (   IsRTLChar(chFirst)
                || pCF->_fBidiEmbed 
                || pCF->_fRTL
               )
           )
        {
            if (!IsFrozen())
            {
                _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
                Assert(GetDirLevel(por->_lscpBase) == 0);

                if (_pBidiLine != NULL && _pBidiLine->GetLevel(cp) > 0)
                {
                    synthCur = SYNTHTYPE_REVERSE;
                    // Add the new synthetic character.
                    lserr = AppendILSControlChar(por, synthCur, &porOut);
                    Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                    goto Cleanup;
                }
            }
        }

        //
        // Currently the only nested elements we have other than layouts are hidden
        // elements. These are taken care of before we get here, so we should
        // never be here with this flag on.
        //

        // Note the relative stuff
        if (pCF->IsRelative(por->_fInnerCF))
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
        }

        // Don't blast:
        // a) disabled lines.
        // b) lines having hidden stuff
        if (   pCF->_fDisabled
            || pCF->IsVisibilityHidden()
           )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        }

        // NB (cthrash) If an NBSP character is at the beginning of a
        // text run, LS will convert that to a space before calling
        // GetRunCharWidths.  This implies that we will fail to recognize
        // the presence of NBSP chars if we only check at GRCW. So an
        // additional check is required here.  Similarly, if our 
        if ( chFirst == WCH_NBSP )
        {
            _lineFlags.AddLineFlag(cp, FLAG_HAS_NBSP);
        }
        
        lserr = ChunkifyTextRun(por, &porOut);
        if (lserr != lserrNone)
            goto Cleanup;

        if (porOut != por)
            goto Cleanup;
    }
    else
    {
        //
        // Check for bidi line
        //
        // NOTE: (grzegorz): The correct thing to do is to check if the parent has 
        // _fBidiEmbed or _fRTL flag set to true in case of layouts. Because there 
        // is no point to creating a bidi line if only layout is RTL.
        // But, since this check is expensive at this point we don't care and we 
        // create a bidi line. This will ensure correct behavior, but can be slight
        // slower, but anyway how many real word pages have ...<img dir=rtl>...
        //
        // NOTE: We have similar case for !_fCharsForNestedLayout, but we have different
        // conditions and we need to eliminate any perf regressions, so we have this code
        // in 2 different places.
        //
        if (   _pBidiLine == NULL 
            && (   pCF->_fBidiEmbed 
                || pCF->_fRTL
               )
           )
        {
            if (!IsFrozen())
            {
                _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
                Assert(GetDirLevel(por->_lscpBase) == 0);

                if (_pBidiLine != NULL && _pBidiLine->GetLevel(cp) > 0)
                {
                    synthCur = SYNTHTYPE_REVERSE;
                    // Add the new synthetic character.
                    lserr = AppendILSControlChar(por, synthCur, &porOut);
                    Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                    goto Cleanup;
                }
            }
        }

        //
        // It has to be some layout other than the layout we are measuring
        //
        Assert(   por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() ) );
        Assert(   por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() ) != _pFlowLayout);

#if DBG == 1
        CElement *pElementLayout = por->Branch()->GetUpdatedLayout( _pci->GetLayoutContext() )->ElementOwner();
        long cpElemStart = pElementLayout->GetFirstCp();

        // Count the characters in this site, so LS can skip over them on this line.
        Assert(por->_lscch == GetNestedElementCch(pElementLayout));
#endif

        _fHasSites = _fMinMaxPass;
        
        // We check if this site belongs on its own line.
        // If so, we terminate this line with an EOS marker.
        if (IsOwnLineSite(por))
        {
            // This guy belongs on his own line.  But we only have to terminate the
            // current line if he's not the first thing on this line.
            if (cp != _cpStart
#if 0
                // See bugs 100429 and 80980 for more details of the 2 lines of code here
                || (   _pMeasurer->_cchPreChars != 0
                    && IsDummyLine(cp)
                   )
#endif
               )
            {
                Assert(!por->_fHidden);

                // We're not first on line.  Terminate this line!
                lserr = TerminateLine(por, TL_ADDEOS, &porOut);
                Assert(lserr != lserrNone || porOut->_synthType != SYNTHTYPE_NONE);
                goto Cleanup;
            }
            // else we are first on line, so even though this guy needs to be
            // on his own line, keep going, because he is!

            // Note the relative stuff
            CTreeNode *pParentNode = por->Branch()->Parent();
            const CCharFormat *pParentCF = pParentNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (pParentCF->IsRelative(SameScope(pParentNode, _pFlowLayout->ElementContent())))
            {
                _lineFlags.AddLineFlag(cp, FLAG_HAS_RELATIVE);
            }

        }

        // If we kept looking after a single line site in _fScanForCR and we
        // came here, it means that we have another site after the single site and
        // hence should terminate the line
        else if (   _fScanForCR
                 && _fSingleSite
                )
        {
            lserr = TerminateLine(por, TL_ADDEOS, &porOut);
            goto Cleanup;
        }

        // Whatever this is, it is under a different site, so we have
        // to give LS an embedded object notice, and later recurse back
        // to format this other site.  For tables and spans and such, we have
        // to count and skip over the characters in this site.
        por->_lsCharProps.idObj = LSOBJID_EMBEDDED;

        Assert(cp == cpElemStart - 1);

        // ppwchRun shouldn't matter for a LSOBJID_EMBEDDED, but chunkify
        // objectrun might modify for putting in the symbols for aligned and
        // abspos'd sites
        WHEN_DBG(fWasTextRun = FALSE;)
        ChunkifyObjectRun(por, &porOut);

        por = porOut;
        goto Cleanup;
    }

    Assert(fWasTextRun);
    
    if (!por->_fHidden)
    {
        por->CheckForUnderLine(_fIsEditable);
        SetRenderingHighlights(por);
        
        if (_chPassword)
        {
            lserr = CheckForPassword(por);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else if (por->GetCF()->IsTextTransformNeeded())
        {
            lserr = TransformTextRun(por);
            if (lserr != lserrNone)
                goto Cleanup;
        }
    }

Cleanup:
    // Some characters we don't want contributing to the line height.
    // Non-textual runs shouldn't, don't bother for hidden runs either.
    //
    // ALSO, we want text metrics if we had a BR or block element
    // which was not break on empty
    porOut->_fNoTextMetrics |=   porOut->_fHidden
                              || porOut->_lsCharProps.idObj != LSOBJID_TEXT;

Done:
    if (   _pMeasurer->_fPseudoLetterEnabled
        && !porOut->IsSyntheticRun()
        && _pMarkup->HasCFState() // May be null in OOM
       )
    {
        BOOL fH, fV;
        CRect rcDimensions;
        CComputeFormatState * pcfState = _pMarkup->GetCFState();

        pNodeRun = pcfState->GetBlockNodeLetter();
        AssertSz(porOut == por, "Por's can only change if you add synthetics");
        if (   !_pflw._fStartedPseudoMBP
            && porOut->IsNormalRun()
            && porOut->_lsCharProps.idObj == LSOBJID_TEXT
            && pNodeRun->GetInlineMBPForPseudo(_pci, GIMBPC_ALL, &rcDimensions, &fH, &fV)
           )
        {
            _pflw._fStartedPseudoMBP = TRUE;
            lserr = AppendSynth(por, SYNTHTYPE_MBPOPEN, &porOut);
            if (lserr == lserrNone)
            {
                porOut->_mbpTop = _mbpTopCurrent;
                porOut->_mbpBottom = _mbpBottomCurrent;
                porOut->_xWidth = rcDimensions.left;
                _mbpTopCurrent += rcDimensions.top;
                _mbpBottomCurrent += rcDimensions.bottom;
                por->_mbpTop = _mbpTopCurrent;
                por->_mbpBottom = _mbpBottomCurrent;
                porOut->_fIsPseudoMBP = TRUE;
            }

            const CFancyFormat *pFF = pNodeRun->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
            if (   HasBorders(pFF, pNodeRun->GetCharFormat(), TRUE)
                || pFF->HasBackgrounds(TRUE))
            {
                _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINE_BG_OR_BORDER);
            }

            goto Done;
        }
        
        Assert(porOut->_lscch);
        Assert(porOut->Cp() < _pMeasurer->_cpStopFirstLetter);
        Assert(_pMeasurer->_cpStopFirstLetter >= 0);
        
        LONG cpLast = porOut->Cp() + porOut->_lscch;
        if (_pMeasurer->_cpStopFirstLetter <= cpLast)
        {
            porOut->_lscch = _pMeasurer->_cpStopFirstLetter - porOut->Cp();
            Assert(porOut->_lscch > 0);
            
            _lineFlags.AddLineFlag(porOut->Cp(), FLAG_HAS_NOBLAST);
            _pflw._fDoPostFirstLetterWork = TRUE;
            _pflw._fChoppedFirstLetter = TRUE;
            if (porOut->_pFF->_fHasAlignedFL)
            {
                _pflw._fTerminateLine = TRUE;
                _li._fForceNewLine = FALSE;
                _li._fHasFloatedFL = TRUE;
            }
        }
    }
    
    *pporOut = porOut;
    return lserr;
}


BOOL
IsPreLikeTag(ELEMENT_TAG eTag)
{
    return eTag == ETAG_PRE || eTag == ETAG_XMP || eTag == ETAG_PLAINTEXT || eTag == ETAG_LISTING;
}


BOOL
IsPreLikeNode(CTreeNode * pNode)
{
    return IsPreLikeTag(pNode->Tag()) || pNode->GetParaFormat()->_fPreInner;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForSpecialObjectBoundaries
//
//  Synopsis:   This function checks to see whether special objects should
//              be opened or closed based on the CF properties
//
//  Returns:    The one run to submit to line services via the pporOut
//              parameter.  Will only change this if necessary, and will
//              return TRUE if that parameter changed.
//
//-----------------------------------------------------------------------------

BOOL  WINAPI
CLineServices::CheckForSpecialObjectBoundaries(
    COneRun *por,
    COneRun **pporOut)
{
    BOOL fRet = FALSE;
    LSERR lserr;
    const CCharFormat *pCF = por->GetCF();
    Assert(pCF);

    if(pCF->_fIsRuby && !_fIsRuby)
    {
        Assert(!_fIsRubyText);

        // Open up a new ruby here (we only enter here in the open ruby case,
        // the ruby object is closed when we see an /RT)
        _fIsRuby = TRUE;
#ifdef RUBY_OVERHANG
        // We set this flag here so that LS will try to do modify the width of
        // run, which will trigger a call to FetchRubyWidthAdjust
        por->_lsCharProps.fModWidthOnRun = TRUE;
#endif
        _yMaxHeightForRubyBase = 0;
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_RUBY);
        lserr = AppendILSControlChar(por, SYNTHTYPE_RUBYMAIN, pporOut);
        Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
        fRet = TRUE;
    }
    else if(pCF->_fIsRubyText != _fIsRubyText)
    {
        Assert(_fIsRuby);

        // if _fIsRubyText is true, that means we have now arrived at text that
        // is no longer Ruby Text.  So, we should close the Ruby object by passing
        // ENDRUBYTEXT to Line Services
        if(_fIsRubyText)
        {
           _fIsRubyText = FALSE;
           _fIsRuby = FALSE;
           lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYTEXT, pporOut);
        }
        // if _fIsRubyText is false, that means that we are now entering text that
        // is Ruby text.  So, we must tell Line Services that we are no longer
        // giving it main text.
        else
        {
            _fIsRubyText = TRUE;
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDRUBYMAIN, pporOut);
        }
        Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
        fRet = TRUE;
    }
    else if (_uLayoutGridModeInner != pCF->_uLayoutGridModeInner)
    {
        LONG cLayoutGridObj = 0;
        if (!pCF->HasCharGrid(TRUE))
        {
            // Character grid layout was turned off. Check if we are entering 
            // nested element.

            // Count nested elements with turned off character grid layout
            // within block element scope.
            CTreeNode * pNodeCurrent = por->_ptp->GetBranch();
            Assert(pNodeCurrent->_iFF != -1);
            while (!pNodeCurrent->_fBlockNess)
            {
                if (    !pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE)
                    &&  pNodeCurrent->Parent()->GetCharFormat()->HasCharGrid(TRUE))
                {
                    ++cLayoutGridObj;
                }
                pNodeCurrent = pNodeCurrent->Parent();
                Assert(pNodeCurrent->_iFF != -1);
            }
            Assert(cLayoutGridObj >= _cLayoutGridObj);

            if (cLayoutGridObj != _cLayoutGridObj)
            {
                // Entering nested element.

                COneRun * porTemp = NULL;
                *pporOut = NULL;
                if (_cLayoutGridObjArtificial > 0)
                {
                    // Need to tell LS that we are closing artificially opened
                    // layout grid object.
                    --_cLayoutGridObjArtificial;
                    Assert(_cLayoutGridObjArtificial == 0);
                    lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                    Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                }

                // Need to tell LS that we entering nested element with
                // turned off character grid layout.
                ++_cLayoutGridObj;
                lserr = AppendILSControlChar(por, SYNTHTYPE_LAYOUTGRID, (*pporOut) ? &porTemp : pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (porTemp ? porTemp : *pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }
        }
        else if (   _cLayoutGridObj > 0
                &&  !(_uLayoutGridModeInner & styleLayoutGridModeChar)
                &&  pCF->HasCharGrid(TRUE))
        {
            // Character grid layout was turned on. Check if we are exiting 
            // nested element.

            // Count nested elements with turned on character grid layout
            // within block element scope.
            CTreeNode * pNodeCurrent = por->_ptp->GetBranch();
            Assert(pNodeCurrent->_iFF != -1);
            while (!pNodeCurrent->_fBlockNess)
            {
                if (    pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE)
                    &&  !pNodeCurrent->Parent()->GetCharFormat()->HasCharGrid(TRUE))
                {
                    ++cLayoutGridObj;
                }
                pNodeCurrent = pNodeCurrent->Parent();
                Assert(pNodeCurrent->_iFF != -1);
            }
            if (pNodeCurrent->GetCharFormat()->HasCharGrid(TRUE))
            {
                ++cLayoutGridObj;
            }

            if (cLayoutGridObj == _cLayoutGridObj)
            {
                // Exiting nested element.

                COneRun * porTemp = NULL;
                *pporOut = NULL;
                if (_cLayoutGridObjArtificial > 0)
                {
                    // Need to tell LS that we are closing artificially opened
                    // layout grid object.
                    --_cLayoutGridObjArtificial;
                    Assert(_cLayoutGridObjArtificial == 0);
                    lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                    Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                }

                // Need to tell LS that we exiting nested element with
                // turned off character grid layout.
                --_cLayoutGridObj;
                lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, (*pporOut) ? &porTemp : pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (porTemp ? porTemp : *pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }
        }
        // Update special object's flags
        _uLayoutGridModeInner = pCF->_uLayoutGridModeInner;
    }
    
    //
    // So far we didn't add a synthetic run. Check if we need to add NOBR.
    //
    if (!fRet)
    {
        BOOL fNoBreak = pCF->HasNoBreak(por->_fInnerCF);
        if (fNoBreak != !!_fNoBreakForMeasurer)
        {
            Assert(!IsFrozen());

            //
            // phrase elements inside PRE's which have layout will not have the HasPre bit turned
            // on and hence we will still start a NOBR object for them. The problem then is that
            // we need to terminate the line for '\r'. To do this we will have to scan the text.
            // To minimize the scanning we find out if we are really in such a situation.
            //
#if DBG==1
            {
                CTreeNode *pNodeOne = por->Branch();
                CTreeNode *pNodeTwo = _pMarkup->SearchBranchForPreLikeNode(por->Branch());
                BOOL fp1Overlapped = pNodeOne && pNodeOne->Element()->IsOverlapped();
                BOOL fp2Overlapped = pNodeTwo && pNodeTwo->Element()->IsOverlapped();
                Assert(   fp1Overlapped 
                       || fp2Overlapped
                       || (!!por->GetPF()->_fHasPreLikeParent == !!pNodeTwo));
            }
#endif
            
            if (por->GetPF()->_fHasPreLikeParent)
            {
                _fScanForCR = TRUE;
                goto Cleanup;
            }

            if (!(por->_fCharsForNestedLayout && IsOwnLineSite(por)))
            {
                // Begin or end NOBR block.
                lserr = AppendILSControlChar(por,
                                             (fNoBreak ? SYNTHTYPE_NOBR : SYNTHTYPE_ENDNOBR),
                                             pporOut);
                Assert(lserr != lserrNone || IsFrozen() || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                fRet = TRUE;
            }
        }
    }

    // Update special object's flags
    _uLayoutGridMode = pCF->_uLayoutGridMode;

Cleanup:

    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetAutoNumberInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetAutoNumberInfo(
    LSKALIGN* plskalAnm,    // OUT
    PLSCHP plsChpAnm,       // OUT
    PLSRUN* pplsrunAnm,     // OUT                                  
    WCHAR* pwchAdd,         // OUT
    PLSCHP plsChpWch,       // OUT                                 
    PLSRUN* pplsrunWch,     // OUT                                  
    BOOL* pfWord95Model,    // OUT
    long* pduaSpaceAnm,     // OUT
    long* pduaWidthAnm)     // OUT
{
    LSTRACE(GetAutoNumberInfo);
    LSNOTIMPL(GetAutoNumberInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetNumericSeparators (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetNumericSeparators(
    PLSRUN plsrun,          // IN
    WCHAR* pwchDecimal,     // OUT
    WCHAR* pwchThousands)   // OUT
{
    LSTRACE(GetNumericSeparators);

    // NOTE: (cthrash) Should set based on locale.
    // NOTE: (dmitryt) Maybe (a matter of spec) on a LANG attribute also (one paragraph may be in 
    //                  Russian (decimal=','), other in English (decimal=".")

    *pwchDecimal = L'.';
    *pwchThousands = L',';

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForDigit (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckForDigit(
    PLSRUN plsrun,      // IN
    WCHAR wch,          // IN
    BOOL* pfIsDigit)    // OUT
{
    LSTRACE(CheckForDigit);

    // NOTE: (mikejoch) IsCharDigit() doesn't check for international numbers.

    *pfIsDigit = IsCharDigit(wch);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchPap (member, LS callback)
//
//  Synopsis:   Callback to fetch paragraph properties for the current line.
//
//  Returns:    lserrNone
//              lserrOutOutMemory
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FetchPap(
    LSCP   lscp,        // IN
    PLSPAP pap)         // OUT
{
    LSTRACE(FetchPap);
    LSERR      lserr = lserrNone;
    const      CParaFormat *pPF;
    CTreePos  *ptp;
    CTreeNode *pNode;
    LONG       cp;
    BOOL       fInnerPF;
    CComplexRun *pcr = NULL;
    CComplexRun crTemp;
    CElement  *pElementFL = _pFlowLayout->ElementContent();

    Assert(lscp <= _treeInfo._lscpFrontier);

    if (lscp < _treeInfo._lscpFrontier)
    {
        COneRun *por = FindOneRun(lscp);
        Assert(por);
        if(!por)
            goto Cleanup;
        ptp = por->_ptp;
        pPF = por->_pPF;
        fInnerPF = por->_fInnerPF;
        cp = por->Cp();
        pcr = por->GetComplexRun();
    }
    else
    {
        //
        // The problem is that we are at the end of the list
        // and hence we cannot find the interesting one-run. In this
        // case we have to use the frontier information. However,
        // the frontier information maybe exhausted, so we need to
        // refresh it by calling AdvanceTreePos() here.
        //
        if (!_treeInfo.GetCchRemainingInTreePos() && !_treeInfo._fHasNestedElement)
        {
            if (!_treeInfo.AdvanceTreePos(LC_TO_FC(_pci->GetLayoutContext())))
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
        }
        ptp = _treeInfo._ptpFrontier;
        pPF = _treeInfo._pPF; // should we use CLineServices::_pPFFirst here???
        fInnerPF = _treeInfo._fInnerPF;
        cp  = _treeInfo._cpFrontier;

        // if might be on a reverse object to begin with. see if we are a
        // complex script
        if (ptp->IsText() && ptp->IsDataPos())
        {
            // if we are a complex script, we just put an unitialized CComplexRun
            // into pcr. We will only be checking for pcr != NULL
            if (IsComplexScriptSid(ptp->Sid()))
                pcr = &crTemp;
        }

    }

    Assert(ptp);
    Assert(pPF);

    //
    // Set up paragraph properties
    //
    PAPFromPF (pap, pPF, fInnerPF, pcr);

    pap->cpFirst = cp;

    // TODO (dmitryt, track bug 112281): SLOWBRANCH: GetBranch is **way** too slow to be used here.
    pNode = ptp->GetBranch();
    if (pNode->Element() == pElementFL)
        pap->cpFirstContent = _treeInfo._cpLayoutFirst;
    else
    {
        CTreeNode *pNodeBlock = _treeInfo._pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        if (pNodeBlock)
        {
            CElement *pElementPara = pNodeBlock->Element();
            pap->cpFirstContent = (pElementPara == pElementFL) ?
                                  _treeInfo._cpLayoutFirst :
                                  pElementPara->GetFirstCp();
        }
        else
            pap->cpFirstContent = _treeInfo._cpLayoutFirst;
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchTabs (member, LS callback)
//
//  Synopsis:   Callback to return tab positions for the current line.
//
//              LineServices calls the callback when it encounters a tab in
//              the line, but does not pass the plsrun.  The cp is supposed to
//              be used to locate the paragraph.
//
//              Instead of allocating a buffer for the return value, we return
//              a table that resides on the CLineServices object.  The tab
//              values are in twips.
//
//  Returns:
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FetchTabs(
    LSCP lscp,                      // IN
    PLSTABS plstabs,                // OUT
    BOOL* pfHangingTab,             // OUT
    long* pduaHangingTab,           // OUT
    WCHAR* pwchHangingTabLeader )   // OUT
{
    LSTRACE(FetchTabs);

    LONG cTab = _pPFFirst->GetTabCount(_fInnerPFFirst);

    // This tab might end up on the current line, so we can't blast.

    _fSpecialNoBlast = TRUE;

    // Note: lDefaultTab is a constant defined in textedit.h

    plstabs->duaIncrementalTab = lDefaultTab;

    // NOTE (dmitryt) hanging tabs are not implemented for now..

    *pfHangingTab = FALSE;
    *pduaHangingTab = 0;
    *pwchHangingTabLeader = 0;

    AssertSz(cTab >= 0 && cTab <= MAX_TAB_STOPS, "illegal tab count");

    if (!_pPFFirst->HasTabStops(_fInnerPFFirst) && cTab < 2)
    {
        if (cTab == 1)
        {
            plstabs->duaIncrementalTab = _pPFFirst->GetTabPos(_pPFFirst->_rgxTabs[0]);
        }

        plstabs->iTabUserDefMac = 0;
        plstabs->pTab = NULL;
    }
    else
    {
        LSTBD * plstbd = _alstbd + cTab - 1;

        while (cTab)
        {
            long uaPos = 0;
            long lAlign = 0;
            long lLeader = 0;

            if (S_OK != _pPFFirst->GetTab( --cTab, &uaPos, &lAlign, &lLeader ) )
            {
                return lserrOutOfMemory;
            }

            Assert( lAlign >= 0 && lAlign < tomAlignBar &&
                    lLeader >= 0 && lLeader < tomLines );

            // NB (cthrash) To ensure that the LSKTAB cast is safe, we
            // verify that that define's haven't changed values in
            // CLineServices::InitTimeSanityCheck().

            plstbd->lskt = LSKTAB(lAlign);
            plstbd->ua = uaPos;
            plstbd->wchTabLeader = s_achTabLeader[lLeader];
            plstbd--;

        }

        plstabs->iTabUserDefMac = cTab;
        plstabs->pTab = _alstbd;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBreakThroughTab (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetBreakThroughTab(
    long uaRightMargin,         // IN
    long uaTabPos,              // IN
    long* puaRightMarginNew)    // OUT
{
    LSTRACE(GetBreakThroughTab);
    LSNOTIMPL(GetBreakThroughTab);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckParaBoundaries (member, LS callback)
//
//  Synopsis:   Callback to determine whether two cp's reside in different
//              paragraphs (block elements in HTML terms).
//
//  Returns:    lserrNone
//              *pfChanged - TRUE if cp's are in different block elements.
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckParaBoundaries(
    LSCP lscpOld,       // IN
    LSCP lscpNew,       // IN
    BOOL* pfChanged)    // OUT
{
    LSTRACE(CheckParaBoundaries);
    *pfChanged = FALSE;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunCharWidths (member, LS callback)
//
//  Synopsis:   Callback to return character widths of text in the current run,
//              represented by plsrun.
//
//  Returns:    lserrNone
//              rgDu - array of character widths
//              pduDu - sum of widths in rgDu, upto *plimDu characters
//              plimDu - character count in rgDu
//
//-----------------------------------------------------------------------------

#if DBG != 1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif // DBG != 1

LSERR WINAPI
CLineServices::GetRunCharWidths(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    LPCWSTR pwchRun,            // IN
    DWORD cwchRun,              // IN
    long du,                    // IN
    LSTFLOW kTFlow,             // IN
    int* rgDu,                  // OUT
    long* pduDu,                // OUT
    long* plimDu)               // OUT
{
    LSTRACE(GetRunCharWidths);

    LSERR lserr = lserrNone;
    pwchRun = plsrun->_fMakeItASpace ? _T(" ") : pwchRun;
    const WCHAR * pch = pwchRun;
    int * pdu = rgDu;
    int * pduEnd = rgDu + cwchRun;
    long duCumulative = 0;
    LONG cpCurr = plsrun->Cp();
    const CCharFormat *pCF = plsrun->GetCF();
    CCcs ccs, ccsAlt;
    XHDC hdc;
    const CBaseCcs *pBaseCcs;
    WHEN_DBG(LONG xLetterSpacingRemovedDbg = 0);

    Assert(cwchRun);

    WHEN_DBG(pBaseCcs = NULL;)
    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    hdc = ccs.GetHDC();
    pBaseCcs = ccs.GetBaseCcs();
    
    if (   pBaseCcs->_fHasInterestingData 
        && !pBaseCcs->_fTTFont
        && _pci->_hdc.HasComplexTransform())
    {
        ccsAlt.SetForceTTFont(TRUE);
        if (!GetCcs(&ccsAlt, plsrun, _pci->_hdc, _pci))
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
        pBaseCcs = ccsAlt.GetBaseCcs();
    }

    //
    // CSS
    //
    Assert(IsAdornment() || !plsrun->_fCharsForNestedElement);

    //
    // Add up the widths
    //
    while (pdu < pduEnd)
    {
        MeasureCharacter(*pch++, cpCurr, rgDu, hdc, pBaseCcs, pdu);
        duCumulative += *pdu++;
        if (duCumulative > du)
            break;
    }
    
    if (plsrun->IsSpecialCharRun())
    {
        *rgDu = plsrun->_xWidth;
        *pduDu = plsrun->_xWidth;
        *plimDu = pdu - rgDu;
    }
    else if (   pCF->_wSpecialObjectFlags() != 0
             && (   HasSomeSpacing(pCF)
                 || pCF->HasCharGrid(plsrun->_fInnerCF)
                )
            )
    {
        lserr = AdjustGlyphWidths( &ccs, GetLetterSpacing(pCF), GetWordSpacing(pCF),
                                   plsrun, pwchRun, cwchRun, 
                                   du, rgDu, pduDu, plimDu, NULL 
#if DBG==1
                                   , &xLetterSpacingRemovedDbg
#endif
                                  );
    }
    else
    {
        *pduDu = duCumulative;
        *plimDu = pdu - rgDu;
        if (   plsrun->_xWidth == 0 
            || plsrun->_pchBase == pwchRun
           )
        {
            plsrun->_xWidth = duCumulative;
            if (   DWORD(plsrun->_lscch) != cwchRun
                && *plsrun->_pchBase == WCH_HYPHEN
               )
            {
                _fSpecialNoBlast = TRUE;
            }
        }
        else
        {
            _fSpecialNoBlast = TRUE;
        }
    }
    
#if DBG == 1
    if (lserr == lserrNone && !GetWordSpacing(pCF))
    {
        // If we are laying out a character grid, skip all the debug verification
        if (pCF->HasCharGrid(plsrun->_fInnerCF))
            goto Cleanup;

        if (    plsrun->IsSyntheticRun()
            && *plsrun->_pchBase == WCH_NODE
           )
            goto Cleanup;
        
        //
        // In debug mode, confirm that all the fast tweaks give the same
        // answer as the really old slow way.
        //

        int* rgDuDbg= new int[ cwchRun ];  // no meters in debug mode.
        long limDuDbg;  // i.e. *plimDu
        DWORD cchDbg = cwchRun;
        const WCHAR * pchDbg = pwchRun;
        int * pduDbg = rgDuDbg;
        long duCumulativeDbg = 0;
        LONG cpCurrDbg = plsrun->Cp();
        int xLetterSpacing = GetLetterSpacing(pCF);

        //index of a last character that has width>0 and is not Combining (dmitryt)
        int cchLastBaseGlyph = -1;   

        Assert(pBaseCcs);
        if (rgDuDbg != NULL)
        {
            while (cchDbg--)
            {
                long duCharDbg = 0;
                TCHAR chDbg = *pchDbg++;

                ((CBaseCcs *)pBaseCcs)->Include(hdc, chDbg, duCharDbg);

                if (duCharDbg)
                {
                    duCharDbg += xLetterSpacing;
                    if(!IsCombiningMark(chDbg))
                        cchLastBaseGlyph = cwchRun - cchDbg - 1;
                }    
                *pduDbg++ = duCharDbg;
                duCumulativeDbg += duCharDbg;

                if (duCumulativeDbg > du)
                  break;

                cpCurrDbg++;
            }

            //dmitryt: we need to adjust the last base (combining diacritic and width>0) 
            //glyph because it doesn't have letter spacing added (last 'real' character
            //in a line - nothing to space from)
            if (cchLastBaseGlyph != -1)
            {
                rgDuDbg[cchLastBaseGlyph] -= xLetterSpacingRemovedDbg;
                duCumulativeDbg -= xLetterSpacingRemovedDbg;
            }

            // *pduDuDbg = duCumulativeDbg;
            limDuDbg = pchDbg - pwchRun;

#ifndef ND_ASSERT // May 17, 1999.  Repro: Switch to Draftview in Netdocs (AlexPf)
            // Calculation done.  Check results.
            Assert( duCumulativeDbg == *pduDu );  // total distance measured.
            Assert( limDuDbg == *plimDu );        // characters measured.
            for(int i=0; i< limDuDbg; i++)
            {
                Assert( rgDu[i] == rgDuDbg[i] );
            }
#endif // ND_ASSERT
          delete rgDuDbg;
        }
    }
#endif  // DBG == 1

Cleanup:
#if DBG==1
    if (pBaseCcs)
    {
        CDisplay *pdp = (CDisplay*)_pMeasurer->_pdp;
        if (pdp->_fBuildFontList)
        {
            pdp->_cstrFonts.Append(fc().GetFaceNameFromAtom(pBaseCcs->_latmLFFaceName));
            pdp->_cstrFonts.Append(_T(";"));
        }
    }
#endif
    return lserr;
}

#if DBG != 1
#pragma optimize("",on)
#endif // DBG != 1

LSERR
CLineServices::AdjustGlyphWidths(
    CCcs *pccs,
    LONG xLetterSpacing,
    LONG xWordSpacing,
    PLSRUN plsrun,
    LPCWSTR pwch,
    DWORD cwch,
    LONG du,            // not used during glyph positioning pass
    int *rgDu,
    long *pduDu,
    long *plimDu,
    PGOFFSET rgGoffset
#if DBG==1
    , LONG *pxLetterSpacingRemovedDbg
#endif
)
{
    LONG lserr = lserrNone;
    LONG duCumulative = 0;
    LONG cpCurr = plsrun->Cp();
    int *pdu = rgDu;
    int *pduLastNonZero = pdu;
    int *pduEnd = rgDu + cwch;
    const CCharFormat *pCF = plsrun->GetCF();
    const CBaseCcs *pBaseCcs = pccs->GetBaseCcs();
    XHDC hdc = pccs->GetHDC();
    BOOL fGlyphPositionPass = !!rgGoffset;
    BOOL fLooseGrid = TRUE;
    BOOL fIsSpace;

    // Add line flags only during non glyph positioning pass.
    // During glyph positioning those flags are already set.
    if (!fGlyphPositionPass)
    {
        _lineFlags.AddLineFlagForce(cpCurr, FLAG_HAS_NOBLAST);
#if DBG==1
        if (xLetterSpacing < 0 || xWordSpacing < 0)
            _fHasNegLetterSpacing = TRUE;
#endif
    }

    //
    // We must be careful to deal with negative letter spacing,
    // since that will cause us to have to actually get some character
    // widths since the line length will be extended.  If the
    // letterspacing is positive, then we know all the letters we're
    // gonna use have already been measured.
    //

    // Apply layout grid widths
    if (pCF->HasCharGrid(plsrun->_fInnerCF))
    {
        long lGridSize = GetCharGridSize();
        styleLayoutGridType lgt = plsrun->GetPF()->GetLayoutGridType(plsrun->_fInnerCF);
        fLooseGrid = !(lgt == styleLayoutGridTypeStrict || lgt == styleLayoutGridTypeFixed);
        BOOL fOneCharPerGridCell = fLooseGrid ? TRUE : plsrun->IsOneCharPerGridCell();
        
        for (pdu = rgDu; pdu < pduEnd;)
        {
            if (   (   xLetterSpacing < 0
                    || xWordSpacing < 0
                   )
                && !fGlyphPositionPass
               )
            {
                MeasureCharacter(pwch[pdu - rgDu], cpCurr, rgDu, hdc, pBaseCcs, pdu);
            }
            
            fIsSpace = isspace(pwch[pdu - rgDu]);
            if (fIsSpace && !fGlyphPositionPass)
            {
                *pdu += xWordSpacing;
            }
            
            if (*pdu)
            {
                pduLastNonZero = pdu;

                *pdu += xLetterSpacing;

                if (fLooseGrid)
                {
                    *pdu += LooseTypeWidthIncrement(pwch[pdu - rgDu], 
                                                    (plsrun->_brkopt == fCscWide), lGridSize);
                }
                else if (fOneCharPerGridCell)
                {
                    *pdu = GetClosestGridMultiple(lGridSize, *pdu);
                }
            }
            else if (fGlyphPositionPass && !fIsSpace)
            {
                if (fLooseGrid)
                {
                    rgGoffset[pdu - rgDu].du -= xLetterSpacing;
                    rgGoffset[pdu - rgDu].du -= LooseTypeWidthIncrement(
                                                    pwch[pduLastNonZero - rgDu], 
                                                    plsrun->_brkopt == fCscWide, lGridSize);
                }
            }

            duCumulative += *pdu++;
            if (duCumulative > du && !fGlyphPositionPass)
                break;
        }
    }
    else
    {
        for (pdu = rgDu; pdu < pduEnd;)
        {
            if (   (   xLetterSpacing < 0
                    || xWordSpacing < 0
                   )
                && !fGlyphPositionPass
               )
            {
                MeasureCharacter(pwch[pdu - rgDu], cpCurr, rgDu, hdc, pBaseCcs, pdu);
            }

            fIsSpace = isspace(pwch[pdu - rgDu]);
            if (fIsSpace && !fGlyphPositionPass)
            {
                *pdu += xWordSpacing;
            }
            
            if (*pdu)
            {
                pduLastNonZero = pdu;
                *pdu += xLetterSpacing;
            }

            // You might think that the !fIsSpace is useless since *pdu for
            // a space will always be non-zero -- NOT true, since xWordSpacing
            // could be negative and reduce *pdu down to zero.
            else if (fGlyphPositionPass && !fIsSpace)
            {
                rgGoffset[pdu - rgDu].du -= xLetterSpacing;
            }

            duCumulative += *pdu++;
            if (duCumulative > du && !fGlyphPositionPass)
                break;
        }
    }

    if (xLetterSpacing && pdu >= pduEnd && !_pNodeLi && fLooseGrid)
    {
        LPCWSTR  lpcwstrJunk;
        DWORD    dwJunk;
        BOOL     fJunk;
        LSCHP    lschpJunk;
        COneRun *por;
        int      xLetterSpacingNextRun = 0;

        lserr = FetchRun(plsrun->_lscpBase + plsrun->_lscch, &lpcwstrJunk, &dwJunk, &fJunk, &lschpJunk, &por);
        if (   lserr == lserrNone
            && por->_ptp != _treeInfo._ptpLayoutLast
           )
        {
            xLetterSpacingNextRun = GetLetterSpacing(por->GetCF());
        }
        
        if (xLetterSpacing != xLetterSpacingNextRun)
        {
            *pduLastNonZero -= xLetterSpacing;
            duCumulative -= xLetterSpacing;
            if (fGlyphPositionPass)
            {
                int *pduZero = pduLastNonZero + 1;
                while (pduZero < pduEnd)
                {
                    rgGoffset[pduZero - rgDu].du += xLetterSpacing;
                    pduZero++;
                }
            }
#if DBG==1
        if (pxLetterSpacingRemovedDbg)
            *pxLetterSpacingRemovedDbg = xLetterSpacing;
#endif
        }
    }

    if (pduDu)
        *pduDu = duCumulative;
    if (plimDu)
        *plimDu = pdu - rgDu;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetLineOrCharGridSize()
//
//  Synopsis:   This function finds out what the height or width of a grid cell 
//              is in pixels, making conversions if necessary.  If this value has 
//              already been calculated, the calculated value is immediately returned
//
//  Returns:    long value of the width of a grid cell in pixels
//
//-----------------------------------------------------------------------------

long WINAPI
CLineServices::GetLineOrCharGridSize(BOOL fGetCharGridSize)
{
    const CUnitValue *pcuv = NULL;
    CUnitValue::DIRECTION dir;
    long * plGridSize = fGetCharGridSize 
        ? (_fInnerPFFirst ? &_lCharGridSizeInner : &_lCharGridSize) 
        : (_fInnerPFFirst ? &_lLineGridSizeInner : &_lLineGridSize);
    
    // If we already have a cached value, return that, or if we haven't set
    // set up the ccs yet return zero
    if(*plGridSize != 0 || !_pPFFirst)
        goto Cleanup;

#if defined(_M_ALPHA64)
    // NOTE: (grzegorz) Do not change second 'if' to 'else'
    // This causes internal compiler error on AXP64.
    if (fGetCharGridSize)
        pcuv = &(_pPFFirst->GetCharGridSize(_fInnerPFFirst));
    if (!fGetCharGridSize)
        pcuv = &(_pPFFirst->GetLineGridSize(_fInnerPFFirst));
#else
    pcuv = fGetCharGridSize ? &(_pPFFirst->GetCharGridSize(_fInnerPFFirst)) : &(_pPFFirst->GetLineGridSize(_fInnerPFFirst));
#endif

    // The uv should have some value, otherwise we shouldn't even be
    // here making calculations for a non-existent grid.
    switch(pcuv->GetUnitType())
    {
    case CUnitValue::UNIT_NULLVALUE:
        break;

    case CUnitValue::UNIT_ENUM:
        // need to handle "auto" here
        if(pcuv->GetUnitValue() == styleLayoutGridCharAuto && _ccsCache.GetBaseCcs()) 
            *plGridSize = fGetCharGridSize ? _ccsCache.GetBaseCcs()->_xMaxCharWidth :
                          _ccsCache.GetBaseCcs()->_yHeight;
        else
            *plGridSize = 0;
        break;

    case CUnitValue::UNIT_PERCENT:
        if (_fMinMaxPass)
            *plGridSize = 1;
        else
        {
            if (fGetCharGridSize)
                *plGridSize = _xWrappingWidth;
            else
            {
                *plGridSize = _pci->_sizeParent.cy;
                if (*plGridSize == 0 && _pFlowLayout->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow())
                    *plGridSize = _pci->_sizeParentForVert.cy;
            }
            *plGridSize = *plGridSize * pcuv->GetUnitValue() / 10000;
        }
        break;

    default:
        dir = fGetCharGridSize ? CUnitValue::DIRECTION_CX : CUnitValue::DIRECTION_CY;
        *plGridSize = pcuv->GetPixelValue(_pci, dir, 
            fGetCharGridSize ? _xWrappingWidth : _pci->_sizeParent.cy, _pPFFirst->_lFontHeightTwips);
        break;
    }

    if (pcuv->IsPercent() && _pFlowLayout && !fGetCharGridSize)
            _pFlowLayout->SetVertPercentAttrInfo(TRUE);

Cleanup:
    return *plGridSize;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetClosestGridMultiple
//
//  Synopsis:   This function just calculates the width of an object in lGridSize
//              multiples.  For example, if lGridSize is 12 and lObjSize is 16,
//              this function would return 24.  If lObjSize is 0, this function
//              will return 0.
//              
//  Returns:    long value of the width in pixels
//
//-----------------------------------------------------------------------------

long WINAPI
CLineServices::GetClosestGridMultiple(long lGridSize, long lObjSize)
{
    long lReturnWidth = lObjSize;
    long lRemainder;
    if (lObjSize == 0 || lGridSize == 0)
        goto Cleanup;

    lRemainder = lObjSize % lGridSize;
    lReturnWidth = lObjSize + lGridSize - (lRemainder ? lRemainder : lGridSize);

Cleanup:
    return lReturnWidth;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckRunKernability (member, LS callback)
//
//  Synopsis:   Callback to test whether current runs should be kerned.
//
//              We do not support kerning at this time.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CheckRunKernability(
    PLSRUN plsrunLeft,  // IN
    PLSRUN plsrunRight, // IN
    BOOL* pfKernable)   // OUT
{
    LSTRACE(CheckRunKernability);

    *pfKernable = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunCharKerning (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunCharKerning(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    LPCWSTR pwchRun,            // IN
    DWORD cwchRun,              // IN
    LSTFLOW kTFlow,             // IN
    int* rgDu)                  // OUT
{
    LSTRACE(GetRunCharKerning);

    DWORD iwch = cwchRun;
    int *pDu = rgDu;

    while (iwch--)
    {
        *pDu++ = 0;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunTextMetrics (member, LS callback)
//
//  Synopsis:   Callback to return text metrics of the current run
//
//  Returns:    lserrNone
//              plsTxMet - LineServices textmetric structure (lstxm.h)
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunTextMetrics(
    PLSRUN   plsrun,            // IN
    LSDEVICE lsDeviceID,        // IN
    LSTFLOW  kTFlow,            // IN
    PLSTXM   plsTxMet)          // OUT
{
    LSTRACE(GetRunTextMetrics);
    const CCharFormat * pCF;
    CCcs ccs, ccsAlt;
    const CBaseCcs *pBaseCcs;
    LONG lLineHeight;
    LSERR lserr = lserrNone;
    
    Assert(plsrun);
    
    if (plsrun->_fNoTextMetrics)
    {
        ZeroMemory( plsTxMet, sizeof(LSTXM) );
        goto Cleanup;
    }

    pCF = plsrun->GetCF();
    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pBaseCcs = ccs.GetBaseCcs();

    if (pBaseCcs->_fHasInterestingData)
    {
        if (   !pBaseCcs->_fTTFont
            && _pci->_hdc.HasComplexTransform())
        {
            ccsAlt.SetForceTTFont(TRUE);
            if (!GetCcs(&ccsAlt, plsrun, _pci->_hdc, _pci))
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
            pBaseCcs = ccsAlt.GetBaseCcs();
        }

        if (pBaseCcs->_xOverhangAdjust || pBaseCcs->_bConvertMode == CM_SYMBOL)
        {
            _lineFlags.AddLineFlag(plsrun->Cp(), FLAG_HAS_NOBLAST);
        }
        _fHasOverhang |= ((plsrun->_xOverhang = pBaseCcs->_xOverhang) != 0);
        plsTxMet->fMonospaced = pBaseCcs->_fFixPitchFont ? TRUE : FALSE;
    }
    else
    {
        plsTxMet->fMonospaced = FALSE;
        Assert(pBaseCcs->_xOverhangAdjust == 0);
        Assert(pBaseCcs->_xOverhang == 0);
        Assert(!pBaseCcs->_fFixPitchFont);
    }

    // Keep track of the line heights specified in all the
    // runs so that we can adjust the line height at the end.
    // Note that we don't want to include break character NEVER
    // count towards height.
    lLineHeight = RememberLineHeight(plsrun->Cp(), pCF, pBaseCcs);

    if (_fHasSites)
    {
        Assert(_fMinMaxPass);
        plsTxMet->dvAscent = 1;
        plsTxMet->dvDescent = 0;
        plsTxMet->dvMultiLineHeight = 1;
    }
    else
    {
        long dvAscent, dvDescent;
        
        dvDescent = pBaseCcs->_yDescent;
        dvAscent  = pBaseCcs->_yHeight - dvDescent;

        plsTxMet->dvAscent = dvAscent;
        plsTxMet->dvDescent = dvDescent;
        plsTxMet->dvMultiLineHeight = lLineHeight;

        if (_pMeasurer->_fPseudoLetterEnabled)
        {
            KernHeightToGlyph(plsrun, &ccs, plsTxMet);
        }
    }

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunUnderlineInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//  Note(SujalP): Lineservices is a bit wierd. It will *always* want to try to
//  merge runs and that to based on its own algorithm. That algorith however is
//  not the one which IE40 implements. For underlining, IE 40 always has a
//  single underline when we have mixed font sizes. The problem however is that
//  this underline is too far away from the smaller pt text in the mixed size
//  line (however within the dimensions of the line). When we give this to LS,
//  it thinks that the UL is outside the rect of the small character and deems
//  it incorrect and does not call us for a callback. To overcome this problem
//  we tell LS that the UL is a 0 (baseline) but remember the distance ourselves
//  in the PLSRUN.
//
//  Also, since color of the underline can change from run-to-run, we
//  return different underline types to LS so as to prevent it from
//  merging such runs. This also helps avoid merging when we are drawing overlines.
//  Overlines are drawn at different heigths (unlinke underlines) from pt
//  size to pt size. (This probably is a bug -- but this is what IE40 does
//  so lets just go with that for now).
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunUnderlineInfo(
    PLSRUN plsrun,          // IN
    PCHEIGHTS heightsPres,  // IN
    LSTFLOW kTFlow,         // IN
    PLSULINFO plsUlInfo)    // OUT
{
    LSTRACE(GetRunUnderlineInfo);
    BYTE  bUnderlineType;
    CComplexRun *pCcr = plsrun->GetComplexRun();
    static BOOL s_fToggleSwitch = FALSE;

    if (pCcr && pCcr->_RenderStyleProp._fStyleUnderline)
    {
        if (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleDotted)
        {
            // NOTE: (cthrash) We need to switch between dotted and solid
            // underlining when the text goes from unconverted to converted.

            bUnderlineType = CFU_UNDERLINEDOTTED;
        }
        else if (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleThickDash)
        {
            bUnderlineType = CFU_UNDERLINETHICKDASH;
        }
        else
        {
            bUnderlineType = CFU_CF1UNDERLINE;
        }
    }
    else
    {
        bUnderlineType = CFU_CF1UNDERLINE;
    }

    plsUlInfo->kulbase = bUnderlineType | (s_fToggleSwitch ? CFU_SWITCHSTYLE : 0);
    s_fToggleSwitch = !s_fToggleSwitch;

    plsUlInfo->cNumberOfLines = 1;
    plsUlInfo->dvpUnderlineOriginOffset = 0;
    plsUlInfo->dvpFirstUnderlineOffset  = 0;
    plsUlInfo->dvpFirstUnderlineSize = 1;
    plsUlInfo->dvpGapBetweenLines = 0;
    plsUlInfo->dvpSecondUnderlineSize = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetRunStrikethroughInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetRunStrikethroughInfo(
    PLSRUN plsrun,          // IN
    PCHEIGHTS heightPres,   // IN
    LSTFLOW kTFlow,         // IN
    PLSSTINFO plsStInfo)    // OUT
{
    LSTRACE(GetRunStrikethroughInfo);
    LSNOTIMPL(GetRunStrikethroughInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBorderInfo (member, LS callback)
//
//  Synopsis:   Not implemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetBorderInfo(
    PLSRUN plsrun,      // IN
    LSTFLOW ktFlow,     // IN
    long* pdurBorder,   // OUT
    long* pdupBorder)   // OUT
{
    LSTRACE(GetBorderInfo);

    // This should only ever be called if we set the fBorder flag in lschp.
    LSNOTIMPL(GetBorderInfo);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ReleaseRun (member, LS callback)
//
//  Synopsis:   Callback to release plsrun object, which we don't do.  We have
//              a cache of COneRuns which we keep (and grow) for the lifetime
//              of the CLineServices object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ReleaseRun(
    PLSRUN plsrun)      // IN
{
    LSTRACE(ReleaseRun);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Hyphenate (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::Hyphenate(
    PCLSHYPH plsHyphLast,   // IN
    LSCP cpBeginWord,       // IN
    LSCP cpExceed,          // IN
    PLSHYPH plsHyph)        // OUT
{
    LSTRACE(Hyphenate);
    // FUTURE (mikejoch) Need to adjust cp values if kysr != kysrNil.

    plsHyph->kysr = kysrNil;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetHyphenInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetHyphenInfo(
    PLSRUN plsrun,      // IN
    DWORD* pkysr,       // OUT
    WCHAR* pwchKysr)    // OUT
{
    LSTRACE(GetHyphenInfo);

    *pkysr = kysrNil;
    *pwchKysr = WCH_NULL;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptUnderline (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptUnderline(
    PLSRUN plsrunFirst,         // IN
    LSCP cpLastFirst,           // IN
    PLSRUN plsrunSecond,        // IN
    LSCP cpStartSecond,         // IN
    BOOL* pfInterruptUnderline) // OUT
{
    LSTRACE(FInterruptUnderline);
    // FUTURE (mikejoch) Need to adjust cp values if we ever interrupt underlining.

    *pfInterruptUnderline = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptShade (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptShade(
    PLSRUN plsrunFirst,         // IN
    PLSRUN plsrunSecond,        // IN
    BOOL* pfInterruptShade)     // OUT
{
    LSTRACE(FInterruptShade);

    *pfInterruptShade = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptBorder (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptBorder(
    PLSRUN plsrunFirst,         // IN
    PLSRUN plsrunSecond,        // IN
    BOOL* pfInterruptBorder)    // OUT
{
    LSTRACE(FInterruptBorder);

    *pfInterruptBorder = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FInterruptShaping (member, LS callback)
//
//  Synopsis:   We compare CF between the runs to see if they are different
//              enough to cause an interrup in shaping between the runs
//
//  Arguments:  kTFlow              text direction and orientation
//              plsrunFirst         run pointer for the previous run
//              plsrunSecond        run pointer for the current run
//              pfInterruptShaping  TRUE - Interrupt shaping
//                                  FALSE - Don't interrupt shaping, merge runs
//
//  Returns:    LSERR               lserrNone if succesful
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FInterruptShaping(
    LSTFLOW kTFlow,                 // IN
    PLSRUN plsrunFirst,             // IN
    PLSRUN plsrunSecond,            // IN
    BOOL* pfInterruptShaping)       // OUT
{
    LSTRACE(FInterruptShaping);

    Assert(pfInterruptShaping != NULL &&
           plsrunFirst != NULL && plsrunSecond != NULL);

    CComplexRun * pcr1 = plsrunFirst->GetComplexRun();
    CComplexRun * pcr2 = plsrunSecond->GetComplexRun();

    Assert(pcr1 != NULL && pcr2 != NULL);

    *pfInterruptShaping = (pcr1->GetScript() != pcr2->GetScript());

    if (!*pfInterruptShaping)
    {
        const CCharFormat *pCF1 = plsrunFirst->GetCF();
        const CCharFormat *pCF2 = plsrunSecond->GetCF();

        Assert(pCF1 != NULL && pCF2 != NULL);

        // We want to break the shaping if the formats are not similar format
        *pfInterruptShaping = !pCF1->CompareForLikeFormat(pCF2);
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphs (member, LS callback)
//
//  Synopsis:   Returns an index of glyph ids for the run passed in
//
//  Arguments:  plsrun              pointer to the run
//              pwch                string of character codes
//              cwch                number of characters in pwch
//              kTFlow              text direction and orientation
//              rgGmap              map of glyph info parallel to pwch
//              prgGindex           array of output glyph indices
//              prgGprop            array of output glyph properties
//              pcgindex            number of glyph indices
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrInvalidRun if failure
//                                  lserrOutOfMemory if memory alloc fails
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphs(
    PLSRUN plsrun,          // IN
    LPCWSTR pwch,           // IN
    DWORD cwch,             // IN
    LSTFLOW kTFlow,         // IN
    PGMAP rgGmap,           // OUT
    PGINDEX* prgGindex,     // OUT
    PGPROP* prgGprop,       // OUT
    DWORD* pcgindex)        // OUT
{
    LSTRACE(GetGlyphs);

    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    CComplexRun * pcr;
    DWORD cMaxGly;
    XHDC hdc = _pci->_hdc;
    XHDC hdcShape(NULL,NULL);
    FONTIDX hfontOld = HFONT_INVALID;
    SCRIPT_CACHE *psc;
    WORD *pGlyphBuffer = NULL;
    WORD *pGlyph = NULL;
    SCRIPT_VISATTR *pVisAttr = NULL;
    CCcs ccs;
    CStr strTransformedText;
    BOOL fTriedFontLink = FALSE;

    pcr = plsrun->GetComplexRun();
    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    if (!GetCcs(&ccs, plsrun, hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);

    // In some fonts in some locales, NBSPs aren't rendered like spaces.
    // Under these circumstances, we need to convert NBSPs to spaces
    // before calling ScriptShape.
    // NOTE: Due to a bug in Bidi Win9x GDI, we can't detect that
    // old bidi fonts lack an NBSP (IE5 bug 68214). We hack around this by
    // simply always swapping the space character for the NBSP. Since this
    // only happens for glyphed runs, US perf is not impacted.
    if (_lineFlags.GetLineFlags(plsrun->Cp() + cwch) & FLAG_HAS_NBSP)
    {
        const WCHAR * pwchStop;
        WCHAR * pwch2;

        HRESULT hr = THR(strTransformedText.Set(pwch, cwch));
        if (hr == S_OK)
        {
            pwch = strTransformedText;

            pwch2 = (WCHAR *) pwch;
            pwchStop = pwch + cwch;

            while (pwch2 < pwchStop)
            {
                if (*pwch2 == WCH_NBSP)
                {
                    *pwch2 = L' ';
                }

                pwch2++;
            }
        }
    }

    // Inflate the number of max glyphs to generate
    // A good high end guess is the number of chars plus 6% or 10,
    // whichever is greater.
    cMaxGly = cwch + max(10, (int)cwch >> 4);

    Assert(cMaxGly > 0);
    pGlyphBuffer = (WORD *) NewPtr(cMaxGly * (sizeof(WORD) + sizeof(SCRIPT_VISATTR)));
    // Our memory alloc failed. No point in going on.
    if (pGlyphBuffer == NULL)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pGlyph = (WORD *) pGlyphBuffer;
    pVisAttr = (SCRIPT_VISATTR *) (pGlyphBuffer + cMaxGly);

    // Repeat the shaping process until it succeds, or fails for a reason different
    // from insufficient memory, a cache fault, or failure to glyph a character using
    // the current font
    do
    {
        // If a prior ::ScriptShape() call failed because it needed the font
        // selected into the hdc, then select the font into the hdc and try
        // again.
        if (hr == E_PENDING)
        {
            // If we have a valid hdcShape, then ScriptShape() failed for an
            // unknown reason. Bail out.
            if (hdcShape != NULL)
            {
                AssertSz(FALSE, "ScriptShape() failed for an unknown reason");
                lserr = LSERRFromHR(hr);
                goto Cleanup;
            }

            // Select the current font into the hdc and set hdcShape to hdc.
            hfontOld = ccs.PushFont(hdc);
            hdcShape = hdc;
        }
        // If a prior ::ScriptShape() call failed because it was unable to
        // glyph a character with the current font, swap the font around and
        // try it again.
        else if (hr == USP_E_SCRIPT_NOT_IN_FONT)
        {
            if (!fTriedFontLink)
            {
                // Unable to find the glyphs in the font. Font link to try an
                // alternate font which might work.
                fTriedFontLink = TRUE;

                // Set the sid for the complex run to match the text (instead
                // of sidDefault.
                Assert(plsrun->_ptp->IsText());
                plsrun->_sid = plsrun->_ptp->Sid();
                if (plsrun->_sid == sidAmbiguous)
                {
                    plsrun->_sid = sidDefault;
                }

                // Deselect the font if we selected it.
                if (hdcShape != NULL)
                {
                    Assert(hfontOld != HFONT_INVALID);
                    ccs.PopFont(hdc, hfontOld);
                    hdcShape = NULL;
                    hfontOld = HFONT_INVALID;
                }

                // Get the font using the normal sid from the text to fontlink.
                if (!GetCcs(&ccs, plsrun, hdc, _pci))
                {
                    lserr = lserrOutOfMemory;
                    goto Cleanup;
                }

                // Reset the psc using the new ccs.
                psc = ccs.GetUniscribeCache();
                Assert(psc != NULL);
            }
            else
            {
                // We tried to font link but we still couldn't make it work.
                // Blow the SCRIPT_ANALYSIS away and just let GDI deal with it.
                pcr->NukeAnalysis();
            }
        }
        // If ScriptShape() failed because of insufficient buffer space,
        // resize the buffer
        else if (hr == E_OUTOFMEMORY)
        {
            WORD *pGlyphBufferT = NULL;

            // enlarge the glyph count by another 6% of run or 10, whichever is larger.
            cMaxGly += max(10, (int)cwch >> 4);

            Assert(cMaxGly > 0);
            pGlyphBufferT = (WORD *) ReallocPtr(pGlyphBuffer, cMaxGly *
                                                (sizeof(WORD) + sizeof(SCRIPT_VISATTR)));
            if (pGlyphBufferT != NULL)
            {
                pGlyphBuffer = pGlyphBufferT;
                pGlyph = (WORD *) pGlyphBuffer;
                pVisAttr = (SCRIPT_VISATTR *) (pGlyphBuffer + cMaxGly);
            }
            else
            {
                // Memory alloc failure.
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }
        }

        // Try to shape the script again
        hr = ::ScriptShape(hdcShape, psc, pwch, cwch, cMaxGly, pcr->GetAnalysis(),
                           pGlyph, rgGmap, pVisAttr, (int *) pcgindex);

        // Uniscribe can return S_OK when it resolves to the default glyph.
        // In this case we are forcing to fontlink, if we didn't do it yet.
        if ((S_OK == hr) && (!fTriedFontLink) && (0 == *pGlyph))
            hr = USP_E_SCRIPT_NOT_IN_FONT;
    }
    while (hr == E_PENDING || hr == USP_E_SCRIPT_NOT_IN_FONT || hr == E_OUTOFMEMORY);

    // NB (mikejoch) We shouldn't ever fail except for the OOM case. USP should
    // always be loaded, since we wouldn't get a valid eScript otherwise.
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);
    lserr = LSERRFromHR(hr);

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        Assert(hdcShape != NULL);
        ccs.PopFont(hdc, hfontOld);
    }

    // If LS passed us a string which was an aggregate of several runs (which
    // happens if we returned FALSE from FInterruptShaping()) then we need
    // to make sure that the same _sid is stored in each por covered by the
    // aggregate string. Normally this isn't a problem, but if we changed
    // por->_sid for font linking then it becomes necessary. We determine
    // if a change occurred by comparing plsrun->_sid to sidDefault, which
    // is the value plsrun->_sid is always set to for a glyphed run (in
    // ChunkifyTextRuns()).
    if (plsrun->_sid != sidDefault && plsrun->_lscch < (LONG) cwch)
    {
        DWORD sidAlt = plsrun->_sid;
        COneRun * por = plsrun->_pNext;
        LONG lscchMergedRuns = cwch - plsrun->_lscch;

        while (lscchMergedRuns > 0 && por)
        {
            if (por->IsNormalRun() || por->IsSyntheticRun())
            {
                por->_sid = sidAlt;
                lscchMergedRuns -= por->_lscch;
            }
            por = por->_pNext;
        }
    }

    if (lserr == lserrNone)
    {
        // Move the values from the working buffer to the output arguments
        pcr->CopyPtr(pGlyphBuffer);
        *prgGindex = pGlyph;
        *prgGprop = (WORD *) pVisAttr;
    }
    else
    {
        // free up the allocated memory on failure
        if (pGlyphBuffer != NULL)
        {
            DisposePtr(pGlyphBuffer);
        }
        *prgGindex = NULL;
        *prgGprop = NULL;
        *pcgindex = 0;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphPositions (member, LS callback)
//
//  Synopsis:   Returns an index of glyph ids for the run passed in
//
//  Arguments:  plsrun              pointer to the run
//              lsDevice            presentation or reference
//              pwch                string of character codes
//              rgGmap              map of glyphs
//              cwch                number of characters in pwch
//              prgGindex           array of output glyph indices
//              prgGprop            array of output glyph properties
//              pcgindex            number of glyph indices
//              kTFlow              text direction and orientation
//              rgDu                array of glyph widths
//              rgGoffset           array of glyph offsets
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrModWidthPairsNotSet if failure
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphPositions(
    PLSRUN plsrun,          // IN
    LSDEVICE lsDevice,      // IN
    LPWSTR pwch,            // IN
    PCGMAP pgmap,           // IN
    DWORD cwch,             // IN
    PCGINDEX rgGindex,      // IN
    PCGPROP rgGprop,        // IN
    DWORD cgindex,          // IN
    LSTFLOW kTFlow,         // IN
    int* rgDu,              // OUT
    PGOFFSET rgGoffset)     // OUT
{
    LSTRACE(GetGlyphPositions);

    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    CComplexRun * pcr;
    XHDC hdc = _pci->_hdc;
    XHDC hdcPlace(NULL,NULL);
    FONTIDX hfontOld = HFONT_INVALID;
    SCRIPT_CACHE *psc;
    CCcs ccs;
    const CCharFormat *pCF = plsrun->GetCF();
    const CBaseCcs *pBaseCcs = NULL;
    ULONG i;
    
    pcr = plsrun->GetComplexRun();
    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    if (!GetCcs(&ccs, plsrun, hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);


    // Try to place the glyphs
    hr = ::ScriptPlace(hdcPlace, psc, rgGindex, cgindex, (SCRIPT_VISATTR *)rgGprop,
                       pcr->GetAnalysis(), rgDu, rgGoffset, NULL);

    // Handle failure
    if(hr == E_PENDING)
    {

        Assert(hdcPlace == NULL);

        // Select the current font into the hdc and set hdcShape to hdc.
        hfontOld = ccs.PushFont(hdc);
        hdcPlace = hdc;

        // Try again
        hr = ::ScriptPlace(hdcPlace, psc, rgGindex, cgindex, (SCRIPT_VISATTR *)rgGprop,
                           pcr->GetAnalysis(), rgDu, rgGoffset, NULL);

    }

    //see if font measurements needs scaling adjustment
    pBaseCcs = ccs.GetBaseCcs();
    Assert(pBaseCcs);

    for (i = 0; i < cgindex; i++)
    {
        // see if font measurements needs scaling adjustment
        if (pBaseCcs->_fScalingRequired)
        {
            rgDu[i] *= pBaseCcs->_flScaleFactor;
            rgGoffset[i].du *= pBaseCcs->_flScaleFactor;
            rgGoffset[i].dv *= pBaseCcs->_flScaleFactor;
        }
        if (rgGoffset[i].dv > 0)
            _cyAscent = max(_cyAscent, rgGoffset[i].dv);
        else if (rgGoffset[i].dv < 0)
            _cyDescent = max(_cyDescent, -rgGoffset[i].dv);
    }

    if (pCF->_wSpecialObjectFlags() != 0)
    {
        LONG xLetterSpacing = GetLetterSpacing(pCF);
        LONG xWordSpacing   = GetWordSpacing(pCF);

        if (xLetterSpacing || xWordSpacing || pCF->HasCharGrid(plsrun->_fInnerCF))
        {
            AdjustGlyphWidths(&ccs, xLetterSpacing, xWordSpacing, plsrun, pwch, cwch, 
                              0, rgDu, NULL, NULL, rgGoffset
#if DBG==1
                              , NULL
#endif
                                  );
        }
    }

    // NB (mikejoch) We shouldn't ever fail except for the OOM case (if USP is
    // allocating the cache). USP should always be loaded, since we wouldn't
    // get a valid eScript otherwise.
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);
    lserr = LSERRFromHR(hr);

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        ccs.PopFont(hdc, hfontOld);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   ResetRunContents (member, LS callback)
//
//  Synopsis:   This callback seems to be more informational.
//
//  Arguments:  plsrun              pointer to the run
//              cpFirstOld          cpFirst before shaping
//              dcpOld              dcp before shaping
//              cpFirstNew          cpFirst after shaping
//              dcpNew              dcp after shaping
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrMismatchLineContext if failure
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ResetRunContents(
    PLSRUN plsrun,      // IN
    LSCP cpFirstOld,    // IN
    LSDCP dcpOld,       // IN
    LSCP cpFirstNew,    // IN
    LSDCP dcpNew)       // IN
{
    LSTRACE(ResetRunContents);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    // FUTURE (paulnel) this doesn't appear to be needed for IE. Clarification
    // is being obtained from Line Services
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphExpansionInfo (member, LS callback)
//
//  Synopsis:   This callback is used for glyph based justification
//              1. For Arabic, it handles kashida insetion
//              2. For cluster characters, (thai vietnamese) it keeps tone 
//                 marks on their base glyphs
//
//  NOTE:       LS uses exptAddWhiteSpace for proportional expansion and
//                      exptAddInkContinuous for non-proportional expansion
//              Be sure that Thai uses exptAddInkContinuous for justification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphExpansionInfo(
    PLSRUN plsrun,                  // IN
    LSDEVICE lsDeviceID,            // IN
    LPCWSTR pwch,                   // IN
    PCGMAP rggmap,                  // IN
    DWORD cwch,                     // IN
    PCGINDEX rgglyph,               // IN
    PCGPROP rgProp,                 // IN
    DWORD cglyph,                   // IN
    LSTFLOW kTFlow,                 // IN
    BOOL fLastTextChunkOnLine,      // IN
    PEXPTYPE rgExpType,             // OUT
    LSEXPINFO* rgexpinfo)           // OUT
{
    LSTRACE(GetGlyphExpansionInfo);

    LSERR lserr = lserrNone;
    SCRIPT_VISATTR *psva = (SCRIPT_VISATTR *)&rgProp[0];
    CComplexRun * pcr;
    const SCRIPT_PROPERTIES *psp = NULL;
    float flKashidaPct = 100;
    BOOL fKashida = FALSE;
    int iKashidaWidth = 1;  // width of a kashida
    int iWhiteWidth = 1;
    int iPropL = 0;         // index to the connecting glyph left
    int iPropR = 0;         // index to the connecting glyph right
    int iBestPr = -1;       // address of the best priority in a word so far
    int iPrevBestPr = -1;   
    int iKashidaLevel = 0;
    int iBestKashidaLevel = 10;
    BYTE bBestPr = SCRIPT_JUSTIFY_NONE;
    BYTE bCurrentPr = SCRIPT_JUSTIFY_NONE;
    BYTE bNext;
    BYTE expType = exptNone;
    int iSpaceMax, iCharMax;
    LSEMS lsems;
    
    pcr = plsrun->GetComplexRun();
    UINT justifyStyle = plsrun->_pPF->_uTextJustify;

    if (pcr == NULL)
    {
        Assert(FALSE);
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // 1. From the script analysis we can tell what language we are dealing with
    //    a. if we are Arabic block languages, we need to do the kashida insertion
    //    b. if we are Thai or Vietnamese, we need to set the expansion type for diacritics 
    //       to none so they remain on their base glyph.
    psp = GetScriptProperties(pcr->GetAnalysis()->eScript);

    // Check to see if we are an Arabic block language
    fKashida = IsInArabicBlock(psp->langid);

    // if we are going to do kashida insertion we need to get the kashida width information
    if(fKashida)
    {
        lserr = GetKashidaWidth(plsrun, &iKashidaWidth);

        if(lserr != lserrNone)
            goto Cleanup;

        if (!plsrun->_pPF->_cuvTextKashidaSpace.IsNull())
        {
            flKashidaPct = plsrun->_pPF->_cuvTextKashidaSpace.GetUnitValue();
        }

        if (flKashidaPct == 0)
        {
            iWhiteWidth = iKashidaWidth;
            iKashidaWidth = 1;
        }
        else if (flKashidaPct < 100)
        {
            iWhiteWidth = max((int)((float)iKashidaWidth * ((100 - flKashidaPct) / flKashidaPct)), 1);
        }

    }

    // find the max space and character widths for expansion
    // this will give us compatibility with expansion used by
    // character based runs. 8-)
    lserr = GetEms(plsrun, kTFlow, &lsems);
    if(lserr != lserrNone)
        goto Cleanup;

    if (justifyStyle == styleTextJustifyNewspaper)
    {
        iSpaceMax = lsems.udExp;
    }
    else
    {
        iSpaceMax = lsems.em2;
    }
    iCharMax = lsems.em4;

    //initialize rgExpType and rgexpinfo to zeros
    expType = exptNone;
    memset(rgExpType, expType, sizeof(EXPTYPE)*cglyph);
    memset(rgexpinfo, 0, sizeof(LSEXPINFO)*cglyph);

    // Loop through the glyph attributes. We assume logical order here
    while(iPropL < (int)cglyph)
    {
        bCurrentPr = psva[iPropL].uJustification;

        switch(bCurrentPr)
        {
        case SCRIPT_JUSTIFY_NONE:
            rgExpType[iPropL] = exptNone;

            // this is a HACK to fix a Uniscribe problem. When Uniscribe is fixed, 
            // this needs to be removed.
            if(IsNoSpaceLang(psp->langid) && !psva[iPropL].fDiacritic && !psva[iPropL].fZeroWidth)
            {
                if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1)) // base glyph
                {
                    BOOL fLastBaseGlyph = FALSE;

                    if (fLastTextChunkOnLine)
                    {
                        iPropR = cglyph - 1;
                        while (iPropR > iPropL)
                        {
                            if (!psva[iPropR].fDiacritic && !psva[iPropR].fZeroWidth) // base glyph
                                break;
                            iPropR--;
                        }
                        if (iPropR == iPropL)
                            fLastBaseGlyph = TRUE;
                    }
                    if (!fLastBaseGlyph)
                    {
                        switch(justifyStyle)
                        {
                        default:
                        case styleTextJustifyInterWord:
                        case styleTextJustifyInterIdeograph:
                        case styleTextJustifyKashida:
                            rgExpType[iPropL] = exptNone;
                            break;
                        case styleTextJustifyNewspaper:
                        case styleTextJustifyDistribute:
                        case styleTextJustifyDistributeAllLines:
                        case styleTextJustifyInterCluster:
                            rgExpType[iPropL] = exptAddInkContinuous;
                            rgexpinfo[iPropL].prior = 1;
                            rgexpinfo[iPropL].duMax = iSpaceMax;
                            rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                            rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                            break;
                        }
                    }
                }
            }

            break;

        case SCRIPT_JUSTIFY_CHARACTER:
            if(!NoInterClusterJustification(psp->langid) && !IsNoSpaceLang(psp->langid))
            {
                if (!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
                {
                    switch(justifyStyle)
                    {
                    default:
                    case styleTextJustifyInterWord:
                    case styleTextJustifyInterIdeograph:
                    case styleTextJustifyKashida:
                    case styleTextJustifyInterCluster:
                        rgExpType[iPropL] = exptNone;
                        break;
                    case styleTextJustifyNewspaper:
                    case styleTextJustifyDistribute:
                    case styleTextJustifyDistributeAllLines:
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = iCharMax;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                        break;
                    }
                }
                // Final character on the line should not get justification
                // flag set.
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
                
            }
            // NoSpaceLanguage
            else if (IsNoSpaceLang(psp->langid))
            {
                if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1)) 
                {
                    if (!psva[iPropL].fDiacritic && !psva[iPropL].fZeroWidth) // base glyph
                    {
                        BOOL fLastBaseGlyph = FALSE;

                        if (fLastTextChunkOnLine)
                        {
                            iPropR = cglyph - 1;
                            while (iPropR > iPropL)
                            {
                                if (!psva[iPropR].fDiacritic && !psva[iPropR].fZeroWidth) // base glyph
                                    break;
                                iPropR--;
                            }
                            if (iPropR == iPropL)
                                fLastBaseGlyph = TRUE;
                        }
                        if (!fLastBaseGlyph)
                        {
                            switch(justifyStyle)
                            {
                            default:
                            case styleTextJustifyInterWord:
                            case styleTextJustifyInterIdeograph:
                            case styleTextJustifyKashida:
                                rgExpType[iPropL] = exptNone;
                                break;
                            case styleTextJustifyNewspaper:
                            case styleTextJustifyDistribute:
                            case styleTextJustifyDistributeAllLines:
                            case styleTextJustifyInterCluster:
                                rgExpType[iPropL] = exptAddInkContinuous;
                                rgexpinfo[iPropL].prior = 1;
                                rgexpinfo[iPropL].duMax = iSpaceMax;
                                rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                                rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                                break;
                            }
                        }
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                }
                // Final character on the line should not get justification
                // flag set.
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
            }
            // NoInterClusterJustification
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_BLANK:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {
                rgExpType[iPropL] = exptAddInkContinuous;
                rgexpinfo[iPropL].prior = 1;
                rgexpinfo[iPropL].duMax = iSpaceMax;
                rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_ARABIC_BLANK:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {

                switch(justifyStyle)
                {
                case styleTextJustifyInterWord:
                    rgExpType[iPropL] = exptAddInkContinuous;
                    rgexpinfo[iPropL].prior = 1;
                    rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                    rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                    rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    break;
                case styleTextJustifyNewspaper:
                case styleTextJustifyDistribute:
                case styleTextJustifyDistributeAllLines:
                    if (flKashidaPct < 100)
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyInterCluster:
                case styleTextJustifyInterIdeograph:
                    if (flKashidaPct < 100)
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyNotSet:
                case styleTextJustifyKashida:
                case styleTextJustifyAuto:
                    if (flKashidaPct == 100)
                    {
                        if (iBestPr >= 0)
                        {
                            rgExpType[iBestPr] = exptAddInkContinuous;
                            rgexpinfo[iBestPr].prior = 1;
                            rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
                            rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
                        }

                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 2;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    }
                    else if (flKashidaPct > 0)
                    {
                        if (iBestPr >= 0)
                        {
                            rgExpType[iBestPr] = exptAddInkContinuous;
                            rgexpinfo[iBestPr].prior = 1;
                            rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
                            rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
                        }

                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = iWhiteWidth;
                    }
                    else // fKashida == 0
                    {
                        rgExpType[iPropL] = exptAddInkContinuous;
                        rgexpinfo[iPropL].prior = 1;
                        rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                        rgexpinfo[iPropL].fCanBeUsedForResidual = TRUE;
                        rgexpinfo[iPropL].u.AddInkContinuous.duMin = 1;
                    }

                    if (flKashidaPct > 0 && iBestPr >=0)
                    {
                        iPrevBestPr = iPropL;
                        iBestPr = -1;
                        bBestPr = SCRIPT_JUSTIFY_NONE;
                        iBestKashidaLevel = KASHIDA_PRIORITY9;
                    }
                    break;
                default:
                    rgExpType[iPropL] = exptNone;
                    break;
                }
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                rgExpType[iPropL] = exptNone;
            }
            break;

        case SCRIPT_JUSTIFY_ARABIC_KASHIDA: // kashida is placed after kashida and seen characters
        case SCRIPT_JUSTIFY_ARABIC_SEEN:
        case SCRIPT_JUSTIFY_ARABIC_HA: // kashida is placed before the ha and alef
        case SCRIPT_JUSTIFY_ARABIC_ALEF:
        case SCRIPT_JUSTIFY_ARABIC_RA: // kashida is placed before prior character if prior char is a medial ba type
        case SCRIPT_JUSTIFY_ARABIC_BARA:
        case SCRIPT_JUSTIFY_ARABIC_BA:
        case SCRIPT_JUSTIFY_ARABIC_NORMAL:
            if(!fLastTextChunkOnLine || (DWORD)iPropL != (cglyph - 1))
            {
                switch(justifyStyle)
                {
                case styleTextJustifyInterWord:
                case styleTextJustifyInterCluster:
                case styleTextJustifyInterIdeograph:
                    rgExpType[iPropL] = exptNone;
                    break;
                case styleTextJustifyNewspaper:
                case styleTextJustifyDistribute:
                case styleTextJustifyDistributeAllLines:
                    if (flKashidaPct > 0)
                    {
                        if (   bCurrentPr == SCRIPT_JUSTIFY_ARABIC_KASHIDA
                            || bCurrentPr == SCRIPT_JUSTIFY_ARABIC_SEEN)
                        {
                            rgExpType[iPropL] = exptAddInkContinuous;
                            rgexpinfo[iPropL].prior = 1;
                            rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                            rgexpinfo[iPropL].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iPropL].u.AddInkContinuous.duMin = iKashidaWidth;
                        }
                        else
                        {
                            Assert(iPropL > 0);
                            rgExpType[iPropL - 1] = exptAddInkContinuous;
                            rgexpinfo[iPropL - 1].prior = 1;
                            rgexpinfo[iPropL - 1].duMax = lsexpinfInfinity;
                            rgexpinfo[iPropL - 1].fCanBeUsedForResidual = FALSE;
                            rgexpinfo[iPropL - 1].u.AddInkContinuous.duMin = iKashidaWidth;

                            bNext = psva[iPropL + 1].uJustification;
                            if (   bNext >= SCRIPT_JUSTIFY_ARABIC_NORMAL
                                && bNext < SCRIPT_JUSTIFY_ARABIC_SEEN
                                && bNext != SCRIPT_JUSTIFY_ARABIC_KASHIDA)
                            {
                                rgExpType[iPropL] = exptAddInkContinuous;
                                rgexpinfo[iPropL].prior = 1;
                                rgexpinfo[iPropL].duMax = lsexpinfInfinity;
                                rgexpinfo[iPropL].fCanBeUsedForResidual = FALSE;
                                rgexpinfo[iPropL].u.AddInkContinuous.duMin = iKashidaWidth;
                            }
                        }
                    }
                    else
                    {
                        rgExpType[iPropL] = exptNone;
                    }
                    break;
                case styleTextJustifyKashida:
                default:
                    if (flKashidaPct > 0)
                    {
                        iKashidaLevel = s_iKashidaPriFromScriptJustifyType[bCurrentPr];
                        if(iKashidaLevel <= iBestKashidaLevel)
                        {
                            iBestKashidaLevel = iKashidaLevel;

                            if (   bCurrentPr == SCRIPT_JUSTIFY_ARABIC_KASHIDA
                                || bCurrentPr == SCRIPT_JUSTIFY_ARABIC_SEEN)
                            {
                                // these types of kashida go after this glyph visually
                                for(iPropR = iPropL + 1; iPropR < (int)cglyph && psva[iPropR].fDiacritic; iPropR++);
                                if(iPropR != iPropL)
                                    iPropR--;

                                iBestPr = iPropR;
                            }
                            else
                            {
                                if (bCurrentPr != SCRIPT_JUSTIFY_ARABIC_BARA)
                                {
                                    Assert(iPropL > 0);
                                    iBestPr = iPropL - 1;
                                }
                                else
                                {
                                    Assert(iPropL > 0);

                                    // if we have a medial ba before the ra, add the kashida before
                                    // the medial ba
                                    if (   psva[iPropL - 1].uJustification == SCRIPT_JUSTIFY_ARABIC_BA)
                                    {
                                        Assert(iPropL > 1);
    	                                iBestPr = iPropL - 2;
                                    }
                                    else
                                    {
                                        // We did not have a medial tooth type character before, so we
                                        // demote the value
                                        iBestKashidaLevel = s_iKashidaPriFromScriptJustifyType[SCRIPT_JUSTIFY_ARABIC_RA];

                                        iBestPr = iPropL - 1;
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
            // Final character on the line should not get justification
            // flag set.
            else
            {
                if (   bCurrentPr != SCRIPT_JUSTIFY_ARABIC_KASHIDA
                    && bCurrentPr != SCRIPT_JUSTIFY_ARABIC_SEEN
                    && flKashidaPct > 0)
                {
                    iKashidaLevel = KASHIDA_PRIORITY3;
                    if(iKashidaLevel <= iBestKashidaLevel)
                    {
                        iBestKashidaLevel = iKashidaLevel;
                        Assert(iPropL > 0);
                        iBestPr = iPropL - 1;
                    }
                }
                else
                {
                    rgExpType[iPropL] = exptNone;
                }
            }
            break;

        }

        iPropL++;
    }

    // add/set any remaining priority.
    if(fKashida && iBestPr >= 0 && flKashidaPct)
    {
        rgExpType[iBestPr] = exptAddInkContinuous;
        rgexpinfo[iBestPr].prior = 1;
        rgexpinfo[iBestPr].duMax = lsexpinfInfinity;
        rgexpinfo[iBestPr].fCanBeUsedForResidual = FALSE;
        rgexpinfo[iBestPr].u.AddInkContinuous.duMin = iKashidaWidth;
    }
    
Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetGlyphExpansionInkInfo (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetGlyphExpansionInkInfo(
    PLSRUN plsrun,              // IN
    LSDEVICE lsDeviceID,        // IN
    GINDEX gindex,              // IN
    GPROP gprop,                // IN
    LSTFLOW kTFlow,             // IN
    DWORD cAddInkDiscrete,      // IN
    long* rgDu)                 // OUT
{
    LSTRACE(GetGlyphExpansionInkInfo);
    LSNOTIMPL(GetGlyphExpansionInkInfo);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FTruncateBefore (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FTruncateBefore(
    PLSRUN plsrunCur,       // IN
    LSCP cpCur,             // IN
    WCHAR wchCur,           // IN
    long durCur,            // IN
    PLSRUN plsrunPrev,      // IN
    LSCP cpPrev,            // IN
    WCHAR wchPrev,          // IN
    long durPrev,           // IN
    long durCut,            // IN
    BOOL* pfTruncateBefore) // OUT
{
    LSTRACE(FTruncateBefore);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(FTruncateBefore);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FHangingPunct (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FHangingPunct(
    PLSRUN plsrun,
    MWCLS mwcls,
    WCHAR wch,
    BOOL* pfHangingPunct)
{
    LSTRACE(FHangingPunct);

    *pfHangingPunct = FALSE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSnapGrid (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetSnapGrid(
    WCHAR* rgwch,           // IN
    PLSRUN* rgplsrun,       // IN
    LSCP* rgcp,             // IN
    DWORD cwch,             // IN
    BOOL* rgfSnap,          // OUT
    DWORD* pwGridNumber)    // OUT
{
    LSTRACE(GetSnapGrid);

    // This callback function shouldn't be called. We manage grid snapping ourselves.
    *pwGridNumber = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FCancelHangingPunct (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FCancelHangingPunct(
    LSCP cpLim,                // IN
    LSCP cpLastAdjustable,      // IN
    WCHAR wch,                  // IN
    MWCLS mwcls,                // IN
    BOOL* pfCancelHangingPunct) // OUT
{
    LSTRACE(FCancelHangingPunct);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(FCancelHangingPunct);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModifyCompAtLastChar (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModifyCompAtLastChar(
    LSCP cpLim,             // IN
    LSCP cpLastAdjustable,  // IN
    WCHAR wchLast,          // IN
    MWCLS mwcls,            // IN
    long durCompLastRight,  // IN
    long durCompLastLeft,   // IN
    long* pdurChangeComp)   // OUT
{
    LSTRACE(ModifyCompAtLastChar);
    // FUTURE (mikejoch) Need to adjust cp values if we ever implement this.
    LSNOTIMPL(ModifyCompAtLastChar);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumText (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumText(
    PLSRUN plsrun,           // IN
    LSCP cpFirst,            // IN
    LSDCP dcp,               // IN
    LPCWSTR rgwch,           // IN
    DWORD cwch,              // IN
    LSTFLOW lstflow,         // IN
    BOOL fReverseOrder,      // IN
    BOOL fGeometryProvided,  // IN
    const POINT* pptStart,   // IN
    PCHEIGHTS pheightsPres,  // IN
    long dupRun,             // IN
    BOOL fCharWidthProvided, // IN
    long* rgdup)             // IN
{
    LSTRACE(EnumText);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumTab (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumTab(
    PLSRUN plsrun,          // IN
    LSCP cpFirst,           // IN
    WCHAR * rgwch,          // IN                   
    WCHAR wchTabLeader,     // IN
    LSTFLOW lstflow,        // IN
    BOOL fReversedOrder,    // IN
    BOOL fGeometryProvided, // IN
    const POINT* pptStart,  // IN
    PCHEIGHTS pheightsPres, // IN
    long dupRun)
{
    LSTRACE(EnumTab);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   EnumPen (member, LS callback)
//
//  Synopsis:   Enumeration function, currently unimplemented
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::EnumPen(
    BOOL fBorder,           // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverseOrder,     // IN
    BOOL fGeometryProvided, // IN
    const POINT* pptStart,  // IN
    long dup,               // IN
    long dvp)               // IN
{
    LSTRACE(EnumPen);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetObjectHandlerInfo (member, LS callback)
//
//  Synopsis:   Returns an object handler for the client-side functionality
//              of objects which are handled primarily by LineServices.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetObjectHandlerInfo(
    DWORD idObj,        // IN
    void* pObjectInfo)  // OUT
{
    LSTRACE(GetObjectHandlerInfo);

    switch (idObj)
    {
        case LSOBJID_RUBY:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(RUBYINIT) == sizeof(::RUBYINIT) );
            *(RUBYINIT *)pObjectInfo = s_rubyinit;
#else
            int iSize = InitRubyinit();
            Assert( sizeof(RUBYINIT) == sizeof(::RUBYINIT) + iSize );
            *(::RUBYINIT *)pObjectInfo = s_unix_rubyinit;
#endif
            break;

        case LSOBJID_TATENAKAYOKO:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(TATENAKAYOKOINIT) == sizeof(::TATENAKAYOKOINIT) );
            *(TATENAKAYOKOINIT *)pObjectInfo = s_tatenakayokoinit;
#else
            iSize = InitTatenakayokoinit();
            Assert( sizeof(TATENAKAYOKOINIT) == sizeof(::TATENAKAYOKOINIT) + iSize);
            *(::TATENAKAYOKOINIT *)pObjectInfo = s_unix_tatenakayokoinit;
#endif
            break;

        case LSOBJID_HIH:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(HIHINIT) == sizeof(::HIHINIT) );
            *(HIHINIT *)pObjectInfo = s_hihinit;
#else
            iSize = InitHihinit();
            Assert( sizeof(HIHINIT) == sizeof(::HIHINIT) + iSize);
            *(::HIHINIT *)pObjectInfo = s_unix_hihinit;
#endif
            break;

        case LSOBJID_WARICHU:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(WARICHUINIT) == sizeof(::WARICHUINIT) );
            *(WARICHUINIT *)pObjectInfo = s_warichuinit;
#else
            iSize = InitWarichuinit();
            Assert( sizeof(WARICHUINIT) == sizeof(::WARICHUINIT) + iSize);
            *(::WARICHUINIT *)pObjectInfo = s_unix_warichuinit;
#endif
            break;

        case LSOBJID_REVERSE:
#if !defined(UNIX) && !defined(_MAC)
            Assert( sizeof(REVERSEINIT) == sizeof(::REVERSEINIT) );
            *(REVERSEINIT *)pObjectInfo = s_reverseinit;
#else
            iSize = InitReverseinit();
            Assert( sizeof(REVERSEINIT) == sizeof(::REVERSEINIT) + iSize);
            *(::REVERSEINIT *)pObjectInfo = s_unix_reverseinit;
#endif
            break;

        default:
            AssertSz(0,"Unknown LS object ID.");
            break;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   AssertFailed (member, LS callback)
//
//  Synopsis:   Assert callback for LineServices
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

void WINAPI
CLineServices::AssertFailed(
    char* szMessage,
    char* szFile,
    int   iLine)
{
    LSTRACE(AssertFailed);

#if DBG==1
    if (IsTagEnabled(tagLSAsserts))
    {
        DbgExAssertImpl( szFile, iLine, szMessage );
    }
#endif
}

//-----------------------------------------------------------------------------
//
//  Function:   ChunkifyTextRun
//
//  Synopsis:   Break up a text run if necessary.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::ChunkifyTextRun(COneRun *por, COneRun **pporOut)
{
    LONG    cchRun;
    LPCWSTR pwchRun;
    BOOL    fHasInclEOLWhite = por->_pPF->HasInclEOLWhite(por->_fInnerPF);
    const   DWORD cpCurr = por->Cp();
    LSERR   lserr = lserrNone;
    
    *pporOut = por;
    
    //
    // 0) If current run has character grid, in some cases we need to open/close
    //    LS installed object (LSOBJID_LAYOUTGRID).
    //    A special object should be created in following circumstances:
    //    * 'layout-grid-type' is 'fixed' and run has 'cursive' characters.
    //    * 'layout-grid-type' is 'strict' and run has 'cursive'/'half-width' characters
    //
    if (por->GetCF()->HasCharGrid(por->_fInnerCF))
    {
        if (!IsFrozen())
        {
            if (    por->GetPF()->GetLayoutGridType(por->_fInnerPF) == styleLayoutGridTypeFixed
                ||  por->GetPF()->GetLayoutGridType(por->_fInnerPF) == styleLayoutGridTypeStrict)
            {
                // Look backward for a run which is either:
                // * normal text run.
                // * synthetic run of type SYNTHTYPE_LAYOUTGRID
                // * synthetic run of type SYNTHTYPE_ENDLAYOUTGRID
                COneRun * porGridCompare = por->_pPrev ? por->_pPrev : _listCurrent._pTail;
                while (     porGridCompare
                        &&  !(porGridCompare->_ptp->IsText() &&  porGridCompare->IsNormalRun())
                        &&  porGridCompare->_synthType != SYNTHTYPE_LAYOUTGRID
                        &&  porGridCompare->_synthType != SYNTHTYPE_ENDLAYOUTGRID)
                {
                    porGridCompare = porGridCompare->_pPrev;
                }
                if (porGridCompare && porGridCompare->_synthType == SYNTHTYPE_ENDLAYOUTGRID)
                    porGridCompare = NULL;

                if (por->IsOneCharPerGridCell())
                {
                    if (    porGridCompare 
                        &&  porGridCompare->IsNormalRun()
                        &&  porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
                        &&  !porGridCompare->IsOneCharPerGridCell())
                    {
                        // Need to tell LS that we are closing artificially opened
                        // layout grid object.
                        Assert(_cLayoutGridObjArtificial > 0);  // Can't close without opening
                        --_cLayoutGridObjArtificial;
                        lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
                        Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                        goto Cleanup;
                    }
                }
                else
                {
                    if (    !porGridCompare 
                        ||  (   porGridCompare->IsNormalRun()
                            &&  (   !porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
                                ||  porGridCompare->IsOneCharPerGridCell())))
                    {
                        // Need to tell LS that we are opening artificial layout grid object.
                        Assert(_cLayoutGridObjArtificial == 0); // We are allowed to have only one
                        ++_cLayoutGridObjArtificial;
                        lserr = AppendILSControlChar(por, SYNTHTYPE_LAYOUTGRID, pporOut);
                        Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
                        goto Cleanup;
                    }
                }
            }
        }
    }
    else if (_cLayoutGridObjArtificial > 0)
    {
        // Look backward for a run which is either:
        // * normal text run.
        // * synthetic run of type SYNTHTYPE_LAYOUTGRID
        // * synthetic run of type SYNTHTYPE_ENDLAYOUTGRID
        COneRun * porGridCompare = por->_pPrev ? por->_pPrev : _listCurrent._pTail;
        while (     porGridCompare
                &&  !(porGridCompare->_ptp->IsText() &&  porGridCompare->IsNormalRun())
                &&  porGridCompare->_synthType != SYNTHTYPE_LAYOUTGRID
                &&  porGridCompare->_synthType != SYNTHTYPE_ENDLAYOUTGRID)
        {
            porGridCompare = porGridCompare->_pPrev;
        }
        if (porGridCompare && porGridCompare->_synthType == SYNTHTYPE_ENDLAYOUTGRID)
        {
            Assert(_cLayoutGridObjArtificial == 0);
            porGridCompare = NULL;
        }

        if (    porGridCompare 
            &&  porGridCompare->IsNormalRun()
            &&  porGridCompare->GetCF()->HasCharGrid(porGridCompare->_fInnerCF)
            &&  !porGridCompare->IsOneCharPerGridCell())
        {
            // Need to tell LS that we are closing artificially opened
            // layout grid object.
            Assert(_cLayoutGridObjArtificial > 0);  // Can't close without opening
            --_cLayoutGridObjArtificial;
            lserr = AppendILSControlChar(por, SYNTHTYPE_ENDLAYOUTGRID, pporOut);
            Assert(lserr != lserrNone || (*pporOut)->_synthType != SYNTHTYPE_NONE);
            goto Cleanup;
        }
    }

    //
    // 1) If there is a whitespace at the beginning of line, we
    //    do not want to show the whitespace (0 width -- the right
    //    way to do it is to say that the run is hidden).
    //
    if (IsFirstNonWhiteOnLine(cpCurr))
    {
        const TCHAR * pwchRun = por->_pchBase;
        DWORD cp = cpCurr;
        cchRun  = por->_lscch;

        if (!fHasInclEOLWhite)
        {
            while (cchRun)
            {
                const TCHAR ch = *pwchRun++;

                if (!IsWhite(ch))
                    break;

                // Note a whitespace at BOL
                WhiteAtBOL(cp, 1);
                //_lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
                cp++;

                // Goto next character
                cchRun--;
            }
        }


        //
        // Did we find any whitespaces at BOL? If we did, then
        // create a chunk with those whitespace and mark them
        // as hidden.
        //
        if (cchRun != por->_lscch)
        {
            por->_lscch -= cchRun;
            por->_fHidden = TRUE;
            goto Cleanup;
        }
    }

    //
    // 2. Fold whitespace after an aligned or abspos'd site if there
    //    was a whitespace *before* the aligned site. The way we do this
    //    folding is by saying that the present space is hidden.
    //
    {
        const TCHAR chFirst = *por->_pchBase;
        if (!fHasInclEOLWhite)
        {
            if ( !_fIsEditable
                   )
            {
                if (   IsWhite(chFirst)
                    && NeedToEatThisSpace(por)
                   )
                {
                    _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_NOBLAST);
                    por->_lscch = 1;
                    por->_fHidden = TRUE;
                    goto Cleanup;
                }
            }

            if (IsFirstNonWhiteOnLine(cpCurr))
            {
                //
                // 3. Note any \n\r's
                //
                if (chFirst == TEXT('\r') || chFirst == TEXT('\n'))
                {
                    WhiteAtBOL(cpCurr, 1);
                    _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_NOBLAST);
                }
            }
        }
    }
    
    if (_fScanForCR)
    {
        cchRun = por->_lscch;
        pwchRun = por->_pchBase;

        if (WCH_CR == *pwchRun)
        {
            // If all we have on the line are sites, then we do not want the \r to
            // contribute to height of the line and hence we set _fNoTextMetrics to TRUE.
            if (LineHasOnlySites(por->Cp()))
                por->_fNoTextMetrics = TRUE;
            
            lserr = TerminateLine(por, TL_ADDNONE, pporOut);
            if (lserr != lserrNone)
                goto Cleanup;
            if (*pporOut == NULL)
            {
                //
                // All lines ending in a carriage return have the BR flag set on them.
                //
                _lineFlags.AddLineFlag(cpCurr, FLAG_HAS_A_BR);
                por->FillSynthData(SYNTHTYPE_LINEBREAK);
                *pporOut = por;
            }
            goto Cleanup;
        }
        // if we came here after a single site in _fScanForCR mode, it means that we
        // have some text after the single site and hence it should be on the next
        // line. Hence terminate the line here. (If it were followed by a \r, then
        // it would have fallen in the above case which would have consumed that \r)
        else if (_fSingleSite)
        {
            lserr = TerminateLine(por, TL_ADDEOS, pporOut);
            goto Cleanup;
        }
        else
        {
            LONG cch = 0;
            while (cch != cchRun)
            {
                if (WCH_CR == *pwchRun)
                    break;
                cch++;
                pwchRun++;
            }
            por->_lscch = cch;
        }
    }

    Assert(por->_ptp && por->_ptp->IsText() && por->_sid == DWORD(por->_ptp->Sid()));

    if (   _pBidiLine != NULL
        || sidAsciiLatin != por->_sid
        || g_iNumShape != NUMSHAPE_NONE
        || _li._fLookaheadForGlyphing)
    {
        BOOL fGlyph = FALSE;
        BOOL fForceGlyphing = FALSE;
        BOOL fNeedBidiLine = (_pBidiLine != NULL);
        BOOL fRTL = FALSE;
        DWORD uLangDigits = LANG_NEUTRAL;
        WCHAR chNext = WCH_NULL;

        //
        // 4. Note any glyphable etc chars
        //
        cchRun = por->_lscch;
        pwchRun = por->_pchBase;
        while (cchRun-- && !(fGlyph && fNeedBidiLine))
        {
            const TCHAR ch = *pwchRun++;

            fGlyph |= IsGlyphableChar(ch);
            fNeedBidiLine |= IsRTLChar(ch);
        }

        //
        // 5. Break run based on the text direction.
        //
        if (fNeedBidiLine && _pBidiLine == NULL)
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
        }
        if (_pBidiLine != NULL)
        {
            por->_lscch = _pBidiLine->GetRunCchRemaining(por->Cp(), por->_lscch);
            // FUTURE (mikejoch) We are handling symmetric swapping by forced
            // glyphing of RTL runs. We may be able to do this faster by
            // swapping symmetric characters in CLSRenderer::TextOut().
            fRTL = fForceGlyphing = _pBidiLine->GetLevel(por->Cp()) & 1;
        }

        //
        // 6. Break run based on the digits.
        //
        if (g_iNumShape != NUMSHAPE_NONE)
        {
            cchRun = por->_lscch;
            pwchRun = por->_pchBase;
            while (cchRun && !InRange(*pwchRun, ',', '9'))
            {
                pwchRun++;
                cchRun--;
            }
            if (cchRun)
            {
                if (g_iNumShape == NUMSHAPE_NATIVE)
                {
                    uLangDigits = g_uLangNationalDigits;
                    fGlyph = TRUE;
                }
                else
                {
                    COneRun * porContext;

                    Assert(g_iNumShape == NUMSHAPE_CONTEXT && InRange(*pwchRun, ',', '9'));

                    // Scan back for first strong text.
                    cchRun = pwchRun - por->_pchBase;
                    pwchRun--;
                    while (cchRun != 0 && (!IsStrongClass(DirClassFromCh(*pwchRun)) || InRange(*pwchRun, WCH_LRM, WCH_RLM)))
                    {
                        cchRun--;
                        pwchRun--;
                    }
                    porContext = _listCurrent._pTail;
                    if (porContext == por)
                    {
                        porContext = porContext->_pPrev;
                    }
                    while (cchRun == 0 && porContext != NULL)
                    {
                        if (porContext->IsNormalRun() && porContext->_pchBase != NULL)
                        {
                            cchRun = porContext->_lscch;
                            pwchRun = porContext->_pchBase + cchRun - 1;
                            while (cchRun != 0 && (!IsStrongClass(DirClassFromCh(*pwchRun)) || InRange(*pwchRun, WCH_LRM, WCH_RLM)))
                            {
                                cchRun--;
                                pwchRun--;
                            }
                        }

                        if (cchRun == 0)
                        {
                            porContext = porContext->_pPrev;
                        }
                    }

                    if (cchRun > 0 && porContext != NULL)
                    {
                        CComplexRun * pcr;
                        const SCRIPT_PROPERTIES *psp = NULL;

                        pcr = porContext->GetComplexRun();
                        if (pcr != NULL)
                        {
                            psp = GetScriptProperties(pcr->GetAnalysis()->eScript);

                            uLangDigits = psp->langid;
                            fGlyph = TRUE;
                        }
                    }
                    else if (   _li._fRTLLn 
                             && IsInArabicBlock(PRIMARYLANGID(g_lcidLocalUserDefault)))
                    {
                        uLangDigits = PRIMARYLANGID(g_lcidLocalUserDefault);
                        fGlyph = TRUE;
                    }
                }
            }
        }

        //
        // 7. Check if we should have glyphed the prior run (for combining
        //    Latin diacritics; esp. Vietnamese)
        //
        if (_lsMode == LSMODE_MEASURER && !_li._fLookaheadForGlyphing)
        {
            if (fGlyph && IsCombiningMark(*(por->_pchBase)))
            {
                // We want to break the shaping if the formats are not similar
                COneRun * porPrev = _listCurrent._pTail;

                while (porPrev != NULL && !porPrev->IsNormalRun())
                {
                    porPrev = porPrev->_pPrev;
                }

                if (porPrev != NULL && !porPrev->_lsCharProps.fGlyphBased)
                {
                    const CCharFormat *pCF1 = por->GetCF();
                    const CCharFormat *pCF2 = porPrev->GetCF();

                    Assert(pCF1 != NULL && pCF2 != NULL);
                    _li._fLookaheadForGlyphing = pCF1->CompareForLikeFormat(pCF2);
                    _fNeedRecreateLine = TRUE;
                }
            }
        }
        else if (_li._fLookaheadForGlyphing)
        {
            Assert (por->_lscch >= 1);

            CTxtPtr txtptr(_pMarkup, por->Cp() + por->_lscch - 1);

            // N.B. (mikejoch) This is an extremely non-kosher lookup to do
            // here. It is quite possible that chNext will be from an
            // entirely different site. If that happens, though, it will
            // only cause the unnecessary glyphing of this run, which
            // doesn't actually affect the visual appearence.
            while ((chNext = txtptr.NextChar()) == WCH_NODE);
            if (IsCombiningMark(chNext))
            {
                // Good chance this run needs to be glyphed with the next one.
                // Turn glyphing on.
                fGlyph = fForceGlyphing = TRUE;
            }
        }

        //
        // 8. Break run based on the script.
        //
        if (fGlyph || fRTL)
        {
            CComplexRun * pcr = por->GetNewComplexRun();

            if (pcr == NULL)
                return lserrOutOfMemory;

            pcr->ComputeAnalysis(_pFlowLayout, fRTL, fForceGlyphing, chNext,
                                 _chPassword, por, _listCurrent._pTail, 
                                 uLangDigits, _pBidiLine);

            // Something on the line needs glyphing.
            if (por->_lsCharProps.fGlyphBased)
            {
                _fGlyphOnLine = TRUE;

                //
                // In case of glyphing set sid to sidDefault.
                // Keep sid informatio only for:
                // * surrogates
                // * sidHan - we need to UnUnify it and keep this information for fontlinking
                // 
                if (   uLangDigits != LANG_NEUTRAL
                    || (   por->_sid != sidHan 
                        && por->_sid != sidThai
                        && por->_sid != sidHangul
#ifndef NO_UTF16
                        && por->_sid != sidSurrogateA 
                        && por->_sid != sidSurrogateB
#endif
                       )
                   )
                {
                    por->_sid = ScriptIDFromLangID(uLangDigits);
                }
            }
        }
    }

    Assert(sidAmbiguous < sidCurrency);
    if (por->_sid >= sidAmbiguous) 
    {
        //
        // (Bug 44817) (grzegorz) Built-in printer fonts sometimes do not contain
        // EURO sign. So, in case of priniting currency signs font's out precision
        // is changed to force downloading software fonts instead of using printer 
        // built-in fonts.
        //
        if (    por->_sid == sidCurrency
            &&  _pci->_pMarkup->IsPrintMedia())
        {
            CCharFormat * pCFNew = por->GetOtherCloneCF();
            pCFNew->_fOutPrecision = 1;
            pCFNew->_bCrcFont = pCFNew->ComputeFontCrc();

            // Do not blast this line
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        }

        if (por->_sid == sidAmbiguous)
        {
            //
            // (Bug 85263) (grzegorz) If we have SOFT HYPHEN character we don't want to 
            // blast a line. In case of blasting we render this character, that is wrong.
            //
            cchRun = por->_lscch;
            pwchRun = por->_pchBase;

            LONG cch = 0;
            while (cch != cchRun)
            {
                if (WCH_NONREQHYPHEN == *pwchRun)
                    break;
                cch++;
                pwchRun++;
            }
            if (cch != cchRun)
            {
                // Don't blast this line
                _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
            }

            COneRun * porPrev = _listCurrent._pTail;
            while (porPrev != NULL && (!porPrev->IsNormalRun() || porPrev == por))
            {
                porPrev = porPrev->_pPrev;
            }

            // Disambiguate ScriptId
            por->_sid = fl().DisambiguateScript(_pMarkup->GetFamilyCodePage(), 
                por->GetCF()->_lcid, porPrev ? porPrev->_sid : sidDefault, por->_pchBase, &por->_lscch);

            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
        }
    }

    // Ununify sidHan script
    if (por->_sid == sidHan)
    {
        CCcs ccs;
        GetCcs(&ccs, por, _pci->_hdc, _pci, FALSE);
        const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
        const UINT uiFamilyCodePage = _pMarkup->GetFamilyCodePage();

        SCRIPT_IDS sidsFace = 0;
        if (pBaseCcs)
            sidsFace = fc().EnsureScriptIDsForFont(_pci->_hdc, pBaseCcs, FC_SIDS_USEMLANG);
        por->_sid = fl().UnunifyHanScript(uiFamilyCodePage, 
                por->GetCF()->_lcid, sidsFace, por->_pchBase, &por->_lscch);

        // We want Han chars to linebreak with Wide (W) rules.
        por->_brkopt |= fCscWide;

        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);
    }
    
    // Do not blast lines with layout grid.
    if (por->GetCF()->HasLayoutGrid(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        // Vertical align lines with line layout grid
        if (por->GetCF()->HasLineGrid(por->_fInnerCF))
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_VALIGN);
    }

    // Do not blast lines with non default vertical-align attribute.
    if (por->GetCF()->_fNeedsVerticalAlign)
    {
        BOOL fNeedsVAlign = FALSE;
        if (por->GetFF()->HasCSSVerticalAlign() || por->GetCF()->HasVerticalLayoutFlow())
        {
            fNeedsVAlign = (styleVerticalAlignBaseline != por->GetFF()->GetVerticalAlign(por->GetCF()->HasVerticalLayoutFlow()));
        }
        else
        {
            CTreeNode * pNodeParent = por->Branch()->Parent();
            while (pNodeParent)
            {
                const CCharFormat  * pCF = pNodeParent->GetCharFormat();
                const CFancyFormat * pFF = pNodeParent->GetFancyFormat();
                if (pFF->HasCSSVerticalAlign() || pCF->HasVerticalLayoutFlow())
                {
                    fNeedsVAlign = (styleVerticalAlignBaseline != pFF->GetVerticalAlign(pCF->HasVerticalLayoutFlow()));
                    break;
                }
                pNodeParent = pNodeParent->Parent();
            }
        }
        if (fNeedsVAlign)
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST | FLAG_HAS_VALIGN);
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   NeedToEatThisSpace
//
//  Synopsis:   Decide if the current space needs to be eaten. We eat any space
//              after a abspos or aligned site *IF* that site was preceeded by
//              a space too.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::NeedToEatThisSpace(COneRun *porIn)
{
    BOOL fMightFold = FALSE;
    BOOL fFold      = FALSE;
    CElement   *pElementLayout;
    CTreeNode  *pNode;
    COneRun    *por;

    por = FindOneRun(porIn->_lscpBase);
    if (   por == NULL
        && porIn->_lscpBase >= _listCurrent._pTail->_lscpBase
       )
        por = _listCurrent._pTail;

    //
    // TODO: (SujalP, track bug 112335): We will not fold across hidden stuff... need to fix this...
    //
    while(por)
    {
        if (por->_fCharsForNestedLayout)
        {
            Assert(por->_fCharsForNestedElement);
            pNode = por->Branch();
            Assert(pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())));
            pElementLayout = pNode->GetUpdatedLayout( _pci->GetLayoutContext() )->ElementOwner();
            if (!pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
                fMightFold = TRUE;
            else
                break;
        }
        else
            break;
        por = por->_pPrev;
    }

    if (fMightFold)
    {
        if (!por)
        {
            fFold = TRUE;
        }
        else if (!por->_fCharsForNestedElement)
        {
            Assert(por->_pchBase);
            TCHAR ch = por->_pchBase[por->_lscch-1];
            if (   ch == _T(' ')
                || ch == _T('\t')
               )
            {
                fFold = TRUE;
            }
        }
    }

    return fFold;
}

//-----------------------------------------------------------------------------
//
//  Function:   ChunkifyObjectRun
//
//  Synopsis:   Breakup a object run if necessary.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

void
CLineServices::ChunkifyObjectRun(COneRun *por, COneRun **pporOut)
{
    CElement        *pElementLayout;
    CLayout         *pLayout;
    CTreeNode       *pNode;
    BOOL             fInlinedElement;
    BOOL             fIsAbsolute = FALSE;
    LONG             cp     = por->Cp();
    COneRun         *porOut = por;

    Assert(por->_lsCharProps.idObj == LSOBJID_EMBEDDED);
    pNode = por->Branch();
    Assert(pNode);
    pLayout = pNode->GetUpdatedLayout( _pci->GetLayoutContext() );
    Assert(pLayout);
    pElementLayout = pLayout->ElementOwner();
    Assert(pElementLayout);
    fInlinedElement = pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext()));

   _pMeasurer->_fHasNestedLayouts = TRUE;
   
    //
    // Setup all the various flags and counts
    //
    if (fInlinedElement)
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_INLINEDSITES);
    }
    else
    {
        fIsAbsolute = pNode->IsAbsolute((stylePosition)por->GetFF()->_bPositionType);

        if (!fIsAbsolute)
        {
            _lineCounts.AddLineCount(cp, LC_ALIGNEDSITES, por->_lscch);
        }
        else
        {
            //
            // This is the only opportunity for us to measure abspos'd sites
            //
            if (_lsMode == LSMODE_MEASURER)
            {
                _lineCounts.AddLineCount(cp, LC_ABSOLUTESITES, por->_lscch);
                pLayout->SetXProposed(0);
                pLayout->SetYProposed(0);
            }
        }
    }
    _lineFlags.AddLineFlag(cp, FLAG_HAS_EMBED_OR_WBR);

    if (por->_fCharsForNestedRunOwner)
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_NESTED_RO);
        _pMeasurer->_pRunOwner = pLayout;
    }

    if (IsOwnLineSite(por))
    {
        _fSingleSite = TRUE;

        // In edit mode, if we are showing editing glyphs for the ownline site
        // then the only thing on the line will not be the the layout, we will also
        // have the editing glyph on that line. Hence we say that its not a single
        // site line in that case. The other option would have been to give the
        // glyph a line of its own but thats not possible since where will I get
        // a character for it? Done to fix IE5.5 bug 101569.
        if (   _fIsEditable
            && por->_ptp->ShowTreePos()
           )
            _li._fSingleSite = FALSE;
        else
            _li._fSingleSite = TRUE;
        _li._fHasEOP = TRUE;
    }

    if (!fInlinedElement)
    {
        // Since we are not showing this run, lets just anti-synth it!
        por->MakeRunAntiSynthetic();

        // And remember that these chars are white at BOL
        if (IsFirstNonWhiteOnLine(cp))
        {
            AlignedAtBOL(cp, por->_lscch);
        }
    }

    // Do not blast lines with layout grid.
    if (por->GetCF()->HasLayoutGrid(por->_fInnerCF))
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        // Vertical align lines with line layout grid
        if (por->GetCF()->HasLineGrid(por->_fInnerCF))
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_VALIGN);
    }

    // Do not blast lines with non default vertical-align attribute.
    if (por->GetCF()->_fNeedsVerticalAlign)
    {
        BOOL fNeedsVAlign = FALSE;
        if (por->GetFF()->HasCSSVerticalAlign() || por->GetCF()->HasVerticalLayoutFlow())
        {
            fNeedsVAlign = (styleVerticalAlignBaseline != por->GetFF()->GetVerticalAlign(por->GetCF()->HasVerticalLayoutFlow()));
        }
        else
        {
            CTreeNode * pNodeParent = por->Branch()->Parent();
            while (pNodeParent)
            {
                const CCharFormat  * pCF = pNodeParent->GetCharFormat();
                const CFancyFormat * pFF = pNodeParent->GetFancyFormat();
                if (pFF->HasCSSVerticalAlign() || pCF->HasVerticalLayoutFlow())
                {
                    fNeedsVAlign = (styleVerticalAlignBaseline != pFF->GetVerticalAlign(pCF->HasVerticalLayoutFlow()));
                    break;
                }
                pNodeParent = pNodeParent->Parent();
            }
        }
        if (fNeedsVAlign)
            _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST | FLAG_HAS_VALIGN);
    }

    SetRenderingHighlights(por);

    *pporOut = porOut;
}

//+==============================================================================
//
//  Method: GetRenderingHighlights
//
//  Synopsis: Get the type of highlights between these two cp's by going through
//            the array of CRenderStyle
//
//  A 'CRenderStyle' denotes a "non-content-based" way of changing the rendering
// of something. 
//
//-------------------------------------------------------------------------------

HRESULT
CLineServices::GetRenderingHighlights( 
                    int cpLineMin, 
                    int cpLineMax, 
                    CPtrAry<CRenderStyle*> *papHighlight )
{
    int i;
    HighlightSegment* pHighlight;
    CLSRenderer *pRenderer = GetRenderer();

    if( !papHighlight )
        RRETURN(E_INVALIDARG);
    Assert( pRenderer && pRenderer->HasSelection() );

    Assert( papHighlight->Size() == 0 );
    
    for (i = pRenderer->_aryHighlight.Size(), pHighlight = pRenderer->_aryHighlight;
        i > 0 ;
        i --, pHighlight++)
    {
        if ( (  pHighlight->_cpStart <= cpLineMin ) && ( pHighlight->_cpEnd >= cpLineMax) )
        {
            if( papHighlight->Size() > 0 ) 
            {
                for( int j = 0; j < papHighlight->Size(); j++ )
                {                    
                    if( ((*papHighlight)[j])->GetAArenderingPriority() < 
                        pHighlight->_pRenderStyle->GetAArenderingPriority() )
                    {
                        papHighlight->Insert(j, pHighlight->_pRenderStyle);
                        break;
                    }
                }
                if( j == papHighlight->Size() )
                {
                    papHighlight->Append( pHighlight->_pRenderStyle );
                }
            }
            else
            {
                papHighlight->Append( pHighlight->_pRenderStyle );
            }
        }
    }

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: SetRenderingHighlightsCore
//
// Synopsis: Set any 'markup' on this COneRun
//
// NOTE:   marka - currently the only type of Markup is Selection. We see if the given
//         run is selected, and if so we mark-it.
//
//         This used to be called ChunkfiyForSelection. However, under due to the new selection
//         model's use of TreePos's the Run is automagically chunkified for us
//
//------------------------------------------------------------------------------------
void
CLineServices::SetRenderingHighlightsCore(COneRun  *por)
{
    CLSRenderer * pRenderer = GetRenderer();
    Assert(pRenderer && pRenderer->HasSelection());

    CPtrAry<CRenderStyle *> apRenderStyle(Mt(CLineServices_SetRenHighlightScore_apRender_pv));
    int cpMin = por->Cp();
    int cpMax = min(long(pRenderer->_cpSelMax), por->Cp() + por->_lscch);
    if (cpMin < cpMax)
    {
        // If we are not rendering we should do nothing
        Assert(_lsMode == LSMODE_RENDERER);

        // We will not show selection if it is hidden.
        Assert(!por->_fHidden);
        
        GetRenderingHighlights( cpMin, cpMax, &apRenderStyle );

        if ( apRenderStyle.Size() )
        {
            por->Selected(pRenderer, _pFlowLayout, &apRenderStyle);
        }
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   TransformTextRun
//
//  Synopsis:   Do any necessary text transformations.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::TransformTextRun(COneRun *por)
{
    LSERR lserr = lserrNone;
    const CCharFormat* pCF = por->GetCF();
    TCHAR chPrev = WCH_NULL;

    Assert(pCF->IsTextTransformNeeded());

    _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

    if (pCF->_bTextTransform == styleTextTransformCapitalize)
    {
        COneRun *porTemp = FindOneRun(por->_lscpBase - 1);

        // If no run found on this line before this run, then its the first
        // character on this line, and hence needs to be captilaized. This is
        // done implicitly by initializing chPrev to WCH_NULL.
        while (porTemp)
        {
            // If it is anti-synth, then its not shown at all or
            // is not in the flow, hence we ignore it for the purposes
            // of transformations. If it is synthetic then we will need
            // to look at runs before the synthetic to determine the
            // prev character. Hence, we only need to investigate normal runs
            if (porTemp->IsNormalRun())
            {
                // If the previous run had a nested layout, then we will ignore it.
                // The rule says that if there is a layout in the middle of a word
                // then the character after the layout is *NOT* capitalized. If the
                // layout is at the beginning of the word then the character needs
                // to be capitalized. In essence, we completely ignore layouts when
                // deciding whether a char should be capitalized, i.e. if we had
                // the combination:
                // <charX><layout><charY>, then capitalization of <charY> depends
                // only on what <charX> -- ignoring the fact that there is a layout
                // (It does not matter if the layout is hidden, aligned, abspos'd
                // or relatively positioned).
                if (   !porTemp->_fCharsForNestedLayout
                    && porTemp->_synthType == SYNTHTYPE_NONE
                   )
                {
                    Assert(porTemp->_ptp->IsText());
                    chPrev = porTemp->_pchBase[porTemp->_lscch - 1];
                    break;
                }
            }
            porTemp = porTemp->_pPrev;
        }
    }

    if (pCF->_fSmallCaps)
    {
        por->ConvertToSmallCaps(chPrev);
        pCF = por->GetCF(); // _pCF can be cloned inside ConvertToSmallCaps()
    }

    por->_pchBase = (TCHAR *)TransformText(por->_cstrRunChars, por->_pchBase, por->_lscch,
                                           pCF->_bTextTransform, chPrev);
    if (por->_pchBase == NULL)
        lserr = lserrOutOfMemory;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CheckForPassword
//
//  Synopsis:   If text transformation is necessary for the run, then do it here.
//
//  Returns:    lserr.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::CheckForPassword(COneRun  *por)
{
    static TCHAR zwnbsp = WCH_ZWNBSP;

    LSERR lserr = lserrNone;
    CStr strPassword;
    TCHAR * pchPassword;
    HRESULT hr;
    
    Assert(_chPassword);

    for (LONG i = 0; i < por->_lscch; i++)
    {
        pchPassword = (   (IsZeroWidthChar(por->_pchBase[i]) && !IsCombiningMark(por->_pchBase[i])) 
                       || IsLowSurrogateChar(por->_pchBase[i]))
                      ? &zwnbsp : &_chPassword;
        hr = strPassword.Append(pchPassword, 1);
        if (hr != S_OK)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
    }
    por->_pchBase = por->SetString(strPassword);
    if (por->_pchBase == NULL)
        lserr = lserrOutOfMemory;
    
Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustForNavBRBug (member)
//
//  Synopsis:   Navigator will break between a space and a BR character at
//              the end of a line if the BR character, when it's width is
//              treated like that of a space character, will cause line to
//              overflow. Necessary for compat.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::AdjustCpLimForNavBRBug(
    LONG xWrapWidth,        // IN
    LSLINFO *plslinfo )     // IN/OUT
{
    LSERR lserr = lserrNone;

    // Do not support this NAV bug in vertical layout.
    if (_pFlowLayout->ElementOwner()->HasVerticalLayoutFlow())
        goto Cleanup;
        
    // check 1: (a) We must not be in a PRE and (b) the line
    // must have at least three chars.
    if (   !_pPFFirst->HasPre(_fInnerPFFirst)
        && _cpLim - plslinfo->cpFirstVis >= 3)
    {
        COneRun *por = FindOneRun(_lscpLim - 1);
        if (!por)
            goto Cleanup;

        // check 2: Line must have ended in a BR
        if (   por->_ptp->IsEndNode()
            && por->Branch()->Tag() == ETAG_BR
           )
        {
            // check 3: The BR char must be preceeded by a space char.

            // Go to the begin BR
            por = por->_pPrev;
            if (!(   por
                  && por->IsAntiSyntheticRun()
                  && por->_ptp->IsBeginNode()
                  && por->Branch()->Tag() == ETAG_BR)
               )
                goto Cleanup;

            // Now go one more beyond that to check for the space
            do
            {
                por = por->_pPrev;
            }
            while (por && por->IsAntiSyntheticRun() && !por->_fCharsForNestedLayout);
            if (!por)
                goto Cleanup;

            // NOTE (SujalP + CThrash): This will not work if the space was
            // in, say, a reverse object. But then this *is* a NAV bug. If
            // somebody complains vehemently, then we will fix it...
            if (   por->IsNormalRun()
                && por->_ptp->IsText()
                && WCH_SPACE == por->_pchBase[por->_lscch - 1]
               )
            {
                if (_fMinMaxPass)
                    ((CDisplay *)_pMeasurer->_pdp)->SetNavHackPossible();

                // check 4: must have overflowed, because the width of a BR
                // character is included in _xWidth
                if (!_fMinMaxPass && _li._xWidth > xWrapWidth)
                {
                    // check 5:  The BR alone cannot be overflowing.  We must
                    // have at least one pixel more to break before the BR.

                    HRESULT hr;
                    LSTEXTCELL lsTextCell;

                    hr = THR( QueryLineCpPpoint( _lscpLim, FALSE, NULL, &lsTextCell ) );

                    if (   S_OK == hr
                        && (_li._xWidth - lsTextCell.dupCell) > xWrapWidth)
                    {
                        // Break between the space and the BR.  Yuck! Also 2
                        // here because one for open BR and one for close BR
                        _cpLim -= 2;

                        // The char for open BR was antisynth'd in the lscp
                        // space, so just reduce by one char for the close BR.
                        _lscpLim--;
                    }
                }
            }
        }
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustForRelElementAtEnd (member)
//
//  Synopsis: In our quest to put as much on the line as possible we will end up
//      putting the begin splay for a relatively positioned element on this
//      line(the first character in this element will be on the next line)
//      This is not really acceptable for positioning purposes and hence
//      we detect that this happened and chop off the relative element
//      begin splay (and any chars anti-synth'd after it) so that they will
//      go to the next line. (Look at bug 54162).
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
CLineServices::AdjustForRelElementAtEnd()
{
    //
    // By looking for _lscpLim - 1, we find the last but-one-run. After
    // this run, there will possibly be antisynthetic runs (all at the same
    // lscp -- but different cp's -- as the last char of this run) which
    // have ended up on this line. It is these set of antisynthetic runs
    // that we have to investigate to find any ones which begin a relatively
    // positioned element. If we do find one, we will stop and modify cpLim
    // so as to not include the begin splay and any antisynth's after it.
    //
    COneRun *por = FindOneRun(_lscpLim - 1);

    Assert(por);

    //
    // Go to the start of the antisynth chunk (if any).
    //
    por = por->_pNext;

    //
    // Walk while we have antisynth runs
    //
    while (   por
           && por->IsAntiSyntheticRun()
           && _lscpLim == por->_lscpBase
          )
    {
        //
        // If it begins a relatively positioned element, then we want to
        // stop and modify the cpLim
        //
        if (   por->_ptp->IsBeginElementScope()
            && por->GetCF()->IsRelative(por->_fInnerCF))
        {
            _cpLim = por->Cp();
            break;
        }
        Assert(por->_lscch == 1);
        por = por->_pNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   ComputeWhiteInfo (member)
//
//  Synopsis:   A post pass for the CMeasurer to compute whitespace
//              information (_cchWhite and _xWhite) on the associated
//              CLineFull object (_li).
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::ComputeWhiteInfo(LSLINFO *plslinfo, LONG *pxMinLineWidth, DWORD dwlf,
                                LONG durWithTrailing, LONG durWithoutTrailing)
{
    HRESULT hr = S_OK;
    BOOL  fInclEOLWhite = _pPFFirst->HasInclEOLWhite(_fInnerPFFirst);
    CMarginInfo *pMarginInfo = (CMarginInfo*)_pMarginInfo;

    // Note that cpLim is no longer an LSCP.  It's been converted by the
    // caller.

    const LONG cpLim = _cpLim;
    CTxtPtr txtptr( _pMarkup, cpLim );
    const TCHAR chBreak = txtptr.GetPrevChar();

    LONG  lscpLim = _lscpLim - 1;
    COneRun *porLast = FindOneRun(lscpLim);

    WHEN_DBG(LONG cchWhiteTest=0);


    Assert( _cpLim == _cpStart + _li._cch );

    //
    // Compute all the flags for the line
    //
    Assert(dwlf == _lineFlags.GetLineFlags(cpLim));
    if (dwlf)
    {
        _li._fHasEmbedOrWbr       = (dwlf & FLAG_HAS_EMBED_OR_WBR) ? TRUE : FALSE;
        _li._fHasNestedRunOwner   = (dwlf & FLAG_HAS_NESTED_RO)    ? TRUE : FALSE;
        _li._fHasBackground       = (dwlf & FLAG_HAS_BACKGROUND)   ? TRUE : FALSE;
        _li._fHasNBSPs            = (dwlf & FLAG_HAS_NBSP)         ? TRUE : FALSE;
        _fHasRelative             = (dwlf & FLAG_HAS_RELATIVE)     ? TRUE : FALSE;
        _fFoundLineHeight         = (dwlf & FLAG_HAS_LINEHEIGHT)   ? TRUE : FALSE;
        pMarginInfo->_fClearLeft |= (dwlf & FLAG_HAS_CLEARLEFT)    ? TRUE : FALSE;
        pMarginInfo->_fClearRight|= (dwlf & FLAG_HAS_CLEARRIGHT)   ? TRUE : FALSE;
        _fHasMBP                  = (dwlf & FLAG_HAS_MBP)          ? TRUE : FALSE;
        _fHasVerticalAlign        = (dwlf & FLAG_HAS_VALIGN)       ? TRUE : FALSE;
        _li._fHasBreak            = (dwlf & FLAG_HAS_A_BR)         ? TRUE : FALSE;
        _fHasInlinedSites         = (dwlf & FLAG_HAS_INLINEDSITES) ? TRUE : FALSE;
        _li._fHasInlineBgOrBorder = (dwlf & FLAG_HAS_INLINE_BG_OR_BORDER) ? TRUE : FALSE;
        _fLineWithHeight         |= (dwlf & FLAG_HAS_NODUMMYLINE)  ? TRUE : FALSE;
   }
    else
    {
        _li._fHasEmbedOrWbr       = FALSE;
        _li._fHasNestedRunOwner   = FALSE;
        _li._fHasBackground       = FALSE;
        _li._fHasNBSPs            = FALSE;
        _fHasRelative             = FALSE;
        _fFoundLineHeight         = FALSE;
      //pMarginInfo->_fClearLeft |= FALSE;
      //pMarginInfo->_fClearRight|= FALSE;
        _fHasMBP                  = FALSE;
        _fHasVerticalAlign        = FALSE;
        _li._fHasBreak            = FALSE;
        _fHasInlinedSites         = FALSE;
        _li._fHasInlineBgOrBorder = FALSE;
      //_fLineWithHeight         |= FALSE;
    }
    
    // Lines containing \r's also need to be marked _fHasBreak
    if (   !_li._fHasBreak
        && _fExpectCRLF
        && plslinfo->endr == endrEndPara
       )
    {
        _li._fHasBreak = TRUE;
    }
    
    _pFlowLayout->_fContainsRelative |= _fHasRelative;

    // If all we have is whitespaces till here then mark it as a dummy line
    if (IsDummyLine(cpLim))
    {
        const LONG cchHidden = _lineCounts.GetLineCount(cpLim, LC_HIDDEN);
        const LONG cch = (_cpLim - _cpStart) - cchHidden;

        _li._fDummyLine = TRUE;
        _li._fForceNewLine = FALSE;

        // If this line was a dummy line because all it contained was hidden
        // characters, then we need to mark the entire line as hidden.  Also
        // if the paragraph contains nothing (except a blockbreak), we also
        // need the hide the line.  Note that LI's are an exception to this
        // rule -- even if all we have on the line is a blockbreak, we don't
        // want to hide it if it's an LI. (LI's are excluded in the dummy
        // line check).
        if ( cchHidden
             && (   cch == 0
                 || _li._fFirstInPara
                )
           )
        {
            _li._fHidden = TRUE;
            _li._yBeforeSpace = 0;
        }
    }

    //
    // Also find out all the relevant counts
    //
    _cAbsoluteSites = _lineCounts.GetLineCount(cpLim, LC_ABSOLUTESITES);
    _cAlignedSites  = _lineCounts.GetLineCount(cpLim, LC_ALIGNEDSITES);
    _li._fHasAbsoluteElt = !!_cAbsoluteSites;
    _li._fHasAligned     = !!_cAlignedSites;

    //
    // And the relevant values
    //
    if (_fFoundLineHeight)
    {
        _lMaxLineHeight = max(plslinfo->dvpMultiLineHeight,
                              _lineCounts.GetMaxLineValue(cpLim, LC_LINEHEIGHT));
    }
    
    //
    // Consume trailing WCH_NOSCOPE/WCH_BLOCKBREAK characters.
    //

    _li._cchWhite = 0;
    _li._xWhite = 0;

    if (   porLast
        && porLast->_ptp->IsNode()
        && porLast->Branch()->Tag() != ETAG_BR
       )
    {
        // NOTE (cthrash) We're potentially tacking on characters but are
        // not included their widths.  These character can/will have widths in
        // edit mode.  The problem is, LS never measured them, so we'd have
        // to measure them separately.

        CTxtPtr txtptrT( txtptr );
        long dcch;

        // If we have a site that lives on it's own line, we may have stopped
        // fetching characters prematurely.  Specifically, we may have left
        // some space characters behind.

        while (TEXT(' ') == txtptrT.GetChar())
        {
            if (!txtptrT.AdvanceCp(1))
                break;
        }
        dcch = txtptrT.GetCp() - txtptr.GetCp();

        _li._cchWhite += (SHORT)dcch;
        _li._cch += dcch;
    }

    WHEN_DBG(cchWhiteTest = _li._cchWhite);

    //
    // Compute _cchWhite and _xWhite of line
    //
    if (!fInclEOLWhite)
    {
        BOOL  fDone = FALSE;
        TCHAR ch;
        COneRun *por = porLast;
        LONG index = por ? lscpLim - por->_lscpBase : 0;
        WHEN_DBG (CTxtPtr txtptrTest(txtptr));

        while (por && !fDone)
        {
            if (por->_fCharsForNestedLayout)
            {
                fDone = TRUE;
                break;
            }

            if (por->IsNormalRun())
            {
                for(LONG i = index; i >= 0; i--)
                {
                    ch = por->_pchBase[i];
                    if (   IsWhite(ch)
                        // If its a no scope char and we are not showing it then
                        // we treat it like a whitespace.
                       )
                    {
                        _li._cchWhite++;
                        txtptr.AdvanceCp(-1);
                    }
                    else
                    {
                        fDone = TRUE;
                        break;
                    }
                }
            }
            por = por->_pPrev;
            index = por ? por->_lscch - 1 : 0;
        }

#if DBG==1            
        {
            long durWithTrailingDbg, durWithoutTrailingDbg;
            LSERR lserr = GetLineWidth( &durWithTrailingDbg,
                                        &durWithoutTrailingDbg );
            Assert(lserr || durWithTrailingDbg == durWithTrailing);
            Assert(lserr || durWithoutTrailingDbg == durWithoutTrailing);
        }
#endif

        _li._xWhite  = durWithTrailing - durWithoutTrailing;
        _li._xWidth -= _li._xWhite;
        
        if ( porLast && chBreak == WCH_NODE && !_fScanForCR )
        {
            CTreePos *ptp = porLast->_ptp;

            if (   ptp->IsEndElementScope()
                && ptp->Branch()->Tag() == ETAG_BR
               )
            {
                LONG cp = CPFromLSCP( plslinfo->cpFirstVis );
                _li._fEatMargin = LONG(txtptr.GetCp()) == cp + 1;
            }
        }
    }
    else if (_fScanForCR)
    {
        HRESULT hr;
        LSTEXTCELL  lsTextCell;
        CTxtPtr tp(_pMarkup, cpLim);
        TCHAR ch = tp.GetChar();
        TCHAR chPrev = tp.GetPrevChar();
        BOOL fDecWidth = FALSE;
        LONG cpJunk;
        
        if (   chPrev == _T('\n')
            || chPrev == _T('\r')
           )
        {
            fDecWidth = TRUE;
        }
        else if (ch == WCH_NODE)
        {
            CTreePos *ptpLast = _pMarkup->TreePosAtCp(cpLim - 1, &cpJunk);

            if (   ptpLast->IsEndNode()
                && (   ptpLast->Branch()->Tag() == ETAG_BR
                    || IsPreLikeNode(ptpLast->Branch())
                   )
               )
            {
                fDecWidth = TRUE;
            }
        }

        if (fDecWidth)
        {
            // The width returned by LS includes the \n, which we don't want
            // included in CLine::_xWidth.
            hr = THR( QueryLineCpPpoint( _lscpLim - 1, FALSE, NULL, &lsTextCell ) );
            if (!hr)
            {
                _li._xWidth -= lsTextCell.dupCell; // note _xWhite is unchanged
                if (pxMinLineWidth)
                    *pxMinLineWidth -= lsTextCell.dupCell;
            }
        }
    }
    else
    {
        _li._cchWhite = plslinfo->cpFirstVis - _cpStart;
    }

    //
    // If the white at the end of the line meets the white at the beginning
    // of a line, then we need to shift the BOL white to the EOL white.
    //

    if (_cWhiteAtBOL + _li._cchWhite >= _li._cch)
    {
        _li._cchWhite = _li._cch;
    }

    //
    // Find out if the last char on the line has any overhang, and if so set it on
    // the line.
    //
    if (_fHasOverhang)
    {
        CTreeNode *pNode = _pFlowLayout->GetFirstBranch();
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        styleOverflow so = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);

        if (   so == styleOverflowHidden
            || so == styleOverflowNotSet
           )
        {
            COneRun *por = porLast;

            while (por)
            {
                if (por->_ptp->IsText())
                {
                    _li._xLineOverhang = por->_xOverhang;
                    if (pxMinLineWidth)
                        *pxMinLineWidth += por->_xOverhang;
                    break;
                }
                else if(por->_fCharsForNestedLayout)
                    break;
                // Continue for synth and antisynth runs
                por = por->_pPrev;
            }
        }
    }
    
    // Fold the S_FALSE case in -- don't propagate.
    hr = SUCCEEDED(hr) ? S_OK : hr;
    if (hr)
        goto Cleanup;

    DecideIfLineCanBeBlastedToScreen(_cpStart + _li._cch - _li._cchWhite, dwlf);

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   DecideIfLineCanBeBlastedToScreen
//
//  Synopsis:   Decides if it is possible for a line to be blasted to screen
//              in a single shot.
//
//  Params:     The last cp in the line
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::DecideIfLineCanBeBlastedToScreen(LONG cpEndLine, DWORD dwlf)
{
    // By default you cannot blast a line to the screen
    _li._fCanBlastToScreen = FALSE;

#if DBG==1
    if (IsTagEnabled(tagLSNoBlast))
        goto Cleanup;
#endif

    //
    // 0) If we have eaten a space char or have fontlinking, we cannot blast
    //    line to screen
    //
    if (dwlf & FLAG_HAS_NOBLAST)
        goto Cleanup;

    //
    // 1) No justification
    //
    if (_pPFFirst->GetBlockAlign(_fInnerPFFirst) == htmlBlockAlignJustify)
        goto Cleanup;

    //
    // 2) Only simple LTR
    //
    if (_pBidiLine != NULL || _li.IsRTLLine() || _pFlowLayout->IsRTLFlowLayout())
        goto Cleanup;

    //
    // 3) Cannot handle passwords for blasting.
    //
    if (_chPassword)
        goto Cleanup;

    //
    // 4) If there is a glyph on the line then do not blast.
    //
    if (_fGlyphOnLine)
        goto Cleanup;

    //
    // 5) There's IME highlighting, so we can't blast,
    //    or funny callback for getruncharwidths
    //
    if (_fSpecialNoBlast)
        goto Cleanup;

    //
    // None of the restrictions apply, lets blast this to the screen!
    //
    _li._fCanBlastToScreen = TRUE;

Cleanup:
    return;
}

LONG
CLineServices::RememberLineHeight(LONG cp, const CCharFormat *pCF, const CBaseCcs *pBaseCcs)
{
    long lAdjLineHeight;
    
    AssertSz(pCF->_cuvLineHeight.GetUnitType() != CUnitValue::UNIT_PERCENT,
             "Percent units should have been converted to points in ApplyInnerOuterFormats!");
    
    // If there's no height set, get out quick.
    if (pCF->_cuvLineHeight.IsNull())
    {
        lAdjLineHeight = pBaseCcs->_yHeight;
    }

    // Apply the CSS Attribute LINE_HEIGHT
    else
    {
        const CUnitValue *pcuvUseThis = &pCF->_cuvLineHeight;
        long lFontHeight = 1;
        
        if (pcuvUseThis->GetUnitType() == CUnitValue::UNIT_FLOAT)
        {
            CUnitValue cuv;
            cuv = pCF->_cuvLineHeight;
            cuv.ScaleTo ( CUnitValue::UNIT_EM );
            pcuvUseThis = &cuv;
            lFontHeight = pCF->GetHeightInTwips( _pFlowLayout->Doc() );
        }

        lAdjLineHeight = pcuvUseThis->YGetPixelValue(_pci, 0, lFontHeight );
        NoteLineHeight(cp, lAdjLineHeight);
    }

    if (pCF->HasLineGrid(TRUE))
    {
        _lineFlags.AddLineFlag(cp, FLAG_HAS_NOBLAST);
        lAdjLineHeight = GetClosestGridMultiple(GetLineGridSize(), lAdjLineHeight);
        NoteLineHeight(cp, lAdjLineHeight);
    }

    return lAdjLineHeight;
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignObjectsFast
//
//  Synopsis:   Process all vertically aligned objects and adjust the line
//              height.
//              Fast version - not used in case of CSS:vertical-align.
//
//-------------------------------------------------------------------------
#pragma warning(disable:4189) // local variable initialized but not used 
#pragma warning(disable:4701)
void
CLineServices::VerticalAlignObjectsFast(CLSMeasurer& lsme, long xLineShift)
{
    const LONG  cchPreChars = lsme._fMeasureFromTheStart ? 0 : lsme._cchPreChars;
    CTreePos  * ptpStart;
    LONG        cch;
    LONG        cchAdvanceStart;
    LONG        cchAdvance;
    LONG        cchNewAdvance;
    BOOL        fDisplayNone = FALSE;
    BOOL        fFastProcessing;
    COneRun   * porHead;
    COneRun   * por;
    VAOFINFO    vaoi;
        
    // Initialize the constants in the VAOINFO structure
    vaoi._pElementFL  = _pFlowLayout->ElementOwner();
    vaoi._pFL         = _pFlowLayout;
    vaoi._xLineShift  = xLineShift;
    
    // Now initialize the loop specific vars
    vaoi._fMeasuring   = TRUE;
    vaoi._fPositioning = FALSE;
    vaoi._yTxtAscent   = _li._yHeight - _li._yDescent;
    vaoi._yTxtDescent  = _li._yDescent;
    vaoi._yDescent     = _li._yDescent;
    vaoi._yAscent      = vaoi._yTxtAscent;
    vaoi._yAbsHeight   = 0;
    vaoi._atAbs        = htmlControlAlignNotSet;
    vaoi._xWidthSoFar  = 0;
    vaoi._yMaxHeight   = LONG_MIN;
    
    // Setup so that we can use the one run list as soon as we are
    // done with the prechars.
    por = _listCurrent._pHead;
    while (   por
           && por->IsSyntheticRun()
          )
        por = por->_pNext;
    porHead = por;

    // Based on the prechars and blast status decide if we can do fast processing or not
    // and setup the vars appropriately
    if (cchPreChars == 0 && _li._fCanBlastToScreen)
    {
        ptpStart = porHead->_ptp;
        cchAdvanceStart = porHead->_lscch;
    }
    else
    {
        LONG ich;
        ptpStart = _pMarkup->TreePosAtCp(lsme.GetCp() - _li._cch - cchPreChars, &ich, TRUE);
        Assert(ptpStart);
        cchAdvanceStart = min(long(_li._cch + cchPreChars), ptpStart->GetCch() - ich);
    }

    // first pass we measure the line's baseline and height
    // second pass we set the rcProposed of the site relative to the line.
    while (vaoi._fMeasuring || vaoi._fPositioning)
    {
        por = porHead;
        fFastProcessing = cchPreChars == 0 && _li._fCanBlastToScreen;
        
        cch = _li._cch + cchPreChars;
        vaoi._ptp = ptpStart;
        lsme.Advance(-cch, vaoi._ptp);
        cchAdvance = cchAdvanceStart;
        vaoi._pCF = NULL;

        while(cch)
        {
            vaoi._cp = lsme.GetCp();
            if (fFastProcessing)
            {
                Assert(vaoi._ptp == por->_ptp);
                if (por->_fCharsForNestedLayout)
                {
                    vaoi._pNode = vaoi._ptp->Branch();
                    vaoi._pLayout = vaoi._pNode->GetUpdatedLayout( _pci->GetLayoutContext() );
                    vaoi._lscp = por->_lscpBase;
                    vaoi._por = por;
                    Assert(vaoi._pLayout);
                }
                else
                {
                    vaoi._pNode = por->Branch();
                    vaoi._pLayout = NULL;
                }
            }
            else
            {
                if(vaoi._ptp && vaoi._ptp->IsBeginElementScope())
                {
                    vaoi._pNode = vaoi._ptp->Branch();
                    vaoi._pLayout = (   vaoi._pElementFL != vaoi._pNode->Element()
                                     && vaoi._pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()))
                                    ) 
                                    ? vaoi._pNode->GetUpdatedLayout( _pci->GetLayoutContext() )
                                    : NULL;
                    vaoi._lscp = -1;
                    vaoi._por = NULL;
                }
                else if(vaoi._ptp)
                {
                    vaoi._pNode = vaoi._ptp->GetBranch();
                    vaoi._pLayout = NULL;
                }
		else
		{
                    vaoi._pNode = NULL;
		    vaoi._pLayout = NULL;
		    break;
		}
            }
            
            vaoi._pElementLayout = vaoi._pLayout ? vaoi._pNode->Element() : NULL;
            vaoi._pCF = vaoi._pNode->GetCharFormat( LC_TO_FC(_pci->GetLayoutContext()));
            fDisplayNone = vaoi._pCF->IsDisplayNone();

            // If we are transisitioning from a normal chunk to relative or
            // relative to normal chunk, add a new chunk to the line. Relative
            // elements can end in the prechar's so look for transition in
            // prechar's too.
            if(vaoi._fMeasuring && _fHasRelative && !fDisplayNone
                && (    vaoi._ptp->IsBeginElementScope()
                    ||  vaoi._ptp->IsText()
                    ||  (   vaoi._ptp->IsEndElementScope()
                            &&  cch > (_li._cch - (lsme._fMeasureFromTheStart ? lsme._cchPreChars : 0)))
                   )
              )
            {
                TestForTransitionToOrFromRelativeChunk(
                    lsme.GetCp(),
                    vaoi._pCF->IsRelative(SameScope(vaoi._pNode, vaoi._pElementFL)),
                    FALSE /*fForceChunk*/,
                    lsme.CurrBranch(),
                    vaoi._pElementLayout);
            }

            // If the current branch is a site and not the current CTxtSite
            if (vaoi._pLayout)
            {
                if (!fDisplayNone )
                {
                    VerticalAlignOneObjectFast(lsme, &vaoi);
                }

                Assert(vaoi._pElementLayout);
                
                //  setup cchAdvance to skip the current layout
                cchAdvance = lsme.GetNestedElementCch(vaoi._pElementLayout, &vaoi._ptp);
                Assert(vaoi._ptp);
            }
            else if (vaoi._pCF->HasLineGrid(FALSE))
            {
                vaoi._yMaxHeight = max(vaoi._yMaxHeight, GetClosestGridMultiple(GetLineGridSize(), _li._yHeight));
            }

            cch -= cchAdvance;
            if (cch != 0)
            {
                if (fFastProcessing)
                {
                    vaoi._xWidthSoFar += por->_xWidth;
                    do
                    {
                        por = por->_pNext;
                    } while (por && por->IsSyntheticRun());
                    if (por)
                    {
                        vaoi._ptp = por->_ptp;
                        cchNewAdvance = por->_lscch;
                    }
                    else
                    {
                        fFastProcessing = FALSE;
                        vaoi._ptp = vaoi._ptp->NextTreePos();
                        cchNewAdvance = vaoi._ptp->GetCch();
                    }
                }
                else
                {
                    if (   _li._fCanBlastToScreen
                        && por
                        && lsme.GetCp() + cchAdvance == por->Cp())
                    {
                        fFastProcessing = TRUE;
                        vaoi._ptp = por->_ptp;
                        cchNewAdvance = por->_lscch;
                    }
                    else
                    {
			if(vaoi._ptp)
                            vaoi._ptp = vaoi._ptp->NextTreePos();
			if(vaoi._ptp)
	                    cchNewAdvance = vaoi._ptp->GetCch();
			else
                        {
                            cchNewAdvance = 0;
                            cchAdvance = 0;
                            break;
                        }
                    }
                }
            }
            else
            {
                cchNewAdvance = 0;
                vaoi._ptp = NULL;
            }
            lsme.Advance(cchAdvance, vaoi._ptp);
            vaoi._ptp = lsme.GetPtp();
            cchAdvance = min(cch, cchNewAdvance);
        }

        // Add the final chunk to line with relative if there is text left
        if (vaoi._fMeasuring && _fHasRelative && !fDisplayNone && 
            lsme.GetLastCp() > _cpLastChunk)
        {
            TestForTransitionToOrFromRelativeChunk(
                lsme.GetLastCp(),
                vaoi._pCF ? vaoi._pCF->IsRelative(SameScope(vaoi._pNode, vaoi._pElementFL))
                          : TRUE,  // _pCF is NULL if we failed to enter the loop
                TRUE /*fForceChunk*/,
                lsme.CurrBranch(),
                vaoi._pCF ? vaoi._pElementLayout : NULL);
        }

        // We have just finished measuring, update the line's ascent and descent.
        if(vaoi._fMeasuring)
        {
            // If we have ALIGN_TYPEABSBOTTOM or ALIGN_TYPETOP, they do not contribute
            // to ascent or descent based on the baseline
            if(vaoi._yAbsHeight > vaoi._yAscent + vaoi._yDescent)
            {
                if (vaoi._yAscent == 0 && vaoi._yDescent == 0)
                {
                    // Always add to ascent if there is not content but
                    // abs-aligned object
                    vaoi._yAscent = vaoi._yAbsHeight;
                }
                else if(vaoi._atAbs == htmlControlAlignAbsMiddle)
                {
                    LONG yDiff = vaoi._yAbsHeight - vaoi._yAscent - vaoi._yDescent;
                    vaoi._yAscent += (yDiff + 1) / 2;
                    vaoi._yDescent += yDiff / 2;
                }
                else if(vaoi._atAbs == htmlControlAlignAbsBottom)
                {
                    vaoi._yAscent = vaoi._yAbsHeight - vaoi._yDescent;
                }
                else
                {
                    vaoi._yDescent = vaoi._yAbsHeight - vaoi._yAscent;
                }
            }

            // now update the line height
            _li._yHeight = vaoi._yAscent + vaoi._yDescent;
            _li._yDescent = vaoi._yDescent;
            
            // Only do this if there is a layout-grid-line used somewhere.
            if (vaoi._yMaxHeight != LONG_MIN)
            {
                LONG lHeight = max(vaoi._yMaxHeight, _li._yHeight);
                _li._yDescent += (lHeight - _li._yHeight) / 2;
                _li._yHeight = lHeight;
            }

            // Without this line, line heights specified through
            // styles would override the natural height of the
            // image. This would be cool, but the W3C doesn't
            // like it. Absolute & aligned sites do not affect
            // line height.
            if(_fHasInlinedSites)
                _fFoundLineHeight = FALSE;

            Assert(_li._yHeight >= 0);

            // Allow last minute adjustment to line height, we need
            // to call this here, because when positioning all the
            // site in line for the display tree, we want the correct
            // YTop.
            AdjustLineHeight();

            // And now the positioning pass
            vaoi._fMeasuring = FALSE;
            vaoi._fPositioning = TRUE;
        }
        else
        {
            vaoi._fPositioning = FALSE;
        }
    }
}
#pragma warning(default:4701)
#pragma warning(default:4189) // local variable initialized but not used 

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignOneObjectFast
//
//  Synopsis:   VAlign one object in a line.
//              Fast version - not used in case of CSS:vertical-align.
//
//-------------------------------------------------------------------------
void
CLineServices::VerticalAlignOneObjectFast(CLSMeasurer& lsme, VAOFINFO *pvaoi)
{
    BOOL  fAbsolute;
    LONG  yTopMargin,   yBottomMargin;
    long  xLeftMargin,  xRightMargin;
    const CFancyFormat *pFF;

    MtAdd( Mt(CLineServices_VerticalAlignOneObjectFast), +1, 0 );

    fAbsolute = pvaoi->_pNode->IsAbsolute(LC_TO_FC(_pci->GetLayoutContext()));
    if (!(   fAbsolute
          || pvaoi->_pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext()))
         )
       )
        goto Cleanup;
    
    pFF = pvaoi->_pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
    Assert(fAbsolute || pvaoi->_pElementLayout->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())));
    pvaoi->_pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    // Do the horizontal positioning. We can do it either during
    // measuring or during vertical positioning. We arbitrarily
    // chose to do it during measuring.
    if (pvaoi->_fMeasuring)
    {
        LONG xPosOfCp;
        BOOL fSubtractWidthFromXProposed = FALSE;
        
        if (!fAbsolute || pFF->_fAutoPositioned)
        {
            LONG lscp = pvaoi->_lscp == -1 ? LSCPFromCP(pvaoi->_cp) : pvaoi->_lscp;
            BOOL  fRTLDisplay = _pFlowLayout->IsRTLFlowLayout();
            BOOL  fRTLFlow = fRTLDisplay;
            
            //
            // If editable, then the char at the above computed lscp
            // might be the glyph for that layout rather than the layout
            // itself. To do this right, we need to we need to find the
            // run at that lscp, and if it is a glyph-synthetic run then
            // we need to go to the next run which contains the nested
            // layout and look at its lscp.
            //
            if (_fIsEditable && !fAbsolute)
            {
                COneRun *por = FindOneRun(lscp);
                if (   por
                    && por->IsSyntheticRun()
                    && por->_synthType == SYNTHTYPE_GLYPH
                   )
                {
                    por = por->_pNext;

                    //
                    // Check that this run exists, and has nested layout
                    // and that the nested layout is indeed the one we
                    // are hunting for.
                    //
                    Assert(por);
                    Assert(por->_fCharsForNestedElement);
                    Assert(por->_fCharsForNestedLayout);
                    Assert(por->_ptp->Branch() == pvaoi->_pNode);
                    lscp = por->_lscpBase;
                }
            }

            xPosOfCp = _li._fCanBlastToScreen ? pvaoi->_xWidthSoFar : CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlow);

#if DBG==1
            {
                BOOL fRTLFlowDbg = fRTLDisplay;
                Assert(xPosOfCp == CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlowDbg));
                Assert(fRTLFlow == fRTLFlowDbg);
            }
#endif

            if ((!!_li._fRTLLn) != fRTLFlow)
            {
                // Postpone flow adjustment for absolute objects. Their size is not updated yet.

                //TODO (dmitryt, track bug 112318) I see that fSubtractWidthFromXProposed is used below after we 
                //calculated the actual width of abspositioned object. I think I can move that 
                //calculation in front of this and get rid of the flag.
                if (fAbsolute)
                {
                    fSubtractWidthFromXProposed = TRUE; 
                }
                else
                {
                    long xObjectWidth = pvaoi->_pLayout->GetApparentWidth();
                    xPosOfCp -= xObjectWidth;
                }
            }

            if (pvaoi->_pCF->HasCharGrid(FALSE))
            {
                long xWidth;
                _pMeasurer->GetSiteWidth(pvaoi->_pNode, pvaoi->_pLayout, _pci, FALSE, _xWidthMaxAvail, &xWidth);
                xPosOfCp += (GetClosestGridMultiple(GetCharGridSize(), xWidth) - xWidth)/2;
            }

            // absolute margins are added in CLayout::HandlePositionRequest
            // due to reverse flow issues.
            if(!fAbsolute)
            {
                if (!_li._fRTLLn)
                    xPosOfCp += xLeftMargin;
                else
                    xPosOfCp += xRightMargin;
            }
            
            pvaoi->_pLayout->SetXProposed(xPosOfCp);
        }
        else
        {
            xPosOfCp = 0;
        }

        if (fAbsolute)
        {
            // NOTE: (paulnel) What about when the left or right has been specified and the width is auto?
            //                  The xPos needs to be adjusted to properly place this case.

            // fix for #3214, absolutely positioned sites with width auto
            // need to be measure once we know the line shift, since their
            // size depends on the xPosition in the line.

            // NOTE: (dmitryt)
            //      This is the only place where we CalcSize absolutely positioned 
            //      objects that were on the current line. These objects were taken out during 
            //      normal MeasureLine pass, because they don't participate in line width. 
            //      Now we want to measure them. When this function will be called for 
            //      positioning pass (pvaoi->fPositioning==true) we will add/position their 
            //      dispnodes accordingly. So here is the main place where we measure/position 
            //      abspos objects.
            //      I think the comment for bug 3214 was intended for abspos'ed objects without
            //      horizontal position specified. Those have left=(x-position-of-their-cp-in-the-line).
            long xWidth;
            _pMeasurer->GetSiteWidth(pvaoi->_pNode, pvaoi->_pLayout, _pci, TRUE, _xWidthMaxAvail, &xWidth );

            // Subtract object width from XProposed if needed, now that we know the width
            if (fSubtractWidthFromXProposed)
            {
                xPosOfCp -= xWidth;
                pvaoi->_pLayout->SetXProposed(xPosOfCp);
            }
        }
    } // if (fMeasuring)

    if(!fAbsolute)
    {
        htmlControlAlign atSite;
        CSize            size;
        LONG             yObjHeight;
        LONG             yTmpAscent  = 0;
        LONG             yTmpDescent = 0;
        LONG             yProposed   = 0;
        LONG             lBorderSpace;
        LONG             lVPadding   = 0; 

        if (    pvaoi->_pElementLayout->TestClassFlag(CElement::ELEMENTDESC_VPADDING) 
            // In print preview an element inside a table cell with VPADDING and percent 
            // height may be pushed to the next page by CDisplay code during set cell 
            // position pass -- when table code does not expect it. The checks below 
            // prevent it (#23413)
            &&  (   !_pci->_fTableCalcInfo 
                ||  !_pci->GetLayoutContext() 
                ||  !_pci->GetLayoutContext()->ViewChain() 
                ||  !pvaoi->_pLayout->PercentHeight()       )   )
        {
            lVPadding = 1;
        }

        if(pvaoi->_pElementLayout->Tag() == ETAG_HR)
            lBorderSpace = GRABSIZE;
        else
            // Netscape has a pixel descent and ascent to the line if one of the sites
            // spans the entire line vertically(#20029, #25534).
            lBorderSpace = lVPadding;

        lBorderSpace = _pci->DeviceFromDocPixelsY(lBorderSpace);

        pvaoi->_pLayout->GetApparentSize(&size);
        yObjHeight = max(0L, size.cy + yTopMargin + yBottomMargin)+ (2 * lBorderSpace);

        if(pvaoi->_pCF->_fIsRubyText)
        {
            RubyInfo *pRubyInfo = GetRubyInfoFromCp(pvaoi->_cp);
            if(pRubyInfo)
            {
                yObjHeight += pRubyInfo->yHeightRubyBase - pvaoi->_yTxtDescent + pRubyInfo->yDescentRubyText;
            }                        
        }

        atSite   = pvaoi->_pElementLayout->GetSiteAlign(LC_TO_FC(_pci->GetLayoutContext()));
        switch (atSite)
        {
        // align to the baseline of the text
        case htmlControlAlignNotSet:
        case htmlControlAlignBottom:
        case htmlControlAlignBaseline:
        {
            LONG lDefDescent = 0;
            if (pvaoi->_pElementLayout->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
            {
                lDefDescent = _pci->DeviceFromDocPixelsY(4);
            }
            else if (!pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
            {
                lDefDescent = pvaoi->_pLayout->GetDescent();

                // This is a hack to get IE5 compat when you have negative margins on inline sites.
                // See bug 103469.
                if (   yBottomMargin < 0 
                    && pvaoi->_pLayout->IsFlowLayout())
                {
                    lDefDescent += yBottomMargin;
                    lDefDescent = max(0l, lDefDescent);
                }
            }

            if(pvaoi->_fMeasuring)
            {
                yTmpDescent = lBorderSpace + lDefDescent;
                yTmpAscent  = yObjHeight - yTmpDescent;
            }
            else
            {
                yProposed += pvaoi->_yAscent - yObjHeight + 2 * lBorderSpace + lDefDescent;
            }
            break;
        }

        // align to the top of the text
        case htmlControlAlignTextTop:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent  = pvaoi->_yTxtAscent + lBorderSpace;
                yTmpDescent = yObjHeight - pvaoi->_yTxtAscent - lBorderSpace;
            }
            else
            {
                yProposed += pvaoi->_yAscent - pvaoi->_yTxtAscent + lBorderSpace;
            }
            break;

            // center of the image aligned to the baseline of the text
        case htmlControlAlignMiddle:
        case htmlControlAlignCenter:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent  = (yObjHeight + 1)/2; // + 1 for round off
                yTmpDescent = yObjHeight/2;
            }
            else
            {
                yProposed += (pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight) / 2 + lBorderSpace;
            }
            break;

            // align to the top, absmiddle and absbottom of the line, doesn't really
            // effect the ascent and descent directly, so we store the
            // absolute height of the object and recompute the ascent
            // and descent at the end.
        case htmlControlAlignAbsMiddle:
            if(pvaoi->_fPositioning)
            {
                yProposed += (pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight) / 2 + lBorderSpace;
                break;
            } // fall through when measuring and update max abs height
        case htmlControlAlignTop:
            if(pvaoi->_fPositioning)
            {
                yProposed += lBorderSpace;
                break;
            } // fall through when measuring and update the max abs height
        case htmlControlAlignAbsBottom:
            if(pvaoi->_fMeasuring)
            {
                yTmpAscent = 0;
                yTmpDescent = 0;
                if(yObjHeight > pvaoi->_yAbsHeight)
                {
                    pvaoi->_yAbsHeight = yObjHeight;
                    pvaoi->_atAbs = atSite;
                }
            }
            else
            {
                yProposed += pvaoi->_yAscent + pvaoi->_yDescent - yObjHeight + lBorderSpace;
            }
            break;

        default:        // we don't want to do anything for
            if(pvaoi->_pElementLayout->HasFlag(TAGDESC_OWNLINE))
            {
                LONG lDefDescent = 0;
                if (!pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
                {
                    lDefDescent = pvaoi->_pLayout->GetDescent();
                }
                if(pvaoi->_fMeasuring)
                {
                    yTmpDescent = lBorderSpace + lDefDescent;
                    yTmpAscent  = yObjHeight - lBorderSpace;
                }
                else
                {
                    yProposed += pvaoi->_yAscent - yObjHeight + lBorderSpace + lDefDescent;
                }
            }
            break;      // left/center/right aligned objects
        } // switch(atSite)

        // Keep track of the max ascent and descent
        if(pvaoi->_fMeasuring)
        {
            if(pvaoi->_pCF->HasLineGrid(FALSE))
            {
                pvaoi->_yMaxHeight = max(pvaoi->_yMaxHeight, 
                    GetClosestGridMultiple(GetLineGridSize(), yTmpAscent + yTmpDescent));
            }

            if(yTmpAscent > pvaoi->_yAscent)
                pvaoi->_yAscent = yTmpAscent;
            if(yTmpDescent > pvaoi->_yDescent)
                pvaoi->_yDescent = yTmpDescent;
        }
        else
        {
            LONG yP;
            
            if(pvaoi->_pCF->HasLineGrid(FALSE))
            {
                yP = _li._yHeight - (pvaoi->_yAscent + _li._yDescent) + yTopMargin + yProposed;
            }
            else
            {
                yP = yProposed + lsme._cyTopBordPad + yTopMargin;
            }
            pvaoi->_pLayout->SetYProposed(yP - min((LONG)0, (LONG)_li._yHeightTopOff));

            if (pvaoi->_por)
            {
                pvaoi->_por->_yObjHeight = yObjHeight;
                pvaoi->_por->_yProposed  = yP;
            }
        }
    } // if(!fAbsolute)

    //
    // If positioning, add the current layout to the display tree
    //
    if (    pvaoi->_fPositioning
        && !pvaoi->_pElementLayout->IsAligned(LC_TO_FC(_pci->GetLayoutContext()))
        && _pci->IsNaturalMode()
       )
    {
        long dx;
        if (!_li.IsRTLLine())
            dx = _pMarginInfo->_xLeftMargin + _li._xLeft;
        else
        {
            dx = - _pMarginInfo->_xRightMargin - _li._xRight;
        }

        long xPos;
        if (!_li.IsRTLLine())
            xPos = dx + pvaoi->_pLayout->GetXProposed();
        else
            xPos = dx + _pFlowLayout->GetContainerWidth() 
                 - pvaoi->_pLayout->GetXProposed() - pvaoi->_pLayout->GetApparentWidth();


        if (   (    !pFF->_fPositioned
                ||  (   pvaoi->_pElementFL->HasSlavePtr()
                            // Non CSS1 compatible slave markup
                     && (   (   pvaoi->_pElementLayout->_etag == ETAG_BODY
                             && !pvaoi->_pElementLayout->GetMarkup()->IsHtmlLayout()
                            )
                            // CSS1 compatible slave markup
                         || (   pvaoi->_pElementLayout->_etag == ETAG_HTML
                             && pvaoi->_pElementLayout->GetMarkup()->IsHtmlLayout()
                            )
                        )
                    )
                )
            && !pvaoi->_pCF->_fRelative
            )
        {
            // we are not using GetYTop for to get the offset of the line because
            // the before space is not added to the height yet.
            lsme._pDispNodePrev = pvaoi->_pFL->AddLayoutDispNode(
                            _pci,
                            pvaoi->_pElementLayout->GetFirstBranch(),
                            xPos,
                            lsme._yli 
                                + _li._yBeforeSpace 
                                + _li._yHeightTopOff
                                + pvaoi->_pLayout->GetYProposed(),
                            lsme._pDispNodePrev);
        }
        else
        {
            //
            // If top and bottom or left and right are "auto", position the object
            //

            if (fAbsolute)
                pvaoi->_pLayout->SetYProposed(lsme._cyTopBordPad);

            CPoint ptAuto(xPos,
                          lsme._yli + _li._yBeforeSpace + _li._yHeightTopOff +
                          pvaoi->_pLayout->GetYProposed());

            pvaoi->_pElementLayout->RepositionElement(0, &ptAuto, _pci->GetLayoutContext());
        }
    }
    
Cleanup:
    return;
}

//-------------------------------------------------------------------------
//
//  Member:     GetNextNodeForVerticalAlign
//
//  Synopsis:   gets next node to be vertical aligned
//
//-------------------------------------------------------------------------
void
CLineServices::GetNextNodeForVerticalAlign(VAOINFO * pvaoi)
{
    Assert(pvaoi->_cchPreChars >= 0);
    Assert(pvaoi->_cchAdvance  == 0);

    if (pvaoi->_fFastProcessing)
    {
        Assert(pvaoi->_por);
        Assert(pvaoi->_ptpNext == NULL);
        pvaoi->_pNodeNext       = pvaoi->_por->_ptp->GetBranch();
    }
    else if (pvaoi->_cchPreChars == 0 && !pvaoi->_fPostCharsProcessing)
    {
        Assert(pvaoi->_por);
        pvaoi->_fFastProcessing = TRUE;
        pvaoi->_ptpNext         = NULL;
        pvaoi->_pNodeNext       = pvaoi->_por->_ptp->GetBranch();
    }
    else if (pvaoi->_ptpNext)
    {
        pvaoi->_ptpNext    = pvaoi->_ptpNext->NextNonPtrTreePos();
        pvaoi->_pNodeNext  = pvaoi->_ptpNext->GetBranch();
        pvaoi->_cchAdvance = pvaoi->_ptpNext->GetCch();
    }
    else
    {
        LONG ich;
        pvaoi->_ptpNext    = _pMarkup->TreePosAtCp(_cpStart + _li._cch - pvaoi->_cch, &ich, TRUE);
        pvaoi->_pNodeNext  = pvaoi->_ptpNext->GetBranch();
        pvaoi->_cchAdvance = pvaoi->_ptpNext->GetCch() - ich;
    }

    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= pvaoi->_cchAdvance);
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignObjects
//
//  Synopsis:   Process all vertically aligned objects and adjust the line
//              height
//
//-------------------------------------------------------------------------
void
CLineServices::VerticalAlignObjects(
    CLSMeasurer & lsme, 
    long xLineShift)
{
    Assert(_li._cch >= 0 && _listCurrent._pHead);

    BOOL fPositioning = FALSE;

    VAOINFO vaoi;
    ZeroMemory(&vaoi, sizeof(VAOINFO));
    vaoi._xLineShift  = xLineShift;
    vaoi._fMeasuring  = TRUE;

    VANINFO vani;
    ZeroMemory(&vani, sizeof(VANINFO));

    COneRun * porHead = _listCurrent._pHead;
    while (porHead && porHead->IsSyntheticRun())
        porHead = porHead->_pNext;

    // First pass we measure the line's ascent and descent
    // second pass we set the height and yPosition of objects.
    while (vaoi._fMeasuring || fPositioning)
    {
        vaoi._fFastProcessing      = lsme._fMeasureFromTheStart;
        vaoi._fPostCharsProcessing = FALSE;
        vaoi._por         = porHead;
        vaoi._pvaniCached = &vani;
        vaoi._xWidthSoFar = 0;
        vaoi._cchPreChars = lsme._cchPreChars;
        vaoi._cch         = _li._cch + (vaoi._fFastProcessing ? 0 : vaoi._cchPreChars);
        vaoi._cchAdvance  = 0;
        vaoi._pNodeNext   = NULL;
        vaoi._ptpNext     = NULL;

        while (vaoi._cch > 0)
        {
            VANINFO * pvaniBlock;

            if (!vaoi._pNodeNext)
                GetNextNodeForVerticalAlign(&vaoi);
            Assert(vaoi._pNodeNext);

            if (vaoi._fMeasuring)
            {
                Assert(!vaoi._pvaniCached->_pNext);
                vaoi._pvaniCached->_pNext = new VANINFO;
                if (!vaoi._pvaniCached->_pNext)
                {
                    vaoi._fMeasuring = FALSE; // Error: skip positioning process
                    break;
                }
                ZeroMemory(vaoi._pvaniCached->_pNext, sizeof(VANINFO));
                // In case of tags overlaping we can VAlign node, which does't belong to current flow layout.
                // In this case VAlign this node.
                if (vaoi._pNodeNext->GetBeginPos()->GetCp() < _pFlowLayout->ElementOwner()->GetFirstCp())
                {
                    vaoi._pvaniCached->_pNext->_pNode = vaoi._pNodeNext;
                }
                else
                {
                    CTreeNode * pNodeBlock = _pMarkup->SearchBranchForBlockElement(vaoi._pNodeNext, _pFlowLayout);
                    if (!pNodeBlock)
                        pNodeBlock = vaoi._pNodeNext;
                    vaoi._pvaniCached->_pNext->_pNode = pNodeBlock;
                }
            }
            pvaniBlock = vaoi._pvaniCached = vaoi._pvaniCached->_pNext;
            
            Assert(pvaniBlock->_pNode);

            if (!VerticalAlignNode(lsme, &vaoi, pvaniBlock))
            {
                vaoi._fMeasuring = FALSE; // Error: skip positioning process
                break;
            }

            if (    vaoi._fMeasuring
                &&  vaoi._cchPreChars == 0)
            {
                vani._yAscent  = max(vani._yAscent, pvaniBlock->_yAscent);
                vani._yDescent = max(vani._yDescent, pvaniBlock->_yDescent);
            }
        }

        // We have just finished measuring, update the line's ascent and descent.
        if (vaoi._fMeasuring)
        {
            // now update the line height
            vaoi._yLineHeight = max(vaoi._yLineHeight, vani._yAscent + vani._yDescent);

            if (_lsMode == LSMODE_MEASURER)
            {
                /* BOOL fEmptyLine = (vaoi._xWidthSoFar == 0 && !vaoi._fHasAbsSites); */
                _li._yDescent = max((LONG)_li._yDescent, /*fEmptyLine ? 0L : */vani._yDescent);
                _li._yHeight  = max((LONG)_li._yHeight,  /*fEmptyLine ? 0L : */vaoi._yLineHeight);

                // Without this line, line heights specified through
                // styles would override the natural height of the
                // image. This would be cool, but the W3C doesn't
                // like it. Absolute & aligned sites do not affect
                // line height.
                if(_fHasInlinedSites)
                    _fFoundLineHeight = FALSE;

                Assert(_li._yHeight >= 0);

                // Allow last minute adjustment to line height, we need
                // to call this here, because when positioning all the
                // site in line for the display tree, we want the correct
                // YTop.
                if (vaoi._fHasLineGrid)
                {
                    _fFoundLineHeight = TRUE;
                    _lMaxLineHeight = GetClosestGridMultiple(GetLineGridSize(), max(_lMaxLineHeight, vaoi._yLineHeight));
                }
                AdjustLineHeight();
            }

            // And now the positioning pass
            vaoi._fMeasuring = FALSE;
            fPositioning = TRUE;
        }
        else
        {
            fPositioning = FALSE;
        }
    }

    // VANINFO list cleanup
    while (vani._pNext)
    {
        VANINFO * pTemp = vani._pNext;
        vani._pNext = pTemp->_pNext;
        delete pTemp;
    }
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignNode
//
//  Synopsis:   vartical align contents of the node
//
//-------------------------------------------------------------------------
BOOL
CLineServices::VerticalAlignNode(
    CLSMeasurer & lsme, 
    VAOINFO * pvaoi, 
    VANINFO * pvani)
{
    if (pvaoi->_fMeasuring)
    {
        pvani->_pCF = pvani->_pNode->GetCharFormat(LC_TO_FC(GetLayoutContext()));
        pvani->_pFF = pvani->_pNode->GetFancyFormat(LC_TO_FC(GetLayoutContext()));

        // If we are transisitioning from a normal chunk to relative or
        // relative to normal chunk, add a new chunk to the line.
        if (_fHasRelative && !pvani->_pCF->IsDisplayNone())
        {
            CElement * pElementLayout = (   _pFlowLayout->ElementOwner() != pvani->_pNode->Element()
                                        &&  pvani->_pFF->_fShouldHaveLayout)
                                        ? pvani->_pNode->Element()
                                        : NULL;

            TestForTransitionToOrFromRelativeChunk(_cpStart + _li._cch - pvaoi->_cch, 
                pvani->_pCF->IsRelative(SameScope(pvani->_pNode, _pFlowLayout->ElementOwner())), 
                FALSE /*fForceChunk*/,
                pvani->_pNode, pElementLayout);
        }

        pvaoi->_fHasLineGrid |= !!pvani->_pCF->HasLineGrid(TRUE);
        pvani->_fRubyVAMode   = !!pvani->_pCF->_fIsRuby;

        if (pvani->_yTxtAscent == 0)
        {
            Assert(pvani->_yTxtDescent == 0);

            // Get font's ascent and descent from ccs
            CCcs ccs;
            const CBaseCcs *pBaseCcs;

            if (   pvaoi->_fFastProcessing 
                && pvaoi->_cchPreChars == 0 
                && pvaoi->_por->Branch() == pvani->_pNode)
            {
                GetCcs(&ccs, pvaoi->_por, _pci->_hdc, _pci);
                pBaseCcs = ccs.GetBaseCcs();

                // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                // 107681 is fixed.
                if (pBaseCcs)
                {
                    pvani->_yAscent  = pvani->_yTxtAscent  = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                    pvani->_yDescent = pvani->_yTxtDescent = pBaseCcs->_yDescent;
                }
            }
            else
            {
                fc().GetCcs(&ccs, _pci->_hdc, _pci, pvani->_pCF);
                pBaseCcs = ccs.GetBaseCcs();

                // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                // 107681 is fixed.
                if (pBaseCcs)
                {
                    pvani->_yAscent  = pvani->_yTxtAscent  = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                    pvani->_yDescent = pvani->_yTxtDescent = pBaseCcs->_yDescent;
                }

                ccs.Release();
            }
        }
    }

    // Run this aligment loop until end of line is not reached
    // or we exiting this node scope ('break' statement)
    while (pvaoi->_cch > 0)
    {
        if (!pvaoi->_pNodeNext)
            GetNextNodeForVerticalAlign(pvaoi);

        if (pvani->_pNode == pvaoi->_pNodeNext)
        {
            //
            // We are at the same node level. Do regular aligment processing.
            // Align only normal text runs and objects with layout, but only
            // if we are done with pre chars.
            //
            if (pvaoi->_fFastProcessing && pvaoi->_cchPreChars == 0)
            {
                if (pvaoi->_por->_fCharsForNestedLayout)
                {
                    if ( !pvani->_pCF->IsDisplayNone())
                    {
                        if (!pvani->_pLayout)
                        {
                            pvani->_pLayout = pvani->_pNode->GetUpdatedLayout(_pci->GetLayoutContext());
                        }

                        VerticalAlignOneObject(lsme, pvaoi, pvani);
                    }
                }
                // NOTE: text run can be hidden (display:none) => not normal run
                else if (pvaoi->_por->_ptp->IsText() && pvaoi->_por->IsNormalRun())
                {
                    if (!pvaoi->_fMeasuring)
                    {
                        Assert(pvani->_yAscent >= pvani->_yTxtAscent);

                        pvaoi->_por->_yProposed  = pvani->_yProposed + pvani->_yAscent - pvani->_yTxtAscent;
                        pvaoi->_por->_yProposed += _li._yBeforeSpace + _li._cyTopBordPad + max((LONG)0, (LONG)_li._yHeightTopOff);
                        pvaoi->_por->_yObjHeight = pvani->_yTxtAscent + pvani->_yTxtDescent;
                        // If we have smallcaps we have to adjust _yProposed such that if there are only small letters, 
                        // the letters are brought down on base line.
                        if (pvani->_pCF->_fSmallCaps) 
                        {
                            CCcs ccs;
                            const CBaseCcs *pBaseCcs;
                            GetCcs(&ccs, pvaoi->_por, _pci->_hdc, _pci);
                            pBaseCcs = ccs.GetBaseCcs();

                            // TODO: (grzegorz): remove checking for null CBaseCcs object, when
                            // 107681 is fixed. 
                            if (pBaseCcs) 
                            {
                                pvaoi->_por->_yProposed -= (pBaseCcs->_yHeight - pBaseCcs ->_yDescent) - pvani->_yTxtAscent;
                            }
                        }
                    }
#if DBG==1
                    else
                    {
                        // Make sure we adjust ascent/descent correctly
                        Assert(pvani->_yAscent  >= pvani->_yTxtAscent);
                        Assert(pvani->_yDescent >= pvani->_yTxtDescent);
                    }
#endif
                    pvaoi->_xWidthSoFar += pvaoi->_por->_xWidth;
                    pvani->_fHasContent = TRUE;

                    // Cannot blast lines with RUBY inside
                    Assert(!pvani->_pCF->_fIsRubyText || !_li._fCanBlastToScreen);

                }

                pvaoi->_cch -= pvaoi->_por->_lscch;
                pvaoi->_por  = pvaoi->_por->_pNext;
#if DBG==1
                // Make sure we adjust _cch correctly
                if (pvaoi->_por && pvaoi->_cch > 0)
                    Assert(pvaoi->_por->Cp() - _cpStart == _li._cch - pvaoi->_cch);
#endif
            }
            else
            {
                //
                // We are during pre or post chars processing.
                //

                if (pvaoi->_fFastProcessing)
                {
                    Assert(pvaoi->_ptpNext    == NULL);
                    Assert(pvaoi->_cchAdvance == 0);
                    pvaoi->_ptpNext    = pvaoi->_por->_ptp;
                    pvaoi->_cchAdvance = pvaoi->_por->_lscch;
                }
                Assert(pvaoi->_ptpNext);
                Assert(pvaoi->_ptpNext->GetBranch() == pvani->_pNode);

                if (    pvaoi->_ptpNext->IsBeginElementScope()
                    &&  pvani->_pFF->IsAbsolute()
                    &&  pvani->_pNode->ShouldHaveLayout()
                   )
                {
                    if (!pvani->_pCF->IsDisplayNone())
                    {
                        pvani->_pLayout = pvani->_pNode->GetUpdatedLayout();
                        VerticalAlignOneObject(lsme, pvaoi, pvani);
                    }
                    LONG cchSite = GetNestedElementCch(pvani->_pNode->Element(), &pvaoi->_ptpNext);

                    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= cchSite);

                    if (pvaoi->_cchPreChars)
                        pvaoi->_cchPreChars -= min(cchSite, pvaoi->_cchPreChars);
                    pvaoi->_cch        -= cchSite;
                    pvaoi->_cchAdvance  = 0;
                    pvaoi->_pNodeNext   = NULL;

                    if (pvaoi->_fFastProcessing)
                    {
                        pvaoi->_ptpNext = NULL;
                        pvaoi->_por     = pvaoi->_por->_pNext;
                    }

                    // We are finished with this node.
                    goto Cleanup;
                }
                else
                {
                    Assert(pvaoi->_cchPreChars == 0 || pvaoi->_cchPreChars >= pvaoi->_cchAdvance);

                    if (pvaoi->_cchPreChars)
                        pvaoi->_cchPreChars -= pvaoi->_cchAdvance;
                    pvaoi->_cch        -= pvaoi->_cchAdvance;
                    pvaoi->_cchAdvance  = 0;

                    if (pvaoi->_fFastProcessing)
                    {
                        pvaoi->_ptpNext = NULL;
                        pvaoi->_por     = pvaoi->_por->_pNext;
                    }
                }
            }

            // Skip synthetic runs and invalidate next node
            while (pvaoi->_por && pvaoi->_por->IsSyntheticRun())
            {
                pvaoi->_por = pvaoi->_por->_pNext;
            }
            pvaoi->_pNodeNext = NULL;

            if (!pvaoi->_por && pvaoi->_fFastProcessing)
            {
                pvaoi->_fFastProcessing      = FALSE;
                pvaoi->_fPostCharsProcessing = TRUE;
            }
        }
        else if (pvani->_pNode->AmIAncestorOf(pvaoi->_pNodeNext))
        {
            //
            // We are entering child node. Store 'pCurrentNode' for use
            // during child node processing.
            // 

            VANINFO * pvaniChild;
            if (pvaoi->_fMeasuring)
            {
                CTreeNode * pNodeChild = pvaoi->_pNodeNext;
                // Make sure we are going down only one level
                while (pNodeChild->Parent() != pvani->_pNode)
                    pNodeChild = pNodeChild->Parent();

                // Setup VANINFO for child node and add it cached list.
                // NOTE: Memory will be freed at the end of aligning process.
                pvaniChild = new VANINFO;
                if (!pvaniChild)
                    return FALSE;
                Assert(!pvaoi->_pvaniCached->_pNext);
                pvaoi->_pvaniCached->_pNext = pvaniChild;
                ZeroMemory(pvaniChild, sizeof(VANINFO));
                pvaniChild->_pNode = pNodeChild;
                pvaoi->_pvaniCached = pvaniChild;
            }
            else
            {
                pvaniChild = pvaoi->_pvaniCached = pvaoi->_pvaniCached->_pNext;

                // Set yProposed for child node
                switch (pvaniChild->_pFF->GetVerticalAlign(pvani->_pCF->HasVerticalLayoutFlow()))
                {
                case styleVerticalAlignSub:
                    {
                        LONG yOffset;
                        if (pvaniChild->_pCF->_fSubscript)
                        {
                            yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                _pci) / 2);
                        }
                        else
                        {
                            yOffset = pvaniChild->_yAscent - (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                        }
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - 
                            pvaniChild->_yAscent + yOffset;
                    }
                    break;

                case styleVerticalAlignSuper:
                    {
                        LONG yOffset;
                        if (pvaniChild->_pCF->_fSuperscript)
                        {
                            yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                _pci) / 2);
                        }
                        else
                        {
                            yOffset = pvaniChild->_yDescent + (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                        }
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - 
                            pvaniChild->_yAscent - yOffset;
                    }
                    break;

                case styleVerticalAlignTop:
                    pvaniChild->_yProposed = 0;
                    break;

                case styleVerticalAlignBottom:
                    pvaniChild->_yProposed = pvaoi->_yLineHeight - (pvaniChild->_yAscent + pvaniChild->_yDescent);
                    break;

                case styleVerticalAlignAbsMiddle:
                    pvaniChild->_yProposed = (pvaoi->_yLineHeight - (pvaniChild->_yAscent + pvaniChild->_yDescent)) / 2;
                    break;

                case styleVerticalAlignMiddle:
                    if (pvaniChild->_fRubyVAMode)
                    {
                        // Ruby in vertical text is aligned to the baseline
                        Assert(!pvaniChild->_pFF->HasCSSVerticalAlign());
                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent;
                    }
                    else
                    {
                        LONG yDiff = (pvaniChild->_yAscent + pvaniChild->_yDescent - (pvani->_yTxtAscent + pvani->_yTxtDescent)) / 2;
                        pvaniChild->_yProposed = pvani->_yProposed + (pvani->_yAscent - pvani->_yTxtAscent) - yDiff;
                    }
                    break;

                case styleVerticalAlignTextTop:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvani->_yTxtAscent;
                    break;

                case styleVerticalAlignTextBottom:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent + pvani->_yTxtDescent - (pvaniChild->_yAscent + pvaniChild->_yDescent);
                    break;

                case styleVerticalAlignBaseline:
                    pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent;
                    break;

                case styleVerticalAlignPercent:
                case styleVerticalAlignNumber:
                    {
                        LONG lFontHeightTwips  = pvaniChild->_pCF->GetHeightInTwips(_pci->_pDoc);
                        LONG lFontHeightPixels = pvaniChild->_pCF->GetHeightInPixels(_pci->_hdc, _pci);
                        LONG lLineHeightPixels = lFontHeightPixels;
                        if (!pvaniChild->_pCF->_cuvLineHeight.IsNull())
                            lLineHeightPixels = pvaniChild->_pCF->_cuvLineHeight.YGetPixelValue(_pci, lFontHeightPixels, lFontHeightTwips);
                        const CUnitValue & cuvVA = pvaniChild->_pFF->GetVerticalAlignValue();
                        LONG yOffset = cuvVA.YGetPixelValue(_pci, lLineHeightPixels, lFontHeightTwips);

                        pvaniChild->_yProposed = pvani->_yProposed + pvani->_yAscent - pvaniChild->_yAscent - yOffset;
                    }
                    break;

                default:
                    Assert(FALSE);
                }
                Assert(pvaniChild->_yProposed >= 0);
            }

            // Vertical align child node
            if (!VerticalAlignNode(lsme, pvaoi, pvaniChild))
                return FALSE;

            if (pvaoi->_fMeasuring)
            {
                // Set ruby vertical align mode; can be cleared later.
                pvani->_fRubyVAMode = pvaniChild->_fRubyVAMode;

                // Height of child node may affect height of this node. 
                // Make necessary adjustments.
                if (pvaniChild->_pCF->_fIsRubyText)
                {
                    //
                    // Vertical align has no effect on RT tag
                    //

                    Assert(pvani->_pCF->_fIsRuby);

                    RubyInfo * pRubyInfo = GetRubyInfoFromCp(pvaniChild->_pNode->Element()->GetFirstCp());
                    if(pRubyInfo)
                    {
                        pvani->_yAscent = max(pvani->_yAscent, pRubyInfo->yHeightRubyBase - pRubyInfo->yDescentRubyBase + pvaniChild->_yAscent + pvaniChild->_yDescent);
                    }                        
                }
                else
                {
                    switch (pvaniChild->_pFF->GetVerticalAlign(pvani->_pCF->HasVerticalLayoutFlow()))
                    {
                    case styleVerticalAlignSub:
                        {
                            LONG yOffset;
                            if (pvaniChild->_pCF->_fSubscript)
                            {
                                yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                    pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                    _pci) / 2);
                            }
                            else
                            {
                                yOffset = pvaniChild->_yAscent - (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                            }
                            pvani->_yAscent  = max(pvani->_yAscent,  pvaniChild->_yAscent  - yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent + yOffset);
                        }
                        break;

                    case styleVerticalAlignSuper:
                        {
                            LONG yOffset;
                            if (pvaniChild->_pCF->_fSuperscript)
                            {
                                yOffset = (LONG)(pvaniChild->_pCF->GetHeightInPixelsEx(
                                                    pvaniChild->_yTxtAscent + pvaniChild->_yTxtDescent, 
                                                    _pci) / 2);
                            }
                            else
                            {
                                yOffset = pvaniChild->_yDescent + (LONG)((pvani->_yTxtAscent - pvani->_yTxtDescent) / 2);
                            }
                            pvani->_yAscent  = max(pvani->_yAscent,  pvaniChild->_yAscent  + yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent - yOffset);
                        }
                        break;

                    case styleVerticalAlignTop:
                    case styleVerticalAlignBottom:
                    case styleVerticalAlignAbsMiddle:
                        pvaoi->_yLineHeight = max(pvaoi->_yLineHeight, pvaniChild->_yAscent + pvaniChild->_yDescent);
                        break;

                    case styleVerticalAlignMiddle:
                        // allign to the middle of parent's element font
                        if (pvaniChild->_fRubyVAMode)
                        {
                            // ruby in vertical text is aligned to the baseline
                            Assert(!pvaniChild->_pFF->HasCSSVerticalAlign());
                            pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent);
                        }
                        else
                        {
                            LONG yDiff = pvaniChild->_yAscent + pvaniChild->_yDescent - (pvani->_yTxtAscent + pvani->_yTxtDescent);
                            pvani->_yAscent   = max(pvani->_yAscent, (LONG)(pvani->_yTxtAscent  + (yDiff + 1) / 2));
                            pvani->_yDescent  = max(pvani->_yDescent,(LONG)(pvani->_yTxtDescent + yDiff / 2));
                        }
                        break;

                    case styleVerticalAlignTextTop:
                        // ascent is not changed
                        pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yAscent + pvaniChild->_yDescent - pvani->_yTxtAscent);
                        break;

                    case styleVerticalAlignTextBottom:
                        pvani->_yAscent = max(pvani->_yAscent, pvaniChild->_yAscent + pvaniChild->_yDescent - pvani->_yTxtDescent);
                        // descent is not changed
                        break;

                    case styleVerticalAlignBaseline:
                        pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent);
                        pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent);
                        break;

                    case styleVerticalAlignPercent:
                    case styleVerticalAlignNumber:
                        {
                            LONG lFontHeightTwips  = pvaniChild->_pCF->GetHeightInTwips(_pci->_pDoc);
                            LONG lFontHeightPixels = pvaniChild->_pCF->GetHeightInPixels(_pci->_hdc, _pci);
                            LONG lLineHeightPixels = lFontHeightPixels;
                            if (!pvaniChild->_pCF->_cuvLineHeight.IsNull())
                                lLineHeightPixels = pvaniChild->_pCF->_cuvLineHeight.YGetPixelValue(_pci, lFontHeightPixels, lFontHeightTwips);
                            const CUnitValue & cuvVA = pvaniChild->_pFF->GetVerticalAlignValue();
                            LONG yOffset = cuvVA.YGetPixelValue(_pci, lLineHeightPixels, lFontHeightTwips);

                            pvani->_yAscent  = max(pvani->_yAscent, pvaniChild->_yAscent + yOffset);
                            pvani->_yDescent = max(pvani->_yDescent, pvaniChild->_yDescent - yOffset);
                        }
                        break;

                    default:
                        Assert(FALSE);
                    }
                }

                // If we are transisitioning from a normal chunk to relative or
                // relative to normal chunk, add a new chunk to the line.
                if (_fHasRelative && !pvani->_pCF->IsDisplayNone() && pvaoi->_cch > 0)
                {
                    CElement * pElementLayout = (   _pFlowLayout->ElementOwner() != pvani->_pNode->Element()
                                                &&  pvani->_pFF->_fShouldHaveLayout)
                                                ? pvani->_pNode->Element()
                                                : NULL;

                    TestForTransitionToOrFromRelativeChunk(_cpStart + _li._cch - pvaoi->_cch, 
                        pvani->_pCF->IsRelative(SameScope(pvani->_pNode, _pFlowLayout->ElementOwner())),
                        FALSE /*fForceChunk*/,
                        pvani->_pNode, pElementLayout);
                }
            }
        }
        else
        {
            //
            // Vertical aligment for this node has been completed.
            // 
            break;
        }
    }
Cleanup:
    // Clear ruby vertical align mode, if this node is not a ruby 
    // and has content or has explicit vertical align.
    if (   pvani->_fRubyVAMode 
        && (   (pvani->_fHasContent && !pvani->_pCF->_fIsRuby)
            || pvani->_pFF->HasCSSVerticalAlign()))
    {
        pvani->_fRubyVAMode = FALSE;
    }

    return TRUE;
}

//-------------------------------------------------------------------------
//
//  Member:     VerticalAlignOneObject
//
//  Synopsis:   VAlign one object in a line.
//
//-------------------------------------------------------------------------
// TODO: (dmitryt, track bug 112319) Merge these two functions into one.
void
CLineServices::VerticalAlignOneObject(
    CLSMeasurer & lsme, 
    VAOINFO *pvaoi, 
    VANINFO *pvani)
{
    BOOL fAbsolute = pvani->_pNode->IsAbsolute();
    pvaoi->_fHasAbsSites |= !!fAbsolute;
    
    if (!(fAbsolute || pvani->_pNode->IsInlinedElement()))
        return;
    
    LONG yTopMargin,   yBottomMargin;
    LONG xLeftMargin,  xRightMargin;
    pvani->_pLayout->GetMarginInfo(_pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    // Do the horizontal positioning. We can do it either during
    // measuring or during vertical positioning. We arbitrarily
    // chose to do it during measuring.
    if (pvaoi->_fMeasuring && _lsMode == LSMODE_MEASURER)
    {
        LONG xPosOfCp;
        BOOL fSubtractWidthFromXProposed = FALSE;
        
        if (!fAbsolute || pvani->_pFF->_fAutoPositioned)
        {
            LONG lscp = (pvaoi->_cchPreChars == 0) ? pvaoi->_por->_lscpBase : LSCPFromCP(_cpStart + _li._cch - pvaoi->_cch);
            BOOL fRTLDisplay = _pFlowLayout->IsRTLFlowLayout();
            BOOL fRTLFlow = fRTLDisplay;
            
            //
            // If editable, then the char at the above computed lscp
            // might be the glyph for that layout rather than the layout
            // itself. To do this right, we need to we need to find the
            // run at that lscp, and if it is a glyph-synthetic run then
            // we need to go to the next run which contains the nested
            // layout and look at its lscp.
            //
            if (_fIsEditable && !fAbsolute)
            {
                COneRun *por = FindOneRun(lscp);
                if (   por
                    && por->IsSyntheticRun()
                    && por->_synthType == SYNTHTYPE_GLYPH
                   )
                {
                    por = por->_pNext;

                    //
                    // Check that this run exists, and has nested layout
                    // and that the nested layout is indeed the one we
                    // are hunting for.
                    //
                    Assert(por);
                    Assert(por->_fCharsForNestedElement);
                    Assert(por->_fCharsForNestedLayout);
                    Assert(por->_ptp->Branch() == pvani->_pNode);
                    lscp = por->_lscpBase;
                }
            }

            xPosOfCp = _li._fCanBlastToScreen ? pvaoi->_xWidthSoFar : CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlow);
#if DBG==1
            {
                BOOL fRTLFlowDbg = fRTLDisplay;
                Assert(xPosOfCp == CalculateXPositionOfLSCP(lscp, FALSE, &fRTLFlowDbg));
                Assert(fRTLFlow == fRTLFlowDbg);
            }
#endif

            if ((!!_li._fRTLLn) != fRTLFlow)
            {
                // Postpone flow adjustment for absolute objects. Their size is not calculated yet.
                if (fAbsolute)
                {
                    fSubtractWidthFromXProposed = TRUE; 
                }
                else
                {
                    long xObjectWidth = pvani->_pLayout->GetApparentWidth();
                    xPosOfCp -= xObjectWidth;
                }
            }

            if (pvani->_pCF->HasCharGrid(FALSE))
            {
                long xWidth;
                _pFlowLayout->GetSiteWidth(pvani->_pLayout, _pci, FALSE, _xWidthMaxAvail, &xWidth);
                xPosOfCp += (GetClosestGridMultiple(GetCharGridSize(), xWidth) - xWidth)/2;
            }

            // absolute margins are added in CLayout::HandlePositionRequest
            // due to reverse flow issues.
            if (!fAbsolute)
            {
                if (!_li._fRTLLn)
                    xPosOfCp += xLeftMargin;
                else
                    xPosOfCp += xRightMargin;
            }

            pvani->_pLayout->SetXProposed(xPosOfCp);
        }
        else
        {
            xPosOfCp = 0;
        }
        
        if (fAbsolute)
        {

            // fix for #3214, absolutely positioned sites with width auto
            // need to be measure once we know the line shift, since their
            // size depends on the xPosition in the line.

            // TODO RTL 112514: (dmitryt)
            //      This is the only place where we CalcSize absolutely positioned 
            //      objects that were on the current line. These objects were taken out during 
            //      normal MeasureLine pass, because they don't participate in line width. 
            //      Now we want to measure them. When this function will be called for 
            //      positioning pass (pvaoi->fPositioning==true) we will add/position their 
            //      dispnodes accordingly. So here is the main place where we measure/position 
            //      abspos objects.
            //      I think the comment for bug 3214 was intended for abspos'ed objects without
            //      horizontal position specified. Those have left=(x-position-of-their-cp-in-the-line).
            long xWidth;
            _pMeasurer->GetSiteWidth(pvani->_pNode, pvani->_pLayout, _pci, TRUE, _xWidthMaxAvail, &xWidth );

            // Subtract object width from XProposed if needed, now that we know the width
            if (fSubtractWidthFromXProposed)
            {
                xPosOfCp -= xWidth;
                pvani->_pLayout->SetXProposed(xPosOfCp);
            }
        }
    }

    if (!fAbsolute)
    {
        Assert(pvaoi->_cchPreChars == 0);

        LONG lBorderSpace;

        if (pvani->_pNode->Tag() == ETAG_HR)
            lBorderSpace = GRABSIZE;
        else
            // Netscape has a pixel descent and ascent to the line if one of the sites
            // spans the entire line vertically(#20029, #25534).
            lBorderSpace = pvani->_pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_VPADDING) ? 1 : 0;

        if (pvaoi->_fMeasuring)
        {
            CSize size;
            pvani->_pLayout->GetApparentSize(&size);
            pvaoi->_por->_yObjHeight = max(0L, size.cy + yTopMargin + yBottomMargin)+ (2 * lBorderSpace);

            if (pvani->_pCF->_fIsRubyText)
            {
                RubyInfo *pRubyInfo = GetRubyInfoFromCp(pvani->_pNode->Element()->GetFirstCp());
                if (pRubyInfo)
                {
                    pvaoi->_por->_yObjHeight += pRubyInfo->yHeightRubyBase - pvani->_yTxtDescent + pRubyInfo->yDescentRubyText;
                }                        
            }
 
            LONG lDefDescent = 0;
            if (pvani->_pNode->Element()->TestClassFlag(CElement::ELEMENTDESC_HASDEFDESCENT))
            {
                lDefDescent = pvani->_yTxtDescent;
            }
            else if (!pvani->_pFF->_fLayoutFlowChanged)    // Do not adjust layout's descent if flow has been changed
            {
                lDefDescent = pvani->_pLayout->GetDescent();
            }

            // Override default ascent/descent (from font properties)
            pvani->_yDescent = lBorderSpace + lDefDescent + yBottomMargin;
            pvani->_yAscent  = pvaoi->_por->_yObjHeight - pvani->_yDescent;
        }
        else
        {
            pvaoi->_por->_yProposed  = pvani->_yProposed + (pvani->_yAscent + pvani->_yDescent - pvaoi->_por->_yObjHeight) / 2;
            pvaoi->_por->_yProposed += lBorderSpace + yTopMargin;
            pvaoi->_por->_yProposed += _li._cyTopBordPad;
            pvani->_pLayout->SetYProposed(pvaoi->_por->_yProposed - min((LONG)0, (LONG)_li._yHeightTopOff));
        }
    }

    //
    // If positioning, add the current layout to the display tree
    //
    if (   !pvaoi->_fMeasuring
        &&  _lsMode == LSMODE_MEASURER
        && !pvani->_pNode->IsAligned()
        && _pci->IsNaturalMode()
       )
    {
        long dx;
        if (!_pFlowLayout->IsRTLFlowLayout())
            dx = _pMarginInfo->_xLeftMargin + _li._xLeft;
        else
        {
            dx = - _pMarginInfo->_xRightMargin - _li._xRight;
        }

        long xPos;
        if (!_li.IsRTLLine())
            xPos = dx + pvani->_pLayout->GetXProposed();
        else
            xPos = dx + _pFlowLayout->GetContainerWidth() 
                 - pvani->_pLayout->GetXProposed() - pvani->_pLayout->GetApparentWidth();


        if (   (    !pvani->_pFF->_fPositioned
                ||  (   _pFlowLayout->ElementOwner()->HasSlavePtr()
                            // Non CSS1 compatible slave markup
                     && (   (   pvani->_pNode->Tag() == ETAG_BODY
                             && !pvani->_pNode->GetMarkup()->IsHtmlLayout()
                            )
                            // CSS1 compatible slave markup
                         || (   pvani->_pNode->Tag() == ETAG_HTML
                             && pvani->_pNode->GetMarkup()->IsHtmlLayout()
                            )
                        )
                    )
               )
            && !pvani->_pCF->_fRelative
            )
        {
            // we are not using GetYTop for to get the offset of the line because
            // the before space is not added to the height yet.
            lsme._pDispNodePrev = _pFlowLayout->AddLayoutDispNode(
                            _pci,
                            pvani->_pNode,
                            xPos,
                            lsme._yli 
                                + _li._yBeforeSpace 
                                + _li._yHeightTopOff
                                + pvani->_pLayout->GetYProposed(),
                            lsme._pDispNodePrev);
        }
        else
        {
            //
            // If top and bottom or left and right are "auto", position the object
            //
            if (fAbsolute)
                pvani->_pLayout->SetYProposed(lsme._cyTopBordPad);

            CPoint ptAuto(xPos,
                          lsme._yli + _li._yBeforeSpace + _li._yHeightTopOff +
                          pvani->_pLayout->GetYProposed());

            pvani->_pNode->Element()->RepositionElement(0, &ptAuto, _pci->GetLayoutContext());
        }
    }
    
    if (!fAbsolute)
    {
        CSize size;
        pvani->_pLayout->GetApparentSize(&size);
        pvaoi->_xWidthSoFar += size.cx;
    }

    return;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetRubyInfoFromCp(LONG cpRubyText)
//
//  Synopsis:   Linearly searches through the list of ruby infos and
//              returns the info of the ruby object that contains the given
//              cp.  Note that this function should only be called with a
//              cp that corresponds to a position within Ruby pronunciation
//              text.
//
//              NOTE (t-ramar): this code does not take advantage of
//              the fact that this array is sorted by cp, but it does depend 
//              on this fact.  This may be a problem because the entries in this 
//              array are appended in the FetchRubyPosition Line Services callback.
//
//-----------------------------------------------------------------------------

RubyInfo *
CLineServices::GetRubyInfoFromCp(LONG cpRubyText)
{
    RubyInfo *pRubyInfo = NULL;
    int i;

    if((RubyInfo *)_aryRubyInfo == NULL)
        goto Cleanup;

    for (i = 0; i < _aryRubyInfo.Size(); i++)
    {
        if (_aryRubyInfo[i].cp > cpRubyText)
            break;
    }
    pRubyInfo = (i==0) ? NULL : &_aryRubyInfo[i-1];
    
    // if this assert fails, chances are that the cp isn't doesn't correspond
    // to a position within some ruby pronunciation text
    Assert(!pRubyInfo || pRubyInfo >= (RubyInfo *)_aryRubyInfo);

Cleanup:
    return pRubyInfo;
}


//-----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::AdjustLineHeight()
//
//  Synopsis:   Adjust for space before/after and line spacing rules.
//
//-----------------------------------------------------------------------------
void
CLineServices::AdjustLineHeight()
{
    // This had better be true.
    Assert (_li._yHeight >= 0);

    // Need to remember these for hit testing.
    _li._yExtent = _li._yHeight;

    // We remember the original natural descent of the line here since
    // it could be modified if there was a CSS height specified. We
    // need the original descent to compute the extent of the line
    // if it has MBP.
    _yOriginalDescent = _li._yDescent;
            
    // Only do this if there is a line height used somewhere.
    if (_lMaxLineHeight != LONG_MIN && _fFoundLineHeight)
    {
        LONG delta = _lMaxLineHeight - _li._yHeight;
        LONG yDescentIncr = delta / 2;
        
        _li._yHeightTopOff = delta - yDescentIncr;
        _li._yDescent += yDescentIncr;
        _li._yHeight = _lMaxLineHeight;
    }
    else
    {
        _li._yHeightTopOff = 0;
    }

    // Now, if there is any MBP take care of that -- MBP's increase
    // the extent of the line rather than change the height as was
    // in the previous case.
    if (_fHasMBP)
    {
        AdjustLineHeightForMBP();
    }
}

//-----------------------------------------------------------------------------
//
// Member:      CLineServices::MeasureLineShift (fZeroLengthLine)
//
// Synopsis:    Computes and returns the line x shift due to alignment
//
//-----------------------------------------------------------------------------
LONG
CLineServices::MeasureLineShift(LONG cp, LONG xWidthMax, BOOL fMinMax, LONG * pdxRemainder)
{
    long    xShift;
    UINT    uJustified;

    Assert(_li._fRTLLn == (unsigned)_pPFFirstPhysical->HasRTL(_fInnerPFFirstPhysical));

    xShift = ComputeLineShift(
                        (htmlAlign)_pPFFirstPhysical->GetBlockAlign(_fInnerPFFirstPhysical),
                        _pFlowLayout->IsRTLFlowLayout(),
                        _li._fRTLLn,
                        fMinMax,
                        xWidthMax,
                        _li.CalcLineWidth(),
                        &uJustified,
                        pdxRemainder);
    _li._fJustified = uJustified;
    return xShift;
}

//-----------------------------------------------------------------------------
//
// Member:      CalculateXPositionOfLSCP
//
// Synopsis:    Calculates the X position for LSCP
//
//-----------------------------------------------------------------------------

LONG
CLineServices::CalculateXPositionOfLSCP(
    LSCP lscp,          // LSCP to return the position of.
    BOOL fAfterPrevCp,  // Return the trailing point of the previous LSCP (for an ambigous bidi cp)
    BOOL* pfRTLFlow)    // Flow direction of LSCP.
{
    LSTEXTCELL lsTextCell;
    HRESULT hr;
    BOOL fRTLFlow = FALSE;
    BOOL fUsePrevLSCP = FALSE;
    LONG xRet;

    if (fAfterPrevCp && _pBidiLine != NULL)
    {
        LSCP lscpPrev = FindPrevLSCP(lscp, &fUsePrevLSCP);
        if (fUsePrevLSCP)
        {
            lscp = lscpPrev;
        }
    }

    hr = THR( QueryLineCpPpoint(lscp, FALSE, NULL, &lsTextCell, &fRTLFlow ) );

    if(pfRTLFlow)
        *pfRTLFlow = fRTLFlow;

    xRet = lsTextCell.pointUvStartCell.u;

    // If we're querying for a character which cannot be measured (e.g. a
    // section break char), then LS returns the last character it could
    // measure.  To get the x-position, we add the width of this character.

    if (S_OK == hr && (lsTextCell.cpEndCell < lscp || fUsePrevLSCP))
    {
        if(fRTLFlow == _li.IsRTLLine())
            xRet += lsTextCell.dupCell;
        else
        {
            xRet -= lsTextCell.dupCell;
            //
            // What is happening here is that we are being positioned at say pixel
            // pos 10 (xRet=10) and are asked to draw reverese a character which is
            // 11 px wide. So we would then draw at px10, at px9 ... and finally at
            // px 0 -- for at grand total of 11 px. Having drawn at 0, we would be
            // put back at -1. While the going back by 1px is correct, at the BOL
            // this will put us at -1, which is unaccepatble and hence the max with 0.
            //
            xRet = max(0L, xRet);
        }
    }
    else if (hr == S_OK && lsTextCell.cCharsInCell > 1 &&
             lscp > lsTextCell.cpStartCell)
    {
        long lClusterAdjust = MulDivQuick(lscp - lsTextCell.cpStartCell,
                                          lsTextCell.dupCell, lsTextCell.cCharsInCell);
        // we have multiple cps mapped to one glyph. This simply places the caret
        // a percentage of space between beginning and end
        if(fRTLFlow == _li.IsRTLLine())
            xRet += lClusterAdjust;
        else
        {
            xRet -= lClusterAdjust;
        }
    }

    return hr ? 0 : xRet;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::CalcPositionsOfRangeOnLine
//
// Synopsis:    Find the position of a stretch of text starting at cpStart and
//              and running to cpEnd, inclusive. The text may be broken into
//              multiple rects if the line has reverse objects (runs with
//              mixed directionallity) in it.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as rects from
//              the beginning of the line. The top and bottom entries of each
//              rect will be 0. No assumptions should be made about the order
//              of the rects; the first rect may or may not be the leftmost or
//              rightmost.
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CalcPositionsOfRangeOnLine(
    LONG cpStart,
    LONG cpEnd,
    LONG xShift,
    CDataAry<CChunk> * paryChunks,
    DWORD dwFlags)
{
    CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesCalculatePositionsOfRangeOnLine_aryLsqsubinfo_pv));
    LSTEXTCELL lsTextCell;
    COneRun *porLast;
    LSCP lscpStart = LSCPFromCP(max(cpStart, _cpStart));
    LSCP lscpEnd = LSCPFromCPCore(cpEnd, &porLast);
    HRESULT hr;
    BOOL fSublineReverseFlow = FALSE;
    LONG xStart;
    LONG xEnd;
    CChunk rcChunk;
    LONG i;
    LSTFLOW tflow = (!_li._fRTLLn ? lstflowES : lstflowWS);
    BOOL fSelection = ((dwFlags  & RFE_SELECTION) == RFE_SELECTION);
    
    Assert(paryChunks != NULL && paryChunks->Size() == 0);
    Assert(cpStart <= cpEnd);

    if (fSelection)
    {
        if (porLast && porLast->IsSyntheticRun())
            lscpEnd++;
    }
    
    rcChunk.top = rcChunk.bottom = 0;

    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

    hr = THR(QueryLineCpPpoint(lscpStart, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

    xStart = lsTextCell.pointUvStartCell.u;

    for (i = aryLsqsubinfo.Size() - 1; i >= 0; i--)
    {
        const LSQSUBINFO &qsubinfo = aryLsqsubinfo[i];
        const LSQSUBINFO &qsubinfoParent = aryLsqsubinfo[max((LONG)(i - 1), 0L)];

        if (lscpEnd < (LSCP) (qsubinfo.cpFirstSubline + qsubinfo.dcpSubline))
        {
            // lscpEnd is in this subline. Break out.
            break;
        }

        // If the subline and its parent are going in different directions
        // stuff the current range into the chunk array and move xStart to
        // the "end" (relative to the parent) of the current subline.
        if ((qsubinfo.lstflowSubline & fUDirection) !=
            (qsubinfoParent.lstflowSubline & fUDirection))
        {
            // Append the start of the chunk to the chunk array.
            rcChunk.left = xShift + xStart;

            fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

            // Append the end of the chunk to the chunk array.
            // If the subline flow doesn't match the line direction then we're
            // moving against the flow of the line and we will subtract the
            // subline width from the subline start to find the end point.
            rcChunk.right = xShift + qsubinfo.pointUvStartSubline.u + (fSublineReverseFlow ?
                            -qsubinfo.dupSubline : qsubinfo.dupSubline);

            // do some reverse flow cleanup before inserting rect into the array
            if(rcChunk.left > rcChunk.right)
            {
                Assert(fSublineReverseFlow);
                long temp = rcChunk.left;
                rcChunk.left = rcChunk.right + 1;
                rcChunk.right = temp + 1;
            }

            paryChunks->AppendIndirect(&rcChunk);

            xStart = qsubinfo.pointUvStartSubline.u + (fSublineReverseFlow ? 1 : -1);
        }
    }

    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

    hr = THR(QueryLineCpPpoint(lscpEnd, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

    xEnd = lsTextCell.pointUvStartCell.u;
    if(lscpEnd <= lsTextCell.cpEndCell && lsTextCell.cCharsInCell > 1 ||
       lscpEnd > lsTextCell.cpEndCell)
    {
        xEnd += ((aryLsqsubinfo.Size() == 0 ||
                  !((aryLsqsubinfo[aryLsqsubinfo.Size() - 1].lstflowSubline ^ tflow) & fUDirection)) ?
                  lsTextCell.dupCell : -lsTextCell.dupCell );
    }

    for (i = aryLsqsubinfo.Size() - 1; i >= 0; i--)
    {
        const LSQSUBINFO &qsubinfo = aryLsqsubinfo[i];
        const LSQSUBINFO &qsubinfoParent = aryLsqsubinfo[max((LONG)(i - 1), 0L)];

        if (lscpStart >= qsubinfo.cpFirstSubline)
        {
            // lscpStart is in this subline. Break out.
            break;
        }

        // If the subline and its parent are going in different directions
        // stuff the current range into the chunk array and move xEnd to
        // the "start" (relative to the parent) of the current subline.
        if ((qsubinfo.lstflowSubline & fUDirection) !=
            (qsubinfoParent.lstflowSubline & fUDirection))
        {
            fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

            if (xEnd != qsubinfo.pointUvStartSubline.u)
            {
                // Append the start of the chunk to the chunk array.
                rcChunk.left = xShift + qsubinfo.pointUvStartSubline.u;
 
                // Append the end of the chunk to the chunk array.
                rcChunk.right = xShift + xEnd;

                // do some reverse flow cleanup before inserting rect into the array
                if(rcChunk.left > rcChunk.right)
                {
                    Assert(fSublineReverseFlow);
                    long temp = rcChunk.left;
                    rcChunk.left = rcChunk.right + 1;
                    rcChunk.right = temp + 1;
                }

                paryChunks->AppendIndirect(&rcChunk);
            }

            // If the subline flow doesn't match the line direction then we're
            // moving against the flow of the line and we will subtract the
            // subline width from the subline start to find the end point.
            xEnd = qsubinfo.pointUvStartSubline.u +
                   (fSublineReverseFlow ? -(qsubinfo.dupSubline - 1) : (qsubinfo.dupSubline - 1));
        }
    }

    rcChunk.left = xShift + xStart;
    rcChunk.right = xShift + xEnd;
    // do some reverse flow cleanup before inserting rect into the array
    if(rcChunk.left > rcChunk.right)
    {
        long temp = rcChunk.left;
        rcChunk.left = rcChunk.right + 1;
        rcChunk.right = temp + 1;
    }
    paryChunks->AppendIndirect(&rcChunk);

    return paryChunks->Size();
}


//+----------------------------------------------------------------------------
//
// Member:      CLineServices::CalcRectsOfRangeOnLine
//
// Synopsis:    Find the position of a stretch of text starting at cpStart and
//              and running to cpEnd, inclusive. The text may be broken into
//              multiple runs if different font sizes or styles are used, or there
//              is mixed directionallity in it.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as rects of
//              offsets from the beginning of the line. 
//              No assumptions should be made about the order of the chunks;
//              the first chunk may or may not be the chunk which includes
//              cpStart.
//
//              Returned coordinates are LOGICAL (from the right in RTL line).
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CalcRectsOfRangeOnLine(
    LSCP lscpRunStart,
    LSCP lscpEnd,
    LONG xShift,
    LONG yPos,
    CDataAry<CChunk> * paryChunks,
    DWORD dwFlags,
    LONG curTopBorder,
    LONG curBottomBorder)
{
    CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesCalculateRectsOfRangeOnLine_aryLsqsubinfo_pv));
    HRESULT hr;
    LSTEXTCELL lsTextCell = {0}; // keep compiler happy
    BOOL fSublineReverseFlow;
    LSTFLOW tflow = (!_li._fRTLLn ? lstflowES : lstflowWS);
    LONG xStart;
    LONG xEnd;
    LONG yTop = 0;
    LONG yBottom = 0;
    LONG topBorder = 0;
    LONG bottomBorder = 0;
    LONG leftBorder = 0;
    LONG rightBorder = 0;
    CChunk rcChunk;
    CChunk rcLast;
    COneRun * porCurrent = _listCurrent._pHead;
    BOOL fIncludeBorders = (dwFlags & RFE_INCLUDE_BORDERS) ? TRUE : FALSE;
    BOOL fWigglyRects = (dwFlags & RFE_WIGGLY_RECTS) ? TRUE : FALSE;
    BOOL fOnlyOnce = fIncludeBorders && (lscpRunStart == lscpEnd);
    CTreeNode *pNodeStart;
    BOOL fSelection = ((dwFlags & RFE_SELECTION) == RFE_SELECTION);
    BOOL fForSynthetic = FALSE;

    // It may happen if the only thing in the line is <BR>
    if (lscpRunStart == lscpEnd)
        return paryChunks->Size();

    // we should never come in here with an LSCP that is in the middle of a COneRun. Those types (for selection)
    // should go through CalcPositionsOfRangeOnLine.
    
    // move quickly to the por that has the right lscpstart
    while(porCurrent->_lscpBase < lscpRunStart)
    {
        porCurrent = porCurrent->_pNext;

        // If we assert here, something is messed up. Please investigate
        Assert(porCurrent != NULL);
        // if we reached the end of the list we need to bail out.
        if(porCurrent == NULL)
            return paryChunks->Size();
    }

    // Save the node from the first one run
    pNodeStart = porCurrent->Branch();

    // for selection we want to start highlight invalidation at beginning of the run
    // to avoid vertical line turds with RTL text.
    if (fSelection)
        lscpRunStart = porCurrent->_lscpBase;

    Assert(paryChunks != NULL && paryChunks->Size() == 0);
    Assert(lscpRunStart <= lscpEnd);

    while(   fOnlyOnce
          || lscpRunStart < lscpEnd)
    {
        // if we reached the end of the list we need to bail out.
        if (porCurrent == NULL)
            break;

        if (porCurrent->_fHidden)
        {
            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            goto Next;
        }

        // Do not draw the selection around the \r inside a pre (bug 84801.htm)
        if (   _fScanForCR
            && 1 == porCurrent->_lscch
            && WCH_SYNTHETICLINEBREAK == *porCurrent->_pchBase
            && _li._fHasBreak
           )
        {
            goto Next;
        }
        
        switch(porCurrent->_fType)
        {
Normal:
        case COneRun::OR_NORMAL:
            {
                if (rcChunk != g_Zero.rc)
                {
                    Assert(leftBorder >= 0);
                    Assert(rightBorder >= 0);

                    rcChunk.left  -= leftBorder;
                    rcChunk.right += rightBorder;
                    rightBorder = leftBorder = 0;

                    // do some reverse flow cleanup before inserting rect into the array
                    if(rcChunk.left > rcChunk.right)
                    {
                        long temp = rcChunk.left;
                        rcChunk.left = rcChunk.right + 1;
                        rcChunk.right = temp + 1;
                    }

                    // In the event we have <A href="x"><B>text</B></A> we get two runs of
                    // the same rect. One for the Anchor and one for the bold. These two
                    // rects will xor themselves when drawing the wiggly and look like they
                    // did not select. This patch resolves this issue for the time being.
                    if (rcChunk != rcLast)
                    {
                        paryChunks->AppendIndirect(&rcChunk);
                        rcLast = rcChunk;
                    }
                    rcChunk.SetRectEmpty();
                }

                fOnlyOnce = FALSE;

                aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

                // 1. If we failed, return what we have so far
                // 2. If LS returns less than the cell we have asked for we have situation
                //    where one glyph (2 or more characters) is split between separate runs.
                //    That usually happens during selection or drag & drop.
                //    To solve this problem we will go to the next cp in this run and try again.
                //    If we are out of characters in this run we go to the next COneRun and 
                //    try again.
                BOOL fContinueQuery = TRUE;
                hr = S_OK;  // to make compiler happy
                while (fContinueQuery)
                {
                    hr = THR(QueryLineCpPpoint(lscpRunStart, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

                    if(hr || lsTextCell.cpStartCell < lscpRunStart)
                    {
                        ++lscpRunStart;
                        fContinueQuery = (lscpRunStart < porCurrent->_lscpBase + porCurrent->_lscch);
                    }
                    else
                    {
                        fContinueQuery = FALSE;
                    }
                }
                if(hr || lsTextCell.cpStartCell < lscpRunStart)
                {
                    lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                    break;
                }

                long  nDepth = aryLsqsubinfo.Size() - 1;
                Assert(nDepth >= 0);
                const LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth];
                WHEN_DBG( DWORD dwIDObj = qsubinfo.idobj );
                long lAscent = qsubinfo.heightsPresRun.dvAscent;
                long lDescent = fIncludeBorders
                                ? qsubinfo.heightsPresRun.dvDescent
                                : _pMeasurer->_li._yDescent;

                // now set the end position based on which way the subline flows
                fSublineReverseFlow = !!((qsubinfo.lstflowSubline ^ tflow) & fUDirection);

                xStart = lsTextCell.pointUvStartCell.u;

                // If we're querying for a character which cannot be measured (e.g. a
                // section break char), then LS returns the last character it could
                // measure. Therefore, if we are okay, use dupRun for the distance.
                // Otherwise, query the last character of porCurrent. This prevents us
                // having to loop when LS creates dobj's that are cch of five (5).
                if((LSCP)(porCurrent->_lscpBase + porCurrent->_lscch) <= (LSCP)(qsubinfo.cpFirstRun + qsubinfo.dcpRun))
                {
                    xEnd = xStart + (!fSublineReverseFlow
                                     ? qsubinfo.dupRun
                                     : -qsubinfo.dupRun);
                }
                else
                {
                    aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.
                    long lscpLast = min(lscpRunStart + porCurrent->_lscch, _lscpLim);

                    hr = THR(QueryLineCpPpoint(lscpLast, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

                    // If LS returns the cell before than the cell we have asked for we have situation where:
                    // 1) we have queried on lscp pointing on a synthetic run
                    // 2) we have queried on lscp pointing on certain characters, like hyphen
                    // In this case add/subtract the width of the last cell given.
                    xEnd = lsTextCell.pointUvStartCell.u;
                    if (lsTextCell.cpStartCell < lscpLast)
                    {
                        if (fSublineReverseFlow)
                            xEnd -= lsTextCell.dupCell;
                        else
                            xEnd += lsTextCell.dupCell;
                    }
                }

                if (   fIncludeBorders
                    && _li._xWhite
                   )
                {
                    // If we are indeed the last run which contributes to the background
                    // color only then should we consider removing the whitespace from the background.
                    // To find that out, walk the list to verify that we are indeed the last
                    // *visible* run on the line.
                    COneRun *porTemp = porCurrent->_pNext;
                    LONG xWhiteToRemove = _li._xWhite;
                    while (   porTemp
                           && porTemp->_lscpBase < _lscpLim
                          )
                    {
                        if (    porTemp->_pchBase 
                            && *porTemp->_pchBase == WCH_SYNTHETICLINEBREAK
                           )
                        {
                            xWhiteToRemove -= porTemp->_xWidth;
                        }
                        else if (porTemp->IsNormalRun())
                        {
                            xWhiteToRemove = 0;
                            break;
                        }
                        porTemp = porTemp->_pNext;
                    }

                    // OK, so we have some white space which we will remove, but do not
                    // do so until and unless our parent block element does not have borders on it
                    // or it has borders, but is a layout, since if its a layout, we will
                    // not be able to write on its border in anycase!
                    if (xWhiteToRemove)
                    {
                        CTreeNode *pNode = _pMarkup->SearchBranchForBlockElement(pNodeStart);
                        if (pNode)
                        {
                            CElement *pElement = pNode->Element();
                            if (!pElement->_fDefinitelyNoBorders)
                            {
                                CBorderInfo borderinfo;
                                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNode, _pci, &borderinfo, GBIH_NONE);
                            }
                            if (   pNode->ShouldHaveLayout()
                                || pElement->_fDefinitelyNoBorders
                               )
                            {
                                xWhiteToRemove = 0;
                            }
                        }
                    }
                    xEnd -= xWhiteToRemove;

                    // in reverse flow or RTL line, xStart and xEnd may be reversed
                    if (xStart > xEnd)
                    {
                        LONG xTemp = xStart; xStart = xEnd+1; xEnd = xTemp+1;
                    }
                }

                // get the top and bottom for the rect
                if(porCurrent->_fCharsForNestedLayout)
                {
// NOTICE: Absolutely positioned, aligned, and Bold elements are ONERUN_ANTISYNTH types. See note below
                    Assert(dwIDObj == LSOBJID_EMBEDDED);
            
                    CTreeNode *pNodeCur = porCurrent->_ptp->Branch();

                    //
                    // HACK ALERT!!!!!
                    // We do NOT paint selection backgrounds for tables (bug 84820)
                    //
                    if (   fSelection
                        && pNodeCur->Tag() == ETAG_TABLE
                       )
                    {
                        xEnd = xStart;
                    }
                    else
                    {
                        RECT rc;
                        long cyHeight;
                        const CCharFormat* pCF = porCurrent->GetCF();
                        CLayout *pLayout = pNodeCur->GetUpdatedLayout( _pci->GetLayoutContext() );

                        pLayout->GetRect(&rc, COORDSYS_TRANSFORMED);

                        cyHeight = rc.bottom - rc.top;

                        // XProposed and YProposed have been set to the amount of margin
                        // the layout has.                
                        xStart = pLayout->GetXProposed();
                        xEnd = xStart + (rc.right - rc.left);

                        yTop = yPos + pLayout->GetYProposed() + _pMeasurer->_li._yHeightTopOff + _pMeasurer->_li._yBeforeSpace;
                        yBottom = yTop + cyHeight;

                        // take care of any nested relatively positioned elements
                        if(   pCF->_fRelative 
                           && (dwFlags & RFE_NESTED_REL_RECTS))
                        {
                            long xRelLeft = 0, yRelTop = 0;

                            // get the layout's relative positioning to its parent. The parent's relative
                            // positioning would be adjusted in RegionFromElement
                            CTreeNode * pNodeParent = pNodeCur->Parent();
                            if(pNodeParent)
                            {
                                pNodeCur->GetRelTopLeft(pNodeParent->Element(), _pci, &xRelLeft, &yRelTop);
                            }

                            xStart += xRelLeft;
                            xEnd += xRelLeft;
                            yTop += yRelTop;
                            yBottom += yRelTop;
                        }
                    }
                }
                else
                {
                    Assert(dwIDObj == LSOBJID_TEXT || dwIDObj == LSOBJID_GLYPH || fForSynthetic);
                    const CCharFormat* pCF = porCurrent->GetCF();

                    if (porCurrent->_fIsBRRun)
                    {
                        if (fSelection)
                        {
                            if (lAscent == 0)
                            {
                                CCcs ccs;
                                if (GetCcs(&ccs, porCurrent, _pci->_hdc, _pci))
                                {
                                    const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
                                    lAscent = pBaseCcs->_yHeight - pBaseCcs->_yDescent;
                                }
                            }
                        }
                        else
                        {
                            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                            break;
                        }
                    }
                    // The current character does not have height. Throw it out.
                    else if(lAscent == 0 && !fForSynthetic)
                    {
                        lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
                        break;
                    }
                    
                    fForSynthetic = FALSE;

                    if (_fHasVerticalAlign)
                    {
                        yTop = yPos + porCurrent->_yProposed;
                        yBottom = yTop + porCurrent->_yObjHeight;
                    }
                    else
                    {
                        if (fSelection)
                        {
                            yBottom = yPos + _pMeasurer->_li.GetYBottom();
                            yTop = yPos + _pMeasurer->_li.GetYTop();
                        }
                        else
                        {
                            yBottom = yPos + _pMeasurer->_li._yHeight 
                                      - _pMeasurer->_li._yDescent + lDescent;
                            yTop = yBottom - lDescent - lAscent;
                        }
                    }

                    // If we are ruby text, adjust the height to the correct position above the line.
                    if(pCF->_fIsRubyText)
                    {
                        RubyInfo *pRubyInfo = GetRubyInfoFromCp(porCurrent->_lscpBase);

                        if(pRubyInfo)
                        {
                            yBottom = yPos + _pMeasurer->_li._yHeight - _pMeasurer->_li._yDescent 
                                + pRubyInfo->yDescentRubyBase - pRubyInfo->yHeightRubyBase;
                            yTop = yBottom - pRubyInfo->yDescentRubyText - lAscent;
                        }
                    }
                }

                if (fIncludeBorders)
                {
                    topBorder = porCurrent->_mbpTop;
                    bottomBorder = porCurrent->_mbpBottom;
                }
                else
                {
                    topBorder = 0;
                    bottomBorder = 0;
                }
                
                rcChunk.left = xShift + xStart;
                rcChunk.top = yTop - topBorder + curTopBorder;
                rcChunk.bottom = yBottom + bottomBorder - curBottomBorder;
                rcChunk.right = xShift + xEnd;
                rcChunk._fReversedFlow = fSublineReverseFlow;

                lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            }
            break;

        case COneRun::OR_SYNTHETIC:
        {
            if (fIncludeBorders)
            {
                if (porCurrent->_synthType == SYNTHTYPE_MBPOPEN)
                {
                    if (rcChunk != g_Zero.rc)
                    {
                        Assert(leftBorder >= 0);
                        Assert(rightBorder >= 0);

                        rcChunk.left  -= leftBorder;
                        rcChunk.right += rightBorder;
                        rightBorder = leftBorder = 0;

                        // do some reverse flow cleanup before inserting rect into the array
                        if(rcChunk.left > rcChunk.right)
                        {
                            long temp = rcChunk.left;
                            rcChunk.left = rcChunk.right + 1;
                            rcChunk.right = temp + 1;
                        }

                        // In the event we have <A href="x"><B>text</B></A> we get two runs of
                        // the same rect. One for the Anchor and one for the bold. These two
                        // rects will xor themselves when drawing the wiggly and look like they
                        // did not select. This patch resolves this issue for the time being.
                        if (rcChunk != rcLast)
                        {
                            paryChunks->AppendIndirect(&rcChunk);
                            rcLast = rcChunk;
                        }
                        rcChunk.SetRectEmpty();
                    }

                    CRect rcDimensions;
                    BOOL fIgnore;
                    DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                    // Ignore negative margins
                    porCurrent->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                    dwFlags |= (rcDimensions.left > 0) ? GIMBPC_MARGINONLY : 0;

                    porCurrent->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                    leftBorder += rcDimensions.left;
                }
                else if (porCurrent->_synthType == SYNTHTYPE_MBPCLOSE)
                {
                    CRect rcDimensions;
                    BOOL fIgnore;
                    DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                    // Ignore negative margins
                    porCurrent->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                    dwFlags |= (rcDimensions.right > 0) ? GIMBPC_MARGINONLY : 0;

                    porCurrent->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                    rightBorder += rcDimensions.right;
                }
            }

            const CLineServices::SYNTHDATA & synthdata = CLineServices::s_aSynthData[porCurrent->_synthType];

            if (   (   synthdata.idObj == idObjTextChp
                    && fSelection
                    && porCurrent->IsSelected()
                   )
                || (    fWigglyRects
                     && (   porCurrent->_synthType == SYNTHTYPE_MBPOPEN
                         || porCurrent->_synthType == SYNTHTYPE_MBPCLOSE
                        )
                   )
               )
            {
                fForSynthetic = TRUE;
                goto Normal;
            }

            // We want to set the lscpRunStart to move to the next start position
            // when dealing with synthetics (reverse objects, etc.)
            lscpRunStart = porCurrent->_lscpBase + porCurrent->_lscch;
            break;
        }
        
        case COneRun::OR_ANTISYNTHETIC:
            // NOTICE:
            // this case covers absolutely positioned elements and aligned elements
            // However, per BrendanD and SujalP, this is not the correct place
            // to implement focus rects for these elements. Some
            // work needs to be done to the CAdorner to properly 
            // handle absolutely positioned elements. RegionFromElement should handle
            // frames for aligned objects.
            break;

        default:
            Assert("Missing COneRun type");
            break;
        }

Next:
        porCurrent = porCurrent->_pNext;
    }

    if (rcChunk != g_Zero.rc)
    {
        // We need to include the borders in the rects that we return
        if (fIncludeBorders)
        {
            // Figure out the width of the right border
            if (lscpEnd != _lscpLim)
            {
                COneRun * por = FindOneRun(lscpEnd);

                // The end might actually be before the por found by FindOneRun.
                // To find the actual por, we will need to go to a COneRun object
                // which has the same pNode as the start and also the same lscp
                if (!SameScope(por->Branch(), pNodeStart))
                {
                    COneRun *porTemp = por->_pPrev;
                    while(   porTemp
                          && porTemp->_lscpBase == por->_lscpBase
                         )
                    {
                        if (SameScope(porTemp->Branch(), pNodeStart))
                        {
                            por = porTemp;
                            break;
                        }
                        porTemp = porTemp->_pPrev;
                    }
                    // If we did not find a por with the same lscp as por and
                    // the same node as pNodeStart, then we do not touch the por at all
                }

                while (por && (por->_lscpBase >= lscpEnd))
                {
                    if (    por->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE
                        && !por->_fHidden)
                    {
                        CRect rcDimensions;
                        BOOL fIgnore;
                        DWORD dwFlags = GIMBPC_BORDERONLY | GIMBPC_PADDINGONLY;

                        // Ignore negative margins
                        por->GetInlineMBP(_pci, GIMBPC_MARGINONLY, &rcDimensions, &fIgnore, &fIgnore);
                        dwFlags |= (rcDimensions.right > 0) ? GIMBPC_MARGINONLY : 0;

                        por->GetInlineMBP(_pci, dwFlags, &rcDimensions, &fIgnore, &fIgnore);
                        rightBorder += rcDimensions.right;
                    }
                            
                    por = por->_pPrev;
                }

                Assert(rightBorder >= 0);
            }
        }

        // do some reverse flow cleanup before inserting rect into the array
        if (rcChunk.left > rcChunk.right)
        {
            long temp = rcChunk.left;
            rcChunk.left = rcChunk.right + 1;
            rcChunk.right = temp + 1;
        }

        Assert(leftBorder >= 0);
        Assert(rightBorder >= 0);

        rcChunk.left  -= leftBorder;
        rcChunk.right += rightBorder;
        rightBorder = leftBorder = 0;

        // In the event we have <A href="x"><B>text</B></A> we get two runs of
        // the same rect. One for the Anchor and one for the bold. These two
        // rects will xor themselves when drawing the wiggly and look like they
        // did not select. This patch resolves this issue for the time being.
        if (rcChunk != rcLast)
        {
            paryChunks->AppendIndirect(&rcChunk);
            rcLast = rcChunk;
        }
        rcChunk.SetRectEmpty();
    }

    return paryChunks->Size();
}

//-----------------------------------------------------------------------------
//
// Member:      CLineServices::RecalcLineHeight()
//
// Synopsis:    Reset the height of the the line we are measuring if the new
//              run of text is taller than the current maximum in the line.
//
//-----------------------------------------------------------------------------
void CLineServices::RecalcLineHeight(const CCharFormat *pCF, LONG cp, CCcs * pccs, CLineFull *pli)
{
    AssertSz(pli,  "we better have a line!");
    AssertSz(pccs, "we better have a some metric's here");

    if(pccs)
    {
        LONG yAscent;
        LONG yDescent;

        pccs->GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);

        if(yAscent < pli->_yHeight - pli->_yDescent)
            yAscent = pli->_yHeight - pli->_yDescent;
        if(yDescent > pli->_yDescent)
            pli->_yDescent = yDescent;

        pli->_yHeight        = yAscent + pli->_yDescent;

        Assert(pli->_yHeight >= 0);

        if (!pCF->_cuvLineHeight.IsNull())
        {
            const CUnitValue *pcuvUseThis = &pCF->_cuvLineHeight;
            long lFontHeight = 1;

            if (pcuvUseThis->GetUnitType() == CUnitValue::UNIT_FLOAT)
            {
                CUnitValue cuv;
                cuv = pCF->_cuvLineHeight;
                cuv.ScaleTo ( CUnitValue::UNIT_EM );
                pcuvUseThis = &cuv;
                lFontHeight = pCF->GetHeightInTwips( _pFlowLayout->Doc() );
            }
            NoteLineHeight(cp, pcuvUseThis->YGetPixelValue(_pci, 0, lFontHeight));
        }
    }
}


//-----------------------------------------------------------------------------
//
// Member:      TestFortransitionToOrFromRelativeChunk
//
// Synopsis:    Test if we are transitioning from a relative chunk to normal
//                chunk or viceversa
//
//-----------------------------------------------------------------------------
void
CLineServices::TestForTransitionToOrFromRelativeChunk(
    LONG cp,
    BOOL fRelative,
    BOOL fForceChunk,
    CTreeNode *pNode,
    CElement *pElementLayout)
{
    CTreeNode * pNodeRelative = NULL;
    BOOL fRTLFlow;
    LONG xPos = CalculateXPositionOfCp(cp, FALSE, &fRTLFlow);
    BOOL fDirectionChange = (!fRTLFlow != !_fLastChunkRTL);

    // Also force a chunk when direction changes
    if (fDirectionChange)
        fForceChunk = TRUE;

    // if the current line is relative and the chunk is not
    // relative or if the current line is not relative and the
    // the current chunk is relative then break out.
    if (fForceChunk || fRelative)
        pNodeRelative = pNode->GetCurrentRelativeNode(_pFlowLayout->ElementOwner());

    // note: this is the only caller of UpdateRelativeChunk
    if (fForceChunk || DifferentScope(_pElementLastRelative, pNodeRelative))
        UpdateRelativeChunk(cp, pNodeRelative->SafeElement(), pElementLayout, xPos /*logical*/, fRTLFlow);
}

//-----------------------------------------------------------------------------
//
// Member:        UpdateRelativeChunk
//
// Synopsis:    We have just transitioned from a relative chunk to normal chunk
//              or viceversa, or inbetween relative chunks, so update the last
//              chunk information.
//
//-----------------------------------------------------------------------------
void
CLineServices::UpdateRelativeChunk(
    LONG cp,
    CElement *pElementRelative,
    CElement *pElementLayout,
    LONG xPosCurrChunk,  // logical
    BOOL fRTLFlow)
{
    // Mirror position if RTL line
    if (_li._fRTLLn)
    {
        xPosCurrChunk = _li._xWidth - xPosCurrChunk;
    }

    // only add a chunk if cp has advanced or if flow direction has changed
    // (an empty chunk of opposite direction is required for the logic of FixupChunks
    if (cp > _cpLastChunk || fRTLFlow != _fLastChunkRTL)
    {

        // If flow direction has changed, the current chunk position is not helpful for
        // calculation of last chunk width. We need to get the position of the end of previous chunk
        LONG xEndLastChunk;
        if (_fLastChunkRTL == fRTLFlow)
        {
            // same direction
            xEndLastChunk = xPosCurrChunk;
        }
        else
        {
            // direction change
            xEndLastChunk = _xPosLastChunk; // this works for the leading empty chunk

            // Find end of previous chunk (the point where direction changes 
            // is where the interesting X position is)
            for (LONG cpLimLastChunk = cp; cpLimLastChunk > _cpLastChunk; cpLimLastChunk--)
            {
                BOOL fRTLFlowPrev;
                xEndLastChunk = CalculateXPositionOfCp(cpLimLastChunk, TRUE /*fAfterPrevCp*/, &fRTLFlowPrev);
                if (fRTLFlowPrev != fRTLFlow)
                    break;
            }
        }

        // width and position calculations depend on direction of the chunk we are adding
        LONG xLeftLastChunk;
        LONG xWidthLastChunk;
        if (!_fLastChunkRTL)
        {
            // LTR
            xLeftLastChunk = _xPosLastChunk;
            xWidthLastChunk = xEndLastChunk - _xPosLastChunk;

            // TODO RTL 112514: for some reason, we don't need to remove a pixel for opposite flow in this case. Why?
        }
        else
        {
            // RTL
            xLeftLastChunk = xEndLastChunk;
            xWidthLastChunk = _xPosLastChunk - xEndLastChunk;

            // Adjust position for opposite-direction inclusiveness 
            if (!_li._fRTLLn)
            {
                xLeftLastChunk++;
            }
        }
        

        CLSLineChunk * plcNew = new CLSLineChunk();
        if (plcNew)
        {
            plcNew->_cch             = cp  - _cpLastChunk;
            plcNew->_xLeft           = xLeftLastChunk;
            plcNew->_xWidth          = xWidthLastChunk;
            plcNew->_fRelative       = _pElementLastRelative != NULL;
            plcNew->_fSingleSite     = _fLastChunkSingleSite;
            plcNew->_fRTLChunk       = _fLastChunkRTL;

            // append this chunk to the line
            if(_plcLastChunk)
            {
                Assert(!_plcLastChunk->_plcNext);

                _plcLastChunk->_plcNext = plcNew;
                _plcLastChunk = plcNew;
            }
            else
            {
                _plcLastChunk = _plcFirstChunk = plcNew;
            }
        }
    }
    
    // after a new chunk is added, the current chunk immediately becomes "last"
    _xPosLastChunk        = xPosCurrChunk;
    _fLastChunkRTL        = fRTLFlow;

    _cpLastChunk          = cp;
    _pElementLastRelative = pElementRelative;
    _fLastChunkSingleSite =    pElementLayout
                            && pElementLayout->IsOwnLineElement(_pFlowLayout);
}

//-----------------------------------------------------------------------------
//
// Member:      HasBorders()
//
// Synopsis:    Look at the fancy format to see if borders have been set
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::HasBorders(const CFancyFormat* pFF, const CCharFormat* pCF, BOOL fIsPseudo)
{
    // Fill the CBorderInfo structure
    CBorderInfo borderInfo;
    GetBorderInfoHelperEx(pFF, pCF, _pci, &borderInfo, fIsPseudo ? GBIH_PSEUDO : GBIH_NONE);

    return (borderInfo.wEdges & BF_RECT);
}

//-----------------------------------------------------------------------------
//
// Member:      GetKashidaWidth()
//
// Synopsis:    gets the width of the kashida character (U+0640) for Arabic
//              justification
//
//-----------------------------------------------------------------------------
LSERR 
CLineServices::GetKashidaWidth(PLSRUN plsrun, int *piKashidaWidth)
{
    LSERR lserr = lserrNone;
    HRESULT hr = S_OK;
    XHDC hdc = _pci->_hdc;
    FONTIDX hfontOld = HFONT_INVALID;
    XHDC hdcFontProp(NULL,NULL);
    CCcs ccs;
    SCRIPT_CACHE *psc = NULL;

    SCRIPT_FONTPROPERTIES  sfp;
    sfp.cBytes = sizeof(SCRIPT_FONTPROPERTIES);

    if (!GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    psc = ccs.GetUniscribeCache();
    Assert(psc != NULL);

    hr = ScriptGetFontProperties(hdcFontProp, psc, &sfp);
    
    AssertSz(hr != E_INVALIDARG, "You might need to update USP10.DLL");

    // Handle failure
    if(hr == E_PENDING)
    {
        Assert(hdcFontProp == NULL);

        // Select the current font into the hdc and set hdcFontProp to hdc.
        hfontOld = ccs.PushFont(hdc);
        hdcFontProp = hdc;

        hr = ScriptGetFontProperties(hdcFontProp, psc, &sfp);

    }
    Assert(hr == S_OK || hr == E_OUTOFMEMORY);

    lserr = LSERRFromHR(hr);

    if(lserr == lserrNone)
    {
        *piKashidaWidth = max(sfp.iKashidaWidth, 1);

        const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
        Assert(pBaseCcs);
        if(pBaseCcs->_fScalingRequired)
            *piKashidaWidth *= pBaseCcs->_flScaleFactor;
    }

Cleanup:
    // Restore the font if we selected it
    if (hfontOld != HFONT_INVALID)
    {
        ccs.PopFont(hdc, hfontOld);
    }

    return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\font.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module FONT.C -- font cache
 *
 *  Owner: GrzegorZ, SujalP and DmitryT
 *
 *  Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DeclareTag( tagTextOutA, "TextOut", "Render using TextOutA always." );
DeclareTag( tagTextOutFE, "TextOut", "Reneder using FE ExtTextOutW workaround.");
DeclareTag( tagCCcsMakeFont, "Font", "Trace CCcs::MakeFont");
DeclareTag( tagCCcsCompare, "Font", "Trace CCcs::Compare");
DeclareTag( tagFontLeaks, "Font", "Trace HFONT leaks");
DeclareTag( tagFontNoWidth, "Font", "Trace no width");

MtDefine(CCcs, PerProcess, "CCcs");
MtDefine(CBaseCcs, PerProcess, "CBaseCcs");
MtDefine(CWidthCache, PerProcess, "CWidthCache");
MtDefine(CWidthCacheEntry, CWidthCache, "CWidthCache::GetEntry");

//
// UseScreenDCForMeasuring()
// 
// We were using printer DC to measure fonts when printing. That is not 
// the right thing to do with printer-independent measurement. When combined 
// with huge virtual printer resolution, it has produced bogus font data on some 
// printers. The bogus fonts are probably a printer driver bug, but using 
// printer DC for anything other than final output is wrong in the new printing 
// model.
// 
// The fix is to always use screen-compatible DC for font measurements. Note 
// that in the future, we may need to make a special case for printer fonts, 
// which can only be measured in printer DC. 
//
// In IE5.5, printer fonts are not supported.
//
// (This fixes bug 101791: HOT IE 5.5 2827: Printing http://www.msn.com home page, 
// text is overlayed, missing and out of place.)
//
void UseScreenDCForMeasuring(XHDC *pxhdc)
{
#if NEEDED // DBG==1
    // Font measurements should never be taken from printer DC. 
    // That's how it becines printer-independent

    int technology = GetDeviceCaps(pxhdc->GetFontInfoDC(), TECHNOLOGY);
    int logpixel_x = GetDeviceCaps(pxhdc->GetFontInfoDC(), LOGPIXELSX);

    if (technology != DT_RASDISPLAY ||
        logpixel_x > 200)
    {
        AssertSz(FALSE, "We must not take font metrics from printer DC!");
    }
#endif

    *pxhdc = XHDC(TLS(hdcDesktop), NULL);
}

//+----------------------------------------------------------------------------
//
//  Begin font wrappers
//
//-----------------------------------------------------------------------------

// We need this wrapper to compile. 
// In this file (font.cxx) GetCharWidth32 is resolved to wrapper from 
//      mshtml\src\core\include\xgdiwrap.h
// But in flowlyt.cxx GetCharWidth32 is resolved to wrapper from <w95wrap.h>
// No time to investigate this problem.
BOOL GetCharWidthHelper(XHDC hdc, UINT c, LPINT piWidth)
{
    return GetCharWidth32(hdc, c, c, piWidth);
}

//#if DBG != 1

inline BOOL    DeleteFontIdx(FONTIDX hfont)         { return DeleteFontEx(hfont); }
inline FONTIDX GetSystemFontIdx()                   { return (HFONT)GetStockObject(SYSTEM_FONT); }
inline FONTIDX GetCurrentFontIdx(XHDC hdc)          { return (HFONT)GetCurrentObject(hdc, OBJ_FONT); }
inline FONTIDX CreateFontIndirectIdx(CONST LOGFONT *lplf) { return CreateFontIndirect(lplf); }
inline FONTIDX PushFontIdx(XHDC hdc, FONTIDX idx)   { return SelectFontEx(hdc, idx); }
inline FONTIDX PopFontIdx(XHDC hdc, FONTIDX idx)    { return SelectFontEx(hdc, idx); }
inline HFONT   GetFontFromIdx(FONTIDX idx)          { return idx; }

//#else
#if DBG == 1

MtDefine(IdxToHFONT, PerProcess, "CIdxToHFONT")

// ----------------------------------------------------------------------------
// Implementation of HDC <=> HFONT mapping; HFONT leaks detection
// ----------------------------------------------------------------------------
const int cMapSize = 1024;
class CDCToHFONT
{
    HDC   _dc[cMapSize];
    HFONT _font[cMapSize];
    DWORD _objType[cMapSize];
public:
    CDCToHFONT() 
    {
        memset(_dc, 0, cMapSize*sizeof(HDC));
        memset(_font, 0, cMapSize*sizeof(HFONT));
        memset(_objType, 0, cMapSize*sizeof(DWORD));
    };
    void Assign(HDC hdc, HFONT hfont) 
    {
        int freePos = -1;
        for (int i = 0; i < cMapSize; i++) 
        {
            if (_dc[i] == hdc) 
            {
                _font[i] = hfont;
                return;
            } 
            else if (freePos == -1 && _dc[i] == 0)
                freePos = i;
        }
        if (freePos == -1) 
        {
            CleanMap();
            for (int i = 0; i < cMapSize; i++) 
            {
                if (_dc[i] == 0) 
                {
                    freePos = i;
                    break;
                }
            }
            Assert(freePos != -1);
        }
        _dc[freePos] = hdc;
        _font[freePos] = hfont;
        _objType[freePos] = ::GetObjectType(hdc);
    };
    int FindNextFont(int posStart, HFONT hfont) 
    {
        for (int i = posStart; i < cMapSize; i++) 
        {
            if (_font[i] == hfont)
                return i;
        }
        return -1;
    };
    void CleanMap() 
    {
        for (int i = 0; i < cMapSize; i++) 
        {
            if (_objType[i] != OBJ_DC) 
            {
                _dc[i] = 0;
                _font[i] = 0;
                _objType[i] = 0;
            }
        }
    };
    void Erase(int pos) 
    {
        _dc[pos] = 0;
        _font[pos] = 0;
        _objType[pos] = 0;
    };
    HFONT Font(int pos) 
    {
        return _font[pos];
    };
    HDC DC(int pos) 
    {
        return _dc[pos];
    };
};

#ifdef NEVER
// ----------------------------------------------------------------------------
// Implementation of index <=> HFONT mapping
// ----------------------------------------------------------------------------
class CIdxToHFONT
{
    struct FONTDATA {
        HFONT _font;
        DWORD _data;
    };
    enum {
        MASK_CREATED = 0x80000000,
        MASK_ALL     = 0x80000000
    };
    FONTDATA *   _afd;
    size_t       _size;
    const size_t _cchunk;
    CRITICAL_SECTION _cs;

    void Alloc();
    void Realloc();
    DWORD Ref(FONTIDX idx)       const { return (_afd[idx]._data & ~MASK_ALL); };
    void  SetCreated(FONTIDX idx)      { _afd[idx]._data |= MASK_CREATED; };

    FONTIDX Add(HFONT hfont, BOOL fCreated);

public:
    CIdxToHFONT();
    ~CIdxToHFONT();

    BOOL  IsCreated(FONTIDX idx) const { return !!(_afd[idx]._data & MASK_CREATED); };
    void ClearFontData(FONTIDX idx)    { _afd[idx]._font = HFONT_INVALID; _afd[idx]._data = 0; };

    FONTIDX AddFont(HFONT hfont, BOOL fCreated);
    FONTIDX IdxFromHFont(HFONT hfont, BOOL fAdd);
    HFONT RemoveFont(FONTIDX idx);
    HFONT HFontFromIdx(FONTIDX idx);

    void AddRef(FONTIDX idx);
    void Release(FONTIDX idx, BOOL fStrict);
};

CIdxToHFONT::CIdxToHFONT()
    : _cchunk(32) 
{
    HrInitializeCriticalSection(&_cs);
    _size = 0;
    _afd  = 0;
    Alloc();
}
CIdxToHFONT::~CIdxToHFONT() 
{
    MemFree((void *)_afd);
    DeleteCriticalSection(&_cs);
}
void CIdxToHFONT::Alloc() 
{
    Assert(_size == 0);
    _afd = (FONTDATA *) MemAlloc(Mt(IdxToHFONT), _cchunk * sizeof(FONTDATA));
    memset((void *)_afd, 0, _cchunk * sizeof(FONTDATA));
    _size += _cchunk;
}
void CIdxToHFONT::Realloc() 
{
    MemRealloc(Mt(IdxToHFONT), (void **)&_afd, (_size + _cchunk) * sizeof(FONTDATA));
    memset((void *)(_afd + _size), 0, _cchunk * sizeof(FONTDATA));
    _size += _cchunk;
}
FONTIDX CIdxToHFONT::Add(HFONT hfont, BOOL fCreated) 
{
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == HFONT_INVALID)
            break;
        ++i;
    }
    if (i == _size)
    {
        Realloc();
        Assert(i == _size - _cchunk);
    }
    Assert(_afd[i]._data == 0);
    _afd[i]._font = hfont;
    if (fCreated)
        SetCreated(i);
    return i;
};
FONTIDX CIdxToHFONT::AddFont(HFONT hfont, BOOL fCreated) 
{
    EnterCriticalSection(&_cs);
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == hfont)
        {
            AssertSz(fCreated, "Duplicate font handle");
            break;
        }
        ++i;
    }
    if (i == _size)
        i = Add(hfont, fCreated);
    LeaveCriticalSection(&_cs);
    return i;
};
HFONT CIdxToHFONT::RemoveFont(FONTIDX idx) 
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    AssertSz(IsCreated(idx), "Deleting non-Trident created font");
    AssertSz(Ref(idx) == 0,  "Deleting selected font");
    HFONT hfont = _afd[idx]._font;
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    ClearFontData(idx);
    LeaveCriticalSection(&_cs);
    return hfont;
};
FONTIDX CIdxToHFONT::IdxFromHFont(HFONT hfont, BOOL fAdd) 
{
    EnterCriticalSection(&_cs);
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    size_t i = 1;       // skip 0
    while (i < _size)
    {
        if (_afd[i]._font == hfont)
            break;
        ++i;
    }
    if (i == _size)
    {
        AssertSz(fAdd, "Font index not found");
        i = AddFont(hfont, FALSE);
    }
    LeaveCriticalSection(&_cs);
    return i;
};

HFONT CIdxToHFONT::HFontFromIdx(FONTIDX idx) 
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    HFONT hfont = _afd[idx]._font;
    AssertSz(hfont != HFONT_INVALID, "Got invalid font handle");
    LeaveCriticalSection(&_cs);
    return hfont;
};

void CIdxToHFONT::AddRef(FONTIDX idx)
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    ++_afd[idx]._data;
    AssertSz(Ref(idx) != 0, "Ref counter overflow");
    LeaveCriticalSection(&_cs);
};

void CIdxToHFONT::Release(FONTIDX idx, BOOL fStrict)
{
    EnterCriticalSection(&_cs);
    AssertSz(idx < _size,    "Accessing non-existing entry");
    if (Ref(idx) == 0)
        AssertSz(!fStrict, "Releasing unselected object");
    else
        --_afd[idx]._data;
    LeaveCriticalSection(&_cs);
};
CIdxToHFONT g_mIdx2HFont;
#endif

CDCToHFONT mDc2Font;

inline BOOL IsFontHandle(HFONT hfont)
{
    // WIN64: GetObjectType is returning zero.
#ifndef _WIN64
    return (OBJ_FONT == GetObjectType(hfont));
#else
    return TRUE;
#endif
}

#ifdef NEVER

inline BOOL DeleteFontIdx(FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.RemoveFont(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return DeleteFontEx(hfont);
}

inline FONTIDX GetSystemFontIdx()
{
    HFONT hfont = (HFONT)GetStockObject(SYSTEM_FONT);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.AddFont(hfont, FALSE);
}

inline FONTIDX CreateFontIndirectIdx(CONST LOGFONT *lplf)
{
    HFONT hfont = CreateFontIndirect(lplf);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.AddFont(hfont, TRUE);
}

inline FONTIDX GetCurrentFontIdx(XHDC hdc)
{
    HFONT hfont = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    return g_mIdx2HFont.IdxFromHFont(hfont, TRUE);
}

FONTIDX PushFontIdx(XHDC hdc, FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.HFontFromIdx(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    HFONT hfontold = SelectFontEx(hdc, hfont);
    AssertSz(IsFontHandle(hfontold), "This is not valid font handle");

    g_mIdx2HFont.AddRef(idx);
    FONTIDX idxold = g_mIdx2HFont.IdxFromHFont(hfontold, FALSE);
    g_mIdx2HFont.Release(idxold, FALSE);

    return idxold;
}

FONTIDX PopFontIdx(XHDC hdc, FONTIDX idx)
{
    HFONT hfont = g_mIdx2HFont.HFontFromIdx(idx);
    AssertSz(IsFontHandle(hfont), "This is not valid font handle");
    HFONT hfontold = SelectFontEx(hdc, hfont);
    AssertSz(IsFontHandle(hfontold), "This is not valid font handle");

    g_mIdx2HFont.AddRef(idx);
    FONTIDX idxold = g_mIdx2HFont.IdxFromHFont(hfontold, FALSE);
    g_mIdx2HFont.Release(idxold, TRUE);

    // if we are selecting back font not created by us, remove it from our mapping
    if (!g_mIdx2HFont.IsCreated(idx))
    {
        g_mIdx2HFont.ClearFontData(idx);
    }

    return idxold;
}

inline HFONT GetFontFromIdx(FONTIDX idx)
{ 
    return g_mIdx2HFont.HFontFromIdx(idx);; 
}

#endif

HFONT SelectFontEx(XHDC hdc, HFONT hfont)
{
    if (IsTagEnabled(tagFontLeaks))
    {
        mDc2Font.Assign(hdc.GetDebugDC(), hfont);
    }
    return SelectFont(hdc.GetDebugDC(), hfont);
}

BOOL DeleteFontEx(HFONT hfont)
{
    if (IsTagEnabled(tagFontLeaks))
    {
        int pos = -1;
        while (-1 != (pos = mDc2Font.FindNextFont(pos+1, hfont))) 
        {
            TraceTag((tagFontLeaks, "##### Attempt to delete selected font"));
            SelectObject(mDc2Font.DC(pos), GetStockObject(SYSTEM_FONT));
            mDc2Font.Erase(pos);
        }
    }
    return DeleteObject((HGDIOBJ)hfont);
}

#endif // DBG==1
//+----------------------------------------------------------------------------
//
//  End font wrappers
//
//-----------------------------------------------------------------------------

#define CLIP_DFA_OVERRIDE   0x40    //  Used to disable Korea & Taiwan font association

// corresponds to yHeightCharPtsMost in textedit.h
#define yHeightCharMost 32760

ExternTag(tagMetrics);

static TCHAR lfScriptFaceName[LF_FACESIZE] = _T("Script");

inline const TCHAR * Arial() { return _T("Arial"); }
inline const TCHAR * TimesNewRoman() { return _T("Times New Roman"); }


// U+0000 -> U+4DFF     All Latin and other phonetics.
// U+4E00 -> U+ABFF     CJK Ideographics
// U+AC00 -> U+FFFF     Korean+, as Korean ends at U+D7A3

// For 2 caches at CJK Ideo split, max cache sizes {256,512} that give us a
// respective collision rate of <4% and <22%, and overall rate of <8%.
// Stats based on a 300K char Japanese text file.
const INT maxCacheSize[TOTALCACHES] = {255, 511, 511};

DeclareTag(tagFontCache, "FontCache", "FontCache");

#define IsZeroWidth(ch) ((ch) >= 0x0300 && IsZeroWidthChar((ch)))

//
// Work around Win9x GDI bugs
//

static inline BOOL
FEFontOnNonFE95(BYTE bCharSet)
{
    // Use ExtTextOutA to hack around all sort of Win95FE EMF or font problems
    return VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID &&
            !g_fFarEastWin9X &&
            IsFECharset(bCharSet);
}

#if DBG==1
LONG CBaseCcs::s_cMaxCccs = 0;
LONG CBaseCcs::s_cTotalCccs = 0;
#endif

// =============================  CBaseCcs  class  ============================

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::Init
//
//  Synopsis:   Init one font cache object. The global font cache stores
//              individual CBaseCcs objects.
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::Init(
    XHDC hdc,                       // HDC into which font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    LONG latmBaseFaceName,
    BOOL fForceTTFont)
{
    Assert(pdci && pdci->_pDoc);

    _sc = NULL; // Initialize script cache to NULL - COMPLEXSCRIPT
    _fPrinting = pdci->_pMarkup->IsPrintMedia();
    _bConvertMode = CM_NONE;
    _fScalingRequired = FALSE;

    if (MakeFont(hdc, pcf, pdci, fForceTTFont))
    {
        _bCrc = pcf->_bCrcFont;
        _yCfHeight = pcf->_yHeight;
        _latmBaseFaceName = latmBaseFaceName;
        _fHeightAdjustedForFontlinking = FALSE;

        // TODO: (cthrash, track bug 112152) This needs to be removed.  We used to calculate
        // this all the time, now we only calculate it on an as-needed basis,
        // which means at intrinsics fontlinking time.
      
        _dwLangBits = 0;

        _dwAge = fc()._dwAgeNext++;

        return TRUE;         // successfully created a new font cache.
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::ReleaseScriptCache
//
//-----------------------------------------------------------------------------

void
CBaseCcs::ReleaseScriptCache()
{
    // Free the script cache
    if (_sc)
    {
        ::ScriptFreeCache(&_sc);
        // NB (mikejoch) If ScriptFreeCache() fails then there is no way to
        // free the cache, so we'll end up leaking it. This shouldn't ever
        // happen since the only way for _sc to be non- NULL is via some other
        // USP function succeeding.

        Assert(_sc == NULL);
        _sc = NULL; // A safety value so we don't crash.
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PrivateRelease
//
//-----------------------------------------------------------------------------

void
CBaseCcs::PrivateRelease()
{
    if (InterlockedDecrement((LONG *)&_dwRefCount) == 0)
        delete this;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GrabInitNewBaseCcs
//
//  Synopsis:   Create a logical font and store it in our cache.
//
//-----------------------------------------------------------------------------

CBaseCcs *
CFontCache::GrabInitNewBaseCcs(
    XHDC hdc,                       // HDC into which font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    LONG latmBaseFaceName,
    BOOL fForceTTFont)
{
    int     i;
    int     iReplace = -1;
    int     iOldest = -1;
    DWORD   dwAgeReplace = 0xffffffff;
    DWORD   dwAgeOldest = 0xffffffff;
    CBaseCcs *pBaseCcsNew = new CBaseCcs();

    // Initialize new CBaseCcs
    if (!pBaseCcsNew || !pBaseCcsNew->Init(hdc, pcf, pdci, latmBaseFaceName, fForceTTFont))
    {
        if (pBaseCcsNew)
            pBaseCcsNew->PrivateRelease();

        AssertSz(FALSE, "CFontCache::GrabInitNewBaseCcs init of entry FAILED");
        return NULL;
    }

    MemSetName((pBaseCcsNew, "CBaseCcs F:%ls, H:%d, W:%d", pBaseCcsNew->_lf.lfFaceName, -pBaseCcsNew->_lf.lfHeight, pBaseCcsNew->_lf.lfWeight));

    // Don't cache in 'force TrueType' mode
    if (!fForceTTFont)
    {
        // look for unused entry and oldest in use entry
        for(i = 0; i < CFontCache::cFontCacheSize && _rpBaseCcs[i]; i++)
        {
            CBaseCcs * pBaseCcs = _rpBaseCcs[i];
            if (pBaseCcs->_dwAge < dwAgeOldest)
            {
                iOldest = i;
                dwAgeOldest = pBaseCcs->_dwAge;
            }
            if (pBaseCcs->_dwRefCount == 1)
            {
                if (pBaseCcs->_dwAge < dwAgeReplace)
                {
                    iReplace  = i;
                    dwAgeReplace = pBaseCcs->_dwAge;
                }
            }
        }

        if (i == CFontCache::cFontCacheSize)     // Didn't find an unused entry, use oldest entry
        {
            int hashKey;
            // if we didn't find a replacement, replace the oldest
            if (iReplace == -1)
            {
                Assert(iOldest != -1);
                iReplace = iOldest;
            }

#if DBG == 1
            _cCccsReplaced++;
#endif

            hashKey = _rpBaseCcs[iReplace]->_bCrc & CFontCache::cQuickCrcSearchSize;
            if (quickCrcSearch[hashKey].pBaseCcs == _rpBaseCcs[iReplace])
            {
                quickCrcSearch[hashKey].pBaseCcs = NULL;
            }

            TraceTag((tagFontCache, "Releasing font(F:%ls, H:%d, W:%d) from slot %d",
                      _rpBaseCcs[iReplace]->_lf.lfFaceName,
                      -_rpBaseCcs[iReplace]->_lf.lfHeight,
                      _rpBaseCcs[iReplace]->_lf.lfWeight,
                      iReplace));

            _rpBaseCcs[iReplace]->PrivateRelease();
            i = iReplace;
        }

        TraceTag((tagFontCache, "Storing font(F:%ls, H:%d, W:%d) in slot %d",
                  pBaseCcsNew->_lf.lfFaceName,
                  -pBaseCcsNew->_lf.lfHeight,
                  pBaseCcsNew->_lf.lfWeight,
                  i));

        _rpBaseCcs[i]  = pBaseCcsNew;
    }

    return pBaseCcsNew;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::MakeFont
//
//  Synopsis:   Wrapper, setup for CreateFontIndirect() to create the font to be
//              selected into the HDC.
//
//  Returns:    TRUE if OK, FALSE if allocation failure
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::MakeFont(
    XHDC hdc,                       // HDC into which  font will be selected
    const CCharFormat * const pcf,  // description of desired logical font
    CDocInfo * pdci,
    BOOL fForceTTFont)
{
    BOOL fTweakedCharSet = FALSE;
    FONTIDX hfontOriginalCharset = HFONT_INVALID;
    TCHAR pszNewFaceName[LF_FACESIZE];
    const CODEPAGE cpDoc = pdci->_pMarkup->GetFamilyCodePage();
    const LCID lcid = pcf->_lcid;
    BOOL fRes;
    LONG lfHeight;

    // Note (paulpark): We must be careful with _lf.  It is important that
    // _latmLFFaceName be kept in sync with _lf.lfFaceName.  The way to do that
    // is to use the SetLFFaceName function.
    SetLFFaceNameAtm(pcf->_latmFaceName);

    // We need the _sCodePage in case we need to call ExtTextOutA rather than ExtTextOutW.  
    _sCodePage = (USHORT)DefaultCodePageFromCharSet(pcf->_bCharSet, cpDoc);

    // Computes font height
    AssertSz(pcf->_yHeight <= INT_MAX, "It's too big");

    //  Roundoff can result in a height of zero, which is bad.
    //  If this happens, use the minimum legal height.
    lfHeight = -(const_cast<CCharFormat *const>(pcf)->GetHeightInPixels(hdc, pdci));
    if (lfHeight > 0)
    {
        lfHeight = -lfHeight;       // TODO: do something more intelligent...
    }
    else if (!lfHeight)
    {
        lfHeight--;                 // round error, make this a minimum legal height of -1.
    }
    
    _lf.lfHeight = _yOriginalHeight = lfHeight;
    _lf.lfWidth  = 0;

    _lf.lfWeight        = (pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL);
    _lf.lfItalic        = pcf->_fItalic;
    _lf.lfUnderline     = 0; // pcf->_fUnderline;
    _lf.lfStrikeOut     = 0; // pcf->_fStrikeOut;
    _lf.lfCharSet       = pcf->_bCharSet;
    _lf.lfEscapement    = 0;
    _lf.lfOrientation   = 0;
    _lf.lfOutPrecision  = OUT_DEFAULT_PRECIS;
    if (pcf->_fOutPrecision)
        _lf.lfOutPrecision = (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS) ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
    if (fForceTTFont)
        _lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    _lf.lfQuality       = DEFAULT_QUALITY;
    _lf.lfPitchAndFamily = _bPitchAndFamily = pcf->_bPitchAndFamily;
    _lf.lfClipPrecision = CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;

    //
    // Don't pick a non-TT font if we cannot find any default font for sid.
    // Ex. For surrogated (sidSurrogateA/B) on 9x/NT4 systems we may not 
    // have any font, which support them, so pcf->_latmFaceName in this case 
    // is 0.
    // We used to set pcf->_latmFaceName to 0 for generic font families, but 
    // this case is now handled during ComputeFormats.
    //
    if (pcf->_latmFaceName == 0)
        _lf.lfOutPrecision |= OUT_TT_ONLY_PRECIS;
    
    // Only use CLIP_EMBEDDED when necessary, or Win95 will make you pay.
    if (pcf->_fDownloadedFont)
    {
        _lf.lfClipPrecision |= CLIP_EMBEDDED;
    }

    fRes = GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

    if (!_tcsiequal(pszNewFaceName, _lf.lfFaceName))
    {
        BOOL fCorrectFont = FALSE;

        if (_bCharSet == SYMBOL_CHARSET)
        {
            // #1. if the face changed, and the specified charset was SYMBOL,
            //     but the face name exists and suports ANSI, we give preference
            //     to the face name

            _lf.lfCharSet = ANSI_CHARSET;
            fTweakedCharSet = TRUE;

            hfontOriginalCharset = _hfont;
            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
                // that's right, ANSI is the asnwer
                fCorrectFont = TRUE;
            else
                // no, fall back by default
                // the charset we got was right
                _lf.lfCharSet = pcf->_bCharSet;
        }
        else if (_lf.lfCharSet == DEFAULT_CHARSET &&
                 _bCharSet == DEFAULT_CHARSET)
        {
            // #2. If we got the "default" font back, we don't know what it
            // means (could be anything) so we verify that this guy's not SYMBOL
            // (symbol is never default, but the OS could be lying to us!!!)
            // we would like to verify more like whether it actually gave us
            // Japanese instead of ANSI and labeled it "default"...
            // but SYMBOL is the least we can do

            _lf.lfCharSet = SYMBOL_CHARSET;
            SetLFFaceName(pszNewFaceName);
            fTweakedCharSet = TRUE;

            hfontOriginalCharset = _hfont;
            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
                // that's right, it IS symbol!
                // 'correct' the font to the 'true' one,
                //  and we'll get fMappedToSymbol
                fCorrectFont = TRUE;

            // always restore the charset name, we didn't want to
            // question he original choice of charset here
            _lf.lfCharSet = pcf->_bCharSet;

        }
#ifndef NO_MULTILANG
        else if ( _bConvertMode != CM_SYMBOL &&
                  IsFECharset(_lf.lfCharSet) &&
                  (!g_fFarEastWinNT || !g_fFarEastWin9X))
        {
            // NOTE (cthrash) _lf.lfCharSet is what we asked for, _bCharset is what we got.

            if (_bCharSet != _lf.lfCharSet &&
                (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID))
            {
                SCRIPT_ID sid;
                LONG latmFontFace;

                // on Win95, when rendering to PS driver,
                // it will give us something other than what we asked.
                // We have to try some known font we got from GDI
                switch (_lf.lfCharSet)
                {
                    case CHINESEBIG5_CHARSET:
                        sid = sidBopomofo;
                        break;

                    case SHIFTJIS_CHARSET:
                        sid = sidKana;
                        break;

                    case HANGEUL_CHARSET:
                        sid = sidHangul;
                        break;

                    case GB2312_CHARSET:
                        sid = sidHan;
                        break;

                    default:
                        sid = sidDefault;
                        break;
                }

                ScriptAppropriateFaceNameAtom(sid, pdci->_pDoc, FALSE, pcf, pdci->_pMarkup, &latmFontFace);
                SetLFFaceNameAtm(latmFontFace);
            }
            else if (   _lf.lfCharSet == GB2312_CHARSET
                     && _lf.lfPitchAndFamily | FIXED_PITCH)
            {
                // HACK (cthrash) On vanilla PRC systems, you will not be able to ask
                // for a fixed-pitch font which covers the non-GB2312 GBK codepoints.
                // We come here if we asked for a fixed-pitch PRC font but failed to 
                // get a facename match.  So we try again, only without FIXED_PITCH
                // set.  The side-effect is that CBaseCcs::Compare needs to compare
                // against the original _bPitchAndFamily else it will fail every time.
                
                _lf.lfPitchAndFamily = _lf.lfPitchAndFamily ^ FIXED_PITCH;
            }
            else
            {
                // this is a FE Font (from Lang pack) on a nonFEsystem
                SetLFFaceName(pszNewFaceName);
            }

            hfontOriginalCharset = _hfont;

            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);

            if (_tcsiequal(pszNewFaceName, _lf.lfFaceName))
            {
                // that's right, it IS the FE font we want!
                // 'correct' the font to the 'true' one.
                fCorrectFont = TRUE;
            }

            fTweakedCharSet = TRUE;
        }
#endif // !NO_IME

        if (hfontOriginalCharset != HFONT_INVALID)
        {
            // either keep the old font or the new one

            if (fCorrectFont)
            {
                DeleteFontIdx(hfontOriginalCharset);
                hfontOriginalCharset = HFONT_INVALID;
            }
            else
            {
                // fall back to the original font
                DeleteFontIdx(_hfont);

                _hfont = hfontOriginalCharset;
                hfontOriginalCharset = HFONT_INVALID;

                GetTextMetrics( hdc, cpDoc, lcid );
            }
        }
    }

RetryCreateFont:
    if (!pcf->_fDownloadedFont)
    {
        // could be that we just plain symply get mapped to symbol.
        // avoid it
        BOOL fMappedToSymbol =  (_bCharSet == SYMBOL_CHARSET &&
                                 _lf.lfCharSet != SYMBOL_CHARSET);

        BOOL fChangedCharset = (_bCharSet != _lf.lfCharSet &&
                                _lf.lfCharSet != DEFAULT_CHARSET);

        if (fChangedCharset || fMappedToSymbol)
        {
            const TCHAR * pchFallbackFaceName = (pcf->_bPitchAndFamily & FF_ROMAN)
                                                ? TimesNewRoman()
                                                : Arial();
            
            // Here, the system did not preserve the font language or mapped
            // our non-symbol font onto a symbol font,
            // which will look awful when displayed.
            // Giving us a symbol font when we asked for a non-symbol one
            // (default can never be symbol) is very bizzare and means
            // that either the font name is not known or the system
            // has gone complete nuts here.
            // The charset language takes priority over the font name.
            // Hence, I would argue that nothing can be done to save the
            // situation at this point, and we have to
            // delete the font name and retry

            // let's tweak it a bit
            fTweakedCharSet = TRUE;

            if (_tcsiequal(_lf.lfFaceName, pchFallbackFaceName))
            {
                // we've been here already
                // no font with an appropriate charset is on the system
                // try getting the ANSI one for the original font name
                // next time around, we'll null out the name as well!!
                if (_lf.lfCharSet == ANSI_CHARSET)
                {
                    TraceTag((tagWarning, "Asking for ANSI ARIAL and not getting it?!"));

                    // those Win95 guys have definitely outbugged me
                    goto Cleanup;
                }

                SetLFFaceNameAtm(pcf->_latmFaceName);
                _lf.lfCharSet = ANSI_CHARSET;
            }
            else
                SetLFFaceName(pchFallbackFaceName);

            DeleteFontIdx(_hfont);
            _hfont = HFONT_INVALID;

            GetFontWithMetrics(hdc, pszNewFaceName, cpDoc, lcid);
            goto RetryCreateFont;
        }

    }

Cleanup:
    if (fTweakedCharSet || _bConvertMode == CM_SYMBOL)
    {
        // we must preserve the original charset value, since it is used in Compare()
        _lf.lfCharSet = pcf->_bCharSet;
        SetLFFaceNameAtm(pcf->_latmFaceName);
    }

    if (hfontOriginalCharset != HFONT_INVALID)
    {
        DeleteFontIdx(hfontOriginalCharset);
        hfontOriginalCharset = HFONT_INVALID;
    }

    // if we're really really stuck, just get the system font and hope for the best.
    if (_hfont == HFONT_INVALID)
        _hfont = GetSystemFontIdx();

    _fFEFontOnNonFEWin95 = FEFontOnNonFE95( _bCharSet );


    // What font are we *really* using?
    _latmRealFaceName = fc().GetAtomFromFaceName(pszNewFaceName);

    // Make sure we know what have script IDs computed for this font.  Cache this value
    // to avoid a lookup later.
    BOOL fHKSCSHack = pdci->_pDoc->_pOptionSettings->fHKSCSSupport;
    _sids = fc().EnsureScriptIDsForFont(hdc, this, pcf->_fDownloadedFont ? FC_SIDS_DOWNLOADEDFONT : 0, &fHKSCSHack);
    _sids &= GetScriptsFromCharset(_bCharSet);
    if (fHKSCSHack)
        _sids |= ScriptBit(sidLatin);

    Assert(!fForceTTFont || _fTTFont);   // We are forceing to TT font, so we should get one.

    TraceTag((tagCCcsMakeFont,
              "CCcs::MakeFont(facename=%S,charset=%d) returned %S(charset=%d), rendering %S",
             fc().GetFaceNameFromAtom(pcf->_latmFaceName),
             pcf->_bCharSet,
             fc().GetFaceNameFromAtom(_latmLFFaceName),
             _bCharSet,
             fc().GetFaceNameFromAtom(_latmRealFaceName)));

    return (_hfont != HFONT_INVALID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetFontWithMetrics
//
//  Synopsis:   Get metrics used by the measurer and renderer 
//              and the new face name.
//              
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetFontWithMetrics (
    XHDC hdc,                              
    TCHAR* szNewFaceName,
    CODEPAGE cpDoc,
    LCID lcid )
{
    UseScreenDCForMeasuring(&hdc);

    // if required font is too big (more then 30000), Windows (incl W2K and W9x) 
    // computes wrong char widths. We use scale factor and smaller font then to
    // calculate right widths. (dmitryt)
    _fScalingRequired = FALSE;
    LONG lHeight = _lf.lfHeight;
    if(lHeight < 0) lHeight = -lHeight; 
    if(lHeight > MAX_SAFE_FONT_SIZE)
    {
        _lf.lfHeight = (_lf.lfHeight < 0) ? -MAX_SAFE_FONT_SIZE : MAX_SAFE_FONT_SIZE; 
        _fScalingRequired = TRUE; 
        _flScaleFactor = ((float)lHeight) / (float)MAX_SAFE_FONT_SIZE; 
    }

    // IMPORTANT: we want to keep _lf untouched as it is used in Compare().
    LOGFONT lf = _lf;

#ifdef UNIX
    if (( lf.lfCharSet == DEFAULT_CHARSET ) ||
        ( lf.lfCharSet == SYMBOL_CHARSET )) {
        // On Unix we actually do sometimes map to a symbol charset
        // and somewhere in this code we don't handle that case well
        // and end up showing symbols where text should be.  I don't
        // have time to fix that right now so always ask for ansi.
        lf.lfCharSet = ANSI_CHARSET;
    }
#endif

    // Sometimes we want to retry font creation with different paramenter.
    // Of course, we are very careful when we jump back to this label.
Retry:
    _hfont = CreateFontIndirectIdx(&lf);

    if (_hfont != HFONT_INVALID)
    {
        // get text metrics, in logical units, that are constant for this font,
        // regardless of the hdc in use.

        if (GetTextMetrics( hdc, cpDoc, lcid ))
        {
            // Retry if we have asked for a TT font, but got something else
            if (lf.lfOutPrecision == OUT_TT_ONLY_PRECIS && !_fTTFont)
            {
                // remove font name and ask for a nameless font 
                // with same pitch and family
                if (lf.lfFaceName[0])
                {
                    // destroying the font name ensures we wont come here again
                    lf.lfFaceName[0] = 0;
                    
                    if (!lf.lfPitchAndFamily)
                    {
                        // use pitch and family returned by GetTextMetrics (we hope the family is usable)
                        lf.lfPitchAndFamily = _sPitchAndFamily;
                    }

                    // dangerously jump back. 
                    DeleteObject((HGDIOBJ)_hfont);
                    goto Retry;
                }
                else
                {
                    // this may not be the first retry. give up
                }
            }
        }

        {
            FONTIDX hfontOld = PushFont(hdc);
            GetTextFace(hdc, LF_FACESIZE, szNewFaceName);
            PopFont(hdc, hfontOld);
        }
    }

    return (_hfont != HFONT_INVALID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetTextMetrics
//
//  Synopsis:   Get metrics used by the measureer and renderer.
//              These are in logical coordinates which are dependent
//              on the mapping mode and font selected into the hdc.
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetTextMetrics(
    XHDC hdc,
    CODEPAGE cpDoc,
    LCID lcid )
{
    UseScreenDCForMeasuring(&hdc);

    BOOL        fRes = TRUE;
    TEXTMETRIC  tm;

    FONTIDX hfontOld = PushFont(hdc);

    if (!::GetTextMetrics(hdc, &tm))
    {
        WHEN_DBG(GetLastError());
        fRes = FALSE;
        goto Cleanup;
    }

    if(_fScalingRequired)
    {
        tm.tmHeight *= _flScaleFactor;
        tm.tmAscent *= _flScaleFactor;
        tm.tmDescent *= _flScaleFactor;
        tm.tmAveCharWidth *= _flScaleFactor;
        tm.tmMaxCharWidth *= _flScaleFactor;
        tm.tmOverhang *= _flScaleFactor;
        tm.tmInternalLeading *= _flScaleFactor;
        tm.tmExternalLeading *= _flScaleFactor;
    }

    // if we didn't know the true codepage, determine this now.
    if (_lf.lfCharSet == DEFAULT_CHARSET)
    {
        // TODO: investigate (track bug 112167). 
        // Looks like _sCodePage is always defined at this point.
        // (cthrash) Remove this.  The _sCodePage computed by MakeFont should
        // be accurate enough.
        
        _sCodePage = (USHORT)DefaultCodePageFromCharSet( tm.tmCharSet, cpDoc, lcid );
    }

    // the metrics, in logical units, dependent on the map mode and font.
    _yHeight         = tm.tmHeight;
    _yDescent        = tm.tmDescent;
    _xAveCharWidth   = tm.tmAveCharWidth;
    _xMaxCharWidth   = tm.tmMaxCharWidth;
    _xOverhangAdjust = (SHORT) tm.tmOverhang;
    _sPitchAndFamily = (SHORT) tm.tmPitchAndFamily;
    _bCharSet        = tm.tmCharSet;
    _fTTFont         = !!(TMPF_TRUETYPE & tm.tmPitchAndFamily);

    if (   _bCharSet == SHIFTJIS_CHARSET 
        || _bCharSet == CHINESEBIG5_CHARSET 
        || _bCharSet == HANGEUL_CHARSET
        || _bCharSet == GB2312_CHARSET
       )
    {
        if (tm.tmExternalLeading == 0)
        {
            // Increase descent by 1/8 font height for FE fonts
            LONG delta = _yHeight / 8;
            _yDescent += delta;
            _yHeight  += delta;
        }
        else
        {
            //
            // use the external leading
            //

            _yDescent += tm.tmExternalLeading;
            _yHeight += tm.tmExternalLeading;
        }
    }

#ifndef UNIX // We don't support TRUE_TYPE font yet.
    // bug in windows95, synthesized italic?
    if ( _lf.lfItalic && 0 == tm.tmOverhang &&
         !(TMPF_TRUETYPE & tm.tmPitchAndFamily) &&
         !( (TMPF_DEVICE & tm.tmPitchAndFamily) &&
            (TMPF_VECTOR & tm.tmPitchAndFamily ) ) )
    {                                               // This is a *best* guess.
        // When printing to a PCL printer, we prefer zero as our overhang adjust. (41546)
        DWORD   dwDCObjType = GetObjectType(hdc);
        if (!_fPrinting
            || (dwDCObjType != OBJ_ENHMETADC && dwDCObjType != OBJ_METADC))
        {
            _xOverhangAdjust = (SHORT) (tm.tmMaxCharWidth >> 1);
        }
    }
#endif

    _xOverhang = 0;
    _xUnderhang = 0;
    if ( _lf.lfItalic )
    {
        _xOverhang =  SHORT ( (tm.tmAscent + 1) >> 2 );
        _xUnderhang =  SHORT ( (tm.tmDescent + 1) >> 2 );
    }

    // HACK (cthrash) Many Win3.1 vintage fonts (such as MS Sans Serif, Courier)
    // will claim to support all of Latin-1 when in fact it does not.  The hack
    // is to check the last character, and if the font claims that it U+2122
    // TRADEMARK, then we suspect the coverage is busted.

    _fLatin1CoverageSuspicious =    !(_sPitchAndFamily & TMPF_TRUETYPE)
                                 && (PRIMARYLANGID(LANGIDFROMLCID(g_lcidUserDefault)) == LANG_ENGLISH);

    // if fix pitch, the tm bit is clear
    _fFixPitchFont = !(TMPF_FIXED_PITCH & tm.tmPitchAndFamily);
    _xDefDBCWidth = 0;

    if (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        // Hack imported from Word via Riched.  This is how they compute the
        // discrepancy between the return values of GetCharWidthA and
        // GetCharWidthW.   Compute it once per CBaseCcs, so we don't have to
        // recompute on every Include call.

        const TCHAR chX = _T('X');
        SIZE size;
        INT dxX;

        GetTextExtentPoint(hdc, &chX, 1, &size);
        GetCharWidthA(hdc, chX, chX, &dxX);

        _sAdjustFor95Hack = size.cx - dxX;
        _sAdjustFor95Hack = ( !_fScalingRequired ? _sAdjustFor95Hack : (SHORT)(_sAdjustFor95Hack * _flScaleFactor));

        _fLatin1CoverageSuspicious &= (tm.tmLastChar == 0xFF);
    }
    else
    {
        _sAdjustFor95Hack = 0;

        _fLatin1CoverageSuspicious &= (tm.tmLastChar == 0x2122);
    }

    if (_bCharSet == SYMBOL_CHARSET)
    {
        // Must use doc codepage, unless of course we have a Unicode document
        // In this event, we pick cp1252, just to maximize coverage.

        _sCodePage = IsStraightToUnicodeCodePage(cpDoc) ? CP_1252 : cpDoc;

        _bConvertMode = CM_SYMBOL;        
    }
    else if (IsExtTextOutWBuggy( _sCodePage ))
    {
        _bConvertMode = CM_MULTIBYTE;
    }
#if !defined(WINCE)
    else if (_bConvertMode == CM_NONE &&
         VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        // Some fonts have problems under Win95 with the GetCharWidthW call;
        // this is a simple heuristic to determine if this problem exists.

        INT     widthA, widthW;
        BOOL    fResA, fResW;

        // Future(BradO):  We should add the expression
        //  "&& IsFELCID(GetSystemDefaultLCID())" to the 'if' below to use
        //  Unicode GetCharWidth and ExtTextOut for FE fonts on non-FE
        //  systems (see postponed bug #3337).

        // Yet another hack - FE font on Non-FE Win95 cannot use
        // GetCharWidthW and ExtTextOutW
        if (FEFontOnNonFE95(tm.tmCharSet))
        {
            // always use ANSI call for DBC fonts.
            _bConvertMode = CM_FEONNONFE;

            // setup _xDefDBWidth to by-pass some Trad. Chinese character
            // width problem.
            if (CHINESEBIG5_CHARSET == tm.tmCharSet)
            {
                BYTE    ansiChar[2] = {0xD8, 0xB5 };

                fResA = GetCharWidthA( hdc, *((USHORT *) ansiChar),
                                       *((USHORT *) ansiChar), &widthA );
                if (fResA && widthA)
                {
                    _xDefDBCWidth = ( !_fScalingRequired ? widthA : widthA * _flScaleFactor );
                }
            }
        }
        else
        {
            fResA = GetCharWidthA( hdc, ' ', ' ', &widthA );
            fResW = GetCharWidthW( hdc, L' ', L' ', &widthW );
            if ( fResA && fResW && widthA != widthW )
            {
                _bConvertMode = CM_MULTIBYTE;
            }
            else
            {
                fResA = GetCharWidthA( hdc, 'a', 'a', &widthA );
                fResW = GetCharWidthW( hdc, L'a', L'a', &widthW );
                if ( fResA && fResW && widthA != widthW )
                {
                    _bConvertMode = CM_MULTIBYTE;
                }
            }
        }
    }
#endif // !WINCE

    _fHasInterestingData =    _fFixPitchFont
                           || _xOverhang != 0
                           || _xOverhangAdjust != 0
                           || _bConvertMode == CM_SYMBOL
                           || !_fTTFont;

Cleanup:
    PopFont(hdc, hfontOld);

    return fRes;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::NeedConvertNBSPs
//
//  Synopsis:   Determine NBSPs need conversion or not during render
//              Some fonts wont render NBSPs correctly.
//              Flag fonts which have this problem
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::NeedConvertNBSPs(XHDC hdc, CDoc *pDoc)
{
    UseScreenDCForMeasuring(&hdc);
    
    Assert(!_fConvertNBSPsSet);

    FONTIDX hfontOld = PushFont(hdc);

    // NOTE: (cthrash) Once ExtTextOutW is supported in CRenderer, we need
    //                 to set _fConvertNBSPsIfA, so that we can better tune when we need to
    //                 convert NBSPs depending on which ExtTextOut variant we call.

#if !defined(WINCE)
    if (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID)
    {
        extern BOOL IsATMInstalled();

        Assert(pDoc);
        if (   pDoc
            && pDoc->PrimaryMarkup()->IsPrintMedia()
            && IsATMInstalled()
           )
        {
            _fConvertNBSPs = FALSE;
        }
        else
        {
            TCHAR   ch = WCH_NBSP;
            char    b;
            BOOL    fUsedDefChar;

            WideCharToMultiByte(_sCodePage, 0, &ch, 1, &b, 1, NULL, &fUsedDefChar);

            if (fUsedDefChar)
            {
                _fConvertNBSPs = TRUE;
            }
            else
            {
                // Some fonts (like Wide Latin) claim the width of spaces and
                // NBSP chars are the same, but when you actually call ExtTextOut,
                // you'll get fatter spaces;

                ABC abcSpace, abcNbsp;

                _fConvertNBSPs = !GetCharABCWidthsA( hdc, ' ', ' ', &abcSpace ) ||
                                 !GetCharABCWidthsA( hdc, b, b, &abcNbsp ) ||
                                 abcSpace.abcA != abcNbsp.abcA ||
                                 abcSpace.abcB != abcNbsp.abcB ||
                                 abcSpace.abcC != abcNbsp.abcC;
            }
        }
    }
    else
    {
#ifndef UNIX // UNIX doesn't have true-type fonts
        ABC abcSpace, abcNbsp;

        _fConvertNBSPs = !GetCharABCWidthsW( hdc, L' ', L' ', &abcSpace ) ||
                         !GetCharABCWidthsW( hdc, WCH_NBSP, WCH_NBSP, &abcNbsp ) ||
                         abcSpace.abcA != abcNbsp.abcA ||
                         abcSpace.abcB != abcNbsp.abcB ||
                         abcSpace.abcC != abcNbsp.abcC;
#else // UNIX
        int lSpace, lNbsp;

        _fConvertNBSPs = !GetCharWidthW( hdc, L' ', L' ', &lSpace ) ||
                         !GetCharWidthW( hdc, WCH_NBSP, WCH_NBSP, &lNbsp ) ||
                         lSpace != lNbsp;
#endif
    }
#endif // !WINCE

    PopFont(hdc, hfontOld);

    _fConvertNBSPsSet = TRUE;
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::DestroyFont
//
//  Synopsis:   Destroy font handle for this CBaseCcs.
//
//-----------------------------------------------------------------------------

void
CBaseCcs::DestroyFont()
{
    // clear out any old font
    if (_hfont != HFONT_INVALID)
    {
        DeleteFontIdx(_hfont);
        _hfont = HFONT_INVALID;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::Compare
//
//  Synopsis:   Compares this font cache with the font properties of a
//              given CHARFORMAT.
//
//  Returns:    FALSE if did not match exactly
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::Compare( CompareArgs * pCompareArgs )
{
    VerifyLFAtom();
    // NB: We no longer create our logical font with an underline and strike through.
    // We draw strike through & underline separately.

    // If are mode is CM_MULTIBYTE, we need the sid to match exactly, otherwise we
    // will not render correctly.  For example, <FONT FACE=Arial>A&#936; will have two
    // text runs, first sidAsciiLatin, second sidCyrillic.  If are conversion mode is
    // multibyte, we need to make two fonts, one with ANSI_CHARSET, the other with
    // RUSSIAN_CHARSET.
    const CCharFormat * pcf = pCompareArgs->pcf;

    BOOL fMatched =    (_yCfHeight == pcf->_yHeight) // because different mapping modes
                    && (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL)))
                    && (_latmLFFaceName == pcf->_latmFaceName)
                    && (_lf.lfItalic == pcf->_fItalic)
                    && (_lf.lfHeight == pCompareArgs->lfHeight)  // have diff logical coords
                    && (   pcf->_bCharSet == DEFAULT_CHARSET
                        || _bCharSet == DEFAULT_CHARSET
                        || pcf->_bCharSet == _bCharSet)
                    && (_bPitchAndFamily == pcf->_bPitchAndFamily)
                    && (!pCompareArgs->fTTFont || _fTTFont);

    WHEN_DBG( if (!fMatched) )
    {
        TraceTag((tagCCcsCompare,
                  "%s%s%s%s%s%s%s",
                  (_yCfHeight == pcf->_yHeight) ? "" : "height ",
                  (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL))) ? "" : "weight ",
                  (_latmLFFaceName == pcf->_latmFaceName) ? "" : "facename ",
                  (_lf.lfItalic == pcf->_fItalic) ? "" : "italicness ",
                  (_lf.lfHeight == pCompareArgs->lfHeight) ? "" : "logical-height ",
                  (   pcf->_bCharSet == DEFAULT_CHARSET
                   || _bCharSet == DEFAULT_CHARSET
                   || pcf->_bCharSet == _bCharSet) ? "" : "charset ",
                  (_lf.lfPitchAndFamily == pcf->_bPitchAndFamily) ? "" : "pitch&family" ));
    }

    return fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::CompareForFontLink
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::CompareForFontLink( CompareArgs * pCompareArgs )
{
    // The difference between CBaseCcs::Compare and CBaseCcs::CompareForFontLink is in it's
    // treatment of adjusted/pre-adjusted heights.  If we ask to fontlink with MS Mincho
    // in the middle of 10px Arial text, we may choose to instantiate an 11px MS Mincho to
    // compenstate for the ascent/descent discrepancies.  10px is the _yOriginalHeight, and
    // 11px is the _lf.lfHeight in this scenario.  If we again ask for 10px MS Mincho while
    // fontlinking Arial, we want to match based on the original height, not the adjust height.
    // CBaseCcs::Compare, on the other hand, is only concerned with the adjusted height.

    VerifyLFAtom();
    // NB: We no longer create our logical font with an underline and strike through.
    // We draw strike through & underline separately.

    // If are mode is CM_MULTIBYTE, we need the sid to match exactly, otherwise we
    // will not render correctly.  For example, <FONT FACE=Arial>A&#936; will have two
    // text runs, first sidAsciiLatin, second sidCyrillic.  If are conversion mode is
    // multibyte, we need to make two fonts, one with ANSI_CHARSET, the other with
    // RUSSIAN_CHARSET.
    const CCharFormat * pcf = pCompareArgs->pcf;

    BOOL fMatched =    (_yCfHeight == pcf->_yHeight) // because different mapping modes
                    && (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL)))
                    && (_latmLFFaceName == pcf->_latmFaceName)
                    && (_latmBaseFaceName == pCompareArgs->latmBaseFaceName)
                    && (_lf.lfItalic == pcf->_fItalic)
                    && (_yOriginalHeight == pCompareArgs->lfHeight)  // have diff logical coords
                    && (   pcf->_bCharSet == DEFAULT_CHARSET
                        || _bCharSet == DEFAULT_CHARSET
                        || pcf->_bCharSet == _bCharSet)
                    && (_bPitchAndFamily == pcf->_bPitchAndFamily)
                    && (!pCompareArgs->fTTFont || _fTTFont);

    WHEN_DBG( if (!fMatched) )
    {
        TraceTag((tagCCcsCompare,
                  "%s%s%s%s%s%s%s",
                  (_yCfHeight == pcf->_yHeight) ? "" : "height ",
                  (_lf.lfWeight == ((pcf->_wWeight != 0) ? pcf->_wWeight : (pcf->_fBold ? FW_BOLD : FW_NORMAL))) ? "" : "weight ",
                  (_latmLFFaceName == pcf->_latmFaceName) ? "" : "facename ",
                  (_lf.lfItalic == pcf->_fItalic) ? "" : "italicness ",
                  (_yOriginalHeight == pCompareArgs->lfHeight) ? "" : "logical-height ",
                  (   pcf->_bCharSet == DEFAULT_CHARSET
                   || _bCharSet == DEFAULT_CHARSET
                   || pcf->_bCharSet == _bCharSet) ? "" : "charset ",
                  (_lf.lfPitchAndFamily == pcf->_bPitchAndFamily) ? "" : "pitch&family" ));
    }

    return fMatched;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::SetLFFaceNameAtm
//
//-----------------------------------------------------------------------------

void 
CBaseCcs::SetLFFaceNameAtm(LONG latmFaceName)
{
    VerifyLFAtom();
    Assert(latmFaceName >= 0);
    _latmLFFaceName = latmFaceName;
    // Sets the string inside _lf to what _latmLFFaceName represents.
    _tcsncpy(_lf.lfFaceName, fc().GetFaceNameFromAtom(_latmLFFaceName), LF_FACESIZE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::SetLFFaceName
//
//-----------------------------------------------------------------------------

void 
CBaseCcs::SetLFFaceName(const TCHAR * szFaceName)
{
    VerifyLFAtom();
    LONG latmLFFaceName = fc().GetAtomFromFaceName(szFaceName);
    Assert(latmLFFaceName >= 0);
    _latmLFFaceName = latmLFFaceName;
    _tcsncpy(_lf.lfFaceName, szFaceName, LF_FACESIZE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetConvertMode
//
//-----------------------------------------------------------------------------

CONVERTMODE
CBaseCcs::GetConvertMode(
    BOOL fEnhancedMetafile,
    BOOL fMetafile ) const
{
#if DBG==1
    if (IsTagEnabled(tagTextOutA))
    {
        if (IsTagEnabled(tagTextOutFE))
        {
            TraceTag((tagTextOutFE,
                      "tagTextOutFE is being ignored "
                      "(tagTextOutA is set.)"));
        }

        return CM_MULTIBYTE;
    }
    else if (IsTagEnabled(tagTextOutFE))
    {
        return CM_FEONNONFE;
    }
#endif

    CONVERTMODE cm = (CONVERTMODE)_bConvertMode;

    // For hack around ExtTextOutW Win95 FE problems.
    // NB (cthrash) The following is an enumeration of conditions under which
    // ExtTextOutW is broken.  This code is originally from RichEdit.

    if (cm == CM_MULTIBYTE)
    {
        // If we want CM_MULTIBYTE, that's what we get.
    }
    else if (g_fFarEastWin9X || _fFEFontOnNonFEWin95)
    {
        // Ultimately call ReExtTextOutW, unless symbol.
        // If symbol, call ExtTextOutA.

        if (cm != CM_SYMBOL)
        {
            if (   IsExtTextOutWBuggy( _sCodePage )
                && IsFECharset( _lf.lfCharSet ) )
            {
                // CHT ExtTextOutW does not work on Win95 Golden on
                // many characters (cthrash).

                cm = CM_MULTIBYTE;
            }
            else
            {
                cm = CM_FEONNONFE;
            }
        }
    }
    else
    {
        if (CM_SYMBOL != cm)
        {
#if NOTYET
            if (fEnhancedMetafile &&
                ((VER_PLATFORM_WIN32_WINDOWS   == g_dwPlatformID) ||
                 (VER_PLATFORM_WIN32_MACINTOSH == g_dwPlatformID)))
#else
                if (fEnhancedMetafile &&
                    (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID))
#endif
                {
                    cm = CM_MULTIBYTE;
                }
                else if (fMetafile && g_fFarEastWinNT)
                {
                    // FE NT metafile ExtTextOutW hack.
                    cm = CM_MULTIBYTE;
                }
        }
        if ((VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID) &&
            fMetafile && !fEnhancedMetafile )
        {
            //Win95 can't handle TextOutW to regular metafiles
            cm = CM_MULTIBYTE;
        }
    }

    return cm;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::FillWidths
//
//  Synopsis:   Fill in this CBaseCcs with metrics info for given device.
//
//  Returns:    TRUE if OK, FALSE if failed
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::FillWidths(
    XHDC hdc,
    TCHAR ch,                       // the TCHAR character we need a width for.
    LONG &rlWidth)                  // the width of the character
{
    UseScreenDCForMeasuring(&hdc);
    
    BOOL  fRes = FALSE;

    FONTIDX hfontOld = PushFont(hdc);

    // fill up the width info.
    fRes = _widths.FillWidth( hdc, this, ch, rlWidth );

    PopFont(hdc, hfontOld);

    return fRes;
}

#if DBG==1
//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PopFont
//
//  Synopsis:   Selects the instance var _hfont so we can measure, 
//              but remembers the old font so we don't actually change anything 
//              when we're done measuring.
//              Returns the previously selected font.
//              
//-----------------------------------------------------------------------------

FONTIDX
CBaseCcs::PushFont(XHDC hdc)
{
    AssertSz(_hfont != HFONT_INVALID, "CBaseCcs has no font");

    FONTIDX hfontOld = GetCurrentFontIdx(hdc);

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(this );

        WHEN_DBG( FONTIDX hfontReturn = )
        PushFontIdx(hdc, _hfont);
        AssertSz(hfontReturn == hfontOld, "GDI failure changing fonts");
    }

    return hfontOld;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::PopFont
//
//  Synopsis:   Restores the selected font from before PushFont.
//              This is really just a lot like SelectFont, but is optimized, and
//              will only work if PushFont was called before it.
//              
//-----------------------------------------------------------------------------

void
CBaseCcs::PopFont(XHDC hdc, FONTIDX hfontOld)
{
    // This assert will fail if Pushfont was not called before popfont,
    // Or if somebody else changes fonts in between.  (They shouldn't.)
    AssertSz(_hfont == GetCurrentFontIdx(hdc), "PushFont has not been called");

    if (hfontOld != _hfont)
    {
        hdc.SetBaseCcsPtr(NULL);

        WHEN_DBG( FONTIDX hfontReturn = )
        PopFontIdx(hdc, hfontOld);
        AssertSz(hfontReturn == _hfont, "GDI failure changing fonts");
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetHFont
//              
//-----------------------------------------------------------------------------

HFONT
CBaseCcs::GetHFont() const
{
    return GetFontFromIdx(_hfont);
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::FixupForFontLink
//
//  Synopsis:   Optionally scale a font height when fontlinking.
//
//              This code was borrowed from UniScribe (usp10\str_ana.cxx)
//
//              Let's say you're base font is a 10pt Tahoma, and you need
//              to substitute a Chinese font (e.g. MingLiU) for some ideo-
//              graphic characters.  When you simply ask for a 10pt MingLiU,
//              you'll get a visibly smaller font, due to the difference in
//              in distrubution of the ascenders/descenders.  The purpose of
//              this function is to examine the discrepancy and pick a
//              slightly larger or smaller font for improved legibility. We
//              may also adjust the baseline by 1 pixel.
//              
//-----------------------------------------------------------------------------

void
CBaseCcs::FixupForFontLink(
    XHDC hdc,
    const CBaseCcs * const pBaseBaseCcs,
    BOOL fFEFont )
{
    LONG lOriginalDescender = pBaseBaseCcs->_yDescent;
    LONG lFallbackDescender = _yDescent;
    LONG lOriginalAscender  = pBaseBaseCcs->_yHeight - lOriginalDescender;
    LONG lFallbackAscender  = _yHeight - lFallbackDescender;

    if (   lFallbackAscender  > 0
        && lFallbackDescender > 0)
    {
        LONG lAscenderRatio  = 1024 * lOriginalAscender  / lFallbackAscender;
        LONG lDescenderRatio = 1024 * lOriginalDescender / lFallbackDescender;

        if (lAscenderRatio != lDescenderRatio)
        {
            // We'll allow moving the baseline by one pixel to reduce the amount of
            // scaling required.

            if (lAscenderRatio < lDescenderRatio)
            {
                // Clipping, if any, would happen in the ascender.
                ++lOriginalAscender;    // Move the baseline down one pixel.
                --lOriginalDescender;
                TraceTag((tagMetrics, "Moving baseline down one pixel to leave more room for ascender"));
            }
            else
            {
                // Clipping, if any, would happen in the descender.
                --lOriginalAscender;    // Move the baseline up one pixel.
                ++lOriginalDescender;
                TraceTag((tagMetrics, "Moving baseline up one pixel to leave more room for descender"));
            }

            // Recalculate ascender ratio based on shifted baseline
            lAscenderRatio  = 1024 * lOriginalAscender  / lFallbackAscender;
        }

        // Establish extent of worst mismatch, either too big or too small
        LONG lNewRatio = max(lAscenderRatio, 768L); // Never reduce size by over 25%
        if (fFEFont && lNewRatio < 1024)
        {
            // Never reduce size of FE font. We expect only to increase the size.
            lNewRatio = 1024;
        }

        if (lNewRatio < 1000 || lNewRatio > 1048)
        {
            LONG  lfHeightCurrent = _lf.lfHeight;
            LONG  lAdjust = (lNewRatio < 1024) ? 1023 : 0; // round towards 100% (1024)
            LONG  lfHeightNew = (lfHeightCurrent * lNewRatio - lAdjust) / 1024;

            Assert(lfHeightCurrent < 0);  // lfHeight should be negative; otherwise rounding will be incorrect

            if (lfHeightNew != lfHeightCurrent)
            {
                FONTIDX hfontCurrent   = _hfont;
                LONG  yHeightCurrent   = _yHeight;
                SHORT sCodePageCurrent = _sCodePage;
                TCHAR achNewFaceName[LF_FACESIZE];

                // Reselect with new ratio

                TraceTag((tagMetrics, "Reselecting fallback font to improve legibility"));
                TraceTag((tagMetrics, " Original font ascender %4d, descender %4d, lfHeight %4d, \'%S\'",
                          lOriginalAscender, lOriginalDescender, pBaseBaseCcs->_yHeight, fc().GetFaceNameFromAtom(pBaseBaseCcs->_latmLFFaceName)));
                TraceTag((tagMetrics, " Fallback font ascender %4d, descender %4d, -> lfHeight %4d, \'%s\'",
                          lFallbackAscender, lFallbackDescender, _yHeight * lNewRatio / 1024, fc().GetFaceNameFromAtom(_latmLFFaceName)));

                _lf.lfHeight = lfHeightNew;

                if (GetFontWithMetrics(hdc, achNewFaceName, CP_UCS_2, 0))
                {
                    _latmRealFaceName = fc().GetAtomFromFaceName(achNewFaceName);
                    DeleteFontIdx(hfontCurrent);
                }
                else
                {
                    Assert(_hfont == HFONT_INVALID);

                    _lf.lfHeight = lfHeightCurrent;
                    _yHeight = yHeightCurrent;
                    _hfont = hfontCurrent;
                }

                _sCodePage = sCodePageCurrent;
            }
        }
    }

    _fHeightAdjustedForFontlinking = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::EnsureLangBits
//
//-----------------------------------------------------------------------------

// TODO: (cthrash, track bug 112152) This needs to be removed as soon as the FontLinkTextOut
// is cleaned up for complex scripts.

void
CBaseCcs::EnsureLangBits(XHDC hdc)
{
    if (!_dwLangBits)
    {
        // Get the charsets supported by this font.
        if (_bCharSet != SYMBOL_CHARSET)
        {
            _dwLangBits = GetFontScriptBits( hdc,
                                             fc().GetFaceNameFromAtom( _latmLFFaceName ),
                                             &_lf );
        }
        else
        {
            // See comment in GetFontScriptBits.
            // SBITS_ALLLANGS means _never_ fontlink.

            _dwLangBits = SBITS_ALLLANGS;
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CBaseCcs::GetLogFont
//
//-----------------------------------------------------------------------------

BOOL
CBaseCcs::GetLogFont(LOGFONT * plf) const
{
    BOOL fSuccess = GetObject(GetHFont(), sizeof(LOGFONT), (LPVOID)plf);
    if (fSuccess && _fScalingRequired)
    {
        plf->lfHeight *= _flScaleFactor;
        plf->lfWidth  *= _flScaleFactor;
    }
    return fSuccess;
}

// =========================  WidthCache by jonmat  ===========================

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::FillWidth
//
//  Synopsis:   Call GetCharWidth() to obtain the width of the given char.
//
//              The HDC must be setup with the mapping mode and proper font
//              selected *before* calling this routine.
//              
//  Returns:    TRUE if we were able to obtain the widths
//
//-----------------------------------------------------------------------------

BOOL
CWidthCache::FillWidth (
    XHDC hdc,
    CBaseCcs * pBaseCcs,
    const TCHAR ch,                 // Char to obtain width for
    LONG &rlWidth )                 // Width of character
{
    BOOL    fRes;
    INT     numOfDBCS = 0;
    CacheEntry  widthData;
    
    // NOTE: GetCharWidthW is really broken for bullet on Win95J. Sometimes it will return
    // a width or 0 or 1198 or ...So, hack around it. Yuk!
    // Also, WideCharToMultiByte() on Win95J will NOT convert bullet either.

    Assert( !IsCharFast(ch) );  // This code shouldn't be called for that.

    if ( ch == WCH_NBSP )
    {
        // Use the width of a space for an NBSP
        fRes = pBaseCcs->Include(hdc, L' ', rlWidth);

        if( !fRes )
        {
            // Error condition, just use the default width.
            rlWidth = pBaseCcs->_xAveCharWidth;
        }

        widthData.ch = ch;
        widthData.width = rlWidth;
        *GetEntry(ch) = widthData;
    }
    else
    {
        INT xWidth = 0;

        // Diacritics, tone marks, and the like have 0 width so return 0 if
        // GetCharWidthW() succeeds.
        BOOL fZeroWidth = IsZeroWidth(ch);
        BOOL fEUDCFixup = g_dwPlatformVersion < 0x40000 && IsEUDCChar(ch);

        if ( pBaseCcs->_bConvertMode == CM_SYMBOL )
        {
            if ( ch > 255 )
            {
#ifndef UNIX
                const unsigned char chSB = InWindows1252ButNotInLatin1(ch);
            
                if (chSB)
                {
                    fRes = GetCharWidthA( hdc, chSB, chSB, &xWidth );
                    if(pBaseCcs->_fScalingRequired) 
                        xWidth *= pBaseCcs->_flScaleFactor;
                }
                else
#endif
                {
                    char achSB[3];
                    INT xWidthSBC;

                    int cb = WideCharToMultiByte( pBaseCcs->_sCodePage, 0, &ch, 1, achSB, 3, NULL, NULL );

                    while (cb)
                    {
                        unsigned char uch = achSB[cb-1];
                        if (GetCharWidthA( hdc, uch, uch, &xWidthSBC ))
                            xWidth += ( !pBaseCcs->_fScalingRequired ? 
                                            xWidthSBC : xWidthSBC * pBaseCcs->_flScaleFactor );
                        else
                            xWidth += pBaseCcs->_xAveCharWidth;
                        --cb;
                    }
                    fRes = TRUE;
                }

            }
            else
            {
                fRes = GetCharWidthA( hdc, ch, ch, &xWidth );
                if(pBaseCcs->_fScalingRequired) 
                    xWidth *= pBaseCcs->_flScaleFactor;
            }
        }
        else if ( !fEUDCFixup && pBaseCcs->_bConvertMode != CM_MULTIBYTE )
        {
            // GetCharWidthW will crash on a 0xffff.
            Assert(ch != 0xffff);
            fRes = GetCharWidthW( hdc, ch, ch, &xWidth );
            if(pBaseCcs->_fScalingRequired) 
                xWidth *= pBaseCcs->_flScaleFactor;

            // See comment in CBaseCcs::GetTextMetrics

            xWidth += pBaseCcs->_sAdjustFor95Hack;
        }
        else
        {
            fRes = FALSE;
        }

        // either fAnsi case or GetCharWidthW fail, let's try GetCharWidthA
#ifndef UNIX
        if (!fRes || (0 == xWidth && !fZeroWidth))
#else // It's possible on UNIX with charWidth=0.
        if (!fRes)
#endif
        {
            WORD wDBCS;
            char ansiChar[2] = {0};
            UINT uCP = fEUDCFixup ? CP_ACP : pBaseCcs->_sCodePage;

            // Convert string
            numOfDBCS = WideCharToMultiByte( uCP, 0, &ch, 1,
                                             ansiChar, 2, NULL, NULL);

            if (2 == numOfDBCS)
                wDBCS = (BYTE)ansiChar[0] << 8 | (BYTE)ansiChar[1];
            else
                wDBCS = (BYTE)ansiChar[0];

            fRes = GetCharWidthA( hdc, wDBCS, wDBCS, &xWidth );
            if(pBaseCcs->_fScalingRequired) 
                xWidth *= pBaseCcs->_flScaleFactor;
        }

        widthData.width = xWidth;

        if ( fRes )
        {
#ifndef UNIX // On Unix , charWidth == 0 is not a bug.
            if (0 == widthData.width && !fZeroWidth)
            {
                // Sometimes GetCharWidth will return a zero length for small
                // characters. When this happens we will use the default width
                // for the font if that is non-zero otherwise we just us 1
                // because this is the smallest valid value.

                // NOTE: - under Win95 Trad. Chinese, there is a bug in the
                // font. It is returning a width of 0 for a few characters
                // (Eg 0x09F8D, 0x81E8) In such case, we need to use 2 *
                // pBaseCcs->_xAveCharWidth since these are DBCS

                if (0 == pBaseCcs->_xAveCharWidth)
                {
                    widthData.width = 1;
                }
                else
                {
                    widthData.width = (numOfDBCS == 2)
                                      ? (pBaseCcs->_xDefDBCWidth
                                         ? pBaseCcs->_xDefDBCWidth
                                         : 2 * pBaseCcs->_xAveCharWidth)
                                      : pBaseCcs->_xAveCharWidth;
                }
            }
#endif
            widthData.ch      = ch;
            if (widthData.ch <= pBaseCcs->_xOverhangAdjust)
                widthData.width = 1;
            else
                widthData.width   -= pBaseCcs->_xOverhangAdjust;
            rlWidth = widthData.width;
            *GetEntry(ch) = widthData;
        }
    }

#if DBG==1
    if (!fRes) 
         TraceTag((tagFontNoWidth, "no width?"));
#endif // DBG==1

    Assert( widthData.width == rlWidth );  // Did we forget to set it?

    return fRes;
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::~CWidthCache
//
//  Synopsis:   Free any allocated caches
//
//-----------------------------------------------------------------------------

CWidthCache::~CWidthCache()
{
    INT i;

    for (i = 0; i < TOTALCACHES; i++ )
    {
        if (_pWidthCache[i])
            MemFree(_pWidthCache[i]);
    }
    MemFree(_pFastWidthCache);
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::~CWidthCache
//
//  Synopsis:   Goes into a critical section, and allocates memory for 
//              a width cache.
//
//-----------------------------------------------------------------------------

void
CWidthCache::ThreadSafeCacheAlloc(void** ppCache, size_t iSize)
{
    EnterCriticalSection(&(fc()._csOther));

    if (!*ppCache)
    {
        *ppCache = MemAllocClear( Mt(CWidthCacheEntry), iSize );
    }

    LeaveCriticalSection(&(fc()._csOther));
}

//+----------------------------------------------------------------------------
//
//  Function:   CWidthCache::PopulateFastWidthCache
//
//  Synopsis:   Fills in the widths of the low 128 characters.
//              Allocates memory for the block if needed
//
//-----------------------------------------------------------------------------

#if !defined(WINCE)
// This function uses GetCharacterPlacement to get character widths. This
// This works better than GetCharWidths() under Win95.
static BOOL
GetWin95CharWidth(
    XHDC hdc,
    UINT iFirstChar,
    UINT iLastChar,
    int *pWidths)
{
    UINT i, start;
    TCHAR chars[257];
    GCP_RESULTS gcp={sizeof(GCP_RESULTS), NULL, NULL, pWidths,
    NULL, NULL, NULL, 128, 0};

    // Avoid overflows.
    Assert (iLastChar - iFirstChar < 128);

    // We want to get all the widths from 0 to 255 to stay in sync with our
    // width cache. Unfortunately, the zeroeth character is a zero, which
    // is the string terminator, which prevents any of the other characters
    // from getting the correct with. Since we can't use it anyway, we get the
    // width of a space character for zero.
    start=iFirstChar;
    if (iFirstChar == 0)
    {
        chars[0] = (TCHAR)' ';
        start++;
    }

    // Fill up our "string" with
    for (i=start; i<=iLastChar; i++)
    {
        chars[i-iFirstChar] = (TCHAR)i;
    }
    // Null terminate because I'm suspicious of GetCharacterPlacement's handling
    // of NULL characters.
    // chars[i-iFirstChar] = 0;

    gcp.nGlyphs = iLastChar - iFirstChar + 1;

    return !!GetCharacterPlacement(hdc, chars, iLastChar-iFirstChar + 1, 0, &gcp, 0);
}
#endif // !WINCE

extern BOOL g_fPrintToGenericTextOnly;

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used
#endif

BOOL
CWidthCache::PopulateFastWidthCache(XHDC hdc, CBaseCcs* pBaseCcs, CDocInfo * pdci)
{    
    UseScreenDCForMeasuring(&hdc);

    BOOL fRes;
    FONTIDX hfontOld;
    // First switch to the appropriate font.
    hfontOld = pBaseCcs->PushFont(hdc);

    // characters in 0 - 127 range (cache 0), so initialize the character widths for
    // for all of them.
    int widths[ FAST_WIDTH_CACHE_SIZE ];
    int i;

    // TODO: (track bug 112157) remove this HACKHACK..
    // HACKHACK (greglett)
    // Remove this for v4!
    // Hack to support Generic/Text Only printer - it always returns non TrueType, monospace 60px/12px (NT/9x) characters.
    // Since we instantiate fonts on the screen DC, we get completely wrong answers.  So, our hack is just to assume
    // we know what the character widths should be.
    // This should be removed in v4, when we have time to do a correct fix!  It's related to (and should be fixed at the same
    // time as) the UseScreenDCForMeasuring hack.
    if (    g_fPrintToGenericTextOnly
        &&  pdci->GetResolution().cx > 400 )    // HACK!  (on top of hack!) to check print media for Generic/TextOnly printer.
    {
        int nTargetWidth = g_fUnicodePlatform ? 60 : 12;                // Known character width on printer.
        double nScale    = pdci->GetResolution().cx / (nTargetWidth * 10);    // Known resolution of printer.
        nTargetWidth = (nTargetWidth * nScale) + (nTargetWidth - 1);

        for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
            widths[i] = nTargetWidth;

        fRes = TRUE;
    }
    else
    {

#if !defined(WINCE) && !defined(UNIX)
    // If this is Win95 and this is not a true type font
    // GetCharWidth*() returns unreliable results, so we do something
    // slow, painful, but accurate.
#if defined(_MAC)
    fRes = GetCharWidth(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
    if(pBaseCcs->_fScalingRequired)
    {
        for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
            widths[i] *= pBaseCcs->_flScaleFactor; 
    }
    
    // ## v-gsrir
    // Overhang adjustments for non-truetype fonts in Win16
    if (   pBaseCcs->_xOverhangAdjust 
        && fRes)
    {
        for (i=0; i< FAST_WIDTH_CACHE_SIZE; i++)
            widths[i] -= pBaseCcs->_xOverhangAdjust;
    }

#else
    if (!g_fUnicodePlatform)
    {
        LONG lfAbsHeight = abs(pBaseCcs->_lf.lfHeight);

        // COMPLEXSCRIPT - With so many nonsupported charsets, why not avoid using GCP?
        //                 GCP does not work with any of the languages that need it.
        // HACK (cthrash) If the absolute height is too small, the return values
        // from GDI are unreliable.  We might as well use the GetCharWidthA values,
        // which aren't stellar either, but empirically better.
        if (lfAbsHeight > 3 &&
            !(pBaseCcs->_sPitchAndFamily & TMPF_VECTOR) &&
            pBaseCcs->_bCharSet != SYMBOL_CHARSET &&
            pBaseCcs->_bCharSet != ARABIC_CHARSET &&
            pBaseCcs->_bCharSet != HEBREW_CHARSET &&
            pBaseCcs->_bCharSet != VIETNAMESE_CHARSET &&
            pBaseCcs->_bCharSet != THAI_CHARSET)
        {
            fRes = GetWin95CharWidth(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
            if(pBaseCcs->_fScalingRequired)
            {
                for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                    widths[i] *= pBaseCcs->_flScaleFactor; 
            }
        }
        else
        {
            fRes = GetCharWidthA(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
            if(pBaseCcs->_fScalingRequired)
            {
                for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                    widths[i] *= pBaseCcs->_flScaleFactor; 
            }

            if (   pBaseCcs->_xOverhangAdjust 
                && fRes)
            {
                for (i=0; i< FAST_WIDTH_CACHE_SIZE; i++)
                    widths[i] -= pBaseCcs->_xOverhangAdjust;
            }
        }
    }
    else
#endif // !_MAC
#endif // !WINCE && !UNIX

    {
        fRes = GetCharWidth32(hdc, 0, FAST_WIDTH_CACHE_SIZE-1, widths);
        if(pBaseCcs->_fScalingRequired)
        {
            for(int i=0; i < FAST_WIDTH_CACHE_SIZE; i++) 
                widths[i] *= pBaseCcs->_flScaleFactor; 
        }
#if DBG==1
        if (!fRes)
        {
            AssertSz(0, "GetCharWidth32 failed");
            INT errorVal = GetLastError();
            HFONT hf = (HFONT)GetCurrentObject(hdc, OBJ_FONT);
#ifdef NEVER
            FONTIDX fidx = GetCurrentFontIdx(hdc);
            Assert(fidx == pBaseCcs->_hfont);
#endif // NEVER
        }
#endif // DBG==1
    }
    }

    // Copy the results back into the real cache, if it worked.
    if (fRes)
    {
        Assert( !_pFastWidthCache );  // Since we should only populate this once.

        ThreadSafeCacheAlloc( (void **)&_pFastWidthCache, sizeof(CharWidth) * FAST_WIDTH_CACHE_SIZE );

        if( !_pFastWidthCache )
        {
            // We're kinda in trouble if we can't get memory for the cache.
            AssertSz(0,"Failed to allocate fast width cache.");
            fRes = FALSE;
            goto Cleanup;
        }

        for(i = 0; i < FAST_WIDTH_CACHE_SIZE; i++)
        {
            _pFastWidthCache[i]= (widths[i]) ? widths[i] : pBaseCcs->_xAveCharWidth;
        }

        // NB (cthrash) Measure NBSPs with space widths.
        SetCacheEntry(WCH_NBSP, _pFastWidthCache[_T(' ')] );
    }

Cleanup:
    pBaseCcs->PopFont(hdc, hfontOld);

    return fRes;
}  // PopulateFastWidthCache

#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//+----------------------------------------------------------------------------
//
//  Function:   InWindows1252ButNotInLatin1Helper
//
//-----------------------------------------------------------------------------
BYTE
InWindows1252ButNotInLatin1Helper(WCHAR ch)
{
    for (int i=32;i--;)
    {
        if (ch == g_achLatin1MappingInUnicodeControlArea[i])
        {
            return 0x80 + i;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\fontlink.cxx ===
#include "headers.hxx"

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#ifndef X_MULTILANG_HXX_
#define X_MULTILANG_HXX_
#include "multilang.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

#ifndef X_WCHDEFS_H___
#define X_WCHDEFS_H___
#include "wchdefs.h"
#endif

extern CUnicodeRanges g_UnicodeRanges;

//+----------------------------------------------------------------------------
//
//  MLang fontlinking deinitialization
//  This function is implemented here because intlcore library doesn't know
//  about THREADSTATE.
//
//-----------------------------------------------------------------------------
void DeinitMLangFontLinking(THREADSTATE * pts)
{
    if (mlang().IsLoaded())
    {
        IMLangFontLink * pMLangFontLink = mlang().GetMLangFontLink();
        if (pMLangFontLink)
            pMLangFontLink->ResetFontMapping();
    }
}

//+----------------------------------------------------------------------------
// Fontlink wrapper object
//-----------------------------------------------------------------------------

CFontLink g_FontLink;

//+----------------------------------------------------------------------------
//
//  Function:   DeinitFontLinking
//
//  Synopsis:   Detach from Fontlink. Called from DllAllThreadsDetach.
//              Globals are locked during the call.
//
//-----------------------------------------------------------------------------
void DeinitFontLinking()
{
    fl().Unload();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::CFontLink
//
//  Synopsis:   Initializes Fontlink wrapper object.
//
//-----------------------------------------------------------------------------

CFontLink::CFontLink()
{
    _pUnicodeScriptMapper = NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::~CFontLink
//
//  Synopsis:   Deinitializes Fontlink wrapper object.
//
//-----------------------------------------------------------------------------

CFontLink::~CFontLink()
{
    Assert(_pUnicodeScriptMapper == NULL);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::CreateObjects
//
//  Synopsis:   Create Fontlink object and QI required interfaces.
//
//-----------------------------------------------------------------------------

void CFontLink::CreateObjects()
{
    g_UnicodeRanges.QueryInterface(IID_IUnicodeScriptMapper, reinterpret_cast<void **>(&_pUnicodeScriptMapper));
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::DestroyObjects
//
//  Synopsis:   Release all Fontlink interfaces
//
//-----------------------------------------------------------------------------

void CFontLink::DestroyObjects()
{
    if (_pUnicodeScriptMapper)
    {
        _pUnicodeScriptMapper->Release();
        _pUnicodeScriptMapper = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::DisambiguateScript
//
//  Synopsis:   Pick up one of valid script ids for a string of ambiguous characters.
//              Will stop analyzing when finds a new script.
//
//  Arguments:  [cpFamily] - family codepage of the document
//              [lcid]     - locale id of the text
//              [sidLast]  - script id of the previous character
//              [pch]      - text buffer to analyze
//              [pcch]     - [in]  size of the text buffer
//                           [out] number of characters analyzed
//
//  Returns:    Script ID.
//
//-----------------------------------------------------------------------------

SCRIPT_ID CFontLink::DisambiguateScript(
    CODEPAGE cpFamily, 
    LCID lcid, 
    SCRIPT_ID sidLast, 
    const TCHAR * pch, 
    long * pcch)
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    //
    // PERF (cthrash) In the following HTML, we will have a sidAmbiguous
    // run with a single space char in in (e.g. amazon.com): <B>&middot;</B> X
    // The middot is sidAmbiguous, the space is sidMerge, and thus they merge.
    // The X of course is sidAsciiLatin.  When called for a single space char,
    // we don't want to bother calling MLANG.  Just give the caller a stock
    // answer so as to avoid the unnecessary busy work.
    //    
    if (*pcch == 1 && *pch == WCH_SPACE)
        return sidAsciiLatin;

    //
    // PERF (grzegorz) When called for single Latin-1, General Punctuation
    // or Letterlike Symbols character on English pages, 
    // we don't want to bother calling MLANG. Just give the caller a stock answer.
    // NOTE: we cannot apply this hack for Unicode pages, because we can have any content there.
    //
    if (   cpFamily == CP_1252
        && (   InRange(*pch, 0x0080, 0x00ff)
            || InRange(*pch, 0x2000, 0x206f) 
            || InRange(*pch, 0x2100, 0x214f)))
    {
        *pcch = 1;
        return sidLatin;
    }

    EnsureObjects();

    if (!_pUnicodeScriptMapper) 
        return sidDefault;

    SCRIPT_ID  sidPrefered;
    SCRIPT_IDS sidsAvailable = ScriptsFromCPBit(mlang().GetInstalledLangPacks());

    if (lcid)
    {
        sidPrefered = ScriptIDFromLangID(LANGIDFROMLCID(lcid));
    }
    else
    {
        sidPrefered = sidLast;
        if (sidPrefered == sidDefault)
        {
            sidPrefered = ScriptIDFromCodePage(cpFamily);
            if (sidPrefered == sidDefault)
            {
                LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
                sidPrefered = ScriptIDFromLangID(lid);
            }
        }
    }

    HRESULT hr;
    SCRIPT_ID sid;
    hr = _pUnicodeScriptMapper->DisambiguateScriptMulti(pch, *pcch, 
        sidPrefered, sidsAvailable, 0, pcch, &sid);
    if (FAILED(hr))
        return sidDefault;

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontLink::UnunifyHanScript
//
//  Synopsis:   Pick up one of the Far East script ids (sidKana, sidHangul, 
//              sidBopomofo, sidHan) for a string of Han characters.
//              Will stop analyzing when finds a new script.
//
//  Arguments:  [cpFamily] - family codepage of the document
//              [lcid]     - locale id of the text
//              [sidsFontFace] - script coverage of the current font
//              [pch]      - text buffer to analyze
//              [pcch]     - [in]  size of the text buffer
//                           [out] number of characters analyzed
//
//  Returns:    sidKana     for Japanese
//              sidHangul   for Korean
//              sidBopomofo for Traditional Chinese
//              sidHan      for Simplified Chinese
//
//-----------------------------------------------------------------------------

SCRIPT_ID CFontLink::UnunifyHanScript(
    CODEPAGE cpFamily, 
    LCID lcid, 
    SCRIPT_IDS sidsFontFace, 
    const TCHAR * pch, 
    long * pcch)
{
    Assert(pch && *pch);
    Assert(pcch && (*pcch > 0));

    EnsureObjects();

    if (!_pUnicodeScriptMapper) 
        return sidDefault;

    SCRIPT_ID  sidPrefered;
    SCRIPT_IDS sidsAvailable = ScriptsFromCPBit(mlang().GetInstalledLangPacks());

    if (lcid)
    {
        sidPrefered = ScriptIDFromLangID(LANGIDFROMLCID(lcid));
    }
    else
    {
        sidPrefered = ScriptIDFromCodePage(cpFamily);
        if (sidPrefered == sidDefault)
        {
            LANGID lid  = LANGIDFROMLCID(GetSystemDefaultLCID());
            sidPrefered = ScriptIDFromLangID(lid);
        }
    }
    
    HRESULT hr = S_FALSE;
    SCRIPT_ID sid = sidDefault;
    long cch = *pcch;

    // First ask about scripts supported by the current font.
    // If it fails to resolve to appropriate script id, use available
    // lang pack.
    if (sidsFontFace)
    {
        hr = _pUnicodeScriptMapper->UnunifyHanScriptMulti(pch, *pcch,
            sidPrefered, sidsFontFace, USM_AVAILABLESIDONLY, &cch, &sid);
        if (FAILED(hr))
            return sidDefault;
    }
    if (hr == S_FALSE)
    {
        cch = *pcch;
        hr = _pUnicodeScriptMapper->UnunifyHanScriptMulti(pch, *pcch,
            sidPrefered, sidsAvailable, 0, &cch, &sid);
        if (FAILED(hr))
            return sidDefault;
    }

    *pcch = cch;

    return sid;
}

//+----------------------------------------------------------------------------
//
//  Function:   ScriptAppropriateFaceNameAtom
//
//  Synopsis:   Queries MLANG for a font that supports a particular script.
//
//  Returns:    An atom value for the script-appropriate font.  0 on error.
//              0 implies the system font.
//
//-----------------------------------------------------------------------------

HRESULT CFontLink::ScriptAppropriateFaceNameAtom(
    SCRIPT_ID sid,
    LONG & atmProp,
    LONG & atmFixed)
{
    Assert(atmProp == -1 || atmFixed == -1);

    HRESULT hr;
    wchar_t pchPropName  [LF_FACESIZE];
    wchar_t pchFixedName [LF_FACESIZE];

    hr = mlang().ScriptAppropriateFaceName(sid, pchPropName, pchFixedName);
    if (SUCCEEDED(hr))
    {
        if (atmProp == -1)
            atmProp = pchPropName[0] ? fc().GetAtomFromFaceName(pchPropName) : 0; // 0 == System
        if (atmFixed == -1)
            atmFixed = pchFixedName[0] ? fc().GetAtomFromFaceName(pchFixedName) : 0; // 0 == System
    }
    else
    {
        atmProp  = 0; // 0 == System
        atmFixed = 0; // 0 == System
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\fontcache.cxx ===
#include "headers.hxx"

#ifndef X_FONTCACHE_HXX_
#define X_FONTCACHE_HXX_
#include "fontcache.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DeclareTag(tagNoFontLinkAdjust, "Font", "Don't adjust font height when fontlinking");
ExternTag(tagMetrics);
MtDefine(CFontCache, PerProcess, "CFontCache");

//+----------------------------------------------------------------------------
//
//  Font cache stock object.
//
//-----------------------------------------------------------------------------

CFontCache g_FontCache;

//+----------------------------------------------------------------------------
//
//  Function:   InitFontCache
//
//  Synopsis:   Initialize the font cache.
//
//  Returns:    E_OUTOFMEMORY if cannot initialize critical sections;
//              S_OK otherwise
//
//-----------------------------------------------------------------------------

HRESULT InitFontCache()
{
    return fc().Init();
}

//+----------------------------------------------------------------------------
//
//  Function:   DeInitFontCache
//
//  Synopsis:   Cleart the font cache.
//
//-----------------------------------------------------------------------------

void DeInitFontCache()
{
    fc().DeInit();
}

//+----------------------------------------------------------------------------
//
//  Function:   ClearFaceCache
//
//  Synopsis:   Return our small face name cache to a zero state.
//
//-----------------------------------------------------------------------------

void ClearFaceCache()
{
    fc().ClearFaceCache();
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitUniscribe
//
//  Synopsis:   Clear script caches in USP.DLL private heap. This will permit 
//              a clean shut down of USP.DLL (Uniscribe).
//
//-----------------------------------------------------------------------------

void DeinitUniscribe()
{
    fc().FreeScriptCaches();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::CFontCache
//
//  Synopsis:   Font cache ctor.
//
//-----------------------------------------------------------------------------

CFontCache::CFontCache()
{
    _dwAgeNext = 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::CFontCache
//
//  Synopsis:   Font cache dctor.
//
//-----------------------------------------------------------------------------

CFontCache::~CFontCache()
{
#if DBG == 1
    unsigned long i;

    //
    // Make sure font cache is cleared
    //
    for (i = 0; i < cFontCacheSize; i++)
    {
        Assert(NULL == _rpBaseCcs[i]);
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        Assert(NULL == quickCrcSearch[i].pBaseCcs);
    }

    //
    // Make sure font face cache is cleared
    //
    Assert(0 == _iCacheLen);
    Assert(0 == _iCacheNext);
#endif
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::Init
//
//  Synopsis:   Initialize font cache data.
//
//              Don't need to be guarded. This function is called only if
//              the current process is attaching.
//
//-----------------------------------------------------------------------------

HRESULT CFontCache::Init()
{
    //
    // Make sure font cache is uninitialized
    //
    Assert(_dwAgeNext == 0);

    HRESULT hr;

    //
    // Initialize font cache guards.
    //
    _lCSInited = 0;

    hr = HrInitializeCriticalSection(&_cs);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csOther);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csFaceCache);
    if (hr) goto Cleanup;
    ++_lCSInited;

    hr = HrInitializeCriticalSection(&_csFaceNames);
    if (hr) goto Cleanup;
    ++_lCSInited;

    //
    // Initialize font cache.
    //
    EnterCriticalSection(&_cs/*FontCache*/);
    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        _rpBaseCcs[i] = NULL;
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        quickCrcSearch[i].pBaseCcs = NULL;
    }
    LeaveCriticalSection(&_cs/*FontCache*/);

    //
    // Initialize face cache
    //

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::DeInit
//
//  Synopsis:   Uninitialize font cache data.
//
//              Don't need to be guarded. This function is called only if
//              the current process is detaching.
//
//-----------------------------------------------------------------------------

void CFontCache::DeInit()
{
    //
    // Clear caches
    //
    ClearFontCache();
    ClearFaceCache();

    // Only delete the Critical Sections that were successfully initialized
    unsigned long iCSCurrent = 4;
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csFaceNames);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csFaceCache);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_csOther);
    if (iCSCurrent-- <= _lCSInited)
        DeleteCriticalSection(&_cs);
    _lCSInited = 0;

    _atFontInfo.Free();  // Maybe we should do this in a critical section, but naw...

#if DBG == 1
    TraceTag((tagMetrics, "Font Metrics:"));

    TraceTag((tagMetrics, "\tSize of FontCache:%ld", sizeof(CFontCache)));
    TraceTag((tagMetrics, "\tSize of Cccs:%ld + a min of 1024 bytes", sizeof(CCcs)));
    TraceTag((tagMetrics, "\tMax no. of fonts allocated:%ld", CBaseCcs::s_cMaxCccs));
    TraceTag((tagMetrics, "\tNo. of fonts replaced: %ld", _cCccsReplaced));
#endif
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::ClearFontFaceCache
//
//  Synopsis:   Clear font face cache.
//
//-----------------------------------------------------------------------------

void CFontCache::ClearFaceCache()
{
    EnterCriticalSection(&_csFaceCache);

    _iCacheLen = 0;
    _iCacheNext = 0;

    LeaveCriticalSection(&_csFaceCache);
}


//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::ClearFontCache
//
//  Synopsis:   Clear font cache.
//
//-----------------------------------------------------------------------------

void CFontCache::ClearFontCache()
{
    EnterCriticalSection(&_cs/*FontCache*/);

    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        if (_rpBaseCcs[i])
        {
            _rpBaseCcs[i]->ReleaseScriptCache();
            _rpBaseCcs[i]->PrivateRelease();
            _rpBaseCcs[i] = NULL;
        }
    }
    for (i = 0; i < cQuickCrcSearchSize+1; i++)
    {
        quickCrcSearch[i].pBaseCcs = NULL;
    }
    _dwAgeNext = 0;

    LeaveCriticalSection(&_cs/*FontCache*/);
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::FreeScriptCaches
//
//  Synopsis:   Free script caches in USP.DLL private heap. This will permit 
//              a clean shut down of USP.DLL (Uniscribe).
//
//              Don't need to be guarded. This function is called only if
//              all threads have been detached.
//
//-----------------------------------------------------------------------------

void CFontCache::FreeScriptCaches()
{
    unsigned long i;
    for (i = 0; i < cFontCacheSize; i++)
    {
        if (_rpBaseCcs[i])
        {
            _rpBaseCcs[i]->ReleaseScriptCache();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::EnsureScriptIDsForFont
//
//  Synopsis:   When we add a new facename to our _atFontInfo cache, we
//              defer the calculation of the script IDs (sids) for this
//              face.  An undetermined sids has the value of sidsNotSet.
//              Inside of CBaseCcs::MakeFont, we need to make sure that the
//              script IDs are computed, as we will need this information
//              to fontlink properly.
//
//  Arguments:  [hdc]             - handle to the current DC
//              [pBaseCcs]        - font information set
//              [dwFlags]         - is font downloaded? or need to use MLang?
//              [pfHKSCSHack]     - [in] need to check for HKSCS hack?
//                                  [out] need to apply HKSCS hack?
//
//  Returns:    SCRIPT_IDS.  If an error occurs, we return sidsAll, which
//              effectively disables fontlinking for this font.
//
//-----------------------------------------------------------------------------

SCRIPT_IDS CFontCache::EnsureScriptIDsForFont(
    XHDC hdc,                   // [in]
    const CBaseCcs * pBaseCcs,  // [in]
    DWORD dwFlags,              // [in]
    BOOL * pfHKSCSHack )        // [in, out]
{
    // NOTE (grzegorz): It might be a good idea to use _latmRealFaceName
    // instead of _latmLFFaceName.

    const LONG latmFontInfo = pBaseCcs->_latmLFFaceName;
    SCRIPT_IDS sids;

    if (latmFontInfo)
    {
        CFontInfo * pfi;
        HRESULT hr = THR(_atFontInfo.GetInfoFromAtom(latmFontInfo-1, &pfi));

        if (SUCCEEDED(hr))
        {
            if (   pfi->_sids == sidsNotSet
                || (pfi->_fFSOnly && (dwFlags & FC_SIDS_USEMLANG)))
            {
                if (!(dwFlags & FC_SIDS_DOWNLOADEDFONT))
                {
                    CFontInfo * pfiReal;
                    Assert(pBaseCcs->_latmRealFaceName > 0);
                    HRESULT hr = THR(_atFontInfo.GetInfoFromAtom(pBaseCcs->_latmRealFaceName-1, &pfiReal));
                    if (SUCCEEDED(hr))
                    {
                        pfi->_sids = GetFontScriptCoverage(pfiReal->_cstrFaceName, hdc.GetFontInfoDC(), 
                                                           pBaseCcs->GetHFont(), 
                                                           pBaseCcs->_sPitchAndFamily & TMPF_TRUETYPE,
                                                           !(dwFlags & FC_SIDS_USEMLANG));
                    }
                    else
                    {
                        pfi->_sids = sidsAll;
                    }
                }
                else
                {
                    pfi->_sids = sidsAll; // don't fontlink for embedded fonts
                }
                pfi->_fFSOnly = !(dwFlags & FC_SIDS_USEMLANG);
            }

            sids = pfi->_sids;

            // NOTE (cthrash) FE fonts will rarely cover enough of the Greek & Cyrillic
            // codepoints.  This hack basically forces us to fontlink for these.
            if (IsFECharset(pBaseCcs->_bCharSet))
            {
                sids &= ~(ScriptBit(sidLatin) | ScriptBit(sidCyrillic) | ScriptBit(sidGreek));
            }
            if (pBaseCcs->_fLatin1CoverageSuspicious && !(dwFlags & FC_SIDS_DOWNLOADEDFONT))
            {
                sids &= ~ScriptBit(sidLatin);
            }
            if (pfHKSCSHack)
            {
                if (*pfHKSCSHack
                    && sids & ScriptBit(sidBopomofo)
                    && pfi->_cstrFaceName.Length())
                {
                    TCHAR * szFaceName = pfi->_cstrFaceName;
                    if (pfi->_cstrFaceName[0] == _T('@'))
                        ++szFaceName;
                    const TCHAR * szAltFaceName = AlternateFontNameIfAvailable(szFaceName);

                    if (   0 == _tcsicmp(_T("MingLiU_HKSCS"), szFaceName)
                        || 0 == _tcsicmp(_T("MingLiU"), szFaceName)
                        || 0 == _tcsicmp(_T("PMingLiU"), szFaceName)
                        || 0 == _tcsicmp(_T("MingLiU_HKSCS"), szAltFaceName)
                        || 0 == _tcsicmp(_T("MingLiU"), szAltFaceName)
                        || 0 == _tcsicmp(_T("PMingLiU"), szAltFaceName))
                    {
                        sids |= ScriptBit(sidLatin);
                        Assert(*pfHKSCSHack == TRUE);
                    }
                    else
                    {
                        *pfHKSCSHack = FALSE;
                    }
                }
                else
                {
                    *pfHKSCSHack = FALSE;
                }
            }

            if (sids & ScriptBit(sidLatin))
            {
                sids |= ScriptBit(sidCurrency);
            }
        }
        else
            sids = sidsAll;
    }
    else
    {
        sids = sidsAll;
    }

    return sids;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetAtomWingdings
//
//-----------------------------------------------------------------------------

LONG
CFontCache::GetAtomWingdings()
{
    if( !_latmWingdings )
    {
        _latmWingdings = GetAtomFromFaceName( _T("Wingdings") );
        _atFontInfo.SetScriptIDsOnAtom( _latmWingdings - 1, sidsAll );
    }
    return _latmWingdings;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

BOOL
CFontCache::GetCcs(
    CCcs * pccs,
    XHDC hdc,
    CDocInfo * pdci,
    const CCharFormat * const pcf )
{
    Assert(pccs);
    pccs->SetHDC(hdc);
    pccs->SetBaseCcs(GetBaseCcs(hdc, pdci, pcf, NULL, pccs->_fForceTTFont));
    return !!pccs->GetBaseCcs();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetFontLinkCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

BOOL
CFontCache::GetFontLinkCcs(
    CCcs * pccs,
    XHDC hdc,
    CDocInfo * pdci,
    CCcs * pccsBase,
    const CCharFormat * const pcf )
{
    Assert(pccs);

#if DBG==1
    //
    // Allow disabling the height-adjusting feature of fontlinking through tags
    //
    
    if (IsTagEnabled(tagNoFontLinkAdjust))
        return GetCcs(pccs, hdc, pdci, pcf);
#endif

    CBaseCcs * pBaseBaseCcs = pccsBase->_pBaseCcs;

    pBaseBaseCcs->AddRef();

    pccs->SetHDC(hdc);
    pccs->SetBaseCcs(GetBaseCcs(hdc, pdci, pcf, pBaseBaseCcs, pccs->_fForceTTFont));
                   
    pBaseBaseCcs->PrivateRelease();

    return !!pccs->GetBaseCcs();
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetBaseCcs
//
//  Synopsis:   Search the font cache for a matching logical font and return it.
//              If a match is not found in the cache, create one.
//
//-----------------------------------------------------------------------------

CBaseCcs *
CFontCache::GetBaseCcs(
    XHDC hdc,
    CDocInfo * pdci,
    const CCharFormat * const pcf,          // description of desired logical font
    const CBaseCcs * const pBaseBaseCcs,    // facename from which we're fontlinking
    BOOL fForceTTFont)
{
    CBaseCcs *pBaseCcs = NULL;
    LONG      lfHeight;
    int       i;
    BYTE      bCrc;
    SHORT     hashKey;
    CBaseCcs::CompareArgs cargs;
    BOOL (CBaseCcs::*CompareFunc)(CBaseCcs::CompareArgs*);
    BOOL fNeedRelease = FALSE;

    // Duplicate the format structure because we might need to change some of the
    // values by the zoom factor
    // and in the case of sub superscript
    CCharFormat cf = *pcf;

    //FUTURE igorzv
    //Take subscript size, subscript offset, superscript offset, superscript size
    // from the OUTLINETEXMETRIC

    lfHeight = -cf.GetHeightInPixels(hdc, pdci);

    bCrc = cf._bCrcFont;

    Assert (bCrc == cf.ComputeFontCrc());

    if (!lfHeight)
        lfHeight--; // round error, make this a minimum legal height of -1.

    cargs.pcf = &cf;
    cargs.lfHeight = lfHeight;
    cargs.fTTFont = fForceTTFont;

    if (pBaseBaseCcs)
    {
        cargs.latmBaseFaceName = pBaseBaseCcs->_latmLFFaceName;
        CompareFunc = CBaseCcs::CompareForFontLink;
    }
    else
    {
        cargs.latmBaseFaceName = pcf->_latmFaceName;
        CompareFunc = CBaseCcs::Compare;
    }

    EnterCriticalSection(&_cs);

    // check our hash before going sequential.
    hashKey = bCrc & cQuickCrcSearchSize;
    if ( bCrc == quickCrcSearch[hashKey].bCrc )
    {
        pBaseCcs = quickCrcSearch[hashKey].pBaseCcs;
        if (pBaseCcs && pBaseCcs->_bCrc == bCrc)
        {
            if ((pBaseCcs->*CompareFunc)( &cargs ))
            {
                goto matched;
            }
        }
    }
    quickCrcSearch[hashKey].bCrc = bCrc;

    // squentially search ccs for same character format
    for (i = 0; i < cFontCacheSize; i++)
    {
        pBaseCcs = _rpBaseCcs[i];
        if (pBaseCcs && pBaseCcs->_bCrc == bCrc)
        {
            if ((pBaseCcs->*CompareFunc)( &cargs ))
            {
                goto matched;
            }
        }
    }
    pBaseCcs = NULL;

matched:
    if (!pBaseCcs)
    {
        fNeedRelease = fForceTTFont;

        // we did not find a match, init a new font cache.
        pBaseCcs = GrabInitNewBaseCcs(hdc, &cf, pdci, cargs.latmBaseFaceName, fForceTTFont);

        if (   pBaseCcs
            && pBaseBaseCcs
            && !pBaseCcs->_fHeightAdjustedForFontlinking)
        {
            // Adjust font height only for:
            // 1) thai script
            // 2) FE script and size < 9pt
            SCRIPT_IDS sidsFE = ScriptBit(sidKana) | ScriptBit(sidHan) | ScriptBit(sidBopomofo) | ScriptBit(sidHangul);
            if (   (pBaseCcs->_sids & ScriptBit(sidThai))
                || ((pBaseCcs->_sids & sidsFE) && cf._yHeight < TWIPS_FROM_POINTS(9)))
            {
                pBaseCcs->FixupForFontLink(hdc, pBaseBaseCcs, pBaseCcs->_sids & sidsFE);
            }
        }
    }
    else
    {
        if (pBaseCcs->_dwAge != _dwAgeNext - 1)
            pBaseCcs->_dwAge = _dwAgeNext++;
    }

    if (pBaseCcs)
    {
        // Don't cache in 'force TrueType' mode
        if (!fForceTTFont)
            quickCrcSearch[hashKey].pBaseCcs = pBaseCcs;

        // AddRef the entry being returned
        pBaseCcs->AddRef();

        if (!pBaseCcs->EnsureFastCacheExists(hdc, pdci))
        {
            pBaseCcs->PrivateRelease();
            pBaseCcs = NULL;
        }

        if (fNeedRelease)
            pBaseCcs->PrivateRelease();
    }

    LeaveCriticalSection(&_cs);

    return pBaseCcs;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetAtomFromFaceName
//
//  Synopsis:   Checks to see if this face name is in the atom table.
//              if not, puts it in.  We report externally 1 higher than the
//              actualy atom table values, so that we can reserve latom==0
//              to the error case, or a blank string.
//
//-----------------------------------------------------------------------------

LONG
CFontCache::GetAtomFromFaceName( const TCHAR* szFaceName )
{
    HRESULT hr;
    LONG lAtom=0;

    // If they pass in the NULL string, when they ask for it out again,
    // they're gonna get a blank string, which is different.
    Assert(szFaceName);

    if( szFaceName && *szFaceName ) {

        EnterCriticalSection(&_csFaceNames);
        hr= _atFontInfo.GetAtomFromName(szFaceName, &lAtom);
        if( hr )
        {
            // String not in there.  Put it in.
            // Note we defer the calculation of the SCRIPT_IDS.
            hr= THR(_atFontInfo.AddInfoToAtomTable(szFaceName, &lAtom));
            AssertSz(hr==S_OK,"Failed to add Font Face Name to Atom Table");
        }
        if( hr == S_OK )
        {
            lAtom++;
        }
        LeaveCriticalSection(&_csFaceNames);
    }
    // else input was NULL or empty string.  Return latom=0.

    return lAtom;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::FindAtomFromFaceName
//
//  Synopsis:   Checks to see if this face name is in the atom table.
//
//-----------------------------------------------------------------------------

LONG
CFontCache::FindAtomFromFaceName( const TCHAR* szFaceName )
{
    HRESULT hr;
    LONG lAtom=0;

    // If they pass in the NULL string, when they ask for it out again,
    // they're gonna get a blank string, which is different.
    Assert(szFaceName);

    if( szFaceName && *szFaceName ) {

        EnterCriticalSection(&_csFaceNames);
        hr= _atFontInfo.GetAtomFromName(szFaceName, &lAtom);
        if( hr == S_OK )
        {
            lAtom++;
        }
        LeaveCriticalSection(&_csFaceNames);
    }

    // lAtom of zero means that it wasn't found or that the input was bad.
    return lAtom;
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontCache::GetFaceNameFromAtom
//
//-----------------------------------------------------------------------------

const TCHAR *
CFontCache::GetFaceNameFromAtom( LONG latmFaceName )
{
    const TCHAR* szReturn=g_Zero.ach;

    if (latmFaceName > 0)
    {
        HRESULT hr;
        CFontInfo * pfi;

        EnterCriticalSection(&_csFaceNames);
        hr = THR(_atFontInfo.GetInfoFromAtom(latmFaceName-1, &pfi));
        LeaveCriticalSection(&_csFaceNames);
        Assert( !hr );
        Assert( pfi->_cstrFaceName.Length() < LF_FACESIZE );
        szReturn = pfi->_cstrFaceName;
    }
    return szReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\line.cxx ===
/*
 *  LINE.C
 *
 *  Purpose:
 *      CLine* classes
 *
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X__LINE_H_
#define X__LINE_H_
#include "_line.h"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

MtDefine(CLinePtr, Tree, "CLinePtr")
MtDefine(CLine, Tree, "CLine")

ExternTag(tagAssertOnHittestingWithLS);

/*
 *  CLineFull::CchFromXPos
 *
 *  Purpose:
 *      Computes cp corresponding to a x position in a line
 *
 *  Arguments:
 *      me                  measurer position at start of line
 *      x                   xpos to search for
 *      y                   ypos to search for
 *      pdx                 returns adjustment to x at returned cp
 *      fExactFit           Do we need to fit exactly?
 *      pyHeightRubyBase    Support for ruby
 *
 *      HACKHACK (t-ramar): This function calls DiscardLine() at the 
 *              end, but we would like to keep information about Ruby Base
 *              heights around for hit testing purposes.  Thus, there is an
 *              optional parameter:
 *                  ppRubyInfo (out):  is the information pertaining to
 *                                     ruby object that contains the cp
 *                                     (NULL by default)
 *              It's also important to note that this value is ignored if
 *              line flag FLAG_HAS_RUBY is not set.  In this case the 
 *              value pointed to by ppRubyInfo will remain unchanged.
 *  Returns
 *      cp of character found
 *
 *  Note:
 *      me is moved to returned cp
 *
 *  TKTK CF
 *      this should probably be done by a CRenderer to allow
 *      left - right justification
 */
LONG CLineFull::CchFromXpos(CLSMeasurer& me, LONG x, LONG y, LONG *pdx,
                            BOOL fExactFit, LONG *pyHeightRubyBase,
                            BOOL *pfGlyphHit, LONG *pyProposed) const
{
    CMarginInfo marginInfo;
    LONG dx = 0;
    LONG cpStart = me.GetCp();
    LONG cp = cpStart;
    UINT uiFlags = 0;
    WHEN_DBG( LONG oldcch = 0; );
    WHEN_DBG( LONG olddx  = 0; );
    BOOL fReverseFlow = FALSE;

    //
    // Bail out if the line has no charaters in it.
    //
    if (_cch == 0)
        return 0;

    if (me._pFlowLayout->IsDisplayNone())
        return 0;
    
    me.SetBreakLongLines(me._ptpCurrent->GetBranch(), &uiFlags);

    if (pyProposed)
        *pyProposed = LONG_MIN;

    // Determine where x is relative to the line. LTR lines have their origin
    // at the left edge of the text in the line and progress positively to the
    // right; RTL lines have their origin at the  right edge of the text and
    // progress positively to the left.
    if (!_fRTLLn)
    {
        x = x - (_xLeftMargin + _xLeft);
    }
    else
    {
        x = -(x - (_xLeftMargin + _xLeft + _xWidth - 1));
    }

    me._li._cch = 0;                         // Default zero count

    if(x > 0)                          // In between right & left margins
    {
        {
            CLineCore *pliFirstFrag;
            LONG cpStartContainerLine;
            LSERR lserr = lserrNone;
                
            lserr = me.PrepAndMeasureLine((CLineFull*)this, &pliFirstFrag, &cpStartContainerLine, &marginInfo, _cch, uiFlags);

            if (lserr == lserrNone)
            {
                if (me._pLS->_plsline)
                {
                    LONG xTrailEdge;
                    CLineOtherInfo *ploi = pliFirstFrag->oi();
                    
                    Assert(pliFirstFrag->_fRTLLn == _fRTLLn);
                    if (!_fRTLLn)
                    {
                        x += (_xLeft + _xLeftMargin) -
                             (ploi->_xLeft + ploi->_xLeftMargin);
                    }
                    else
                    {
                        x += (_xRight + _xRightMargin) -
                             (pliFirstFrag->_xRight + ploi->_xRightMargin);
                    }

                    if (pliFirstFrag != (CLineCore*)this)
                    {
                        long durWithTrailing, duIgnore;
                        HRESULT hr = me._pLS->GetLineWidth(&durWithTrailing, &duIgnore);
                        if (hr)
                            goto Cleanup;
                        xTrailEdge = durWithTrailing;
                    }
                    else
                    {
                        xTrailEdge = _xWidth + _xWhite;
                    }
                     
                    // If our point is past the end of the line, the return value of
                    // LsQueryLinePointPcp is invalid.
                    if (x < xTrailEdge)
                    {
                        HRESULT hr;
                        LSTEXTCELL lsTextCell;
                        LSTFLOW kTFlow;
                        COneRun *porHit;
                        
                        // FUTURE: (paulnel) If we find we need any more information
                        // from the LSQSUBLINEINFO we can pass it back here.
                        hr = THR( me._pLS->QueryLinePointPcp( x, y, 
                                            &kTFlow, &lsTextCell ) );

                        if (hr)
                        {
                            AssertSz(0,"QueryLinePointPcp failed.");
                            goto Cleanup;
                        }

                        dx = lsTextCell.pointUvStartCell.u - x;
                        fReverseFlow = (IsRTLLine() == !(kTFlow & fUDirection));
                        cp = me._pLS->CPFromLSCPCore(lsTextCell.cpStartCell, &porHit);

                        if (pfGlyphHit)
                        {
                            *pfGlyphHit =    porHit 
                                          && porHit->IsSyntheticRun() 
                                          && porHit->_synthType == CLineServices::SYNTHTYPE_GLYPH;
                        }

                        if (pyProposed)
                        {
                            if (me._pLS->_fHasVerticalAlign)
                                *pyProposed = porHit->_yProposed;
                        }
#if DBG==1
                        // (paulnel) This is a helper for hit testing to see if we 
                        // have the correct character
                        CTxtPtr tp(me._pdp->GetMarkup(), cp);
                        TCHAR ch = tp.GetChar();
                        Assert(!g_Zero.ab[0] || ch);
#endif // DBG
                        if (!fExactFit)
                        {
                            if (cp + long(lsTextCell.cCharsInCell) <= me._cp + _cch)
                            {
                                // It is possible to have lsTextCell flowing against
                                // the line. If this is the case dx is positive and
                                // we will need to subtract dupCell from dx if we
                                // advance the cp.
                                if ( ((!fReverseFlow) ? -dx : dx) >= lsTextCell.dupCell / 2 )
                                {
                                    cp += lsTextCell.cCharsInCell;
                                    dx += (!fReverseFlow) ? lsTextCell.dupCell : -lsTextCell.dupCell;
                                }
                            }
                        }
                    }
                    else
                    {
                        cp = cpStart + _cch;
                        // NOTE: (mikejoch) Shouldn't this be (_xWidth + _xWhite) - x?
                        // NOTE: (dmitryt) I think it doesn't matter. the only place where 
                        // this function (CchFromXpos) is called, is only using the sign of dx (+ or -)
                        // If our point was past the line, dx will be negative. We could assign -1 here...
                        dx = _xWidth - x;
                    }
                }
                else
                {
                    // If _plsline is NULL, we didn't measure.  This usually
                    // means we had no text to measure, or we had no width.
                    
                    Assert(   IsTagEnabled(tagAssertOnHittestingWithLS)
                           || me._li._cch == 0 );
                    
                    dx = _xWidth - x;
                    cp = cpStart;
                }

                // The IE4 measure has a bug in that if you hit test on a
                // BR, you'll get the cch *after* the BR regardless of
                // where in the BR you're positioned.  Don't assert on
                // these false alarms (cthrash)

  #if DBG==1
                if (IsTagEnabled(tagAssertOnHittestingWithLS))
                {
                    WHEN_DBG( if (!me._fLastWasBreak) )
                    {
                        Assert(cp - cpStart == oldcch);
                        Assert(dx           == olddx);
                    }
                }
  #endif // DBG
            }
        }
        me._li._cch = cp - cpStart;
    }
    else
    {
        CTreePos *  ptp;

        me._pdp->FormattingNodeForLine(FNFL_STOPATGLYPH, me.GetCp(), me.GetPtp(), _cch, &me._cchPreChars, &ptp, NULL);

        me._li._cch = me._cchPreChars;
        dx = -x;
    }

    if (pdx)
    {
        *pdx = (!fReverseFlow ? dx : -dx);
    }

Cleanup:
    if (cpStart != long(me.GetCp()))
        me.SetCp(cpStart, NULL);
    me.Advance(me._li._cch);

    if(me.CurrBranch()->GetCharFormat(LC_TO_FC(me._pci->GetLayoutContext()))->_fIsRubyText && pyHeightRubyBase)
    {
        RubyInfo *pRubyInfo = me._pLS->GetRubyInfoFromCp(me.GetCp());
        if(pRubyInfo) 
        {
            *pyHeightRubyBase = pRubyInfo->yHeightRubyBase;
        }
    }

    me._pLS->DiscardLine();
    me.PseudoLineDisable();

    return me._li._cch;
}

// =====================  CLinePtr: Line Run Pointer  ==========================

void CLinePtr::Init ( CLineArray & line_arr )
{
    _prgRun = (CRunArray *) & line_arr;
    SetIRun( 0 );
    SetIch( 0 );
    _iLOI = -1;
    _pLOI = &g_loiStock; //better then NULL, will not crash in low mem stress
}

//
// NOTE (sujalp): Presently this method is only called from the
// constructor. However, we may need it when we need to point the
// rp's to different displays. This functionality may be needed
// when we implement cursor navigation in edit mode between sites.
//
void
CLinePtr::Hijack (CDisplay *pdp)
{
    _pdp = pdp;
    _pdp->InitLinePtr( * this );
}

// Move runptr by a certain number of cch/runs

BOOL
CLinePtr::RpAdvanceCp ( long cch, BOOL fSkipFrame )
{
    // See if this is a multi-line ptr

    Assert( _prgRun );

    if (cch == CRunPtr<CLineCore>::AdvanceCp(cch))
    {
        if (fSkipFrame)
        {
            CLineCore *pLine=GetCurrRun();

            // There might not be a valid run pointer.
            if (pLine && pLine->IsFrame())
            {
                int iStep;
                long iRunEnd;

                Assert( NumRuns() );

                if (cch < 0)
                {
                    iStep = -1;
                    iRunEnd = 0;
                }
                else
                {
                    iStep = 1;
                    iRunEnd = NumRuns() - 1;
                }

                while (GetCurrRun()->IsFrame())
                {
                    if (GetIRun() == iRunEnd)
                    {
                        // If the last line is a frame line, then put the
                        // line ptr at the end of the previous line. Assert
                        // that we have a previous line: it will contain the
                        // embedding character for the site in the frame line.
                        Assert(iRunEnd > 0);
                        SetIRun(iRunEnd - 1);
                        if ((pLine = GetCurrRun()) != NULL)
                        {
                            SetIch(pLine->_cch);
                        }

#if DBG==1
                        {
                            CTxtPtr tp(_pdp->GetMarkup(), GetCp() - 1);
                            TCHAR ch = tp.GetChar();

                            Assert( '\r' != ch );
                        }
#endif
                        return TRUE;
                    }
                    else
                    {
                        SetIRun( GetIRun() + iStep );
                    }
                }
            }
        }
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
CLinePtr::PrevLine ( BOOL fSkipFrame, BOOL fSkipEmptyLines )
{
    long iRun = GetIRun();

    if (PrevRun())
    {
        while ((fSkipFrame && GetCurrRun()->IsFrame()) ||
               (fSkipEmptyLines && 0 == GetCurrRun()->_cch))
        {
            if (!PrevRun())
            {
                SetIRun( iRun );
                SetIch( 0 );

                return FALSE;
            }
        }

        return TRUE;
    }

    return FALSE;
}

BOOL
CLinePtr::NextLine( BOOL fSkipFrame, BOOL fSkipDummyLines )
{
    long iRun = GetIRun();

    if (NextRun())
    {
        while ((fSkipFrame && GetCurrRun()->IsFrame()) ||
                (fSkipDummyLines && GetCurrRun()->IsClear()))
        {
            if (!NextRun())
            {
                SetIRun( iRun );
                SetIch( GetCurrRun()->_cch );

                return FALSE;
            }
        }

        return TRUE;
    }

    return FALSE;
}

CLineCore &
CLinePtr::operator [] ( long dRun )
{
    if (_prgRun)
        return * CRunPtr<CLineCore>::GetRunRel( dRun );

    AssertSz( dRun + GetIRun() == 0 ,
        "LP::[]: inconsistent line ptr");

    return  * (CLineCore *) CRunPtr<CLineCore>::GetRunAbs( GetIRun() );
}

/*
 *  CLinePtr::RpSetCp(cp, fAtEnd)
 *
 *  Purpose
 *      Set this line ptr to cp allowing for ambigous cp and taking advantage
 *      of _cpFirstVisible and _iliFirstVisible
 *
 *  Arguments:
 *      cp      position to set this line ptr to
 *      fAtEnd  if ambiguous cp:
 *              if fAtEnd = TRUE, set this line ptr to end of prev line;
 *              else set to start of line (same cp, hence ambiguous)
 *  Return:
 *      TRUE iff able to set to cp
 */
BOOL CLinePtr::RpSetCp(LONG cp, BOOL fAtEnd, BOOL fSkipFrame, BOOL fSupportBrokenLayout)
{
    Assert(_prgRun);

    BOOL fRet;
    // Adjust the cp to be relative to the txt site containting the disp
    if ( !fSupportBrokenLayout )
    {
        cp -= _pdp->GetFlowLayout()->GetContentFirstCp();
    }
    else
    {
        cp -= _pdp->GetFlowLayout()->GetContentFirstCpForBrokenLayout();
    }
    
    {
        SetIRun( 0 );
        SetIch( 0 );
        fRet = RpAdvanceCp(cp, fSkipFrame);  // Start from 0
    }

    //
    // Note(SujalP): As exposed in bug 50281, it can happen that the containing
    // txtsite contains no lines. In which case we cannot really position
    // ourselves anywhere. Return failure.
    //
    if (!CurLine())
    {
        fRet = FALSE;
    }

    //
    // Note(SujalP): Problem exposed in bug34660 -- when we are positioned at a
    // frame line, then the fAtEnd flag is really meaning less, since we base
    // our decision to move to prev or next line based on where in the line
    // is the cp positioned. Since, frame lines contain to characters, we really
    // cannot make that decision at all.
    //
    else if (!CurLine()->IsFrame())
    {
        // Ambiguous-cp caret position, should we be at the end of the line?
        if(fAtEnd)
        {
            if (!GetIch() && PrevLine( fSkipFrame, FALSE ))
            {
                SetIch( GetCurrRun()->_cch );  //  the first, go to end of
            }
        }

        // Or the beginning of the next one?
        else
        {
            if (GetIch() == long( GetCurrRun()->_cch ) && NextLine( fSkipFrame, FALSE ))
            {
                SetIch( 0 );   // Beginning of next line.
            }
        }
    }

    return fRet;
}


/*
 *  CLinePtr::RpBeginLine(void)
 *
 *  Purpose
 *      Move the current character to the beginning of the line.
 *
 *  Return:
 *      change in cp
 *
 *  Note that this will only work on the array type of line pointer.
 *  You will get an assert otherwise.
 */

long
CLinePtr::RpBeginLine ( )
{
    long cch = GetIch();

    Assert( _prgRun );

    SetIch( 0 );

    return cch - GetIch();
}

/*
 *  CLinePtr::RpEndLine(void)
 *
 *  Purpose
 *      Move the current character to the end of the line.
 *
 *  Return:
 *      change in cp
 *
 *  Note that this will only work on the array type of line pointer.
 *  You will get an assert otherwise.
 */
LONG CLinePtr::RpEndLine(void)
{
    LONG cch = GetIch();

    Assert( _prgRun );

    SetIch( GetCurrRun()->_cch );

    return GetIch() - cch;
}

/*
 *  CLinePtr::FindParagraph(fForward)
 *
 *  Purpose
 *      Move this line ptr to paragraph (fForward) ? end : start, and return
 *      change in cp
 *
 *  Arguments:
 *      fForward    TRUE move this line ptr to para end; else to para start
 *
 *  Return:
 *      change in cp
 */

long
CLinePtr::FindParagraph ( BOOL fForward )
{
    LONG cch;

    if(!fForward)                           // Go to para start
    {
        cch = 0;                            // Default already at para start
        if(RpGetIch() != (LONG)(*this)->_cch ||
           !((*this)->_fHasEOP)) // It isn't at para start
        {
            cch = -RpGetIch();              // Go to start of current line
            while(!((*this)->_fFirstInPara) && (*this) > 0)
            {
                if (!PrevLine(TRUE, FALSE)) // Go to start of prev line
                    break;
                cch -= (*this)->_cch;       // Subtract # chars in line
            }
            SetIch( 0 );                       // Leave *this at para start
        }
    }
    else                                    // Go to para end
    {
        cch = (*this)->_cch - RpGetIch();   // Go to end of current line

        while(((*this) < _pdp->LineCount() - 1 ||
                _pdp->WaitForRecalcIli((LONG)*this + 1))
              && !((*this)->_fHasEOP))
        {
            if (!NextLine(TRUE, FALSE))      // Go to start of next line
                break;
            cch += (*this)->_cch;           // Add # chars in line
        }
        SetIch( (*this)->_cch );               // Leave *this at para end
    }
    return cch;
}

/*
 *  CLinePtr::GetAdjustedLineLength
 *
 *  @mfunc  returns the length of the line _without_ EOP markers
 *
 *  @rdesc  LONG; the length of the line
 */
LONG CLinePtr::GetAdjustedLineLength()
{
    CLineCore * pline = GetCurrRun();
    Assert(pline);
    
    LONG cchJunk;
    LONG cchTrim;
    CTreePos *ptpRet, *ptpPrev;
    
    LONG cpEndLine = _pdp->GetFirstCp() + GetCp() - GetIch() + pline->_cch;
    CTreePos *ptp = _pdp->GetMarkup()->TreePosAtCp(cpEndLine, &cchJunk);
    
    _pdp->EndNodeForLine(cpEndLine, ptp, NULL, &cchTrim, &ptpRet, NULL);
    cchTrim = min(cchTrim, pline->_cch);

    LONG cpNewMost = cpEndLine - cchTrim;
    
    if (ptpRet)
    {
        ptpPrev = ptpRet;

        
        if (   ptpPrev->GetCch() == 0
            || (   ptpPrev->IsNode()
                && !ptpPrev->ShowTreePos()
               )
            || (   ptpPrev->IsText()
                && ptpPrev->GetCp() >= cpNewMost
               )
           )
        {
            do
            {
                ptpPrev = ptpPrev->PreviousTreePos();
            }
            while (ptpPrev->GetCch() == 0);
        }
        
        if (   ptpPrev->IsEndElementScope()
            && ptpPrev->Branch()->Tag() == ETAG_BR
           )
        {
            cchTrim += 2;
        }
        else if (ptpPrev->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), cpNewMost - 1);
            if (tp.GetChar() == WCH_ENDPARA1)
                cchTrim++;
        }
    }
    
    cchTrim = min(cchTrim, pline->_cch);
    return pline->_cch - cchTrim;
}

BOOL
CLinePtr::IsLastTextLine()
{
    return _pdp->IsLastTextLine(*this);
}

#if DBG==1
void
CLineArray::Remove(DWORD ielFirst, LONG celFree, ArrayFlag flag)
{
    DWORD ielLast = (celFree == -1) ? Count() : (ielFirst + celFree);
    CLineCore *pli;
    DWORD i;

    for (i = ielFirst, pli=Elem(ielFirst); i < ielLast; i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    super::Remove(ielFirst, celFree, flag);
}

void
CLineArray::Clear(ArrayFlag flag)
{
    CLineCore *pli;
    DWORD i;
    for (i = 0, pli = Elem(0); i < Count(); i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    super::Clear(flag);
}

BOOL
CLineArray::Replace (DWORD iel, LONG cel, CArrayBase *par)
{
    CLineCore *pli;
    DWORD i;
    CLineArray *plar = DYNCAST(CLineArray, par);
    DWORD iLimit = cel == -1 ? Count() : iel + cel;

    for (i = iel, pli = Elem(iel); i < iLimit; i++, pli++)
    {
        AssertSz(pli->_iLOI == -1, "Not freed, need to call Forget before this!");
    }
    for (i = 0, pli = plar->Elem(0); i < plar->Count(); pli++, i++)
    {
        Assert(pli->_iLOI != -1);
    }
    return super::Replace(iel, cel, par);
}
#endif

BOOL
CLinePtr::Replace(LONG cRun, CLineArray *parLine)
{
    CLineCore *pli;
    DWORD i;

    ((CLineArray *)_prgRun)->Forget(GetIRun(), cRun);
    for (i = 0, pli = parLine->Elem(0); i < parLine->Count(); pli++, i++)
    {
        pli->AddRefOtherInfo();
    }
    return CRunPtr<CLineCore>::Replace(cRun,(CRunArray *)parLine);
}

void
CLineArray::Forget(DWORD iel, LONG cel)
{
    DWORD iLimit = cel == -1 ? Count() : iel + cel;
    CLineCore *pli;
    DWORD i;

    for (i = iel, pli = Elem(iel); i < iLimit; i++, pli++)
    {
        pli->ReleaseOtherInfo();
    }
}

CLineOtherInfo *
CLinePtr::oi()
{
    CLineCore *pli = CurLine();

    Assert(pli->_iLOI != -1);

    if (pli->_iLOI != _iLOI)
    {
        _pLOI = pli->oi();
        _iLOI = pli->_iLOI;
    }
    return _pLOI;
}

WORD
CLineOtherInfo::ComputeCrc() const
{
    Assert((sizeof(CLineOtherInfo) / sizeof(DWORD)) * sizeof(DWORD) == sizeof(CLineOtherInfo));
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CLineOtherInfo)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

CElement *
CLineCore::AO_Element(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->Element();
}

CLayout *
CLineCore::AO_GetUpdatedLayout(CLineOtherInfo *ploi, CLayoutContext *pLayoutContext)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->GetUpdatedLayout(pLayoutContext);
}

LONG
CLineCore::AO_GetFirstCp(CLineOtherInfo *ploi, LONG cpLine)
{
    LONG cpFirst;
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        Assert(cpLine != -1);
        cpFirst = cpLine - ploi->_cchFirstLetter;
    }
    else
    {
        cpFirst = ploi->_pNodeForLayout->Element()->GetFirstCp();
    }
    return cpFirst;
}

LONG
CLineCore::AO_GetLastCp(CLineOtherInfo *ploi, LONG cpLine)
{
    LONG cpLast;
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        Assert(cpLine != -1);
        cpLast = cpLine;
    }
    else
    {
        cpLast = ploi->_pNodeForLayout->Element()->GetLastCp();
    }
    return cpLast;
}

void
CLineCore::AO_GetSize(CLineOtherInfo *ploi, CSize *pSize)
{
    Assert(IsFrame());
    Assert(pSize);
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    if (ploi->_fHasFloatedFL)
    {
        pSize->cx = _xWidth;
        pSize->cy = _yHeight;
    }
    else
    {
        AO_GetUpdatedLayout(ploi)->GetSize(pSize);
    }
}

const CFancyFormat *
CLineCore::AO_GetFancyFormat(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? NULL : ploi->_pNodeForLayout->GetFancyFormat();
}

LONG
CLineCore::AO_GetXProposed(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? 0 : AO_GetUpdatedLayout(ploi)->GetXProposed();
}

LONG
CLineCore::AO_GetYProposed(CLineOtherInfo *ploi)
{
    Assert(IsFrame());
    if (!ploi)
        ploi = oi();
    Assert(ploi == oi());
    return ploi->_fHasFloatedFL ? 0 : AO_GetUpdatedLayout(ploi)->GetYProposed();
}

//
//  For RTL line, convert offsets from right to offsets from left
//  Also, ensure that the chunk widh is >= 0.
//  (why do we need to ensure positive width in LTR case? Don't know, may be we don't.)
//
void CLineCore::AdjustChunkForRtlAndEnsurePositiveWidth(CLineOtherInfo const *ploi, 
                                             LONG xStartChunk, LONG xEndChunk, 
                                             LONG *pxLeft, LONG *pxRight)
{
    
    if (IsRTLLine())
    {
        // note: _xLineWidth is defined as width between margins. 
        //       If there is no overflow, line width is not affected by _xLeft or _xRight; 
        //       it takes all space between margins.
        //       In case of RTL, chunks are positioned relative to the right margin.
        //         
        int xLineRight = ploi->_xLeftMargin + ploi->_xRightMargin + _xLineWidth;
      
        // in RTL layout, _xLineWidth doesn't always start at left margin
        xLineRight += ploi->_xNegativeShiftRTL;
            
        xStartChunk = xLineRight - xStartChunk;
        xEndChunk = xLineRight - xEndChunk;
    }

    if (xStartChunk <= xEndChunk)
    {
        *pxLeft = xStartChunk;
        *pxRight = xEndChunk;
    }
    else
    {
        // This shouldn't happen in LTR, but the author is being over 
        // optimistic about more common usage of content offset in the future.
        // Some call it overengineering, some call it defensive code.
        Assert(IsRTLLine() || !IsTagEnabled(tagDebugRTL));    
        *pxLeft = xEndChunk;
        *pxRight = xStartChunk;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsconst.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCONST.CXX -- line services constants
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      1/29/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_ROBJ_H_
#define X_ROBJ_H_
#include <robj.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifdef _MAC
CLineServices::LSCBK CLineServices::s_lscbk =
#else
const CLineServices::LSCBK CLineServices::s_lscbk =
#endif
{
    CLineServices::NewPtr,
    CLineServices::DisposePtr,
    CLineServices::ReallocPtr,
    CLineServices::FetchRun,
    CLineServices::GetAutoNumberInfo,
    CLineServices::GetNumericSeparators,
    CLineServices::CheckForDigit,
    CLineServices::FetchPap,
    CLineServices::FetchTabs,
    CLineServices::GetBreakThroughTab,
    CLineServices::FGetLastLineJustification,
    CLineServices::CheckParaBoundaries,
    CLineServices::GetRunCharWidths,
    CLineServices::CheckRunKernability,
    CLineServices::GetRunCharKerning,
    CLineServices::GetRunTextMetrics,
    CLineServices::GetRunUnderlineInfo,
    CLineServices::GetRunStrikethroughInfo,
    CLineServices::GetBorderInfo,
    CLineServices::ReleaseRun,
    CLineServices::Hyphenate,
    CLineServices::GetHyphenInfo,
    CLineServices::DrawUnderline,
    CLineServices::DrawStrikethrough,
    CLineServices::DrawBorder,
    CLineServices::DrawUnderlineAsText,
    CLineServices::FInterruptUnderline,
    CLineServices::FInterruptShade,
    CLineServices::FInterruptBorder,
    CLineServices::ShadeRectangle,
    CLineServices::DrawTextRun,
    CLineServices::DrawSplatLine,
    CLineServices::FInterruptShaping,
    CLineServices::GetGlyphs,
    CLineServices::GetGlyphPositions,
    CLineServices::ResetRunContents,
    CLineServices::DrawGlyphs,
    CLineServices::GetGlyphExpansionInfo,
    CLineServices::GetGlyphExpansionInkInfo,
    CLineServices::GetEms,
    CLineServices::PunctStartLine,
    CLineServices::ModWidthOnRun,
    CLineServices::ModWidthSpace,
    CLineServices::CompOnRun,
    CLineServices::CompWidthSpace,
    CLineServices::ExpOnRun,
    CLineServices::ExpWidthSpace,
    CLineServices::GetModWidthClasses,
    CLineServices::GetBreakingClasses,
    CLineServices::FTruncateBefore,
    CLineServices::CanBreakBeforeChar,
    CLineServices::CanBreakAfterChar,
    CLineServices::FHangingPunct,
    CLineServices::GetSnapGrid,
    CLineServices::DrawEffects,
    CLineServices::FCancelHangingPunct,
    CLineServices::ModifyCompAtLastChar,
    CLineServices::EnumText,
    CLineServices::EnumTab,
    CLineServices::EnumPen,
    CLineServices::GetObjectHandlerInfo,
    CLineServices::AssertFailed
};


WHEN_DBG( int CLineServices::s_nSerialMax=0; )

const struct lstxtcfg CLineServices::s_lstxtcfg =
{
    LS_AVG_CHARS_PER_LINE,              // cEstimatedCharsPerLine; modify as necessary
    WCH_UNDEF,
    WCH_NULL,
    WCH_SPACE,
    WCH_HYPHEN,
    WCH_TAB,
    WCH_ENDPARA1,
    WCH_ENDPARA2,
    WCH_ALTENDPARA,
    WCH_SYNTHETICLINEBREAK,
    WCH_COLUMNBREAK,
    WCH_SECTIONBREAK,
    WCH_PAGEBREAK,
    WCH_UNDEF,                          // NB (cthrash) Don't let LS default-handle NONBREAKSPACE
    WCH_NONBREAKHYPHEN,
    WCH_NONREQHYPHEN,
    WCH_EMDASH,
    WCH_ENDASH,
    WCH_EMSPACE,
    WCH_ENSPACE,
    WCH_NARROWSPACE,
    WCH_OPTBREAK,
    WCH_NOBREAK,
    WCH_FESPACE,
    WCH_ZWJ,
    WCH_ZWNJ,
    WCH_TOREPLACE,
    WCH_REPLACE,
    WCH_VISINULL,
    WCH_VISIALTENDPARA,
    WCH_VISIENDLINEINPARA,
    WCH_VISIENDPARA,
    WCH_VISISPACE,
    WCH_VISINONBREAKSPACE,
    WCH_VISINONBREAKHYPHEN,
    WCH_VISINONREQHYPHEN,
    WCH_VISITAB,
    WCH_VISIEMSPACE,
    WCH_VISIENSPACE,
    WCH_VISINARROWSPACE,
    WCH_VISIOPTBREAK,
    WCH_VISINOBREAK,
    WCH_VISIFESPACE,
    WCH_ESCANMRUN,
};

CLineServices::LSIMETHODS
CLineServices::g_rgLsiMethods[CLineServices::LSOBJID_COUNT] =
{
    //
    // The order of these is determined by the order of 
    // enum LSOBJID
    //

    // LSOBJID_EMBEDDED
    {
        CLineServices::CreateILSObj,
        CEmbeddedILSObj::DestroyILSObj,
        CEmbeddedILSObj::SetDoc,
        CEmbeddedILSObj::CreateLNObj,
        CEmbeddedILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CEmbeddedILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CEmbeddedILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CDobjBase::TruncateChunk,
        CEmbeddedDobj::FindPrevBreakChunk,
        CEmbeddedDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CDobjBase::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CDobjBase::CalcPresentation,  
        CEmbeddedDobj::QueryPointPcp,
        CEmbeddedDobj::QueryCpPpoint,
        CEmbeddedDobj::Enum,
        CEmbeddedDobj::Display,
        CEmbeddedDobj::DestroyDObj
    },

    // LSOBJID_NOBR
    {
        CLineServices::CreateILSObj,
        CNobrILSObj::DestroyILSObj,
        CNobrILSObj::SetDoc,
        CNobrILSObj::CreateLNObj,
        CNobrILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CNobrILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CNobrILSObj::FmtResume,
        CNobrDobj::GetModWidthPrecedingChar,
        CNobrDobj::GetModWidthFollowingChar,
        CNobrDobj::TruncateChunk,
        CNobrDobj::FindPrevBreakChunk,
        CNobrDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CNobrDobj::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CNobrDobj::CalcPresentation,  
        CNobrDobj::QueryPointPcp,  
        CNobrDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CNobrDobj::Display,
        CNobrDobj::DestroyDObj
    },

    // LSOBJID_GLYPH
    {
        CLineServices::CreateILSObj,
        CGlyphILSObj::DestroyILSObj,
        CGlyphILSObj::SetDoc,
        CGlyphILSObj::CreateLNObj,
        CGlyphILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CGlyphILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CGlyphILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CGlyphDobj::TruncateChunk,
        CGlyphDobj::FindPrevBreakChunk,
        CGlyphDobj::FindNextBreakChunk,
        CDobjBase::ForceBreakChunk,
        CDobjBase::SetBreak,  
        CDobjBase::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CDobjBase::CalcPresentation,  
        CGlyphDobj::QueryPointPcp,  
        CGlyphDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CGlyphDobj::Display,
        CGlyphDobj::DestroyDObj
    },

    // LSOBJID_LAYOUTGRID
    {
        CLineServices::CreateILSObj,
        CLayoutGridILSObj::DestroyILSObj,
        CLayoutGridILSObj::SetDoc,
        CLayoutGridILSObj::CreateLNObj,
        CLayoutGridILSObj::DestroyLNObj,
        (LSERR (WINAPI CILSObjBase::*)(PCFMTIN, FMTRES*))CLayoutGridILSObj::Fmt,
        (LSERR (WINAPI CILSObjBase::*)(BREAKREC*, DWORD, PCFMTIN, FMTRES*))CLayoutGridILSObj::FmtResume,
        CDobjBase::GetModWidthPrecedingChar,
        CDobjBase::GetModWidthFollowingChar,
        CLayoutGridDobj::TruncateChunk,
        CLayoutGridDobj::FindPrevBreakChunk,
        CLayoutGridDobj::FindNextBreakChunk,
        CLayoutGridDobj::ForceBreakChunk,
        CLayoutGridDobj::SetBreak,  
        CLayoutGridDobj::GetSpecialEffectsInside,
        CDobjBase::FExpandWithPrecedingChar,
        CDobjBase::FExpandWithFollowingChar,
        CLayoutGridDobj::CalcPresentation,  
        CLayoutGridDobj::QueryPointPcp,  
        CLayoutGridDobj::QueryCpPpoint,
        CDobjBase::Enum,
        CLayoutGridDobj::Display,
        CLayoutGridDobj::DestroyDObj
    },

    // The remainder is populated by LineServices.
};

#if defined(UNIX) || defined(_MAC)
// UNIX uses s_unix_rgLsiMethods to replace g_rgLsiMethods
::LSIMETHODS
CLineServices::s_unix_rgLsiMethods[CLineServices::LSOBJID_COUNT] =
{
    // Will be filled later.
};

// It takes only 4 bytes of each Method pointer in g_rgLsiMethods
#if defined(SPARC) || defined(_MAC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
void CLineServices::InitLsiMethodStruct()
{
    int i, j;
    DWORD *pdest = (DWORD*)s_unix_rgLsiMethods;
    DWORD *psrc = (DWORD*)g_rgLsiMethods;
    // The # of bytes of each member of LSIMETHODS
    // Macintosh uses 12 byte entries not 8
    int s_LSIMETHODS_Sizes[] = {8,8,8,8,8,8,8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4};

    for (i=0; i< 3; i++) // 3 sub-structs were initialized in g_rgLsiMethods
        for (j=0; j< 23; j++) // Each sub-struct has 23 members
        {
            if (s_LSIMETHODS_Sizes[j] == 8)
            {
#ifdef _MAC
                psrc++; // skip an extra 4 bytes
#endif
                psrc++; // skip the first 4 bytes
            }
            *pdest++ = *psrc++;
        }
}
#else // HP
#error "HP uses 12 bytes method ptrs, so it needs to implement differently"
#endif //SPARC
#endif //UNIX

const CLineServices::RUBYINIT CLineServices::s_rubyinit =
{
    RUBY_VERSION,
    RubyMainLineFirst,
    WCH_ESCRUBY,
    WCH_ESCMAIN,
    WCH_NULL,
    WCH_NULL,
    CLineServices::FetchRubyPosition,
    CLineServices::FetchRubyWidthAdjust,
    CLineServices::RubyEnum,
};

#if defined(UNIX) || defined(_MAC)
::RUBYINIT CLineServices::s_unix_rubyinit =
{
    // will be filled out later
};
#if defined(SPARC) || defined(_MAC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitRubyinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 3;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_rubyinit;
        BYTE* psrc  = (BYTE*)&s_rubyinit;

#ifdef _MAC
        int iFirst = sizeof(RUBYINIT) - cMethodPtrs * 12; // 3 12-bytes member;
#else
        int iFirst = sizeof(RUBYINIT) - cMethodPtrs * 8; // 3 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement differently"
#endif
#endif // UNIX || _MAC

const CLineServices::TATENAKAYOKOINIT CLineServices::s_tatenakayokoinit =
{
    TATENAKAYOKO_VERSION,
    WCH_ENDTATENAKAYOKO,
    WCH_NULL,
    WCH_NULL,
    WCH_NULL,
    CLineServices::GetTatenakayokoLinePosition,
    CLineServices::TatenakayokoEnum,
};

#if defined(UNIX) || defined(_MAC)
::TATENAKAYOKOINIT CLineServices::s_unix_tatenakayokoinit =
{
    // will be filled later
};

int CLineServices::InitTatenakayokoinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 2;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_tatenakayokoinit;
        BYTE* psrc  = (BYTE*)&s_tatenakayokoinit;

#ifdef _MAC
        int iFirst = sizeof(TATENAKAYOKOINIT) - cMethodPtrs * 12; // 2 12-bytes member;
#else
        int iFirst = sizeof(TATENAKAYOKOINIT) - cMethodPtrs * 8; // 2 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#endif

const CLineServices::HIHINIT CLineServices::s_hihinit =
{
    HIH_VERSION,
    WCH_ENDHIH,
    WCH_NULL,
    WCH_NULL,
    WCH_NULL,
    CLineServices::HihEnum,
};

#if defined(UNIX) || defined(_MAC)
::HIHINIT CLineServices::s_unix_hihinit =
{
    // will be filled later
};
#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitHihinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 1;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_hihinit;
        BYTE* psrc  = (BYTE*)&s_hihinit;

#ifdef _MAC
        int iFirst = sizeof(HIHINIT) - 12; // 1 12-bytes member;
#else
        int iFirst = sizeof(HIHINIT) - 8; // 1 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

#ifdef _MAC
        psrc += sizeof(DWORD);
#endif
        psrc += sizeof(DWORD);
        *(DWORD*)pdest = *(DWORD*)psrc;
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const CLineServices::WARICHUINIT CLineServices::s_warichuinit =
{
    WARICHU_VERSION,
    WCH_ENDFIRSTBRACKET,
    WCH_ENDTEXT,
    WCH_ENDWARICHU,
    WCH_NULL,
    CLineServices::GetWarichuInfo,
    CLineServices::FetchWarichuWidthAdjust,
    CLineServices::WarichuEnum,
    FALSE
};

#if defined(UNIX) || defined(_MAC)
::WARICHUINIT CLineServices::s_unix_warichuinit =
{
    // will be filled later
};

#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitWarichuinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 3; 
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_warichuinit;
        BYTE* psrc  = (BYTE*)&s_warichuinit;

#ifdef _MAC
        int iFirst = sizeof(WARICHUINIT) - cMethodPtrs * 12; // 3 12-bytes member;
#else
        int iFirst = sizeof(WARICHUINIT) - cMethodPtrs * 8; // 3 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

        for(int i=0; i< cMethodPtrs; i++)
        {
#ifdef _MAC
            psrc += sizeof(DWORD);
#endif
            psrc += sizeof(DWORD);
            *(DWORD*)pdest = *(DWORD*)psrc;
            pdest += sizeof(DWORD);
            psrc  += sizeof(DWORD);
        }
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const CLineServices::REVERSEINIT CLineServices::s_reverseinit =
{
    REVERSE_VERSION,
    WCH_ENDREVERSE,
    WCH_NULL,
    0,
    CLineServices::ReverseEnum,
};

#if defined(UNIX) || defined(_MAC)
::REVERSEINIT CLineServices::s_unix_reverseinit =
{
    // will be filled later
};

#if defined(SPARC) || (defined(_HPUX_SOURCE) && defined(__APOGEE__))
int CLineServices::InitReverseinit()
{
    static BOOL fInit = FALSE;
    int cMethodPtrs = 1;
    if (!fInit)
    {
        BYTE* pdest = (BYTE*)&s_unix_reverseinit;
        BYTE* psrc  = (BYTE*)&s_reverseinit;

#ifdef _MAC
        int iFirst = sizeof(REVERSEINIT) - 8; // 1 8-bytes member;
#else
        int iFirst = sizeof(REVERSEINIT) - 8; // 1 8-bytes member;
#endif
        memcpy(pdest, psrc, iFirst);
        pdest += iFirst;
        psrc += iFirst;

#ifdef _MAC
        psrc += sizeof(DWORD);
#endif
        psrc += sizeof(DWORD);
        *(DWORD*)pdest = *(DWORD*)psrc;
        fInit = TRUE;
    }
    return cMethodPtrs * sizeof(DWORD);
}
#else
#error "HP needs to implement this function"
#endif
#endif // UNIX

const WCHAR CLineServices::s_achTabLeader[tomLines] =
{
    WCH_NULL,
    WCH_DOT,
    WCH_HYPHEN
};

const CLineServices::SYNTHDATA
CLineServices::s_aSynthData[SYNTHTYPE_COUNT] =
{
//
//    wch               idObj               typeEndObj              idLevel     fObjStart   fObjEnd,    fHidden     fLSCPStop   pszSynthName
//
    { WCH_UNDEF,        idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      TRUE,       FALSE,      WHEN_DBG(_T("[none]")) },
    { WCH_SECTIONBREAK, idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[sectionbreak]")) },
    { WCH_REVERSE,      LSOBJID_REVERSE,    SYNTHTYPE_ENDREVERSE,   2,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[reverse]")) },
    { WCH_ENDREVERSE,   LSOBJID_REVERSE,    SYNTHTYPE_NONE,         2,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endreverse]")) },
    { WCH_NOBRBLOCK,    LSOBJID_NOBR,       SYNTHTYPE_ENDNOBR,      3,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[nobr]")) },
    { WCH_NOBRBLOCK,    LSOBJID_NOBR,       SYNTHTYPE_NONE,         3,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endnobr]")) },
    { WCH_ENDPARA1,     idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[endpara1]")) },
    { WCH_ALTENDPARA,   idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[altendpara]")) },
    { WCH_UNDEF,     	LSOBJID_RUBY,       SYNTHTYPE_ENDRUBYTEXT,  1,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[rubymain]")) },
    { WCH_ESCMAIN,     	LSOBJID_RUBY,       SYNTHTYPE_NONE,         1,       	TRUE,       TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endrubymain]")) },
    { WCH_ESCRUBY,     	LSOBJID_RUBY,       SYNTHTYPE_NONE,         1,       	FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endrubytext]")) },
    { WCH_SYNTHETICLINEBREAK, idObjTextChp, SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[linebreak]")) },
    { WCH_UNDEF,        LSOBJID_GLYPH,      SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[glyph]")) },
    { WCH_LAYOUTGRID,   LSOBJID_LAYOUTGRID, SYNTHTYPE_ENDLAYOUTGRID,1,          TRUE,       FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[layoutgrid]")) },
    { WCH_ENDLAYOUTGRID,LSOBJID_LAYOUTGRID, SYNTHTYPE_NONE,         1,          FALSE,      TRUE,       FALSE,      FALSE,      WHEN_DBG(_T("[endlayoutgrid]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[mbp open]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      TRUE,       WHEN_DBG(_T("[mbp close]")) },
    { WCH_NODE,         idObjTextChp,       SYNTHTYPE_NONE,         0,          FALSE,      FALSE,      FALSE,      FALSE,      WHEN_DBG(_T("[wbr]")) },
};

//
// This is a line-services structure defining an escape sequence.
// In this case, it is the escape sequence ending LS installed 
// object. A pair of characters represents a range of characters,
// which ends an object.
//
const LSESC CNobrILSObj::s_lsescEndNOBR[NBREAKCHARS] = 
{
    {WCH_NOBRBLOCK,  WCH_NOBRBLOCK},
};

const LSESC CLayoutGridILSObj::s_lsescEndLayoutGrid[NBREAKCHARS] = 
{
    {WCH_ENDLAYOUTGRID,  WCH_ENDLAYOUTGRID},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsm2.cxx ===
/*
 *  LSM2.CXX -- CLSMeasurer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/27/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_POBJDIM_H_
#define X_POBJDIM_H_
#include <pobjdim.h>
#endif

#ifndef X_HEIGHTS_H_
#define X_HEIGHTS_H_
#include <heights.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagDontReuseLinkFonts);
MtDefine(CFormatStash_pv, Locals, "Format Stash");

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::Resync()
//
//  Synopsis:   This is temporary fn till we are using the CLSMeasurer and
//              CMeasurer. Essentiall does me = lsme
//
//-----------------------------------------------------------------------------

void
CLSMeasurer::Resync()
{
    _cAlignedSites = _pLS->_cAlignedSites;
    _cAlignedSitesAtBeginningOfLine = _pLS->_cAlignedSitesAtBOL;
    _cchWhiteAtBeginningOfLine = _pLS->_cWhiteAtBOL;
    _fLastWasBreak = _pLS->_li._fHasBreak;
}

//+----------------------------------------------------------------------------
//  Member:     CLSMeasurer::MeasureListIndent()
//
//  Synopsis:   Compute and indent of line due to list properties (bullets and
//              numbering) in device units
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureListIndent()
{
    const   CParaFormat *pPF;
    BOOL    fInner = FALSE; // Keep retail compiler happy
    LONG    dxOffset = 0;
    LONG    dxPFOffset;
    CTreePos *ptp;
    
    if (!_fMeasureFromTheStart)
    {
        pPF = MeasureGetPF(&fInner);
        ptp = GetPtp();
    }
    else
    {
        LONG cp = GetCp() + _cchPreChars;
        ptp = GetMarkup()->TreePosAtCp(cp, NULL, FALSE);
        pPF = ptp->GetBranch()->GetParaFormat();
    }

    dxPFOffset = pPF->GetBulletOffset(GetCalcInfo());

    // Adjust the line height if the current line has a bullet or number.
    // Get offset of the bullet.
    if (_li._fHasBulletOrNum)
    {
        SIZE sizeImg;
        if (   pPF->GetImgCookie() 
            && MeasureImage(pPF->GetImgCookie(), &sizeImg))
        {
            // If we have an image cookie, try measuring the image.
            // If it has not come in yet or does not exist, fall through
            // to either bullet or number measuring.

            dxOffset = sizeImg.cx;

            // Adjust line height if necessary
            if (sizeImg.cy > _li._yHeight - _li._yDescent)
                _li._yHeight = sizeImg.cy + _li._yDescent;

            _li._yBulletHeight = sizeImg.cy;
        }
        else
        {
            switch (pPF->GetListing().GetType())
            {
                case CListing::BULLET:
                    MeasureSymbol(ptp, chDisc, &dxOffset);
                    break;

                case CListing::NUMBERING:
                    MeasureNumber(ptp, pPF, &dxOffset);
                    break;
            }
        }

        dxOffset = max(int(dxOffset), _pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    // In case of bullet position inside adjust _xLeft, if necessary.
    if (   dxOffset > dxPFOffset
        && pPF->_bListPosition == styleListStylePositionInside)
    {
        if (!pPF->HasRTL(fInner))
        {
            _li._xLeft += dxOffset - dxPFOffset;
        }
        else
        {
            _li._xRight += dxOffset - dxPFOffset;
        }
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureNumber(pxWidth, pyHeight)
//
// Synopsis:    Computes number width and height (if any)
//
// Returns:     number width and height
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureNumber(CTreePos *ptp, const CParaFormat *ppf, LONG *pxWidth)
{
    CCcs          ccs;
    CTreeNode   * pNodeLI;

    pNodeLI = GetMarkup()->SearchBranchForCriteriaInStory(ptp->GetBranch(), IsListItemNode);
    Assert(pNodeLI);
    
    const  CCharFormat *pCF = pNodeLI->GetCharFormat();
    GetCcsNumber(&ccs, pCF);
    AssertSz(pxWidth, "CLSMeasurer::MeasureNumber: invalid arg(s)");

    Assert(ccs.GetBaseCcs());

    // NOTE (cthrash) Currently we employ Netscape-sytle numbering.
    // This means we don't adjust for the size of the index value,
    // keeping the offset constant regardless of the size of the index value
    // string.
    *pxWidth = 0;

    if (ccs.GetBaseCcs())
    {
        LONG yAscent, yDescent;

        ccs.GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);
        _li._yBulletHeight = yAscent + yDescent;
        _pLS->RecalcLineHeight(pCF, GetCp(), &ccs, &_li);
        ccs.Release();
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::GetCcsSymbol() (used for symbols & bullets)
//
// Synopsis:    Get CCcs for symbol font
//
// Returns:     ptr to symbol font CCcs
//
//-----------------------------------------------------------------------------

// Default character format for a bullet
static CCharFormat s_cfBullet;

BOOL
CLSMeasurer::GetCcsSymbol(
    CCcs *              pccs,
    TCHAR               chSymbol,
    const CCharFormat * pcf,
    CCharFormat *       pcfRet)
{
    CCharFormat         cf;
    CCharFormat *       pcfUsed = (pcfRet != NULL) ? pcfRet : &cf;
    static BOOL         s_fBullet = FALSE;
    BOOL                fRet;
    
    Assert(pccs);
    if (!s_fBullet)
    {
        // N.B. (johnv) For some reason, Win95 does not render the Windings font properly
        //  for certain characters at less than 7 points.  Do not go below that size!
        s_cfBullet.SetHeightInTwips( TWIPS_FROM_POINTS ( 7 ) );
        s_cfBullet._bCharSet = SYMBOL_CHARSET;
        s_cfBullet._fNarrow = FALSE;
        s_cfBullet._bPitchAndFamily = (BYTE) FF_DONTCARE;
        s_cfBullet.SetFaceNameAtom(fc().GetAtomWingdings());
        s_cfBullet._bCrcFont = s_cfBullet.ComputeFontCrc();

        s_fBullet = TRUE;
    }

    // Use bullet char format
    *pcfUsed = s_cfBullet;

    pcfUsed->_ccvTextColor    = pcf->_ccvTextColor;

    // Since we always cook up the bullet character format, we don't need
    // to cache it.
    if (fc().GetCcs(pccs, _pci->_hdc, _pci, pcfUsed))
    {
        // Important - CM_SYMBOL is a special mode where out WC chars are actually
        // zero-extended MB chars.  This allows us to have a codepage-independent
        // call to ExTextOutA. (cthrash)

        pccs->SetConvertMode(CM_SYMBOL);
        fRet = TRUE;
    }
    else
    {
        TraceTag((tagError, "CRchMeasurer::GetCcsBullet(): no CCcs"));
        fRet = FALSE;
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::GetCcsNumber()
//
//  Synopsis:   Get CCcs for numbering font
//
//  Returns:    ptr to numbering CCcs
//
//  Comment:    The font for the number could change with every instance of a
//              number, because it is subject to the implied formatting of the
//              LI.
//
//-----------------------------------------------------------------------------

BOOL
CLSMeasurer::GetCcsNumber (CCcs *pccs, const CCharFormat * pCF, CCharFormat * pCFRet)
{
    CCharFormat cf = *pCF;

    cf._fSubscript = cf._fSuperscript = FALSE;
    cf._bCrcFont = cf.ComputeFontCrc();

    if(pCFRet)
        *pCFRet = cf;

    return fc().GetCcs(pccs, _pci->_hdc, _pci, &cf);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLSMeasurer::MeasureSymbol()
//
//  Synopsis:   Measures the special character in WingDings
//
//  Returns:    Nothing
//
//  Note:       that this function returns ascent of the font
//              rather than the entire height. This means that the
//              selected symbol (bullet) character should NOT have a descender.
//
//-----------------------------------------------------------------------------

void CLSMeasurer::MeasureSymbol (CTreePos *ptp, TCHAR chSymbol, LONG *pxWidth)
{
    const      CCharFormat *pCF;
    LONG       xWidthTemp;
    CTreeNode *pNode;
    CCcs       ccs;

    AssertSz(pxWidth, "CLSMeasurer::MeasureSymbol: invalid arg(s)");
    
    pNode = GetMarkup()->SearchBranchForCriteriaInStory(ptp->GetBranch(), IsListItemNode);
    Assert(pNode);
    pCF = pNode->GetCharFormat();
    GetCcsSymbol(&ccs, chSymbol, pCF);

    xWidthTemp = 0;

    if(ccs.GetBaseCcs())
    {
        if(!ccs.Include(chSymbol, xWidthTemp))
        {
            TraceTag((tagError,
                "CLSMeasurer::MeasureSymbol(): Error filling CCcs"));
        }

        xWidthTemp += ccs.GetBaseCcs()->_xUnderhang + ccs.GetBaseCcs()->_xOverhangAdjust;
    }

    *pxWidth = xWidthTemp;

    if (ccs.GetBaseCcs())
    {
        LONG yAscent, yDescent;
        
        ccs.GetBaseCcs()->GetAscentDescent(&yAscent, &yDescent);
        _li._yBulletHeight = yAscent + yDescent;
        ccs.Release();

        // Get the height of normal text in the site.
        // I had originally used the height of the LI,
        // but Netscape doesn't seem to do that. It's
        // possible that they actually have a fixed
        // height for the bullets.
        // (dmitryt, staryear 2001) only do this ancient netscapizm if
        // we don't have line-height, otherwise use LI's CharFormat.
        if (pCF->_cuvLineHeight.IsNull()) 
        {
            CTreePos *ptpStart;
            _pFlowLayout->GetContentTreeExtent(&ptpStart, NULL);
            pCF = ptpStart->Branch()->GetCharFormat();
        }
        
        if (fc().GetCcs(&ccs, _pci->_hdc, _pci, pCF))
        {
            _pLS->RecalcLineHeight(pCF, GetCp(), &ccs, &_li);
            ccs.Release();
        }
    }
}

BOOL
CLSMeasurer::MeasureImage(long lImgCookie, SIZE * psizeImg)
{
    CMarkup * pMarkup = _pFlowLayout->GetOwnerMarkup();
    CDoc    * pDoc = pMarkup->Doc();
    CImgCtx * pImgCtx = pDoc->GetUrlImgCtx(lImgCookie);

    if (!pImgCtx || !(pImgCtx->GetState(FALSE, psizeImg) & IMGLOAD_COMPLETE))
    {
        psizeImg->cx = psizeImg->cy = 0;
        return FALSE;
    }

    // The *psizeImg obtained from getState() assumed to be in OM pixels
    _pci->DeviceFromDocPixels(*psizeImg, *psizeImg);

    return TRUE;
}


//-----------------------------------------------------------------------------
//
// Member:      TestForClear
//
// Synopsis:    Tests if the clear bit is to be set and returns the result
//
//-----------------------------------------------------------------------------

BOOL
CLSMeasurer::TestForClear(const CMarginInfo *pMarginInfo, LONG cp, BOOL fShouldMarginsExist, const CFancyFormat *pFF)
{
    //
    // If margins are not necessary for clear to be turned on, then lets ignore it
    // and just check the flags inside the char format. Bug 47575 shows us that
    // if clear has been applied to BR's and that line contains a aligned image, then 
    // the margins have not been setup yet (since the image will be measure
    // *after* the line is measured. However, if we do not turn on clear left/right
    // here then we will never clear the margins!
    //
    BOOL fClearLeft  =    (!fShouldMarginsExist || pMarginInfo->HasLeftMargin())
                       && pFF->_fClearLeft;
    BOOL fClearRight =    (!fShouldMarginsExist || pMarginInfo->HasRightMargin())
                       && pFF->_fClearRight;
    
    if (cp >= 0)
    {
        Assert(_pLS);
        if (fClearLeft)
            _pLS->_lineFlags.AddLineFlag(cp, FLAG_HAS_CLEARLEFT);
        if (fClearRight)
            _pLS->_lineFlags.AddLineFlag(cp, FLAG_HAS_CLEARRIGHT);
    }
    
    return fClearLeft || fClearRight;
}


//-----------------------------------------------------------------------------
//
//  Function:   AdjustForMargins
//
//  Synopsis:   Adjust the RECT for margins, including negative margins and
//              the beginning and end of lines.
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::AdjustForMargins(CRect *prc, CBorderInfo *pborderInfo, CTreeNode *pNode,
                             const CFancyFormat *pFF, const CCharFormat *pCF,
                             BOOL fBOLWrapped, BOOL fEOLWrapped, BOOL fIsPseudoMBP)
{
    BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
    LONG lFontHeight = pCF->GetHeightInTwips(_pdp->GetMarkup()->Doc());
    LONG xParentWidth = 0;

    CUnitValue cuvMarginLeft;
    CUnitValue cuvMarginRight;
    // We do not want to include the margin in the rect we 
    // are going to draw the border around
    if (fIsPseudoMBP)
    {
        const CPseudoElementInfo * pPEI = GetPseudoElementInfoEx(pFF->_iPEI);

        cuvMarginLeft  = pPEI->GetLogicalMargin(SIDE_LEFT, fNodeVertical, fWritingModeUsed, pFF);
        cuvMarginRight = pPEI->GetLogicalMargin(SIDE_RIGHT, fNodeVertical, fWritingModeUsed, pFF);

        if (cuvMarginLeft.IsPercent() || cuvMarginRight.IsPercent())
        {
            xParentWidth = pNode->GetParentWidth(_pci, _pci->_sizeParent.cx);
        }
    }
    else
    {
        cuvMarginLeft  = pFF->GetLogicalMargin(SIDE_LEFT, fNodeVertical, fWritingModeUsed);
        cuvMarginRight = pFF->GetLogicalMargin(SIDE_RIGHT, fNodeVertical, fWritingModeUsed);

        if (cuvMarginLeft.IsPercent() || cuvMarginRight.IsPercent())
        {
            xParentWidth = pNode->GetParentWidth(_pci, _pci->_sizeParent.cx);
        }
    }

    if (!fBOLWrapped)
    {
        long xMarginLeft = cuvMarginLeft.XGetPixelValue(_pci, cuvMarginLeft.IsPercent() ?  xParentWidth : _pci->_sizeParent.cx, lFontHeight);
        if (xMarginLeft > 0)
            prc->left += xMarginLeft;
    }

    if (!fEOLWrapped)
    {
        long xMarginRight = cuvMarginRight.XGetPixelValue(_pci, cuvMarginRight.IsPercent() ? xParentWidth : _pci->_sizeParent.cx, lFontHeight);
        if (xMarginRight > 0)
            prc->right -= xMarginRight;
    }
}

//-----------------------------------------------------------------------------
//
// Member:      FindMBPAboveNode
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::FindMBPAboveNode(CElement *pElement, LONG *plmbpTop, LONG *plmbpBottom)
{
    CTreeNode *pNode = pElement->GetFirstBranch();
    CTreeNode *pNodeStop = _pdp->GetFlowLayout()->GetFirstBranch();
    WHEN_DBG(CTreeNode *pNodeTemp = NULL;)
    const CCharFormat *pCF;

    Assert(plmbpTop && plmbpBottom);
    
    if (!pNode || SameScope(pNode, pNodeStop))
        goto Cleanup;

    // Gather the MBP info from my parent up.
    pNode = pNode->Parent();
    if (!pNode)
        goto Cleanup;

    *plmbpTop = *plmbpBottom = 0;
    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

    while(   pCF->_wSpecialObjectFlags()
          && !SameScope(pNode, pNodeStop)
         )
    {
        CRect rcDimensions;
        BOOL fIgnore;

        // Check if the current node has any MBP, and if so, does it start before
        // this line. If it does, then add it to the stack.
        if (   pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext()))
            && pNode->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore)
           )
        {
            *plmbpTop += rcDimensions.top;
            *plmbpBottom += rcDimensions.bottom;
        }

        WHEN_DBG(pNodeTemp = pNode;)
        pNode = pNode->Parent();
        if (!pNode)
        {
            Assert(   pNodeTemp->Element()->HasMasterPtr()
                   && pNodeTemp->Element()->GetMasterPtr() == pNodeStop->Element()
                  );
            break;
        }

        pCF = pNode->GetCharFormat();
    }

Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
// Member:      SetupMBPInfoInLS
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetupMBPInfoInLS(CDataAry<CTreeNode*> *paryNodes)
{
    CTreeNode *pNode = GetPtp()->GetBranch();
    CTreeNode *pNodeStop = _pdp->GetFlowLayout()->GetFirstBranch();
    LONG cpFirstOnLine = GetCp() - (_fMeasureFromTheStart ? 0 : _cchPreChars);
    BOOL fFirstNode = TRUE;
    BOOL fAdded;
    BOOL fStartsOnPreviousLine;
    WHEN_DBG(CTreeNode *pNodeTemp = NULL;)

    Assert(_pLS->_mbpTopCurrent == 0);
    Assert(_pLS->_mbpBottomCurrent == 0);

    const CCharFormat *pCF;
    COneRun* por = _pLS->_listCurrent._pHead;

    // por is used only if paryNodes is not NULL. That happens when this function
    // is called from DrawInlineBordersAndBg(), in which case the one run list
    // *is* intialized. Make sure that it is.
    Assert(   paryNodes == NULL
           || por != NULL
          );

    if (   pNode->ShouldHaveLayout()
        && !SameScope(pNode, pNodeStop)
       )
    {
        pNode = pNode->Parent();
        Assert(SameScope(pNode, pNodeStop) || !pNode->ShouldHaveLayout());
        fFirstNode = FALSE;
    }

    pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
    
    while(   pCF->_wSpecialObjectFlags()
          && !SameScope(pNode, pNodeStop)
         )
    {
        const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

        fAdded = FALSE;
        fStartsOnPreviousLine = FALSE;

        // If the element begins before this line, then it will influence the
        // extent of the line, since this element has MBP
        if (pNode->Element()->GetFirstCp() - 1 < cpFirstOnLine)
        {
            fStartsOnPreviousLine = TRUE;
            
            // Check if the current node has any MBP, and if so, does it start before
            // this line. If it does, then add it to the stack.
            if (pNode->HasInlineMBP(LC_TO_FC(_pci->GetLayoutContext())))
            {
                CRect rcDimensions;
                BOOL fIgnore;

                if (pNode->GetInlineMBPContributions(_pci, GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore))
                {
                    _pLS->_mbpTopCurrent += rcDimensions.top;
                    _pLS->_mbpBottomCurrent += rcDimensions.bottom;
                    _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_NOBLAST | FLAG_HAS_MBP);
                    if (   _pLS->HasBorders(pNode->GetFancyFormat(), pNode->GetCharFormat(), FALSE)
                        || pFF->HasBackgrounds(FALSE))
                    {
                        if (   paryNodes
                            && (   !por->_fCharsForNestedElement
                                || !fFirstNode))
                        {
                            paryNodes->AppendIndirect(&pNode);
                            fAdded = TRUE;
                        }
                        _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_INLINE_BG_OR_BORDER);
                    }
                }
            }
        }
        
        if (   !pFF->_fBlockNess
            && pFF->HasBackgrounds(FALSE))
        {
            _pLS->_lineFlags.AddLineFlag(_pLS->_cpStart, FLAG_HAS_NOBLAST | FLAG_HAS_INLINE_BG_OR_BORDER);
            if (   !fAdded
                && fStartsOnPreviousLine
                && paryNodes
                && (   !por->_fCharsForNestedElement
                    || !fFirstNode))
                paryNodes->AppendIndirect(&pNode);
        }

        WHEN_DBG(pNodeTemp = pNode;)
        pNode = pNode->Parent();
        if (!pNode)
        {
            Assert(pNodeTemp->Element()->HasMasterPtr() && pNodeTemp->Element()->GetMasterPtr() == pNodeStop->Element());
            break;
        }

        pCF = pNode->GetCharFormat();
        fFirstNode = FALSE;
    }
}

BOOL
CLSMeasurer::PseudoLineEnable(CTreeNode* pNodeBlock)
{
    BOOL fRet;
    CComputeFormatState * pcfState;
    Assert(pNodeBlock);
    Assert(!pNodeBlock->_fPseudoEnabled);
    Assert(pNodeBlock->GetFancyFormat()->_fHasFirstLine);
    CMarkup *pMarkup = pNodeBlock->GetMarkup();

    _fPseudoLineEnabled = TRUE;
    _fPseudoElementEnabled = TRUE;

    pcfState = pMarkup->EnsureCFState();
    if(pcfState)
    {
        pcfState->SetBlockNodeLine(pNodeBlock);
    }

    fRet = CopyStateFromTree(pNodeBlock, &_aryFormatStash_Line);
    _pLS->ClearFontCaches();
    return fRet;
}

void
CLSMeasurer::PseudoLineDisableCore()
{
    Assert(_fPseudoElementEnabled);
    if (_fPseudoLetterEnabled)
    {
        PseudoLetterDisable();
    }
    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pdp->GetMarkup();
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            pcfState->ResetLine();
            pMarkup->EnsureDeleteCFState(pcfState);
        }

        _fPseudoLineEnabled = FALSE;

        CopyStateToTree(&_aryFormatStash_Line, FALSE);
        _pLS->ClearFontCaches();
    }
    if (_aryFormatStashAfterDisable_Letter.Size())
        PseudoLetterFree();
    _fPseudoElementEnabled = FALSE;
}

BOOL
CLSMeasurer::CopyStateFromTree(CTreeNode *pNodeBlock, CAryFormatStash *paryFormatStash)
{
    CTreePos *ptp;
    CTreePos *ptpStop;
    CFormatStash fmStash;
    HRESULT hr;

    // Walk the scope of the block element and stash away the formatting info
    Assert(paryFormatStash->Size() == 0);
    pNodeBlock->Element()->GetTreeExtent(&ptp, &ptpStop);
    while (ptp != ptpStop)
    {
        if (ptp->IsBeginNode())
        {
            CTreeNode *pNode = ptp->Branch();
            fmStash._iPF = pNode->_iPF;
            fmStash._iCF = pNode->_iCF;
            fmStash._iFF = pNode->_iFF;
            fmStash._fBlockNess = pNode->_fBlockNess;
            fmStash._fShouldHaveLayout = pNode->_fShouldHaveLayout;
            fmStash._pNode = pNode;
            hr = THR(paryFormatStash->AppendIndirect(&fmStash));
            if (hr != S_OK)
                goto Cleanup;
            pNode->_iPF = -1;
            pNode->_iCF = -1;
            pNode->_iFF = -1;
            pNode->_fPseudoEnabled = TRUE;
        }
        ptp = ptp->NextTreePos();
    }
Cleanup:
    return TRUE;
}

void
CLSMeasurer::CopyStateToTree(CAryFormatStash *paryFormatStash, BOOL fPseudoEnabled)
{
    LONG index;
    THREADSTATE * pts = GetThreadState();
    CFormatStash *pfmStash;
    CTreeNode *pNode;
    
    // Walk the scope of the block element and resotre the stashed formatting info
    Assert(paryFormatStash->Size() != 0);
    for (index = 0; index < paryFormatStash->Size(); index++)
    {
        pfmStash = &(*paryFormatStash)[index];
        pNode = pfmStash->_pNode;
        
        Assert(pNode->_fPseudoEnabled != fPseudoEnabled);
        
        if (pNode->_iPF != -1)
            (pts->_pParaFormatCache)->ReleaseData( pNode->_iPF );
        if (pNode->_iCF != -1)
            (pts->_pCharFormatCache)->ReleaseData( pNode->_iCF );
        if (pNode->_iFF != -1)
            (pts->_pFancyFormatCache)->ReleaseData( pNode->_iFF );

        pNode->_iPF = pfmStash->_iPF;
        pNode->_iCF = pfmStash->_iCF;
        pNode->_iFF = pfmStash->_iFF;

        pNode->_fBlockNess = pfmStash->_fBlockNess;
        pNode->_fShouldHaveLayout = pfmStash->_fShouldHaveLayout;
        pNode->_fPseudoEnabled = fPseudoEnabled;
    }
    paryFormatStash->DeleteAll();
}

BOOL
CLSMeasurer::CopyStateFromSpline(CTreeNode *pNodeFrom, CTreeNode *pNodeTo)
{
    CFormatStash fmStash;
    CTreeNode *pNode;
    BOOL fRet = FALSE;
    HRESULT hr;
    
    pNode = pNodeFrom;
    pNodeTo = pNodeTo->Parent(); // I want pNodeTo to be included in the walk
    
    while (pNode != pNodeTo)
    {
        fmStash._iPF = pNode->_iPF;
        fmStash._iCF = pNode->_iCF;
        fmStash._iFF = pNode->_iFF;
        fmStash._fBlockNess = pNode->_fBlockNess;
        fmStash._fShouldHaveLayout = pNode->_fShouldHaveLayout;
        fmStash._pNode = pNode;
        hr = THR(_aryFormatStashForNested_Line.AppendIndirect(&fmStash));
        if (hr != S_OK)
            goto Cleanup;
        pNode->_iPF = -1;
        pNode->_iCF = -1;
        pNode->_iFF = -1;
        pNode->_fPseudoEnabled = FALSE;
        pNode = pNode->Parent();
    }
    fRet = TRUE;
    
Cleanup:
    return fRet;
}

BOOL
CLSMeasurer::PseudoLetterEnable(CTreeNode *pNodeBlock)
{
    Assert(pNodeBlock);
    // No format computation can occur between enabling of pseudo line
    // and enabling of letter.
    CMarkup *pMarkup = pNodeBlock->GetMarkup();
    CComputeFormatState * pcfState;
    BOOL fRet = TRUE;


    Assert(_cpStopFirstLetter >= 0);
    Assert(!_fPseudoLetterEnabled);
    _fPseudoLetterEnabled = TRUE;
    _fPseudoElementEnabled = TRUE;

    pcfState = pMarkup->EnsureCFState();
    if(pcfState)
    {
        pcfState->SetBlockNodeLetter(pNodeBlock);
    }

    if (!_fPseudoLineEnabled)
        fRet = CopyStateFromTree(pNodeBlock, &_aryFormatStash_Letter);
    _pLS->ClearFontCaches();
    Assert(!_fPseudoLineEnabled || pNodeBlock->_iCF == -1);
    return fRet;
}

BOOL
CLSMeasurer::PseudoLetterDisable()
{
    BOOL fRet = FALSE;
    LONG index;
    CFormatStash *pfmStash;
    CFormatStash fmStash;
    CTreeNode *pNode;
    HRESULT hr;
    
    if (_fPseudoLetterEnabled)
    {
        CMarkup * pMarkup = _pdp->GetMarkup();

        if (pMarkup->HasCFState() )
        {
            CComputeFormatState * pcfState = pMarkup->GetCFState();

            pcfState->ResetLetter();
            pMarkup->EnsureDeleteCFState( pcfState );
        }
        _fPseudoLetterEnabled = FALSE;
        _cpStopFirstLetter = -1;
        _pLS->ClearFontCaches();

        if (_fPseudoLineEnabled)
        {
            Assert(_aryFormatStash_Letter.Size() == 0);
            Assert(_aryFormatStash_Line.Size() != 0);
            for(index = 0; index < _aryFormatStash_Line.Size(); index++)
            {
                pfmStash = &_aryFormatStash_Line[index];
                pNode = pfmStash->_pNode;
                
                if (   pNode->_iPF != -1
                    || pNode->_iCF != -1
                    || pNode->_iFF != -1
                   )
                {
                    fmStash._iPF = pNode->_iPF;
                    fmStash._iCF = pNode->_iCF;
                    fmStash._iFF = pNode->_iFF;
                    // other stash values are not interesting.

                    hr = THR(_aryFormatStashAfterDisable_Letter.AppendIndirect(&fmStash));
                    if (hr != S_OK)
                        goto Cleanup;

                    // Invalidate the format caches so that they will be computed
                    // for the line-formats if necessary
                    pNode->_iPF = -1;
                    pNode->_iCF = -1;
                    pNode->_iFF = -1;
                }
                Assert(pNode->_fPseudoEnabled);
            }
        }
        else
        {
            Assert(_aryFormatStash_Letter.Size() != 0);
            Assert(_aryFormatStashAfterDisable_Letter.Size() == 0);
            for (index = 0; index < _aryFormatStash_Letter.Size(); index++)
            {
                pfmStash = &_aryFormatStash_Letter[index];
                pNode = pfmStash->_pNode;

                if (   pNode->_iPF != -1
                    || pNode->_iCF != -1
                    || pNode->_iFF != -1
                   )
                {
                    fmStash._iPF = pNode->_iPF;
                    fmStash._iCF = pNode->_iCF;
                    fmStash._iFF = pNode->_iFF;
                    fmStash._pNode = pNode;
                    // other stash values are not interesting.

                    hr = THR(_aryFormatStashAfterDisable_Letter.AppendIndirect(&fmStash));
                    if (hr != S_OK)
                        goto Cleanup;
                }

                pNode->_iPF = pfmStash->_iPF;
                pNode->_iCF = pfmStash->_iCF;
                pNode->_iFF = pfmStash->_iFF;

                pNode->_fBlockNess = pfmStash->_fBlockNess;
                pNode->_fShouldHaveLayout = pfmStash->_fShouldHaveLayout;
                pNode->_fPseudoEnabled = FALSE;
            }
            _aryFormatStash_Letter.DeleteAll();
        }
    }
    fRet = TRUE;
Cleanup:
    return fRet;
}

void
CLSMeasurer::PseudoLetterFree()
{
    CFormatStash *pfmStash;
    THREADSTATE * pts = GetThreadState();
    LONG index;
    
    for (index = 0; index < _aryFormatStashAfterDisable_Letter.Size(); index++)
    {
        pfmStash = &_aryFormatStashAfterDisable_Letter[index];
        if (pfmStash->_iPF != -1)
            (pts->_pParaFormatCache)->ReleaseData( pfmStash->_iPF );
        if (pfmStash->_iCF != -1)
            (pts->_pCharFormatCache)->ReleaseData( pfmStash->_iCF );
        if (pfmStash->_iFF != -1)
            (pts->_pFancyFormatCache)->ReleaseData( pfmStash->_iFF );
    }
    _aryFormatStashAfterDisable_Letter.DeleteAll();
}

LONG
CLSMeasurer::GetCpOfLastLetter(CTreeNode *pNodeBlock)
{
    CTreePos *ptp, *ptpStop;
    CTreeNode *pNode;
    CElement *pElement;
    BOOL fFoundText = FALSE;
    LONG cp;
    LONG ich = 0;
    
    pNodeBlock->Element()->GetTreeExtent(&ptp, &ptpStop);
    // Go past out begin splay
    ptp = ptp->NextTreePos();
    while (ptp != ptpStop)
    {
        if (ptp->IsBeginNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            
            if (pNode->IsDisplayNone())
            {
                GetNestedElementCch(pElement, &ptp);
            }
            else if (  pNode->ShouldHaveLayout()
                     ||(pElement->Tag() == ETAG_BR)
                     ||(    _pFlowLayout->IsElementBlockInContext(pElement)
                        &&  pElement->IsInlinedElement()
                       )
                    )
            {
                ich = 0;
                break;
            }
        }
        else if (ptp->IsText())
        {
            CTxtPtr tp(_pdp->GetMarkup(), ptp->GetCp());
            BOOL fTerminated = FALSE;
            
            ich = 0;
            while (ich < ptp->Cch())
            {
                TCHAR ch = tp.GetChar();

                fFoundText = TRUE;
                if (   ch != _T(' ')
                    && ch != _T('\'')
                    && ch != _T('"')
                    && ch != WCH_NBSP
                   )
                {
                    ich++;
                    fTerminated = TRUE;
                    break;
                }

                ich++;
                tp.AdvanceCp(1);
            }
            if (fTerminated)
                break;
        }
        ptp = ptp->NextTreePos();
    }

    cp = fFoundText ? (ptp->GetCp() + ich) : -1;
    return cp;
}

BOOL
CLSMeasurer::GetSiteWidth(CTreeNode *pNodeLayout,
                          CLayout   *pLayout,
                          CCalcInfo *pci,
                          BOOL       fBreakAtWord,
                          LONG       xWidthMax,
                          LONG      *pxWidth,
                          LONG      *pyHeight,
                          INT       *pxMinSiteWidth,
                          LONG      *pyBottomMargin)
{
    BOOL fRet;
    
    Assert(!_fPseudoLetterEnabled);
    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pLS->_pMarkup;
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            _cfStateSave = *pcfState;
            pcfState->ResetLine();
        }

        CopyStateFromSpline(pNodeLayout, _cfStateSave.GetBlockNodeLine());
    }

    fRet = _pFlowLayout->GetSiteWidth(pLayout, pci, fBreakAtWord, xWidthMax, pxWidth, pyHeight, pxMinSiteWidth, pyBottomMargin);

    if (_fPseudoLineEnabled)
    {
        CMarkup * pMarkup = _pLS->_pMarkup;
        CComputeFormatState * pcfState = pMarkup->GetCFState();

        if (pcfState)
        {
            *pcfState = _cfStateSave;
        }

        CopyStateToTree(&_aryFormatStashForNested_Line, TRUE);
    }

    return fRet;
}

void
CLSMeasurer::SetBreakLongLines(CTreeNode *pNode, UINT *puiFlags)
{
    const CParaFormat *pPF;
    if (   pNode->ShouldHaveLayout()
        && !SameScope(pNode, _pFlowLayout->ElementContent())
       )
    {
        pNode = pNode->Parent();
        if (pNode)
            pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
        else
            pPF = NULL;
    }
    else
    {
        pPF = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()));
    }
    
    *puiFlags &= ~MEASURE_BREAKLONGLINES;
    _fBreaklinesFromStyle = FALSE;
    if (pPF)
    {
        if (pPF->_fWordWrap == styleWordWrapNotSet)
        {
            if (   _pdp->GetWordWrap()
                && _pdp->GetWrapLongLines()
               )
            {
                _fBreaklinesFromStyle = FALSE;
                *puiFlags |= MEASURE_BREAKLONGLINES;
            }
        }
        else
        {
            if (pPF->_fWordWrap == styleWordWrapOn)
            {
                _fBreaklinesFromStyle = TRUE;
                *puiFlags |= MEASURE_BREAKLONGLINES;
            }
        }
    }
}

BOOL
CLSMeasurer::GetBreakLongLines(CTreeNode *pNode)
{
    UINT uiFlags = 0;
    SetBreakLongLines(pNode, &uiFlags);
    return uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE;
}

#if 0
BOOL
CLSMeasurer::SearchBranchForPseudoElement(CTreeNode  *pNodeStateHere,
                                          CTreeNode **ppBlockElement,
                                          CTreeNode **ppBlockLine,
                                          CTreeNode **ppBlockLetter
                                         )
{
    BOOL fRet = FALSE;
    const CParaFormat *pPF;
    const CFancyFormat *pFF;
    CBlockElement *pBlockElement = NULL;
    CBlockElement *pBlockLine = NULL;
    CBlockElement *pBlockLetter = NULL;
    
    for (pNode = pNodeStartHere ; ; pNode = pNode->Parent())
    {
        if (!pNode)
            return NULL;

        pPF = pNode->GetParaFormat();
        if (!pPF->_fHasPseudoElement)
            break;
        
        if (pNode->Element()->IsBlockElement())
        {
            fRet = TRUE;
            
            pFF = pNode->GetFancyFormat();

            if (!pBlockElement)
                pBlockElement = pNode;

            if (   pFF->_fHasFirstLine
                && !pBlockLine
               )
                pBlockLine = pNode;

            if (   pFF->_fHasFirstLetter
                && !pBlockLetter
               )
                pBlockLetter = pNode;
        }

        if (pNode->HasFlowLayout())
            return NULL;
    }
    if (fRet)
    {
        *ppBlockElement = pBlockElement;
        *ppBlockLine = pBlockLine;
        *ppBlockLetter = pBlockLetter;
    }
    return fRet;
}
#endif

#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsbreak.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSBREAK.CXX -- line services break callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/22/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_BRKCLS_H_
#define X_BRKCLS_H_
#include <brkcls.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagLSCallBack);

// The following tables depend on the fact that there is no more
// than a single alternate for each MWCLS and that at most one
// condition needs to be taken into account in resolving each MWCLS

// NB (cthrash) This is a packed table.  The first three elements (brkcls,
// brkclsAlt and brkopt) are indexed by CHAR_CLASS.  The fourth column we
// access (brkclsLow) we access by char value.  The fourth column is for a
// speed optimization.

#if defined(UNIX) || (defined(_MSC_VER) && (_MSC_VER >= 1200))
// Unix and Newer MS compilers can't use DWORD to initialize enum type BRKCLS.
#define BRKINFO(a,b,c,d) { CLineServices::a, CLineServices::b, CLineServices::c, CLineServices::d }
#else
#define BRKINFO(a,b,c,d) { DWORD(CLineServices::a), DWORD(CLineServices::b), DWORD(CLineServices::c), DWORD(CLineServices::d) }
#endif

const CLineServices::PACKEDBRKINFO CLineServices::s_rgBrkInfo[CHAR_CLASS_MAX] =
{
    //       brkcls             brkclsAlt         brkopt     brkclsLow                    QPID ( CC)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOB_   1 (  0)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPP   2 (  1)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPA   2 (  2)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOPW   2 (  3)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // HOP_   3 (  4)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOP_   4 (  5)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOP5   5 (  6)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOQW   6 (  7)
    BRKINFO( brkclsQuote,       brkclsOpen,       fCscWide,  brkclsAlpha        ), // AOQW   7 (  8)
    BRKINFO( brkclsOpen,        brkclsNil,        fBrkNone,  brkclsSpaceN       ), // WOQ_   8 (  9)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // WCB_   9 ( 10)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCPP  10 ( 11)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NCPA  10 ( 12)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NCPW  10 ( 13)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // HCP_  11 ( 14)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCP_  12 ( 15)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCP5  13 ( 16)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCQW  14 ( 17)
    BRKINFO( brkclsQuote,       brkclsClose,      fCscWide,  brkclsAlpha        ), // ACQW  15 ( 18)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCQ_  16 ( 19)
    BRKINFO( brkclsQuote,       brkclsClose,      fCscWide,  brkclsAlpha        ), // ARQW  17 ( 20)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCSA  18 ( 21)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // HCO_  19 ( 22)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC__  20 ( 23)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCS_  20 ( 24)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC5_  21 ( 25)
    BRKINFO( brkclsClose,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // WC5S  21 ( 26)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKS_  22 ( 27)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKSM  23 ( 28)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WIM_  24 ( 29)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSSW  25 ( 30)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WSS_  26 ( 31)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAsciiSpace   ), // WHIM  27 ( 32)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsExclaInterr  ), // WKIM  28 ( 33)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsQuote        ), // NKSL  29 ( 34)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsAlpha        ), // WKS_  30 ( 35)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsPrefix       ), // WKSC  30 ( 36)
    BRKINFO( brkclsIdeographic, brkclsNoStartIdeo,fBrkStrict,brkclsPostfix      ), // WHS_  31 ( 37)
    BRKINFO( brkclsExclaInterr, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQFP  32 ( 38)
    BRKINFO( brkclsExclaInterr, brkclsNil,        fBrkNone,  brkclsQuote        ), // NQFA  32 ( 39)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsOpen         ), // WQE_  33 ( 40)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsClose        ), // WQE5  34 ( 41)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKCC  35 ( 42)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKC_  36 ( 43)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NOCP  37 ( 44)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsSpaceN       ), // NOCA  37 ( 45)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NOCW  37 ( 46)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsSlash        ), // WOC_  38 ( 47)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOCS  38 ( 48)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOC5  39 ( 49)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WOC6  39 ( 50)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // AHPW  40 ( 51)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumeral      ), // NPEP  41 ( 52)
    BRKINFO( brkclsNumSeparator,brkclsNil,        fBrkNone,  brkclsNumeral      ), // NPAR  41 ( 53)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // HPE_  42 ( 54)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPE_  43 ( 55)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPES  43 ( 56)
    BRKINFO( brkclsNoStartIdeo, brkclsNil,        fBrkNone,  brkclsNumeral      ), // WPE5  44 ( 57)
    BRKINFO( brkclsInseparable, brkclsNil,        fBrkNone,  brkclsNumSeparator ), // NISW  45 ( 58)
    BRKINFO( brkclsInseparable, brkclsNil,        fBrkNone,  brkclsNumSeparator ), // AISW  46 ( 59)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCS  47 ( 60)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCW  47 ( 61)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQCC  47 ( 62)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsExclaInterr  ), // NPTA  48 ( 63)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPNA  48 ( 64)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEW  48 ( 65)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEH  48 ( 66)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPEV  48 ( 67)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // APNW  49 ( 68)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // HPEW  50 ( 69)
    BRKINFO( brkclsPrefix,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // WPR_  51 ( 70)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQEP  52 ( 71)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQEW  52 ( 72)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQNW  52 ( 73)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQEW  53 ( 74)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQNW  53 ( 75)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // AQLW  53 ( 76)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // WQO_  54 ( 77)
    BRKINFO( brkclsAsciiSpace,  brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBL  55 ( 78)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WSP_  56 ( 79)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WHI_  57 ( 80)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NKA_  58 ( 81)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WKA_  59 ( 82)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASNW  60 ( 83)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASEW  60 ( 84)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASRN  60 ( 85)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ASEN  60 ( 86)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALA_  61 ( 87)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // AGR_  62 ( 88)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ACY_  63 ( 89)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WID_  64 ( 90)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsOpen         ), // WPUA  65 ( 91)
    BRKINFO( brkclsHangul,      brkclsNil,        fBrkNone,  brkclsPrefix       ), // NHG_  66 ( 92)
    BRKINFO( brkclsHangul,      brkclsNil,        fBrkNone,  brkclsClose        ), // WHG_  67 ( 93)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WCI_  68 ( 94)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // NOI_  69 ( 95)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOI_  70 ( 96)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIC  70 ( 97)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIL  70 ( 98)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIS  70 ( 99)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WOIT  70 (100)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSEN  71 (101)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSET  71 (102)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSNW  71 (103)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASAN  72 (104)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASAE  72 (105)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NDEA  73 (106)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WD__  74 (107)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLLA  75 (108)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsAlpha        ), // WLA_  76 (109)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NWBL  77 (110)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NWZW  77 (111)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPLW  78 (112)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPZW  78 (113)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPF_  78 (114)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPFL  78 (115)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NPNW  78 (116)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // APLW  79 (117)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // APCO  79 (118)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // ASYW  80 (119)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHYP  81 (120)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHYW  81 (121)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // AHYW  82 (122)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsOpen         ), // NAPA  83 (123)
    BRKINFO( brkclsQuote,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NQMP  84 (124)
    BRKINFO( brkclsSlash,       brkclsNil,        fBrkNone,  brkclsClose        ), // NSLS  85 (125)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSF_  86 (126)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBS  86 (127)
    BRKINFO( brkclsSpaceN,      brkclsNil,        fBrkNone,  brkclsAlpha        ), // NSBB  86 (128)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLA_  87 (129)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQ_  88 (130)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQN  88 (131)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NLQC  88 (132)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALQ_  89 (133)
    BRKINFO( brkclsAlpha,       brkclsIdeographic,fCscWide,  brkclsAlpha        ), // ALQN  89 (134)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGR_  90 (135)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGRN  90 (136)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGQ_  91 (137)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NGQN  91 (138)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCY_  92 (139)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCYP  93 (140)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NCYC  93 (141)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAR_  94 (142)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAQL  95 (143)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAQN  95 (144)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHB_  96 (145)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBC  96 (146)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBW  96 (147)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHBR  96 (148)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NASR  97 (149)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAR  97 (150)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAC  97 (151)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAD  97 (152)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAED  97 (153)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NANW  97 (154)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAEW  97 (155)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NAAS  97 (156)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHI_  98 (157)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHIN  98 (158)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsAlpha        ), // NHIC  98 (159)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsGlueA        ), // NHID  98 (160)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBE_  99 (161)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NBEC  99 (162)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NBED  99 (163)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBET  99 (164)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGM_ 100 (165)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NGMC 100 (166)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NGMD 100 (167)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGJ_ 101 (168)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NGJC 101 (169)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NGJD 101 (170)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOR_ 102 (171)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NORC 102 (172)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NORD 102 (173)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTA_ 103 (174)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTAC 103 (175)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTAD 103 (176)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTE_ 104 (177)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTEC 104 (178)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTED 104 (179)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKD_ 105 (180)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NKDC 105 (181)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NKDD 105 (182)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMA_ 106 (183)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NMAC 106 (184)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NMAD 106 (185)
    BRKINFO( brkclsThaiFirst,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTH_ 107 (186)
    BRKINFO( brkclsThaiFirst,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTHC 107 (187)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTHD 107 (188)
    BRKINFO( brkclsPostfix,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTHT 107 (189)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NLO_ 108 (190)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NLOC 108 (191)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NLOD 108 (192)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTI_ 109 (193)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTIC 109 (194)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NTID 109 (195)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTIN 109 (196)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGE_ 110 (197)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NGEQ 111 (198)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBO_ 112 (199)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBSP 113 (200)
    BRKINFO( brkclsGlueA,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBSS 113 (201)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOF_ 114 (202)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOBS 114 (203)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEA 114 (204)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONA 114 (205)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONP 114 (206)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEP 114 (207)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NONW 114 (208)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEW 114 (209)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOLW 114 (210)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NOCO 114 (211)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOSP 114 (212)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOEN 114 (213)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOBN 114 (214)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NET_ 115 (215)
    BRKINFO( brkclsSpecialPunct,brkclsNil,        fBrkNone,  brkclsNil          ), // NETP 115 (216)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NETD 115 (217)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NCA_ 116 (218)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NCH_ 117 (219)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WYI_ 118 (220)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WYIN 118 (221)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBR_ 119 (222)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NRU_ 120 (223)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOG_ 121 (224)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOGS 121 (225)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NOGN 121 (226)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSI_ 122 (227)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NSIC 122 (228)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NTN_ 123 (229)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NTNC 123 (230)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKH_ 124 (231)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NKHC 124 (232)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NKHD 124 (233)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NKHT 124 (234)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NBU_ 125 (235)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NBUC 125 (236)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NBUD 125 (237)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSY_ 126 (238)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSYP 126 (239)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NSYC 126 (240)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NSYW 126 (241)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMO_ 127 (242)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // NMOC 127 (243)
    BRKINFO( brkclsNumeral,     brkclsNil,        fBrkNone,  brkclsNil          ), // NMOD 127 (244)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMOB 127 (245)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NMON 127 (246)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // NHS_ 128 (247)
    BRKINFO( brkclsIdeographic, brkclsNil,        fBrkNone,  brkclsNil          ), // WHT_ 129 (248)
    BRKINFO( brkclsCombining,   brkclsNil,        fBrkNone,  brkclsNil          ), // LS__ 130 (249)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          ), // XNW_ 131 (250)
    BRKINFO( brkclsAlpha,       brkclsNil,        fBrkNone,  brkclsNil          )  // XNWA 131 (251)
};

// Break pair information for normal or strict Kinsoku
const BYTE s_rgbrkpairsKinsoku[CLineServices::brkclsLim][CLineServices::brkclsLim] =
{
//1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25    = brclsAfter
                                                                                                    //  brkclsBefore:
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  1,  1,  1,  0, //   1 brkclsOpen    
  0,  1,  1,  1,  0,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   2 brkclsClose   
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   3 brkclsNoStartIdeo
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   4 brkclsExclamInt
  0,  1,  2,  1,  2,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   5 brkclsInseparable
  2,  1,  2,  1,  0,  2,  0,  2,  2,  0,  3,  2,  1,  2,  1,  2,  2,  0,  0,  2,  1,  1,  1,  1,  0, //   6 brkclsPrefix  
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   7 brkclsPostfix 
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   8 brkclsIdeoW   
  0,  1,  2,  1,  2,  0,  2,  0,  3,  0,  3,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //   9 brkclsNumeral 
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  10 brkclsSpaceN  
  0,  1,  2,  1,  2,  2,  2,  4,  3,  0,  3,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  11 brkclsAlpha   
  2,  1,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  1,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  12 brkclsGlueA   
  0,  1,  2,  1,  2,  0,  2,  0,  2,  0,  3,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  13 brkclsSlash   
  1,  1,  2,  1,  2,  2,  3,  2,  2,  2,  2,  2,  1,  2,  1,  2,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  14 brkclsQuotation
  0,  1,  2,  1,  0,  2,  2,  0,  2,  0,  3,  2,  1,  2,  2,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  15 brkclsNumSeparator
  0,  1,  2,  1,  2,  0,  2,  4,  0,  0,  4,  2,  1,  2,  1,  4,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  16 brkclsHangul  
  0,  1,  2,  1,  2,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  4,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  17 brkclsThaiFirst
  0,  1,  2,  1,  2,  0,  2,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  2,  2,  2,  1,  1,  1,  1,  0, //  18 brkclsThaiLast
  0,  1,  2,  1,  2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  1,  0,  2,  2,  2,  2,  1,  1,  1,  1,  0, //  19 brkclsThaiAlpha
  0,  1,  2,  1,  2,  2,  2,  4,  3,  0,  3,  2,  1,  2,  1,  4,  0,  0,  0,  1,  1,  1,  1,  1,  0, //  20 brkclsCombining
  0,  1,  2,  1,  0,  0,  0,  0,  0,  0,  0,  2,  1,  2,  1,  0,  0,  0,  0,  2,  1,  1,  1,  1,  0, //  21 brkclsAsiiSpace
  0,  1,  2,  1,  0,  2,  2,  0,  2,  0,  0,  2,  1,  2,  2,  0,  0,  0,  0,  2,  1,  2,  1,  1,  0, //  22 brkclsSpecialPunct
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0, //  23 brkclsMBPOpen
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0, //  24 brkclsMBPClose
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, //  25 brkclsWBR
};

inline CLineServices::BRKCLS
QuickBrkclsFromCh(WCHAR ch)
{
    Assert(ch);  // This won't work for ch==0.
    Assert( CanQuickBrkclsLookup(ch) );
    return (CLineServices::BRKCLS)CLineServices::s_rgBrkInfo[ch].brkclsLow;
}

inline
CLineServices::BRKCLS
BrkclsFromCh(WCHAR ch, DWORD brkopt)
{
    Assert( !CanQuickBrkclsLookup(ch) ); // Should take another code path.

    CHAR_CLASS cc = CharClassFromCh(ch);
    Assert(cc < CHAR_CLASS_MAX);

    const CLineServices::PACKEDBRKINFO * p = CLineServices::s_rgBrkInfo + cc;

    return CLineServices::BRKCLS((p->brkopt & brkopt) ? p->brkclsAlt : p->brkcls);
}

// Line breaking behaviors

// Standard Breaking Behaviors retaining normal line break for non-FE text
static const LSBRK s_rglsbrkNormal[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 0,1,  // only allowed across space (word wrap case)
    /* 4*/ 1,1,  // always allowed (no CJK/Hangul word wrap case)
};

// Breaking Behaviors allowing FE style breaking in the middle of words (any language)
static const LSBRK s_rglsbrkBreakAll[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 1,1,  // always allowed (no word wrap case)
    /* 4*/ 1,1,  // always allowed (no CJK/Hangul word wrap case)
};

// Breaking Behaviors allowing Hangul style breaking 
static const LSBRK s_rglsbrkKeepAll[] = 
{
    /* 0*/ 1,1,  // always allowed
    /* 1*/ 0,0,  // always prohibited
    /* 2*/ 0,1,  // only allowed across space
    /* 3*/ 0,1,  // only allowed across space (word wrap case)
    /* 4*/ 0,1,  // only allowed across space (CJK/Hangul word wrap case)
};

const struct lsbrk * const alsbrkTables[4] =
{                                                           
    s_rglsbrkNormal,
    s_rglsbrkNormal,
    s_rglsbrkBreakAll,
    s_rglsbrkKeepAll
};

LSERR
CLineServices::CheckSetBreaking()
{
    const struct lsbrk * lsbrkCurr = alsbrkTables[_pPFFirst->_fWordBreak];

    HRESULT hr;

    //
    // Are we in need of calling LsSetBreaking?
    //

    if (lsbrkCurr == _lsbrkCurr)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRFromLSERR( LsSetBreaking( _plsc,
                                         sizeof( s_rglsbrkNormal ) / sizeof( LSBRK ),
                                         lsbrkCurr,
                                         brkclsLim,
                                         (const BYTE *)s_rgbrkpairsKinsoku ) );

        _lsbrkCurr = (struct lsbrk *)lsbrkCurr;
    }

    RRETURN(hr);
}


#ifdef _MAC
void ReverseByteSex(DWORD* pdw);
void ReverseByteSex(DWORD* pdw)
{
    DWORD In = (*pdw);
    BYTE* pIn = (BYTE*) &In;
    BYTE* pOut = ((BYTE*) pdw) + 3;
    
    for ( short i = 0; i < 4; i++, pIn++, pOut-- )
        (*pOut) = (*pIn);
}

void ClearDWORD(DWORD* pdw);
void ClearDWORD(DWORD* pdw)
{
    (*pdw) = 0;
}

#endif


LSERR WINAPI
CLineServices::GetBreakingClasses(
    PLSRUN plsrun,          // IN
    LSCP lscp,              // IN
    WCHAR wch,              // IN
    BRKCLS* pbrkclsFirst,    // OUT
    BRKCLS* pbrkclsSecond)  // OUT
{
    LSTRACE(GetBreakingClasses);
    LSERR lserr = lserrNone;

#ifdef _MAC
    ClearDWORD((DWORD*) pbrkclsFirst);
    ClearDWORD((DWORD*) pbrkclsSecond);
#endif

#if 0
    if (plsrun->GetCF()->_bCharSet == SYMBOL_CHARSET)
    {
        *pbrkclsFirst = *pbrkclsSecond = brkclsAlpha;
    }
    else
#endif
    if (CanQuickBrkclsLookup(wch))
    {
        // prefer ASCII (true block) for performance
        Assert( HasWhiteBetweenWords(wch) );
        *pbrkclsFirst = *pbrkclsSecond = QuickBrkclsFromCh(wch);
    }
    else if(plsrun->IsSpecialCharRun())
    {
        if (plsrun->IsMBPRun())
        {
            GetMBPBreakingClasses(plsrun, pbrkclsFirst, pbrkclsSecond);
        }
        else
        {
            Assert(plsrun->_synthType == SYNTHTYPE_WBR);
            *pbrkclsFirst = *pbrkclsSecond = brkclsWBR;
        }
    }
    else if(HasWhiteBetweenWords(wch))  
    {
        *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
    }
    else
    {
        switch(CharClassFromCh(wch))
        {
        // numbers and Baht sign need to be given correct break class
        case NTHT:  // Thai Baht
        case NTHD:  // Thai digits
        case NLOD:  // Lao digits
        case NKHD:  // Khmer digits
        case NBUD:  // Burmese/Myanmar digits
            *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
            break;
        // rest needs to be handled as no space language text.
        default:
            {
                
                CComplexRun * pcr = plsrun->GetComplexRun();

                if (pcr != NULL)
                {
                    LONG cp = CPFromLSCP(lscp);

#if DBG==1
                    // Assertion to make sure that someone has not changed the 
                    // s_aPropBitsFromCharClass[] table
                    CHAR_CLASS cclass = CharClassFromCh(wch);
                    Assert(   cclass == NTH_
                           || cclass == NTHC
                           || cclass == NLO_
                           || cclass == NLOC
                           || cclass == NKH_
                           || cclass == NKHC
                           || cclass == NBU_
                           || cclass == NBUC);

                    Assert(LSCPFromCP(cp) == lscp);
#endif // DBG

                    pcr->NoSpaceLangBrkcls(_pMarkup, _cpStart, cp, (::BRKCLS*)pbrkclsFirst, (::BRKCLS*)pbrkclsSecond);
                }
                else
                {
                    // BUGFIX 14717 (a-pauln)
                    // A complex run has not been created so pass this through the normal
                    // Kinsoku classes for clean failure.
                    *pbrkclsFirst = *pbrkclsSecond = BrkclsFromCh(wch, plsrun->_brkopt);
                }
            }
            break;
        }
    }

#ifdef _MAC
    ReverseByteSex((DWORD*) pbrkclsFirst);
    ReverseByteSex((DWORD*) pbrkclsSecond);
#endif

    return lserr;
}

// NB (cthrash) This table came from Quill.

const BRKCOND CLineServices::s_rgbrkcondBeforeChar[brkclsLim] =
{
    brkcondPlease,  // brkclsOpen
    brkcondNever,   // brkclsClose
    brkcondNever,   // brkclsNoStartIdeo
    brkcondNever,   // brkclsExclaInterr
    brkcondCan,     // brkclsInseparable
    brkcondCan,     // brkclsPrefix
    brkcondCan,     // brkclsPostfix
    brkcondPlease,  // brkclsIdeographic
    brkcondCan,     // brkclsNumeral
    brkcondCan,     // brkclsSpaceN
    brkcondCan,     // brkclsAlpha
    brkcondCan,     // brkclsGlueA
    brkcondPlease,  // brkclsSlash
    brkcondCan,     // brkclsQuote
    brkcondCan,     // brkclsNumSeparator
    brkcondCan,     // brkclsHangul
    brkcondCan,     // brkclsThaiFirst
    brkcondNever,   // brkclsThaiLast
    brkcondNever,   // brkclsThaiMiddle
    brkcondCan,     // brkclsCombining
    brkcondCan,     // brkclsAsciiSpace
    brkcondPlease,  // brkclsMBPOpen
    brkcondNever,   // brkclsMBPClose
    brkcondPlease,  // brkclsWBR
};

LSERR WINAPI
CLineServices::CanBreakBeforeChar(
    BRKCLS brkcls,          // IN
    BRKCOND* pbrktxtBefore) // OUT
{
    LSTRACE(CanBreakBeforeChar);

    Assert( brkcls >= 0 && brkcls < brkclsLim );

    *pbrktxtBefore = s_rgbrkcondBeforeChar[ brkcls ];

    return lserrNone;
}

const BRKCOND CLineServices::s_rgbrkcondAfterChar[brkclsLim] =
{
    brkcondPlease,  // brkclsOpen
    brkcondCan,     // brkclsClose
    brkcondCan,     // brkclsNoStartIdeo
    brkcondCan,     // brkclsExclaInterr
    brkcondCan,     // brkclsInseparable
    brkcondCan,     // brkclsPrefix
    brkcondCan,     // brkclsPostfix
    brkcondPlease,  // brkclsIdeographic
    brkcondCan,     // brkclsNumeral
    brkcondCan,     // brkclsSpaceN
    brkcondCan,     // brkclsAlpha
    brkcondNever,   // brkclsGlueA
    brkcondPlease,  // brkclsSlash
    brkcondCan,     // brkclsQuote
    brkcondCan,     // brkclsNumSeparator
    brkcondCan,     // brkclsHangul
    brkcondNever,   // brkclsThaiFirst
    brkcondCan,     // brkclsThaiLast
    brkcondNever,   // brkclsThaiAlpha
    brkcondCan,     // brkclsCombining
    brkcondCan,     // brkclsAsciiSpace
    brkcondNever,   // brkclsMBPOpen
    brkcondPlease,  // brkclsMBPClose
    brkcondPlease,  // brkclsWBR
};

LSERR WINAPI
CLineServices::CanBreakAfterChar(
    BRKCLS brkcls,          // IN
    BRKCOND* pbrktxtAfter)  // OUT
{
    LSTRACE(CanBreakAfterChar);

    Assert( brkcls >= 0 && brkcls < brkclsLim );

    *pbrktxtAfter = s_rgbrkcondAfterChar[ brkcls ];

    return lserrNone;
}

void
CLineServices::GetMBPBreakingClasses(PLSRUN plsrun, BRKCLS *pbrkclsFirst, BRKCLS *pbrkclsSecond)
{
    COneRun *por;
    BRKCLS dummy;

    if (plsrun->_synthType == SYNTHTYPE_MBPOPEN)
    {
        *pbrkclsFirst = brkclsMBPOpen; /* After */
        
        *pbrkclsSecond = brkclsOpen;
        por = plsrun->_pNext;
        while(por)
        {
            if (   por->IsNormalRun()
                && por->_synthType == SYNTHTYPE_NONE
               )
            {
                if (por->_pchBase)
                {
                    GetBreakingClasses(por, por->_lscpBase, por->_pchBase[0], &dummy, pbrkclsSecond);
                }
                // Presently, if a border starts before an embedded object
                // we will just break between the border and whatever (say X) is
                // there before it, even if there was not a break opportunity
                // between X and the object.
                break;
            }
            por = por->_pNext;
        }
    }
    else
    {
        Assert(plsrun->_synthType == SYNTHTYPE_MBPCLOSE);
        *pbrkclsSecond = brkclsMBPClose; /* before */
        
        *pbrkclsFirst = brkclsClose;
        por = plsrun->_pPrev;
        while(por)
        {
            if (   por->IsNormalRun()
                && por->_synthType == SYNTHTYPE_NONE
               )
            {
                if (por->_pchBase)
                {
                    GetBreakingClasses(por, por->_lscpBase+por->_lscch-1, por->_pchBase[por->_lscch-1], pbrkclsFirst, &dummy);
                }
                // Presently, if a border starts before an embedded object
                // we will just break between the border and whatever (say X) is
                // there before it, even if there was not a break opportunity
                // between X and the object.
                break;
            }
            por = por->_pPrev;
        }
    }
}

#if DBG==1
const char * s_achBrkCls[] =  // Note brkclsNil is -1
{
    "brkclsNil",
    "brkclsOpen",
    "brkclsClose",
    "brkclsNoStartIdeo",
    "brkclsExclaInterr",
    "brkclsInseparable",
    "brkclsPrefix",
    "brkclsPostfix",
    "brkclsIdeographic",
    "brkclsNumeral",
    "brkclsSpaceN",
    "brkclsAlpha",
    "brkclsGlueA",
    "brkclsSlash",
    "brkclsQuote",
    "brkclsNumSeparator",
    "brkclsHangul",
    "brkclsThaiFirst",
    "brkclsThaiLast",
    "brkclsThaiMiddle",
    "brkclsCombining",
    "brkclsAsciiSpace",
    "brkclsMBPOpen",
    "brkclsMBPClose",
};

const char *
CLineServices::BrkclsNameFromCh(TCHAR ch, BOOL fStrict)
{
    BRKCLS brkcls = CanQuickBrkclsLookup(ch) ? QuickBrkclsFromCh(ch) : BrkclsFromCh(ch, fStrict);

    return s_achBrkCls[int(brkcls)+1];    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lscache.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCACHE.CXX -- CLSCache and related classes implementation
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      1/26/98     sujalp created
 *
 *  Note:
 *      The LS cache is a cache of CLineServices objects. We use one
 *      such object per line calculation and then return it to this
 *      cache. It can then be used for subsequent line computations.
 *      More than one such object will be in use only when we have
 *      nested flow layouts (like table cells).
 *  
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include <lscache.hxx>
#endif

MtDefine(CAryLSCache_aryLSCacheEntry_pv, LineServices, "CLSCache::CLSEntry allocation")
MtDefine(THREADSTATE_pLSCache, THREADSTATE, "THREADSTATE::_pLSCache")

//+----------------------------------------------------------------------------
//
//  Function:   InitLSCache
//
//  Synopsis:   Allocate the LS context cache
//
//  Arguments:  pts - THREADSTATE for current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitLSCache(THREADSTATE *pts)
{
    Assert(pts);
    pts->_pLSCache = new (Mt(THREADSTATE_pLSCache)) CLSCache;
    if (!pts->_pLSCache)
        RRETURN(E_OUTOFMEMORY);
    RRETURN(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitLSCache
//
//  Synopsis:   Delete the LS context cache
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void DeinitLSCache(THREADSTATE *pts)
{
    Assert(pts);

#if DBG==1
    if (pts->_pLSCache)
    {
        pts->_pLSCache->VerifyNoneUsed();
    }
#endif

    delete pts->_pLSCache;
}

//-------------------------------------------------------------------------
//
// Member:   GetFreeEntry
//
// Synopsis: Finds a free entry inside LS cache. If one does not exist, creates
//           a new and adds it to the LS cache.
//           called internally by the constructors.
//
// Params:   None.
//
// Retruns:  A CLineServices object.
//
//-------------------------------------------------------------------------

CLineServices *
CLSCache::GetFreeEntry(CMarkup *pMarkup, BOOL fStartUpLSDLL)
{
    CLSCacheEntry *pLSEntry;
    CLSCacheEntry  LSEntry;
    CLineServices *pLS = NULL;
    HRESULT        hr = S_OK;
    LONG           i;
    
    for (i = _aLSEntries.Size() - 1; i >= 0; i--)
    {
        pLSEntry = &_aLSEntries[i];
        if (!pLSEntry->_fUsed)
        {
            pLS = pLSEntry->_pLS;

            // If the LS context has not been intialized and initialization
            // has been requested, then start it up.
            if (fStartUpLSDLL)
            {
                hr = THR(StartUpLSDLL(pLS, pMarkup));
                if (hr)
                {
                    pLS = NULL;
                    goto Error;
                }
                Assert(pLS->_plsc);
            }
            else
            {
                if (pMarkup != pLS->GetMarkup())
                    pLS->_treeInfo._tpFrontier.Reinit(pMarkup, 0);
            }
            
            pLSEntry->_fUsed = TRUE;
            goto Cleanup;
        }
    }

    hr = THR(InitLineServices(pMarkup, fStartUpLSDLL, &LSEntry._pLS));
    if (hr)
        goto Cleanup;

    LSEntry._fUsed = TRUE;

    hr = THR(_aLSEntries.AppendIndirect(&LSEntry));
    if (hr)
        goto Cleanup;

    pLS = LSEntry._pLS;
    
Cleanup:
    if (pLS)
    {
        Assert(!fStartUpLSDLL || pLS->_plsc);
        _cUsed++;
    }

Error:    
    return pLS;
}

//-------------------------------------------------------------------------
//
// Member:   ReleaseEntry
//
// Synopsis: Releases an entry which was retrieved via GetFreeEntry(). It
//           puts this CLineServices object back into the cache for it to
//           be used by subsequent GetFreeEntry() calls.
//
// Params:   [pLS]: The entry to be released.
//
// Retruns:  None.
//
//-------------------------------------------------------------------------

void
CLSCache::ReleaseEntry(CLineServices *pLS)
{
    CLSCacheEntry *pLSEntry;
    LONG           i;

    Assert(pLS);
    for (i = 0; i < _aLSEntries.Size(); i++)
    {
        pLSEntry = &_aLSEntries[i];
        if (pLSEntry->_pLS == pLS)
        {
            Assert(pLSEntry->_fUsed == TRUE);
            pLSEntry->_fUsed = FALSE;
            goto Cleanup;
        }
    }

    AssertSz(0, "Invalid cache entry passed to release");
    
Cleanup:
    _cUsed--;
    if (!_cUsed)
    {
        Dispose(FALSE);
    }
    return;
}

//-------------------------------------------------------------------------
//
// Member:   Dispose
//
// Synopsis: Appropriately destroys the complete cache of entries.
//
// Params:   fDiposeAll - Dispose all the entries.
//
// Retruns:  None.
//
//-------------------------------------------------------------------------
void
CLSCache::Dispose(BOOL fDisposeAll)
{
    CLSCacheEntry *pLSEntry;
    LONG i;

    //
    // Find the number of entries to free from the cache.
    //
    LONG nUnusedEntriesNeedToFree = _aLSEntries.Size() - (fDisposeAll ? 0 : N_CACHE_MINSIZE);

    //
    // Do we need to free any entries?
    //
    if (nUnusedEntriesNeedToFree > 0)
    {
        //
        // Run thru the array finding free entries and disposing them till we
        // have disposed as many unused entries as we needed to.
        //
        for(i = _aLSEntries.Size() - 1; i >= 0; i--)
        {
            Assert(nUnusedEntriesNeedToFree > 0);
            pLSEntry = &_aLSEntries[i];
            if (!pLSEntry->_fUsed)
            {
                Assert(pLSEntry->_pLS);
                DeinitLineServices(pLSEntry->_pLS);
                _aLSEntries.Delete(i);
                if (--nUnusedEntriesNeedToFree == 0)
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lscomplx.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSCOMPLX.CXX -- line services complex script support
 *
 *
 *  Owner: <nl>
 *      Michael Jochimsen <nl>
 *
 *  History: <nl>
 *      04/02/98     mikejoch created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include <txtdefs.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

MtDefine(CAryDirRun_pv, LineServices, "CAryDirRun::_pv");
MtDefine(CComplexRun, LineServices, "CComplexRun");
MtDefine(CBidiLine, LineServices, "CBidiLine");
MtDefine(CComplexRunComputeAnalysis_aryAnalysis_pv, Locals, "CComplexRun::ComputeAnalysis::aryAnalysis_pv");
MtDefine(CComplexRunNoSpaceLangBrkcls_aryItemize_pv, Locals, "CComplexRun::NoSpaceLangBrkcls::aryItemize::_pv");
MtDefine(CComplexRunNoSpaceLangBrkcls_aryItems_pv, Locals, "CComplexRun::NoSpaceLangBrkcls::aryItems::_pv");

#define DEFAULT_CHARS_TO_EVALUATE ((LONG) 100)

extern LCID g_lcidLocalUserDefault;

extern CGlobalCriticalSection g_csJitting;
extern BYTE g_bUSPJitState;

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::CBidiLine
//
//  Synopsis:   Create a complex line. This essentially consists of
//              grabbing copies of the properties that describe the line's
//              place in the backing store, initializing the bidi stack and
//              algorithm state, and priming the DIR_RUN array. If we know the
//              length of the line already the we also go ahead and run the
//              bidi algorithm for the text in the line.
//
//-----------------------------------------------------------------------------
CBidiLine::CBidiLine(
    const CTreeInfo & treeinfo,
    LONG cp,
    BOOL fRTLPara,
    const CLineFull * pli) :
        _txtptr(treeinfo._pMarkup, cp)
{
#ifdef NO_IMPLICIT_BIDI
    DIR_RUN dr;

    dr.cp = cp;
    dr.iLevel = fRTLPara;
    _aryDirRun.AppendIndirect(&dr);
#else
    const CCharFormat * pCF = NULL;
    CTreeNode * ptn;
    DIR_RUN dr;
    LONG nEmbed;
    WORD wDir;
    WORD wOverride;
    LONG cchOffset;

    // Keep a copy of the flow layout and markup.
    _pFlowLayout = treeinfo._pFlowLayout;
    _pMarkup = treeinfo._pMarkup;
    Assert(_pFlowLayout != NULL && _pMarkup != NULL);

    // The cp should be in the scope of the flow layout.
    Assert(cp >= _pFlowLayout->GetContentFirstCp() && cp <= _pFlowLayout->GetContentLastCp());
    _cpFirst = _cp = cp;
    _cpLim = treeinfo._cpLayoutLast;

     // Initialize the tree pointer and _cchRemaining.
    _ptp = _pMarkup->TreePosAtCp(cp, &cchOffset);
    _cchRemaining = (_ptp->IsText() ? _ptp->Cch() - cchOffset : 0);
    Assert(_ptp != NULL && (!_ptp->IsText() || _cchRemaining > 0));

    // Initialize the bidi stack.
    _fRTLPara = fRTLPara;
    // TODO (track bug 112281): SLOWBRANCH: GetBranch is very slow, but it is the best thing to
    // use here. It only gets called when the CBidiLine is created, so it isn't
    // actually prohibitive.
    ptn = _ptp->GetBranch();
    nEmbed = 0;
    wDir = 0;
    wOverride = 0;
    while (ptn && !ptn->Element()->IsBlockElement() && ptn->GetUpdatedLayout() != _pFlowLayout)
    {
        // We can measure lines with the node chars for the phrase elements at BOL;
        // this would happen when we have borders/glyphs/backgrounds etc. To handle
        // this case, make sure that we do account for them here, since we are going 
        // to see the begin node's for these elements during our regular processing.
        if (_cpFirst >= ptn->Element()->GetFirstCp())
        {
            pCF = ptn->GetCharFormat();
            if (pCF->_fBidiEmbed)
            {
                wDir = (wDir << 1) | pCF->_fRTL;
                wOverride = (wOverride << 1) | pCF->_fBidiOverride;
                nEmbed++;
            }
        }
        ptn = ptn->Parent();
    }

    _iLevel = _fRTLPara;
    // set the static reading order state for the line
    if (ptn)
    {
        _fVisualLine = (_pMarkup->_fVisualOrder &&
                        !ptn->Element()->HasFlag(TAGDESC_LOGICALINVISUAL));
        _dcEmbed = (_fVisualLine || ptn->GetCharFormat()->_fBidiOverride ) 
                    ? (_fRTLPara ? RLO : LRO) : (_fRTLPara ? RLE : LRE);
    }
    _iEmbed = 0;
    _iOverflow = 0;
    while (nEmbed > 0)
    {
        // We're starting an embedding. Update the stack and _iLevel.
        BOOL fRTL = (wDir & 1);
        if (_iLevel < 14 + fRTL && _iOverflow == 0)
        {
            _aEmbed[_iEmbed++] = _dcEmbed;
            _iLevel += 1 + ((_iLevel & 1) == fRTL);
            _dcEmbed = (wOverride & 1) ? (fRTL ? RLO : LRO) : (fRTL ? RLE : LRE);
        }
        else
        {
            _iOverflow++;
        }
        wDir >>= 1;
        wOverride >>= 1;
        nEmbed--;
    }

    // Initialize the bidi algorithm state.
    _dcPrev = _dcPrevStrong = GetInitialDirClass(_iLevel & 1);

    // Initialize the run array. We always have at least one entry in the
    // current embedding level (usually the paragraph direction). We don't need
    // to worry about OOM because we're derived from a CStackDataArray with 8
    // element.
    dr.cp = cp;
    dr.iLevel = _iLevel;
    _aryDirRun.AppendIndirect(&dr);
    Assert(_aryDirRun.Size() == 1);

    // Initialize to current run to zero.
    _iRun = 0;

    if (pli != NULL)
    {
        // If we know the length of the line already precompute the runs.
        Assert(cp + pli->_cch <= _cpLim);
        if (pli->_cch > 0)
        {
            EvaluateLayoutToCp(cp + pli->_cch - 1, cp + pli->_cch - 1);
            AdjustTrailingWhitespace(cp + pli->_cch - 1);
        }
    }

#if DBG==1
    _fStringLayout = FALSE;
#endif
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::CBidiLine
//
//  Synopsis:   Create a complex line from a text buffer. This is used to get
//              the ordering for bidi numbering. We basically just zap out most
//              of the properties and pass the text straight into the bidi
//              algorithm.
//
//-----------------------------------------------------------------------------
CBidiLine::CBidiLine(
    BOOL fRTLPara,
    LONG cchText,
    const WCHAR * pchText)
{
#ifdef NO_IMPLICIT_BIDI
    DIR_RUN dr;

    dr.cp = 0;
    dr.iLevel = fRTLPara;
    _aryDirRun.AppendIndirect(&dr);
#else
    DIR_RUN dr;

    // Nuke the flow layout and markup.
    _pFlowLayout = NULL;
    _pMarkup = NULL;

    // Set CPs. These are just indices into pchText.
    _cpFirst = _cp = 0;
    _cpLim = cchText - 1;

     // Nuke the tree pointer and _cchRemaining.
    _ptp = NULL;
    _cchRemaining = 0;

    // Initialize the bidi stack.
    _fRTLPara = fRTLPara;
    _iLevel = _fRTLPara;
    _dcEmbed = _fRTLPara ? RLE : LRE;
    _iEmbed = 0;
    _iOverflow = 0;

    // Initialize the bidi algorithm state.
    _dcPrev = _dcPrevStrong = (_iLevel & 1) ? RTL : LTR;

    // Initialize the run array. We always have at least one entry in the
    // current embedding level. We don't need to worry about OOM because we're
    // derived from a CStackDataArray with 8 elements.
    dr.cp = 0;
    dr.iLevel = _iLevel;
    _aryDirRun.AppendIndirect(&dr);
    Assert(_aryDirRun.Size() == 1);

    // Initialize to current run to zero.
    _iRun = 0;

    // We've already got the text so compute the runs.
    EvaluateLayout(pchText, cchText, BLK, BLK, 0);
    _cp += cchText;

#if DBG==1
    _fStringLayout = TRUE;
#endif
#endif // NO_IMPLICIT_BIDI
}


#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::IsEqual
//
//  Synopsis:   Check to see if the line which would be created using the
//              passed parameters is the same as the current line.
//
//  Returns:    TRUE if the lines would be the same, FALSE if not.
//
//-----------------------------------------------------------------------------
BOOL CBidiLine::IsEqual(
    const CTreeInfo & treeinfo,
    LONG cp,
    BOOL fRTLPara,
    const CLineFull * pli) const
{
#ifdef NO_IMPLICIT_BIDI
    return _aryDirRun[0].cp == cp;
#else
    Assert(!_fStringLayout);
    return _pFlowLayout == treeinfo._pFlowLayout &&
           _pMarkup == treeinfo._pMarkup &&
           _cpFirst == cp &&
           _cpLim == treeinfo._cpLayoutLast &&
           _fRTLPara == (unsigned)fRTLPara;
#endif // NO_IMPLICIT_BIDI
}
#endif


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetInitialDirClass
//
//  Synopsis:   Figure out the start state for the bidi algorithm, based on the
//              line direction, document charset, and system locale.
//
//  Returns:    The initial DIRCLS used to prime the bidi algorithm.
//
//-----------------------------------------------------------------------------
DIRCLS
CBidiLine::GetInitialDirClass(
    BOOL fRTLLine)
{
    if (!fRTLLine)
    {
        // LTR lines always start with a LTR DIRCLS.
        return LTR;
    }

    CODEPAGE codepage = _pFlowLayout->ElementOwner()->GetMarkup()->GetCodePage();

    switch (codepage)
    {
    case CP_ASMO_708:
    case CP_ASMO_720:
    case CP_1256:
    case CP_ISO_8859_6:
        // If the charset is Arabic, set the DIRCLS to be ARA.
        return ARA;
    case CP_UNDEFINED:
    case CP_UCS_2:
    case CP_UCS_2_BIGENDIAN:
    case CP_AUTO:
    case CP_AUTO_JP:
    case CP_UTF_7:
    case CP_UTF_8:
    case CP_UCS_4:
    case CP_UCS_4_BIGENDIAN:
        // If the charset is ambiguous, and the system locale is Arabic, set
        // the DIRCLS to ARA.
        if(IsInArabicBlock(PRIMARYLANGID(g_lcidLocalUserDefault)))
        {
            return ARA;
        }
    }

    // In all other cases, set the DIRCLS to RTL for RTL lines.
    return RTL;
}

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::DirClassFromChAndContextSlow
//
//  Synopsis:   Figure out character's direction class based on its context.
//
//-----------------------------------------------------------------------------
DIRCLS 
CBidiLine::DirClassFromChAndContextSlow(WCHAR ch, LANGID lang, LANGID sublang)
{
    Assert(ch == WCH_PLUSSIGN || ch == WCH_MINUSSIGN);

    DIRCLS   dc = DirClassFromCh(ch);
    CODEPAGE cp = _pMarkup->GetFamilyCodePage();

    Assert(dc == NEU);

    // The + and - signs need to be classified as ES when used with Hebrew Script
    // 1. If the language of the run is Hebrew, change
    // 2. If the language of the run is Yiddish, change (uses Hebrew script)
    // 3. If no language is assigned to the run, and the previous strong character 
    //    has DIRCLS of RTL, and the document CP is Hebrew or the user's default 
    //    LCID is Hebrew or Yiddish, change
    if (   LANG_HEBREW == lang
        || LANG_YIDDISH == lang
        || (   LANG_NEUTRAL == lang
            && RTL == _dcPrevStrong
            && (   CP_1255 == cp 
                || LANG_HEBREW == PRIMARYLANGID(g_lcidLocalUserDefault)
                || LANG_YIDDISH == PRIMARYLANGID(g_lcidLocalUserDefault)) ) )
    {
        dc = ESP;
    }

    return dc;
}

//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetRunCchRemaining
//
//  Synopsis:   Gets the number of characters remaining in the DIR_RUN at cp,
//              limited by cchMax. This will just look in the run array if
//              possible, but if cp is beyond the end of the run array then we
//              will extend the run array by analyzing the text with the bidi
//              algorithm.
//
//  Returns:    The number of characters remaining in the DIR_RUN or cchMax,
//              whichever is greater.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::GetRunCchRemaining(
    LONG cp,
    LONG cchMax)
{
#ifdef NO_IMPLICIT_BIDI
    return cchMax;
#else
    LONG iRun;
    LONG cch;

    Assert(!_fStringLayout);
    Assert(cp >= _cpFirst && cp <= _cpLim);
    Assert(cchMax > 0);

    // If we don't have the requested run evaluate it with the bidi algorithm.
    if (cp + cchMax > _cp)
    {
        EvaluateLayoutToCp(cp + cchMax - 1);
        Assert(cp < _cp);
    }

    // Find the requested run.
    iRun = FindRun(cp);
    Assert(iRun >= 0 && iRun < _aryDirRun.Size());

    // Get the length of the requested run.
    cch = ((iRun == _aryDirRun.Size() - 1) ? _cp : _aryDirRun[iRun + 1].cp) - cp;

    return min(cchMax, cch);
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetDirRun
//
//  Synopsis:   Gets the DIR_RUN at cp.
//
//  Returns:    The DIR_RUN at cp.
//
//-----------------------------------------------------------------------------
const DIR_RUN &
CBidiLine::GetDirRun(
    LONG cp)
{
#ifdef NO_IMPLICIT_BIDI
    return _aryDirRun[0];
#else
    LONG iRun;

    Assert(!_fStringLayout);
    Assert(cp >= _cpFirst && cp <= _cpLim);

    // If we don't have the requested run evaluate it with the bidi algorithm.
    if (cp >= _cp)
    {
        EvaluateLayoutToCp(cp);
        Assert(cp < _cp);
    }

    // Find the requested run.
    iRun = FindRun(cp);
    Assert(iRun >= 0 && iRun < _aryDirRun.Size());

    // Return the requested DIR_RUN.
    return _aryDirRun[iRun];
#endif // NO_IMPLICIT_BIDI
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::FindRun
//
//  Synopsis:   Find the run which contains the specified cp. Set _iRun and
//              return the run value.
//
//  Returns:    The run that the cp is in.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::FindRun(
    LONG cp)
{
    Assert(!_fStringLayout);
    Assert(_aryDirRun.Size() != 0);
    Assert(cp >= _cpFirst && cp < _cp);
    Assert(_iRun >= 0 && _iRun < _aryDirRun.Size());

    // If the requested cp is in the range of _aryDirRun[_iRun] then we can
    // just return _iRun. Otherwise we'll have to search for it.
    if (_aryDirRun[_iRun].cp > cp ||
        (_iRun != _aryDirRun.Size() - 1 && _aryDirRun[_iRun + 1].cp <= cp))
    {
        LONG iRun;

        // We have to search for the correct run. If the current run (_iRun)
        // is before cp, then we start searching from _iRun (which we will
        // do most of the time), otherwise we start searching from the start of
        // the run array. We keep searching until we blow out the end of the
        // run array or we find a run beyond cp, at which point we back up
        // one run.
        for (iRun = (_aryDirRun[_iRun].cp <= cp) ? _iRun : 0;
             iRun < _aryDirRun.Size() && _aryDirRun[iRun].cp <= cp;
             iRun++);
        _iRun = iRun - 1;
    }

    // Make sure the current run is in range.
    Assert(_iRun >= 0 && _iRun < _aryDirRun.Size());

    return _iRun;
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::LogicalToVisual
//
//  Synopsis:   Convert an array of characters from logical to visual order
//              using the levels stored in _aryDirRun[]. The visual string is
//              passed back in pchVisual. The conversion optionally reverse the
//              visual string, which is handy if it will eventually be rendered
//              RTL (as with RTL numbering).
//
//              The algorithm used is not necessarily the fastest out there,
//              but given that this function is primarily used for strings that
//              are no deeper than 2 levels and are virtually never longer than
//              10 characters it should suffice.
//
//-----------------------------------------------------------------------------
void CBidiLine::LogicalToVisual(
    BOOL fRTLBuffer,
    LONG cchText,
    const WCHAR * pchLogical,
    WCHAR * pchVisual)
{
    LONG iLev = 0;
    LONG iRun;
    LONG cRun = _aryDirRun.Size();
    WCHAR * pch1;
    WCHAR * pch2;
    WCHAR ch;

    Assert(_fStringLayout);

    // Copy off the logical buffer.
    CopyMemory(pchVisual, pchLogical, cchText * sizeof(WCHAR));

    // Find run with the deepest level
    for (iRun = 0; iRun < cRun; iRun++)
    {
        iLev = max(iLev, _aryDirRun[iRun].iLevel);
    }

    // For each level, walk through the runs.

    while (iLev > 0)
    {
        for (iRun = 0; iRun < cRun; iRun++)
        {
            // If the run is as deep as the current level, reverse the text
            // under it.
            if (_aryDirRun[iRun].iLevel >= iLev)
            {
                pch1 = pchVisual + _aryDirRun[iRun].cp;
                // Look forward for a run which is shallower than the current
                // level.
                while (++iRun < cRun && _aryDirRun[iRun].iLevel >= iLev);
                pch2 = pchVisual + (iRun == cRun ? _cp : _aryDirRun[iRun].cp) - 1;
                while (pch1 < pch2)
                {
                    ch = *pch1;
                    *pch1 = *pch2;
                    *pch2 = ch;
                    pch1++;
                    pch2--;
                }
                iRun--;
            }
        }
        iLev--;
    }

    // If the fRTLBuffer flag is set reverse the entire buffer.
    if (fRTLBuffer)
    {
        pch1 = pchVisual;
        pch2 = pchVisual + cchText - 1;
        while (pch1 < pch2)
        {
            ch = *pch1;
            *pch1 = *pch2;
            *pch2 = ch;
            pch1++;
            pch2--;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::EvaluateLayoutToCp
//
//  Synopsis:   Evaluates the text beginning at _cp up to (and including)
//              cpLine using the bidi algorithm. If cpLine is -1, we evaluate
//              the next DEFAULT_CHARS_TO_EVALUATE characters, limited by
//              _cpLim. We also guarentee that we at least evaluate as far as
//              cp.
//
//-----------------------------------------------------------------------------
void
CBidiLine::EvaluateLayoutToCp(
    LONG cp,
    LONG cpLine)
{
    WCHAR ach[DEFAULT_CHARS_TO_EVALUATE];
    LONG cch;
    const WCHAR * pch;
    const WCHAR * pchLim;
    DIRCLS dcTrail;
    DIRCLS dcTrailForNumeric;
    LONG cchFetch;

    Assert(cp >= _cpFirst && cp <= _cpLim &&
           (cpLine == -1 || (cpLine >= _cpFirst && cpLine <= _cpLim)));

    // While we haven't processed the requested cp...
    while (_cp <= cp)
    {
        // Fetch some text from the store
        cchFetch = (cpLine == -1) ?
                   DEFAULT_CHARS_TO_EVALUATE :
                   min(DEFAULT_CHARS_TO_EVALUATE, (LONG) (cpLine - _cp + 1));
        cch = GetTextForLayout(ach, cchFetch, _cp, &_ptp, &_cchRemaining);
        Assert(cch > 0 && cch <= cchFetch);

        // Find the last non-node character
        for (pch = ach + cch; pch-- > ach && *pch == WCH_NODE; );

        // If there was some non-node text in the retreived data...
        if (pch >= ach)
        {
            BOOL fNeedNumericPunctResolution;

            // Get the DIRCLS of the final character.
            dcTrail = DirClassFromChAndContext(*pch, _cp + (pch - ach));

            // If the final DIRCLS is a ETM, ESP, or CSP then we'll need to
            // find the character that resolves it.
            fNeedNumericPunctResolution = IsNumericPunctuationClass(dcTrail);
            dcTrailForNumeric = dcTrail;

            // If the final DIRCLS is neutral we'll need to look beyond it to
            // resolve it in EvaluateLayout().
            if (IsIndeterminateClass(dcTrail))
            {
#define TRAIL_BUFFER 32
                CTreePos * ptpTrail;
                LONG cchTrailRemaining;
                LONG cpTrail;
                LONG cchTrail;
                WCHAR achTrail[TRAIL_BUFFER];

                // Record the position of the end of the fetch. We'll start
                // looking from here.
                ptpTrail = _ptp;
                cchTrailRemaining = _cchRemaining;
                cpTrail = _cp + cch;

                // TEMPORARY FIX: (gschneid) This check prevents IE to crash. In case ptpTrail 
                // is NULL dcTrail is set to BLK which is a reasonable choice. 
                // (TODO) This bug (#20341) needs to be reviewed for blackcomb.
                if (ptpTrail)
                {
                    if (ptpTrail->IsBeginNode() && cchTrailRemaining > 1)
                    {
                        // We're in the midst of an embedding. Go ahead and skip
                        // over all the embedding text, since it will all evaluate
                        // as neutrals and waste lots of our time.
    
                        // We should never need numeric punctuation; since we
                        // should always be preceeded by a WCH_EMBEDDING (neutral).
                        Assert(!fNeedNumericPunctResolution);
                        cpTrail += cchTrailRemaining - 1;
                        cchTrailRemaining = 1;
                    }
    
                    do
                    {
                        // if out of range, break
                        if (cpTrail < _cpFirst || cpTrail > _cpLim)
                        {
                            if (cpTrail > _cpLim && IsIndeterminateClass(dcTrail))
                            {
                                // NOTE (grzegorz): we run out of characters and direction
                                // is still unresolved, treat this situation as and of block
                                dcTrail = BLK;
                            }
                            break;
                        }

                        // Fetch some more text from the store.
                        cchTrail = GetTextForLayout(achTrail, TRAIL_BUFFER, cpTrail,
                                                    &ptpTrail, &cchTrailRemaining);
                        Assert(cchTrail > 0 && cchTrail <= TRAIL_BUFFER);

                        // Advance cpTrail. ptpTrail and cchTrailRemaining have
                        // already been advanced.
                        cpTrail += cchTrail;

                        // Search until we find a non-neutral class (or we run out
                        // of text). Note that WCH_NODE evaluates as neutral.
                        for (pch = achTrail, pchLim = achTrail + cchTrail;
                             pch < pchLim && IsIndeterminateClass(dcTrail);
                            pch++)
                        {
                            dcTrail = DirClassFromChAndContext(*pch, cpTrail + (pch - achTrail));
                            if (dcTrail == FMT)
                            {
                                // FMT covers all the embedding control characters.
                                // We need to differentiate between them.
                                Assert(InRange(*pch, WCH_LRE, WCH_RLO));
                                dcTrail = s_adcEmbedding[*pch - WCH_LRE];
                            }

                            // If we need to find a character to resolve a ETM,
                            // ESP, or CSP then check for it here. Note that ESP
                            // and CSP are resolved by whatever the next character
                            // is, while ETM needs the next non-ETM character.
                            if (fNeedNumericPunctResolution &&
                                *pch != WCH_NODE &&
                                (dcTrail != ETM || IsNumericSeparatorClass(dcTrailForNumeric)))
                            {
                                dcTrailForNumeric = dcTrail;
                                fNeedNumericPunctResolution = FALSE;
                            }
                        }

                    // If that pass failed to find a dcTrail that would resolve
                    // things pull in some more text.
                    } while (IsIndeterminateClass(dcTrail));
                    // This flag should always get cleared in the above loop.
                    // TODO (grzegorz): see IE6 #20157, need to reenable this assert.
                    //      For now it's harmless assert in some situations 
                    //      (see repro file for the bug).
                    // Assert(!fNeedNumericPunctResolution);

                    // Let 'er rip! _cp is only needed to record the DIR_RUNs.
                }
                else
                {
                    // See comment of gschneid at the beginning of the if statement.
                    // (TODO) When reviewing this bug please take grzegorz comment above in
                    // account.
                    dcTrail = BLK;
                }
            }

            EvaluateLayout(ach, cch, dcTrail, dcTrailForNumeric, _cp);
        }

        // We've now added all cch characters to _aryDirRun[]. Move _cp ahead.
        _cp += cch;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::EvaluateLayout
//
//  Synopsis:   Evaluates pchText using the bidi algorithm. When this function
//              is called we assume that we are in the midst of processing
//              EvaluateLayout() several times, hence we carry the following
//              state:
//
//              _dcPrev         Previous resolved character class
//              _dcPrevStrong   Previous strong character class
//              _iLevel         Current level
//              _dcEmbed        Type of current embedding
//              _aEmbed         Bidi stack
//              _iEmbed         Depth of bidi stack
//              _iOverflow      Overflow from bidi stack
//              _fRTLPara       Paragraph direction
//
//              This state is updated by the algorithm to reflect the
//              processing of the text in pchText. The algorithm also updates
//              _aryDirRun to include a list of directions matching the
//              resolved levels of pchText.
//
//              WARNING! This function can only deal with text which is shorter
//              than DEFAULT_CHARS_TO_EVALUATE. The calling functions currently
//              constrain this so it's not a problem. If (at some future time)
//              it becomes necessary to deal with text longer than this, turn
//              on HANDLE_LONG_LAYOUT_TEXT.
//
//-----------------------------------------------------------------------------
void
CBidiLine::EvaluateLayout(
    const WCHAR * pchText,
    LONG cchText,
    DIRCLS dcTrail,
    DIRCLS dcTrailForNumeric,
    LONG cp)
{
    DIRCLS dc;
    DIRCLS dcPrev;
    const WCHAR * pchLim;
    const WCHAR * pch;
    DIRCLS adc[DEFAULT_CHARS_TO_EVALUATE];
    LONG cdc;
    DIRCLS * pdcStart = adc;
    DIRCLS * pdcLim;
    DIRCLS * pdc;
    DIRCLS * pdcNeutral;
    DIRCLS dcNumeral;
    DIRCLS dcNeutral;
    BYTE aLevel[DEFAULT_CHARS_TO_EVALUATE];
    BYTE * pLevelStart = aLevel;
    BYTE * pLevel;
    BYTE iLevel;
    BOOL fRTL = FALSE;

    // Verify our parameters
    Assert(pchText != NULL && !IsIndeterminateClass(dcTrail) && cp <= _cpLim);

    // Verify our state
    Assert(IsFinalClass(_dcPrev) && IsStrongClass(_dcPrevStrong));
    Assert((_iLevel & 1) == IsRTLEmbeddingClass(_dcEmbed));
#if DBG==1
    {
        LONG i;
        LONG iLev;

        iLev = _iLevel;
        for (i = _iEmbed - 1; i >= 0; i--)
        {
            Assert(IsEmbeddingClass(_aEmbed[i]));
            iLev -= 1 + ((iLev & 1) == IsRTLEmbeddingClass(_aEmbed[i]));
        }
        Assert(_iLevel < 16 && iLev == (long)_fRTLPara);
    }
#endif

#ifdef HANDLE_LONG_LAYOUT_TEXT
    // If there are more characters than will fit in our stack buffers
    // allocatate some working buffers off the heap.
    if (cchText > DEFAULT_CHARS_TO_EVALUATE)
    {
        pdcStart = new DIRCLS[cchText];
        pLevelStart = new BYTE[cchText];
        if (pdcStart == NULL || pLevelStart == NULL)
        {
            goto Cleanup;
        }
    }
#else
    Assert(cchText <= DEFAULT_CHARS_TO_EVALUATE);
#endif

    // Convert the characters into DIRCLSs
    pch = pchText;
    pdc = pdcStart;
    pchLim = pchText + cchText;
    for (pch = pchText; pch < pchLim; pch++)
    {
        // Skip nodes. They have no effect on layout.
        if (*pch != WCH_NODE)
        {
            dc = DirClassFromChAndContext(*pch, _cp + (pch - pchText));
            if (dc == FMT)
            {
                // FMT covers all the embedding control characters. We need to
                // differentiate between them.
                Assert(InRange(*pch, WCH_LRE, WCH_RLO));
                dc = s_adcEmbedding[*pch - WCH_LRE];
            }
            *pdc++ = dc;
        }
    }
    cdc = pdc - pdcStart;
    pdcLim = pdc;

    // Resolve breaks, embeddings, and overrides and set base level values.
    pdc = pdcStart;
    pLevel = pLevelStart;
    while (pdc < pdcLim)
    {
        if (IsBreakOrEmbeddingClass(*pdc))
        {
            dc = *pdc;
            switch (dc)
            {
            case BLK:
                // Block breaks reset the embedding level and are resolved as
                // strong characters in the paragraph direction.
                _iEmbed = 0;
                _iLevel = _fRTLPara;
                _dcEmbed = _fVisualLine ? (_fRTLPara ? RLO : LRO) : (_fRTLPara ? RLE : LRE);

                break;
            case SEG:
                // Segment separators are set at the paragraph level and are
                // resolved as strong characters in the paragraph direction.
                // Note that the do NOT reset the stack, so we advance pdc and
                // pLevel and continue.
                *pLevel++ = (BYTE)_fRTLPara;
                *pdc++ = _fRTLPara ? RTL : LTR;
                continue;
            case PDF:
                // PDF resets the embedding level to the previous entry on the
                // stack. It is resolved as a strong character in the direction
                // of the current level before the stack is popped. Since the
                // level and dc do not necessarily match the popped values, we
                // advance pLevel and pdc and continue.
                *pLevel++ = _iLevel;
                *pdc++ = (_iLevel & 1) ? RTL : LTR;
                if (_iEmbed > 0 && _iOverflow == 0)
                {
                    _dcEmbed = _aEmbed[--_iEmbed];
                    fRTL = IsRTLEmbeddingClass(_dcEmbed);
                    _iLevel -= 1 + ((_iLevel & 1) == fRTL);
                }
                else if (_iOverflow > 0)
                {
                    _iOverflow--;
                }
                continue;
            case LRE:
            case RLE:
            case LRO:
            case RLO:
                // The embedding controls push the current embedding onto the
                // stack and set a new embedding direction. They are resolved
                // as strong characters in the direction of the embedding.
                fRTL = IsRTLEmbeddingClass(dc);
                if (_iLevel < 14 + fRTL && _iOverflow == 0)
                {
                    _aEmbed[_iEmbed++] = _dcEmbed;
                    _iLevel += 1 + ((_iLevel & 1) == fRTL);
                    _dcEmbed = dc;
                }
                else
                {
                    _iOverflow++;
                }
                break;
#if DBG==1
            default:
                Assert(FALSE);
                break;
#endif
            }
            // All block characters are resolved as strong characters.
            *pdc = (_iLevel & 1) ? RTL : LTR;
        }
        if (IsOverrideClass(_dcEmbed))
        {
            // If we're currently in an override stomp on the dc and turn it
            // into a strong character in the override direction.
            *pdc = (_dcEmbed == LRO) ? LTR : RTL;
        }
        // Record the level and advance pLevel and pdc.
        *pLevel++ = _iLevel;
        pdc++;
    }
    if (IsBreakOrEmbeddingClass(dcTrail))
    {
        // If the dcTrail class is a break or embedding turn it into the
        // appropriate strong direction.
        switch (dcTrail)
        {
        case BLK:
        case SEG:
            fRTL = _fRTLPara;
            break;
        case PDF:
            fRTL = (_iLevel & 1);
            break;
        case LRE:
        case LRO:
            fRTL = FALSE;
            break;
        case RLE:
        case RLO:
            fRTL = TRUE;
            break;
#if DBG==1
        default:
            Assert(FALSE);
            break;
#endif
        }
        dcTrail = fRTL ? RTL : LTR;
    }

    // Resolve numerals.
    dcPrev = _dcPrevStrong;
    for (pdc = pdcStart; pdc < pdcLim; pdc++)
    {
        if (IsStrongClass(*pdc))
        {
            dcPrev = *pdc;
        }
        else if (*pdc == ENM)
        {
            // European numerals are changed into ENL, ENR, or ANM depending
            // on the previous strong character.
            Assert(IsStrongClass(dcPrev));
            *pdc = s_adcNumeric[dcPrev];
        }
    }
    if (dcTrail == ENM)
    {
        // The trailing character is also changed to ENL, ENR or ANM.
        dcTrail = s_adcNumeric[dcPrev];
    }

    // Update _dcPrevStrong to the last strong class in the text.
    _dcPrevStrong = dcPrev;

    // Resolve numeric punctuation (separators and terminators).
    dcPrev = _dcPrev;
    for (pdc = pdcStart; pdc < pdcLim; pdc++)
    {
        if (IsNumericPunctuationClass(*pdc))
        {
            if (*pdc == ETM)
            {
                DIRCLS * pdcT;

                if (!IsResolvedEuroNumClass(dcPrev))
                {
                    // If the run of ETMs is bounded by a ENL or ENR then we
                    // get dcPrev set to ENL or ENR.
                    for (pdcT = pdc + 1; pdcT < pdcLim && *pdcT == ETM; pdcT++);
                    if (pdcT == pdcLim)
                    {
                        if (dcTrailForNumeric == ENM)
                        {
                            dcTrailForNumeric = s_adcNumeric[_dcPrevStrong];
                        }
                        pdcT = &dcTrailForNumeric;
                    }
                    dcPrev = *pdcT;
                }
                // Turn the ETMs into ENLs or ENRs if they are bounded on
                // either side by such a class, otherwise turn them into NEUs.
                dcNumeral = IsResolvedEuroNumClass(dcPrev) ? dcPrev : NEU;
                for (pdcT = pdc; pdcT < pdcLim && *pdcT == ETM; pdcT++)
                {
                    *pdcT = dcNumeral;
                }
            }
            else
            {
                // If a separator is bounded on both sides by numerals of the same
                // class, and it is not an ESP bounded by ANMs, turn it into such
                // a numeral. Otherwise turn it into a neutral.
                DIRCLS dcNext = (pdc + 1 < pdcLim) ? *(pdc + 1) : dcTrailForNumeric;
                if (dcPrev == dcNext &&
                    (IsResolvedEuroNumClass(dcPrev) || (dcPrev == ANM && *pdc == CSP)) )
                {
                    *pdc = dcPrev;
                }
                else
                {
                    *pdc = NEU;
                }
            }
        }
        dcPrev = *pdc;
    }

    // Resolve neutrals
    dcPrev = _dcPrev;
    pLevel = pLevelStart;
    pdcNeutral = NULL;
    for (pdc = pdcStart; pdc < pdcLim; pdc++, pLevel++)
    {
        dc = *pdc;
        if (!IsNeutralClass(dc))
        {
            Assert(IsFinalClass(dc));
            if (pdcNeutral != NULL)
            {
                // If this is character is not a neutral and it is preceeded by
                // neutrals (pdcNeutral != NULL) figure out what class the
                // neutrals should be resolved as using s_adcNeutral and
                // replace them with that class.
                Assert(pLevel - pLevelStart >= 1);
                dcNeutral = s_adcNeutral[*(pLevel - 1) & 1][dcPrev][dc];
                while (pdcNeutral < pdc)
                {
                    *pdcNeutral++ = dcNeutral;
                }
                pdcNeutral = NULL;
            }
            dcPrev = dc;
        }
        else if (pdcNeutral == NULL)
        {
            if (dc == CBN)
            {
                // If this is a combining mark let if follow the classification
                // of the previous text
                *pdc = dcPrev;
            }
            else
            {
                // If we encounter a run of neutrals record where the run starts.
                pdcNeutral = pdc;
            }
        }
    }
    if (pdcNeutral != NULL)
    {
        Assert(IsFinalClass(dcTrail));
        // Resolve trailing neutrals using dcTrail.
        dcNeutral = s_adcNeutral[_iLevel & 1][dcPrev][dcTrail];
        while (pdcNeutral < pdcLim)
        {
            *pdcNeutral++ = dcNeutral;
        }
    }

    // Update _dcPrev to the last class in the text.
    if (cdc != 0)
    {
        _dcPrev = *(pdcLim - 1);
    }

    // Convert resolved classes to levels using s_abLevelOffset.
    for (pdc = pdcStart, pLevel = pLevelStart; pdc < pdcLim; pdc++, pLevel++)
    {
        Assert(IsFinalClass(*pdc));
        *pLevel += s_abLevelOffset[*pLevel & 1][*pdc];
    }

    // Convert the resolved levels into an array of DIR_RUNs. We merge the
    // nodes back in at this time.
    Assert(_aryDirRun.Size() > 0);
    iLevel = _aryDirRun[_aryDirRun.Size() - 1].iLevel;
    for (pch = pchText, pLevel = pLevelStart; pch < pchLim; pch++, cp++)
    {
        if (*pch != WCH_NODE)
        {
            if (*pLevel != iLevel)
            {
                DIR_RUN dr;
                iLevel = *pLevel;
                dr.iLevel = iLevel;
                dr.cp = cp;
                _aryDirRun.AppendIndirect(&dr);
            }
            pLevel++;
        }
    }
    Assert(pLevel == pLevelStart + cdc);

#ifdef HANDLE_LONG_LAYOUT_TEXT
Cleanup:
    if (cchText > DEFAULT_CHARS_TO_EVALUATE)
    {
        // If we had to allocate working buffers off the heap free them now.
        if (pdcStart != NULL)
        {
            Assert(pdcStart != adc);
            delete pdcStart;
        }
        if (pLevelStart != NULL)
        {
            Assert(pLevelStart != aLevel);
            delete pLevelStart;
        }
    }
#endif
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::AdjustTrailingWhitespace
//
//  Synopsis:   Adjusts the trailing whitespace on the line to follow the line
//              direction. This gets called after the bidi algorithm has been
//              run over the full line.
//
//-----------------------------------------------------------------------------
void
CBidiLine::AdjustTrailingWhitespace(
    LONG cpEOL)
{
    LONG iRun;
    BOOL fWhite;
    LONG cchValid;
    LONG cchRemaining;
    CTreePos * ptp;
    const WCHAR * pch=NULL;
    LONG cpTrail;
    LONG cp = cpEOL;

    iRun = _aryDirRun.Size() - 1;
    Assert(iRun >= 0);
    if (_aryDirRun[iRun].iLevel == (long)_fRTLPara)
    {
        // If the last run (potential whitespace) is the same as the paragraph
        // direction, then we don't need to adjust it.
        return;
    }

     // Initialize the tree pointer and cchRemaining.
    ptp = _pMarkup->TreePosAtCp(cpEOL, &cchRemaining);
    if (ptp->IsText())
    {
        cchRemaining++;
    }
    Assert(ptp != NULL && (ptp->IsText() ^ (cchRemaining == 0)));

    // Only need to go back as far as the first direction change. At this point
    // there is either non-white text or a level transition.
    cpTrail = _aryDirRun[iRun].cp;
    fWhite = TRUE;
    cchValid = 0;
    while (fWhite && cp >= cpTrail)
    {
        if (cchValid == 0)
        {
            // This is sort of goofy. GetPchReverse() doesn't actaully return
            // a valid pointer to cp, it returns a pointer to cp such that
            // there is text behind pch. This means that pch itself may point
            // into the gap or beyond the end of a block. We fix this by
            // grabbing text at cp + 1 (which is safe due to the trailing
            // WCH_NODE character) and decrementing pch.
            _txtptr.SetCp(cp + 1);
            pch = _txtptr.GetPchReverse(cchValid);
            Assert(pch != NULL);
            pch--;
        }

        AssertSz(pch != NULL, "Checking on a complaint from the compiler.");
        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            if (ptp->IsEdgeScope())
            {
                Assert(*pch == WCH_NODE && cchRemaining == 0);
                fWhite = !ptp->Branch()->ShouldHaveLayout();
                if (fWhite)
                {
                    cchValid--;
                    pch--;
                    cp--;
                }
            }
            break;
        case CTreePos::Text:
            if (cchRemaining == 0)
            {
                cchRemaining = ptp->Cch();
            }
            while (fWhite && cchValid && cchRemaining && cp >= cpTrail)
            {
                fWhite = (DirClassFromCh(*pch--) == WSP);
                if (fWhite)
                {
                    cchValid--;
                    cchRemaining--;
                    cp--;
                }
            }
            break;
#if DBG==1
        default:
            // The only other type we should encounter are pointers.
            Assert(ptp->Type() == CTreePos::Pointer);
            break;
#endif
        }

        // Update ptp.
        if (!cchRemaining)
        {
            ptp = ptp->PreviousTreePos();
        }
    }

    if (!fWhite || cp < cpTrail)
    {
        cp++;
    }

    Assert(cp >= cpTrail);
    if (cp == cpTrail)
    {
        // If the last run is completely whitespace just change its level.
        _aryDirRun[iRun].iLevel = _fRTLPara;
    }
    else
    {
        // Add another run that follows the paragraph direction which
        // covers the trailing whitespace.
        DIR_RUN dr;
        dr.iLevel = _fRTLPara;
        dr.cp = cp;
        _aryDirRun.AppendIndirect(&dr);
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CBidiLine::GetTextForLayout
//
//  Synopsis:   Gets cch characters from the backing store. Directional
//              embeddings are fixed up to use LRE/RLE/PDF type marks, and
//              elements with their own layout are overridden to WCH_EMBEDDING.
//              The final ptp and the number of characters remaining in it are
//              passed back to the caller.
//
//  Returns:    The number of characters in the buffer. This may be less than
//              cch if an end of line (block element, BR, etc) was encountered.
//
//-----------------------------------------------------------------------------
LONG
CBidiLine::GetTextForLayout(
    WCHAR * pch,
    LONG cch,
    LONG cp,
    CTreePos ** pptp,
    LONG * pcchRemaining)
{
    WCHAR * pchStart;
    WCHAR * pchLim;
    LONG cchRemaining = *pcchRemaining;
    CTreePos * ptp = *pptp;
    CTreeNode * ptnText = NULL;

    // Position the tree node for the text format
    ptnText = ptp->GetBranch();

    // Move the _txtptr to the requested cp.
    if ((LONG) _txtptr.GetCp() != cp)
    {
        _txtptr.SetCp(cp);
    }

    pchStart = pch;
    pchLim = pch + min((LONG) (_cpLim - cp + 1), cch);

    // Copy from the store into the buffer.
    while (pch < pchLim)
    {
        const TCHAR * pchRead;
        LONG cchFetch;

        pchRead = _txtptr.GetPch(cchFetch);

        Assert(pchRead != NULL);

        cchFetch = min(cchFetch, (LONG) (pchLim - pch));
        CopyMemory(pch, pchRead, cchFetch * sizeof(WCHAR));
        pch += cchFetch;
        if (pch < pchLim)
        {
            _txtptr.AdvanceCp(cchFetch);
        }
    }

    pch = pchStart;

    // Keep going while we have characters.
    while (pch < pchLim)
    {
        Assert(ptp != NULL);
        Assert(   *pch == WCH_NODE
               || ptp->IsText()
               || ptp->IsPointer()
               || (   ptp->IsBeginNode()
                   && !ptp->IsEdgeScope()
                  )
               || (   ptp->IsBeginNode()
                   && cchRemaining > 0
                  )
              );

        switch (ptp->Type())
        {
        case CTreePos::NodeBeg:
        {
            if (ptp->NodeCch())
            {
                // Handle element begin processing.
                CTreeNode * ptn = ptp->Branch();
                CElement * pElement = ptn->Element();

                Assert(ptn != NULL);

                // Update the tree node for the text format
                ptnText = ptn;

                if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                    pElement->Tag() == ETAG_BR ||
                    pElement->IsBlockElement())
                {
                    // If the element would force a new line to be created then
                    // replace the node with a CR and cut short the processing.
                    *pch++ = WCH_CR;
                    pchLim = pch;
                }
                else
                {
                    if (!pElement->ShouldHaveLayout())
                    {
                        // We are transitioning into an element's scope. We
                        // need to check to see if the direction level of the
                        // CCharFormat has changed.
                        const CCharFormat * pCF = ptn->GetCharFormat();

                        if (pCF->_fBidiEmbed)
                        {
                            // We've changed levels, so generate a character which
                            // describes the transition.
                            *pch = ((!pCF->_fBidiOverride) ?
                                    (!pCF->_fRTL ? WCH_LRE : WCH_RLE) :
                                    (!pCF->_fRTL ? WCH_LRO : WCH_RLO));
                        }
                        pch++;
                    }
                    else if (pElement->GetUpdatedLayout() != _pFlowLayout)
                    {
                        // We are entering an element which has its own layout. This will
                        // be handled as an embedding, so all we need to do is treat all
                        // the text under the element as a single neutral run.
                        LONG cchEmbed;
                        CTreePos * ptpEnd = NULL;

                        if (cchRemaining == 0)
                        {
                            // cchRemaining is the number of characters under the
                            // element plus the begin and end node characters.
                            pElement->GetTreeExtent(NULL, &ptpEnd);
                            Assert(ptpEnd != NULL && ptpEnd->IsEndNode() &&
                                   ptpEnd->Branch()->Element() == pElement);
                            cchRemaining = ptpEnd->GetCp() - (pch - pchStart + cp) + 1;
                        }

                        cchEmbed = min(cchRemaining, (LONG) (pchLim - pch));
                        cchRemaining -= cchEmbed;
                        while (cchEmbed--)
                        {
                            *pch++ = WCH_SYNTHETICEMBEDDING;
                        }
                        if (cchRemaining == 0)
                        {
                            // Advance the ptp to the end of the element.
                            if (ptpEnd != NULL)
                            {
                                ptp = ptpEnd;
                            }
                            else
                            {
                                pElement->GetTreeExtent(NULL, &ptp);
                                Assert(ptp != NULL && ptp->IsEndNode() &&
                                       ptp->Branch()->Element() == pElement);
                            }
                        }
                    }
                    else
                    {
                        // This is just the beginning of the flow layout. Skip it.
                        Assert(pElement->GetUpdatedLayout() == _pFlowLayout);
                        Assert(ptp->GetCp() == _cpFirst);
                        pch++;
                    }
                }
            }
            break;
        }
        case CTreePos::NodeEnd:
        {
            if (ptp->NodeCch())
            {
                // Handle element end processing.
                CTreeNode * ptn = ptp->Branch();
                CElement * pElement = ptn->Element();

                Assert(ptn != NULL);

                // Update the tree node for the text format
                ptnText = ptn->Parent();

                if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                    pElement->Tag() == ETAG_BR ||
                    pElement->IsBlockElement() ||
                    pElement->GetUpdatedLayout() == _pFlowLayout)
                {
                    // If the element would force a new line to be created then
                    // replace the node with a CR and cut short the processing.
                    *pch = WCH_CR;
                    pchLim = pch;
                }
                else
                {
                    Assert(!pElement->ShouldHaveLayout());

                    // We are transitioning out of an element's scope. We
                    // need to check to see if the direction level of the
                    // CCharFormat has changed.
                    if (ptn->GetCharFormat()->_fBidiEmbed)
                    {
                        // We've changed levels, so generate a PDF.
                        *pch = WCH_PDF;
                    }
                }
                pch++;
            }
            break;
        }
        case CTreePos::Text:
        {
            LONG cchText;
            Assert(ptnText != NULL);
            const CCharFormat * pCF = ptnText->GetCharFormat();

            // Return a text run.
            if (cchRemaining == 0)
            {
                cchRemaining = ptp->Cch();
            }
            cchText = min((LONG) (pchLim - pch), cchRemaining);
            if (pCF->_bCharSet == SYMBOL_CHARSET)
            {
                WCHAR * pchSymbol;
                for (pchSymbol = pch + cchText - 1;
                     pchSymbol >= pch;
                     pchSymbol--)
                {
                    *pchSymbol = WCH_SYNTHETICEMBEDDING;
                }
            }
            pch += cchText;
            cchRemaining -= cchText;
            break;
        }
#if DBG==1
        default:
            // The only other type we should encounter are pointers.
            Assert(ptp->Type() == CTreePos::Pointer);
            break;
#endif
        }

        // Update ptp.
        if (!cchRemaining)
        {
            ptp = ptp->NextTreePos();
        }
    }

    if ((cchRemaining == 0) && ptp && ptp->IsText())
    {
        cchRemaining = ptp->Cch();
    }

    cch = (pch - pchStart);
    *pptp = ptp;
    *pcchRemaining = cchRemaining;

    return cch;
}


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcEmbedding
//
//  Synopsis:   Translates an embedding, override, or PDF character into the
//              appropriate DIRCLS. This is needed because all these characters
//              are in the same partition. If they were in different partitions
//              we wouldn't need this.
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcEmbedding[5] =
{
    LRE,    // WCH_LRE (LTR Embedding)
    RLE,    // WCH_RLE (RTL Embedding)
    PDF,    // WCH_PDF (Pop directional formatting)
    LRO,    // WCH_LRE (LTR Override)
    RLO,    // WCH_RLO (RTL Override)
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcNumeric
//
//  Synopsis:   Translates an ENM into an ENL, ENR, or ANM based on the
//              preceeding strong character.
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcNumeric[3] =
{
    ENL,    // LTR ENM
    ENR,    // RTL ENM
    ANM,    // ARA ENM
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_adcNeutral
//
//  Synopsis:   Translates a neutral into LTR or RTL based on the base
//              embedding direction and the bounding characters. The table is
//              constructed as s_adcNeutral[fRTLEmbedding][dcLead][dcTrail].
//
//-----------------------------------------------------------------------------
const DIRCLS
CBidiLine::s_adcNeutral[2][6][6] =
{
//  Table for LTR embedding. First class is in the rows, second class is the columns.
//  LTR     RTL     ARA     ANM     ENL     ENR
    LTR,    LTR,    LTR,    LTR,    LTR,    LTR,    // LTR
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // RTL
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ARA
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ANM
    LTR,    LTR,    LTR,    LTR,    LTR,    LTR,    // ENL
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ENR

//  Table for RTL embedding. First class is in the rows, second class is the columns.
//  LTR     RTL     ARA     ANM     ENL     ENR
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // LTR
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // RTL
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ARA
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ANM
    LTR,    RTL,    RTL,    RTL,    LTR,    RTL,    // ENL
    RTL,    RTL,    RTL,    RTL,    RTL,    RTL,    // ENR
};


//-----------------------------------------------------------------------------
//
//  Table:      CBidiLine::s_abLevelOffset
//
//  Synopsis:   Translates a DIRCLS into a level offset to be added to the base
//              embedding level. The table is constructed as
//              s_abLevelOffset[fRTLEmbedding][dc].
//
//-----------------------------------------------------------------------------
const BYTE
CBidiLine::s_abLevelOffset[2][6] =
{
//  Table for LTR embedding.
    0,  // LTR
    1,  // RTL
    1,  // ARA
    2,  // ANM
    0,  // ENL
    2,  // ENR

//  Table for RTL embedding.
    1,  // LTR
    0,  // RTL
    0,  // ARA
    1,  // ANM
    1,  // ENL
    1,  // ENR
};


//+----------------------------------------------------------------------------
//
//  Function:   CchContextFromScript
//
//  Synopsis:   We return a default script ID based on the language id passed
//              in. There is usually a 1:1 mapping here, but there are
//              exceptions for FE langs. In these cases we try to pick a unique
//              script ID.
//
//  Returns:    Script ID matching the lang.
//
//-----------------------------------------------------------------------------

static const BYTE s_acchContextFromLang[] = 
{
    0,      // LANG_NEUTRAL     0x00
    6,      // LANG_ARABIC      0x01
    0,      // LANG_BULGARIAN   0x02
    0,      // LANG_CATALAN     0x03
    0,      // LANG_CHINESE     0x04
    0,      // LANG_CZECH       0x05
    0,      // LANG_DANISH      0x06
    0,      // LANG_GERMAN      0x07
    0,      // LANG_GREEK       0x08
    0,      // LANG_ENGLISH     0x09
    0,      // LANG_SPANISH     0x0a
    0,      // LANG_FINNISH     0x0b
    0,      // LANG_FRENCH      0x0c
    4,      // LANG_HEBREW      0x0d
    0,      // LANG_HUNGARIAN   0x0e
    0,      // LANG_ICELANDIC   0x0f
    0,      // LANG_ITALIAN     0x10
    0,      // LANG_JAPANESE    0x11
    0,      // LANG_KOREAN      0x12
    0,      // LANG_DUTCH       0x13
    0,      // LANG_NORWEGIAN   0x14
    0,      // LANG_POLISH      0x15
    0,      // LANG_PORTUGUESE  0x16
    0,      //                  0x17
    0,      // LANG_ROMANIAN    0x18
    0,      // LANG_RUSSIAN     0x19
    0,      // LANG_SERBIAN     0x1a
    0,      // LANG_SLOVAK      0x1b
    0,      // LANG_ALBANIAN    0x1c
    0,      // LANG_SWEDISH     0x1d
    3,      // LANG_THAI        0x1e
    0,      // LANG_TURKISH     0x1f
    6,      // LANG_URDU        0x20
    0,      // LANG_INDONESIAN  0x21
    0,      // LANG_UKRAINIAN   0x22
    0,      // LANG_BELARUSIAN  0x23
    0,      // LANG_SLOVENIAN   0x24
    0,      // LANG_ESTONIAN    0x25
    0,      // LANG_LATVIAN     0x26
    0,      // LANG_LITHUANIAN  0x27
    0,      //                  0x28
    6,      // LANG_FARSI       0x29
    0,      // LANG_VIETNAMESE  0x2a
    0,      // LANG_ARMENIAN    0x2b
    0,      // LANG_AZERI       0x2c
    0,      // LANG_BASQUE      0x2d
    0,      //                  0x2e
    0,      // LANG_MACEDONIAN  0x2f
    0,      //                  0x30
    0,      //                  0x31
    0,      //                  0x32
    0,      //                  0x33
    0,      //                  0x34
    0,      //                  0x35
    0,      // LANG_AFRIKAANS   0x36
    0,      // LANG_GEORGIAN    0x37
    0,      // LANG_FAEROESE    0x38
    13,     // LANG_HINDI       0x39
    0,      //                  0x3a
    0,      //                  0x3b
    0,      //                  0x3c
    0,      //                  0x3d
    0,      // LANG_MALAY       0x3e
    0,      // LANG_KAZAK       0x3f
    0,      //                  0x40
    0,      // LANG_SWAHILI     0x41
    0,      //                  0x42
    0,      // LANG_UZBEK       0x43
    0,      // LANG_TATAR       0x44
    13,     // LANG_BENGALI     0x45
    13,     // LANG_PUNJABI     0x46
    13,     // LANG_GUJARATI    0x47
    13,     // LANG_ORIYA       0x48
    13,     // LANG_TAMIL       0x49
    13,     // LANG_TELUGU      0x4a
    13,     // LANG_KANNADA     0x4b
    13,     // LANG_MALAYALAM   0x4c
    13,     // LANG_ASSAMESE    0x4d
    13,     // LANG_MARATHI     0x4e
    13,     // LANG_SANSKRIT    0x4f
    0,      //                  0x50
    0,      //                  0x51
    0,      //                  0x52
    0,      //                  0x53
    0,      //                  0x54
    0,      //                  0x55
    0,      //                  0x56
    13,     // LANG_KONKANI     0x57
    13,     // LANG_MANIPURI    0x58
    6,      // LANG_SINDHI      0x59
    0,      //                  0x5a
    0,      //                  0x5b
    0,      //                  0x5c
    0,      //                  0x5d
    0,      //                  0x5e
    0,      //                  0x5f
    6,      // LANG_KASHMIRI    0x60
    13,     // LANG_NEPALI      0x61
};

BYTE
CchContextFromScript(
    WORD eScript)
{
    const SCRIPT_PROPERTIES * pProp = GetScriptProperties(eScript);
    LANGID lang;

    Assert(pProp != NULL);
    lang = PRIMARYLANGID(pProp->langid);
    if (lang >= 0 && lang < sizeof(s_acchContextFromLang) / sizeof(s_acchContextFromLang[0]))
    {
        return s_acchContextFromLang[lang];
    }
    else
    {
        return sidDefault;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CComplexRun::ComputeAnalysis
//
//  Synopsis:   Compute the first SCRIPT_ANALYSIS in the string in pch.
//
//  Returns:    True if the run needs to be glyphed, otherwise false.
//
//-----------------------------------------------------------------------------

void
CComplexRun::ComputeAnalysis(
    const CFlowLayout * pFlowLayout,
    BOOL fRTL,                          // RTL paragraph/line
    BOOL fForceGlyphing,
    WCHAR chNext,
    WCHAR chPassword,
    COneRun * por,
    COneRun * porTail,
    DWORD uLangDigits,
    CBidiLine * pBidiLine)
{
    CStackDataAry<SCRIPT_ITEM, 64> aryItem(Mt(CComplexRunComputeAnalysis_aryAnalysis_pv));
    CStr strText;
    const WCHAR * pch = por->_pchBase;
    LONG cch = por->_lscch;
    HRESULT hr;
    INT cRuns = 0;
    INT iItem;
    WORD eScript;
    BOOL fNumeric;
    BOOL fUseControlState = fRTL;
    SCRIPT_CONTROL sControl = {0};
    SCRIPT_STATE sState = {0};

    // Zap the _Analysis structure and initialize fRTL and fLogicalOrder.
    memset(&_Analysis, 0, sizeof(SCRIPT_ANALYSIS));
    _Analysis.fRTL = fRTL;
    _Analysis.fLogicalOrder = TRUE;

    // We disable glyphing when we're dealing with passwords or symbols. Also,
    // if glyphing causes crashes (Win95FE) then bypass it and return. The net
    // effect of this is that we render as if we didn't have USP loaded.
    if (chPassword || por->GetCF()->_bCharSet == SYMBOL_CHARSET ||
        g_fExtTextOutGlyphCrash)
    {
        _Analysis.eScript = SCRIPT_UNDEFINED;
        return;
    }

    if (fForceGlyphing && chNext != WCH_NULL)
    {
        if (THR(strText.Set(pch, cch)) == S_OK &&
            THR(strText.Append(&chNext, 1)) == S_OK)
        {
            pch = strText;
            cch++;
        }
    }

    // set up state and control
    sState.fArabicNumContext = por->GetCF()->_fRTL;
    sState.uBidiLevel = (fRTL ? 1 : 0);

    sControl.uDefaultLanguage = uLangDigits;

    if (g_iNumShape != NUMSHAPE_NONE && uLangDigits != LANG_NEUTRAL)
    {
        sState.fDigitSubstitute = TRUE;
        fUseControlState = TRUE;
    }

    // Call ScriptItemize().
    if(g_bUSPJitState == JIT_OK)
        hr = ::ScriptItemize(pch, 
                             cch, 
                             64, 
                             fUseControlState ? &sControl : NULL, 
                             fUseControlState ? &sState : NULL, 
                             &aryItem, 
                             &cRuns);
    else
        hr = E_PENDING;

    if (FAILED(hr))
    {
        if(hr == USP10_NOT_FOUND)
        {
            g_csJitting.Enter();
            if(g_bUSPJitState == JIT_OK)
            {
                g_bUSPJitState = JIT_PENDING;

                // We must do this asyncronously.
                IGNORE_HR(GWPostMethodCall(pFlowLayout->Doc(), 
                                           ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 
                                           0, FALSE, "CDoc::FaultInUSP"));

            }
            g_csJitting.Leave();
        }

        // If ScriptItemize() failed, set the script to SCRIPT_UNDEFINED. This
        // will cause the run to be handled as a regular text run, which, while
        // not acurate, may be legible.
        _Analysis.eScript = SCRIPT_UNDEFINED;
        return;
    }

    // Make sure this is the right size (cRuns + sentinel item).
    Assert(cRuns + 1 == aryItem.Size());

    eScript = aryItem[0].a.eScript;
    fNumeric = IsNumericScript(eScript);

    // Accumulate all the items which have the same script.
    for (iItem = 1; iItem < cRuns && aryItem[iItem].a.eScript == eScript; iItem++);

    // If we're not going to be glyphing this run then we can accumulate
    // additional items.
    if (!fForceGlyphing && uLangDigits == LANG_NEUTRAL && !IsComplexScript(eScript))
    {
        while (iItem < cRuns && !IsComplexScript(aryItem[iItem].a.eScript))
        {
            iItem++;
        }
    }

    Assert(iItem < cRuns + 1);

    // Set the number of characters in the por covered by the _Analysis.
    por->_lscch = min(por->_lscch, (LONG) aryItem[iItem].iCharPos);

    Assert(por->_lscch > 0);

    // Determine the script to be used for shaping and set it in the _Analysis.
    if (IsComplexScript(eScript))
    {
        // If the first item needs to be handled as complex text, find all the
        // adjacent SCRIPT_ITEMs which are of the same script.
        _Analysis.eScript = eScript;
    }
    else if (uLangDigits != LANG_NEUTRAL && (fNumeric || IsNumericSeparatorRun(por, porTail, pBidiLine)))
    {
        // Merge all the adjacent SCRIPT_ITEMs which have the same
        // script.
        _Analysis.eScript = GetNumericScript(uLangDigits);
    }
    else
    {
        // Not a complex or numeric script. Set the script as
        // SCRIPT_UNDEFINED unless we are forcing glyphing.
        if (   fRTL
            || fForceGlyphing
            || InRange(*por->_pchBase, 0x1100, 0x11FF))
        {
            _Analysis.eScript = eScript;
        }
        else
        {
            _Analysis.eScript = SCRIPT_UNDEFINED;
        }
    }

    // Set the flag indicating whether or not this run needs to be glyphed.
    if (_Analysis.eScript != SCRIPT_UNDEFINED)
    {
        const CCharFormat * pCFBase = por->GetCF();
        BYTE bScriptCharSet = (BYTE)GetScriptCharSet(_Analysis.eScript);
        // HACKHACK (grzegorz): usp10.dll has a bug causing to return ANSI_CHARSET
        // for some scripts. It should return DEFAULT_CHARSET in this cases.
        // But this change affects a lot of cases which use Uniscribe.
        // To avoid any regressions we are doing the right thing only for Hangul.
        if (_Analysis.eScript == 18)
        {
            const SCRIPT_PROPERTIES * pProp = GetScriptProperties(_Analysis.eScript);
            Assert(pProp);
            bScriptCharSet = pProp->fAmbiguousCharSet ? DEFAULT_CHARSET : pProp->bCharSet;
        }

        Assert(pCFBase != NULL);

        por->_lsCharProps.fGlyphBased = TRUE;
        por->_lsCharProps.dcpMaxContext = CchContextFromScript(_Analysis.eScript);

        // Tweak the charset of the CCharFormat to match the script.
        if (IsComplexScript(_Analysis.eScript) &&
            pCFBase->_bCharSet != bScriptCharSet)
        {
            CCharFormat * pCF;

            if (!por->_fMustDeletePcf)
            {
                // We need a custom CF for the por. Base it on the current CF.
                pCF = por->GetOtherCF();
                *pCF = *pCFBase;
            }
            else
            {
                // We've already copied out a custom CF for the por, so we can
                // just scribble on it.
                pCF = (CCharFormat *) pCFBase;
            }

            pCF->_bCharSet = bScriptCharSet;
            pCF->_bCrcFont = pCF->ComputeFontCrc();
        }
    }
    else
    {
        por->_lsCharProps.fGlyphBased = FALSE;
    }
}


//-----------------------------------------------------------------------------
//
//  Function:   CComplexRun::IsNumericSeparatorRun
//
//  Synopsis:   Determines if por is a run consisting of a single numeric
//              separator character surrounded by numbers.
//
//  Returns:    True if the run is a text run consisting a numeric separator
//              bound by numbers.
//
//-----------------------------------------------------------------------------

BOOL
CComplexRun::IsNumericSeparatorRun(
    COneRun * por,
    COneRun * porTail,
    CBidiLine * pBidiLine)
{
    // Check if we've got a single numeric separator for the run.
    if (   por->_lscch != 1 
        || !pBidiLine
        || !IsNumericSeparatorClass(pBidiLine->DirClassFromChAndContext(*(por->_pchBase), 
                                    PRIMARYLANGID(por->GetCF()->_lcid), SUBLANGID(por->GetCF()->_lcid)))
       )
    {
        return FALSE;
    }

    // Check for a number preceeding the por. We can just look back in the por
    // list to do this.
    if (porTail == por)
    {
        porTail = porTail->_pPrev;
    }
    while (porTail != NULL && !(porTail->IsNormalRun() && porTail->_pchBase != NULL))
    {
        porTail = porTail->_pPrev;
    }
    if (porTail == NULL || !InRange(*(porTail->_pchBase + porTail->_lscch - 1), '0', '9'))
    {
        return FALSE;
    }

    // Check for a number following the por. Usually we'll just be able to look
    // in the text store that was originally attached to this por (before it
    // was chopped up), but sometimes we may need to go to the backing store,
    // in which case we have to watch for both the text and the nodes (we want
    // to ignore non-displaying nodes (like <span>) but anything else causes us
    // to evaluate).
    if (por->_lscchOriginal > 1)
    {
        if (!InRange(*(por->_pchBaseOriginal + 1), '0', '9'))
        {
            return FALSE;
        }
    }
    else
    {
        CTreePos * ptp = por->_ptp;
        CTxtPtr txtptr(ptp->GetMarkup(), por->_lscpBase - por->_chSynthsBefore);
        WCHAR ch;

        while ((ch = txtptr.NextChar()) == WCH_NODE)
        {
            ptp = ptp->NextTreePos();

            while(ptp->IsPointer())
            {
                ptp = ptp->NextTreePos();
            }

            Assert(ptp->IsNode() && ptp->Branch() != NULL);

            CElement * pElement = ptp->Branch()->Element();

            if (pElement->HasFlag(TAGDESC_OWNLINE) ||
                pElement->Tag() == ETAG_BR ||
                pElement->ShouldHaveLayout())
            {
                return FALSE;
            }
        }
        if (!InRange(ch, '0', '9'))
        {
            return FALSE;
        }
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
//
//  Function:   NoSpaceLangBrkcls
//
//  Synopsis:   Makes a SCRIPT_ANALYSIS for the run. This is used by Uniscribe
//              functions for Complex Text handling. The SCRIPT_ANALYSIS is
//              stored in the plsrun for multiple uses.
//
//  Arguments:  plsrun              pointer to the run
//              cp                  the cp to evaluate
//              pbrkclsAfter        Can we break after the current cp?
//              pbrkclsBefore       Can we break before the current cp?
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
#define NSL_BREAK_AFTER  0x10
#define NSL_BREAK_BEFORE 0xee
#define NSL_BREAK_TOTAL  0xff

void
CComplexRun::NoSpaceLangBrkcls(CMarkup * pMarkup, LONG cpLineStart, LONG cp, BRKCLS* pbrkclsAfter, BRKCLS* pbrkclsBefore)
{
    long    cchBefore = 0;
    long    cchAfter = 0;

    if(cp < (LONG) _ThaiWord.cp || cp >= (LONG) (_ThaiWord.cp + _ThaiWord.cch))
    {
        // The CP is not in the currently cached word. Bummer. We'll have to
        // compute the word position and length.

        HRESULT hr;
        const TCHAR * pch;
        TCHAR aryItemize[NSL_BREAK_TOTAL];
        unsigned short aryNodePos[NSL_BREAK_TOTAL];
        CStackDataAry<SCRIPT_ITEM, 8> aryItems(Mt(CComplexRunNoSpaceLangBrkcls_aryItems_pv));
        SCRIPT_LOGATTR arySLA[NSL_BREAK_TOTAL];
        int     cItems;
        int     nItem;
        long    cchCtrlBefore = 0;
        long    cchCtrlAfter = 0;
        long    cch;
        long    cchTotal;
        long    cchValid;
        long    ichBreakBefore;
        long    ichBreakAfter;
        CTxtPtr tp(pMarkup, cp);
        TCHAR chCur;

        // Set up for ScriptItemize(). We need to re-itemize the string instead
        // of using the cached _Analysis struct because we don't know how many
        // characters are involved.

        // Make sure the current character is ThaiType
        Assert(NoWhiteBetweenWords(tp.GetChar()));

        // Advance until NSL_BREAK_AFTER characters have passed or a non-ThaiType character
        // is encountered
        while(cchAfter < NSL_BREAK_AFTER)
        {
            chCur = tp.NextChar();
            if(NoWhiteBetweenWords(chCur))
            {
                cchAfter++;
            }
            else if(chCur == WCH_NODE)
            {
                cchCtrlAfter++;
            }
            else
            {
                break;
            }
        }

        // Back up until NSL_BREAK_BEFORE characters have passed or a non-ThaiType character
        // is encountered, or we have arrived to the beginning of the current
        // line. Thai breaking has trouble figuring out correct word break
        // context, so we need to help by beginning at a valid context.
        tp.SetCp(cp);
        while(cchBefore < NSL_BREAK_BEFORE && cp - cchBefore > cpLineStart)
        {
            chCur = tp.PrevChar();
            if(NoWhiteBetweenWords(chCur))
            {
                cchBefore++;
            }
            else if(chCur == WCH_NODE)
            {
                cchCtrlBefore++;
            }
            else
            {
                break;
            }
        }

        // Position the tp to the start of the Thai-type text.
        tp.SetCp(cp - cchBefore - cchCtrlBefore);

        // Get a pointer to the Thai string. We'll only copy data if we must.
        pch = tp.GetPch(cchValid);
        cch = cchBefore + cchAfter + 1;
        cchTotal = cch + cchCtrlBefore + cchCtrlAfter;

        // Strip out any control characters
        long lCount = 0;
        long lTotal = 0;
        long lNode = 0;
        long cchChecked = cchValid;

        while(lCount < cch)
        {
            Assert(lTotal <= cchTotal);

            if(*pch != WCH_NODE)
            {
                Assert(NoWhiteBetweenWords(*pch));

                aryItemize[lCount] = *pch;
                aryNodePos[lCount] = lNode;
                lCount++;
            }
            else
            {
                lNode++;
            }
            lTotal++;
            cchValid--;

            if(cchValid > 0)
            {
                pch++;
            }
            else if(lCount < cch)
            {
                // we've encountered a gap and need to get some more 
                // characters into the pch
                tp.AdvanceCp(cchChecked);
                pch = tp.GetPch(cchValid);
                cchChecked = cchValid;
            }
        }
        Assert(cch == lCount);

        // Prepare SCRIPT_ITEM buffer
        if (FAILED(aryItems.Grow(8)))
        {
            // We should always be able to grow to 8 itemse as we are based on
            // a CStackDataAry of this size.
            Assert(FALSE);
            goto Error;
        }

        // Call ScriptItemize() wrapper in usp.cxx.
        if(g_bUSPJitState == JIT_OK)
            hr = ScriptItemize(aryItemize, cch, 16, 
                               NULL, NULL, &aryItems, &cItems);
        else
            hr = E_PENDING;

        if (FAILED(hr))
        {
            if(hr == USP10_NOT_FOUND)
            {
                g_csJitting.Enter();
                if(g_bUSPJitState == JIT_OK)
                {
                    g_bUSPJitState = JIT_PENDING;
 
                    // We must do this asyncronously.
                    IGNORE_HR(GWPostMethodCall(pMarkup->Doc(), 
                                               ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 
                                               0, FALSE, "CDoc::FaultInUSP"));

                }
                g_csJitting.Leave();
           }
            // ScriptItemize() failed (for whatever reason). We are unable to
            // break, so assume we've got a single word and return.
            goto Error;
        }

        // Find the SCRIPT_ITEM containing cp.
        for(nItem = aryItems.Size() - 1;
            cchBefore < aryItems[nItem].iCharPos;
            nItem--);
        if (nItem < 0 || nItem + 1 >= aryItems.Size())
        {
            // Somehow the SCRIPT_ITEM array has gotten messed up. We can't
            // break, so assume we've got a single word and return.
            goto Error;
        }

        // NB (mikejoch) eScript may have been nuked in GetGlyphs(). If so then
        // this won't match up, but generally it should.
        Assert(_Analysis.eScript == SCRIPT_UNDEFINED ||
               aryItems[nItem].a.eScript == _Analysis.eScript);

        // Adjust pch and cch to correspond to the text indicated by this item.
        cch = aryItems[nItem + 1].iCharPos - aryItems[nItem].iCharPos;
        cchBefore -= aryItems[nItem].iCharPos;
        cchAfter = cch - cchBefore - 1;
        Assert(cchBefore >= 0 && cchAfter >= 0 && cchBefore + cchAfter + 1 == cch);

        // do script break
        hr = ScriptBreak(aryItemize + aryItems[nItem].iCharPos, cch,
                         (SCRIPT_ANALYSIS *) &aryItems[nItem].a,
                         arySLA);

        if (FAILED(hr))
        {
            // ScriptBreak() failed (for whatever reason). We are unable to break,
            // so assume we've got a single word and return.
            goto Error;
        }

        // begin checking for the break before on the current CP
        for(ichBreakBefore = cchBefore;
            ichBreakBefore > 0 && !arySLA[ichBreakBefore].fSoftBreak;
            ichBreakBefore--);

        _ThaiWord.cp = cp - (cchBefore - ichBreakBefore);

        for(ichBreakAfter = cchBefore + 1;
            ichBreakAfter < cch && !arySLA[ichBreakAfter].fSoftBreak;
            ichBreakAfter++);

        Assert(ichBreakAfter <= cch && ichBreakAfter - ichBreakBefore < 64);

        // get the delta between node counts in the word 
        long offset1 = ichBreakBefore + aryItems[nItem].iCharPos;
        long offset2 = ichBreakAfter + aryItems[nItem].iCharPos - 1;

        _ThaiWord.cch = (ichBreakAfter - ichBreakBefore) + 
                        (aryNodePos[offset2] - aryNodePos[offset1]);

    }

    Assert(cp >= (LONG) _ThaiWord.cp && cp < (LONG) (_ThaiWord.cp + _ThaiWord.cch));

    // Can we break before the character?
    if(cp != (LONG) _ThaiWord.cp)
    {
        *pbrkclsBefore = CLineServices::brkclsThaiMiddle;
    }
    else
    {
        *pbrkclsBefore = CLineServices::brkclsThaiFirst;
    }

    // Can we break after the character?
    if(cp != (LONG) (_ThaiWord.cp + _ThaiWord.cch - 1))
    {
        *pbrkclsAfter = CLineServices::brkclsThaiMiddle;
    }
    else
    {
        *pbrkclsAfter = CLineServices::brkclsThaiLast;
    }

    return;

Error:

    *pbrkclsBefore = (cchBefore == 0 ? CLineServices::brkclsThaiFirst : CLineServices::brkclsThaiMiddle);
    *pbrkclsAfter = (cchAfter == 0 ? CLineServices::brkclsThaiLast : CLineServices::brkclsThaiMiddle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsm.cxx ===
/*
 *  LSM.CXX -- CLSMeasurer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/27/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include "lscache.hxx"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_LSCRLINE_H_
#define X_LSCRLINE_H_
#include <lscrline.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#define DEF_FRAMEMARGIN     _pci->DeviceFromTwipsX(TWIPS_FROM_POINTS(2))
// BRECREC_COUNT should be the maximum number of ILS objects we can embed one
// inside the other. Currently that is (16 reverse) + (1 NOBR) + (1 Ruby).
#define BRECREC_COUNT       20

MtDefine(CLSMeasurer, Layout, "CLSMeasurer")
MtDefine(CLSLineChunk, Layout, "CLSLineChunk")

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::CLSMeasurer
//
// Synopsis:    Ctors for CLSMeasurer
//
//+----------------------------------------------------------------------------
CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, CCalcInfo * pci)
{
    CTreePos *ptpFirst, *ptpLast;

    Init(pdp, pci, TRUE);
    _pFlowLayout->GetContentTreeExtent(&ptpFirst, &ptpLast);
    do
    {
        ptpFirst = ptpFirst->NextTreePos();
    }
    while (ptpFirst->GetCch() == 0);
    SetPtp(ptpFirst, -1);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, LONG cp, CCalcInfo * pci)
{
    Init(pdp, pci, TRUE);
    SetCp(cp, NULL);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, CDocInfo * pdci, BOOL fStartUpLSDLL)
{
    Init(pdp, CalcInfoFromDocInfo(pdp, pdci), fStartUpLSDLL);
    SetCp(pdp->GetFirstCp(), NULL);
}

CLSMeasurer::CLSMeasurer (const CDisplay* const pdp, LONG cp, CDocInfo * pdci)
{
    Init(pdp, CalcInfoFromDocInfo(pdp, pdci), TRUE);
    SetCp(cp, NULL);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Init
//
// Synopsis:    Default inits -- called only from the ctors.
//
//+----------------------------------------------------------------------------
void
CLSMeasurer::Init(const CDisplay * pdp, CCalcInfo *pci, BOOL fStartUpLSDLL)
{
    CTreePos * ptpContentEnd;
    _pFlowLayout        = pdp->GetFlowLayout();
    _pFlowLayout->GetContentTreeExtent(&_ptpCurrent, &ptpContentEnd);
    Assert( _ptpCurrent && ptpContentEnd );
    _cp                 = _ptpCurrent->GetCp() + 1;
    _cpEnd              = ptpContentEnd->GetCp();
    Assert(_cp <= _cpEnd);
    _cchPreChars        = 0;
    _pdp                = pdp;
    _fLastWasBreak      = FALSE;
    _pci                = NULL;
    _hdc                = NULL;
    _fBrowseMode        = !_pFlowLayout->IsEditable();
    _fMeasureFromTheStart = FALSE;
    _pRunOwner          = _pFlowLayout;
    _fHasNestedLayouts  = FALSE;
    SetCalcInfo(pci);
    _hdc = _pci->_hdc;
    _pDispNodePrev      = NULL;
    _fPseudoLineEnabled = FALSE;
    _fPseudoLetterEnabled = FALSE;
    _fPseudoElementEnabled = FALSE;
    _fBreaklinesFromStyle = FALSE;

    _pLS = TLS(_pLSCache)->GetFreeEntry(_pdp->GetMarkup(), fStartUpLSDLL);
    if (_pLS)
        _pLS->SetPOLS(this, ptpContentEnd);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Reinit
//
// Synopsis:    reinitializes measurer for use across multiple table cells
//
//+----------------------------------------------------------------------------

void
CLSMeasurer::Reinit(const CDisplay * pdp, CCalcInfo *pci)
{
    CTreePos *ptpFirst, *ptpLast;

    Assert(pdp);

    // Deinitialize measurer.
    Deinit();

    // 1. Reinitialize measurer.
    Init(pdp, pci, TRUE);

    // 2. setup the cp and _ptp
    _pFlowLayout->GetContentTreeExtent(&ptpFirst, &ptpLast);
    do
    {
        ptpFirst = ptpFirst->NextTreePos();
    }
    while (ptpFirst->GetCch() == 0);
    SetPtp(ptpFirst, -1);

    Assert(_pdp);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::Deinit
//
// Synopsis:    Default inits -- called only from the ctors.
//
//+----------------------------------------------------------------------------

void
CLSMeasurer::Deinit()
{
    if (_pLS)
    {
        _pLS->ClearPOLS();

        if (_pdp)
            TLS(_pLSCache)->ReleaseEntry(_pLS);

        _pLS = NULL;
    }
    Assert(_aryFormatStash_Line.Size() == 0);
    Assert(_aryFormatStashForNested_Line.Size() == 0);
    Assert(_aryFormatStash_Letter.Size() == 0);
    Assert(_aryFormatStashAfterDisable_Letter.Size() == 0);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::SetCalcInfo
//
// Synopsis:    Setup the calc info in the LSMeasurer
//
//+----------------------------------------------------------------------------
void
CLSMeasurer::SetCalcInfo(CCalcInfo * pci)
{
    if (!pci)
    {
        _CI.Init(_pFlowLayout);
        _pci = &_CI;
    }
    else
    {
        _pci = pci;
    }
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::CalcInfoFromDocInfo
//
// Synopsis:
//
//+----------------------------------------------------------------------------
CCalcInfo *
CLSMeasurer::CalcInfoFromDocInfo(const CDisplay *pdp, CDocInfo * pdci)
{
    _pFlowLayout = pdp->GetFlowLayout();
    if (!pdci)
    {
        _CI.Init(pdp->GetFlowLayout());
    }
    else
    {
        _CI.Init(pdci, pdp->GetFlowLayout());
        _CI.SizeToParent(pdp->GetFlowLayout());
    }
    return &_CI;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::~CLSMeasurer
//
// Synopsis:    The dtor
//
//+----------------------------------------------------------------------------

CLSMeasurer::~CLSMeasurer()
{
    Deinit();
}

//+----------------------------------------------------------------------------
//
// Member:      SetCp
//
// Synopsis:    Setsup the cp of the measurer
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetCp(LONG cp, CTreePos *ptp)
{
    _cp = cp;
    if (ptp == NULL)
    {
         LONG notNeeded;
         Assert(_pFlowLayout->GetContentMarkup());
        _ptpCurrent = _pFlowLayout->GetContentMarkup()->TreePosAtCp(cp, &notNeeded, TRUE);
    }
    else
    {
        _ptpCurrent = ptp;
    }
    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      SetPtp
//
// Synopsis:    Setup measurer at this ptp and cp. If cp not specified, then
//              set it to the beginning of the ptp
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::SetPtp(CTreePos *ptp, LONG cp)
{
    Assert(ptp);
    if(!ptp)
    {
        return;
    }

    _ptpCurrent = ptp;
    _cp = (cp == -1) ? ptp->GetCp() : cp;

    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      Advance
//
// Synopsis:    Advances the measurer by the cch specified.
//
//-----------------------------------------------------------------------------
void
CLSMeasurer::Advance(long cch, CTreePos *ptp /* = NULL */)
{
    _cp += cch;
    if (ptp)
    {
        _ptpCurrent = ptp;
    }
    else
    {
        SetCp(_cp, NULL);
    }
    Assert(_ptpCurrent);
    Assert(   _ptpCurrent->GetCp() <= _cp
           && _ptpCurrent->GetCp() + _ptpCurrent->GetCch() >= _cp
          );
}


//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::InitLineSpace ()
//
// Synopsis:    Initializes a measurer object to have the same
//              line spacing state as the given one.
//
//
//-----------------------------------------------------------------------------
//
void
CLSMeasurer::InitLineSpace(const CLSMeasurer *pMe, CLinePtr &rpOld)
{
    // Zero it all out.
    NewLine(FALSE);

    // Set up the current cache from the given measurer.
    _fLastWasBreak   = pMe->_fLastWasBreak;

    // Flags given separately.
    _li._dwFlags() = rpOld->_dwFlags();
    _li._fPartOfRelChunk = rpOld->_fPartOfRelChunk;

    // Setup the pf
    CTreeNode *pNode = _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), rpOld->_cch, NULL, NULL, NULL);
    MeasureSetPF(pNode->GetParaFormat(), SameScope(pNode, _pdp->GetFlowLayout()->ElementContent()));
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::NewLine (fFirstInPara)
//
// Synopsis:    Initialize this measurer at the start of a new line
//
//-----------------------------------------------------------------------------

void CLSMeasurer::NewLine(
    BOOL fFirstInPara)
{
    _li.Init();                     // Zero all members

    if(fFirstInPara)
        _li._fFirstInPara = TRUE;   // Need to know if first in para

    // Can't calculate xLeft till we get an HDC.
    _li._xLeft = 0;

    _li._cch = 0;   // No characters to start.

}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::NewLine (&li)
//
// Synopsis:    Initialize this measurer at the start of a new line
//
//-----------------------------------------------------------------------------

void CLSMeasurer::NewLine(
    const CLineFull &li)
{
    _li           = li;
    _li._cch      = 0;
    _li._cchWhite = 0;
    _li._xWidth   = 0;

    // Can't calculate xLeft or xRight till we get an HDC
    _li._xLeft    = 0;
    _li._xRight   = 0;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureText (cch)
//
// Synopsis:    Measure a stretch of text from current running position.
//
//              HACKHACK (t-ramar): This function calls DiscardLine() at the
//              end, but we would like to keep information about Ruby Base
//              heights around for hit testing purposes.  Thus, there is an
//              optional parameter:
//                  pRubyInfo (out):  is a pointer to storage that holds the
//                                    ruby info of the ruby object that contains
//                                    this cp
//              It's also important to note that this value is ignored if
//              line flag FLAG_HAS_RUBY is not set.  In this case the value pointed
//              to by pRubyInfo will remain unchanged.
//
// Returns:     width of text (in device units), < 0 if failed
//
//-----------------------------------------------------------------------------

LONG CLSMeasurer::MeasureText(
    LONG cch,
    LONG cchLine,       // Number of characters to measure
    BOOL fAfterPrevCp,  // Return the trailing point of the previous cp (for an ambigous bidi cp)
    BOOL *pfComplexLine,
    BOOL *pfRTLFlow,      // only used in ViewServices
    RubyInfo *pRubyInfo)  // = NULL (default)
{

    CMarginInfo marginInfo;
    LONG xLeft  = _li._xLeft;
    LONG lRet   = -1;
    LONG cpStart = GetCp();
    LONG cpStartContainerLine;
    LSERR lserr = lserrNone;
    LONG cpToMeasureTill;
    CLineCore *pliContainer;
    UINT uiFlags = 0; 
    
    SetBreakLongLines(_ptpCurrent->GetBranch(), &uiFlags);

    lserr = PrepAndMeasureLine(&_li, &pliContainer, &cpStartContainerLine, &marginInfo, cchLine, uiFlags);
    if (lserr != lserrNone)
    {
        lRet = 0;
        goto Cleanup;
    }

    if (pfComplexLine)
        *pfComplexLine = (_pLS->_pBidiLine != NULL);

    if(pfRTLFlow)
        *pfRTLFlow = _li._fRTLLn;

    cpToMeasureTill = cpStart + cch;

    if(cpToMeasureTill > cpStartContainerLine || _pLS->_pBidiLine != NULL)
    {
        BOOL fRTLFlow;
        lRet = _pLS->CalculateXPositionOfCp(cpToMeasureTill, fAfterPrevCp, &fRTLFlow);

        //
        // To get correct position of cp within the line (which may be just part of a line, e.g. when
        // there is relative positioning), we need to 
        // (1) calculate the whole line (container line)
        // (2) subtract the offset of the line within the container line.
        // Note that we can't just calcluate subline, since there may be justification.
        //
        // The line's offset within the container line is equal to the difference 
        // between the line's offset from left margin and container line's offset from left margin.
        //
        lRet -= xLeft - pliContainer->oi()->_xLeft;

        // this returned parameter is only used in ViewServices 
        if(pfRTLFlow)
            *pfRTLFlow = fRTLFlow;
    }
    else
        lRet = 0;

    Assert(lRet >= 0 || _pLS->_fHasNegLetterSpacing);

    Advance(cch);
    if((_pLS->_lineFlags.GetLineFlags(_cp) & FLAG_HAS_RUBY) && pRubyInfo)
    {
        if(CurrBranch()->GetCharFormat()->_fIsRubyText)
        {
            RubyInfo *pTempRubyInfo = _pLS->GetRubyInfoFromCp(_cp);
            if(pTempRubyInfo)
            {
                memcpy(pRubyInfo, pTempRubyInfo, sizeof(RubyInfo));
            }
        }
    }

Cleanup:
    _pLS->DiscardLine();
    PseudoLineDisable();
    return lRet;

}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureRangeOnLine (ich, cch, li, paryChunks)
//
// Synopsis:    Measure a stretch of text starting at ich on the current line
//              and running for cch characters. The text may be broken into
//              multiple chunks if the line has reverse objects (runs with
//              mixed directionallity) in it. Other ILS objects may also cause
//              fragmentation.
//
// Returns:     The number of chunks in the range. Usually this will just be
//              one. If an error occurs it will be zero. The actual width of
//              text (in device units) is returned in paryChunks as paired
//              offsets from the beginning of the line. Thus, paryChunks[0]
//              will be the start of the first chunk (relative to the start of
//              the line) and paryChunks[1] will be the end of the first chunk.
//
// Comments:    The actual work of this function is actually done down in
//              CalculatePositionOfRangeOnLine() in CLineServices. This just
//              creates and destroys the line and lets that function do the
//              analysis on it.
//
//-----------------------------------------------------------------------------
LONG
CLSMeasurer::MeasureRangeOnLine(
    CElement *pElement,
    LONG ich,                       // Offset to first character in the range
    LONG cch,                       // Number of characters in the range
    const CLineCore &li,            // Information about the line
    LONG yPos,                      // The yPos of the line
    CDataAry<CChunk> * paryChunks,    // Array of chunks to return
    DWORD dwFlags)                  // RFE_FLAGS
{
    CMarginInfo marginInfo;
    LONG cpStart = GetCp() + ich;
    LONG cpEnd = cpStart + cch;

    LONG cpStartContainerLine;
    LSERR lserr;
    LONG cChunk;
    CLineCore * pliContainer;

    Assert(paryChunks != NULL);

    //
    // FUTURE (grzegorz): vertical alignment stuff may be moved to 
    // PrepAndMeasureLine(), but we need to investigate if other callers 
    // need vertical alignment information.
    //

    _pLS->_li = _li;

    lserr = PrepAndMeasureLine(&_li, &pliContainer, &cpStartContainerLine, &marginInfo, li._cch, 0);

    if (lserr == lserrNone)
    {
        LONG xShift;
        if (!pliContainer->IsRTLLine())
        {
            xShift = pliContainer->oi()->_xLeft - li.oi()->_xLeft;
        }
        else
        {
            xShift = pliContainer->_xRight - li._xRight;
        }

#if 0
        _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

        if (_pLS->_fHasVerticalAlign)
        {
            _pLS->_li._cch = _pLS->_cpLim - cpStartContainerLine;
            _pLS->VerticalAlignObjects(*this, 0);
        }
#endif

        if(dwFlags & RFE_TIGHT_RECTS)
        {
            // If the element cp's for which we need to compute the rect are completely
            // in the pre chars, then we do not do anything since the rect will be empty
            // as it is.
            if (cpEnd < _pLS->_cpStart)
            {
                Assert(cpEnd > _pLS->_cpStart - _cchPreChars);
                cChunk = 0;
            }
            else
            {
                COneRun *porRet = NULL;
                BOOL fIncludeBorders = (dwFlags & RFE_INCLUDE_BORDERS) ? TRUE : FALSE;
                LSCP lscpStart = _pLS->LSCPFromCP(max(cpStart, _pLS->_cpStart));
                LSCP lscpEnd = min(_pLS->LSCPFromCPCore(cpEnd, &porRet), _pLS->_lscpLim);

                //
                // We want to include all the trailing mbpcloses.
                //
                if (porRet)
                {
                    COneRun *porMBPClose = NULL;
                    porRet = porRet->_pNext;
                    while (porRet)
                    {
                        if (   (   porRet->IsSyntheticRun()
                                && porRet->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE
                               )
                            || porRet->IsAntiSyntheticRun()
                           )
                        {
                            if (!porRet->IsAntiSyntheticRun())
                                porMBPClose = porRet;
                            porRet = porRet->_pNext;
                        }
                        else
                        {
                            break;
                        }
                    }
                    if (porMBPClose)
                        lscpEnd = porMBPClose->_lscpBase;
                }
                
                if (   pElement
                    && fIncludeBorders
                    && pElement->GetFirstBranch()->HasInlineMBP()
                   )
                {
                    LONG mbpTop = 0;
                    LONG mbpBottom = 0;
                    CDataAry<CChunk> aryTemp(NULL);
                    CTreeNode *pNode = pElement->GetFirstBranch();
                    CBorderInfo borderInfo;
                    BOOL fBOLWrapped = FALSE;
                    BOOL fEOLWrapped = FALSE;
                    
                    LONG cpFirst = pElement->GetFirstCp() - 1;
                    if (cpFirst < _pLS->_cpStart - (_fMeasureFromTheStart ? 0 : _cchPreChars))
                    {
                        fBOLWrapped = TRUE;
                    }
                    LONG cpLast = pElement->GetLastCp() + 1;
                    if (cpLast >= _pLS->_cpLim)
                    {
                        fEOLWrapped = TRUE;
                    }
                    
                    FindMBPAboveNode(pElement, &mbpTop, &mbpBottom);
                    cChunk = _pLS->CalcRectsOfRangeOnLine(lscpStart,
                                                          lscpEnd, 
                                                          xShift,
                                                          yPos, 
                                                          &aryTemp, 
                                                          dwFlags,
                                                          mbpTop, mbpBottom);

                    pElement->GetBorderInfo(_pci, &borderInfo, TRUE, FALSE);
                    MassageRectsForInlineMBP(aryTemp, paryChunks, pNode,
                                             pNode->GetCharFormat(),
                                             pNode->GetFancyFormat(),
                                             borderInfo,
                                             pliContainer,
                                             FALSE, /* fIsPseudoMBP */
                                             FALSE, /* fSwapBorders */
                                             fBOLWrapped,
                                             fEOLWrapped,
                                             FALSE, /* DrawBackgrounds */
                                             FALSE /* DrawBorders */
                                            );
                }
                else
                {
                    dwFlags &= ~RFE_INCLUDE_BORDERS;
                    cChunk = _pLS->CalcRectsOfRangeOnLine(lscpStart,
                                                          lscpEnd, 
                                                          xShift,
                                                          yPos, 
                                                          paryChunks, 
                                                          dwFlags,
                                                          0, 0);
                }
            }
        }
        else
            cChunk = _pLS->CalcPositionsOfRangeOnLine(cpStart, cpEnd, xShift, paryChunks, dwFlags);
    }
    else
    {
        cChunk = 0;
    }

    _pLS->DiscardLine();
    PseudoLineDisable();
    return cChunk;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::MeasureLine (xWidthMax, cchMax, uiFlags, pliTarget)
//
// Synopsis:    Measure a line of text from current cp and determine line break.
//              On return *this contains line metrics for _pdd device.
//
// Returns:     TRUE if success, FALSE if failed
//
//-----------------------------------------------------------------------------

BOOL CLSMeasurer::MeasureLine(
    LONG xWidthMax,     // max width to process (-1 uses CDisplay width)
    LONG cchMax,        // Max chars to process (-1 if no limit)
    UINT uiFlags,       // Flags controlling the process (see Measure())
    CMarginInfo *pMarginInfo,
    LONG *pxMinLine)    // returns min line width required for tables(optional)
{
    BOOL fRet = TRUE;
    LONG lRet;

    // Compute line break
    lRet = Measure(xWidthMax, cchMax, uiFlags, pMarginInfo, pxMinLine);

    // Stop here if failed
    if(lRet == MRET_FAILED)
    {
        AssertSz(0,"Measure returned MRET_FAILED");
        fRet = FALSE;
        goto Cleanup;
    }

Cleanup:
    _pLS->DiscardLine();
    PseudoLineDisable();
    return fRet;
}


#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif


//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::LSDoCreateLine
//
// Synopsis:    Calls the lineservices LSCreateLine
//
//-----------------------------------------------------------------------------
HRESULT
CLSMeasurer::LSDoCreateLine(
    LONG cp,                  // IN
    CTreePos *ptp,            // IN
    CMarginInfo *pMarginInfo, // IN
    LONG xWidthMaxIn,         // IN
    const CLineFull * pli,    // IN
    BOOL fMinMaxPass,         // IN
    LSLINFO *plslinfo)        // OUT
    
{
    PLSC        plsc  = _pLS->GetContext();
    CCalcInfo  *pci   = GetCalcInfo();
    HRESULT     hr;
    LSDEVRES    lsdevres;
    BREAKREC    rgBreakRec[BRECREC_COUNT];
    DWORD       nBreakRec;
    LSLINFO     lslinfo;

    Assert(pci);
    AssertSz(!_pLS->_plsline, "plsline not freed, could be leaking memory here!");

    if (_pLS->_lsMode == CLineServices::LSMODE_MEASURER)
    {
        _pLS->_li._xMeasureWidth = fMinMaxPass ? -1 : xWidthMaxIn;
    }
    else
    {
        Assert(!fMinMaxPass);
        if (_pLS->_li._xMeasureWidth != -1)
            xWidthMaxIn = _pLS->_li._xMeasureWidth;
    }

    hr = THR(_pLS->Setup(xWidthMaxIn, cp, ptp, pMarginInfo, pli, fMinMaxPass));
    if (hr != S_OK)
        goto Cleanup;
    
    if (_cpEnd == 0)
        goto Cleanup;

    if (plslinfo == NULL)
        plslinfo = & lslinfo;

    SetupMBPInfoInLS(NULL);
    
    hr = THR(_pLS->CheckSetTables());
    if (hr)
        goto Cleanup;

    lsdevres.dxpInch = lsdevres.dxrInch = pci->GetResolution().cx;
    lsdevres.dypInch = lsdevres.dyrInch = pci->GetResolution().cy;
    hr = HRFromLSERR(LsSetDoc( plsc, TRUE, TRUE, &lsdevres ));
    if (hr)
        goto Cleanup;

    hr = HRFromLSERR(LsCreateLine( plsc, cp, pci->TwipsFromDeviceCeilX(_pLS->_xWidthMaxAvail),
                               NULL, 0, sizeof(rgBreakRec)/sizeof(BREAKREC), rgBreakRec, &nBreakRec,
                               plslinfo, &_pLS->_plsline ) );
    if (hr)
        goto Cleanup;

    _pLS->_lscpLim = plslinfo->cpLim;
    _pLS->_cpLim   = _pLS->CPFromLSCP(_pLS->_lscpLim);

    // PaulNel - We need to set this up in order to put widths into line
    // for bidi lines.
    if(_pLS->_pBidiLine)
    {
        long durWithTrailing, durWithoutTrailing;

        hr = _pLS->GetLineWidth(&durWithTrailing, &durWithoutTrailing);
        if (hr)
            goto Cleanup;
        _pLS->_li._xWidth = durWithTrailing;
    }

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::LSMeasure
//
// Synopsis:    Measures the line using lineservices and then sets up the
//              various li parameters.
//
//-----------------------------------------------------------------------------
HRESULT
CLSMeasurer::LSMeasure(
    CMarginInfo *pMarginInfo,
    LONG xWidthMaxIn,
    LONG * pxMinLineWidth )
{
    long           cp    = GetCp();
    HRESULT        hr    = S_OK;
    LSLINFO        lslinfo;
    long           durWithTrailing, durWithoutTrailing;
    DWORD          dwlf;
    BOOL           fLineHasBR;
    
    hr = THR( LSDoCreateLine(GetCp(), GetPtp(), pMarginInfo, xWidthMaxIn, NULL,
                             pxMinLineWidth != NULL, &lslinfo) );
    if (hr)
        goto Cleanup;

    if (_pLS->_fNeedRecreateLine)
    {
        _pLS->DiscardLine();
        hr = THR( LSDoCreateLine(GetCp(), GetPtp(), pMarginInfo, xWidthMaxIn, &_pLS->_li,
                                 pxMinLineWidth != NULL, &lslinfo) );
        if (hr)
            goto Cleanup;
    }

    hr = _pLS->GetLineWidth(&durWithTrailing, &durWithoutTrailing);
    if (hr)
        goto Cleanup;
    _pLS->_li._xWidth = durWithTrailing;

    //
    // We will now do all the cases where we might potentially reduce the
    // length of the line. To aid us in doing this we will use the line
    // flags to tell us if the stuff really needs to be done. If we do
    // end up reducing the length of the line, we need to recompute the
    // the flags. We will then pass these flags down to ComputeWhiteInfo.
    //
    {
        LONG cpLimOld = _pLS->_cpLim;
        BOOL fRetakeFlags = FALSE;
        
        dwlf = _pLS->_lineFlags.GetLineFlags(cpLimOld);

        fLineHasBR = dwlf & FLAG_HAS_A_BR;
        
        // Mimic the Nav BR bug, but don't bother if we're in a min-max pass.
        // NB (cthrash) We don't don't drop the BR if we have CSS text-jusitify,
        // since the justification rules can hinge on whether there's a BR on
        // the line or not.  Since Nav doesn't support text-justify, there's no
        // concert for compat.
        if (   fLineHasBR
            && !g_fInMoney98
            && !_pLS->_li._fJustified
           )
        {
            // Note: this call modifies _pLS->_cpLim
            _pLS->AdjustCpLimForNavBRBug(xWidthMaxIn, &lslinfo);
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }

        if (   (dwlf & FLAG_HAS_RELATIVE)
            &&  lslinfo.endr == endrNormal
           )
        {
            _pLS->AdjustForRelElementAtEnd();
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }

#if 0        
        if (   _pLS->_fWrapLongLines
            && _pLS->_li._xWidth > xWidthMaxIn
            && _pLS->_cpLim - cp > 1
           )
        {
            _pLS->AdjustForSpaceAtEnd();
            fRetakeFlags = _pLS->_cpLim < cpLimOld;
        }
#endif
        
        if (fRetakeFlags)
        {
            dwlf = _pLS->_lineFlags.GetLineFlags(_pLS->_cpLim);
        }
        else
        {
            Assert(_pLS->_cpLim == cpLimOld);
        }
    }
    
    _pLS->_li._cch = _pLS->_cpLim - cp;

    //
    // If this is a min-max pass, we need to deterine the correct widths.
    // Note that this is true even when there are aligned sites because
    // We will use that information to truncate the full min pass.
    //
    if (pxMinLineWidth)
    {
        Assert(_pLS->_fMinMaxPass);

        LONG dxMaxDelta;

        //
        // HACK (cthrash) For text, LS correctly computes the minimum value.
        // For embedded objects, however, LS assumes that the min and max
        // widths are the same, even though in the case of tables, for
        // example, these are typically not the same.  We therefore lie
        // to LS and tell that these embedded objects have the width of the
        // minimum width, and then in the post-pass sum the difference to
        // compute the true maximum width.
        //

        hr = HRFromLSERR(_pLS->GetMinDurBreaks( pxMinLineWidth, &dxMaxDelta ));
        if (hr)
            goto Cleanup;

        //
        // Also include the width for the margins!
        //
        *pxMinLineWidth += _pLS->_li._xLeft + _pLS->_li._xRight; // + _li._xOverHang
        // The line overhang is added into the min-line width in ComputeWhiteInfo
        // since its value is computed there.
        
        _pLS->_li._xWidth += dxMaxDelta;

    }

    // This is a bit funky. For lines ending at </P> which could not fit the </P>
    // glyph on the line we want to set _fEndSplayNotMeasured to be FALSE. This
    // would mean that later on in CalcAfterSpace, we would consume
    // atleast one ptp with a glyph (the one having the /P) before we stop consuming
    // more characters on the line.
    //
    // Now, the BR case: If we have a BR, then our ptp is *beyond* the last
    // ptp of the BR rather than at it. In this case we do not want to consume
    // any additional ptp's in CalcAfterSpace. Hence when we have a BR we
    // set _fEndSplayNotMeasured to be true.
    //
    _fEndSplayNotMeasured =  lslinfo.endr == endrNormal || fLineHasBR || _pLS->_li._fSingleSite;

    // LONG_MAX is the return value when (a) the only text on the line is
    // white, and (b) fFmiSpacesInfluenceHeight is not set in the PAP.
    // Since we do set the flag, our MultiLineHeight should never be LONG_MAX.

    // Arye: Trips all the time, yet things work. What's up?
    // This looks like a LS bug. The problem is that for a line with
    // only a BR on it, we get dvpDescent and dvpAscent to be correct
    // but dvpMultiLineHeight is not set.
    //Assert(lslinfo.dvpMultiLineHeight != LONG_MAX);

    ComputeHeights(&lslinfo);

    _pLS->ComputeWhiteInfo(&lslinfo, pxMinLineWidth, dwlf, durWithTrailing, durWithoutTrailing);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:    CMeasure::InitForMeasure
//
// Synopsis:    Initializes some basic members of the measurer.
//
// Arguments:   uiFlags -  Details in comment block of MeasureLine
//
// Return:      Return      -   0 for success
//                          -   MRET_FAILED if failed
//
//-----------------------------------------------------------------------------

LONG
CLSMeasurer::InitForMeasure(UINT uiFlags)
{
    CElement *pElementFL = _pFlowLayout->ElementContent();
    _fLastWasBreak = FALSE;
    _xLeftFrameMargin = 0;
    _xRightFrameMargin = 0;

    _cAlignedSites = 0;
    _cAlignedSitesAtBeginningOfLine = 0;
    _cchWhiteAtBeginningOfLine = 0;

    CTreeNode *pNode;
    
    if (!_fMeasureFromTheStart)
        pNode = CurrBranch();
    else
    {
        LONG cp = GetCp() + _cchPreChars;
        CTreePos *ptp = GetMarkup()->TreePosAtCp(cp, NULL, TRUE);
        pNode = ptp ? ptp->GetBranch() : CurrBranch();
    }
    MeasureSetPF(pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext())), SameScope(pNode, pElementFL));

    // Get the device context
    if(_hdc.IsEmpty())
    {
        _hdc = _pci->_hdc;

        if(_hdc.IsEmpty())
        {
            AssertSz(FALSE, "CLSMeasurer::Measure could not get DC");
            return MRET_FAILED;
        }
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:    CMeasure::Measure
//
// Synopsis:    Measure the width of text and the number of characters of text
//              that fits on a line based on the flags. Store the number of
//              characters in _cch.
//
// Arguments:   xWidthMax   -   max width of the line
//              cchMax      -   max chars to process (-1 if no limit)
//              uiFlags     -   flags controlling the process, which mean
//
//                  MEASURE_FIRSTINPARA     this is first line of paragraph
//                  MEASURE_BREAKATWORD     break out on a word break
//                  MEASURE_BREAKATWIDTH    break closest possible before
//                                          xWidthMax
//                  MEASURE_BREAKNEARWIDTH  break closest possible to xWidthMax
//                  MEASURE_MIN_MAX         measure both min and max size of
//                                          possible line size
//              pxMinLineWidth - if non-NULL, Measure() measures minimum line width.
//                                defaults to NULL if not specified.
// Return:      Return      -   o for success
//                          -   MRET_FAILED if failed
//                          -   MRET_NOWIDTH if a second pass is needed to
//                              compute correct width
//
//-----------------------------------------------------------------------------

LONG CLSMeasurer::Measure(
    LONG    xWidthMaxIn,
    LONG    cchMax,
    UINT    uiFlags,
    CMarginInfo *pMarginInfo,
    LONG *  pxMinLineWidth)
{
    LONG    xWidthMax  = xWidthMaxIn;
    LONG    xLineShift = 0;
    LONG    lRet       = 0;
    LONG    yEmptyLineHeight;
    LONG    yEmptyLineDescent;
    
    CLineFull*pli;
#if DBG==1
    LONG    cpStart = GetCp();
    CTxtPtr txtptr( _pFlowLayout->GetContentMarkup(), cpStart );
#endif

    AssertSz(pMarginInfo, "Margin info should never be NULL");

    _pLS->SetMeasurer(this, uiFlags & MEASURE_BREAKWORDS ?
                      CLineServices::LSMODE_HITTEST :
                      CLineServices::LSMODE_MEASURER,
                      uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE
                     );

    lRet = InitForMeasure(uiFlags);
    if(lRet)
    {
        //the only error code we anticipate from InitForMeasure
        Assert(lRet == MRET_FAILED);
        goto Error;
    }

    _li._fFirstInPara = uiFlags & MEASURE_FIRSTINPARA;
    _li._fFirstFragInLine = TRUE;
    _li._xWhite = 0;
    _li._fClearBefore = FALSE;
    _li._fClearAfter  = FALSE;
    
    // Always force a newline by default
    _li._fForceNewLine = TRUE;
    _li._fDummyLine    = FALSE;

    // Set the line direction here
    _li._fRTLLn = _pLS->_pPFFirst->HasRTL(_pLS->_fInnerPFFirst);

    // For hit testing we dont need to do any of the following, _xLeft
    // is computed is computed and available in the line.

    // Compute width to break out at
    if (uiFlags & MEASURE_BREAKATWORD)
    {
        // Adjust left indent
        MeasureListIndent();

        if (pMarginInfo->HasLeftFrameMargin())
        {
            _xLeftFrameMargin = DEF_FRAMEMARGIN;
        }
        if (pMarginInfo->HasRightFrameMargin())
        {
            _xRightFrameMargin = DEF_FRAMEMARGIN;
        }

        if(xWidthMax != MAXLONG ||
            (_li._xRight + _li._xLeft + _pdp->GetCaret() +
                        _xLeftFrameMargin + _xRightFrameMargin) > 0)
        {
            xWidthMax -= _li._xRight + _li._xLeft - _li._xNegativeShiftRTL +
                        _xLeftFrameMargin + _xRightFrameMargin;
        }
    }

    // Compute max number of characters to process, if -1 (no limit) is specified
    if (cchMax < 0)
        cchMax = GetLastCp() - GetCp();

    Assert(_pLS);
    _pLS->_li = _li;
    if(S_OK != LSMeasure(pMarginInfo, xWidthMax, pxMinLineWidth))
    {
        lRet = MRET_FAILED;
        goto Error;
    }

    pli = &_pLS->_li;

    //-------------- HACK HACK (SujalP) --------------------------
    //
    // Bug 46277 shows us that the measurer can measure beyond the end
    // of the layout. The problem could be anywhere and is difficult to
    // find out in a post-mortem manner. So till we have a better repro
    // case, I am going to put in a band-aid fix.
    //
    //-------------- HACK HACK (SujalP) --------------------------
    if (_pLS->_cpStart + _pLS->_li._cch > _pLS->_treeInfo._cpLayoutLast)
    {
        AssertSz(0, "This should not happen ... ever!");
        _pLS->_li._cch = _pLS->_treeInfo._cpLayoutLast - _pLS->_cpStart;
    }
    
    // If we can auto clear and the given space does not fit a word,
    // let's auto clear.
    if (pli->_xWidth > xWidthMax &&
        (uiFlags & MEASURE_AUTOCLEAR))
    {
        LONG cchAtBOL;


        if (_pLS->GetAlignedAtBOL() && !pli->_fHasBreak)
        {
            cchAtBOL = _pLS->CchSkipAtBOL() - (_fMeasureFromTheStart ? 0 : _pLS->GetWhiteAtBOL());
        }
        else
        {
            cchAtBOL = _pLS->CchSkipAtBOL();
        }
        
        pMarginInfo->_fAutoClear = TRUE;

        pli->_cch      = cchAtBOL;
        pli->_xWidth   = 0;
        pli->_xWhite   = 0;
        pli->_cchWhite = cchAtBOL;
        _pLS->DeleteChunks();
        Advance( pli->_cch );
        goto Cleanup;
    }

    Advance( _pLS->_li._cch, _pLS->FigureNextPtp(_pLS->_cpStart + _pLS->_li._cch) );

    // If the line is completely empty or the line contains
    // nothing but noscope element and potentially
    // a break character (that don't have any height of their own),
    // then we need to give the line the height of the prevailing font.
    //
    // NB (cthrash) pli->_cch can be less than _pLS->CchSkipAtBOL(),
    // in the case of an empty LI.  We start measuring at the new block
    // element, but end up bailing immediately.  Unfortunately, we will
    // have already bumped up the _cWhiteAtBOL when we looked at the
    // begin node character of this block element.
    if (   !pli->_fHidden
        && (!(pli->_cch + (_fBrowseMode ? _cchPreChars : 0))
            || (   (   pli->_fHasBreak
                    || pli->_fHasBulletOrNum
                   )
                && pli->_cch <= _pLS->CchSkipAtBOL()
               )
           )
        && (!_fEmptyLineForPadBord || !_fBrowseMode)
       )
    {
        // Possibly use the compose font for default line height.
        if (!_fBrowseMode)
        {
            // Have to load the empty line height.
            extern long GetSpringLoadedHeight(CCalcInfo *, CFlowLayout *, CTreePos *, long, long *);
            yEmptyLineHeight = GetSpringLoadedHeight(
                                    GetCalcInfo(),
                                    _pFlowLayout,
                                    GetPtp(), GetCp(),
                                    &yEmptyLineDescent);

            if (yEmptyLineHeight == -1)
            {
                yEmptyLineHeight = pli->_yHeight;//24;
                yEmptyLineDescent = pli->_yDescent; //4;
            }

            if (pli->_fHasBulletOrNum)
            {
                pli->_yHeight = max(pli->_yHeight, yEmptyLineHeight);
                pli->_yDescent = max(pli->_yDescent, yEmptyLineDescent);
            }
            else
            {
                pli->_yHeight = yEmptyLineHeight;
                pli->_yDescent = yEmptyLineDescent;
            }
        }
        else
        {
            COneRun *por;
            CCalcInfo *pci = GetCalcInfo();

            por = _pLS->_listFree.GetFreeOneRun(NULL);
            if (!por)
                goto Cleanup;
            por->_pCF = (CCharFormat*)_pLS->_treeInfo._pCF;
#if DBG == 1
            por->_pCFOriginal = por->_pCF;
#endif
            CCcs ccs;

            if (_pLS->GetCcs(&ccs, por, pci->_hdc, pci))
            {
                const CBaseCcs *pBaseCcs = ccs.GetBaseCcs();
                pli->_yHeight  = pBaseCcs->_yHeight;
                pli->_yDescent = pBaseCcs->_yDescent;
                pli->_fDummyLine = FALSE;
                pli->_fForceNewLine = TRUE;
            }

            _pLS->_listFree.SpliceIn(por);
        }

        if (!_pLS->_fFoundLineHeight)
            _pLS->_lMaxLineHeight = pli->_yHeight;
        Assert(pli->_yHeight >= 0);
    }

    // Line with only white space (only occurs in table cells with aligned
    // images), set the height to zero.
    else if (_pLS->IsDummyLine(GetCp()))
    {
        pli->_yHeight = pli->_yDescent = _pLS->_lMaxLineHeight = 0;
    }

    pli->_yTxtDescent = pli->_yDescent;

    if (!lRet && pli->_cch && pli->_fForceNewLine && pli->_xWidth != 0)
    {
        xLineShift = _xLeftFrameMargin;

        // TODO RTL 112514: if this code is now fully obsolete, we need to debug it and delete it.
        if(_pdp->IsRTLDisplay())
        {
            Assert(_xLeftFrameMargin == _xRightFrameMargin || !IsTagEnabled(tagDebugRTL));
        //  xLineShift = _xRightFrameMargin;
        }

        pli->_xLeft   += _xLeftFrameMargin;
        pli->_xRight  += _xRightFrameMargin;
    }

    if( (pli->_fForceNewLine || (pli->_fDummyLine)))
    {
        BOOL fMinMax = uiFlags & (MEASURE_MINWIDTH|MEASURE_MAXWIDTH);
        long xShift;
        long xRemainder = 0;

        // Note: fMinMax here doesn't really mean that we are calculating min/max.
        //       (in that case, MEASURE_MINWIDTH is set, and MeasureLineShift is 
        //       not called at all.
        //       fMinMax rather means "don't bother justifying lines, we either 
        //       don't need to do it at all, or we'll do it on a different pass)
        //       In case of _fSizeToContent, lines are justified by RecalcLineShift() later.
        //       If _fSizeToContent is set, but RecalcLineShift() is not called
        //       (which sounds like a possibility - look at how fNeedLineShift is calculated
        //       in CFlowLayout::CalcSizeCore), all lines will remain left-aligned.
        if(!(uiFlags & MEASURE_MINWIDTH))
            xShift = _pLS->MeasureLineShift(
                               GetCp(),
                               xWidthMaxIn,
                               fMinMax || _pLS->_pFlowLayout->_fSizeToContent,
                               &xRemainder);
        else
            xShift = 0;

        // Now that we know the line width, compute line shift due
        // to alignment, and add it to the left position
        if (!fMinMax)
        {
            pli->_xLeft += xShift;
            pli->_xRight += max(xRemainder, 0L);
            xLineShift += pli->_xLeft;
            
            // In RTL display, save shift if it is negative (that won't happen in LTR)
            if (_pdp->IsRTLDisplay() && xShift < 0)
                pli->_xNegativeShiftRTL = xShift;
        }
    }

    _pLS->_fHasRelative |= !!_fRelativePreChars;
    _pLS->_pFlowLayout->_fContainsRelative |= !!_fRelativePreChars;

    Assert(_pLS->_lsMode == CLineServices::LSMODE_MEASURER);
    if (   _pLS->_fHasInlinedSites 
        || _pLS->_cAbsoluteSites 
        || _cchAbsPosdPreChars 
        || _pLS->_fHasRelative 
       )
    {
        pli->_fRelative = _pLS->_fHasRelative;
        // Assume there are only sites in the line if the number of characters
        // is less than the number of characters given to sites, plus those
        // given to whitespace, plus break characters. (A less than comparison
        // is used since whitespace which occurs at the end of the line is not
        // counted in the cch for the line.)

        if (_pLS->_fHasVerticalAlign)
            _pLS->VerticalAlignObjects(*this, xLineShift);
        else
            _pLS->VerticalAlignObjectsFast(*this, xLineShift);
    }
    else if (_pLS->_fHasVerticalAlign)
    {
        _pLS->VerticalAlignObjects(*this, xLineShift);
    }
    else
    {
        // Allow last minute adjustment to line height
        _pLS->AdjustLineHeight();
    }

Cleanup:
    // SYNCUP THE LINE WITH THE LINE GENERATED BY LINESERVICES
    _li = *pli;

Error:
    return lRet;
}

#pragma optimize("", on)

CLineCore *
CLSMeasurer::AccountForRelativeLines(CLineFull& li,                 // IN
                                     LONG *pcpStartContainerLine,   // OUT
                                     LONG *pxWidthContainerLine,    // OUT
                                     LONG *pcpStartRender,          // OUT
                                     LONG *pcpStopRender,           // OUT
                                     LONG *pcchTotal                // OUT
                                    ) const
{
    CLineCore *pliContainer = &li;

    if (li._fPartOfRelChunk)
    {
        CLinePtr rp((CDisplay *)_pdp);
        BOOL fRet;

        // NOTE(SujalP): The li and the cp should be in sync. on calling
        rp.RpSetCp(GetCp(), FALSE, TRUE, TRUE);

        // Verify that rp was instantiated correctly
        Assert(rp->_fPartOfRelChunk);
 
        *pcpStartRender = *pcpStartContainerLine = GetCp();

        // Navigate backwards all the way so that we reach the start of
        // the current container line
        while(!rp->_fFirstFragInLine)
        {
            Verify(rp.PrevLine(FALSE, FALSE));
            *pcpStartContainerLine -= rp->_cch;
            Assert(rp->_fPartOfRelChunk);
        }

        pliContainer = rp.CurLine();

        // Navigate forward till the end of this container line
        // collecting all the interesting information along the way
        fRet = TRUE;
        if(!rp->_fRTLLn)
        {
            *pxWidthContainerLine = -rp->oi()->_xLeft;
        }
        else
        {
            *pxWidthContainerLine = -rp->_xRight;
        }
        *pcchTotal = 0;
        while (fRet)
        {
            *pcchTotal += rp->_cch;
            fRet = rp.NextLine(FALSE, FALSE);
            if (!fRet || rp->_fFirstFragInLine || rp->IsClear())
            {
                if (fRet)
                    Verify(rp.PrevLine(FALSE, FALSE));
                if(!rp->_fRTLLn)
                {
                    *pxWidthContainerLine += rp->_xLineWidth - rp->_xRight;
                }
                else
                {
                    *pxWidthContainerLine += rp->_xLineWidth - rp->oi()->_xLeft + rp->oi()->_xNegativeShiftRTL;
                }
                break;
            }
            Assert(rp->IsFrame() || rp->_fPartOfRelChunk);
        }
    }
    else
    {
        *pcchTotal = li._cch;
        *pcpStartRender = *pcpStartContainerLine = GetCp();

        //
        // Computing the width is tricky.
        // If the line is right aligned, because in that case the _xWhite 'hangs off'
        // the line, i.e. _xLeft + _xWidth + _xRight = _xLineWidth. Note there
        // is not _xWhite in the lhs of the above expression. So to the correct
        // width to which we need to measure, if the _xWhite hangs off the
        // _xLineWidth, then we need to add it in to the width of the line.
        //
        long xLeft = li._xLeft - li._xNegativeShiftRTL;
        
        *pxWidthContainerLine  = li._xLineWidth - (xLeft + li._xRight);
        if (li._xWidth + li._xWhite + xLeft + _li._xRight > _li._xLineWidth)
        {
            // Make sure were not full justified, since we *don't* want to
            // include the xWhite in the line width in that case.

            if (li._fJustified != JUSTIFY_FULL)
            {
                *pxWidthContainerLine += li._xWhite;
            }
        }

    }
    *pcpStopRender  = *pcpStartRender + li._cch;

    Assert(pliContainer);
    return pliContainer;
}

// Used by the full min pass to find the next island of
// aligned objects around which to advance.
BOOL
CLSMeasurer::AdvanceToNextAlignedObject()
{
    BOOL fFound = FALSE;
    CTreePos *ptp;
    CTreeNode *pNode;
    CTreePos *ptpStop = NULL;
    CTreePos *ptpStart = NULL;
    CTreePos *ptpPrev;
    const CCharFormat *pCF;
    CElement *pElement;

    Assert(_pFlowLayout);
    _pFlowLayout->GetContentTreeExtent(&ptpStart, &ptpStop);
    Assert(ptpStart && ptpStop);

    ptp = GetPtp();
    Assert(ptp);

    // Need to make sure that the ambiguous measurer cp is taken
    // and then moved back to the appropriate non-text node.
    if (ptp->IsText() && _cp == ptp->GetCp() || ptp->IsPointer())
    {
        for (ptpPrev = ptp->PreviousTreePos();
             ptpPrev != ptpStart && ptpPrev->IsBeginNode();
             ptpPrev = ptp->PreviousTreePos()
                     )
        {
            ptp = ptpPrev;
        }
    }

#if DBG == 1
// I don't actually know this is a problem, but AdvanceTreePos is
// a problem, and this looks similar (KTam)
#ifndef MULTI_LAYOUT
    {
        // We will never be positioned inside a nested run owner.
        CLayout *pRunOwner;
        CTreePos *ptpTemp;

        pRunOwner = _pFlowLayout->GetContentMarkup()->GetRunOwner(ptp->GetBranch(), _pFlowLayout);
        if (pRunOwner != _pFlowLayout)
        {
            pRunOwner->GetContentTreeExtent(&ptpTemp, NULL);
            Assert(ptp == ptpTemp);
        }
    }
#endif // MULTI_LAYOUT
#endif

    while (ptp != ptpStop)
    {
        if (ptp->IsNode())
        {
            pNode = ptp->Branch();
            pElement = pNode->Element();
            pCF = pNode->GetCharFormat();
            if (pCF->IsDisplayNone())
            {
                pElement->GetTreeExtent(NULL, &ptp);
            }
            else if (ptp->IsBeginElementScope())
            {
                if (pNode->ShouldHaveLayout())
                {
                    Assert (pElement != _pFlowLayout->ElementContent());
                    if (pElement->IsRunOwner())
                    {
                        if (pElement->GetElementCch())
                        {
                            fFound = TRUE;
                        }
                    }
                    else
                        fFound = TRUE;

                    // We've found a site and it is has content, is it aligned?
                    // If not, then we don't want to measure around it.
                    if (fFound)
                    {
                        if (!pNode->GetFancyFormat()->_fAlignedLayout)
                            fFound = FALSE;
                        else
                            break;
                    }

                    pElement->GetTreeExtent(NULL, &ptp);
                }
            }
        }
        ptp = ptp->NextTreePos();
    }

    Assert(ptp);
    SetCp(ptp->GetCp(), ptp);
    return fFound;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSMeasurer::PrepAndMeasureLine()
//
// Synopsis:    Prepares a line for measurement and then measures it.
//
//
// Returns:     lserr result of line creation
//
//-----------------------------------------------------------------------------

LSERR CLSMeasurer::PrepAndMeasureLine(
    CLineFull *pliIn,             // CLineFull passed in
    CLineCore **ppliOut,          // CLineCore passed out (first frag or container)
    LONG  *pcpStartContainerLine,
    CMarginInfo *pMarginInfo,     // Margin information
    LONG   cchLine,               // number of characters in the line
    UINT   uiFlags)               // MEASURE_ flags
{
    LSERR lserr = lserrNone;
    LONG xWidthContainerLine;
    LONG cpIgnore;
    LONG cchTotal;
    CTreePos *ptp;
    LONG cpOriginal = GetCp();
    CTreePos *ptpOriginal = GetPtp();
    CLineFull li;

    *ppliOut = AccountForRelativeLines(*pliIn,
                                       pcpStartContainerLine,
                                       &xWidthContainerLine,
                                       &cpIgnore,
                                       &cpIgnore,
                                       &cchTotal
                                      );
    if (*pcpStartContainerLine != GetCp())
        SetCp(*pcpStartContainerLine, NULL);
    _cchPreChars = 0;
    _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), cchLine, &_cchPreChars, &ptp, &_fMeasureFromTheStart);
    if (!_fMeasureFromTheStart)
    {
        *pcpStartContainerLine += _cchPreChars;
        SetPtp(ptp, *pcpStartContainerLine);
        if (cchTotal == _cchPreChars)
        {
            lserr = lserrInvalidLine;
            goto Cleanup;
        }
    }
    
    li = **ppliOut;

    // If we are part of relchunk, then AccountForRelLines returns the first line to us
    // which will have lesser number of chars than the container line. So lets change the
    // number of characters to be the total number of characters in the container lines.
    if (li._fPartOfRelChunk)
    {
        li._cch = cchTotal;
    }

    if (_cchPreChars != 0 && !_fMeasureFromTheStart)
    {
        li._cch  -= _cchPreChars;
    }

    if (   li._fFirstInPara
        && (   li._fHasFirstLine
            || li._fHasFirstLetter
           )
       )
    {
        CTreeNode *pNode = ptp->GetBranch();
        pNode = _pLS->_pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        const CFancyFormat *pFF = pNode->GetFancyFormat();

        _cpStopFirstLetter = ((li._fHasFirstLetter && pFF->_fHasFirstLetter)
                             ? GetCpOfLastLetter(pNode)
                             : -1);
        
        if (li._fHasFirstLine && pFF->_fHasFirstLine)
        {
            PseudoLineEnable(pNode);
        }
        if (li._fHasFirstLetter && pFF->_fHasFirstLetter && _cpStopFirstLetter >= 0)
        {
            PseudoLetterEnable(pNode);
        }
    }

    NewLine(li);
    _li._cch = li._cch;
    _li._xLeft = li._xLeft;
    _li._xLeftMargin = li._xLeftMargin;
    _li._xRight = li._xRight;
    _li._xRightMargin = li._xRightMargin;

    // We want the measure width to the be the width at which the container line was measured.
    // This line is stored in li.
    //_pLS->_li._xMeasureWidth = li._xMeasureWidth;
    _pLS->_li = _li;

    _pLS->SetMeasurer(this,  CLineServices::LSMODE_HITTEST, uiFlags & MEASURE_BREAKLONGLINES ? TRUE : FALSE);
    InitForMeasure(uiFlags);
    lserr = LSDoCreateLine(*pcpStartContainerLine, GetPtp(), pMarginInfo, xWidthContainerLine, &li, FALSE, NULL);

    _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

    if (_pLS->_fHasVerticalAlign)
    {
        _pLS->_li._cch = _pLS->_cpLim - *pcpStartContainerLine;
        _pLS->VerticalAlignObjects(*this, 0);
    }

Cleanup:
    SetCp(cpOriginal, ptpOriginal);
    return lserr;
}

#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsfecbk.cxx ===
/*
 *  ExternTag(@module) LSFECBK.CXX -- line services non-Latin object handlers
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/22/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifdef DLOAD1
extern "C" // MSLS interfaces are plain C
{
#endif

#ifndef X_RUBY_H_
#define X_RUBY_H_
#include <ruby.h>
#endif

#ifndef X_TATENAK_H_
#define X_TATENAK_H_
#include <tatenak.h>
#endif

#ifndef X_HIH_H_
#define X_HIH_H_
#include <hih.h>
#endif

#ifndef X_WARICHU_H_
#define X_WARICHU_H_
#include <warichu.h>
#endif

#ifndef X_LSENSUBL_H_
#define X_LSENSUBL_H_
#include <lsensubl.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

ExternTag(tagLSCallBack);

//-----------------------------------------------------------------------------
//
// Ruby support
//
//-----------------------------------------------------------------------------

#define RUBY_OFFSET    2

LSERR WINAPI
CLineServices::FetchRubyPosition(
    LSCP lscp,                          // IN
    LSTFLOW lstflow,                    // IN
    DWORD cdwMainRuns,                  // IN
    const PLSRUN *pplsrunMain,          // IN
    PCHEIGHTS pcheightsRefMain,         // IN
    PCHEIGHTS pcheightsPresMain,        // IN
    DWORD cdwRubyRuns,                  // IN
    const PLSRUN *pplsrunRuby,          // IN
    PCHEIGHTS pcheightsRefRuby,         // IN
    PCHEIGHTS pcheightsPresRuby,        // IN
    PHEIGHTS pheightsRefRubyObj,        // OUT
    PHEIGHTS pheightsPresRubyObj,       // OUT
    long *pdvrOffsetMainBaseline,       // OUT
    long *pdvrOffsetRubyBaseline,       // OUT
    long *pdvpOffsetRubyBaseline,       // OUT
    enum rubycharjust *prubycharjust,   // OUT
    BOOL *pfSpecialLineStartEnd)        // OUT
{
    LSTRACE(FetchRubyPosition);
    LONG yAscent;
    RubyInfo rubyInfo;
    long yRubyOffset = (cdwRubyRuns > 0) ? RUBY_OFFSET : 0;
    
    *pdvrOffsetMainBaseline = 0;  // Don't want to offset the main text from
                                  // the ruby object's baseline

    if(cdwMainRuns)
    {
        HandleRubyAlignStyle((COneRun *)(*pplsrunMain), prubycharjust, pfSpecialLineStartEnd);
    }

    rubyInfo.cp = CPFromLSCP(lscp);

    // Ruby offset is the sum of the ascent of the main text
    // and the descent of the pronunciation text.
    yAscent = max(_yMaxHeightForRubyBase, pcheightsRefMain->dvAscent);
    
    *pdvpOffsetRubyBaseline = 
    *pdvrOffsetRubyBaseline = 
         yAscent + yRubyOffset + pcheightsRefRuby->dvDescent;
    rubyInfo.yHeightRubyBase = yAscent + pcheightsRefMain->dvDescent + yRubyOffset;
    rubyInfo.yDescentRubyBase = pcheightsRefMain->dvDescent;
    rubyInfo.yDescentRubyText = pcheightsRefRuby->dvDescent;

    pheightsRefRubyObj->dvAscent = yAscent + pcheightsRefRuby->dvAscent + pcheightsRefRuby->dvDescent + yRubyOffset;
    pheightsRefRubyObj->dvDescent = pcheightsRefMain->dvDescent;
    pheightsRefRubyObj->dvMultiLineHeight = 
        pheightsRefRubyObj->dvAscent + pheightsRefRubyObj->dvDescent;
    memcpy(pheightsPresRubyObj, pheightsRefRubyObj, sizeof(*pheightsRefRubyObj));

    
    // code in GetRubyInfoFromCp depends on the idea that this callback 
    // is called in order of increasing cps. This of course depends on Line Services.  
    // If this is not guaranteed to be true, then we can't just blindly append the 
    // entry here, we must insert it in sorted order or hold cp ranges in the RubyInfos
    Assert(_aryRubyInfo.Size() == 0
           || _aryRubyInfo[_aryRubyInfo.Size()-1].cp <= rubyInfo.cp);
    if(_aryRubyInfo.FindIndirect(&rubyInfo) == -1)
    {
        _aryRubyInfo.AppendIndirect(&rubyInfo);
    }

    return lserrNone;
}


// Ruby Align Style table
// =========================
// Holds the justification values to pass to line services for each ruby alignment type.
//

static const enum rubycharjust s_aRubyAlignStyleValues[] =
{
    rcjCenter,   // not set
    rcjCenter,   // auto
    rcjLeft,     // left
    rcjCenter,   // center
    rcjRight,    // right
    rcj010,      // distribute-letter
    rcj121,      // distribute-space
    rcjCenter    // line-edge
};

void WINAPI
CLineServices::HandleRubyAlignStyle(
    COneRun *porMain,                   // IN
    enum rubycharjust *prubycharjust,   // OUT
    BOOL *pfSpecialLineStartEnd)        // OUT
{
    Assert(porMain);
    
    CTreeNode *     pNode = porMain->Branch();  // This will call_ptp->GetBranch()
    CElement *      pElement = pNode->SafeElement();
    VARIANT varRubyAlign;
    styleRubyAlign styAlign;

    pElement->ComputeExtraFormat(DISPID_A_RUBYALIGN, 
        ComputeFormatsType_GetInheritedValue, pNode, &varRubyAlign);
    styAlign = (((CVariant *)&varRubyAlign)->IsEmpty()) 
                                                 ? styleRubyAlignNotSet 
                                                 : (styleRubyAlign) V_I4(&varRubyAlign);

    Assert(styAlign >= styleRubyAlignNotSet && styAlign <= styleRubyAlignLineEdge);

    *prubycharjust = s_aRubyAlignStyleValues[styAlign];
    *pfSpecialLineStartEnd = (styAlign == styleRubyAlignLineEdge);

    if(   (styAlign == styleRubyAlignNotSet || styAlign == styleRubyAlignAuto)
       && !porMain->_fCharsForNestedLayout) 
    {
        // default behavior should be centered alignment for latin characters,
        // distribute-space for ideographic characters
        const SCRIPT_ID sid = porMain->_ptp->Sid();
        if (   (sid >= sidFEFirst && sid <= sidFELast)
            || sid == sidSurrogateA 
            || sid == sidSurrogateB)
        {
            *prubycharjust = rcj121;
        }
    }
}


LSERR WINAPI
CLineServices::FetchRubyWidthAdjust(
    LSCP cp,                // IN
    PLSRUN plsrunForChar,   // IN
    WCHAR wch,              // IN
    MWCLS mwclsForChar,     // IN
    PLSRUN plsrunForRuby,   // IN
    enum rubycharloc rcl,   // IN
    long durMaxOverhang,    // IN
    long *pdurAdjustChar,   // OUT
    long *pdurAdjustRuby)   // OUT
{
    LSTRACE(FetchRubyWidthAdjust);
    Assert(plsrunForRuby);

    COneRun *       porRuby = (COneRun *)plsrunForRuby;
    CTreeNode *     pNode = porRuby->Branch();  // This will call_ptp->GetBranch()
    CElement *      pElement = pNode->SafeElement();
    styleRubyOverhang sty;

    {
        VARIANT varValue;

        pElement->ComputeExtraFormat(DISPID_A_RUBYOVERHANG, 
                                     ComputeFormatsType_GetInheritedValue, 
                                     pNode, 
                                     &varValue);

        sty = (((CVariant *)&varValue)->IsEmpty())
                 ? styleRubyOverhangNotSet
                 : (styleRubyOverhang)V_I4(&varValue);
    }
  
	*pdurAdjustChar = 0;
	*pdurAdjustRuby = (sty == styleRubyOverhangNone) ? 0 : -durMaxOverhang;
    return lserrNone;
}

LSERR WINAPI
CLineServices::RubyEnum(
    PLSRUN plsrun,              // IN
    PCLSCHP plschp,             // IN
    LSCP cp,                    // IN
    LSDCP dcp,                  // IN
    LSTFLOW lstflow,            // IN
    BOOL fReverse,              // IN
    BOOL fGeometryNeeded,       // IN
    const POINT* pt,            // IN
    PCHEIGHTS pcheights,        // IN
    long dupRun,                // IN
    const POINT *ptMain,        // IN
    PCHEIGHTS pcheightsMain,    // IN
    long dupMain,               // IN
    const POINT *ptRuby,        // IN
    PCHEIGHTS pcheightsRuby,    // IN
    long dupRuby,               // IN
    PLSSUBL plssublMain,        // IN
    PLSSUBL plssublRuby)        // IN
{
    LSTRACE(RubyEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Tatenakayoko (HIV) support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetTatenakayokoLinePosition(
    LSCP cp,                            // IN
    LSTFLOW lstflow,                    // IN
    PLSRUN plsrun,                      // IN
    long dvr,                           // IN
    PHEIGHTS pheightsRef,               // OUT
    PHEIGHTS pheightsPres,              // OUT
    long *pdvrDescentReservedForClient) // OUT
{
    LSTRACE(GetTatenakayokoLinePosition);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(GetTatenakayokoLinePosition);
    return lserrNone;
}

LSERR WINAPI
CLineServices::TatenakayokoEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* pt,        // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    LSTFLOW lstflowT,       // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(TatenakayokoEnum);
    LSNOTIMPL(TatenakayokoEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Warichu support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetWarichuInfo(
    LSCP cp,                            // IN
    LSTFLOW lstflow,                    // IN
    PCOBJDIM pcobjdimFirst,             // IN
    PCOBJDIM pcobjdimSecond,            // IN
    PHEIGHTS pheightsRef,               // OUT
    PHEIGHTS pheightsPres,              // OUT
    long *pdvrDescentReservedForClient) // OUT
{
    LSTRACE(GetWarichuInfo);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(GetWarichuInfo);
    return lserrNone;
}

LSERR WINAPI
CLineServices::FetchWarichuWidthAdjust(
    LSCP cp,                        // IN
    enum warichucharloc wcl,        // IN
    PLSRUN plsrunForChar,           // IN
    WCHAR wch,                      // IN
    MWCLS mwclsForChar,             // IN
    PLSRUN plsrunWarichuBracket,    // IN
    long *pdurAdjustChar,           // OUT
    long *pdurAdjustBracket)        // OUT
{
    LSTRACE(FetchWarichuWidthAdjust);
    // FUTURE (mikejoch) Need to adjust cp if we ever implement this.
    LSNOTIMPL(FetchWarichuWidthAdjust);
    return lserrNone;
}

LSERR WINAPI
CLineServices::WarichuEnum(
    PLSRUN plsrun,                  // IN: plsrun for the entire Warichu Object
    PCLSCHP plschp,                 // IN: lschp for lead character of Warichu Object
    LSCP cp,                        // IN: cp of first character of Warichu Object
    LSDCP dcp,                      // IN: number of characters in Warichu Object
    LSTFLOW lstflow,                // IN: text flow at Warichu Object
    BOOL fReverse,                  // IN: whether text should be reversed for visual order
    BOOL fGeometryNeeded,           // IN: whether Geometry should be returned
    const POINT* pt,                // IN: starting position, iff fGeometryNeeded
    PCHEIGHTS pcheights,            // IN: height of Warichu object, iff fGeometryNeeded
    long dupRun,                    // IN: length of Warichu Object, iff fGeometryNeeded
    const POINT *ptLeadBracket,     // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsLeadBracket, // IN: height for ruby line iff fGeometryNeeded 
    long dupLeadBracket,            // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    const POINT *ptTrailBracket,    // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsTrailBracket,// IN: height for ruby line iff fGeometryNeeded 
    long dupTrailBracket,           // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    const POINT *ptFirst,           // IN: starting point for main line iff fGeometryNeeded
    PCHEIGHTS pcheightsFirst,       // IN: height of main line iff fGeometryNeeded
    long dupFirst,                  // IN: length of main line iff fGeometryNeeded 
    const POINT *ptSecond,          // IN: point for second line iff fGeometryNeeded and plssublSecond not NULL
    PCHEIGHTS pcheightsSecond,      // IN: height for ruby line iff fGeometryNeeded and plssublSecond not NULL
    long dupSecond,                 // IN: length of Ruby line iff fGeometryNeeded and plssublSecond not NULL
    PLSSUBL plssublLeadBracket,     // IN: subline for lead bracket
    PLSSUBL plssublTrailBracket,    // IN: subline for trail bracket
    PLSSUBL plssublFirst,           // IN: first subline in Warichu object
    PLSSUBL plssublSecond)          // IN: second subline in Warichu object
{
    LSTRACE(WarichuEnum);
    LSNOTIMPL(WarichuEnum);
    return lserrNone;
}


//-----------------------------------------------------------------------------
//
// HIH support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::HihEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* pt,        // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(HihEnum);
    LSNOTIMPL(HihEnum);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
// Reverse Object support
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ReverseEnum(
    PLSRUN plsrun,          // IN
    PCLSCHP plschp,         // IN
    LSCP cp,                // IN
    LSDCP dcp,              // IN
    LSTFLOW lstflow,        // IN
    BOOL fReverse,          // IN
    BOOL fGeometryNeeded,   // IN
    const POINT* ppt,       // IN
    PCHEIGHTS pcheights,    // IN
    long dupRun,            // IN
    LSTFLOW lstflowSubline, // IN
    PLSSUBL plssubl)        // IN
{
    LSTRACE(ReverseEnum);

    return LsEnumSubline(plssubl, fReverse, fGeometryNeeded, ppt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsdraw.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSDRAW.CXX -- line services drawing callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/29/97     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

ExternTag(tagLSCallBack);

LSERR WINAPI
CLineServices::DrawUnderline(
    PLSRUN plsrun,          // IN
    UINT kUlBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupUl,            // IN
    DWORD dvpUl,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawUnderline);

    GetRenderer()->DrawUnderline(plsrun, kUlBase, pptStart, dupUl, dvpUl, kTFlow, kDisp, prcClip);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawStrikethrough(
    PLSRUN plsrun,          // IN
    UINT kStBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupSt,            // IN
    DWORD dvpSt,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawStrikethrough);
    LSNOTIMPL(DrawStrikethrough);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawBorder(
    PLSRUN plsrun,                              // IN
    const POINT* pptStart,                      // IN
    PCHEIGHTS pheightsLineFull,                 // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    PCHEIGHTS pheightRuns,                      // IN
    long dupBorder,                             // IN
    long dupRunsInclBorders,                    // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(DrawBorder);
    LSNOTIMPL(DrawBorder);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawUnderlineAsText(
    PLSRUN plsrun,          // IN
    const POINT* pptStart,  // IN
    long dupLine,           // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSTRACE(DrawUnderlineAsText);
    LSNOTIMPL(DrawUnderlineAsText);
    return lserrNone;
}

LSERR WINAPI
CLineServices::ShadeRectangle(
    PLSRUN plsrun,                              // IN
    const POINT* pptStart,                      // IN
    PCHEIGHTS pheightsLineWithAddSpace,         // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    PCHEIGHTS pheightsRunsExclTrail,            // IN
    PCHEIGHTS pheightsRunsInclTrail,            // IN
    long dupRunsExclTrail,                      // IN
    long dupRunsInclTrail,                      // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(ShadeRectangle);
    LSNOTIMPL(ShadeRectangle);
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawTextRun(
    PLSRUN plsrun,          // IN
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    const POINT* pptText,   // IN
    LPCWSTR plwchRun,       // IN
    const int* rgDupRun,    // IN
    DWORD cwchRun,          // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightPres,   // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    LSTRACE(DrawTextRun);

    TCHAR *pch = (TCHAR *)plwchRun;
    if (plsrun->IsSpecialCharRun())
    {
        GetRenderer()->ShouldSkipThisRun(plsrun, dupRun);
    }
    else
    {
        if (plsrun->_fMakeItASpace)
        {
            Assert(cwchRun == 1);
            pch = _T(" ");
        }
        GetRenderer()->TextOut(plsrun,   fStrikeout, fUnderline, pptText,
                               pch,      rgDupRun,   cwchRun,    kTFlow,
                               kDisp,    pptRun,     heightPres, dupRun,
                               dupLimUnderline,      pRectClip
                              );
    }
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawSplatLine(
    enum lsksplat,                              // IN
    LSCP cpSplat,                               // IN
    const POINT* pptSplatLine,                  // IN
    PCHEIGHTS pheightsLineFull,                 // IN
    PCHEIGHTS pheightsLineWithoutAddedSpace,    // IN
    PCHEIGHTS pheightsSubline,                  // IN
    long dup,                                   // IN
    LSTFLOW kTFlow,                             // IN
    UINT kDisp,                                 // IN
    const RECT* prcClip)                        // IN
{
    LSTRACE(DrawSplatLine);
    // FUTURE (mikejoch) Need to adjust cpSplat if we ever implement this.
    LSNOTIMPL(DrawSplatLine);
    return lserrNone;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLineServices::DrawGlyphs
//
//  Synopsis:   Draws the glyphs which are passed in
//
//  Arguments:  plsrun              pointer to the run
//              fStrikeout          is this run struck out?
//              fUnderline          is this run underlined?
//              pglyph              array of glyph indices
//              rgDu                array of widths after justification
//              rgDuBeforeJust      array of widths before justification
//              rgGoffset           array of glyph offsets
//              rgGprop             array of glyph properties
//              rgExpType           array of glyph expansion types
//              cglyph              number of glyph indices
//              kTFlow              text direction and orientation
//              kDisp               display mode - opaque, transparent
//              pptRun              starting point of the run
//              heights             presentation height for this run
//              dupRun              presentation width of this run
//              dupLimUnderline     underline limit
//              pRectClip           clipping rectangle
//
//  Returns:    LSERR               lserrNone if succesful
//                                  lserrInvalidRun if failure
//
//----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::DrawGlyphs(
    PLSRUN plsrun,                  // IN
    BOOL fStrikeout,                // IN
    BOOL fUnderline,                // IN
    PCGINDEX pglyph,                // IN
    const int* rgDu,                // IN
    const int* rgDuBeforeJust,      // IN
    PGOFFSET rgGoffset,             // IN
    PGPROP rgGprop,                 // IN
    PCEXPTYPE rgExpType,            // IN
    DWORD cglyph,                   // IN
    LSTFLOW kTFlow,                 // IN
    UINT kDisp,                     // IN
    const POINT* pptRun,            // IN
    PCHEIGHTS heightsPres,          // IN
    long dupRun,                    // IN
    long dupLimUnderline,           // IN
    const RECT* pRectClip)          // IN
{
    LSTRACE(DrawGlyphs);

    GetRenderer()->GlyphOut(plsrun,    fStrikeout, fUnderline, pglyph,
                            rgDu,      rgDuBeforeJust,         rgGoffset,
                            rgGprop,   rgExpType,  cglyph,     kTFlow,
                            kDisp,     pptRun,     heightsPres,
                            dupRun,    dupLimUnderline,        pRectClip
                           );
    return lserrNone;
}

LSERR WINAPI
CLineServices::DrawEffects(
    PLSRUN plsrun,              // IN
    UINT EffectsFlags,          // IN
    const POINT* ppt,           // IN
    LPCWSTR lpwchRun,           // IN
    const int* rgDupRun,        // IN
    const int* rgDupLeftCut,    // IN
    DWORD cwchRun,              // IN
    LSTFLOW kTFlow,             // IN
    UINT kDisp,                 // IN
    PCHEIGHTS heightPres,       // IN
    long dupRun,                // IN
    long dupLimUnderline,       // IN
    const RECT* pRectClip)      // IN
{
    LSTRACE(DrawEffects);
    LSNOTIMPL(DrawEffects);
    return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\paste.cxx ===
//+----------------------------------------------------------------------------
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
// This file contains the object model paste and ie50 compat ui paste.  No
// changes in behavior should be introduced for compatibility with
// ie40/ie50.  For the new ui paste (>ie60), see uipaste.cxx.
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
Compare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceFragComments
//
//  Synopsis:   Remove the fragment begin and end comments which occur
//              in CF_HTML.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSourceFragComments(
    CDoc * pDoc,
    IMarkupPointer * pSourceStart,
    IMarkupPointer * pSourceFinish )
{
    HRESULT        hr = S_OK;
    CMarkupPointer pmp ( pDoc );

    //
    // Remove the start frag comment
    //

    hr = THR( pmp.MoveToPointer( pSourceStart ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        CTreeNode *         pNode;
        MARKUP_CONTEXT_TYPE ct;
        
        hr = THR( pmp.Left( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope && pNode->Tag() == ETAG_RAW_COMMENT)
        {
            CCommentElement * pElemComment;
            
            pElemComment = DYNCAST( CCommentElement, pNode->Element() );

            if (pElemComment->_fAtomic &&
                !StrCmpIC( pElemComment->_cstrText, _T( "<!--StartFragment-->" ) ))
            {
                hr = THR( pDoc->RemoveElement( pElemComment ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    //
    // Remove the end frag comment
    //

    hr = THR( pmp.MoveToPointer( pSourceFinish ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        CTreeNode *         pNode;
        MARKUP_CONTEXT_TYPE ct;
        
        hr = THR( pmp.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope && pNode->Tag() == ETAG_RAW_COMMENT)
        {
            CCommentElement * pElemComment;
            
            pElemComment = DYNCAST( CCommentElement, pNode->Element() );

            if (pElemComment->_fAtomic &&
                !StrCmpIC( pElemComment->_cstrText, _T( "<!--EndFragment-->" ) ))
            {
                hr = THR( pDoc->RemoveElement( pElemComment ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

Cleanup:

    RRETURN( hr );
}
                             
//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceTables
//
//  Synopsis:   Makes sure that whole (not parts of) tables are included in
//              the source of a paste.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSourceTables (
    CDoc * pDoc,
    CMarkupPointer * pSourceStart,
    CMarkupPointer * pSourceFinish )
{
    HRESULT hr = S_OK;
    CMarkupPointer pointer ( pDoc );

    Assert( pSourceStart->IsLeftOfOrEqualTo( pSourceFinish ) );
    
    for ( pointer.MoveToPointer( pSourceStart ) ; pointer.IsLeftOf( pSourceFinish ) ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode * pNode;
        
        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            switch ( pNode->Element()->Tag() )
            {
            case ETAG_TC : case ETAG_TD : case ETAG_TR : case ETAG_TBODY :
            case ETAG_THEAD : case ETAG_TFOOT : case ETAG_TH : case ETAG_TABLE :
            {
                CTreeNode * pNodeTable =
                    pNode->SearchBranchToRootForTag( ETAG_TABLE );

                if (pNodeTable)
                {
                    CMarkupPointer pointerTable ( pDoc );

                    hr = THR(
                        pointerTable.MoveAdjacentToElement(
                            pNodeTable->Element(), ELEM_ADJ_BeforeBegin ) );

                    if (hr)
                        goto Cleanup;

                    if (pointerTable.IsLeftOf( pSourceStart ))
                    {
                        hr = THR( pSourceStart->MoveToPointer( & pointerTable ) );

                        if (hr)
                            goto Cleanup;
                    }
                    
                    hr = THR(
                        pointerTable.MoveAdjacentToElement(
                            pNodeTable->Element(), ELEM_ADJ_AfterEnd ) );

                    if (hr)
                        goto Cleanup;

                    if (pointerTable.IsRightOf( pSourceFinish ))
                    {
                        hr = THR( pSourceFinish->MoveToPointer( & pointerTable ) );

                        if (hr)
                            goto Cleanup;
                    }
                    hr = THR( pointer.MoveToPointer( &pointerTable ) );
                    if (hr)
                        goto Cleanup;
                    
                }
            }
        }
        }
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceBody
//
//  Synopsis:   Makes sure the <body> is NOT included in the source of the
//              paste.
//
//-----------------------------------------------------------------------------

static HRESULT
Contain (
    CMarkupPointer * pointer,
    CMarkupPointer * pointerLeft,
    CMarkupPointer * pointerRight )
{
    HRESULT hr = S_OK;
    
    if (Compare( pointerLeft, pointer ) > 0)
    {
        hr = THR( pointer->MoveToPointer( pointerLeft ) );

        if (hr)
            goto Cleanup;
    }

    if (Compare( pointerRight, pointer ) < 0)
    {
        hr = THR( pointer->MoveToPointer( pointerRight ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

static HRESULT
FixupPasteSourceBody (
    CDoc *           pDoc,
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish )
{
    HRESULT        hr = S_OK;
    CElement *     pElementClient;
    CMarkup *      pMarkup;
    CMarkupPointer pointerBodyStart( pDoc );
    CMarkupPointer pointerBodyFinish( pDoc );

    //
    // Get the markup container associated with the sel
    //

    pMarkup = pPointerSourceStart->Markup();

    Assert( pMarkup );

    //
    // Get the client element from the markup and check to make sure
    // it's there and is a body element.
    //

    pElementClient = pMarkup->GetElementClient();

    if (!pElementClient || pElementClient->Tag() != ETAG_BODY)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Move temp pointers to the inside edges of the body
    //

    hr = THR(
        pointerBodyStart.MoveAdjacentToElement(
            pElementClient, ELEM_ADJ_AfterBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pointerBodyFinish.MoveAdjacentToElement(
            pElementClient, ELEM_ADJ_BeforeEnd ) );

    if (hr)
        goto Cleanup;

    //
    // Make sure the source start and finish are within the body
    //

    hr = THR( Contain( pPointerSourceStart, & pointerBodyStart, & pointerBodyFinish ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( Contain( pPointerSourceFinish, & pointerBodyStart, & pointerBodyFinish ) );
    
    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSource
//
//  Synopsis:   Makes sure the source of a paste is valid.  This means, for
//              the most part, that sub-parts of tables must not be pasted
//              without their corresponding table.
//
//-----------------------------------------------------------------------------

static HRESULT
FixupPasteSource (
    CDoc *           pDoc,
    BOOL             fFixupFragComments,
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish )
{
    HRESULT hr = S_OK;

    if (fFixupFragComments)
    {
        hr = THR(
            FixupPasteSourceFragComments(
                pDoc, pPointerSourceStart, pPointerSourceFinish ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( FixupPasteSourceBody( pDoc, pPointerSourceStart, pPointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    hr = THR( FixupPasteSourceTables( pDoc, pPointerSourceStart, pPointerSourceFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   GetRightPartialBlockElement
//
//  Synopsis:   Get the partial block element on the right
//
//-----------------------------------------------------------------------------

static void
GetRightPartialBlockElement (
    CMarkupPointer * pPointerLeft,
    CMarkupPointer * pPointerRight,
    CElement * *     ppElementPartialRight )
{
    CTreeNode * pNode;

    Assert( pPointerLeft && pPointerRight );
    Assert( ppElementPartialRight );
    
    *ppElementPartialRight = NULL;
    
    //
    // We want to only examine elements which partially overlapp either side.
    //
    // Set the mark bits on the left and right branches such that _fMark1
    // on the left branch being 1 means that that elements does not totally
    // overalpp.  Also _fMark2 on the right.
    //

    for ( pNode = pPointerLeft->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark1 = 1;

    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark2 = 1;
    
    for ( pNode = pPointerLeft->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark2 = 0;

    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
        pNode->Element()->_fMark1 = 0;

    //
    // Run up the right for a partial overlapping block element
    //
    
    for ( pNode = pPointerRight->Branch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();
        
        if (!pElement->_fMark2)
            continue;

        if (!*ppElementPartialRight && pElement->IsBlockElement())
            *ppElementPartialRight = pElement;
                    
        if (pElement->IsRunOwner())
            *ppElementPartialRight = NULL;
    }
}
    
//+----------------------------------------------------------------------------
//
//  Function:   ResolveConflict
//
//  Synopsis:   Resolves an HTML DTD conflict between two elements by removing
//              the top element over a limited range (defined by the bottom
//              element).
//
//-----------------------------------------------------------------------------

static HRESULT
ResolveConflict(
    CDoc *     pDoc,
    CElement * pElementBottom,
    CElement * pElementTop )
{
    HRESULT          hr = S_OK;

    if(!pDoc)
        return E_FAIL;

    BOOL             fFoundContent;
    CElement *       pElementClone = NULL;
    CMarkupPointer   pointerTopStart ( pDoc );
    CMarkupPointer   pointerTopFinish ( pDoc );
    CMarkupPointer   pointerBottomStart ( pDoc );
    CMarkupPointer   pointerBottomFinish ( pDoc );
    CMarkupPointer   pointerTemp ( pDoc );

    Assert( pElementBottom->IsInMarkup() );
    Assert( pElementTop->IsInMarkup() );

    //
    // Addref the top element to make sure it does not go away while it
    // is out of the tree.
    //

    pElementTop->AddRef();

    //
    // In IE4, we would never remove a ped (IsContainer is nearly equivalent).
    // So, if a conflict arises where the top element is a ccontainer, remove
    // the bottom element instead.  Also, if there is no container above the
    // top element, we should not remove it.  THis takes care to not remove
    // elements like HTML.
    //

    if (pElementTop->IsContainer() || ! pElementTop->GetFirstBranch()->GetContainer())
    {
        hr = THR( pDoc->RemoveElement( pElementBottom ) );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

#if DBG == 1
    pointerTopStart.SetDebugName( _T( "Top Start" ) );
    pointerTopFinish.SetDebugName( _T( "Top Finish" ) );
    pointerBottomStart.SetDebugName( _T( "Bottom Start" ) );
    pointerBottomFinish.SetDebugName( _T( "Bottom Finish" ) );
#endif
    
    //
    // First, more pointer to the locations of the elements in question.
    //
    
    hr = THR(
        pointerTopStart.MoveAdjacentToElement(
            pElementTop, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        pointerTopFinish.MoveAdjacentToElement(
            pElementTop, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pointerBottomStart.MoveAdjacentToElement(
            pElementBottom, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        pointerBottomFinish.MoveAdjacentToElement(
            pElementBottom, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    //
    // Make sure the input elements are where we think they 'aught to be
    //

    Assert( pointerTopStart.IsLeftOf( & pointerBottomStart ) );
    Assert( pointerTopFinish.IsRightOf( & pointerBottomStart ) );

    //
    // Now, remove the top element and reinsert it so that it is no
    // over the bottom element.
    //

    hr = THR( pDoc->RemoveElement( pElementTop ) );

    if (hr)
        goto Cleanup;

    //
    // Look left.  If we can get to the beginning of the top element,
    // without seeing any text (including break chars) or any elements
    // terminating then we must not put the top element back in before
    // the bottom.
    //

    hr = THR( pointerTemp.MoveToPointer( & pointerBottomStart ) );

    if (hr)
        goto Cleanup;

    fFoundContent = TRUE;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        DWORD               dwBreaks;

        //
        // Where a break is relative to a pointer is ambiguous.  Assume they
        // are to the left of the pointer.  Thus, before moving left, check
        // for breaks.
        //

        hr = THR( pointerTemp.QueryBreaks( & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
            break;

        //
        // See if we have reached the beginning of the top element
        //

        if (pointerTemp.IsEqualTo( & pointerTopStart ))
        {
            fFoundContent = FALSE;
            break;
        }

        //
        // Now, move the pointer left
        //

        hr = THR( pointerTemp.Left( TRUE, & ct, NULL, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct != CONTEXT_TYPE_ExitScope)
            break;
    }

    if (fFoundContent)
    {
        hr = THR(
            pDoc->InsertElement(
                pElementTop, & pointerTopStart, & pointerBottomStart ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Look right.
    //

    hr = THR( pointerTemp.MoveToPointer( & pointerBottomFinish ) );

    if (hr)
        goto Cleanup;

    fFoundContent = TRUE;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        DWORD               dwBreaks;
        
        hr = THR( pointerTemp.QueryBreaks( & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
            break;

        if (pointerTemp.IsEqualTo( & pointerTopFinish ))
        {
            fFoundContent = FALSE;
            break;
        }
        
        hr = THR( pointerTemp.Right( TRUE, & ct, NULL, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct != CONTEXT_TYPE_ExitScope)
            break;
    }

    if (fFoundContent)
    {
        hr = THR( pElementTop->Clone( & pElementClone, pDoc ) );

        if (hr)
            goto Cleanup;

        //
        // If we have overlapping tags, then TopFinish can be to the right of BottonFinish.
        // In this case, the right resolution to the conflict is not to insert the element.
        // 
        // For example:
        //
        //     <E1> x <E2> y </E1> z </E2> should be <E1> x </E1><E2> y z </E2>
        //
        if (pointerTopFinish.IsRightOfOrEqualTo( & pointerBottomFinish ))
        {
            hr = THR(
                pDoc->InsertElement(
                    pElementClone, & pointerBottomFinish, & pointerTopFinish ) );
    
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    if (pElementClone)
        pElementClone->Release();

    pElementTop->Release();
    
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   IsEmbeddedElement
//
//  Synopsis:   Intrinsic control and tables are special elements that we must
//              "jump over" while doing a block merge.
//
//-----------------------------------------------------------------------------

BOOL
IsEmbeddedElement ( CTreeNode * pNode )
{
    switch ( pNode->Tag() )
    {
    case ETAG_BUTTON:
    case ETAG_TEXTAREA:
    case ETAG_FIELDSET:
    case ETAG_LEGEND:
    case ETAG_MARQUEE:
    case ETAG_SELECT:
    case ETAG_TABLE:
        
        return TRUE;

    default:

        return pNode->ShouldHaveLayout();
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   SanitizeRange
//
//  Synopsis:   ...
//
//-----------------------------------------------------------------------------

static HRESULT
ConvertShouldCrLf ( CMarkupPointer * pmp, BOOL & fShouldConvert )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;

    fShouldConvert = FALSE;

    for ( pNode = pmp->Branch() ; pNode ; pNode = pNode->Parent() )
    {
        CElement * pElement = pNode->Element();

        if (pElement->IsContainer())
        {
            fShouldConvert = pElement->HasFlag( TAGDESC_ACCEPTHTML );

            goto Cleanup;
        }

        if (pElement->HasFlag( TAGDESC_LITERALTAG ))
        {
            fShouldConvert = FALSE;

            goto Cleanup;
        }

        //
        // Special case for PRE because it is not marked as literal
        //

        if (pElement->Tag() == ETAG_PRE)
        {
            fShouldConvert = FALSE;

            goto Cleanup;
        }
    }
    
Cleanup:

    RRETURN( hr );
}

static HRESULT
LaunderEdge ( CMarkupPointer * pmp )
{
    HRESULT                hr = S_OK;
    IHTMLEditingServices * pedserv = NULL;
    CMarkupPointer         pmpOther ( pmp->Doc() );

    if (!pedserv)
    {
        IHTMLEditor * phtmed = pmp->Doc()->GetHTMLEditor();

        if (!phtmed)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            phtmed->QueryInterface(
                IID_IHTMLEditingServices, (void **) & pedserv ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR( pmpOther.MoveToPointer( pmp ) );

    if (hr)
        goto Cleanup;

    hr = THR( pedserv->LaunderSpaces( pmp, & pmpOther ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    ReleaseInterface( pedserv );
    
    RRETURN( hr );
}

static HRESULT
SanitizeCrLf ( CMarkupPointer * pmp, long & cchAfter )
{
    HRESULT             hr = S_OK;
    CDoc *              pDoc = pmp->Doc();
    CMarkupPointer      mp2 ( pDoc );
    CElement *          pElementNew = NULL;
    TCHAR               ch1, ch2;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fShouldConvert;
    long                cch;

    //
    // cchAfter is the numner of characters this member deals with after the
    // passed in pointer.
    //

    cchAfter = 0;

    //
    // First, determine the combination of CR/LF chars here
    //

    hr = THR( mp2.MoveToPointer( pmp ) );

    if (hr)
        goto Cleanup;

    hr = THR( mp2.Left( TRUE, & ct, NULL, & (cch = 1), & ch1, NULL ) );

    if (hr)
        goto Cleanup;

    Assert( ct == CONTEXT_TYPE_Text && cch == 1 );
    Assert( ch1 == _T('\r') || ch1 == _T('\n') );

    hr = THR( pmp->Right( FALSE, & ct, NULL, & (cch = 1), & ch2, NULL ) );

    if (hr)
        goto Cleanup;

    if (ct != CONTEXT_TYPE_Text || cch != 1)
        ch2 = 0;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
    {
        hr = THR( pmp->Right( TRUE, NULL, NULL, & (cch = 1), NULL, NULL ) );

        if (hr)
            goto Cleanup;
        
        cchAfter++;
    }

    //
    // Now, the text between mp2 and pmp comprises a single line break.
    // Replace it with some marup if needed.
    //

    hr = THR( ConvertShouldCrLf( pmp, fShouldConvert ) );

    if (hr)
        goto Cleanup;

    if (fShouldConvert)
    {
        //
        // Remove the Cr/LF and insert a BR
        //

        hr = THR( pDoc->Remove( & mp2, pmp ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->PrimaryMarkup()->CreateElement( ETAG_BR, & pElementNew ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertElement( pElementNew, pmp, NULL ) );

        if (hr)
            goto Cleanup;
    }
    
Cleanup:

    if (pElementNew)
        pElementNew->Release();

    RRETURN( hr );
}

static HRESULT
SanitizeRange ( CMarkupPointer * pmpStart, CMarkupPointer * pmpFinish )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = pmpStart->Doc();
    CMarkupPointer mp ( pDoc );
    TCHAR *        pchBuff = NULL;
    long           cchBuff = 0;

    hr = THR( mp.MoveToPointer( pmpStart ) );

    if (hr)
        goto Cleanup;

    IGNORE_HR( mp.SetGravity( POINTER_GRAVITY_Right ) );

// move the start and finish out to catch adjacent space...
// --> instead, use launder spaces to deal with spaces at the edges of block element

    while ( mp.IsLeftOf( pmpFinish ) )
    {
        MARKUP_CONTEXT_TYPE ct;
        long                cch = cchBuff;
        long                ich;
        TCHAR *             pch;

        //
        // NOTE: 
        //
        // It is quite possible to process text AFTER pmpFinish.  This
        // should not be a problem, but if it is, I should add a feature
        // to the There member to stop at a give pointer.  THis may be difficult
        // in that unembedded pointers will have to be searched!
        //

        hr = THR( mp.Right( TRUE, & ct, NULL, & cch, pchBuff, NULL ) );

        if (hr)
            goto Cleanup;
        
        if (ct != CONTEXT_TYPE_Text)
            continue;

        //
        // See if we were not able to get the entire run of text into the buffer
        //

        if (cch == cchBuff)
        {
            long cchMore = -1;
            
            hr = THR( mp.Right( TRUE, & ct, NULL, & cchMore, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            //
            // In order to know if we got all the text, we try to get one more
            // char than we know is there.
            //

            Assert( cchBuff <= cch + cchMore );

            delete pchBuff;

            pchBuff = new TCHAR [ cch + cchMore + 1 ];

            if (!pchBuff)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchBuff = cch + cchMore + 1;

            //
            // Now, move the pointer back and attempt to get the text again.
            //

            cchMore += cch;

            hr = THR( mp.Left( TRUE, NULL, NULL, & cchMore, NULL, NULL ) );

            if (hr)
                goto Cleanup;

            continue;
        }

        //
        // Now, examine the buffer for CR/LF or adjacent spaces
        //

        for ( ich = 0, pch = pchBuff ; ich < cch ; ich++, pch++ )
        {
            TCHAR ch = *pch;
            
            if (ch == _T('\r') || ch == _T('\n'))
            {
                CMarkupPointer mpCRLF ( pDoc );
                long           cchMoveBack, cchAfter;

                hr = THR( mpCRLF.MoveToPointer( & mp ) );

                if (hr)
                    goto Cleanup;

                cchMoveBack = cch - ich - 1;

                hr = THR( mpCRLF.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                if (hr)
                    goto Cleanup;
                
                hr = THR( SanitizeCrLf( & mpCRLF, cchAfter ) );

                if (hr)
                    goto Cleanup;

                ich += cchAfter;
                pch += cchAfter;
            }
            else if (ch == _T(' ') && ich + 1 < cch && *(pch + 1) == _T(' '))
            {
                BOOL fShouldConvert;
                
                hr = THR( ConvertShouldCrLf( & mp, fShouldConvert ) );

                if (hr)
                    goto Cleanup;

                if (fShouldConvert)
                {
                    CMarkupPointer mpBeforeSpace ( pDoc );
                    CMarkupPointer mpAfterSpace ( pDoc );
                    long           cchMoveBack;
                    TCHAR          cpSpace;

                    hr = THR( mpAfterSpace.MoveToPointer( & mp ) );

                    if (hr)
                        goto Cleanup;

                    cchMoveBack = cch - ich - 1;

                    hr = THR( mpAfterSpace.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                    if (hr)
                        goto Cleanup;
                    
                    hr = THR( mpBeforeSpace.MoveToPointer( & mpAfterSpace ) );

                    if (hr)
                        goto Cleanup;

                    cchMoveBack = 1;

                    hr = THR( mpBeforeSpace.Left( TRUE, NULL, NULL, & cchMoveBack, NULL ) );

                    if (hr)
                        goto Cleanup;

                    hr = THR( pDoc->Remove( & mpBeforeSpace, & mpAfterSpace ) );

                    if (hr)
                        goto Cleanup;

                    cpSpace = WCH_NBSP;

                    hr = THR( pDoc->InsertText( & mpBeforeSpace, & cpSpace, 1 ) );

                    if (hr)
                        goto Cleanup;
                }
            }
        }
    }

    hr = THR( LaunderEdge( pmpStart ) );

    if (hr)
        goto Cleanup;

    hr = THR( LaunderEdge( pmpFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    delete pchBuff;

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   MergeBlock
//
//  Synopsis:   Does a block merge.  The content after the give block element
//              is merged with that block elements content.
//
//-----------------------------------------------------------------------------

static BOOL
IsAccessDivHack( CTreeNode * pNode )
{
    CElement * pElement;
    LPCTSTR    strClass;
    
    if (!pNode)
        return FALSE;
    
    if (pNode->Tag() != ETAG_DIV)
        return FALSE;

    pElement = pNode->Element();

    if (!pElement)
        return FALSE;

    strClass = pElement->GetAAclassName();

    if (!strClass)
        return FALSE;

    if (!StrCmpC( strClass, _T( "MicrosoftAccessBanner" ) ))
        return TRUE;
    
    if (!StrCmpC( strClass, _T( "MSOShowDesignGrid" ) ))
        return TRUE;

    return FALSE;
}

HRESULT
MergeBlock ( CMarkupPointer * pPointerMerge )
{
    HRESULT          hr = S_OK;
    CDoc *           pDoc = pPointerMerge->Doc();
    CMarkup *        pMarkup = pPointerMerge->Markup();
    CElement *       pElementContainer;
    CFlowLayout *    pFlowContainer;
    CMarkupPointer   pointer ( pDoc );
    CMarkupPointer   pointerEnd ( pDoc );
    CElement *       pElementBlockMerge;
    CTreeNode *      pNodeBlockMerge;
    CTreeNode *      pNode;
    CLineBreakCompat breaker;
    BOOL             fFoundContent;
    CElement *       pElementBlockContent = NULL;
    int              i;
    CStackPtrAry < CElement *, 4 > aryMergeLeftElems ( Mt( Mem ) );
    CStackPtrAry < CElement *, 4 > aryMergeRightElems ( Mt( Mem ) );
    CStackPtrAry < INT_PTR, 4 > aryMergeRightElemsRemove ( Mt( Mem ) );

    breaker.SetWantPendingBreak( TRUE );

    Assert( pPointerMerge->IsPositioned() );

    //
    // The merge must be contained to certain elements.  For example, a TD
    // cannot be merged with stuff after it.
    //
    // Text sites are the limiting factor here.  Locate the element which
    // will contain the merge.  
    //

    if (!pPointerMerge->Branch())
        goto Cleanup;
    
    pElementContainer = pPointerMerge->Branch()->GetFlowLayoutElement();

    if (!pElementContainer)
        goto Cleanup;

    pFlowContainer = pElementContainer->HasFlowLayout();

    Assert( pFlowContainer );

    //
    // Locate the block element the merge pointer is currently in.  This
    // is the block element which will subsume the content to its right.
    //

    pNodeBlockMerge =
        pMarkup->SearchBranchForBlockElement(
            pPointerMerge->Branch(), pFlowContainer );

    if (!pNodeBlockMerge)
        goto Cleanup;

    pElementBlockMerge = pNodeBlockMerge->Element();

    //
    // Search right looking for real content.  The result of this will
    // be the element under which this content exists.
    //

    hr = THR( pointer.MoveToPointer( pPointerMerge ) );

    if (hr)
        goto Cleanup;

    fFoundContent = FALSE;
    
    for ( ; ; )
    {
        DWORD dwBreaks;
        CTreeNode * pNode;
        CElement * pElementFlow;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        pNode = pointer.Branch();

        if (!pNode)
            break;

        pElementFlow = pNode->GetFlowLayoutElement();

        if (!pElementFlow || pElementFlow != pElementContainer)
            break;

        //
        // Get the current block element
        //
        
        pNode =
            pMarkup->SearchBranchForBlockElement( pNode, pFlowContainer );

        if (!pNode)
            break;
        
        pElementBlockContent = pNode->Element();

        //
        // Get the current break
        //

        hr = THR( breaker.QueryBreaks( & pointer, & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks && pElementBlockContent != pElementBlockMerge)
        {
            fFoundContent = TRUE;
            break;
        }
        //
        // See if there is content to the right
        //

        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            fFoundContent = TRUE;
            break;
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack( pNode ))
                break;
            
            if (IsEmbeddedElement( pNode ))
            {
                fFoundContent = TRUE;
            
                hr = THR( pointer.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;

                break;
            }
        }
    }

    if (!fFoundContent)
        goto Cleanup;

    //
    // Now, locate the extent of this content un this element
    //

    hr = THR( pointerEnd.MoveToPointer( & pointer ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        DWORD dwBreaks;
        CTreeNode * pNode;
        CElement * pElementFlow;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        pNode = pointer.Branch();

        if (!pNode)
            break;

        pElementFlow = pNode->GetFlowLayoutElement();

        if (!pElementFlow || pElementFlow != pElementContainer)
            break;

        //
        // Get the current block element
        //
        
        pNode =
            pMarkup->SearchBranchForBlockElement( pNode, pFlowContainer );

        if (!pNode || pNode->Element() != pElementBlockContent)
            break;

        //
        // Get the current break
        //

        hr = THR( breaker.QueryBreaks( & pointer, & dwBreaks ) );

        if (hr)
            goto Cleanup;

        if (dwBreaks)
        {
            hr = THR( pointerEnd.MoveToPointer( & pointer ) );

            if (hr)
                goto Cleanup;
        }

        //
        // See if there is content to the right
        //

        hr = THR( pointer.Right( TRUE, & ct, & pNode, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            hr = THR( pointerEnd.MoveToPointer( & pointer ) );

            if (hr)
                goto Cleanup;
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack( pNode ))
                break;

            if (IsEmbeddedElement( pNode ))
            {
                hr = THR( pointerEnd.MoveAdjacentToElement( pNode->Element(), ELEM_ADJ_AfterEnd ) );

                if (hr)
                    goto Cleanup;

                hr = THR( pointer.MoveToPointer( & pointerEnd ) );

                if (hr)
                    goto Cleanup;
            }
        }
    }

    //
    // Locate all the elements which will subsume content
    //

    for ( pNode = pPointerMerge->Branch() ;
          pNode->Element() != pElementContainer ;
          pNode = pNode->Parent() )
    {
        if (pFlowContainer->IsElementBlockInContext( pNode->Element() ))
        {
            hr = THR( aryMergeLeftElems.Append( pNode->Element() ) );

            if (hr)
                goto Cleanup;
        }
    }

    //
    // Locate all the elements which will loose content
    //

    for ( pNode = pointerEnd.Branch() ;
          pNode->Element() != pElementBlockMerge && pNode->Element() != pElementContainer ;
          pNode = pNode->Parent() )
    {
        BOOL fHasContentLeftover;
        
        if (!pFlowContainer->IsElementBlockInContext( pNode->Element() ))
            continue;

        {
            CMarkupPointer p ( pDoc );

            fHasContentLeftover = FALSE;
            
            hr = THR( p.MoveToPointer( & pointerEnd ) );

            if (hr)
                goto Cleanup;

            for ( ; ; )
            {
                MARKUP_CONTEXT_TYPE ct;
                CTreeNode * pNode2;
                
                hr = THR( p.Right( TRUE, & ct, & pNode2, NULL, NULL, NULL ) );

                if (hr)
                    goto Cleanup;

                if (ct == CONTEXT_TYPE_ExitScope && pNode2->Element() == pNode->Element())
                    break;

                if (ct == CONTEXT_TYPE_Text)
                {
                    fHasContentLeftover = TRUE;
                    break;
                }
            }
        }
        
        hr = THR( aryMergeRightElemsRemove.Append( ! fHasContentLeftover ) );

        if (hr)
            goto Cleanup;

        hr = THR( aryMergeRightElems.Append( pNode->Element() ) );

        if (hr)
            goto Cleanup;
    }
    
    //
    // Now, move the end of the left elements to subsume the content
    //

    hr = THR( pointerEnd.SetGravity( POINTER_GRAVITY_Right ) );

    if (hr)
        goto Cleanup;

    for ( i = 0 ; i < aryMergeLeftElems.Size() ; i++ )
    {
        CMarkupPointer pointerStart ( pDoc );
        CElement *     pElement = aryMergeLeftElems[i];

        //
        // Make sure we don't move an end tag to the left.
        //

        {
            CMarkupPointer p2 ( pDoc );

            hr = THR( p2.MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ) );

            if (hr)
                goto Cleanup;

            if (p2.IsRightOfOrEqualTo( & pointerEnd ))
                continue;
        }
        
        hr = THR(
            pointerStart.MoveAdjacentToElement(
                pElement, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        pElement->AddRef();
        
        hr = THR( pDoc->RemoveElement( pElement ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            pDoc->InsertElement(
                pElement, & pointerStart, & pointerEnd ) );
        
        if (hr)
            goto Cleanup;

        pElement->Release();
    }

    //
    // Move the begin of the right elements to loose the content
    //

    hr = THR( pointerEnd.SetGravity( POINTER_GRAVITY_Left ) );

    if (hr)
        goto Cleanup;

    for ( i = 0 ; i < aryMergeRightElems.Size() ; i++ )
    {
        CMarkupPointer pointerFinish ( pDoc );
        CElement *     pElement = aryMergeRightElems[i];

        {
            CMarkupPointer p2 ( pDoc );

            hr = THR( p2.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ) );

            if (hr)
                goto Cleanup;

            if (p2.IsLeftOfOrEqualTo( pPointerMerge ))
                continue;
        }
        
        hr = THR(
            pointerFinish.MoveAdjacentToElement(
                pElement, ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;

        pElement->AddRef();
        
        hr = THR( pDoc->RemoveElement( pElement ) );

        if (hr)
            goto Cleanup;

        if (!aryMergeRightElemsRemove[i])
        {
            CMarkupPointer * p1 = & pointerEnd, * p2 = & pointerFinish;

            EnsureLogicalOrder( p1, p2 );

            hr = THR( pDoc->InsertElement( pElement, p1, p2 ) );

            if (hr)
                goto Cleanup;
        }

        pElement->Release();
    }

    //
    // THe content which was "moved" may have \r or multiple spaces which are
    // not legal under the new context.  Sanitize this range.
    //
    
    hr = THR( SanitizeRange( pPointerMerge, & pointerEnd ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

static HRESULT
UiDeleteContent ( CMarkupPointer * pmpStart, CMarkupPointer * pmpFinish )
{
    HRESULT                hr = S_OK;
    CDoc *                 pDoc = pmpStart->Doc();
    IHTMLEditingServices * pedserv = NULL;

    if (!pDoc->GetHTMLEditor())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        pDoc->GetHTMLEditor()->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pedserv ) );

    if (hr)
        goto Cleanup;

    hr = THR( pedserv->Delete( pmpStart, pmpFinish, TRUE ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    ReleaseInterface( pedserv );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveWithBreakOnEmpty
//
//  Synopsis:   Helper fcn which removes stuff between two pointers, and
//              sets the break on empty bit of the block element above
//              the left hand side of the removal.  This is needed for
//              compatibility with IE4 RemoveChars which was used for most
//              text removal operations.
//
//-----------------------------------------------------------------------------

HRESULT
RemoveWithBreakOnEmpty (
    CMarkupPointer * pPointerStart, CMarkupPointer * pPointerFinish )
{
    CMarkup *   pMarkup = pPointerStart->Markup();
    CDoc *      pDoc = pPointerStart->Doc();
    CTreeNode * pNodeBlock;
    HRESULT     hr = S_OK;

    //
    // First, locate the block element above here and set the break on empty bit
    //

    pNodeBlock = pMarkup->SearchBranchForBlockElement( pPointerStart->Branch() );

    if (pNodeBlock)
        pNodeBlock->Element()->_fBreakOnEmpty = TRUE;

    //
    // Now, do the remove
    //

    hr = THR( pDoc->Remove( pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   UnoverlapPartials
//
//  Synopsis:   Assuming the contents of an element have been gutted by a
//              Remove operation, this function will take any elements which
//              partially overlapp it, and remove that partial overalpping.
//
//              For example: calling this on y where we have y overlapped
//              from both sides: "<x><y></x><z></y></z>" will produce
//              "<x><y></y></x><z></z>".
//
//-----------------------------------------------------------------------------

#if DBG == 1

static void
IsBefore (
    CElement * pElement1, ELEMENT_ADJACENCY eAdj1,
    CElement * pElement2, ELEMENT_ADJACENCY eAdj2 )
{
    CMarkupPointer pmp1 ( pElement1->Doc() );
    CMarkupPointer pmp2 ( pElement2->Doc() );

    IGNORE_HR( pmp1.MoveAdjacentToElement( pElement1, eAdj1 ) );
    IGNORE_HR( pmp2.MoveAdjacentToElement( pElement2, eAdj2 ) );

    Assert( pmp1.IsLeftOf( & pmp2 ) );
}

#endif

HRESULT
UnoverlapPartials ( CElement * pElement )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = pElement->Doc();
    CMarkupPointer pmp ( pDoc );
    CElement *     pElementOverlap = NULL;
    CMarkupPointer pmpStart ( pDoc ), pmpFinish ( pDoc );

    Assert( pElement->IsInMarkup() );

    pElement->GetMarkup()->AddRef();

    hr = THR( pmp.MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ) );

    if (hr)
        goto Cleanup;

    for ( ; ; )
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode *         pNodeOverlap;

        hr = THR( pmp.Left( TRUE, & ct, & pNodeOverlap, NULL, NULL, NULL ) );

        if (hr)
            goto Cleanup;

        //
        // All text and no-scopes better have been removed.
        //

        if (ct != CONTEXT_TYPE_EnterScope && ct != CONTEXT_TYPE_ExitScope)
            break;

        if (ct == CONTEXT_TYPE_ExitScope && pNodeOverlap->Element() == pElement)
            break;

        pElementOverlap = pNodeOverlap->Element();
        pElementOverlap->AddRef();

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            WHEN_DBG( IsBefore( pElementOverlap, ELEM_ADJ_BeforeBegin, pElement, ELEM_ADJ_BeforeBegin ) );

            hr = THR( pmpStart.MoveAdjacentToElement( pElementOverlap, ELEM_ADJ_BeforeBegin ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pmpFinish.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );
            
            if (hr)
                goto Cleanup;
        }
        else
        {
            WHEN_DBG( IsBefore( pElement, ELEM_ADJ_AfterEnd, pElementOverlap, ELEM_ADJ_AfterEnd ) );

            hr = THR( pmpFinish.MoveAdjacentToElement( pElementOverlap, ELEM_ADJ_AfterEnd ) );

            if (hr)
                goto Cleanup;
            
            hr = THR( pmpStart.MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );
            
            if (hr)
                goto Cleanup;
        }
        
        hr = THR( pDoc->RemoveElement( pElementOverlap ) );

        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertElement( pElementOverlap, & pmpStart, & pmpFinish ) );

        if (hr)
            goto Cleanup;
        
        pElementOverlap->Release();
        
        pElementOverlap = NULL;
    }

Cleanup:

    pElement->GetMarkup()->Release();
    
    if (pElementOverlap)
        pElementOverlap->Release();

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Performs the actual work of pasting (like, ctrl-V)
//
//-----------------------------------------------------------------------------

HRESULT
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    BOOL             fAutomation )
{
    HRESULT                hr = S_OK;
    
    if(!pPointerTargetStart)
        return E_FAIL;

    CDoc *                 pDoc = pPointerTargetStart->Doc();
    CMarkup *              pMarkup = NULL;
    CMarkupPointer         pointerSourceStart ( pDoc );
    CMarkupPointer         pointerSourceFinish ( pDoc );
    CMarkupPointer         pointerNewContentLeft ( pDoc );
    CMarkupPointer         pointerNewContentRight ( pDoc );
    CMarkupPointer         pointerMergeRight ( pDoc );
    CMarkupPointer         pointerMergeLeft ( pDoc );
    CMarkupPointer         pointerRemoveLeft ( pDoc );
    CMarkupPointer         pointerRemoveRight ( pDoc );
    CMarkupPointer         pointerStatus ( pDoc );
    CElement *             pElementMergeRight;

    //
    // Make sure the pointers are in the same markup and are ordered
    // correctly.
    //

    Assert( pPointerTargetStart->IsPositioned() );
    Assert( pPointerTargetFinish->IsPositioned() );
    Assert( pPointerTargetStart->Markup() == pPointerTargetFinish->Markup() );

    WHEN_DBG( pPointerTargetStart->SetDebugName( _T( "Target Start" ) ) );
    WHEN_DBG( pPointerTargetFinish->SetDebugName( _T( "Target Finish" ) ) );

    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    EnsureLogicalOrder ( pPointerTargetStart, pPointerTargetFinish );

    Assert( Compare( pPointerTargetStart, pPointerTargetFinish ) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    hr = THR(
        pDoc->ParseGlobal(
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pPointerTargetStart->Markup(),  // pContextMarkup
            & pMarkup,
            & pointerSourceStart,
            & pointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    WHEN_DBG( pointerSourceStart.SetDebugName( _T( "Source Start" ) ) );
    WHEN_DBG( pointerSourceFinish.SetDebugName( _T( "Source Finish" ) ) );

    //
    // If there was nothing really there to parse, just do a remove
    //
    
    if (!pMarkup)
    {
        hr = THR( UiDeleteContent( pPointerTargetStart, pPointerTargetFinish ) );

        if (hr)
            goto Cleanup;
        
        goto Cleanup;
    }

    //
    // Make sure this current range is one which is valid to delete and/or
    // replace with something else.  In the old IE4 code, the function
    // ValidateRplace was used to determine this.
    //
    // Also, the ole code used to call ValidateInsert which would decide if
    // the target location was a validate place to insert stuff.
    //
    //

// ValidateInsert code goes here (or similar)

    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // We paste NULL for the last parameter because I do not want the
    // fixup code to conditionally not do the table check.
    //

    hr = THR( FixupPasteSource(
            pDoc, !fAutomation, & pointerSourceStart, & pointerSourceFinish ) );
    if (FAILED(hr))
        goto Cleanup;            
            
    //
    // Compute right block element to merge
    //

    GetRightPartialBlockElement (
        & pointerSourceStart, & pointerSourceFinish, & pElementMergeRight );

    if (hr)
        goto Cleanup;

    //
    // In IE4 because of the way the splice operation was written, any
    // elements which partially overlapped the left side of the stuff to
    // move would not be move to the target.  This implicit behaviour
    // was utilized to effectively get left handed block merging (along
    // with not moving any elements which partially overlapped).
    //
    // Here, I remove all elements which partially overlap the left
    // hand side so that the move operation does not move a clone of them
    // to the target.
    //

    {
        CTreeNode * pNode;
        int i;
        CStackPtrAry < CElement *, 4 > aryRemoveElems ( Mt( Mem ) );
        
        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark1 = 1;

        for ( pNode = pointerSourceFinish.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark2 = 1;

        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark2 = 0;

        for ( pNode = pointerSourceFinish.Branch() ; pNode ; pNode = pNode->Parent() )
            pNode->Element()->_fMark1 = 0;

        for ( pNode = pointerSourceStart.Branch() ; pNode ; pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
            {
                hr = THR( aryRemoveElems.Append( pNode->Element() ) );
                if (hr)
                    goto Cleanup;
            }
        }

        for ( i = 0 ; i < aryRemoveElems.Size() ; i++ )
        {
            hr = THR( pDoc->RemoveElement( aryRemoveElems[i] ) );

            if (hr)
                goto Cleanup;
        }
    }

    //
    // Before actually performing the move, insert two pointers into the
    // target such that they will surround the moved source.
    //
    
    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Right ) );

    hr = THR( pointerNewContentLeft.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;

    hr = THR( pointerNewContentRight.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;

    //
    // Locate the target with pointers which stay to the right of
    // the newly inserted stuff.  This is especially needed when
    // the two are equal.
    //

    hr = THR( pointerRemoveLeft.MoveToPointer( pPointerTargetStart ) );

    if (hr)
        goto Cleanup;
    
    hr = THR( pointerRemoveRight.MoveToPointer( pPointerTargetFinish ) );

    if (hr)
        goto Cleanup;

    IGNORE_HR( pointerRemoveLeft.SetGravity( POINTER_GRAVITY_Right ) );
    IGNORE_HR( pointerRemoveRight.SetGravity( POINTER_GRAVITY_Right ) );

    //
    // Before performing the move, we insert pointers with cling next
    // to elements which we will later perform a merge.  We need to do
    // this because (potentially) clones of the merge elements in the
    // source will be moved to the target because those elements are
    // only partially selected int the source.
    //

    if (pElementMergeRight)
    {
        hr = THR(
            pointerMergeRight.MoveAdjacentToElement(
                pElementMergeRight, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        IGNORE_HR( pointerMergeRight.SetGravity( POINTER_GRAVITY_Right ) );
        
        IGNORE_HR( pointerMergeRight.SetCling( TRUE ) );
    }

    //
    // Now, move the source to the target. Here I insert two pointers
    // to record the location of the source after it has moved to the
    // target.
    //

    hr = THR( pDoc->Move(
            & pointerSourceStart, & pointerSourceFinish,
            pPointerTargetStart ) );
    if (FAILED(hr))
        goto Cleanup;            

    //
    // Now that the new stuff is in, make the pointers which indicate
    // it point inward so that the isolating char does not get in between
    // them.
    //

    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Right ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Left ) );

    //
    // Now, remove the old stuff.  Because we use a rather high level
    // operation to do this, we have to make sure the newly inserted
    // stuff does not get mangled.  We do this by inserting an insulating
    // character.
    //

    {
        long  cch;
        TCHAR ch = _T('~');

        hr = THR( pDoc->InsertText( & pointerNewContentRight, & ch, 1 ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            UiDeleteContent(
                & pointerRemoveLeft, & pointerRemoveRight ) );

        if (hr)
            goto Cleanup;

#if DBG == 1
        {
            MARKUP_CONTEXT_TYPE ct;
        
            IGNORE_HR(
                pointerNewContentRight.Right(
                    FALSE, & ct, NULL, & (cch = 1), & ch ) );

            Assert( ct == CONTEXT_TYPE_Text && ch == _T('~') );
        }
#endif

        hr = THR( pointerRemoveLeft.MoveToPointer( & pointerNewContentRight ) );

        if (hr)
            goto Cleanup;

        hr = THR(
            pointerRemoveLeft.Right(
                TRUE, NULL, NULL, & (cch = 1), NULL ) );

        hr = THR( pDoc->Remove( & pointerNewContentRight, & pointerRemoveLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( pointerRemoveLeft.Unposition() );

        if (hr)
            goto Cleanup;
        
        hr = THR( pointerRemoveRight.Unposition() );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, recover the elements to merge in the target tree
    //

    if (pElementMergeRight)
    {
        MARKUP_CONTEXT_TYPE ct;
        CTreeNode * pNode;
        
        Assert( pointerMergeRight.IsPositioned() );
        
        pointerMergeRight.Right( FALSE, & ct, & pNode, NULL, NULL, NULL );

        Assert( ct == CONTEXT_TYPE_EnterScope );

        pElementMergeRight = pNode->Element();

        hr = THR( pointerMergeRight.Unposition() );

        if (hr)
            goto Cleanup;
    }

    //
    // Now, look for conflicts and remove them
    //

    //
    // Make sure changes to the document get inside the new content pointers
    //
    
    IGNORE_HR( pointerNewContentLeft.SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pointerNewContentRight.SetGravity( POINTER_GRAVITY_Right ) );
    
    for ( ; ; )
    {
        CTreeNode * pNodeFailBottom;
        CTreeNode * pNodeFailTop;

        hr = THR(
            pDoc->ValidateElements(
                & pointerNewContentLeft, & pointerNewContentRight, NULL,
                VALIDATE_ELEMENTS_REQUIREDCONTAINERS,
                &pointerStatus, & pNodeFailBottom, & pNodeFailTop ) );

        if (hr && hr != S_FALSE)
            goto Cleanup;

        if (hr == S_OK)
            break;

        hr = THR(
            ResolveConflict(
                pDoc, pNodeFailBottom->Element(), pNodeFailTop->Element() ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Perform any merging
    //

    if (pElementMergeRight && pElementMergeRight->GetMarkup())
    {
        CMarkupPointer pointer ( pDoc );

        hr = THR(
            pointer.MoveAdjacentToElement(
                pElementMergeRight, ELEM_ADJ_BeforeEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( MergeBlock( & pointer ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Look to see if only site-like elements were pasted in and return them
    // so that htey may be selected after this operation.
    //

    //
    // Because the source context for the paste may have allowed \r's and
    // the like in the text which we just pasted to the target, and the
    // recieving target element may not allow these kind of chars, we must
    // sanitize here.
    //

    hr = THR( SanitizeRange( & pointerNewContentLeft, & pointerNewContentRight ) );

    //
    //
    //

    hr = THR( pointerNewContentLeft.Unposition() );

    if (hr)
        goto Cleanup;
    
    hr = THR( pointerNewContentRight.Unposition() );

    if (hr)
        goto Cleanup;

    ULONG cDie;

    cDie = pDoc->_cDie;

    hr = THR(pDoc->CommitDeferredScripts(FALSE, pPointerTargetStart->Markup()));
    
    if (hr)
        goto Cleanup;

    if (cDie != pDoc->_cDie)
    {
        hr = E_ABORT;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
HandleIE50CompatUIPasteHTML (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch,
    BOOL             fAutomation )
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    hr = THR(
        HandleIE50CompatUIPasteHTML(
            pPointerTargetStart, pPointerTargetFinish, hHtmlText, fAutomation ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleHTMLInjection
//
//  Synopsis:   Workhorse for innerHTML, outerHTML and insertAdjacentHTML and
//              data binding
//
//-----------------------------------------------------------------------------

HRESULT
HandleHTMLInjection (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    HGLOBAL          hglobal,
    CElement *       pElementInside )
{
    HRESULT            hr = S_OK;
    CDoc *             pDoc = pPointerTargetStart->Doc();
    CMarkup *          pMarkupContainer = NULL;
    CMarkup *          pMarkupTarget = NULL;
    CMarkupPointer     pointerSourceStart( pDoc );
    CMarkupPointer     pointerSourceFinish( pDoc );
    CMarkupPointer     pointerStatus( pDoc );
    BOOL               fInHTMLInjectionPrev;
    DWORD              dwFlags = 0;
    
    //
    // Make sure the pointers are in the same markup and are ordered
    // correctly.
    //

    Assert( pPointerTargetStart->IsPositioned() );
    Assert( pPointerTargetFinish->IsPositioned() );
    Assert( pPointerTargetStart->Markup() == pPointerTargetFinish->Markup() );

    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    EnsureLogicalOrder ( pPointerTargetStart, pPointerTargetFinish );

    Assert( Compare( pPointerTargetStart, pPointerTargetFinish ) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    fInHTMLInjectionPrev = pDoc->_fInHTMLInjection;
    pDoc->_fInHTMLInjection = TRUE;

    dwFlags = INTERNAL_PARSE_INNERHTML;
    if (    pPointerTargetStart->Markup()
        &&  pPointerTargetStart->Markup()->IsPrintTemplate())
        dwFlags |= INTERNAL_PARSE_PRINTTEMPLATE;

    hr = THR(
        pDoc->ParseGlobal(
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pPointerTargetStart->Markup(),  // pContextMarkup
            & pMarkupContainer,
            & pointerSourceStart,
            & pointerSourceFinish,
            dwFlags) );

    pDoc->_fInHTMLInjection = fInHTMLInjectionPrev;

    if (hr)
        goto Cleanup;

    pMarkupTarget = pPointerTargetStart->Markup();
    pMarkupTarget->AddRef();

    //
    // If there was nothing really there to parse, just do a remove
    //
    // NOTE: May be merged with the removal after inserting the
    // new stuff.
    //
    
    if (!pMarkupContainer)
    {
        hr = THR(
            RemoveWithBreakOnEmpty(
                pPointerTargetStart, pPointerTargetFinish ) );

        if (hr)
            goto Cleanup;

        if (pElementInside)
        {
            hr = THR( UnoverlapPartials( pElementInside ) );

            if (hr)
                goto Cleanup;
        }

        //
        // We're done, git outta here
        //

        goto Cleanup;
    }
    
    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // Also, the fixup of the source is dependant on the location where
    // it is to be placed.
    //

    hr = THR(
        FixupPasteSource(
            pDoc, FALSE, & pointerSourceStart, & pointerSourceFinish ) );

    if (hr)
        goto Cleanup;

    //
    // See if the source is valid under the context
    //

    hr = THR(
        pDoc->ValidateElements(
            & pointerSourceStart, & pointerSourceFinish, pPointerTargetStart,
            0, &pointerStatus, NULL, NULL ) );

    if (hr == S_FALSE)
    {
        hr = CTL_E_INVALIDPASTESOURCE;
        goto Cleanup;
    }

    if (hr)
        goto Cleanup;

    //
    // Now, remove the old contents, and put the new in.
    //

    hr = THR( RemoveWithBreakOnEmpty( pPointerTargetStart, pPointerTargetFinish ) );

    if (hr)
        goto Cleanup;

    if (pElementInside)
    {
        hr = THR( UnoverlapPartials( pElementInside ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        pDoc->Move(
            & pointerSourceStart, & pointerSourceFinish, pPointerTargetStart ) );

    if (hr)
        goto Cleanup;
    
    ULONG cDie;

    cDie = pDoc->_cDie;

    hr = THR(pDoc->CommitDeferredScripts(FALSE, pMarkupTarget));
    
    if (hr)
        goto Cleanup;

    if (cDie != pDoc->_cDie)
    {
        hr = E_ABORT;
    }

Cleanup:

    if (pMarkupContainer)
        pMarkupContainer->Release();
    
    if (pMarkupTarget)
        pMarkupTarget->Release();

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleHTMLInjection
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
HandleHTMLInjection (
    CMarkupPointer * pPointerTargetStart,
    CMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch,
    CElement *       pElementInside )
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    hr = THR(
        HandleHTMLInjection(
            pPointerTargetStart, pPointerTargetFinish,
            hHtmlText, pElementInside ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\miscprot.h ===
#ifndef I_MISCPROT_H_
#define I_MISCPROT_H_
#pragma INCMSG("--- Beg 'miscprot.h'")

// This function is defined in treenode.cxx
styleBorderStyle ConvertFmToCSSBorderStyle(BYTE bFmBorderStyle);

// This function is defined in disp.cxx
void BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects);

void BoundingRectForAnArrayOfRects(RECT *prcBound, CDataAry<RECT> * paryRects);

#pragma INCMSG("--- End 'miscprot.h'")
#else
#pragma INCMSG("*** Dup 'miscprot.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lswidth.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSWIDTH.CXX -- line services width callbacks
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      08/11/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H
#define X_TXTDEFS_H
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSSETDOC_H_
#define X_LSSETDOC_H_
#include <lssetdoc.h>
#endif

#ifndef X_LSEMS_H_
#define X_LSEMS_H_
#include <lsems.h>
#endif

#ifndef X_LSCBK_H_
#define X_LSCBK_H_
#include <lscbk.h>
#endif

#ifndef X_BRKCLS_H_
#define X_BRKCLS_H_
#include <brkcls.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

//
// Documentation for CSS text-justify can be found on http://ie/specs/secure/trident/text/Line_just.htm
// Documentation for CSS text-autospace can be found on http://ie/specs/secure/trident/text/csc.htm
//

ExternTag(tagLSCallBack);

#define prior5 5        // REVIEW elik (asmusf)
#define priorNum 5

enum CSC
{
    cscUndefined,                       // 0
    cscOpenParenthesisNH,               // 1
    cscOpenParenthesisW,                // 2
    cscCloseParenthesisNH,              // 3
    cscCloseParenthesisW,               // 4
    cscNeutralCharactersNH,             // 5
    cscCommaW,                          // 6
    cscHiraganaOrKatakanaW,             // 7
    cscQuestionOrExclamationW,          // 8
    cscPunctuationN,                    // 9
    cscCenteredCharactersW,             // 10
    cscHiraganaOrKatakanaN,             // 11
    cscPeriodW,                         // 12
    cscSpaceN,                          // 13
    cscSpaceW,                          // 14
    cscIdeographicW,                    // 15
    cscAlphabetsOptionsN,               // 16
    cscDigitsWOrAutospacingOnN,         // 17
    cscInseparableCharactersA,          // 18
    cscGlueCharactersN,                 // 19
    cscPrefixCurrenciesAndSymbol,       // 20
    cscPostfixCurrenciesAndSymbols,     // 21
    cscDigitsWOrAutospacingOffN,        // 22
    cscOpenQuotesA,                     // 23
    cscLim
};

typedef struct
{
    unsigned short csc:5;       // CSC
    unsigned short cscAlt:5;    // Alternate CSC
    unsigned short csco:6;      // CSCOPTION
} PACKEDCSC;

const PACKEDCSC s_aCscMap[] =
{
    { cscOpenParenthesisW,            cscUndefined,               cscoNone             }, // WOB_   1 (  0)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPP   2 (  1)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPA   2 (  2)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOPW   2 (  3)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // HOP_   3 (  4)  
    { cscOpenParenthesisW,            cscUndefined,               cscoNone             }, // WOP_   4 (  5)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // WOP5   5 (  6)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // NOQW   6 (  7)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // AOQW   7 (  8)  
    { cscNeutralCharactersNH,         cscOpenParenthesisNH,       cscoAutospacingParen }, // WOQ_   8 (  9)  
    { cscCloseParenthesisW,           cscUndefined,               cscoNone             }, // WCB_   9 ( 10)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPP  10 ( 11)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPA  10 ( 12)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCPW  10 ( 13)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // HCP_  11 ( 14)
    { cscCloseParenthesisW,           cscUndefined,               cscoNone             }, // WCP_  12 ( 15)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // WCP5  13 ( 16)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // NCQW  14 ( 17)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // ACQW  15 ( 18)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // WCQ_  16 ( 19)
    { cscNeutralCharactersNH,         cscCloseParenthesisNH,      cscoAutospacingParen }, // ARQW  17 ( 20)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NCSA  18 ( 21)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // HCO_  19 ( 22)
    { cscCommaW,                      cscUndefined,               cscoNone             }, // WC__  20 ( 23)
    { cscCommaW,                      cscUndefined,               cscoNone             }, // WCS_  20 ( 24)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WC5_  21 ( 25)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WC5S  21 ( 26)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKS_  22 ( 27)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WKSM  23 ( 28)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WIM_  24 ( 29)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSSW  25 ( 30)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WSS_  26 ( 31)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WHIM  27 ( 32)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WKIM  28 ( 33)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKSL  29 ( 34)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKS_  30 ( 35)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKSC  30 ( 36)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WHS_  31 ( 37)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQFP  32 ( 38)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQFA  32 ( 39)
    { cscQuestionOrExclamationW,      cscUndefined,               cscoNone             }, // WQE_  33 ( 40)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WQE5  34 ( 41)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKCC  35 ( 42)
    { cscCenteredCharactersW,         cscUndefined,               cscoNone             }, // WKC_  36 ( 43)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCP  37 ( 44)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCA  37 ( 45)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NOCW  37 ( 46)
    { cscIdeographicW,                cscUndefined,               cscoVerticalFont     }, // WOC_  38 ( 47)
    { cscIdeographicW,                cscUndefined,               cscoVerticalFont     }, // WOCS  38 ( 48)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WOC5  39 ( 49)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WOC6  39 ( 50)
    { cscPunctuationN,                cscCenteredCharactersW,     cscoWide             }, // AHPW  40 ( 51)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NPEP  41 ( 52)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // NPAR  41 ( 53)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // HPE_  42 ( 54)
    { cscPeriodW,                     cscUndefined,               cscoNone             }, // WPE_  43 ( 55)
    { cscPeriodW,                     cscUndefined,               cscoNone             }, // WPES  43 ( 56)
    { cscPunctuationN,                cscUndefined,               cscoNone             }, // WPE5  44 ( 57)
    { cscInseparableCharactersA,      cscUndefined,               cscoNone             }, // NISW  45 ( 58)
    { cscInseparableCharactersA,      cscUndefined,               cscoNone             }, // AISW  46 ( 59)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCS  47 ( 60)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCW  47 ( 61)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NQCC  47 ( 62)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPTA  48 ( 63)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPNA  48 ( 64)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEW  48 ( 65)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEH  48 ( 66)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // NPEV  48 ( 67)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // APNW  49 ( 68)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // HPEW  50 ( 69)
    { cscPrefixCurrenciesAndSymbol,   cscUndefined,               cscoNone             }, // WPR_  51 ( 70)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQEP  52 ( 71)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQEW  52 ( 72)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // NQNW  52 ( 73)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQEW  53 ( 74)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQNW  53 ( 75)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // AQLW  53 ( 76)
    { cscPostfixCurrenciesAndSymbols, cscUndefined,               cscoNone             }, // WQO_  54 ( 77)
    { cscSpaceN,                      cscUndefined,               cscoNone             }, // NSBL  55 ( 78)
    { cscSpaceW,                      cscUndefined,               cscoNone             }, // WSP_  56 ( 79)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WHI_  57 ( 80)
    { cscHiraganaOrKatakanaN,         cscUndefined,               cscoNone             }, // NKA_  58 ( 81)
    { cscIdeographicW,                cscHiraganaOrKatakanaW,     cscoCompressKana     }, // WKA_  59 ( 82)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASNW  60 ( 83)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASEW  60 ( 84)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASRN  60 ( 85)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASEN  60 ( 86)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALA_  61 ( 87)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // AGR_  62 ( 88)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ACY_  63 ( 89)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WID_  64 ( 90)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WPUA  65 ( 91)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHG_  66 ( 92)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WHG_  67 ( 93)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WCI_  68 ( 94)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOI_  69 ( 95)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOI_  70 ( 96)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIC  70 ( 97)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIL  70 ( 98)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIS  70 ( 99)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WOIT  70 (100)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSEN  71 (101)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSET  71 (102)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSNW  71 (103)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASAN  72 (104)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASAE  72 (105)
    { cscDigitsWOrAutospacingOffN,    cscDigitsWOrAutospacingOnN, cscoAutospacingDigit }, // NDEA  73 (106)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WD__  74 (107)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLLA  75 (108)
    { cscIdeographicW,                cscUndefined,               cscoNone             }, // WLA_  76 (109)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NWBL  77 (110)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NWZW  77 (111)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPLW  78 (112)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPZW  78 (113)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPF_  78 (114)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPFL  78 (115)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NPNW  78 (116)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // APLW  79 (117)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // APCO  79 (118)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ASYW  80 (119)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHYP  81 (120)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NHYW  81 (121)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // AHYW  82 (122)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAPA  83 (123)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NQMP  84 (124)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSLS  85 (125)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSF_  86 (126)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSBS  86 (127)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NSBB  86 (128)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLA_  87 (129)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQ_  88 (130)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQN  88 (131)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLQC  88 (132)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALQ_  89 (133)
    { cscNeutralCharactersNH,         cscIdeographicW,            cscoWide             }, // ALQN  89 (134)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGR_  90 (135)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGRN  90 (136)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGQ_  91 (137)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGQN  91 (138)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCY_  92 (139)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCYP  93 (140)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCYC  93 (141)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAR_  94 (142)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAQL  95 (143)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAQN  95 (144)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHB_  96 (145)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBC  96 (146)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBW  96 (147)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHBR  96 (148)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NASR  97 (149)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAR  97 (150)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAC  97 (151)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAD  97 (152)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAED  97 (153)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NANW  97 (154)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAEW  97 (155)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NAAS  97 (156)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHI_  98 (157)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHIN  98 (158)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHIC  98 (159)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHID  98 (160)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBE_  99 (161)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBEC  99 (162)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBED  99 (163)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBET  99 (164)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGM_ 100 (165)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGMC 100 (166)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGMD 100 (167)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJ_ 101 (168)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJC 101 (169)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGJD 101 (170)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOR_ 102 (171)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NORC 102 (172)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NORD 102 (173)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTA_ 103 (174)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTAC 103 (175)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTAD 103 (176)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTE_ 104 (177)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTEC 104 (178)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTED 104 (179)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKD_ 105 (180)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKDC 105 (181)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKDD 105 (182)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMA_ 106 (183)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMAC 106 (184)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMAD 106 (185)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTH_ 107 (186)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHC 107 (187)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHD 107 (188)
    { cscUndefined,                   cscUndefined,               cscoNone             }, // NTHT 107 (189)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLO_ 108 (190)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLOC 108 (191)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NLOD 108 (192)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTI_ 109 (193)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTIC 109 (194)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTID 109 (195)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTIN 109 (196)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGE_ 110 (197)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NGEQ 111 (198)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBO_ 112 (199)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NBSP 113 (200)
    { cscGlueCharactersN,             cscUndefined,               cscoNone             }, // NBSS 113 (201)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOF_ 114 (202)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOBS 114 (203)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEA 114 (204)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONA 114 (205)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONP 114 (206)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEP 114 (207)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NONW 114 (208)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEW 114 (209)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOLW 114 (210)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOCO 114 (211)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOSP 114 (212)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOEN 114 (213)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // NOBN 114 (214)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NET_ 115 (215)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NETP 115 (216)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NETD 115 (217)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCA_ 116 (218)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NCH_ 117 (219)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // WYI_ 118 (220)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // WYIN 118 (221)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBR_ 119 (222)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NRU_ 120 (223)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOG_ 121 (224)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOGS 121 (225)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NOGN 121 (226)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSI_ 122 (227)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSIC 122 (228)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTN_ 123 (229)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NTNC 123 (230)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKH_ 124 (231)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHC 124 (232)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHD 124 (233)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NKHT 124 (234)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBU_ 125 (235)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBUC 125 (236)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NBUD 125 (237)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSY_ 126 (238)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYP 126 (239)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYC 126 (240)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NSYW 126 (241)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMO_ 127 (242)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOC 127 (243)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOD 127 (244)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMOB 127 (245)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NMON 127 (246)
    { cscNeutralCharactersNH,         cscAlphabetsOptionsN,       cscoAutospacingAlpha }, // NHS_ 128 (247)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // WHT_ 129 (248)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // LS__ 130 (249)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // XNW_ 131 (250)
    { cscNeutralCharactersNH,         cscUndefined,               cscoNone             }, // XNWA 131 (251)
};

//
// Following table maps character class (CHAR_CLASS) to width increment in the loose layout grid mode.
// We store this information on 5 bits only.
// The 4-th bit keeps information about class:
//   * 0 - stands for unambigous class (either wide or narrow),
//   * 1 - stands for ambigous class (wide or narrow - at this point we can not determine)
// Bits 2-3:
//   * for ambigous class stores width increment for narrow characters (see. table)
//   * for unambigous class are not used and set to 0
// Bits 0-1:
//   * for ambigous class stores width increment for wide characters (see. table)
//   * for unambigous class stores width increment for wide or narrow (depends on class) characters (see. table)
//
// Following table presents all possible combination:
//    | bit 1 (3) | bit 0 (2) |
//    |-----------|-----------|
//    |     0     |     0     | width is not incremented                   | width = char_width
//    |     0     |     1     | width is not incremented                   | width = char_width
//    |     1     |     0     | width is incremented by full grid size     | width = char_width + grid
//    |     1     |     1     | width is incremented by half of grid size  | width = char_width + grid/2
// 
const unsigned char s_aLooseTypeWidthIncrement[] =
{
    0x02, // WOB_ 0   
    0x03, // NOPP 1   
    0x03, // NOPA 2   
    0x03, // NOPW 3   
    0x03, // HOP_ 4   
    0x02, // WOP_ 5   
    0x02, // WOP5 6   
    0x03, // NOQW 7   
    0x1e, // AOQW 8   
    0x02, // WOQ_ 9   
    0x02, // WCB_ 10  
    0x03, // NCPP 11  
    0x03, // NCPA 12  
    0x03, // NCPW 13  
    0x03, // HCP_ 14  
    0x02, // WCP_ 15  
    0x02, // WCP5 16  
    0x03, // NCQW 17  
    0x1e, // ACQW 18  
    0x02, // WCQ_ 19  
    0x1e, // ARQW 20  
    0x03, // NCSA 21  
    0x03, // HCO_ 22  
    0x02, // WC__ 23  
    0x02, // WCS_ 24  
    0x02, // WC5_ 25  
    0x02, // WC5S 26  
    0x03, // NKS_ 27  
    0x02, // WKSM 28  
    0x02, // WIM_ 29  
    0x03, // NSSW 30  
    0x02, // WSS_ 31  
    0x02, // WHIM 32  
    0x02, // WKIM 33  
    0x03, // NKSL 34  
    0x02, // WKS_ 35  
    0x00, // WKSC 36  
    0x02, // WHS_ 37  
    0x03, // NQFP 38  
    0x03, // NQFA 39  
    0x02, // WQE_ 40  
    0x02, // WQE5 41  
    0x03, // NKCC 42  
    0x02, // WKC_ 43  
    0x03, // NOCP 44  
    0x03, // NOCA 45  
    0x03, // NOCW 46  
    0x02, // WOC_ 47  
    0x02, // WOCS 48  
    0x02, // WOC5 49  
    0x02, // WOC6 50  
    0x1e, // AHPW 51  
    0x03, // NPEP 52  
    0x03, // NPAR 53  
    0x03, // HPE_ 54  
    0x02, // WPE_ 55  
    0x02, // WPES 56   ???
    0x02, // WPE5 57  
    0x03, // NISW 58  
    0x1e, // AISW 59  
    0x03, // NQCS 60  
    0x03, // NQCW 61  
    0x00, // NQCC 62  
    0x03, // NPTA 63  
    0x03, // NPNA 64  
    0x03, // NPEW 65  
    0x03, // NPEH 66  
    0x03, // NPEV 67  
    0x1e, // APNW 68  
    0x03, // HPEW 69  
    0x02, // WPR_ 70  
    0x03, // NQEP 71  
    0x03, // NQEW 72  
    0x03, // NQNW 73  
    0x1e, // AQEW 74  
    0x1e, // AQNW 75  
    0x1e, // AQLW 76  
    0x02, // WQO_ 77  
    0x03, // NSBL 78  
    0x02, // WSP_ 79  
    0x02, // WHI_ 80  
    0x03, // NKA_ 81  
    0x02, // WKA_ 82  
    0x1e, // ASNW 83  
    0x1e, // ASEW 84  
    0x1e, // ASRN 85  
    0x1e, // ASEN 86  
    0x1e, // ALA_ 87  
    0x1e, // AGR_ 88  
    0x1e, // ACY_ 89  
    0x02, // WID_ 90  
    0x02, // WPUA 91  
    0x03, // NHG_ 92  
    0x02, // WHG_ 93  
    0x02, // WCI_ 94  
    0x03, // NOI_ 95  
    0x02, // WOI_ 96  
    0x00, // WOIC 97  
    0x02, // WOIL 98  
    0x02, // WOIS 99  
    0x02, // WOIT 100 
    0x03, // NSEN 101 
    0x03, // NSET 102 
    0x03, // NSNW 103 
    0x1e, // ASAN 104 
    0x1e, // ASAE 105 
    0x03, // NDEA 106 
    0x02, // WD__ 107 
    0x03, // NLLA 108 
    0x02, // WLA_ 109 
    0x03, // NWBL 110 
    0x03, // NWZW 111 
    0x03, // NPLW 112 
    0x03, // NPZW 113 
    0x03, // NPF_ 114 
    0x03, // NPFL 115 
    0x03, // NPNW 116 
    0x1e, // APLW 117 
    0x00, // APCO 118 
    0x00, // ASYW 119 
    0x03, // NHYP 120 
    0x03, // NHYW 121 
    0x1e, // AHYW 122 
    0x03, // NAPA 123 
    0x03, // NQMP 124 
    0x03, // NSLS 125 
    0x03, // NSF_ 126 
    0x03, // NSBS 127 
    0x03, // NSBB 128 
    0x03, // NLA_ 129 
    0x03, // NLQ_ 130 
    0x03, // NLQN 131 
    0x00, // NLQC 132 
    0x1e, // ALQ_ 133 
    0x03, // ALQN 134 
    0x03, // NGR_ 135 
    0x03, // NGRN 136 
    0x03, // NGQ_ 137 
    0x03, // NGQN 138 
    0x03, // NCY_ 139 
    0x03, // NCYP 140 
    0x00, // NCYC 141 
    0x03, // NAR_ 142 
    0x03, // NAQL 143 
    0x03, // NAQN 144 
    0x03, // NHB_ 145 
    0x00, // NHBC 146 
    0x03, // NHBW 147 
    0x03, // NHBR 148 
    0x00, // NASR 149 
    0x00, // NAAR 150 
    0x00, // NAAC 151 
    0x00, // NAAD 152 
    0x00, // NAED 153 
    0x00, // NANW 154 
    0x00, // NAEW 155 
    0x00, // NAAS 156 
    0x00, // NHI_ 157 
    0x00, // NHIN 158 
    0x00, // NHIC 159 
    0x00, // NHID 160 
    0x00, // NBE_ 161 
    0x00, // NBEC 162 
    0x00, // NBED 163 
    0x00, // NBET 164 
    0x00, // NGM_ 165 
    0x00, // NGMC 166 
    0x00, // NGMD 167 
    0x00, // NGJ_ 168 
    0x00, // NGJC 169 
    0x00, // NGJD 170 
    0x00, // NOR_ 171 
    0x00, // NORC 172 
    0x00, // NORD 173 
    0x00, // NTA_ 174 
    0x00, // NTAC 175 
    0x00, // NTAD 176 
    0x00, // NTE_ 177 
    0x00, // NTEC 178 
    0x00, // NTED 179 
    0x00, // NKD_ 180 
    0x00, // NKDC 181 
    0x00, // NKDD 182 
    0x00, // NMA_ 183 
    0x00, // NMAC 184 
    0x00, // NMAD 185 
    0x00, // NTH_ 186 
    0x00, // NTHC 187 
    0x00, // NTHD 188 
    0x00, // NTHT 189 
    0x00, // NLO_ 190 
    0x00, // NLOC 191 
    0x00, // NLOD 192 
    0x00, // NTI_ 193 
    0x00, // NTIC 194 
    0x00, // NTID 195 
    0x00, // NTIN 196 
    0x03, // NGE_ 197 
    0x03, // NGEQ 198 
    0x03, // NBO_ 199 
    0x03, // NBSP 200 
    0x03, // NBSS 201 
    0x03, // NOF_ 202 
    0x03, // NOBS 203 
    0x03, // NOEA 204 
    0x03, // NONA 205 
    0x03, // NONP 206 
    0x03, // NOEP 207 
    0x03, // NONW 208 
    0x03, // NOEW 209 
    0x03, // NOLW 210 
    0x00, // NOCO 211 
    0x03, // NOSP 212 
    0x03, // NOEN 213 
    0x00, // NOBN 214 
    0x03, // NET_ 215 
    0x03, // NETP 216
    0x03, // NETD 217
    0x03, // NCA_ 218
    0x03, // NCH_ 219
    0x02, // WYI_ 220
    0x02, // WYIN 221
    0x03, // NBR_ 222
    0x03, // NRU_ 223
    0x03, // NOG_ 224
    0x03, // NOGS 225
    0x03, // NOGN 226
    0x00, // NSI_ 227
    0x00, // NSIC 228
    0x03, // NTN_ 229
    0x00, // NTNC 230
    0x00, // NKH_ 231
    0x00, // NKHC 232
    0x00, // NKHD 233
    0x00, // NKHT 234
    0x00, // NBU_ 235
    0x00, // NBUC 236
    0x00, // NBUD 237
    0x00, // NSY_ 238
    0x00, // NSYP 239
    0x00, // NSYC 240
    0x00, // NSYW 241
    0x00, // NMO_ 242
    0x00, // NMOC 243
    0x00, // NMOD 244
    0x00, // NMOB 245
    0x00, // NMON 246
    0x00, // NHS_ 247
    0x02, // WHT_ 248
    0x00, // LS__ 249
    0x00, // XNW_ 250
    0x00, // XNWA 251
};

//-----------------------------------------------------------------------------
//
//  Function:   LooseTypeWidthIncrement
//
//  Synopsis:   Calculate width increment for specified character in 
//              the loose grid layout.
//
//  Returns:    width increment
//
//-----------------------------------------------------------------------------

LONG 
LooseTypeWidthIncrement(
    TCHAR c, 
    BOOL fWide, 
    LONG lGrid)
{
    unsigned char flag = s_aLooseTypeWidthIncrement[CharClassFromCh(c)];

    // If character is narrow and class is ambigous we switch to bits 2-3.
    if (!fWide && (flag & 0x10))
    {
        flag = flag >> 2;
    }

    //
    // We look first at second bit and if it is set to:
    // * 0 - we don't increment character width, so we return '0'
    // * 1 - we look now at first bit and if it set to:
    //   * 0 - we increment character width by grid, so we return 'grid >> 0'
    //   * 1 - we increment character width by grid/2, so we return 'grid >> 1'
    // 
    return (flag & 0x02) ? lGrid >> (flag & 0x01): 0;
}

//-----------------------------------------------------------------------------
//
//  Function:   CscFromCh
//
//  Synopsis:   Determine the CSC from the char with additional information
//              about the run
//
//  Returns:    CSC
//
//-----------------------------------------------------------------------------

CSC
CscFromCh(
    const WCHAR wch,
    long csco )
{
    const PACKEDCSC pcsc = s_aCscMap[CharClassFromCh(wch)];
    CSC csc;

    if (!(pcsc.csco & csco))
    {
        csc = CSC(pcsc.csc);
    }
    else
    {
        csc = CSC(pcsc.cscAlt);
    }

    return csc;
}


//-----------------------------------------------------------------------------
//
//  Function:   PunctStartLine (member, LS callback)
//
//  Synopsis:   Unimplemented LineServices callback
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::PunctStartLine(
    PLSRUN plsrun,      // IN
    MWCLS mwcls,        // IN
    WCHAR wch,          // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(PunctStartLine);
    LSNOTIMPL(PunctStartLine);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModWidthOnRun (member, LS callback)
//
//  Synopsis:   Inter-run width modification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModWidthOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSACT* plsact)          // OUT
{
    LSTRACE(ModWidthOnRun);
    const CSC cscFirst = CscFromCh( wchFirst, plsrunFirst->_csco );
    const CSC cscSecond = CscFromCh( wchSecond, plsrunSecond->_csco );

    //
    // See http://ie/specs/secure/trident/text/csc.htm#Auto_spacing
    //

    if (   (   (cscSecond == 7 || cscSecond == 15)
            && (cscFirst == 3 || cscFirst == 16 || cscFirst == 17))
        || (   (cscFirst == 7 || cscFirst == 15)
            && (cscSecond == 1 || cscSecond == 16 || cscSecond == 17))
        || (   (cscFirst == 8)
            && (cscFirst == 16 || cscFirst == 17)))
    {
        plsact->side = sideRight;
        plsact->kamnt = kamntByQuarterEm;
    }
    else
    {
        plsact->side = sideNone;
        plsact->kamnt = kamntNone;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ModWidthSpace (member, LS callback)
//
//  Synopsis:   Space width modification
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ModWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(ModWidthSpace);

    plsact->side = sideNone;
    plsact->kamnt = kamntNone;

    if (plsrunPrev && plsrunNext)
    {
        const CSC cscFirst = CscFromCh( wchPrev, plsrunPrev->_csco );
        const CSC cscSecond = CscFromCh( wchNext, plsrunNext->_csco );

        //
        // See http://ie/specs/secure/trident/text/csc.htm#Auto_spacing
        //

        if (   (cscFirst == 7 || cscFirst == 15)
            && (cscSecond == 7 || cscSecond == 15))
        {
            plsact->side = sideRight;
            plsact->kamnt = kamntByHalfEm;
        }
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpandOrCompress (static)
//
//  Synopsis:   Whether we can expand or compress is based on the same csc
//              combination for expansion and compression.  The amount and
//              the side will vary.
//
//  Returns:    BOOL - Whether the char/option combination should be subject
//              of expansion or compression
//
//-----------------------------------------------------------------------------

BOOL
ExpandOrCompress(
    WCHAR wchFirst,     // IN
    long cscoFirst,     // IN
    WCHAR wchSecond,    // IN
    long cscoSecond )   // IN
{
    const CSC cscFirst  = CscFromCh( wchFirst,  cscoFirst );
    const CSC cscSecond = CscFromCh( wchSecond, cscoSecond );

    //
    // See http://ie/specs/secure/trident/text/Line_Just.htm
    //

    return (   (   (cscSecond == 7 || cscSecond == 15)
                && (cscFirst == 1 || cscFirst == 16 || cscFirst == 17))
            || (   (cscFirst == 7 || cscFirst == 15)
                && (cscSecond == 1 || cscSecond == 16 || cscSecond == 17))
            || (   (cscFirst == 8)
                && (cscFirst == 16 || cscFirst == 17)));
}

//-----------------------------------------------------------------------------
//
//  Function:   CompOnRun (member, LS callback)
//
//  Synopsis:   Compression on Run behavior
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CompOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSPRACT* plsract)       // OUT
{
    LSTRACE(CompOnRun);

    if (ExpandOrCompress( wchFirst, plsrunFirst->_csco, wchSecond, plsrunSecond->_csco ))
    {
        plsract->lsact.side = sideRight;
        plsract->lsact.kamnt = kamntByEighthEm;
    }
    else
    {
        plsract->lsact.side = sideNone;
        plsract->lsact.kamnt = kamntNone;
    }

    plsract->prior = prior4;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CompWidthSpace (member, LS callback)
//
//  Synopsis:   Space width compression
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::CompWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSPRACT* plspract)  // OUT
{
    LSTRACE(CompWidthSpace);

    if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
    {
        // Newspaper justification is independent of surrounding character classes
        plspract->lsact.kamnt = kamntToUserDefinedComp;
    }
    else
    {
        const BOOL fNonFixedPitch = 0 == (plsrunCur->GetCF()->_bPitchAndFamily & FIXED_PITCH);

        if (   plsrunPrev
            && plsrunNext
            && fNonFixedPitch
            && ExpandOrCompress(wchPrev, plsrunPrev->_csco, wchNext, plsrunNext->_csco))
        {
            plspract->lsact.kamnt = kamntToHalfEm;
        }
        else if (fNonFixedPitch)
        {
            plspract->lsact.kamnt = kamntToQuarterEm;
        }
        else
        {
            plspract->lsact.kamnt = kamntNone;
        }
    }

    //plspract->lsact.side = plspract->lsact.kamnt ? sideLeft : sideNone;
    plspract->lsact.side = sideRight; // LS requires sideRight
    plspract->prior = plspract->lsact.kamnt ? prior1 : prior0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpOnRun (member, LS callback)
//
//  Synopsis:   Determine if we should expand inbetween a given pair of runs
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ExpOnRun(
    PLSRUN plsrunFirst,     // IN
    WCHAR wchFirst,         // IN
    PLSRUN plsrunSecond,    // IN
    WCHAR wchSecond,        // IN
    LSACT* plsact)          // OUT
{
    LSTRACE(ExpOnRun);

    if (ExpandOrCompress( wchFirst, plsrunFirst->_csco, wchSecond, plsrunSecond->_csco ))
    {
        plsact->side = sideRight;
        plsact->kamnt = kamntByQuarterEm;
    }
    else
    {
        plsact->side = sideNone;
        plsact->kamnt = kamntNone;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ExpWidthSpace (member, LS callback)
//
//  Synopsis:   Space width expansion
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::ExpWidthSpace(
    PLSRUN plsrunCur,   // IN
    PLSRUN plsrunPrev,  // IN
    WCHAR wchPrev,      // IN
    PLSRUN plsrunNext,  // IN
    WCHAR wchNext,      // IN
    LSACT* plsact)      // OUT
{
    LSTRACE(ExpWidthSpace);

    if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
    {
        // Newspaper justification is independent of surrounding character classes
        plsact->kamnt = kamntToUserDefinedExpan;
    }
    else
    {
        plsact->kamnt = kamntToHalfEm;
    }

    plsact->side = sideRight;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthClasses (member, LS callback)
//
//  Synopsis:   Return the width-modification index for each character
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::GetModWidthClasses(
    PLSRUN plsrun,      // IN
    const WCHAR* rgwch, // IN
    DWORD cwch,         // IN
    MWCLS* rgmwcls)     // OUT
{
    LSTRACE(GetModWidthClasses);

    const WCHAR * pchSrc = rgwch;
    MWCLS * pbDst = rgmwcls;
#ifdef _MAC
    PACKEDCSC pcscT  = { 0, 0, 0 };
    pcscT.csco = plsrun->_csco;
#else
    const PACKEDCSC pcscT = { 0, 0, plsrun->_csco };
#endif
    const unsigned short uValue = *(unsigned short *)&pcscT;

    while (cwch--)
    {
        WHEN_DBG( const CHAR_CLASS cc = CharClassFromCh(*pchSrc); Assert(!g_Zero.ab[0] || cc); )

        PACKEDCSC pcsc = s_aCscMap[CharClassFromCh(*pchSrc++)];

        if (!((*(unsigned short *)&pcsc) & uValue))
        {
            *pbDst++ = pcsc.csc;
        }
        else
        {
            *pbDst++ = pcsc.cscAlt;
        }
    }

    return lserrNone;
}

// The following table contains indices into the rgpairact table of actions
const BYTE s_rgmodwidthpairs[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  1 cscOpenParenN
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,    //  2 cscOpenParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  3 cscCloseParenN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2,    //  4 cscCloseParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  5 cscNeutralN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2,    //  6 cscCommaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  7 cscKanaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  8 cscPunctW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  9 cscCenteredN
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,    // 10 cscCenteredW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 11 cscPeriodN
    0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,    // 12 cscPeriodW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 13 cscSpaceN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 14 cscSpaceW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 15 cscIdeoW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 16 cscAlphaN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 17 cscEllipse
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 18 cscGlueA
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 19 cscPrefixN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 20 cscPostfixN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 21 cscDigitsN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    // 22 cscDigits
    0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3     // 23 cscOpenQuotesA
};

const LSPAIRACT s_rglspairactV[] =
// first:  side, amount, second: side, amount
{
    sideRight, kamntNone,       sideLeft, kamntNone,
    sideRight, kamntNone,       sideLeft, kamntByHalfEm,
    sideRight, kamntByHalfEm,   sideLeft, kamntNone,
    sideRight, kamntByHalfEm,   sideLeft, kamntNone,
    sideRight, kamntNone,       sideLeft, kamntNone,
    sideRight, kamntByHalfEm,   sideLeft, kamntByHalfEm,
};

HRESULT
CLineServices::SetModWidthPairs()
{
    WHEN_DBG(LSERR lserr = )
            LsSetModWidthPairs( _plsc, sizeof(s_rglspairactV) / sizeof(LSPAIRACT),
                                s_rglspairactV, cscLim, (BYTE *)s_rgmodwidthpairs );

    Assert(!g_Zero.ab[0] || lserr);

    return S_OK;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetEms (member, LS callback)
//
//  Synopsis:   Determine the adjustment amount
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

const long kcchWide     = 41; // approx 5.5" at 10 points
const long kcchNarrow   = 14; // approx 2" at 10 points
const long klCompWide   = 85;
const long klCompNarrow = 75;
const long klExpWide    = 150;
const long klExpNarrow  = 250;

long
Interpolate(int cch, long lMinVal, long lMaxVal)
{
    return (cch <= kcchNarrow)
            ? lMinVal
            : ( (cch >= kcchWide)
                ? lMaxVal
                : lMinVal + MulDivQuick(lMaxVal - lMinVal, cch, kcchWide - kcchNarrow) );
}

LSERR WINAPI
CLineServices::GetEms(
    PLSRUN plsrun,      // IN
    LSTFLOW kTFlow,     // IN
    PLSEMS plems)       // OUT
{
    LSTRACE(GetEms);
    LSERR  lserr;
    CCcs  ccs;

    if (GetCcs(&ccs, plsrun, _pci->_hdc, _pci))
    {
        const int em = ccs.GetBaseCcs()->_xAveCharWidth;

        plems->em   = em;
        plems->em2  = em / 2;
        plems->em3  = em / 3;
        plems->em4  = em / 4;
        plems->em8  = em / 8;
        plems->em16 = MulDivQuick( em, 15, 16 );

        if (_pPFFirst->_uTextJustify == styleTextJustifyNewspaper)
        {
            // get number of chars in column of text
            const int cchCol = _xWrappingWidth / ccs.GetBaseCcs()->_xAveCharWidth;

            plems->udExp  = max(1, MulDivQuick(em, Interpolate(cchCol, klExpNarrow,  klExpWide),  100));
            plems->udComp = max(1, MulDivQuick(em, Interpolate(cchCol, klCompNarrow, klCompWide), 100));
        }
        lserr = lserrNone;
    }
    else
    {
        lserr = lserrOutOfMemory;
    }
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckSetExpansion (member)
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

// The following array contains indices into the rgexp array of expansion actions
#define A 3 // A means expansion allowed always
#define X 2 // X means expansion never
            // 0 means expansion allowed for distributed alignment only

// Expansion actions
const LSEXPAN s_alsexpanTable[] =
{
    // FullScaled  Distributed
    {      0,          1     }, // "0" Distributed only
    {      1,          0     }, //     Justified only -- NOT USED
    {      0,          0     }, // "X" No expansion ever
    {      1,          1     }  // "A" Distributed or Justified (FullScaled)
};

const BYTE s_abIndexExpansion[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  1 cscOpenParenN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  2 cscOpenParenW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  3 cscCloseParenN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  4 cscCloseParenW
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, A, 0, A, 0, A, 0, 0, 0, X, A, A, 0, 0,    //  5 cscNeutralN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  6 cscCommaW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    //  7 cscKanaW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  8 cscPunctW
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, 0, X, 0, 0, 0, 0,    //  9 cscCenteredN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    // 10 cscCenteredW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 11 cscPeriodN
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0,    // 12 cscPeriodW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 13 cscSpaceN
    0, 0, A, 0, A, 0, 0, A, 0, 0, A, A, A, A, A, A, 0, 0, 0, X, A, A, 0, 0,    // 14 cscSpaceW
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 15 cscIdeoW
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, A, 0, A, 0, A, 0, 0, 0, X, A, A, 0, 0,    // 16 cscAlphaN
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, A, A, 0, A, 0, 0, 0, X, A, 0, 0, 0,    // 17 cscEllipse
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, 0, 0, A, 0, X, X, 0, 0, 0, 0,    // 18 cscGlueA
    0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,    // 19 cscPrefixN
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, 0, 0, X, A, A, 0, 0,    // 20 cscPostfixN
    0, 0, 0, 0, 0, A, 0, A, 0, 0, 0, A, 0, A, A, A, A, A, 0, X, A, A, A, 0,    // 21 cscDigitsN
    0, 0, 0, 0, 0, 0, 0, A, 0, 0, 0, 0, A, A, 0, A, 0, 0, 0, X, A, 0, 0, 0,    // 22 cscDigits
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, A, A, 0, 0, 0, 0, X, 0, 0, 0, 0     // 23 cscOpenQuotesA
};


const BYTE s_abIndexExpansionNewspaperNonFE[cscLim][cscLim] =
{
//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 =cscAfter / cscBefore:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  0 cscUndefined
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  1 cscOpenParenN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  2 cscOpenParenW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  3 cscCloseParenN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  4 cscCloseParenW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  5 cscNeutralN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  6 cscCommaW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  7 cscKanaW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  8 cscPunctW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    //  9 cscCenteredN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 10 cscCenteredW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 11 cscPeriodN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 12 cscPeriodW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 13 cscSpaceN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 14 cscSpaceW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 15 cscIdeoW
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 16 cscAlphaN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 17 cscEllipse
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, X, A, A, A, A,    // 18 cscGlueA
    0, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X,    // 19 cscPrefixN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 20 cscPostfixN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 21 cscDigitsN
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A,    // 22 cscDigits
    0, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, X, A, A, A, A     // 23 cscOpenQuotesA
};

#undef A
#undef X

LSERR
CLineServices::CheckSetExpansion()
{
    LSERR lserr;
    BYTE * abIndexExpansion = (BYTE *)
                              ( _pPFFirst->_uTextJustify == styleTextJustifyInterIdeograph 
                                ? s_abIndexExpansion
                                : s_abIndexExpansionNewspaperNonFE );

    if (_abIndexExpansion == abIndexExpansion)
    {
        lserr = lserrNone;
    }
    else
    {
        lserr = LsSetExpansion( _plsc,
                                ARRAY_SIZE(s_alsexpanTable), s_alsexpanTable,
                                cscLim, abIndexExpansion);

        _abIndexExpansion = abIndexExpansion;
    }

    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CheckSetCompression (member)
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

const LSPRACT s_alspractCompression[] =
{
    prior0,     sideNone,       kamntNone,          // not defined
    prior3,     sideLeft,       kamntToHalfEm,      // Open Paren
    prior3,     sideRight,      kamntToHalfEm,      // Close Paren, Comma+Period
    prior5,     sideLeftRight,  kamntTo15Sixteenth, // Kana Compression
    prior2,     sideLeftRight,  kamntToHalfEm,      // Centered Characters

    // Priority 4 is not defined here, reserved for CompOnRun
    // Priority 1 is not defined here, reserved for CompWidthSpace
};

const BYTE s_abIndexPract[cscLim] =
{
    0,  //  0 cscUndefined
    0,  //  1 cscOpenParenN
    1,  //  2 cscOpenParenW
    0,  //  3 cscCloseParenN
    2,  //  4 cscCloseParenW
    0,  //  5 cscNeutralN
    2,  //  6 cscCommaW
    3,  //  7 cscKanaW
    0,  //  8 cscPunctW
    0,  //  9 cscCenteredN
    4,  // 10 cscCenteredW
    0,  // 11 cscPeriodN
    2,  // 12 cscPeriodW
    0,  // 13 cscSpaceN
    0,  // 14 cscSpaceW
    0,  // 15 cscIdeoW
    0,  // 16 cscAlphaN
    0,  // 17 cscEllipse
    0,  // 18 cscGlueA
    0,  // 19 cscPrefixN
    0,  // 20 cscPostfixN
    0,  // 21 cscDigitsN
    0,  // 22 cscDigits
    0,  // 23 cscOpenQuotesA
};

LSERR
CLineServices::CheckSetCompression()
{
    LSERR lserr;

    if (!_abIndexPract)
    {
        lserr = LsSetCompression( _plsc, priorNum,
                                  ARRAY_SIZE(s_alspractCompression), s_alspractCompression,
                                  cscLim, (BYTE *)s_abIndexPract );

        _abIndexPract = (BYTE *)s_abIndexPract;
    }
    else
    {
        lserr = lserrNone;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FGetLastLineJustification (member, LS callback)
//
//  Synopsis:   When you have a justified line, you can either justify or not
//              the last line.  Under some circumstance, you may want to 
//              justfify the line at BRs in addition to block boundaries.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------

LSERR WINAPI
CLineServices::FGetLastLineJustification(
    LSKJUST lskj,               // IN
    LSKALIGN lskal,             // IN
    ENDRES endr,                // IN
    BOOL * pfJustifyLastLine,   // OUT
    LSKALIGN * plskalLine)      // OUT
{
    LSTRACE(FGetLastLineJustification);

    BOOL fJustifyLastLine;

    //
    // We get endr == endrSoftCR whether we have a <BR> or a </P>.  We're interested
    // in the former, but we need to dig around some to determine it.  Note that the
    // assumption here is that if we're being called, any BR we seen in the COneRun
    // linklist is in fact on the line (ie we didn't end up breaking somewhere before
    // the BR after having scanned it.)
    //

    if (   _pPFFirst->_uTextJustify == styleTextJustifyDistributeAllLines
        || _pPFFirst->_uTextAlignLast == styleTextAlignLastJustify)
    {
        fJustifyLastLine = TRUE;
    }
    else if (   _pPFFirst->_uTextJustify == styleTextJustifyNewspaper 
             || _pPFFirst->_uTextJustify == styleTextJustifyInterCluster
             || _pPFFirst->_uTextJustify == styleTextJustifyKashida)
    {
        fJustifyLastLine =    endr == endrSoftCR
                           && _listCurrent._pTail->Branch()->Tag() == ETAG_BR;
    }
    else
    {
        fJustifyLastLine = FALSE;
    }

    *pfJustifyLastLine = fJustifyLastLine;
    switch (_pPFFirst->_uTextAlignLast)
    {
    default:
        *plskalLine = lskal;
        break;

    case styleTextAlignLastLeft:
        *plskalLine = !_li._fRTLLn ? lskalLeft : lskalRight;
        break;

    case styleTextAlignLastCenter:
        *plskalLine = endr == endrSoftCR
                      && _listCurrent._pTail->Branch()->Tag() == ETAG_BR 
                      ? lskal : lskalCentered;
        break;

    case styleTextAlignLastRight:
        *plskalLine = !_li._fRTLLn ? lskalRight : lskalLeft;
        break;
    }
    
    return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsrender.cxx ===
/*
 *  LSRENDER.CXX -- CLSRenderer class
 *
 *  Authors:
 *      Sujal Parikh
 *      Chris Thrasher
 *      Paul  Parker
 *
 *  History:
 *      2/6/98     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include <textxfrm.hxx>
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include <eli.hxx>
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

// This is the number of characters we allocate by default on the stack
// for string buffers. Only if the number of characters in a string exceeds
// this will we need to allocate memory for string buffers.
#define STACK_ALLOCED_BUF_SIZE 256

DeclareTag(tagLSPrintDontAdjustContrastForWhiteBackground, "Print", "Print: Don't adjust contrast for white background");
MtDefine(LSReExtTextOut_aryDx_pv, Locals, "LSReExtTextOut aryDx::_pv")
MtDefine(LSReExtTextOut_aryBuf_pv, Locals, "LSReExtTextOut aryBuf::_pv")
MtDefine(LSUniscribeTextOut_aryAnalysis_pv, Locals, "LSUniscribeTextOut aryAnalysis::_pv")
MtDefine(LSUniscribeTextOutMem, Locals, "LSUniscribeTextOutMem::MemAlloc")
MtDefine(CLSRendererRenderLine_aryBuf_pv, Locals, "CLSRenderer::RenderLine aryBuf::_pv")
MtDefine(CLSRendererRenderLine_aryPassBuf_pv, Locals, "CLSRenderer::RenderLine aryPassBuf::_pv")
MtDefine(CLSRendererTextOut_aryDx_pv, Locals, "CLSRenderer::TextOut aryDx::_pv")
MtDefine(CLSRenderer_aryHighlight, Locals  , "CClsRender::_aryHighlight")

MtDefine(RenderLines, Metrics, "Render/Blast Lines")
MtDefine(BlastedLines, RenderLines, "Lines blasted to the screen")
MtDefine(LSRenderLines, RenderLines, "Lines rendered using LS to the screen");

#ifndef MACPORT
/*
 *  LSReExtTextOutW(CCcs *pccs, hdc, x, y, fuOptions, lprc, lpString, cbCount,lpDx)
 *
 *  @mfunc
 *      Patch around the Win95 FE bug.
 *
 *  @rdesc
 *      Returns whatever ExtTextOut returns
 */

BOOL LSReExtTextOutW(
    CCcs * pccs,                //@parm the font
    XHDC hdc,                   //@parm handle to device context
    int xp,                     //@parm x-coordinate of reference point
    int yp,                     //@parm y-coordinate of reference point
    UINT fuOptions,             //@parm text-output options
    CONST RECT *lprect,         //@parm optional clipping and/or opaquing rectangle
    const WCHAR *lpwchString,   //@parm points to string
    UINT cchCount,              //@parm number of characters in string
    CONST INT *lpDx)            //@parm Ptr to array of intercharacter spacing values
{
    // NB (cthrash) Ported from RichEdit rel0144 11/22/96
    // This is a protion of Word code adapted for our needs.
    // This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
    // characters above Unicode 0x7F are passed to ExtTextOutW.

    int           cch;
    const WCHAR * lpwchT = lpwchString;
    const WCHAR * lpwchStart = lpwchT;
    const WCHAR * lpwchEnd = lpwchString + cchCount;
    const int *   lpdxpCur;
    BOOL          fRet = 0;
    LONG          lWidth=0;
    UINT          uiTA = GetTextAlign(hdc);
    
    if (uiTA & TA_UPDATECP)
    {
        POINT pt;

        SetTextAlign(hdc, uiTA & ~TA_UPDATECP);

        GetCurrentPositionEx(hdc, &pt);

        xp = pt.x;
        yp = pt.y;
    }

    while (lpwchT < lpwchEnd)
    {
        // characters less than 0x007F do not need special treatment
        // we output then in contiguous runs
        if (*lpwchT > 0x007F)
        {
            if ((cch = lpwchT - lpwchStart) > 0)
            {
                lpdxpCur = lpDx ? lpDx + (lpwchStart - lpwchString) : NULL;

                 // Output the run of chars less than 0x7F
                fRet = ::ExtTextOutW( hdc, xp, yp, fuOptions, lprect,
                                      lpwchStart, cch, (int *) lpdxpCur);
                if (!fRet)
                    return fRet;

                fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

                // Advance
                if (lpdxpCur)
                {
                    while (cch--)
                    {
                        xp += *lpdxpCur++;
                    }
                }
                else
                {
                    while (cch)
                    {
                        pccs->Include(lpwchStart[--cch], lWidth);
                        xp += lWidth;
                    }
                }

                lpwchStart = lpwchT;
            }

            // Output chars above 0x7F one at a time to prevent Win95 FE GPF
            lpdxpCur = lpDx ? lpDx + (lpwchStart - lpwchString) : NULL;

            fRet = ::ExtTextOutW(hdc, xp, yp, fuOptions, lprect, 
                                 lpwchStart, 1, (int *)lpdxpCur);

            if (!fRet)
                return fRet;

            fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

            // Advance
            if (lpdxpCur)
            {
                xp += *lpdxpCur;
            }
            else
            {
                pccs->Include( *lpwchStart, lWidth );

                xp += lWidth;
            }

            lpwchStart++;
        }

        lpwchT++;
    }

    // output the final run; also, if we were called with cchCount == 0,
    // make a call here to erase the rectangle
    if ((cch = lpwchT - lpwchStart) > 0 || !cchCount)
    {
        fRet = ::ExtTextOutW( hdc, xp, yp, fuOptions, lprect, lpwchStart, cch,
                              (int *) (lpDx ? lpDx + (lpwchStart - lpwchString) : NULL) );
    }

    if (uiTA & TA_UPDATECP)
    {
        SetTextAlign(hdc, uiTA);

        // Update the xp for the final run.

        AssertSz(!lpDx, "In blast mode -- lpDx should be null.");

        while (cch)
        {
            pccs->Include( lpwchStart[--cch], lWidth );

            xp += lWidth;
        }                
            
        MoveToEx(hdc, xp, yp, NULL);
    }

    return fRet;

}

#endif // MACPORT

//-----------------------------------------------------------------------------
//
//  Function:   WideCharToMultiByteForSymbol
//
//  Purpose:    This function is a hacked-up version of WC2MB that we use to
//              convert when rendering in the symbol font.  Since symbol fonts
//              exist in a codepage-free world, we need to always convert to
//              multibyte to get the desired result.  The only problem comes
//              when you've got content such as the following:
//
//                  <font face="Wingdings">&#171;</font>
//
//              This, incidentally, is the recommended way of creating a little
//              star in your document.  We wouldn't need this hacky converter
//              if the user entered the byte value for 171 instead of the named
//              entity -- this however is problematic for DBCS locales when
//              the byte value may be a leadbyte (and thus would absorb the
//              subsequent byte.)
//
//              Anyway, the hack here is to 'convert' all Unicode codepoints
//              less than 256 by stripping the MSB, and converting normally
//              the rest.
//
//              Note the other unfortunate hack is that we need to convert
//              the offset array
//
//-----------------------------------------------------------------------------

int WideCharToMultiByteForSymbolQuick(UINT,DWORD,LPCWSTR,int,LPSTR,int);
int WideCharToMultiByteForSymbolSlow(UINT,DWORD,LPCWSTR,int,LPSTR,int,const int*,int*,XHDC,const CBaseCcs*);

int
WideCharToMultiByteForSymbol(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb,
    const int * lpDxSrc,
    int *       lpDxDst,
    XHDC        hdc,
    const CBaseCcs * pBaseCcs )
{
    AssertSz( cch != -1, "Don't pass -1 here.");
    int iRet;

    if (lpDxSrc)
    {
        iRet = WideCharToMultiByteForSymbolSlow( uiCodePage, dwFlags, pch, cch, pb, cb, lpDxSrc, lpDxDst, hdc, pBaseCcs );
    }
    else
    {
        iRet = WideCharToMultiByteForSymbolQuick( uiCodePage, dwFlags, pch, cch, pb, cb );
    }

    return iRet;
}

int
WideCharToMultiByteForSymbolQuick(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb )
{
    //
    // This is the quick pass, where we don't need to readjust the width array (lpDx)
    //

    const WCHAR * pchStop = pch + cch;
    const WCHAR * pchStart = NULL;
    const char *  pbStart = pb;
    const char *  pbStop = pb + cb;

    for (;pch < pchStop; pch++)
    {
        TCHAR ch = *pch;

#ifndef UNIX
        if (ch > 255)
        {
            const BYTE b = InWindows1252ButNotInLatin1(ch);
            
            if (b)
            {
                ch = b;
            }
        }
#endif

        if (ch > 255)
        {
            //
            // Accumulate the non Latin-1 characters -- remember the start
            //
            
            pchStart = pchStart ? pchStart : pch;
        }
        else
        {
            if (pchStart)
            {
                //
                // We have accumulated some non-Latin1 chars -- convert these first
                //

                const int cb = WideCharToMultiByte( uiCodePage, dwFlags,
                                                    pchStart, pch - pchStart,
                                                    pb, pbStop - pb,
                                                    NULL, NULL );

                pb += cb;

                pchStart = NULL;
            }

            if (pb < pbStop)
            {
                //
                // Tack on the Latin1 character
                //
                
                *pb++ = ch;
            }
            else
            {
                break;
            }
        }
    }

    if (pchStart)
    {
        //
        // Take care of non-Latin1 chars at the end of the string
        //

        const int cb = WideCharToMultiByte( uiCodePage, dwFlags,
                                            pchStart, pch - pchStart,
                                            pb, pbStop - pb,
                                            NULL, NULL );

        pb += cb;
    }

    return pb - pbStart;
}

int
WideCharToMultiByteForSymbolSlow(
    UINT        uiCodePage,
    DWORD       dwFlags,
    LPCWSTR     pch,
    int         cch,
    LPSTR       pb,
    int         cb,
    const int * lpDxSrc,
    int *       lpDxDst,
    XHDC        hdc,
    const CBaseCcs * pBaseCcs )
{
    //
    // This is the slow pass, where we need to readjust the width array (lpDx)
    // Note lpDxDst is assumed to have (at least) cb bytes in it.
    //

    const WCHAR * pchStop = pch + cch;
    const char *  pbStart = pb;
    const char *  pbStop = pb + cb;

    while (pch < pchStop && pb < pbStop)
    {
        const TCHAR ch = *pch++;

        if (ch < 256)
        {
            *pb++ = char(ch);
            *lpDxDst++ = *lpDxSrc++;
        }
        else
        {
#ifndef UNIX
            const unsigned char chSB = InWindows1252ButNotInLatin1(ch);
            
            if (chSB)
            {
                *pb++ = chSB;
                *lpDxDst++ = *lpDxSrc++;
            }
            else
#endif
            {
                const int cb = WideCharToMultiByte( uiCodePage, dwFlags, &ch, 1, 
                                                    pb, pbStop - pb, NULL, NULL );
                INT xWidthSBC;
                int c = cb;
                while (c)
                {
                    unsigned char uch = pb[c-1];
                    if (GetCharWidthA( hdc, uch, uch, &xWidthSBC ))
                        lpDxDst[c-1] = xWidthSBC;
                    else
                        lpDxDst[c-1] = pBaseCcs->_xAveCharWidth;
                    --c;
                }

                ++lpDxSrc;
                lpDxDst += cb;
                pb += cb;
            }
        }
    }

    return pb - pbStart;
}


/*
 *  LSReExtTextOut
 *
 *  @mfunc
 *      Dispatchs to ExtTextOut that is appropriate for the O/S.
 *
 *  @rdesc
 *      Returns whatever ExtTextOut returns
 */

#define MAX_CHUNK 4000L

DWORD
GetMaxRenderLine() {
 
    static DWORD dwMaxRenderLine = 0;
    HKEY hkInetSettings;
    DWORD dwVal;
    DWORD dwSize;
    DWORD dwType;
    long lResult;

    if(!dwMaxRenderLine) {
        dwMaxRenderLine = MAX_CHUNK;
        if (g_dwPlatformID == VER_PLATFORM_WIN32_NT) 
        {
            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Internet Explorer\\Main"), 0, KEY_QUERY_VALUE, &hkInetSettings);
            if (ERROR_SUCCESS == lResult)  
            {
                dwSize = sizeof(dwVal);
                lResult = RegQueryValueEx(hkInetSettings, _T("MaxRenderLine"), 0, &dwType, (LPBYTE) &dwVal, &dwSize);
                if (ERROR_SUCCESS == lResult && dwSize == sizeof(dwVal) && 
                        (dwType == REG_DWORD || dwType == REG_BINARY)) 
                    dwMaxRenderLine = dwVal;
                RegCloseKey(hkInetSettings);
            } 
        }
    }

    return dwMaxRenderLine;
}

BOOL
LSReExtTextOut(
    CCcs * pccs,                  //@parm the font
    XHDC hdc,                     //@parm handle to device context
    int x,                        //@parm x-coordinate of reference point
    int y,                        //@parm y-coordinate of reference point
    UINT fuOptions,               //@parm text-output options
    CONST RECT *lprc,             //@parm optional clipping and/or opaquing rectangle
    const WCHAR *pchString,       //@parm points to string
    long cchString,               //@parm number of characters in string
    CONST INT *lpDx,              //@parm pointer to array of intercharacter spacing values
    CONVERTMODE cm)               //@parm CM_NONE, CM_SYMBOL, CM_MULTIBYTE, CM_FEONNONFE
{
    BOOL fRetVal=TRUE;
    UINT uiCodePage = pccs->GetBaseCcs()->_sCodePage;
                      

    // Win95 has trouble drawing long strings, even drawing large coordinates.
    // So, we just stop after a few thousand characters.

    cchString = min ((long) GetMaxRenderLine(), cchString);

    //
    // For EUDC-chars (which must be in their own text run, and thus it's own
    // LsReExtTextOut call) cannot be rendered in Win95 through ExtTextOutW; it
    // must be rendered using ExtTextOutA.  For Win98, NT4, and W2K, ExtTextOutW
    // will work just fine.
    //
    
    if (   CM_FEONNONFE == cm
        && cchString
        && IsEUDCChar(pchString[0]))
    {
        // NB (cthrash) We've seen emprically that Win98-PRC is not up to
        // the task, so continue to call ETOA for this platform.

        cm = (   g_dwPlatformVersion < 0x40000
              || (   g_dwPlatformVersion == 0x4000a // win98
                  && g_cpDefault == CP_CHN_GB))     // prc
             ? CM_MULTIBYTE
             : CM_NONE;
    }

    if (CM_SYMBOL == cm || CM_MULTIBYTE == cm)
    {
        // If we are doing LOWBYTE or MULTIBYTE conversion,
        // unless we have a FE font on a non-FE machine.

        CStackDataAry < char, STACK_ALLOCED_BUF_SIZE > aryBuf(Mt(LSReExtTextOut_aryBuf_pv));
        CStackDataAry < int, STACK_ALLOCED_BUF_SIZE> aryDx(Mt(LSReExtTextOut_aryDx_pv));

        char *pbString;
        int * lpDxT = NULL;
        int cbString = 0;
        BOOL fDoDxMap = lpDx && cchString > 1;

        // Double the buffer size, unless in LOWBYTE mode
        int cbBuffer = cchString * 2;

        // Get a buffer as big as it needs to be.
        if (   aryBuf.Grow(cbBuffer) != S_OK
            || (   lpDx
                && aryDx.Grow(cbBuffer) != S_OK
               )
           )
        {
            cbBuffer = STACK_ALLOCED_BUF_SIZE;
        }
        pbString = aryBuf;

        if (lpDx)
        {
            lpDxT = aryDx;
        }

        //
        // NOTE (cthrash) We should really clean this code up a bit --
        // The only difference between CM_MULTIBYTE and CM_SYMBOL as it
        // currently exists is the handling of the U+0080-U+009F range.
        //
        
        if (cm == CM_MULTIBYTE)
        {
            // Convert string

            cbString = WideCharToMultiByte( uiCodePage, 0, pchString, cchString,
                                            pbString, cbBuffer, NULL, NULL );

            if (lpDx && !fDoDxMap)
            {
                lpDxT[0] = *lpDx;
                lpDxT[1] = 0;
            }
        }
        else
        {
            // Note here that we do the lpDx conversion as we go, unlike the
            // CM_MULTIBYTE scenario.

            cbString = WideCharToMultiByteForSymbol( uiCodePage, 0, pchString, cchString,
                                                     pbString, cbBuffer, lpDx, lpDxT, 
                                                     hdc, pccs->GetBaseCcs() );

            // If we were successful, we don't need to map the lpDx
            
            fDoDxMap &= cbString == 0;
        }

        if (!cbString)
        {
            // The conversion failed for one reason or another.  We should
            // make every effort to use WCTMB before we fall back to
            // taking the low-byte of every wchar (below), otherwise we
            // risk dropping the high-bytes and displaying garbage.

            // Use the cpg from the font, since the uiCodePage passed is
            //  the requested codepage and the font-mapper may very well
            //  have mapped to a different one.

            TEXTMETRIC tm;
            UINT uAltCodePage = GetLatinCodepage();

            if (GetTextMetrics(hdc, &tm) && tm.tmCharSet != DEFAULT_CHARSET)
            {
                UINT uFontCodePage =
                      DefaultCodePageFromCharSet( tm.tmCharSet,
                                                  g_cpDefault, 0 );

                if (uFontCodePage != uiCodePage)
                {
                    uAltCodePage = uFontCodePage;
                }
            }

            if (uAltCodePage != uiCodePage)
            {
                cbString = WideCharToMultiByte( uAltCodePage, 0, pchString, cchString,
                                              pbString, cbBuffer, NULL, NULL);
                uiCodePage = uAltCodePage;
            }
        }

        if (!cbString)                         // Convert WCHARs to CHARs
        {
            int cbCopy;

            // FUTURE:  We come here for both SYMBOL_CHARSET fonts and for
            // DBCS bytes stuffed into wchar's (one byte per wchar) when
            // the requested code page is not installed on the machine and
            // the MBTWC fails. Instead, we could have another conversion
            // mode that collects each DBCS char as a single wchar and then
            // remaps to a DBCS string for ExtTextOutA. This would allow us
            // to display text if the system has the right font even tho it
            // doesn't have the right cpg.

            // If we are converting this WCHAR buffer in this manner
            // (by taking only the low-byte's of the WCHAR's), it is
            // because:
            //  1) cm == CM_SYMBOL
            //  2) WCTMB above failed for some reason or another.  It may
            //      be the case that the string is entirely ASCII in which
            //      case dropping the high-bytes is not a big deal (otherwise
            //      we assert).

            cbCopy = cbString = cchString;

            while(cbCopy--)
            {
                AssertSz(pchString[cbCopy] <= 0xFF, "LSReExtTextOut():  Found "
                            "a WCHAR with non-zero high-byte when using "
                            "CM_SYMBOL conversion mode.");
                pbString[cbCopy] = pchString[cbCopy];
            }

            fDoDxMap = FALSE;
            lpDxT = (int *)lpDx;
        }

        // This is really ugly -- our lpDx array is for wide chars, and we
        // may need to convert it for multibyte chars.  Do this only when
        // necessary.

        if (fDoDxMap)
        {
            Assert( cbString <= cbBuffer );

            const int * lpDxSrc = lpDx;
            int * lpDxDst = lpDxT;
            int cb = cbString;
            const WCHAR * pch = pchString;

            memset(lpDxT, 0, cbString * sizeof(int));

            while (cb)
            {
                int cbChar = WideCharToMultiByte( uiCodePage, 0,
                                                  pch, 1, NULL, NULL,
                                                  NULL, NULL );

                Assert( cbChar && cb >= cbChar );

                *lpDxDst = *lpDxSrc++;
                lpDxDst += cbChar;
                cb -= cbChar;
                pch++;
            }
        }

        fRetVal = ExtTextOutA( hdc, x, y, fuOptions, lprc, pbString, cbString, lpDxT );
    }
    else
#ifndef MACPORT
    // do we need the Win95 FE bug workaround??
    if (CM_FEONNONFE == cm)
    {
        fRetVal = LSReExtTextOutW( pccs, hdc, x, y, fuOptions, lprc,
                                   pchString, cchString, lpDx);
    }
    else
#endif
        fRetVal = ::ExtTextOutW(hdc, x, y, fuOptions, lprc,
                                pchString, cchString, (int *)lpDx);

    return (fRetVal);
}

/*
 *  LSUniscribeTextOut
 *
 *  @mfunc
 *      Shapes, places and prints complex text through Uniscribe (USP10.DLL);
 *
 *  @rdesc
 *      Returns indication that we successfully printed through Uniscribe
 */
HRESULT LSUniscribeTextOut(
    const XHDC& hdc,
    int iX,
    int iY,
    UINT uOptions,
    CONST RECT *prc,
    LPCTSTR pString,
    UINT cch,
    int *piDx)
{
    HRESULT hr = S_OK;
    SCRIPT_STRING_ANALYSIS ssa;
    DWORD dwFlags;
    int   xWidth = 0;
    const SIZE *pSize = NULL;
    const int *pich = NULL;
    const SCRIPT_LOGATTR* pSLA = NULL;

    if(piDx)
        *piDx = 0;

    Assert(!g_fExtTextOutGlyphCrash);

    dwFlags = SSA_GLYPHS | SSA_FALLBACK | SSA_BREAK;
    if(uOptions & ETO_RTLREADING)
        dwFlags |= SSA_RTL;

    // BUG 29234 - prc is sometimes passed in NULL
    if (prc != NULL)
    {
        xWidth = prc->right - prc->left;
        dwFlags |= SSA_CLIP;
    }

    while(cch)
    {
        // Using a 0 as the fourth parameter will default the max glyph count at cch * 1.5
        hr = ScriptStringAnalyse(hdc, pString, cch, 0, -1, dwFlags, xWidth,
                                 NULL, NULL, NULL, NULL, NULL, &ssa);

        if (FAILED(hr))
        {
            goto done;
        }

        pich = ScriptString_pcOutChars(ssa);
        if (!pich)
        {
            hr = E_FAIL;
            goto done;
        }

        if((UINT)*pich < cch)
        {
            pSLA = ScriptString_pLogAttr(ssa);

            int i = *pich;

            if(pSLA)
            {
                pSLA += *pich;
                while(i > 0 && !(pSLA->fSoftBreak) && !(pSLA->fWhiteSpace))
                {
                    pSLA--;
                    i--;
                }

                if(i != *pich)
                {
                    ScriptStringFree(&ssa);

                    // Using a 0 as the fourth parameter will default the max glyph count at cch * 1.5
                    hr = ScriptStringAnalyse(hdc, pString, i, 0, -1, dwFlags, xWidth,
                                             NULL, NULL, NULL, NULL, NULL, &ssa);

                    if (FAILED(hr))
                    {
                        goto done;
                    }

                    pich = ScriptString_pcOutChars(ssa);
                    Assert(*pich == i);
                }
            }
        }

        pSize = ScriptString_pSize(ssa);
        
        if(piDx)
        {
            if(pSize->cx > *piDx)
                *piDx = pSize->cx;
        }

        // NOTE: instead of calling ScriptStringOut directly, we call a method on XHDC
        // in order to implement the coordinate transformations that are necessary.
        // This is normally done by GDI wrappers for other rendering methods, but
        // ScriptStringOut has to be treated specially, because it doesn't have an
        // HDC parameter (it's been hidden in ssa by ScriptStringAnalyse).
        hr = hdc.ScriptStringOut(ssa, iX, iY, uOptions, prc, 0, 0, FALSE);

        iY += pSize->cy;

        if(*pich > 0 && (UINT)*pich < cch)
        {
            cch -= *pich;
            pString += *pich;
        }
        else
            cch = 0;

        ScriptStringFree(&ssa);
    }

done:
    return hr;

}


/*
 *  LSIsEnhancedMetafileDC( hDC )
 *
 *  @mfunc
 *      Check if hDC is a Enhanced Metafile DC.
 *      There is work around the Win95 FE ::GetObjectType() bug.
 *
 *  @rdesc
 *      Returns TRUE for EMF DC.
 */

BOOL LSIsEnhancedMetafileDC (
    const XHDC& hDC)            //@parm handle to device context
{
    BOOL fEMFDC = FALSE;

#if !defined(MACPORT) && !defined(WINCE)
    DWORD dwObjectType;

    dwObjectType = ::GetObjectType( hDC );

    if ( OBJ_ENHMETADC == dwObjectType || OBJ_ENHMETAFILE == dwObjectType )
    {
        fEMFDC = TRUE;
    }
    else if ( OBJ_DC == dwObjectType )
    {
        // HACK Alert,  Enhanced Metafile DC does not support any Escape function
        // and shoudl return 0.
        int iEscapeFuction = QUERYESCSUPPORT;
        fEMFDC = Escape( hDC, QUERYESCSUPPORT, sizeof(int),
                         (LPCSTR)&iEscapeFuction, NULL) == 0;
    }
#endif

    return fEMFDC;
}


//-----------------------------------------------------------------------------
//
//  Function:   CLSRenderer::CLSRenderer
//
//  Synopsis:   Constructor for the LSRenderer
//
//-----------------------------------------------------------------------------
CLSRenderer::CLSRenderer (const CDisplay * const pdp, CFormDrawInfo * pDI) :
    CLSMeasurer (pdp, pDI, FALSE),
    _aryHighlight( Mt( CLSRenderer_aryHighlight) )
{
    Assert(pdp);
    Init(pDI);
    _hdc       = pDI->GetDC();

    // TODO TEXT 112556: we shouldn't do this! Drawing DC is for rendering.
    //                 All measuring shoudl be done on a separate DC.
    //                 When printing, this is particularly important.
    //                 Unfortunately, nothing works if this line is removed.
    //                 We'll resort to explicitly using screen DC when we get
    //                 font metrics for IE5.5, and change this in the next release.
    // FUTURE (alexmog): we may actually need the physical DC if we start using
    //                   WYSIWYG support in LS.
    _pci->_hdc = _hdc;
    _hfontOrig = (HFONT)::GetCurrentObject(_hdc, OBJ_FONT);

    _pccsEllipsis = NULL;
    CTreeNode * pFormattingNode = _pdp->GetFlowLayout()->GetFirstBranch();
    _fHasEllipsis = pFormattingNode->HasEllipsis();
    if (_fHasEllipsis)
    {
        const CCharFormat * pCF = pFormattingNode->GetCharFormat();

        _pccsEllipsis = new CCcs;
        if (   _pccsEllipsis
            && !fc().GetCcs(_pccsEllipsis, _hdc, pDI, pCF))
        {
            delete _pccsEllipsis;
            _pccsEllipsis = NULL;
        }
        _fHasEllipsis = (_pccsEllipsis != NULL);
    }
}

//+====================================================================================
//
// Method: Destructor for CLSRenderer
//
// Synopsis: Remove any Highlight Segments which may have been allocated.
//
//------------------------------------------------------------------------------------


CLSRenderer::~CLSRenderer()
{
    // restore original font, including CBaseCcs pointer in CDispSurface
    _hdc.SetBaseCcsPtr(NULL);
    SelectFontEx(_hdc, _hfontOrig);

    if (_pccsEllipsis)
    {
        _pccsEllipsis->Release();
        delete _pccsEllipsis;
    }
}

/*
 *  CLSRenderer::Init
 *
 *  @mfunc
 *      initialize everything to zero
 */
void CLSRenderer::Init(CFormDrawInfo * pDI)
{
    Assert(pDI);

    _pDI        = pDI;
    _rcView     =
    _rcRender   =
    _rcClip     = g_Zero.rc;
    _dwFlags()  = 0;
    _ptCur.x    = 0;
    _ptCur.y    = 0;
    _fRenderSelection = TRUE;

}

/*
 *  CLSRenderer::StartRender (&rcView, &rcRender, yHeightBitmap)
 *
 *  @mfunc
 *      Prepare this renderer for rendering operations
 *
 *  @rdesc
 *      FALSE if nothing to render, TRUE otherwise
 */
BOOL CLSRenderer::StartRender (
    const RECT &rcView,         //@parm View rectangle
    const RECT &rcRender,       //@parm Rectangle to render
    const INT  iliViewStart,
    const LONG cpViewStart)
{
    CRenderInfo     ri;
    CFlowLayout*    pFLayout = _pdp->GetFlowLayout();
    CMarkup*        pMarkup = _pdp->GetMarkup();
    
    if (_hdc.IsEmpty())
    {
        _hdc = _pDI->GetDC();
    }

    AssertSz(!_hdc.IsEmpty(), "CLSRenderer::StartRender() - No rendering DC");

    // Set view and rendering rects
    _rcView = rcView;
    _rcRender = rcRender;

    // Set background mode
    SetBkMode(_hdc, TRANSPARENT);

    _lastTextOutBy = DB_NONE;

    // If this is not the main display or it is a metafile
    // we want to ignore the logic to render selections
    if (pMarkup->IsPrintMedia() || _pDI->IsMetafile())
    {
        _fRenderSelection = FALSE;
    }

    // For hack around ExtTextOutW Win95FE Font and EMF problems.
    _fEnhancedMetafileDC = ((VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID) &&
                            LSIsEnhancedMetafileDC(_hdc));

    ri._pdp = _pdp;
    ri._pDI = _pDI;
    ri._iliStart = iliViewStart;
    ri._cpStart = cpViewStart;
    pMarkup->GetSelectionChunksForLayout( pFLayout, &ri, &_aryHighlight, & _cpSelMin, & _cpSelMax );

    return TRUE;
}

/*
 *  CLSRenderer::NewLine (&li)
 *
 *  @mfunc
 *      Init this CLSRenderer for rendering the specified line
 */
void CLSRenderer::NewLine (const CLineFull &li)
{
    _li = li;

    Assert(GetCp() + _li._cch <= GetLastCp());

    //  for LTR display
    //
    //  |--------------------------------Container width---------------------|
    //  |------------display view width------------------|                   |
    //  |  X-------------- LTR wraping line ---------->  |                   |
    //  |  X-------------- LTR overflowing line ---------|-------------->    |
    //  |  <-------------- RTL wrapping line ---------X  |                   |
    //  |  <-------------- RTL overflowing line ---------|-----------------X |
    //
    if(!_li._fRTLLn)
    {
        _ptCur.x = _rcView.left + _li._xLeftMargin + _li._xLeft;
    }
    else
    {
        _ptCur.x = _rcView.left + _li._xLeftMargin + _li._xLeft + _li._xWidth + _li._xLineOverhang - 1;
    }
        
    //  for RTL display, all content is offset to the right by the difference 
    //  between original view width and container width (that's where logical zero is). 
    //  Overflow lines have negative offsets, calculated at layout time.
    //
    //  |--------------------------------Container width---------------------|
    //  |                   |------------display view width------------------|
    //  |                   |  <-------------- RTL wrapping line ---------X  |
    //  |  <-------------- RTL overflowing line --------------------------X  |
    //  |                   |  X-------------- LTR wraping line ---------->  |
    //  |    X--------------|----------------- LTR overflowing line ------>  |
    //
    if (_pdp->IsRTLDisplay())
    {
        // add content origin, which is non-zero for RTL lines with overflow.
        // TODO RTL 112514: if _rcView.left is ever set to something meaningful for reasons other
        //                  than RTL overflow, this code won't work. 
        _ptCur.x -= _rcView.left;   
    }
    else
    {
        // TODO RTL 112514: need to understand where in LTR _rcView.left is non-zero
        Assert(_rcView.left == 0);
    }

    if(_li._fRelative) // if the current line is relative
    {
        _ptCur.x += _xRelOffset;
    }

    _cchWhiteAtBeginningOfLine = 0;
#if DBG==1
    _xAccumulatedWidth = 0;
    _fBiDiLine = FALSE;
#endif

    // Ellipsis support
    _xRunWidthSoFar = 0;
    _xEllipsisPos = -1;
    _fEllipsisPosSet = FALSE;
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderLine
//
//  Synopsis:   Renders one line of text
//
//  Params:     [li]: The line to be drawn
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
VOID CLSRenderer::RenderLine (CLineFull &li, long xRelOffset)
{
    Assert(_pDI);
    Assert(_pDI->_pSurface);
    
    CMarginInfo marginInfo;
    POINT ptLS;
    LONG cpStartContainerLine;
    LONG xWidthContainerLine;
    LONG cchTotal;
    CTreePos *ptpNext = NULL;
    CTreePos *ptp;
    HRESULT hr;
    CLineCore *pliContainer;
    BOOL fIntersectSelection = FALSE;

    _xRelOffset = xRelOffset;

    NewLine(li);

    if (_li._fHidden)
        goto Cleanup;

    if(_li.IsFrame())
        goto Cleanup;

    if (_li._cch == 0)
        goto Cleanup;

    //
    // We need to render all the characters in the line
    //
    _cpStartRender = GetCp();
    _cpStopRender  = _cpStartRender + _li._cch;

    //
    // marka - examine Cached _cpSelMin, _cpSelMax for when we render.
    //
    if ( _cpSelMax != -1 )
    {
        //
        // Selection starts outside the line and ends
        // inside or beyond the line, then use old method to render
        //

        if (   _cpSelMin <= _cpStartRender
            && _cpSelMax > _cpStartRender
           )
            fIntersectSelection = TRUE;

        //
        // Selection starts inside the line. Irrespective
        // of where it ends, use the old method
        //
        if (   _cpSelMin >= _cpStartRender
            && _cpSelMin <  _cpStopRender
           )
            fIntersectSelection = TRUE;
    }

    if (   _li._fFirstInPara
        && (   _li._fHasFirstLine
            || _li._fHasFirstLetter
           )
       )
    {
        LONG junk;
        AccountForRelativeLines(li,
                                &cpStartContainerLine,
                                &xWidthContainerLine,
                                &_cpStartRender,
                                &_cpStopRender,
                                &cchTotal
                               );
        _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), cchTotal - 1, &junk, &ptp, NULL);
        
        CTreeNode *pNode = ptp->GetBranch();
        pNode = _pLS->_pMarkup->SearchBranchForBlockElement(pNode, _pFlowLayout);
        const CFancyFormat *pFF = pNode->GetFancyFormat();
        
        _cpStopFirstLetter = ((li._fHasFirstLetter && pFF->_fHasFirstLetter)
                              ? GetCpOfLastLetter(pNode)
                              : -1);
        
        if (pFF->_fHasFirstLine && _li._fHasFirstLine)
        {
            PseudoLineEnable(pNode);
        }
        if (pFF->_fHasFirstLetter && _li._fHasFirstLetter && _cpStopFirstLetter >= 0)
        {
            PseudoLetterEnable(pNode);
        }
    }
    
    _rcClip = *_pDI->ClipRect();

    if (_li._fHasBulletOrNum)
    {
        CMarginInfo marginInfo;
        LONG cp = GetCp();
        CTreePos *ptp = GetPtp();

        hr = THR(StartUpLSDLL(_pLS, _pdp->GetMarkup()));
        if (hr)
            goto Cleanup;

        AccountForRelativeLines(li,
                                &cpStartContainerLine,
                                &xWidthContainerLine,
                                &_cpStartRender,
                                &_cpStopRender,
                                &cchTotal
                               );
        
        _pdp->FormattingNodeForLine(FNFL_NONE, cp, ptp, cchTotal - 1, &_cchPreChars, &ptp, NULL);
        cp += _cchPreChars;

        _pLS->_treeInfo._fInited = FALSE;

        //
        // Subsequently we will also reset the renderer inside renderbulletchar
        // with the correct pCFLI. Do it for now so that Setup works.
        //
        _pLS->SetRenderer(this, FALSE);
        if (S_OK == _pLS->Setup(0, cp, ptp, &marginInfo, NULL, FALSE))
        {
            COneRun *por = _pLS->_listFree.GetFreeOneRun(NULL);
            if (por)
            {
                por->_lscpBase = GetCp();
                por->_pPF = _pLS->_treeInfo._pPF;
                por->_fInnerPF = _pLS->_treeInfo._fInnerPF;
                por->_pCF = (CCharFormat*)_pLS->_treeInfo._pCF;
#if DBG == 1
                por->_pCFOriginal = por->_pCF;
#endif
                por->_fInnerCF = _pLS->_treeInfo._fInnerCF;
                por->_pFF = (CFancyFormat*)_pLS->_treeInfo._pFF;

                por->_fCharsForNestedElement  = _pLS->_treeInfo._fHasNestedElement;
                por->_fCharsForNestedLayout   = _pLS->_treeInfo._fHasNestedLayout;
                por->_fCharsForNestedRunOwner = _pLS->_treeInfo._fHasNestedRunOwner;
                por->_ptp = _pLS->_treeInfo._ptpFrontier;
                por->_sid = sidAsciiLatin;

                por = _pLS->AttachOneRunToCurrentList(por);
                if (por)
                {
                    if (_lastTextOutBy != DB_LINESERV)
                    {
                        _lastTextOutBy = DB_LINESERV;
                        SetTextAlign(_hdc, TA_TOP | TA_LEFT);
                    }

                    RenderStartLine(por);
                }
            }
        }
        
        //
        // reset so that the next person to call setup on CLineServices
        // will cleanup after us.
        //
        _pLS->_treeInfo._fInited = FALSE;
    }

    // Set the renderer before we do any output.
    _pLS->SetRenderer(this, GetBreakLongLines(_ptpCurrent->GetBranch()));

    //
    // If the line can be blasted to the screen and it was successfully blasted
    // then we are done.
    //
    if (_li._fCanBlastToScreen && !DontBlastLines() && !fIntersectSelection && !_fHasEllipsis)
    {
        _pLS->_fHasVerticalAlign = FALSE;

        ptpNext = BlastLineToScreen(li);
        if (ptpNext)
        {
            MtAdd(Mt(BlastedLines), 1, 0);
            goto Done;
        }
    }

    hr = THR(StartUpLSDLL(_pLS, _pdp->GetMarkup()));
    if (hr)
        goto Cleanup;

    MtAdd(Mt(LSRenderLines), 1, 0);

    if (_lastTextOutBy != DB_LINESERV)
    {
        _lastTextOutBy = DB_LINESERV;
        SetTextAlign(_hdc, TA_TOP | TA_LEFT);
    }

    pliContainer = AccountForRelativeLines(li,
                            &cpStartContainerLine,
                            &xWidthContainerLine,
                            &_cpStartRender,
                            &_cpStopRender,
                            &cchTotal
                           );

    _li._cch += _cp - cpStartContainerLine;

    if (cpStartContainerLine != GetCp())
        SetCp(cpStartContainerLine, NULL);

    _pdp->FormattingNodeForLine(FNFL_NONE, GetCp(), GetPtp(), _li._cch, &_cchPreChars, &ptp, &_fMeasureFromTheStart);
    if (!_fMeasureFromTheStart)
    {
        cpStartContainerLine += _cchPreChars;
        _li._cch   -= _cchPreChars;
        SetPtp(ptp, cpStartContainerLine);
    }

    _pLS->_li = _li;

    InitForMeasure(MEASURE_BREAKATWORD);
    LSDoCreateLine(cpStartContainerLine, NULL, &marginInfo,
                   xWidthContainerLine, &_li, FALSE, NULL);
    if (!_pLS->_plsline)
        goto Cleanup;

    ptLS = _ptCur;

    _pLS->_fHasVerticalAlign = (_pLS->_lineFlags.GetLineFlags(_pLS->_cpLim) & FLAG_HAS_VALIGN) ? TRUE : FALSE;

    if (_pLS->_fHasVerticalAlign)
    {
        _pLS->_li._cch = _pLS->_cpLim - cpStartContainerLine;
        _pLS->VerticalAlignObjects(*this, 0);
    }

    // Calculate chunk offset for relative lines
    _xChunkOffset  = CalculateChunkOffsetX();

    if (   _li._fHasInlineBgOrBorder
        || fIntersectSelection
       )
    {
        DrawInlineBordersAndBg(pliContainer);
    }

    LsDisplayLine(_pLS->_plsline,   // The line to be drawn
                  &ptLS,            // The point at which to draw the line
                  1,                // Draw in transparent mode
                  &_rcClip          // The clipping rectangle
                 );

    if (_fHasEllipsis && _fEllipsisPosSet)
    {
        RenderEllipsis();
    }

    ptpNext = _pLS->FigureNextPtp(_cp + _li._cch);

Cleanup:

    _pLS->DiscardLine();

Done:
    // increment y position to next line
    if (_li._fForceNewLine)
    {
        _ptCur.y += _li._yHeight;
    }

    // Go past the contents of this line
    Advance(_li._cch, ptpNext);

    PseudoLineDisable();
    
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBordersAngBg
//
//  Synopsis:   Draws borders around the inline elements in the 
//              one run list.
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void 
CLSRenderer::DrawInlineBordersAndBg(CLineCore *pliContainer)
{
    COneRun* por = _pLS->_listCurrent._pHead;
    COneRun *porTemp;
    LSCP lscpStartBorder = -1;
    LSCP lscpEndBorder = -1;
    LSCP lscpStartRender = _pLS->LSCPFromCP(_cpStartRender);
    LSCP lscpStopRender = _pLS->LSCPFromCP(_cpStopRender);
    CTreeNode *pNode;
    BOOL fDrawBorders;
    BOOL fDrawBackgrounds;  // working loop variable
    BOOL fNoBackgroundsForPrinting = !GetMarkup()->PaintBackground();   // used to override fDrawBackgrounds
                                                                        // perf: make it a member var?
    BOOL fDrawSelection;
    const CFancyFormat *pFF = NULL;
    const CCharFormat  *pCF = NULL;

    // If this physical line has a relative chunk in it, 
    // we'll get called several times with a different lscpStart/StopRender
    // for each chunk.  Only process runs within the range we're being
    // called for.
    // This entire "if" block is responsible for the drawing of 
    // inline borders that are continued from a previous line (i.e.
    // borders that didn't start on this line.
    if (!_li._fPartOfRelChunk
         || (   por->_lscpBase >= lscpStartRender
             && por->_lscpBase < lscpStopRender))
    {
        CStackDataAry<CTreeNode*, 8> aryNodes(NULL);
        LONG mbpTop = 0;
        LONG mbpBottom = 0;
        LONG i;

        // Walk up the tree to find all of the nested spans with borders
        _pLS->_mbpTopCurrent = _pLS->_mbpBottomCurrent = 0;
        SetupMBPInfoInLS(&aryNodes);

        lscpStartBorder = por->_lscpBase;

        // Now draw the background for each node in the array.
        for (i = aryNodes.Size() - 1; i >= 0; i--)
        {
            pNode = aryNodes[i];

            pFF = pNode->GetFancyFormat();
            pCF = pNode->GetCharFormat();

            Assert(pCF->HasVerticalLayoutFlow() == pNode->IsParentVertical());
            
            lscpEndBorder = FindEndLSCP(pNode);

            DrawBorderAndBgOnRange(pFF, pCF, pNode, por, lscpStartBorder, lscpEndBorder,
                                   pliContainer, TRUE, mbpTop, mbpBottom,
                                   _pLS->HasBorders(pFF, pCF, por->_fIsPseudoMBP), 
                                   fNoBackgroundsForPrinting ? FALSE : pFF->HasBackgrounds(por->_fIsPseudoMBP),
                                   FALSE);

            if (pNode->HasInlineMBP())
            {
                CRect rcDimensions;
                BOOL fIgnore;
                if (pNode->GetInlineMBPContributions(GetCalcInfo(), GIMBPC_ALL, &rcDimensions, &fIgnore, &fIgnore))
                {
                    mbpTop += rcDimensions.top;
                    mbpBottom += rcDimensions.bottom;
                }
            }
        }
    }

    // Examine the rest of the one run for borders
    while (   por 
           && por->_lscpBase < _pLS->_lscpLim)
    {
        // Figure out if we need to draw borders or backgrounds
        // for this one run
        if (_li._fPartOfRelChunk)
        {
            if (   por->_lscpBase >= lscpStartRender
                && por->_lscpBase < lscpStopRender)
            {
                fDrawBorders = _pLS->HasBorders(por->GetFF(), por->GetCF(), por->_fIsPseudoMBP);
                fDrawBackgrounds = por->GetFF()->HasBackgrounds(por->_fIsPseudoMBP);
                fDrawSelection = por->IsSelected();
            }
            else
            {
                fDrawBorders = FALSE;
                fDrawBackgrounds = FALSE;
                fDrawSelection = FALSE;
            }
        }
        else
        {
            fDrawBorders = _pLS->HasBorders(por->GetFF(), por->GetCF(), por->_fIsPseudoMBP);
            fDrawBackgrounds = por->GetFF()->HasBackgrounds(por->_fIsPseudoMBP);
            fDrawSelection = por->IsSelected();
        }

        // If we don't want backgrounds for printing, override whatever we got from formats.
        if ( fNoBackgroundsForPrinting )
            fDrawBackgrounds = FALSE;

        // See if a border or background has been set. 
        if (   fDrawBorders
            || fDrawBackgrounds)
        {
            // Draw borders when we come to a begin node
          if (   por->_synthType == CLineServices::SYNTHTYPE_MBPOPEN
              || (   por->_ptp->IsBeginNode()
                  && por->Branch()->IsFirstBranch()
                  && !por->_fNotProcessedYet
                  && !por->_fCharsForNestedElement
                  && !por->IsSyntheticRun()
                 )
             )
            {
                lscpStartBorder = por->_lscpBase;
                pNode = por->Branch();
              
                if (por->_fIsPseudoMBP)
                {
                    // Get the formats
                    pFF = por->GetFF();
                    pCF = por->GetCF();

                    // Find the next closing PseudoMBP this the right edge of the border
                    porTemp = por->_pNext;
                    while (   porTemp
                           && porTemp->_synthType != CLineServices::SYNTHTYPE_MBPCLOSE 
                           && !porTemp->_fIsPseudoMBP)
                    {
                        porTemp = porTemp->_pNext;
                    }

                    if (porTemp)
                    {
                        lscpEndBorder = porTemp->_lscpBase;
                        Assert(lscpEndBorder != _pLS->_lscpLim);
                    }
                    else
                    {
                        porTemp = _pLS->_listCurrent._pTail;
                        if (porTemp)
                            lscpEndBorder = porTemp->_lscpBase;
                        else
                        {
                            // This is really a whacky case, which should never happen
                            lscpEndBorder = lscpStartBorder;
                        }
                    }
                }
                else
                {
                    // Get the formats
                    pFF = por->GetFF();
                    pCF = por->GetCF();

                    // Don't draw borders for block elements
                    if (pFF->_fBlockNess)
                        goto Skip;

                    lscpEndBorder = FindEndLSCP(pNode);
                }

                if (lscpStartBorder < lscpEndBorder)
                {
                    DrawBorderAndBgOnRange(pFF, pCF, por->Branch(), por, lscpStartBorder, lscpEndBorder,
                                           pliContainer, FALSE, 0, 0,
                                           fDrawBorders, fDrawBackgrounds, por->_fIsPseudoMBP);
                }
            }
        }

        // If the one run is marked as selected then draw
        // a selection background for it.
        if (fDrawSelection)
        {
            DrawSelection(pliContainer, por);
        }

Skip:
        // Skip the AntiSynth run after MBP runs
        if (por->IsSpecialCharRun() && por->IsMBPRun() && por->_pNext && por->_pNext->IsAntiSyntheticRun())
        {
            por = por->_pNext;
        }

        por = por->_pNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawBorderAngBgOnRange
//
//  Synopsis:   Draw a border around an LSCP range
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawBorderAndBgOnRange(const CFancyFormat* pFF, const CCharFormat* pCF, CTreeNode *pNodeContext,
                                    COneRun *por, LSCP lscpStartBorder, LSCP lscpEndBorder,
                                    CLineCore *pliContainer, BOOL fFirstOneRun,
                                    LONG mbpTop, LONG mbpBottom,
                                    BOOL fDrawBorders, BOOL fDrawBackgrounds,
                                    BOOL fIsPseudoMBP)
{
    Assert(pNodeContext);
    if (!pNodeContext->IsVisibilityHidden())
    {
        CBorderInfo borderInfo;
        CDataAry<CChunk> aryRects(NULL);
        BOOL fSwapBorders = (   por->_synthType == CLineServices::SYNTHTYPE_MBPOPEN
                             && !por->_fIsLTR);

        // Fill the CBorderInfo structure
        GetBorderInfoHelperEx(pFF,
                              pCF,
                              _pDI, 
                              &borderInfo,
                              (por->_fIsPseudoMBP) ? GBIH_PSEUDO | GBIH_ALL : GBIH_ALL);

        aryRects.DeleteAll(); // Need to pass an empty array to CalcRects...

        // Figure out how much to offset the rects calcluated by CalcRects...
        LONG xShift = GetXOffset(pliContainer);

        // Get an array of rects that compose the range of
        // text we are going to draw the border around
        _pLS->CalcRectsOfRangeOnLine(lscpStartBorder, 
                                     lscpEndBorder,
                                     xShift,      // x offset
                                     _ptCur.y,    // y offset
                                     &aryRects,
                                     RFE_INCLUDE_BORDERS,
                                     (fFirstOneRun) ? mbpTop : por->_mbpTop,
                                     (fFirstOneRun) ? mbpBottom : por->_mbpBottom);

        BOOL fBOLWrapped = fFirstOneRun && !por->_fIsPseudoMBP;
        BOOL fEOLWrapped = lscpEndBorder == _pLS->_lscpLim;
        MassageRectsForInlineMBP(aryRects, NULL, pNodeContext, pCF, pFF, borderInfo,
                                 pliContainer,
                                 fIsPseudoMBP, fSwapBorders,
                                 fBOLWrapped, fEOLWrapped,
                                 fDrawBackgrounds, fDrawBorders
                                );
    }
}

void
CLSMeasurer::MassageRectsForInlineMBP(
                                      CDataAry<CChunk> & aryRects,     // Array of chunks comping in
                                      CDataAry<CChunk> * paryRectsOut,  // Could be NULL
                                      CTreeNode *pNode,
                                      const CCharFormat *pCF,
                                      const CFancyFormat *pFF,
                                      CBorderInfo &borderInfo,
                                      CLineCore *pliContainer,
                                      BOOL fIsPseudoMBP,
                                      BOOL fSwapBorders,
                                      BOOL fBOLWrapped,
                                      BOOL fEOLWrapped,
                                      BOOL fDrawBackgrounds,
                                      BOOL fDrawBorders
                                     )
{
    // If CalcRects does not return any rects then
    // don't display anything
    if (aryRects.Size() > 0)
    {
        LONG i;
        CChunk rcChunk;
        BOOL fNodeVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        LONG lFontHeight = pCF->GetHeightInTwips(_pdp->GetMarkup()->Doc());
        BOOL fReversed = FALSE;
        BOOL fFirstRTLChunk = TRUE;
        CRect rc;

        rc.SetRectEmpty();

        // Union all of the rects in the array
        for (i=0; i<aryRects.Size(); i++)
        {
            rcChunk = aryRects[i];
            LONG xStartChunk = rcChunk.left;
            LONG xEndChunk = rcChunk.right;

            if (rcChunk._fReversedFlow)
                fReversed = TRUE;

            // Adjust for RTL flow
            pliContainer->AdjustChunkForRtlAndEnsurePositiveWidth(pliContainer->oi(), xStartChunk, xEndChunk,
                                                        &rcChunk.left, &rcChunk.right);

            // Fixup the rect for top and bottom margins
            if (fIsPseudoMBP)
            {
                const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);

                rcChunk.top    += pPEI->GetLogicalMargin(SIDE_TOP, fNodeVertical, fWritingModeUsed, pFF).YGetPixelValue(_pci, _pci->_sizeParent.cy, lFontHeight);
                rcChunk.bottom -= pPEI->GetLogicalMargin(SIDE_BOTTOM, fNodeVertical, fWritingModeUsed, pFF).YGetPixelValue(_pci, _pci->_sizeParent.cy, lFontHeight);
            }
            else
            {
                if (pNode->HasInlineMBP())
                {
                    CRect rc;
                    BOOL fJunk;
                    pNode->GetInlineMBPContributions(_pci, GIMBPC_MARGINONLY, &rc, &fJunk, &fJunk);
                    rcChunk.top += rc.top;
                    rcChunk.bottom -= rc.bottom;
                }
            }

            if (!rc.IsEmpty())
            {
                // See if we hit text with a different flow direction
                if (   (rcChunk.left < rc.left && rcChunk.right < rc.left)
                    || (rc.left < rcChunk.left && rc.right < rcChunk.left))
                {
                    AdjustForMargins(&rc, &borderInfo, pNode, pFF, pCF, FALSE, FALSE, fIsPseudoMBP);

                    if (paryRectsOut)
                    {
                        CChunk rcChunk(rc);
                        paryRectsOut->AppendIndirect(&rcChunk);
                    }
                
                    if (fDrawBackgrounds)
                    {
                        DYNCAST(CLSRenderer, this)->DrawInlineBackground(rc, pFF, pNode, fIsPseudoMBP);
                    }

                    if (fDrawBorders)
                    {
                        DYNCAST(CLSRenderer, this)->DrawInlineBorderChunk(rc, &borderInfo, pFF, i, aryRects.Size(),
                                              fSwapBorders, fFirstRTLChunk, fReversed, fIsPseudoMBP);
                    }

                    fSwapBorders = !fSwapBorders;

                    fFirstRTLChunk = fReversed = FALSE;
                    rc.SetRectEmpty();
                }
                else
                {
                    // Height of the chunk can be negative because of negative margins.
                    // But we need to union width. In this case make the chunk's height equal to 
                    // combined rectangle's height (it won't affect the height), because Union()
                    // ignores empty rectangles.
                    if (rcChunk.Height() <= 0)
                    {
                        rcChunk.top = rc.top;
                        rcChunk.bottom = rc.bottom;
                    }
                }
            }

            rc.Union(rcChunk);
        }

        // If the text continues on to the next line
        // then don't draw the end border
        if (fEOLWrapped)
        {
            if (!_li.IsRTLLine())
                borderInfo.abStyles[SIDE_RIGHT] = fmBorderStyleNone;
            else
                borderInfo.abStyles[SIDE_LEFT] = fmBorderStyleNone;
        }
                  
        // Don't draw the left border if we are drawing 
        // a line that has been continued from the last line
        if (fBOLWrapped)
        {
            if (!_li.IsRTLLine())
                borderInfo.abStyles[SIDE_LEFT] = fmBorderStyleNone;
            else
                borderInfo.abStyles[SIDE_RIGHT] = fmBorderStyleNone;
        }

        AdjustForMargins(&rc, &borderInfo, pNode, pFF, pCF, fBOLWrapped, fEOLWrapped, fIsPseudoMBP);

        if (paryRectsOut)
        {
            CChunk rcChunk(rc);
            paryRectsOut->AppendIndirect(&rcChunk);
        }
        
        if (fDrawBackgrounds)
        {
            DYNCAST(CLSRenderer, this)->DrawInlineBackground(rc, pFF, pNode, fIsPseudoMBP); 
        }

        if (fDrawBorders)
        {
            DYNCAST(CLSRenderer, this)->DrawInlineBorderChunk(rc, &borderInfo, pFF, i - 1, aryRects.Size(),
                                  fSwapBorders, fFirstRTLChunk, fReversed, fIsPseudoMBP);
        }
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBorderChunk
//
//  Synopsis:   Ranges with multiple flow directions are broken up into
//              chunks. This function draws border around one such
//              chunk.
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawInlineBorderChunk(CRect rc, CBorderInfo *pborderInfo, const CFancyFormat *pFF,
                                   LONG nChunkPos, LONG nChunkCount,
                                   BOOL fSwapBorders, BOOL fFirstRTLChunk, BOOL fReversed,
                                   BOOL fIsPseudoMBP)
{
    // Disable a border if the chunk continues on
    if (nChunkPos != nChunkCount - 1)
    {
        if (!fReversed)
            pborderInfo->abStyles[SIDE_LEFT] = fmBorderStyleNone;
        else
            pborderInfo->abStyles[SIDE_RIGHT] = fmBorderStyleNone;
    }

    // Disable a border if the chunk has more chunks before it
    if (   nChunkPos < nChunkCount
        && !fFirstRTLChunk)
    {
        if (!fReversed)
            pborderInfo->abStyles[SIDE_RIGHT] = fmBorderStyleNone;
        else
            pborderInfo->abStyles[SIDE_LEFT] = fmBorderStyleNone;
    }

    if (fSwapBorders)
    {
        int nTemp = pborderInfo->aiWidths[SIDE_LEFT];
        pborderInfo->aiWidths[SIDE_LEFT] = pborderInfo->aiWidths[SIDE_RIGHT];
        pborderInfo->aiWidths[SIDE_RIGHT] = nTemp;
    }

    if (!rc.IsEmpty())
        DrawBorder(_pDI, &rc, pborderInfo);

    if (fSwapBorders)
    {
        int nTemp = pborderInfo->aiWidths[SIDE_LEFT];
        pborderInfo->aiWidths[SIDE_LEFT] = pborderInfo->aiWidths[SIDE_RIGHT];
        pborderInfo->aiWidths[SIDE_RIGHT] = nTemp;
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawInlineBackground
//
//  Synopsis:   Draw an inline background in the rect
//
//  Returns:    void
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawInlineBackground(CRect rc, const CFancyFormat *pFF, CTreeNode *pNodeContext,
                                  BOOL fIsPseudoMBP)
{
    CBackgroundInfo bgInfo;
    SIZE            sizeImg;
    CPoint          ptBackOrg;
    CImgCtx       * pImgCtx;
    
    Assert(pNodeContext && pFF);

    // Set the color and image context cookie in the BACKGROUNDINFO struct
    if (fIsPseudoMBP)
    {
        const CPseudoElementInfo* pPEI = GetPseudoElementInfoEx(pFF->_iPEI);
        bgInfo.crBack = (pPEI->_ccvBackColor.IsDefined())
            ? pPEI->_ccvBackColor.GetColorRef()
            : COLORREF_NONE;
        bgInfo.lImgCtxCookie = pPEI->_lImgCtxCookie;
    }
    else
    {
        bgInfo.crBack = pFF->_ccvBackColor.IsDefined() ? pFF->_ccvBackColor.GetColorRef()
                                                       : COLORREF_NONE;
        bgInfo.lImgCtxCookie = pFF->_lImgCtxCookie;
    }

    // Assert that we have something to draw on the screen
    Assert(bgInfo.lImgCtxCookie || bgInfo.crBack);

    // Get the image context from the cookie
    pImgCtx = (bgInfo.lImgCtxCookie
                            ? _pFlowLayout->Doc()->GetUrlImgCtx(bgInfo.lImgCtxCookie)
                            : 0);

    if (pImgCtx && !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        pImgCtx = NULL;

    // if the background image is not loaded yet and there is no background color
    // return (we dont have anything to draw)
    if(!pImgCtx && bgInfo.crBack == COLORREF_NONE)
        return;

    bgInfo.pImgCtx       = pImgCtx;
    bgInfo.crTrans       = COLORREF_NONE;

    if (pImgCtx)
    {
        SIZE sizeBound;
        CDataAry<RECT> aryRects(NULL);
        CPoint ptOffset(((CRect*)&_rcView)->TopLeft());

        // TODO RTL 112514: this is a hack, which makes inline background work in mormal case, 
        //                  but it is completely broken for relative.
        if (_pdp->IsRTLDisplay())
            ptOffset.x = 0;
        
        CTreePos *ptpBegin = pNodeContext->GetBeginPos();
        CTreePos *ptpEnd = pNodeContext->GetEndPos();
        LONG cpStart = ptpBegin->GetCp();
        LONG cpEnd = ptpEnd->GetCp();
        RECT rcBound;

        // If the element does not cross multiple lines then
        // we have all the info we need and do not have to
        // call RFE
        if (   cpStart >= _cp
            && cpEnd < _cp + _li._cch)
        {
            sizeBound.cx = rc.Width();
            sizeBound.cy = rc.Height();
            rcBound = rc;
        }
        else
        {
            // In the case of inlined elements with background images
            // we need to know the bounding rects of the element. So we
            // have to call RFE to get it.
            _pFlowLayout->RegionFromElement(pNodeContext->Element(),
                                            &aryRects, 
                                            &ptOffset,
                                            _pDI,
                                            0,
                                            cpStart,
                                            cpEnd,
                                            &rcBound);

            // Set the size of the bounding rect
            sizeBound.cx = rcBound.right - rcBound.left;
            sizeBound.cy = rcBound.bottom - rcBound.top;
        }

        GetBgImgSettings(pFF, &bgInfo);
        CalcBgImgRect(pNodeContext, _pDI, &sizeBound, &sizeImg, &ptBackOrg, &bgInfo);

        OffsetRect(&bgInfo.rcImg, rcBound.left, rcBound.top);

        if (!pNodeContext->IsRelative())
        {
            if (   cpStart >= _cp
                && cpEnd < _cp + _li._cch)
            {
                ptBackOrg.x += rc.left;
                ptBackOrg.y += rc.top;
            }
            else
            {
                ptBackOrg.x += rcBound.left;
                ptBackOrg.y += rcBound.top;
            }
        }

        bgInfo.ptBackOrg = ptBackOrg;

        IntersectRect(&bgInfo.rcImg, &bgInfo.rcImg, &rc);
        IntersectRect(&bgInfo.rcImg, &_rcClip, &bgInfo.rcImg);
    }

    _pFlowLayout->DrawBackground(_pDI, &bgInfo, &rc);
}

//-----------------------------------------------------------------------------
//
//  Function:   FindEndLSCP
//
//  Synopsis:   Find the LSCP value for the end of the tree node.
//
//-----------------------------------------------------------------------------
LSCP
CLSRenderer::FindEndLSCP(CTreeNode* pNode)
{
    LSCP lscpEndBorder;
    COneRun *porTemp;
    LONG cpEndBorder;
    CTreePos *ptpEndPos;

    // Find the last branch
    while (!pNode->IsLastBranch())
        pNode = pNode->NextBranch();
      
    ptpEndPos = pNode->GetEndPos();
    cpEndBorder = ptpEndPos->GetCp();
    lscpEndBorder = _pLS->LSCPFromCP(cpEndBorder);

    porTemp = _pLS->FindOneRun(lscpEndBorder);

    if (   lscpEndBorder >= _pLS->_lscpLim
        || !porTemp)
    {
        // This line is wraps so just end the border at
        // the end of the line
        lscpEndBorder = _pLS->_lscpLim;
    }
    else
    {
        // LSCPFromCP might return the position of an MBP closing
        // a Pseudo element. In this case we might want move to the
        // next one run if its an MBP
        if (   porTemp->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE 
               && porTemp->_fIsPseudoMBP)
        {
            Assert(porTemp->_pNext);
            if (porTemp->_pNext->_synthType == CLineServices::SYNTHTYPE_MBPCLOSE)
                porTemp = porTemp->_pNext;
            else
                porTemp = porTemp->_pPrev;
        }

        lscpEndBorder = porTemp->_lscpBase;
        Assert(lscpEndBorder != _pLS->_lscpLim);
    }

    return lscpEndBorder;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawSelection
//
//  Synopsis:   Draw a selection background for this one run.
//
//-----------------------------------------------------------------------------
void
CLSRenderer::DrawSelection(CLineCore *pliContainer, COneRun *por)
{
    if (!por->Branch()->IsVisibilityHidden())
    {
        CRect rc;
        COLORREF crBackColor;
        CStackDataAry<CChunk, 8> aryRects(NULL);
        LONG xShift;
    
        if (por->GetCurrentBgColor().IsDefined())
            crBackColor = por->GetCurrentBgColor().GetColorRef();
        else
            goto Cleanup;

        // Figure out how much to offset the rects calcluated by CalcRects...
        xShift = GetXOffset(pliContainer);

        // Get the rect for the one run
        _pLS->CalcRectsOfRangeOnLine(por->_lscpBase,
                                     por->_lscpBase + (por->IsAntiSyntheticRun() ? 0 : por->_lscch),
                                     xShift,
                                     _ptCur.y,
                                     &aryRects,
                                     RFE_SELECTION, 0, 0);
    
        Assert(aryRects.Size() <= 1);

        if (aryRects.Size() == 0)
            goto Cleanup;

        // Get the rect for the one run
        rc = aryRects[0];

        // Fixup the rect so that its height is the extent of the line
        rc.top = _ptCur.y + _li.GetYTop();
        rc.bottom = _ptCur.y + _li.GetYBottom();
    
        //
        // Fix up rects for RTL text
        //
        _li.AdjustChunkForRtlAndEnsurePositiveWidth(&_li, rc.left, rc.right,
                                                    &rc.left, &rc.right);

        // Create the BACKGROUNDINFO structure
        CBackgroundInfo bgInfo;
        bgInfo.crBack = crBackColor;
        bgInfo.pImgCtx = NULL;
        bgInfo.crTrans = COLORREF_NONE;

        // Now just draw the background
        _pFlowLayout->DrawBackground(_pDI, &bgInfo, &rc);
    }

Cleanup:
    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetXOffset
//
//  Synopsis:   Calculate the offset to pass to CalcRects...
//
//  Return value is LOGICAL (from right if the line is RTL).
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::GetXOffset(CLineCore *pliContainer)
{
    LONG xOffset;

    if (!pliContainer->IsRTLLine())
    {
        if (!_li._fRelative)
        {
            if (_li._fPartOfRelChunk)
            {
                xOffset = pliContainer->oi()->_xLeft + pliContainer->oi()->_xLeftMargin;
            }
            else
            {
                xOffset = _ptCur.x;
            }
        }
        else
        {
            xOffset = _li._xLeftMargin + pliContainer->oi()->_xLeft + _xRelOffset;
        }
    }
    else
    {
        // TODO RTL 112514: this doesn't work yet, and it may 
        //                  not start working properly until we rewrite relative positioning.
        if (!_li._fRelative)
        {
            if (_li._fPartOfRelChunk)
            {
                xOffset = pliContainer->_xRight + pliContainer->oi()->_xRightMargin;
            }
            else
            {
                xOffset = _li._xRightMargin +  pliContainer->_xRight;
            }
        }
        else
        {
            xOffset = _li._xRightMargin + pliContainer->_xRight + _xRelOffset;
        }
    }

    return xOffset;
}


//-----------------------------------------------------------------------------
//
//  Function:   BlastLineToScreen
//
//  Synopsis:   Renders one line in one shot w/o remeasuring if it can be done.
//
//  Params:     li: The line to be rendered
//
//  Returns:    Whether it rendered anything at all
//
//-----------------------------------------------------------------------------
CTreePos *
CLSRenderer::BlastLineToScreen(CLineFull& li)
{
    CTreePos   *ptpRet = NULL;

    Assert(_li._fCanBlastToScreen);
    Assert(!_li._fHidden);

    //
    // We need to render all the characters in the line
    //
    _cpStartRender = GetCp();
    _cpStopRender  = _cpStartRender + _li._cch;

    // We don't need to calculate chunk offset here - we won't blast relative lines.
    // (and there is an assert in GetChunkOffsetX() that ensures that this is true)
    _xChunkOffset  = 0;

    //
    // For now, lets not do relative lines...
    //
    if (_li._fPartOfRelChunk || _pdp->HasLongLine())
        goto Cleanup;

    //
    // Now we are pretty sure that we can blast this line, so lets go do it.
    //
    {
        CTreePos *ptp;
        LONG      cp  = GetCp();
        LONG      cch = _li._cch;
        LONG      cpAtPtp;

        LONG      cchToRender;
        LONG      cchSkip;
        CTreeNode*pNode = _pdp->FormattingNodeForLine(FNFL_NONE, cp, GetPtp(), cch, &cchSkip, &ptp, NULL);

        if(!pNode)
            goto Cleanup;

        COneRun   onerun;

        const TCHAR *pch = NULL;
        CTxtPtr      tp(_pdp->GetMarkup(), cp += cchSkip);
        LONG         cchValid = 0;

        LONG      xOld = -1;
        LONG      yOld = LONG_MIN;
        LONG      xCur = _ptCur.x;
        LONG      yCur = _ptCur.y;
        LONG      yOriginal = _ptCur.y;
        BOOL      fRenderedText = FALSE;
        LONG      cchCharsTrimmed = 0;
        BOOL      fHasInclEOLWhite = pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasInclEOLWhite(SameScope(pNode, _pFlowLayout->ElementContent()));
      
        WHEN_DBG( BOOL fNoMoreTextOut = FALSE;)

        if (_lastTextOutBy != DB_BLAST)
        {
            _lastTextOutBy = DB_BLAST;
            SetTextAlign(_hdc, TA_TOP | TA_LEFT | TA_UPDATECP);
        }

        cch -= cchSkip;
        cpAtPtp = ptp->GetCp();
        while (cch > 0)
        {
            if (cchValid == 0)
            {
                Assert(cp == (long)tp.GetCp());

                pch = tp.GetPch(cchValid);
                Assert(pch != NULL);
                if (pch == NULL)
                    goto Cleanup;
                cchValid = min(cchValid, cch);
                tp.AdvanceCp(cchValid);
            }

            cchToRender = 0;
            if (ptp->IsPointer())
            {
                ptp = ptp->NextTreePos();
                continue;
            }
            if (ptp->IsNode())
            {
                pNode = ptp->Branch();

                // Start off with a default number of chars to render
                cchToRender = ptp->NodeCch();

                if (ptp->IsBeginElementScope())
                {
                    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
                    CElement *pElement = pNode->Element();

                    if (pCF->IsDisplayNone())
                    {
                        cchToRender = GetNestedElementCch(pElement, &ptp);
                    }
                    else if (pElement->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext())))
                    {
                        CLayout *pLayout = pElement->GetUpdatedLayout(_pci->GetLayoutContext());

                        Assert(pLayout != _pFlowLayout);
                        if (pElement->IsInlinedElement(LC_TO_FC(_pci->GetLayoutContext())))
                        {
                            LONG xWidth;

                            GetSiteWidth(pNode, pLayout, _pci, FALSE, 0, &xWidth);
                            xCur += xWidth;
                            MoveToEx(_hdc, xCur, yCur, NULL);
                            fRenderedText = TRUE;
                        }
                        cchToRender = _pLS->GetNestedElementCch(pElement, &ptp);

                        pNode = ptp->Branch();

                        // We either have overlapping layouts (which is when the cchToRender
                        // etc test will succeed), or our last ptp has to be that of the
                        // layout we just rendered.
                        Assert(   cchToRender != (pNode->Element()->GetElementCch() + 2)
                               || pNode->Element() == ptp->Branch()->Element()
                              );
                    }
                }

                if (ptp->IsEndNode())
                    pNode = pNode->Parent();
                ptp = ptp->NextTreePos();
                cpAtPtp += cchToRender;
            }
            else
            {
                Assert(ptp->IsText());
                Assert(pNode);

                if (ptp->Cch() == 0)
                {
                    ptp = ptp->NextTreePos();
                    continue;
                }
                
                LONG cchRemainingInTextPos = ptp->Cch() - (cp - cpAtPtp);
                LONG cchCanRenderNow = min(cchRemainingInTextPos, cchValid);
                BOOL fWhiteSpaceSkip = FALSE;
                CTreePos * ptpThis = ptp;

                if (fRenderedText)
                {
                    cchToRender = cchCanRenderNow;
                }
                else
                {
                    LONG i = 0;
                    if (!fHasInclEOLWhite)
                    {
                        for(i = 0; i < cchCanRenderNow; i++)
                        {
                            if (!IsWhite(pch[i]))
                                break;
                            fWhiteSpaceSkip = TRUE;
                        }
                    }
                    if (fWhiteSpaceSkip)
                        cchToRender = i;
                    else
                        cchToRender = cchCanRenderNow;
                }

                cchRemainingInTextPos -= cchToRender;
                if (cchRemainingInTextPos == 0)
                {
                    cpAtPtp += ptp->Cch();
                    ptp = ptp->NextTreePos();
                }

                if (!fWhiteSpaceSkip)
                {
                    POINT ptTemp;
                    CCcs ccs;
                    const CBaseCcs *pBaseCcs;
                    BOOL fUnderlined;

                    fRenderedText = TRUE;

                    // Is this needed?
                    memset(&onerun, 0, sizeof(onerun));

                    onerun._fInnerCF = SameScope(pNode, _pFlowLayout->ElementOwner());
                    onerun._pCF = (CCharFormat* )pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));
#if DBG == 1
                    onerun._pCFOriginal = onerun._pCF;
#endif
                    onerun._pFF = (CFancyFormat*)pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
                    onerun._bConvertMode = CM_UNINITED;
                    onerun._ptp = ptpThis;
                    onerun.SetSidFromTreePos(ptpThis);
                    onerun._lscpBase = cp;
                    Assert(onerun._pCF);

                    fUnderlined =    onerun._pCF->_fStrikeOut
                                  || onerun._pCF->_fOverline
                                  || onerun._pCF->_fUnderline;


                    if (   fUnderlined
                        && !pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->HasPre(onerun._fInnerCF)
                       )
                    { 
                        cchCharsTrimmed = TrimTrailingSpaces(
                                            cchToRender,       // number of chars being rendered now
                                            cp + cchToRender,  // cp of next run to be blasted
                                            ptp,
                                            cch - cchToRender);// chars remaining to be rendered
                        cchToRender -= cchCharsTrimmed;
                        Assert(cchToRender >= 0);
                        if (cchToRender == 0)
                        {
                            fUnderlined = FALSE;
                            cchToRender = cchCharsTrimmed;
                        }
                    }

                    if (!_pLS->GetCcs(&ccs, &onerun, _hdc, _pDI))
                        goto Cleanup;

                    pBaseCcs = ccs.GetBaseCcs();
                    Assert(pBaseCcs);
                    
                    yCur = yOriginal + _li._yHeight - _li._yDescent +
                           pBaseCcs->_yDescent - pBaseCcs->_yHeight;
                    if (yCur != yOld)
                    {
                        yOld = yCur;
#if DBG==1
                        BOOL fSuccess =
#endif
                        MoveToEx(_hdc, xCur, yCur, NULL);
#if DBG==1
                        AssertSz(fSuccess, "Failed to do moveto, bad HDC?");
                        if (!fSuccess)
                        {
                            DWORD winerror;
                            winerror = ::GetLastError();
                        }
#endif
                    }
                    xOld = xCur;

                    WHEN_DBG(GetCurrentPositionEx(_hdc, &ptTemp));
                    Assert(   ptTemp.x == xCur
                           || (   VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID
                               && xCur >= 0x8000
                              )
                          );
                    Assert(ptTemp.y == yCur);
                    Assert(fNoMoreTextOut == FALSE);

                    onerun._lscpBase = cp;
                    TextOut(&onerun,                 // por
                            FALSE,                   // fStrikeOut
                            FALSE,                   // fUnderLine
                            NULL,                    // pptText
                            pch,                     // pch
                            NULL,                    // lpDx
                            cchToRender,             // cwchRun
                            lstflowES,               // ktFlow
                            0,                       // kDisp
                            (const POINT*)&g_Zero,   // pptRun
                            NULL,                    // heightPres
                            -1,                      // dupRun
                            0,                       // dupLineUnderline
                            NULL);                   // pRectClip

                    // We will have moved to the right so get our new position
                    GetCurrentPositionEx(_hdc, &ptTemp);
                    xCur = ptTemp.x;
                    
                    // Keep yCur as it is.

                    if (fUnderlined)
                    {
                        LSULINFO lsUlInfo;

                        if (lserrNone != _pLS->GetRunUnderlineInfo(&onerun,        // PLSRUN
                            NULL,       // PCHEIGHTS
                            lstflowES,  // ktFlow
                            &lsUlInfo)
                           )
                            goto Cleanup;

                        ptTemp.x = xOld;
                        ptTemp.y = yOriginal;
                        DrawUnderline(&onerun,                              // por
                                      lsUlInfo.kulbase,                 // kUlBase
                                      &ptTemp,                          // pptStart
                                      xCur - xOld,                      // dupUl
                                      lsUlInfo.dvpFirstUnderlineSize,   // dvpUl
                                      lstflowES,                        // kTFlow
                                      0,                                // kDisp
                                      &_rcClip                          // prcClip
                                     );
                        MoveToEx(_hdc, xCur, yCur, NULL);
                        cchToRender += cchCharsTrimmed;
                        WHEN_DBG(fNoMoreTextOut = !!cchCharsTrimmed;)
                    }
                }
            }
            cp += cchToRender;
            cch -= cchToRender;

            cchValid -= cchToRender;

            // cchValid can go to < 0 if the current text run finishes *within* a
            // site or hidden stuff. In both these cases we will have cchToRender
            // be > cchValid. Take care of this.
            if (cchValid < 0)
            {
                tp.AdvanceCp(-cchValid);
                cchValid = 0;
            }
            else
            {
                pch += cchToRender;
            }
        }
        memset(&onerun, 0, sizeof(onerun));
        ptpRet = ptp;
    }

Cleanup:
    return ptpRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   TrimTrailingSpaces
//
//  Synopsis:   Returns the number of white chars to be trimmed (if necessary)
//              at the end of a run
//
//  Returns:    Number of characters to be trimmed
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::TrimTrailingSpaces(LONG cchToRender,
                                LONG cp,
                                CTreePos *ptp,
                                LONG cchRemainingInLine)
{
    LONG  cchAdvance = 0;
    BOOL  fTrim      = TRUE;
    const CCharFormat *pCF;
    LONG  cchTrim;
    CTreeNode *pNode;
    CElement *pElement;
    LONG  cpMostOfRunToTrim = cp;
    
    LONG  junk;
    //Assert(ptp && ptp == _pdp->GetMarkup()->TreePosAtCp(cp, &junk));

    ptp = _pdp->GetMarkup()->TreePosAtCp(cp, &junk);
    while (cchRemainingInLine > 0)
    {
        Assert(   ptp->GetCp() <= cp
               && ptp->GetCp() + ptp->GetCch() >= cp
              );

        if (ptp->GetCch() == 0)
            cchAdvance = 0;
        else
        {
            pNode = ptp->GetBranch();
            pCF   = pNode->GetCharFormat(LC_TO_FC(_pci->GetLayoutContext()));

            if (ptp->IsNode())
            {
                cchAdvance = ptp->NodeCch();
                if (ptp->IsBeginNode())
                {
                    pElement = pNode->Element();

                    if (pCF->IsDisplayNone())
                    {
                        cchAdvance = GetNestedElementCch(pElement, &ptp);
                    }
                    else if (   ptp->IsEdgeScope()
                             && pElement->ShouldHaveLayout()
                            )
                    {
                        if (pElement->IsInlinedElement())
                        {
                            if (!pElement->IsOwnLineElement(_pFlowLayout))
                                fTrim = FALSE;
                            break;
                        }
                        else
                        {
                            //
                            // If in edit mode we are showing aligned site tags then
                            // we will not blast the line.
                            //
                            Assert( !_pdp->GetFlowLayout()->IsEditable()                        ||                                                              
                                    !_pdp->GetFlowLayout()->GetContentMarkup()->HasGlyphTable() ||
                                    !_pdp->GetFlowLayout()->GetContentMarkup()->GetGlyphTable()->_fShowAlignedSiteTags );
              
                            cchAdvance = GetNestedElementCch(pElement, &ptp);
                        }
                    }
                }
            }
            else if (ptp->Cch() > 0)
            {
                fTrim = FALSE;
                break;
            }
        }

        cp += cchAdvance;
        cchRemainingInLine -= cchAdvance;
        ptp = ptp->NextTreePos();

        // Should never happen, but does in stress cases
        if (!ptp)
        {
            fTrim = FALSE;
            break;
        }
        cchAdvance = ptp->GetCch();
    }

    if (fTrim)
    {
        CTxtPtr tp(_pdp->GetMarkup(), cpMostOfRunToTrim);

        cchTrim = 0;
        while(cchToRender && IsWhite(tp.GetPrevChar()))
        {
            cchToRender--;
            cchTrim++;
            tp.AdvanceCp(-1);
        }
    }
    else
        cchTrim = 0;

    return cchTrim;
}

//-----------------------------------------------------------------------------
//
//  Function:   TextOut
//
//  Synopsis:   Renders one run of text
//
//  Params:     Same as that for LineServices DrawTextRun callback
//
//  Returns:    Number of characters rendered
//
//  Dev Note:   Any changes made to this function should be reflected in
//              CLSRenderer::GlyphOut() (as appropriate)
//
//-----------------------------------------------------------------------------

LONG
CLSRenderer::TextOut(
    COneRun *por,           // IN
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    const POINT* pptText,   // IN
    LPCWSTR pch,            // IN was plwchRun
    const int* lpDx,        // IN was rgDupRun
    DWORD cwchRun,          // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightPres,   // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    CONVERTMODE cm;
    TCHAR ch;
    CStr     strTransformedText;
    COLORREF crTextColor = 0;
    COLORREF crNewTextColor = 0;
    DWORD    cch = cwchRun;
    const    CCharFormat *pCF = por->GetCF();
    CCcs     ccs;
    const CBaseCcs *pBaseCcs;
    RECT     rcClipSave = _rcClip;
    LONG     yDescent = _li._yDescent;
    CDataAry<int> aryDx(Mt(CLSRendererTextOut_aryDx_pv));
    LONG     yCur;
    
    FONTIDX hfontOld = SetNewFont(&ccs, por);
    if (hfontOld == HFONT_INVALID)
        goto Cleanup;
    
    if (ShouldSkipThisRun(por, dupRun))
        goto Cleanup;

    pBaseCcs = ccs.GetBaseCcs();
    
    cm = pBaseCcs->GetConvertMode(_fEnhancedMetafileDC, _pDI->IsMetafile());

    // This is where this run will be drawn.
    _ptCur.x = pptRun->x - ((!(kTFlow & fUDirection)) ? 0 : dupRun - 1) - GetChunkOffsetX();

#ifdef NOTYET // TODO RTL 112514: this fixes bug 86548, but selection and hit testing get broken.
              //                  Needs more investigation.
    // In RTL lines, overhang needs to be added to the right, effectively pushing the run to the left
    if (_li._fRTLLn && por->_xOverhang)
        _ptCur.x -= por->_xOverhang;
#endif
        
    // If pptText is NULL, that means that we are blasting to the screen, so we
    // should just use _ptCur.y as our yCur
    AssertSz((pptText == NULL || _ptCur.y == (pptText->y + por->_lsCharProps.dvpPos) || por->GetCF()->_fIsRuby),
             "Our baseline differs from LS baseline!");
    yCur = (pptText == NULL) ? _ptCur.y : pptText->y + por->_lsCharProps.dvpPos;
        
    // Trim all nondisplayable linebreaking chars off end
    for ( ; cch ; cch-- )
    {
        ch = pch[cch - 1];

        if (!(   ch == LF
              || ch == CR))
            break;
    }

    if (!cch)
        goto Cleanup;


#if DBG==1
    if (!IsTagEnabled(tagLSPrintDontAdjustContrastForWhiteBackground))
#endif
    if (!GetMarkup()->PaintBackground())
    {
        // If we are part of a print doc and the background is not printed,
        // we conceptually replace the background with white (because most
        // paper is white).  This means that we have to enhance the contrast
        // of bright-colored text on dark backgrounds.

        COLORREF crNewBkColor = RGB(255, 255, 255); // white background
        int      nMinimalLuminanceDifference = 150; // for now

        crNewTextColor = GetTextColor(_hdc);

        // Sujal insists that if both colors are the same (in this case both
        // white), then the second color will be modified.
        ContrastColors(crNewTextColor, crNewBkColor, nMinimalLuminanceDifference);

        // Finally, turn off the higher order bits
        crNewTextColor  = (crNewTextColor & CColorValue::MASK_COLOR) | 0x02000000;

        crTextColor = SetTextColor (_hdc, crNewTextColor);
    }

    AssertSz(pCF, "CLSRenderer::TextOut: We better have char format here");

    // In some fonts in some locales, NBSPs aren't rendered like spaces.
    // Under these circumstances, we need to convert NBSPs to spaces
    // Before calling LSReExtTextOut.
    if (pCF && _li._fHasNBSPs && ccs.ConvertNBSPs(_hdc, _pDI->_pDoc))
    {
        const TCHAR * pchStop;
        TCHAR * pch2;

        HRESULT hr = THR( strTransformedText.Set( pch, cch ) );
        if (hr)
            goto Cleanup;
        pch = strTransformedText;

        pch2 = (TCHAR *)pch;
        pchStop = pch + cch;

        while ( pch2 < pchStop )
        {
            if (*pch2 == WCH_NBSP)
            {
                *pch2 = L' ';
            }

            pch2++;
        }
    }

    // Reverse the run if our text is flowing from right to left.
    // NOTE (mikejoch) We actually want to be more conditional about doing
    // this for metafiles, as we don't want to reverse runs that would
    // otherwise be glyphed. Maybe by looking at
    // por->GetComplexRun()->GetAnalysis()?
    if (kTFlow & fUDirection)
    {
        TCHAR * pch1;
        TCHAR * pch2;
        const int * pDx1;
        int * pDx2;

        if (pch != strTransformedText)
        {
            HRESULT hr = THR(strTransformedText.Set(pch, cch));
            if (hr)
                goto Cleanup;
            pch = strTransformedText;
        }

        if (FAILED(aryDx.Grow(cch)))
            goto Cleanup;

        pch1 = (TCHAR *) pch;
        pch2 = pch1 + cch - 1;
        while (pch1 < pch2)
        {
            TCHAR ch = *pch1;
            *pch1 = *pch2;
            *pch2 = ch;
            pch1++;
            pch2--;
        }

        pDx1 = lpDx + cch - 1;
        pDx2 = aryDx;
        while (pDx1 >= lpDx)
        {
            *pDx2++ = *pDx1--;
        }
        lpDx = aryDx;
    }

    if (_pLS->IsAdornment())
    {
        const CFancyFormat * pFFLi = _pLS->_pNodeLi->GetFancyFormat();

        LONG yTextHeight = _li._yHeight - _li.GetYTop();

        // If the first line in the LI is a frame line, then its _yDescent
        // value is garbage. This also means that we will not center WRT
        // the text following the frame line. However, this is much better
        // than before when we did not render the bullet at all when the
        // first line in a LI was a frame line.(SujalP)
        if (_li.IsFrame())
        {
            yDescent = 0;
        }

        // Center the bullet in the ascent of the text line only if
        // the line of text is smaller than the bullet. This adjustment
        // keeps the bullets visible, but tends to keep them low on the
        // line for large text fonts.
        if (pBaseCcs->_yHeight - pBaseCcs->_yDescent > yTextHeight - yDescent)
        {
            yCur += ((pBaseCcs->_yHeight - pBaseCcs->_yDescent) -
                     (yTextHeight - yDescent)) / 2;
            _ptCur.y = yCur;
        }
        else if (pFFLi->HasCSSVerticalAlign())
        {
            LONG yDiff;
            switch (pFFLi->GetVerticalAlign(_pLS->_pNodeLi->Parent()->GetCharFormat()->HasVerticalLayoutFlow()))
            {
            case styleVerticalAlignTop:
            case styleVerticalAlignTextTop:
                yDiff = (pBaseCcs->_yHeight - pBaseCcs->_yDescent) - (yTextHeight - yDescent);
                break;

            case styleVerticalAlignBottom:
            case styleVerticalAlignTextBottom:
                yDiff = yDescent - pBaseCcs->_yDescent;
                break;

            case styleVerticalAlignAbsMiddle:
            case styleVerticalAlignMiddle:
                yDiff = (yDescent - pBaseCcs->_yDescent) - (yTextHeight - pBaseCcs->_yHeight) / 2;
                break;

                break;

            case styleVerticalAlignSuper:
                yDiff =  (yDescent - pBaseCcs->_yDescent) - yTextHeight / 2;
                break;

            case styleVerticalAlignSub:
                yDiff = yTextHeight / 2 - ((yTextHeight - yDescent) - (pBaseCcs->_yHeight - pBaseCcs->_yDescent));
                break;

            case styleVerticalAlignPercent:
            case styleVerticalAlignNumber:
            case styleVerticalAlignBaseline:
            default:
                yDiff = 0;
            }
            yCur += yDiff;
            _ptCur.y = yCur;
        }
    }

    if (!pCF->IsVisibilityHidden())
    {
        int *lpDxNew = NULL;
        const int *lpDxPtr = lpDx;
        long lGridOffset = 0;

        if (pCF->HasCharGrid(por->_fInnerCF) && por->_pPF)
        {
            switch (por->GetPF()->GetLayoutGridType(por->_fInnerPF))
            {
            case styleLayoutGridTypeStrict:
            case styleLayoutGridTypeFixed:
                // Only characters which has its own grid cell need 
                // special processing. Other characters are handled by 
                // LS installed LayoutGrid object.
                if (por->IsOneCharPerGridCell())
                {
                    lpDxNew = new int[cch];
                    if(!lpDxNew)
                        goto Cleanup;
                    lpDxPtr = lpDxNew;

                    long durThisChar = 0;
                    long durNextChar = 0;
                    long lThisDoubleGridOffset = 0;
                    long lError = 0;

                    ccs.Include(pch[0], durThisChar);
                    lThisDoubleGridOffset = lpDx[0] - durThisChar;
                    lGridOffset = lThisDoubleGridOffset/2;

                    for (unsigned int i = 0; i < cch-1; i++)
                    {
                        long lNextDoubleGridOffset = 0;

                        ccs.Include(pch[i+1], durNextChar);
                        lNextDoubleGridOffset = lpDx[i+1] - durNextChar;

                        // The width of the this char is essentially it's width
                        // plus the remaining space ahead of it in its grid cell,
                        // plus the space between the beginning of the next grid
                        // cell and the next character.
                        lpDxNew[i] = lpDx[i] - (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)/2;
                        lError = (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)%2;

                        lThisDoubleGridOffset = lNextDoubleGridOffset;
                        durThisChar = durNextChar;
                    }
                    lpDxNew[cch-1] = lpDx[cch-1] - (lThisDoubleGridOffset + lError)/2;
                }
                break;

            case styleLayoutGridTypeLoose:
            default:
                // In loose grid mode (default mode) the width of a char is 
                // width of its grid cell.
                break;
            }
        }

        Assert(GetBkMode(_hdc) == TRANSPARENT);

        if (por->_fKerned)
        {
            LONG lA = (_li._yHeight - _li._yBeforeSpace - _li._yDescent);
            yCur += _li._yBeforeSpace + lA - (pBaseCcs->_yHeight - pBaseCcs->_yDescent);
        }
        else if (_pLS->_fHasVerticalAlign)
        {
                yCur += por->_yProposed;
        }
        else
        {
            yCur += _li._yHeight - yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;
        }

        BOOL fSelectCont = FALSE;

        if (por->IsSelected())
        {
            // Find the next one run that is not an antisynth
            COneRun *porNext = por->_pNext;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pNext;
            }

            fSelectCont = porNext ? porNext->IsSelected()
                                  : FALSE;
        }

        //
        // If ellipsis is needed in the line, establish truncation point
        // and truncate text if necessary.
        //
        if (_fHasEllipsis)
        {
            DWORD cchOld    = cch;
            BOOL fRTLLayout = _pdp->IsRTLDisplay();
            BOOL fReverse   = fRTLLayout;
            if (por->_pComplexRun)
            {
                fReverse =    (fRTLLayout && !por->_pComplexRun->GetAnalysis()->fRTL)
                           || (!fRTLLayout && por->_pComplexRun->GetAnalysis()->fRTL);
            }

            PrepareForEllipsis(por, cwchRun, dupRun, lGridOffset, fReverse, lpDxPtr, &cch);
            if (cch == 0)
                goto Cleanup;   // Nothing to render

            if (fReverse && cchOld != cch)
            {
                pch += cchOld - cch;
                lpDxPtr += cchOld - cch;
            }
        }

        LONG xCur = _ptCur.x + lGridOffset;

        if (!fSelectCont)
        {
            if (   !_pdp->HasLongLine() 
                || NeedRenderText(xCur, &_rcClip, dupRun))
            {
                if (_fDisabled)
                {
                    if (_crForeDisabled != _crShadowDisabled)
                    {
                        //draw the shadow
                        SetTextColor(_hdc, _crShadowDisabled);
                        LSReExtTextOut(&ccs,
                                       _hdc,
                                       xCur + 1,
                                       yCur + 1,
                                       ETO_CLIPPED,
                                       &_rcClip,
                                       pch,
                                       cch,
                                       lpDxPtr,
                                       cm);
                    }
                    SetTextColor(_hdc, _crForeDisabled);
                }

                LSReExtTextOut(&ccs,
                               _hdc,
                               xCur,
                               yCur,                       
                               ETO_CLIPPED,
                               &_rcClip,
                               pch,
                               cch,
                               lpDxPtr,
                               cm);
            }
        }

        if (por->IsSelected())
        {
            RECT rcSelect;
            COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

            SetTextColor (_hdc, crTextColor);

            // Determine the bounds of the selection.
            rcSelect.left = _ptCur.x;
            rcSelect.right = rcSelect.left + dupRun;
            rcSelect.top = yCur;
            rcSelect.bottom = rcSelect.top + pBaseCcs->_yHeight;

            // If current run is selected, fix up _rcClip.
            if (por->IsSelected())
                FixupClipRectForSelection();

            // Clip the rect to the view and current clipping rect.
            IntersectRect(&rcSelect, &rcSelect, &_rcClip);

            RECT * prcClip = fSelectCont ? &_rcClip : &rcSelect;
            if (   !_pdp->HasLongLine() 
                || NeedRenderText(xCur, prcClip, dupRun))
            {
                if (_fDisabled)
                {
                    if (_crForeDisabled != _crShadowDisabled)
                    {
                        //draw the shadow
                        SetTextColor(_hdc, _crShadowDisabled);
                        LSReExtTextOut(&ccs,
                                       _hdc,
                                       xCur + 1,
                                       yCur + 1,
                                       ETO_CLIPPED,
                                       prcClip,
                                       pch,
                                       cch,
                                       lpDxPtr,
                                       cm);
                    }
                    SetTextColor(_hdc, _crForeDisabled);
                }

                LSReExtTextOut(&ccs,
                               _hdc,
                               xCur,
                               yCur,                       
                               ETO_CLIPPED,
                               prcClip,
                               pch,
                               cch,
                               lpDxPtr,
                               cm);
            }
        }

        if (lpDxNew)
            delete lpDxNew;
    }

    _ptCur.x = ((!(kTFlow & fUDirection)) ? _rcClip.right : _rcClip.left);

Cleanup:
//#if DBG==1
#ifdef NEVER
    // We need this only in case of DEBUG. We will assert otherwise.
    // In retail code we dctor of the renderer will unselect currently selected font.
    if (hfontOld != HFONT_INVALID)
        ccs.PopFont(_hdc, hfontOld);
#endif

    _rcClip = rcClipSave;
    return cch;
}

//-----------------------------------------------------------------------------
//
//  Function:   GlyphOut
//
//  Synopsis:   Renders one run of glyphs
//
//  Params:     Same as that for LineServices DrawGlyphs callback
//
//  Returns:    Number of glyphs rendered
//
//  Dev Note:   Any changes made to this function should be reflected in
//              CLSRenderer::TextOut() (as appropriate)
//
//-----------------------------------------------------------------------------
LONG
CLSRenderer::GlyphOut(
    COneRun * por,          // IN was plsrun
    BOOL fStrikeout,        // IN
    BOOL fUnderline,        // IN
    PCGINDEX pglyph,        // IN
    const int* pDx,         // IN was rgDu
    const int* pDxAdvance,  // IN was rgDuBeforeJust
    PGOFFSET pOffset,       // IN was rgGoffset
    PGPROP pVisAttr,        // IN was rgGProp
    PCEXPTYPE pExpType,     // IN was rgExpType
    DWORD cglyph,           // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const POINT* pptRun,    // IN
    PCHEIGHTS heightsPres,  // IN
    long dupRun,            // IN
    long dupLimUnderline,   // IN
    const RECT* pRectClip)  // IN
{
    COLORREF            crTextColor = 0;
    COLORREF            crNewTextColor = 0;
    const CCharFormat * pCF = por->GetCF();
    CComplexRun *       pcr = por->GetComplexRun();
    CCcs                ccs;
    const CBaseCcs *    pBaseCcs;
    RECT                rcClipSave = _rcClip;
    LONG                yDescent = _li._yDescent;
    SCRIPT_CACHE *      psc;
    LONG yCur;

    // LS should not be calling this function for metafiles.
    Assert(!g_fExtTextOutGlyphCrash);
    Assert(!_fEnhancedMetafileDC && !_pDI->IsMetafile());

    FONTIDX hfontOld = SetNewFont(&ccs, por);
    if (hfontOld == HFONT_INVALID)
        goto Cleanup;
    
    if (ShouldSkipThisRun(por, dupRun))
        goto Cleanup;

    pBaseCcs = ccs.GetBaseCcs();
    psc = ccs.GetUniscribeCache();
    
    // This is where this run will be drawn.
    _ptCur.x = pptRun->x - ((kTFlow & fUDirection) ? dupRun - 1 : 0) - GetChunkOffsetX();

    AssertSz((_ptCur.y == (pptRun->y + por->_lsCharProps.dvpPos) || por->GetCF()->_fIsRuby),
             "Our baseline differs from LS baseline!");
    yCur = pptRun->y + por->_lsCharProps.dvpPos;

#if DBG==1
    if (!IsTagEnabled(tagLSPrintDontAdjustContrastForWhiteBackground))
#endif
    if (!GetMarkup()->PaintBackground())
    {
        // If we are part of a print doc and the background is not printed,
        // we conceptually replace the background with white (because most
        // paper is white).  This means that we have to enhance the contrast
        // of bright-colored text on dark backgrounds.

        COLORREF crNewBkColor = RGB(255, 255, 255); // white background
        int      nMinimalLuminanceDifference = 150; // for now

        crNewTextColor = GetTextColor(_hdc);

        // Sujal insists that if both colors are the same (in this case both
        // white), then the second color will be modified.
        ContrastColors(crNewTextColor, crNewBkColor, nMinimalLuminanceDifference);

        // Finally, turn off the higher order bits
        crNewTextColor  = (crNewTextColor & CColorValue::MASK_COLOR) | 0x02000000;

        crTextColor = SetTextColor (_hdc, crNewTextColor);
    }

    AssertSz(pCF, "CLSRenderer::GlyphOut: We better have char format here");
    AssertSz(pcr, "CLSRenderer::GlyphOut: We better have CComplexRun here");

    if (_pLS->IsAdornment())
    {
        LONG yTextHeight = _li._yHeight - _li.GetYTop();

        // If the first line in the LI is a frame line, then its _yDescent
        // value is garbage. This also means that we will not center WRT
        // the text following the frame line. However, this is much better
        // than before when we did not render the bullet at all when the
        // first line in a LI was a frame line.(SujalP)
        if (_li.IsFrame())
        {
            yDescent = 0;
        }

        // Center the bullet in the ascent of the text line only if
        // the line of text is smaller than the bullet. This adjustment
        // keeps the bullets visible, but tends to keep them low on the
        // line for large text fonts.
        if (pBaseCcs->_yHeight - pBaseCcs->_yDescent > yTextHeight - yDescent)
        {
            yCur += ((pBaseCcs->_yHeight - pBaseCcs->_yDescent) -
                         (yTextHeight - yDescent)) / 2;
            _ptCur.y = yCur;
        }
    }

    if (!pCF->IsVisibilityHidden())
    {
        int *pDxNew = NULL;
        const int *pDxPtr = pDx;
        long lGridOffset = 0;

        if (pCF->HasCharGrid(por->_fInnerCF) && por->_pPF)
        {
            switch (por->GetPF()->GetLayoutGridType(por->_fInnerPF))
            {
            case styleLayoutGridTypeStrict:
            case styleLayoutGridTypeFixed:
                // Only characters which has its own grid cell need 
                // special processing. Other characters are handled by 
                // LS installed LayoutGrid object.
                if (por->IsOneCharPerGridCell())
                {
                    pDxNew = new int[cglyph];
                    if (!pDxNew)
                        goto Cleanup;
                    pDxPtr = pDxNew;

                    long durThisChar = 0;
                    long durNextChar = 0;
                    long lThisDoubleGridOffset = 0;
                    long lError = 0;
                    unsigned int nGlyphIndex = 0;

                    ccs.Include(por->_pchBase[0], durThisChar);
                    lThisDoubleGridOffset = pDx[0] - durThisChar;
                    lGridOffset = lThisDoubleGridOffset/2;

                    for (unsigned int i = 0; i < cglyph-1; i++)
                    {
                        if (pDx[i+1] != 0)
                        {
                            ccs.Include(por->_pchBase[i+1], durNextChar);
                            long lNextDoubleGridOffset = pDx[i+1] - durNextChar;

                            // The width of the this char is essentially it's width
                            // plus the remaining space ahead of it in its grid cell,
                            // plus the space between the beginning of the next grid
                            // cell and the next character.
                            pDxNew[nGlyphIndex] = pDx[nGlyphIndex] - (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)/2;
                            while (nGlyphIndex != i)
                                pOffset[++nGlyphIndex].du -= (lThisDoubleGridOffset + lNextDoubleGridOffset - lError)/2;
                            lError = (lThisDoubleGridOffset - lNextDoubleGridOffset + lError)%2;

                            lThisDoubleGridOffset = lNextDoubleGridOffset;
                            durThisChar = durNextChar;
                            nGlyphIndex = i+1;
                        }
                        else
                        {
                            pDxNew[i+1] = 0;
                        }
                    }
                    pDxNew[nGlyphIndex] = pDx[nGlyphIndex] - (lThisDoubleGridOffset + lError)/2;
                    while (nGlyphIndex != cglyph-1)
                        pOffset[++nGlyphIndex].du -= (lThisDoubleGridOffset - lError)/2;
                }
                break;

            case styleLayoutGridTypeLoose:
            default:
                // In loose grid mode (default mode) the width of a char is 
                // width of its grid cell.
                break;
            }
        }

        Assert(GetBkMode(_hdc) == TRANSPARENT);

        if (_pLS->_fHasVerticalAlign)
            yCur += por->_yProposed;
        else
            yCur += _li._yHeight - yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;

        BOOL fSelectCont = FALSE;

        if (por->IsSelected())
        {
            // Find the next one run that is not an antisynth
            COneRun *porNext = por->_pNext;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pNext;
            }

            fSelectCont = porNext ? porNext->IsSelected()
                                  : FALSE;

            // In RTL text a character actually overhangs the previous character
            porNext = por->_pPrev;
            while (   porNext
                   && porNext->IsAntiSyntheticRun())
            {
                porNext = porNext->_pPrev;
            }

            if (   porNext 
                && porNext->IsSelected())
            {
                fSelectCont = TRUE;
            }
        }

        //
        // If ellipsis is needed in the line, establish truncation point
        // and truncate text if necessary.
        //
        if (_fHasEllipsis)
        {
            DWORD cglyphOld = cglyph;
            BOOL fRTLLayout = _pdp->IsRTLDisplay();
            BOOL fReverse   = fRTLLayout;
            if (por->_pComplexRun)
            {
                fReverse =    (fRTLLayout && !por->_pComplexRun->GetAnalysis()->fRTL)
                           || (!fRTLLayout && por->_pComplexRun->GetAnalysis()->fRTL);
            }

            cglyphOld = cglyph;
            PrepareForEllipsis(por, cglyph, dupRun, lGridOffset, fReverse, pDxPtr, &cglyph);
            if (cglyph == 0)
                goto Cleanup;   // Nothing to render

            if (fReverse && cglyphOld != cglyph)
            {
                pglyph += cglyphOld - cglyph;
                pDxAdvance += cglyphOld - cglyph;
                pDxPtr += cglyphOld - cglyph;
                pOffset += cglyphOld - cglyph;
            }
        }

        if (!fSelectCont)
        {
            if (_fDisabled)
            {
                if (_crForeDisabled != _crShadowDisabled)
                {
                    //draw the shadow
                    SetTextColor(_hdc, _crShadowDisabled);
                    ScriptTextOut(_hdc,
                                  psc,
                                  _ptCur.x + 1 + lGridOffset,
                                  yCur + 1,
                                  ETO_CLIPPED,
                                  &_rcClip,
                                  pcr->GetAnalysis(),
                                  NULL,
                                  0,
                                  pglyph,
                                  cglyph,
                                  pDxAdvance,
                                  pDxPtr,
                                  pOffset);
                }
                SetTextColor(_hdc, _crForeDisabled);
            }

            ScriptTextOut(_hdc,
                          psc,
                          _ptCur.x + lGridOffset,
                          yCur,
                          ETO_CLIPPED,
                          &_rcClip,
                          pcr->GetAnalysis(),
                          NULL,
                          0,
                          pglyph,
                          cglyph,
                          pDxAdvance,
                          pDxPtr,
                          pOffset);
        }

        // If the run is selected, then we need to set up selection colors.
        if (por->IsSelected())
        {
            RECT rcSelect;
            COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

            SetTextColor (_hdc, crTextColor);

            // Determine the bounds of the selection.
            rcSelect.left = _ptCur.x;
            rcSelect.right = rcSelect.left + dupRun;
            rcSelect.top = yCur;
            rcSelect.bottom = rcSelect.top + pBaseCcs->_yHeight;

            // If current run is selected, fix up _rcClip.
            if (por->IsSelected())
                FixupClipRectForSelection();

            // Clip the rect to the view and current clipping rect.
            IntersectRect(&rcSelect, &rcSelect, &_rcClip);

            if (_fDisabled)
            {
                if (_crForeDisabled != _crShadowDisabled)
                {
                    //draw the shadow
                    SetTextColor(_hdc, _crShadowDisabled);
                    ScriptTextOut(_hdc,
                                  psc,
                                  _ptCur.x + 1 + lGridOffset,
                                  yCur + 1,
                                  ETO_CLIPPED,
                                  fSelectCont ? &_rcClip : &rcSelect,
                                  pcr->GetAnalysis(),
                                  NULL,
                                  0,
                                  pglyph,
                                  cglyph,
                                  pDxAdvance,
                                  pDxPtr,
                                  pOffset);
                }
                SetTextColor(_hdc, _crForeDisabled);
            }

            ScriptTextOut(_hdc,
                          psc,
                          _ptCur.x + lGridOffset,
                          yCur,
                          ETO_CLIPPED,
                          fSelectCont ? &_rcClip : &rcSelect,
                          pcr->GetAnalysis(),
                          NULL,
                          0,
                          pglyph,
                          cglyph,
                          pDxAdvance,
                          pDxPtr,
                          pOffset);
        }

        if (pDxNew)
            delete pDxNew;
    }

    _ptCur.x = ((kTFlow & fUDirection) ? _rcClip.left : _rcClip.right);

Cleanup:
//#if DBG==1
#ifdef NEVER
    // We need this only in case of DEBUG. We will assert otherwise.
    // In retail code we dctor of the renderer will unselect currently selected font.
    if (hfontOld != HFONT_INVALID)
        ccs.PopFont(_hdc, hfontOld);
#endif

    _rcClip = rcClipSave;
    return cglyph;
}

//+----------------------------------------------------------------------------
//
// Member:      CLSRenderer::FixupClipRectForSelection()
//
// Synopsis:    This function shrinks the clip rect when we have a selection
//              in order to avoid rendering selection out of bounds.
//              ONLY TO BE CALLED WHEN THERE IS A SELECTION !!!!
//
//-----------------------------------------------------------------------------

void CLSRenderer::FixupClipRectForSelection()
{
    long xOrigin;

    xOrigin = _rcView.left  + _xRelOffset;

    // RTL display may have a negative _rcView.left, but the origin is at zero
    if (_pdp->IsRTLDisplay() && _rcView.left < 0)
    {
        xOrigin -= _rcView.left;
    }

    _pdp->GetClipRectForLine(&_rcClip, _ptCur.y, xOrigin,
                             (CLineCore *)&_li, (CLineOtherInfo *)&_li);
    IntersectRect(&_rcClip, &_rcClip, _pDI->ClipRect());
}


//+----------------------------------------------------------------------------
//
// Member:      CLSRenderer::AdjustColors()
//
// Synopsis:    This function adjusts colors for selection
//
//-----------------------------------------------------------------------------

void CLSRenderer::AdjustColors(const CCharFormat* pCF,    // IN
                               COLORREF& crTextColor,  // IN/OUT
                               COLORREF& crBkColor)    // IN/OUT
{
    COLORREF crNewTextColor, crNewBkColor;

    // TODO (MohanB) Shouldn't this check the editability of the element instead?
    if (GetMarkup()->IsEditable())
    {
        // If we are in edit mode, then we just invert the text color
        // and the back color and draw in opaque mode. We cannot rely
        // on the hdc to provide us accurate bk color info, (because
        // bk could have been painted earlier and we are painting the
        // text in transparent mode, so the bk color may be invalid)
        // Hence, lets get the TRUE bk color.

        crNewTextColor = ~crTextColor;
        if (crBkColor != COLORREF_NONE)
        {
            crNewBkColor = ~crBkColor;
        }
        else
        {
            crNewBkColor = crTextColor;
        }

        ContrastColors (crNewTextColor, crNewBkColor, 100);

        // Finally, turn off the higher order bits
        crNewTextColor &= CColorValue::MASK_COLOR;
        crNewBkColor   &= CColorValue::MASK_COLOR;
    }
    else
    {
        Assert(pCF);

        crNewTextColor = GetSysColor (COLOR_HIGHLIGHTTEXT);
        crNewBkColor   = GetSysColor (COLOR_HIGHLIGHT);

        if (((CCharFormat *)pCF)->SwapSelectionColors())
        {
            COLORREF crTemp;

            crTemp = crNewBkColor;
            crNewBkColor = crNewTextColor;
            crNewTextColor = crTemp;
        }
    }

    crNewTextColor = GetNearestColor (_hdc, crNewTextColor);
    crNewBkColor   = GetNearestColor (_hdc, crNewBkColor);

    crTextColor = crNewTextColor;
    crBkColor = crNewBkColor;
}


/*
 *  CLSRenderer::SetNewFont (BOOL fJustRestore)
 *
 *  @mfunc
 *      Select appropriate font and color in the _hdc based on the
 *      current character format. Also sets the background color
 *      and mode.
 *
 *  @rdesc
 *      Font index if success
 */
FONTIDX
CLSRenderer::SetNewFont(CCcs * pccs, COneRun *por)
{
    const CCharFormat *pCF = por->GetCF();
    COLORREF cr;
    FONTIDX hfontOld = HFONT_INVALID;
    
    Assert(pCF);

    // get information about disabled

    if(pCF->_fDisabled)
    {
        _fDisabled = TRUE;

        _crForeDisabled   = GetSysColorQuick(COLOR_3DSHADOW);
        _crShadowDisabled = GetSysColorQuick(COLOR_3DHILIGHT);

        if (   _crForeDisabled == CLR_INVALID
            || _crShadowDisabled == CLR_INVALID
           )
        {
            _crForeDisabled   =
            _crShadowDisabled = GetSysColorQuick(COLOR_GRAYTEXT);
        }
    }
    else
    {
        _fDisabled = FALSE;
    }

    // Retrieves new font to use
    Assert(!_pDI->_hic.IsEmpty());
    Assert(_hdc != NULL);

   if (!_pLS->GetCcs(pccs, por, _hdc, _pDI))
        goto Cleanup;

    //
    // 1. Select font in _hdc
    //
    AssertSz(pccs->GetBaseCcs()->HasFont(), "CLSRenderer::SetNewFont pBaseCcs->_hfont is NULL");

    hfontOld = pccs->PushFont(_hdc);

    //
    // 2. Select the pen color
    //
    cr = pCF->_ccvTextColor.GetColorRef();


    if(cr == RGB(255,255,255))
    {
        const INT nTechnology = GetDeviceCaps(_hdc, TECHNOLOGY);

        if(nTechnology == DT_RASPRINTER || nTechnology == DT_PLOTTER)
        {
            cr = RGB(0,0,0);
        }
    }
    SetTextColor(_hdc, cr);


    //
    // 3. Set up the drawing mode.
    //
    SetBkMode(_hdc, TRANSPARENT);

Cleanup:
    return hfontOld;
}


/*
 *  CLSRenderer::RenderStartLine()
 *
 *  @mfunc
 *      Render bullet if at start of line
 *
 *  @rdesc
 *      TRUE if this method succeeded
 */
BOOL CLSRenderer::RenderStartLine(COneRun *por)
{
    if (_li._fHasBulletOrNum)
    {
        if (por->GetPF()->GetListing().HasAdornment())
        {
            RenderBullet(por);
        }
        else
        {
#if DBG==1
            {
                CTreeNode *pNode = por->Branch();
                BOOL fFound = FALSE;
                
                while(pNode && !SameScope(pNode, _pFlowLayout->ElementContent()))
                {
                    if (IsGenericListItem(pNode))
                    {
                        fFound = TRUE;
                        break;
                    }
                    pNode = pNode->Parent();
                }
                if (!fFound)
                {
                    fFound = por->_ptp->IsPointer();
                }
                AssertSz(fFound, "Hmm... this needs arye's look forward hack!");
            }
#endif
        }
#if 0
        else
        // NOTE: Arye. This is very hackish, but efficient for now.
        // What's this? We have a bullet bit set on the line, but
        // the immediate paragraph format doesn't have it? This must
        // mean that there is more than one paragraph on this line,
        // a legal state when aligned images occupy an entire paragraph.
        // Get the paraformat from the LAST run in the line paragraph instead.
        {
            // Briefly make it look like we're a little further along than
            // we really are so that we can render the bullet properly.
            por->Advance(_li._cch);

            if (por->GetPF()->GetListing(SameScope(por->Branch(), _pFlowLayout->Element())).HasAdornment())
            {
                RenderBullet(por);
            }
            // If we still can't find a paraformat with a bullet,
            // turn of the bit.
            else
            {
                _li._fHasBulletOrNum = FALSE;
            }
            por->Advance(-long(_li._cch));
        }
#endif
    }

    return TRUE;
}

/*
 *  CLSRenderer::RenderBullet()
 *
 *  @mfunc
 *      Render bullet at start of line
 *
 *  @rdesc
 *      TRUE if this method succeeded
 */
BOOL CLSRenderer::RenderBullet(COneRun *por)
{
    const CParaFormat *pPF;
    const CCharFormat *pCF;
    const CCharFormat *pCFLi;
    CTreeNode * pNodeLI;
    CTreeNode * pNodeFormatting = por->Branch();
    CMarkup *   pMarkup = _pLS->_treeInfo._pMarkup;
    BOOL        fRTLBullet;
    LONG        dxOffset = 0;

    //
    // Consider: <LI><P><B>text
    // The bold is the current branch, so we want to find the LI that's causing
    // the bullet, and accumulate margin/borders/padding for all nodes in between.
    //
    pNodeLI = pMarkup->SearchBranchForCriteriaInStory(pNodeFormatting, IsListItemNode);
    // Windows bug #546122: We may get pNodeLI == NULL in case of weird overlapping.
    if (!pNodeLI)
        goto Cleanup;

    pPF        = pNodeFormatting->GetParaFormat();
    pCF        = pNodeFormatting->GetCharFormat();
    pCFLi      = pNodeLI->GetCharFormat();
    fRTLBullet = pNodeLI->GetParaFormat()->_fRTL;

    // do not display the bullet if the list item is hidden
    if (pCFLi->IsVisibilityHidden() || pCFLi->IsDisplayNone())
        return TRUE;

    // we should be here only if the current paragraph has bullet or number.
    AssertSz(pPF->GetListing().HasAdornment(),
             "CLSRenderer::RenderBullet called for non-bullet");

    //
    // If we have nested block elements, we need to go back by
    // by margin, padding & border space of the nested block elements
    // under the LI to draw the bullet, unless the list position is "inside".
    // (meaning the bullet should be drawn inside the borders/padding)
    //
    if (pPF->_bListPosition != styleListStylePositionInside)
    {
        dxOffset = pPF->GetBulletOffset(GetCalcInfo()) +
                        pPF->GetNonBulletIndent(GetCalcInfo(), FALSE);

        if (pCF->_fPadBord)
        {
            long        xBorderLeft, xPaddingLeft, xBorderRight, xPaddingRight;
            CTreeNode * pNodeStart = pNodeFormatting;

            // If the formatting node itself has layout, then its borders
            // and padding are inside, so start accumulating from its parent.
            if(pNodeFormatting->ShouldHaveLayout())
                pNodeStart = pNodeFormatting->Parent();
                
            pNodeStart->Element()->ComputeHorzBorderAndPadding(
                GetCalcInfo(), pNodeStart, pNodeLI->Parent()->Element(),
                &xBorderLeft, &xPaddingLeft, &xBorderRight, &xPaddingRight);

            if (!fRTLBullet)
            {
                dxOffset += xBorderLeft + xPaddingLeft;
            }
            else
            {
                dxOffset += xBorderRight + xPaddingRight;
            }
        }
        dxOffset = max(int(dxOffset), _pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    if (!pPF->GetImgCookie() || !RenderBulletImage(pPF, dxOffset))
    {
        TCHAR achBullet[NUMCONV_STRLEN];
        GetListIndexInfo(pNodeLI, por, pCFLi, achBullet);
        por->_pchBase = por->SetString(achBullet);
        if (por->_pchBase == NULL)
            goto Cleanup;
        por->_lscch   = _tcslen(achBullet);
        _pLS->CHPFromCF(por, pCFLi);
        return RenderBulletChar(pNodeLI, dxOffset, fRTLBullet);
    }

Cleanup:
    return TRUE;
}

BOOL
CLSRenderer::RenderBulletImage(const CParaFormat *pPF, LONG dxOffset)
{
    SIZE sizeImg;
    RECT imgRect;
    CMarkup * pMarkup = _pFlowLayout->GetOwnerMarkup();
    CDoc    * pDoc = pMarkup->Doc();
    CImgCtx * pImgCtx = pDoc->GetUrlImgCtx(pPF->_lImgCookie);
    IMGANIMSTATE * pImgAnimState = _pFlowLayout->Doc()->GetImgAnimState(pPF->_lImgCookie);

    if (!pImgCtx || !(pImgCtx->GetState(FALSE, &sizeImg) & IMGLOAD_COMPLETE))
        return FALSE;

    // The sizeImg obtained from getState() assumed to be in OM pixels
    _pDI->DeviceFromDocPixels(sizeImg, sizeImg);

    if(!_li._fRTLLn)
    {
        imgRect.right  = min(_ptCur.x, _ptCur.x - dxOffset + sizeImg.cx);
        imgRect.left   = imgRect.right - sizeImg.cx;
    }
    else
    {
        imgRect.left  = max(_ptCur.x, _ptCur.x + dxOffset - sizeImg.cx);
        imgRect.right = imgRect.left + sizeImg.cx;
    }
    imgRect.top    = _ptCur.y + ( _li._yHeight - _li._yDescent +
                     _li._yBeforeSpace - sizeImg.cy) / 2;
    imgRect.bottom = imgRect.top + sizeImg.cy;

    //obtain physically-clipped hdc (IE bug 104651)
    XHDC hdcClipped = _pDI->GetDC(TRUE);
    
    if (pImgAnimState)
    {
        pImgCtx->DrawFrame(hdcClipped, pImgAnimState, &imgRect, NULL, NULL, _pDI->DrawImageFlags());
    }
    else
    {
        pImgCtx->DrawEx(hdcClipped, &imgRect, _pDI->DrawImageFlags());
    }
    
    return TRUE;
}

BOOL
CLSRenderer::RenderBulletChar(CTreeNode * pNodeLi, LONG dxOffset, BOOL fRTLOutter)
{
    BOOL fRet = TRUE;

    LONG  xSave = _ptCur.x;
    LONG  ySave = _ptCur.y;
    DWORD dwFlags  = _dwFlags();
    long  upStartAnm;
    long  upLimAnm;
    long  upStartText;
    long  upTrailingText;
    long  upLimText;
    POINT ptLS;
    CMarginInfo marginInfo;
    LSLINFO     lslinfo;
    LSTEXTCELL lsTextCell;
    LONG cpLastChar;
    LSERR lserr;
    HRESULT hr;

    _pLS->SetRenderer(this, GetBreakLongLines(_ptpCurrent->GetBranch()), pNodeLi);
    InitForMeasure(MEASURE_BREAKATWORD);
    LSDoCreateLine(GetCp(), NULL, &marginInfo,
                   (!fRTLOutter) ? _li._xLeft : _li._xRight,
                   NULL, FALSE, &lslinfo);
    
    if (!_pLS->_plsline)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    lserr = LsQueryLineDup(_pLS->_plsline, &upStartAnm, &upLimAnm,
                           &upStartText, &upTrailingText, &upLimText);
    if (lserr != lserrNone)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    cpLastChar = lslinfo.cpLim - 2;
    AssertSz(cpLastChar >= 0, "There should be atleast one char in the bullet string!");
    
    _cpStartRender = GetCp();
    _cpStopRender  = cpLastChar;
    _xChunkOffset  = CalculateChunkOffsetX();

    hr = _pLS->QueryLineCpPpoint(cpLastChar, FALSE, NULL, &lsTextCell);
    if (hr)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (pNodeLi->GetParaFormat()->_bListPosition != styleListStylePositionInside)
    {
        dxOffset += upLimText - upStartAnm;
        dxOffset -= lsTextCell.dupCell;
    }
    else
    {
        Assert(dxOffset == 0);
        dxOffset = max((LONG)lsTextCell.dupCell, (LONG)_pci->DeviceFromTwipsX(LIST_FIRST_REDUCTION_TWIPS));
    }

    if (!fRTLOutter)
    {
        if(!_li._fRTLLn)
            _ptCur.x -= dxOffset;           // basically _xLeft - dxOffset;
        // TODO (paulnel, track bug 4345) We have a mixed direction problem here.
        //                  On which side should the bullet be rendered?
        else
            _ptCur.x -= _li._xWidth + (dxOffset - lsTextCell.dupCell);
    }
    else
    {
        if(_li._fRTLLn)
            _ptCur.x += dxOffset;           // basically _xRight + dxOffset;
        // TODO (paulnel, track bug 4345) We have a mixed direction problem here.
        //                  On which side should the bullet be rendered?
        else
            _ptCur.x += _li._xWidth + (dxOffset - lsTextCell.dupCell);
    }

    _rcClip = *_pDI->ClipRect();

    ptLS = _ptCur;

#ifdef UNIX //IEUNIX draw bullets
    LPCWSTR pwchRun;
    DWORD  cchRun;
    COneRun *por = FetchLIRun(GetCp(), &pwchRun, &cchRun);
    WCHAR chUnixBulletStyle = por->_pchBase[0];
    if(chUnixBulletStyle == chDisc || chUnixBulletStyle == chCircle ||
       chUnixBulletStyle == chSquare )
    {
        CCcs ccs;
        CBaseCcs *pBaseCcs;
        int x = _ptCur.x;
        int y;
        int xWidth = pccs->GetBaseCcs()->_xAveCharWidth;
        COLORREF crText = GetTextColor(_hdc);
        HPEN hPen = CreatePen(PS_SOLID, 1, crText);
        HPEN hOldPen = (HPEN)SelectObject(_hdc, hPen);

        if (!SetNewFont(&ccs, por))
            goto Cleanup;

        pBaseCcs = ccs.GetBaseCcs();
        y = _ptCur.y + _li._yHeight - _li._yDescent +
                pBaseCcs->_yDescent - pBaseCcs->_yHeight - pBaseCcs->_yOffset;
        
        switch (chUnixBulletStyle)
        {
            case chDisc:
            {
                HBRUSH hNewBrush = CreateSolidBrush(crText);
                HBRUSH hOldBrush = (HBRUSH)SelectObject(_hdc, hNewBrush);
                Ellipse(_hdc, x, y, x+xWidth, y+xWidth);
                SelectObject(_hdc, hOldBrush);
                DeleteObject(hNewBrush);
                break;
            }
            case chCircle:
            {
                Arc(_hdc, x, y, x+xWidth, y+xWidth, x, y, x, y);
                break;
            }
            default: // must be square
            {
                RECT rc = {x, y, x+xWidth, y+xWidth};
                HBRUSH hNewBrush = CreateSolidBrush(crText);
                FillRect(_hdc, &rc, hNewBrush);
                DeleteObject(hNewBrush);
                break;
            }
        }
        SelectObject(_hdc, hOldPen);
        DeleteObject(hPen);
    }
    else // draw number
#endif // UNIX
    LsDisplayLine(_pLS->_plsline,   // The line to be drawn
                  &ptLS,            // The point at which to draw the line
                  1,                // Draw in transparent mode
                  &_rcClip          // The clipping rectangle
                 );
    // Restore render vars to continue with remainder of line.
    _dwFlags() = dwFlags;
    _ptCur.y = ySave;
    _ptCur.x = xSave;

Cleanup:
    _pLS->DiscardLine();

    return fRet;
}

void
CLSRenderer::GetListIndexInfo(CTreeNode *pLINode,
                              COneRun *por,
                              const CCharFormat *pCFLi,
                              TCHAR achNumbering[NUMCONV_STRLEN])
{
    LONG len;
    CListValue LI;

    Assert(pLINode);

    GetValidValue(pLINode, _pLS->_pMarkup->FindMyListContainer(pLINode), _pLS->_pMarkup,
                  _pFlowLayout->ElementContent(), &LI);
    
    switch ( LI._style )
    {
        case styleListStyleTypeNone:
        case styleListStyleTypeNotSet:
            *achNumbering = L'\0';
            break;
        case styleListStyleTypeUpperAlpha:
            NumberToAlphaUpper(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeLowerAlpha:
            NumberToAlphaLower(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeUpperRoman:
            NumberToRomanUpper(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeLowerRoman:
            NumberToRomanLower(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeDecimal:
            NumberToNumeral(LI._lValue, achNumbering);
            _pLS->GetCFNumber(por, pCFLi);      // get ccs for numbered bullet
            break;
        case styleListStyleTypeDisc:
            achNumbering[0] = chDisc;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chDisc, pCFLi);
            break;
        case styleListStyleTypeCircle:
            achNumbering[0] = chCircle;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chCircle, pCFLi);
            break;
        case styleListStyleTypeSquare:
            achNumbering[0] = chSquare;
            achNumbering[1] = L'\0';
            _pLS->GetCFSymbol(por, chSquare, pCFLi);
            break;
        default:
            AssertSz(0, "Unknown numbering style.");
    }
    len = _tcslen(achNumbering);
    if (len > 1 && por->GetPF()->HasRTL(por->_fInnerPF))
    {
        // If we have RTL numbering run it through the bidi algorithm and order
        // the characters visually.
        CBidiLine * pBidiLine = new CBidiLine(TRUE, len, achNumbering);

        if (pBidiLine != NULL)
        {
            TCHAR achNumberingVisual[NUMCONV_STRLEN];

            pBidiLine->LogicalToVisual(TRUE, len, achNumbering, achNumberingVisual);
            CopyMemory(achNumbering, achNumberingVisual, len  * sizeof(WCHAR));
            delete pBidiLine;
        }
    }
    achNumbering[len] = CLineServices::s_aSynthData[CLineServices::SYNTHTYPE_SECTIONBREAK].wch;
    achNumbering[len+1] = '\0';
}


COneRun *
CLSRenderer::FetchLIRun(
    LSCP lscp,          // IN
    LPCWSTR* ppwchRun,  // OUT
    DWORD* pcchRun)     // OUT
{
    COneRun *por = _pLS->_listCurrent._pHead;
    Assert(por);
    Assert(   lscp >= por->_lscpBase
           && lscp < por->_lscpBase + por->_lscch
          );
    LONG cpOffset = lscp - por->_lscpBase;
    *ppwchRun = por->_pchBase;
    *pcchRun = por->_lscch;
    if (cpOffset > 0)
    {
        *ppwchRun += cpOffset;
        *pcchRun -= cpOffset;
    }
    Assert(*pcchRun > 0);
    por->CheckForUnderLine(_pLS->_fIsEditable);
    
    return por;
}


//+---------------------------------------------------------------------------
//
//  Function:   LSDeinitUnderlinePens
//
//  Synopsis:   Releases any pen still stored in the cache
//
//----------------------------------------------------------------------------
void
LSDeinitUnderlinePens(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (!pts->hpenUnderline)
        return;

    DeleteObject(pts->hpenUnderline);

    return;
}

//-----------------------------------------------------------------------------
//
//  Function:   Drawunderline
//
//  Synopsis:   Draws an underline
//
//  Params:     Same as that passed by lineservices to drawunderline
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLSRenderer::DrawUnderline(
    COneRun *por,           // IN
    UINT kUlBase,           // IN
    const POINT* pptStart,  // IN
    DWORD dupUl,            // IN
    DWORD dvpUl,            // IN
    LSTFLOW kTFlow,         // IN
    UINT kDisp,             // IN
    const RECT* prcClip)    // IN
{
    LSERR lserr = lserrNone;

    if (   por->Cp() >= _cpStartRender
        && por->Cp() <  _cpStopRender
       )
    {
        const CCharFormat  *pCF = por->GetCF();
        POINT ptStart           = *pptStart;
        CComplexRun *pCcr       = por->GetComplexRun();
        BOOL  fUnderline        = (pCcr && pCcr->_RenderStyleProp._fStyleUnderline);
        BOOL  fUnderlineAbove   = FALSE;
        BOOL  fOverline         = pCF->_fOverline  || (pCcr && pCcr->_RenderStyleProp._fStyleOverline);
        BOOL  fLineThrough      = pCF->_fStrikeOut || (pCcr && pCcr->_RenderStyleProp._fStyleLineThrough);

        if (pCF->_fUnderline)
        {
            const LANGID langid = PRIMARYLANGID(LANGIDFROMLCID(pCF->_lcid));
            BOOL fAbove =    (pCF->_bTextUnderlinePosition == styleTextUnderlinePositionAbove)
                          || (   pCF->HasVerticalLayoutFlow()
                              && (pCF->_bTextUnderlinePosition == styleTextUnderlinePositionAuto)
                              && (   (langid == LANG_JAPANESE) 
                                  || (langid == 0 && GetMarkup()->GetFamilyCodePage() == CP_JPN_SJ)
                                 )
                             );
            fUnderline = fUnderline || !fAbove;
            fUnderlineAbove = fUnderlineAbove || fAbove;
        }

        CCcs ccs;
        const CBaseCcs *pBaseCcs;
        COLORREF crTextColor = por->GetCF()->_ccvTextColor.GetColorRef();

        FONTIDX hfontOld = SetNewFont(&ccs, por);
        if (hfontOld == HFONT_INVALID)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
        pBaseCcs = ccs.GetBaseCcs();

        if (por->IsSelected())
        {
            SetTextColor (_hdc, crTextColor);
        }

        ptStart.x -= GetChunkOffsetX();
        ptStart.y += por->_lsCharProps.dvpPos;

        // draw line-through
        if (fLineThrough)
        {
            POINT pt       = ptStart;
            CColorValue cv = por->IsSelected() 
                             ? ((pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                                ? pCcr->_RenderStyleProp._ccvDecorationColor
                                : GetTextColor(_hdc) )
                             : por->GetTextDecorationColor(TD_LINETHROUGH);
            LONG dwWidth   = max(1L, LONG(((pBaseCcs->_yHeight / 10) / 2) * 2 + 1 )); // must be odd
            
            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed + por->_yObjHeight / 2;
            }
            else
            {
                pt.y += _li._yHeight - _li._yDescent + 
                        pBaseCcs->_yDescent - (pBaseCcs->_yHeight + 1) / 2;
            }
            
            DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dwWidth, kTFlow, kDisp, prcClip);
        }

        // draw overline
        if (fOverline || fUnderlineAbove)
        {
            POINT pt       = ptStart;
            CColorValue cv = por->IsSelected() 
                             ? ((pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                                ? pCcr->_RenderStyleProp._ccvDecorationColor
                                : GetTextColor(_hdc) ) 
                             : por->GetTextDecorationColor(fUnderlineAbove ? TD_UNDERLINE : TD_OVERLINE);

            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed;
            }
            else
            {
                pt.y += _li._yHeight - _li._yDescent + pBaseCcs->_yDescent - pBaseCcs->_yHeight;
            }

            DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);
        }

        // draw underline
        if (fUnderline)
        {
            POINT pt       = ptStart;
            CColorValue cv = (pCcr && pCcr->_RenderStyleProp._ccvDecorationColor.IsDefined())
                             ? pCcr->_RenderStyleProp._ccvDecorationColor
                             : (por->IsSelected()) 
                               ? GetTextColor(_hdc) 
                               : por->GetTextDecorationColor(TD_UNDERLINE);

            if (_pLS->_fHasVerticalAlign)
            {
                pt.y += por->_yProposed + por->_yObjHeight - (pBaseCcs->_yDescent + 1) / 2;
            }
            else
            {
                // NOTE (t-ramar): Since we are using _li._yTxtDescent here, this causes a bit of
                // strangeness with underlining of Ruby pronunciation text. Basically, since the pronunciation
                // text is 50% the size of the base text (_li._yTxtDescent is usually based on the base text)
                // underlining of the pronunciation text will appear a little too low
                pt.y += _li._yHeight - _li._yDescent + _li._yTxtDescent / 2;
            }

            // NOTE(SujalP): Some fonts may have no descent in which we can show the
            // underline, and we may end up with pt.y being below the line. So adjust
            // the underline such that it is always within the line.
            if (pt.y >= pptStart->y + _li.GetYBottom())
                pt.y = pptStart->y + _li.GetYBottom() - 1;
            

            if(  pCcr && pCcr->_RenderStyleProp._fStyleUnderline 
                 && (pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleWave) )
                 DrawEnabledDisabledLine(cv, CFU_SQUIGGLE, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);
            else
                 DrawEnabledDisabledLine(cv, kUlBase, &pt, dupUl, dvpUl, kTFlow, kDisp, prcClip);

        }
//#if DBG==1
#ifdef NEVER
        // We need this only in case of DEBUG. We will assert otherwise.
        // In retail code we dctor of the renderer will unselect currently selected font.
        Assert(hfontOld != HFONT_INVALID);
        ccs.PopFont(_hdc, hfontOld);
#endif
    }

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   DrawEnabledDisabledLine
//
//  Synopsis:   Draws an enabled or a disabled line at the specified coordinates
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLSRenderer::DrawEnabledDisabledLine(
    const CColorValue & cv,     // IN
    UINT     kUlBase,           // IN
    const    POINT* pptStart,   // IN
    DWORD    dupUl,             // IN
    DWORD    dvpUl,             // IN
    LSTFLOW  kTFlow,            // IN
    UINT     kDisp,             // IN
    const    RECT* prcClip)     // IN
{
    LSERR lserr    = lserrNone;
    COLORREF color = cv.GetColorRef();
    CRect ulRect;

    // If we're drawing from RtL then we need to shift one pixel to the right
    // in order to account for the left biased drawing of rects (pixel at
    // rc.left is drawn, pixel at rc.right is not).
    ulRect.left   = pptStart->x - ((!(kTFlow & fUDirection)) ? 0 : dupUl - 1);
    ulRect.top    = pptStart->y;
    ulRect.right  = pptStart->x + ((!(kTFlow & fUDirection)) ? dupUl : 1);
    ulRect.bottom = pptStart->y + dvpUl;

    if (IntersectRect(&ulRect, &ulRect, prcClip))
    {
        int bkModeOld = 0;
        
        if (_fDisabled)
        {
            if (_crForeDisabled != _crShadowDisabled)
            {
                CRect ulRectDisabled(ulRect);

                // draw the shadow
                color = _crShadowDisabled;
                ulRectDisabled.OffsetRect(1, 1);
                lserr = DrawLine(kUlBase, color, &ulRectDisabled);
                if (lserr != lserrNone)
                    goto Cleanup;

                // now set the drawing mode to transparent
                bkModeOld = SetBkMode(_hdc, TRANSPARENT);
            }
            color = _crForeDisabled;
        }

        // draw the actual line
        if (kUlBase & CFU_SQUIGGLE)
        {
            lserr = DrawSquiggle(pptStart, color, dupUl);
        }
        else if ((kUlBase& CFU_UNDERLINE_BITS) == CFU_UNDERLINETHICKDASH)
        {
            POINT pt;
            if (kTFlow & fUDirection)
            {
                pt.x = pptStart->x - dupUl;
                pt.y = pptStart->y;
            }
            else
            {
                pt.x = pptStart->x;
                pt.y = pptStart->y;
            }
            lserr = DrawThickDash(&pt, color, dupUl);
        }
        else
        {
            lserr = DrawLine(kUlBase, color, &ulRect);
        }
        if (lserr != lserrNone)
            goto Cleanup;
        
        // restore the background mode.
        if (_fDisabled && _crForeDisabled != _crShadowDisabled)
        {
            SetBkMode(_hdc, bkModeOld);
        }
    }

Cleanup:
    return lserr;
}

LSERR 
CLSRenderer::DrawSquiggle(
    const    POINT* pptStart,   // IN
    COLORREF colorUnderLine,    // IN
    DWORD    dupUl)             // IN
{
    // This table represents the change in y that the wavy underline needs.
    // If this is changed the other numbers below must change.
    const int  ldyTable[4] = { 0, 1, 0, -1 };
    const int  ySquiggleHeight = 3; //height of the squiggle
    LSERR      lserr = lserrNone;
    POINT      pt;
    HPEN       hPen, hPenOld;

    hPen = CreatePen(PS_SOLID, 0, colorUnderLine);

    if (hPen && dupUl)
    {  
        int i, dx, tableSize = 4;
        LONG x, y;
        XHDC hdc = _pDI->GetDC(TRUE);

        hPenOld = (HPEN) SelectObject(hdc, hPen);        
        GetViewportOrgEx(hdc, &pt);
        i = (pt.x-pptStart->x)%tableSize;
        i = (i > 0) ? i : (i+tableSize)%tableSize;
        x = pptStart->x;
        //adjust y position. Squiggle should fit into text descent, otherwise
        //lets move it up so that it doesn't go lower then text descent.
        y = pptStart->y - max(0L, ySquiggleHeight - _li.oi()->_yTxtDescent);

        MoveToEx(hdc, x, y + ldyTable[i], NULL );
        for( dx = (dupUl>1)?1+(i%2):dupUl; dupUl > 0; dx = ((dupUl <= 1)?1:2) )
        {
            dupUl -= dx;
            x += dx;
            i = (i + dx) % tableSize;
            LineTo(hdc, x, y + ldyTable[i] );
        }

        SelectObject(hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

LSERR 
CLSRenderer::DrawThickDash(
    const    POINT* pptStart,   // IN
    COLORREF colorUnderLine,    // IN
    DWORD    dupUl)             // IN
{
    const int  xDashWidth = 3;
    LSERR      lserr = lserrNone;
    HPEN       hPen, hPenOld;

    hPen = CreatePen(PS_SOLID, 0, colorUnderLine);

    if (hPen && dupUl)
    {
        LONG dx, x;
        XHDC hdc = _pDI->GetDC(TRUE);

        hPenOld = (HPEN) SelectObject(hdc, hPen);

        dx = (pptStart->x/(2*xDashWidth))*(2*xDashWidth);
        dx -= ((dx >= 0) ? 0 : (((pptStart->x%(2*xDashWidth)) == 0) ? 0 : 2*xDashWidth));
        x = pptStart->x%(2*xDashWidth);
        x += dx + ((x >= 0) ? 0 : 2*xDashWidth);

        if (x - dx >= xDashWidth)
        {
            dx += 2*xDashWidth;
            x = dx;
        }

        while (x < pptStart->x + (LONG)dupUl)
        {
            MoveToEx(hdc, x, pptStart->y, NULL);
            LineTo(hdc, min((LONG)(dx+xDashWidth-(x-dx)), (LONG)(pptStart->x+(LONG)dupUl)), pptStart->y);
            MoveToEx(hdc, x, pptStart->y+1, NULL);
            LineTo(hdc, min((LONG)(dx+xDashWidth-(x-dx)), (LONG)(pptStart->x+(LONG)dupUl)), pptStart->y+1);

            dx += 2*xDashWidth;
            x = dx;
        }

        SelectObject(hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

LSERR
CLSRenderer::DrawLine(
    UINT     kUlBase,        // IN
    COLORREF colorUnderLine, // IN
    CRect    *pRectLine)     // IN
{
    LSERR    lserr = lserrNone;
    HPEN     hPen,   hPenOld;
    UINT     lopnStyle = PS_SOLID;
    if (((kUlBase & CFU_UNDERLINE_BITS) == CFU_UNDERLINEDOTTED))
    {
        lopnStyle = PS_DOT;
    }

    hPen = CreatePen(lopnStyle, 0, colorUnderLine);
    if (hPen)
    {    
        hPenOld = (HPEN) SelectObject(_hdc, hPen);        
        if (pRectLine->bottom - pRectLine->top <= 1)
        {
            MoveToEx( _hdc, pRectLine->left, pRectLine->top, NULL );
            LineTo( _hdc, pRectLine->right, pRectLine->top );
        }
        else
        {
            HBRUSH  hBrush, hBrushOld;

            hBrush = CreateSolidBrush(colorUnderLine);
            if (hBrush)
            {
                hBrushOld = (HBRUSH) SelectObject(_hdc, hBrush);
                Rectangle(_hdc, pRectLine->left, pRectLine->top, pRectLine->right, pRectLine->bottom);
                SelectObject(_hdc, hBrushOld);
                DeleteObject(hBrush);
            }
        }
        SelectObject(_hdc, hPenOld);
        DeleteObject(hPen);
    }

    return lserr;
}

//
// Get offset of the line within a relative chunk
//
// The offset is physical (positive direction is always left-to-right)
// For RTL lines, the offset is from the right margin (and usually negative).
//
LONG    
CLSRenderer::CalculateRelativeChunkOffsetX() const
{
    // Non-relative case should be handled by the inline method
    Assert(_li._fPartOfRelChunk);

    // Get position of chunk start in the master line
    BOOL fRTLFlow;
    LONG xOffset = GetLS()->CalculateXPositionOfCp(_cpStartRender, FALSE, &fRTLFlow);

    // adjust for line and flow direction
    if (GetLS()->_li.IsRTLLine())
    {
        // In RTL lines, chunks move in opposite direction 
        xOffset = -xOffset;

        // LTR in RTL
        // note: opposite-flow adjustment is one-pixel different for RTL and LTR lines
        if (!fRTLFlow)
            xOffset += _li._xWidth;
    }
    else if (fRTLFlow)
    {
        // RTL in LTR
        xOffset -= _li._xWidth - 1;
    }

#if DBG==1
    // check that in all LTR case, xOffset always matches accumulated width
    // (old code used accumulated width to caclulate chunk offset)
    if (fRTLFlow != GetLS()->_li.IsRTLLine())
        const_cast<CLSRenderer*>(this)->_fBiDiLine = TRUE;
        
    Assert(GetLS()->_li.IsRTLLine() || fRTLFlow || _fBiDiLine || xOffset == _xAccumulatedWidth 
           || !IsTagEnabled(tagDebugRTL));
#endif
    
    return xOffset;
}

//-----------------------------------------------------------------------------
//
//  Function:   NeedRenderText
//
//  Synopsis:   Determines whether to render text or not, by comparing
//              clipping rectangle to text position and width.
//
//-----------------------------------------------------------------------------
BOOL
CLSRenderer::NeedRenderText(long x, const RECT *prcClip, long dup) const
{
    Assert(_pdp->HasLongLine());

    BOOL fRenderText = x < prcClip->right;
    if (fRenderText)
    {
        AssertSz(dup != -1, "Cannot use dup.");
        if (dup != -1)
        {
            fRenderText = (x + dup >= prcClip->left);
        }
    }
    return fRenderText;
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderEllipsis
//
//  Synopsis:   Renders ellipsis at the end of the line.
//
//-----------------------------------------------------------------------------
VOID
CLSRenderer::RenderEllipsis()
{
    Assert(_fHasEllipsis);
    Assert(_pccsEllipsis && _pccsEllipsis->GetBaseCcs());

    // Select font in _hdc
    FONTIDX hfontOld = HFONT_INVALID;
    XHDC hdc = _pccsEllipsis->GetHDC();
    AssertSz(_pccsEllipsis->GetBaseCcs()->HasFont(), "CLSRenderer::RenderEllipsis pBaseCcs->_hfont is NULL");
    hfontOld = _pccsEllipsis->PushFont(hdc);

    // Select the pen color
    CTreeNode * pFormattingNode = _pdp->GetFlowLayout()->GetFirstBranch();
    const CCharFormat  * pCF = pFormattingNode->GetCharFormat();
    COLORREF cr = pCF->_ccvTextColor.GetColorRef();
    if (cr == RGB(255,255,255))
    {
        const INT nTechnology = GetDeviceCaps(hdc, TECHNOLOGY);
        if (nTechnology == DT_RASPRINTER || nTechnology == DT_PLOTTER)
            cr = RGB(0,0,0);
    }
    SetTextColor(hdc, cr);

    // Set up the drawing mode.
    SetBkMode(hdc, TRANSPARENT);

    // Get ellipsis metrics
    LONG xEllipsisWidth;
    _pccsEllipsis->Include(WCH_DOT, xEllipsisWidth);
    wchar_t achEllipsis[3] = { WCH_DOT, WCH_DOT, WCH_DOT };
    LONG aEllipsisWidth[3] = { xEllipsisWidth, xEllipsisWidth, xEllipsisWidth };
    LONG yEllipsisPos = _ptCur.y + (_li._yHeight - _li._yDescent) - 
                        (_pccsEllipsis->GetBaseCcs()->_yHeight - _pccsEllipsis->GetBaseCcs()->_yDescent);

    // Render ellipsis
    if (pCF->_fDisabled)
    {
        COLORREF crForeDisabled   = GetSysColorQuick(COLOR_3DSHADOW);
        COLORREF crShadowDisabled = GetSysColorQuick(COLOR_3DHILIGHT);

        if (crForeDisabled == CLR_INVALID || crShadowDisabled == CLR_INVALID)
            crForeDisabled = crShadowDisabled = GetSysColorQuick(COLOR_GRAYTEXT);

        SetTextColor(hdc, crShadowDisabled);
        ::ExtTextOutW(hdc, _xEllipsisPos+1, yEllipsisPos+1, ETO_CLIPPED, &_rcClip, achEllipsis, 3, (const int *)&aEllipsisWidth);
        SetTextColor(hdc, crForeDisabled);
    }
    ::ExtTextOutW(hdc, _xEllipsisPos, yEllipsisPos, ETO_CLIPPED, &_rcClip, achEllipsis, 3, (const int *)&aEllipsisWidth);

    if (hfontOld != HFONT_INVALID)
    {
        _pccsEllipsis->PopFont(hdc, hfontOld);
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   RenderEllipsis
//
//  Synopsis:   Renders ellipsis at the end of the line.
//
//-----------------------------------------------------------------------------
VOID
CLSRenderer::PrepareForEllipsis(
    COneRun *por, 
    DWORD cchRun, 
    long dupRun, 
    long lGridOffset, 
    BOOL fReverse,
    const int *lpDxPtr, 
    DWORD *pcch)
{
    Assert(_pccsEllipsis && _pccsEllipsis->GetBaseCcs());

    LONG xRenderWidth;
    RECT rcView;
    BOOL fRTLLayout = _pdp->IsRTLDisplay();

    //
    // Retrieve the width of rendered content.
    //
    _pFlowLayout->GetElementDispNode()->GetClientRect(&rcView, CLIENTRECT_CONTENT);
    if (fRTLLayout)
        xRenderWidth = _li._xWidth - rcView.left + _li._xNegativeShiftRTL;
    else
        xRenderWidth = rcView.right - _li._xLeft - max(0L, rcView.right - (_li._xLeft + _li._xWidth));

    //
    // Need to show ellipsis, when the line's width is greater than the width
    // used for measuring.
    //
    if (   xRenderWidth > 0
        && _li._xWidth > xRenderWidth)
    {
        LONG xWidthBefore;
        LONG xEllipsisWidth;

        //
        // Get the width of ellipsis.
        //
        xEllipsisWidth = 0; // to make compiler happy
        _pccsEllipsis->Include(WCH_DOT, xEllipsisWidth);
        xEllipsisWidth *= 3;

        if (fRTLLayout)
            xWidthBefore = _li._xWidth - (_ptCur.x - _li._xNegativeShiftRTL + dupRun);
        else
            xWidthBefore = _ptCur.x - _li._xLeft;

        //
        // If the text run doesn't overlap ellipsis position, don't need to truncate the run.
        //
        if (xWidthBefore + dupRun > xRenderWidth - xEllipsisWidth)
        {
            //
            // If truncation occurs in this text run.
            // Find index of the last rendered character and truncate the rendered text.
            // NOTE: In case of selection don't show ellipsis.
            //
            if (!por->_fSelected)
            {
                long dur;
                unsigned int i;
                unsigned int idx;
                LONG xRunWidthRemaining = (long(cchRun) == por->_lscch) ? dupRun : por->_xWidth - _xRunWidthSoFar;

                dur = lGridOffset;
                for (i = 0; i < *pcch; i++)
                {
                    idx = fReverse ? *pcch - i - 1 : i;
                    dur += lpDxPtr[idx];

                    if (xWidthBefore + dur > xRenderWidth - xEllipsisWidth)
                    {
                        // Truncation point after 'i' characters. 
                        dur -= lpDxPtr[idx];

                        //
                        // If this is not the last rendered run, we need to check if:
                        // (1) following visible runs are selected
                        // (2) following visible runs are objects
                        // In these case don't show ellipsis for the current text run.
                        //
                        if (xWidthBefore + xRunWidthRemaining < xRenderWidth)
                        {
                            BOOL fStop = TRUE;
                            COneRun * porLast = por;
                            POINT ptTest = _ptCur;
                            if (fRTLLayout)
                                ptTest.x = _ptCur.x - 1;
                            else
                                ptTest.x = _li._xLeft + xWidthBefore + xRunWidthRemaining + 1;

                            do
                            {
                                COneRun * porFollowing;
                                LONG cpFollowingRun;

                                // Get cp of the following run (in the text flow direction)
                                cpFollowingRun = ((CDisplay *)_pdp)->CpFromPoint(ptTest, NULL, NULL, NULL, CDisplay::CFP_EXACTFIT, NULL, NULL, NULL, NULL);
                                Assert(cpFollowingRun >= 0);

                                // Find run, which contains the requested cp.
                                _pLS->LSCPFromCPCore(cpFollowingRun, &porFollowing);
                                Assert(porFollowing);
                                Assert(porFollowing->IsNormalRun() && !porFollowing->_fHidden);
                                if (porFollowing == porLast)
                                    break;

                                if (   porFollowing->_fSelected
                                    || porFollowing->_fCharsForNestedLayout)
                                {
                                    // Don't truncate the current text run
                                    i = *pcch;
                                    break;
                                }

                                porLast = porFollowing;
                                if (fRTLLayout)
                                {
                                    ptTest.x -= porFollowing->_xWidth;
                                    fStop = (ptTest.x < 0);
                                }
                                else
                                {
                                    ptTest.x += porFollowing->_xWidth;
                                    fStop = (ptTest.x > xRenderWidth + _li._xLeft);
                                }

                            } while (!fStop);
                        }
                        break;
                    }
                }
                Assert((i < *pcch) || (xWidthBefore + xRunWidthRemaining < xRenderWidth));

                //
                // If this run has been truncated, need to:
                // * set ellipsis position
                // * move rendering position in case of RTL layout
                //
                if (i != *pcch)
                {
                    // In RTL layout need to move rendering point to the beginning
                    // of rendered text
                    if (fRTLLayout)
                        _ptCur.x += dupRun - dur;

                    // Reset ellipsis position, if:
                    // (1) need to render any characters in the run
                    // (2) ellipsis position hasn't been set yet
                    // (3) new ellipsis position is closer to the logical beginning of 
                    //     the line, this case handles BIDI text
                    if (   i != 0
                        || !_fEllipsisPosSet
                        || (!fRTLLayout && (_xEllipsisPos > _ptCur.x + dur))
                        || (fRTLLayout && (_xEllipsisPos < _ptCur.x - xEllipsisWidth))
                       )
                    {
                        _fEllipsisPosSet = TRUE;
                        if (fRTLLayout)
                            _xEllipsisPos = _ptCur.x - xEllipsisWidth;
                        else
                            _xEllipsisPos = _ptCur.x + dur;
                    }

                    *pcch = i;
                }
            }
        }

        //
        // If rendering only part of the text run, accumulate width of the run.
        // This situation can occur in case of hyphens.
        //
        if (long(cchRun) != por->_lscch)
        {
            if (dupRun + _xRunWidthSoFar >= por->_xWidth)
                _xRunWidthSoFar = 0;
            else
                _xRunWidthSoFar += dupRun;
        }
        else
        {
            _xRunWidthSoFar = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsmisc.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSMISC.CXX -- line services misc support
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      01/05/98     cthrash created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifdef DLOAD1
extern "C"  // MSLS interfaces are C
{
#endif

#ifndef X_LSPAP_H_
#define X_LSPAP_H_
#include <lspap.h>
#endif

#ifndef X_LSCHP_H_
#define X_LSCHP_H_
#include <lschp.h>
#endif

#ifndef X_LSFFI_H_
#define X_LSFFI_H_
#include <lsffi.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_LSKTAB_H_
#define X_LSKTAB_H_
#include <lsktab.h>
#endif

#ifndef X_LSENUM_H_
#define X_LSENUM_H_
#include <lsenum.h>
#endif

#ifndef X_POSICHNK_H_
#define X_POSICHNK_H_
#include <posichnk.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include <ltcell.hxx>
#endif

#ifndef X__FONTLINK_H_
#define X__FONTLINK_H_
#include "_fontlnk.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_MLANG_H_
#define X_MLANG_H_
#include <mlang.h>
#endif

#ifndef X_LSTXM_H_
#define X_LSTXM_H_
#include <lstxm.h>
#endif

#define MSLS_MIN_VERSION 337
//#define MSLS_MIN_VERSION 349
#define MSLS_MAX_VERSION INT_MAX
#define MSLS_BUILD_LOCATION "\\\\word2\\lineserv\\rel0337"
//#define MSLS_BUILD_LOCATION "\\\\word2\\lineserv\\rel0349"

DeclareLSTag(tagLSAllowEmergenyBreaks, "Allow emergency breaks");
DeclareLSTag(tagLSTraceLines, "Trace plsline setup/discardal");

DeclareTag(tagCCcsCacheHits, "LineServices", "Trace Ccs cache hit %");
DeclareTag(tagFontLinkFonts, "Font", "Trace fontlinking on selected text");

MtDefine(QueryLinePointPcp_aryLsqsubinfo_pv, Locals, "CLineServices::QueryLinePointPcp::aryLsqsubinfo_pv");
MtDefine(QueryLineCpPpoint_aryLsqsubinfo_pv, Locals, "CLineServices::QueryLineCpPpoint::aryLsqsubinfo_pv");
MtDefine(GetGlyphOutline, Locals, "CLineServices::KernHeightToGlyph::GetGlyphOutline");
MtDefine(LSVerCheck, Locals, "LS Version check")
MtDefine(CFLSlab_pv, LineServices, "CLineServices::KernHeightToGlyph");

#if DBG==1
void CLineServices::InitTimeSanityCheck()
{
    //
    // First verify we're looking at the right version of msls.
    //

    static BOOL fCheckedVersion = FALSE;

    if (!fCheckedVersion)
    {
        BOOL fAOK = FALSE;
        HMODULE hmoduleMSLS;
#ifdef DLOAD1
        hmoduleMSLS = GetModuleHandleA("msls31"); // note - no need to free
#else        
        extern DYNLIB g_dynlibMSLS;
        hmoduleMSLS = g_dynlibMSLS.hinst;
#endif

        AssertSz( hmoduleMSLS, "Line Services (msls31.dll) was not loaded.  This is bad.");

        if (hmoduleMSLS)
        {
            char achPath[MAX_PATH];

            if (GetModuleFileNameA( hmoduleMSLS, achPath, sizeof(achPath) ))
            {
                DWORD dwHandle;
                DWORD dwVerInfoSize = GetFileVersionInfoSizeA(achPath, &dwHandle);

                if (dwVerInfoSize)
                {
                    void * lpBuffer = MemAlloc( Mt(LSVerCheck), dwVerInfoSize );

                    if (lpBuffer)
                    {
                        if (GetFileVersionInfoA(achPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            char * pchVersion;
                            UINT uiLen;
                                                    
                            if (VerQueryValueA(lpBuffer, "\\StringFileInfo\\040904E4\\FileVersion", (void **)&pchVersion, &uiLen) && uiLen)
                            {
                                char * pchDot = StrChrA( pchVersion, '.' );

                                if (pchDot)
                                {
                                    pchDot = StrChrA( pchDot + 1, '.' );

                                    if (pchDot)
                                    {
                                        int iVersion = atoi(pchDot + 1);

                                        fAOK = iVersion >= MSLS_MIN_VERSION && iVersion <= MSLS_MAX_VERSION;
                                    }
                                }
                            }
                        }

                        MemFree(lpBuffer);
                    }
                }
            }
        }

        fCheckedVersion = TRUE;

        AssertSz(fAOK, "MSLS31.DLL version mismatch.  You should get a new version from " MSLS_BUILD_LOCATION );
    }

    
    // lskt values should be indentical tomAlign values
    

    AssertSz( lsktLeft == tomAlignLeft &&
              lsktCenter == tomAlignCenter &&
              lsktRight == tomAlignRight &&
              lsktDecimal == tomAlignDecimal &&
              lsktChar == tomAlignChar,
              "enum values have changed!" );

    AssertSz( tomSpaces == 0 &&
              tomDots == 1 &&
              tomDashes == 2 &&
              tomLines == 3,
              "enum values have changed!" );

    // Checks for synthetic characters.
    
    AssertSz( (SYNTHTYPE_REVERSE & 1) == 0 &&
              (SYNTHTYPE_ENDREVERSE & 1) == 1,
              "synthtypes order has been broken" );

    // The breaking rules rely on this to be true.

    Assert( long(ichnkOutside) < 0 );

    // Check some basic classifications.

    Assert( !IsGlyphableChar(WCH_NBSP) &&
            !IsGlyphableChar(TEXT('\r')) &&
            !IsGlyphableChar(TEXT('\n')) &&
            !IsRTLChar(WCH_NBSP) &&
            !IsRTLChar(TEXT('\r')) &&
            !IsRTLChar(TEXT('\n')) );

    // Check the range for justification (uses table lookup)
    // Don't add to this list unless you have also updated
    // s_ablskjustMap[].
    AssertSz(    0 == styleTextJustifyNotSet
              && 1 == styleTextJustifyInterWord
              && 2 == styleTextJustifyNewspaper
              && 3 == styleTextJustifyDistribute
              && 4 == styleTextJustifyDistributeAllLines
              && 5 == styleTextJustifyInterIdeograph
              && 6 == styleTextJustifyInterCluster
              && 7 == styleTextJustifyKashida
              && 8 == styleTextJustifyAuto,
              "CSS text-justify values have changed.");
    //
    // Test alternate font functionality.
    //

    {
        const WCHAR * pchMSGothic;

        pchMSGothic = AlternateFontName( L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF" );

        Assert( pchMSGothic && StrCmpC( L"MS Gothic", pchMSGothic ) == 0 );
        
        pchMSGothic = AlternateFontName( L"ms GOthic" );

        Assert( pchMSGothic && StrCmpC( L"\xFF2D\xFF33\x0020\x30B4\x30B7\x30C3\x30AF", pchMSGothic ) == 0 );
    }
}
#endif

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::SetRenderer
//
// Synopsis:    Sets up the line services object to indicate that we will be
//              using for rendering.
//
//+----------------------------------------------------------------------------
void
CLineServices::SetRenderer(CLSRenderer *pRenderer, BOOL fWrapLongLines, CTreeNode * pNodeLi)
{
    _pMeasurer = pRenderer;
    _pNodeLi   = pNodeLi;
    _lsMode    = LSMODE_RENDERER;
    _fWrapLongLines = fWrapLongLines;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::SetMeasurer
//
// Synopsis:    Sets up the line services object to indicate that we will be
//              using for measuring / hittesting.
//
//+----------------------------------------------------------------------------
void
CLineServices::SetMeasurer(CLSMeasurer *pMeasurer, LSMODE lsMode, BOOL fWrapLongLines)
{
    _pMeasurer = pMeasurer;
    Assert(lsMode != LSMODE_NONE && lsMode != LSMODE_RENDERER);
    _lsMode    = lsMode;
    _fWrapLongLines = fWrapLongLines;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::GetRenderer
//
//+----------------------------------------------------------------------------
CLSRenderer *
CLineServices::GetRenderer()
{
    return (_pMeasurer && _lsMode == LSMODE_RENDERER) ?
            DYNCAST(CLSRenderer, _pMeasurer) : NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      CLineServices::GetMeasurer
//
//+----------------------------------------------------------------------------
CLSMeasurer *
CLineServices::GetMeasurer()
{
    return (_pMeasurer && _lsMode == LSMODE_MEASURER) ? _pMeasurer : NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::PAPFromPF
//
//  Synopsis:   Construct a PAP from PF
//
//-----------------------------------------------------------------------------

static const BYTE s_ablskjustMap[] =
{
    lskjFullInterWord,          // NotSet (default)
    lskjFullInterWord,          // InterWord
    lskjFullInterLetterAligned, // Newspaper
    lskjFullInterLetterAligned, // Distribute
    lskjFullInterLetterAligned, // DistributeAllLines
    lskjFullScaled,             // InterIdeograph
    lskjFullInterLetterAligned, // InterCluster
    lskjFullInterLetterAligned, // Kashida
    lskjFullInterWord           // Auto (?)
};

void
CLineServices::PAPFromPF(PLSPAP pap, const CParaFormat *pPF, BOOL fInnerPF, CComplexRun *pcr)
{
    _fExpectCRLF = pPF->HasPre(fInnerPF) || _fIsTextLess;
    const BOOL fJustified = pPF->GetBlockAlign(fInnerPF) == htmlBlockAlignJustify
                            && !pPF->HasInclEOLWhite(fInnerPF)
                            && !_fMinMaxPass;
        
    // line services format flags (lsffi.h)

    pap->grpf =   fFmiApplyBreakingRules     // Use our breaking tables
                | fFmiSpacesInfluenceHeight; // Whitespace contributes to extent

    if (_fWrapLongLines)
        pap->grpf |= fFmiWrapAllSpaces;
    else
        pap->grpf |= fFmiForceBreakAsNext;   // No emergency breaks

#if DBG==1
    // To test possible bugs with overriding emergency breaks in LS, we
    // provide an option here to turn it off.  Degenerate lines will break
    // at the wrapping width (default LS behavior.)

    if (IsTagEnabled(tagLSAllowEmergenyBreaks))
    {
        pap->grpf &= ~fFmiForceBreakAsNext;
    }
#endif // DBG

    pap->uaLeft = 0;
    pap->uaRightBreak = 0;
    pap->uaRightJustify = 0;
    pap->duaIndent = 0;
    pap->duaHyphenationZone = 0;
 
    // Justification type
    pap->lsbrj = lsbrjBreakJustify;

    // Justification
    if (fJustified)
    {
        _li._fJustified = JUSTIFY_FULL;
        
        // A. If we are a complex script or have a complex script style,
        //    set lskj to do glyphing
        // NOTE: (paulnel) if you ever do something other than check pcr != NULL,
        //       you will need to make sure we have a good pcr. See FetchPap
        if(   pcr != NULL 
           || _li._fRTLLn
           || pPF->_uTextJustify == styleTextJustifyInterCluster)
        {
            pap->lskj = lskjFullGlyphs;
            // no compress for glyph based stuff
            pap->lsbrj = lsbrjBreakThenExpand;
            // make sure that we don't get microspacing with connected text
            pap->grpf &= ~(fFmiPresExactSync | fFmiPresSuppressWiggle | fFmiHangingPunct);


            if(!pPF->_cuvTextKashida.IsNull())
            {
                Assert(_xWidthMaxAvail > 0);

                // set the amount of the right break
                long xKashidaPercent = pPF->_cuvTextKashida.GetPercentValue(CUnitValue::DIRECTION_CX, _xWidthMaxAvail);
                _xWrappingWidth = _xWidthMaxAvail - xKashidaPercent;
                
                // we need to set this amount as twips
                Assert(_pci);
                pap->uaRightBreak = _pci->TwipsFromDeviceX(xKashidaPercent);

                Assert(_xWrappingWidth >= 0);
            }
        }
        else
        {
            pap->lskj = LSKJUST(s_ablskjustMap[ pPF->_uTextJustify ]);
#if 0            
            if (   pap->lskj == lskjFullInterLetterAligned
                || pap->lskj == lskjFullScaled
               )
            {
                pap->lsbrj = lsbrjBreakWithCompJustify;
            }
#endif
            
        }
        _fExpansionOrCompression = pPF->_uTextJustify > styleTextJustifyInterWord;

        // Clear justification if we have a 'strict' or 'fixed' character grid
        if (    styleLayoutGridTypeFixed == pPF->GetLayoutGridType(fInnerPF)
            ||  styleLayoutGridTypeStrict == pPF->GetLayoutGridType(fInnerPF))
            pap->lskj = lskjNone;
    }
    else
    {
        _fExpansionOrCompression = FALSE;
        pap->lskj = lskjNone;
    }

    // Alignment

    pap->lskal = lskalLeft;

    // Autonumbering

    pap->duaAutoDecimalTab = 0;

    // kind of paragraph ending

    pap->lskeop = _fExpectCRLF ? lskeopEndPara1 : lskeopEndParaAlt;

    // Main text flow direction

    Assert(pPF->HasRTL(fInnerPF) == (BOOL) _li._fRTLLn);
    if (!_li._fRTLLn)
    {
        pap->lstflow = lstflowES;
    }
    else
    {
        if (_pBidiLine == NULL)
        {
            _pBidiLine = new CBidiLine(_treeInfo, _cpStart, _li._fRTLLn, _pli);
        }
#if DBG==1
        else
        {
            Assert(_pBidiLine->IsEqual(_treeInfo, _cpStart, _li._fRTLLn, _pli));
        }
#endif
        pap->lstflow = lstflowWS;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::CHPFromCF
//
//  Synopsis:   Construct a CHP from CF
//
//-----------------------------------------------------------------------------
void
CLineServices::CHPFromCF(
    COneRun * por,
    const CCharFormat * pCF )
{
    PLSCHP pchp = &por->_lsCharProps;

    // The structure has already been zero'd out in fetch run, which sets almost
    // everything we care about to the correct value (0).

    if (pCF->_fTextAutospace)
    {
        _lineFlags.AddLineFlag(por->Cp(), FLAG_HAS_NOBLAST);

        if (pCF->_fTextAutospace & TEXTAUTOSPACE_ALPHA)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingAlpha;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_NUMERIC)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingDigit;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_SPACE)
        {
            pchp->fModWidthSpace = TRUE;
            por->_csco |= cscoAutospacingAlpha;
        }
        if (pCF->_fTextAutospace & TEXTAUTOSPACE_PARENTHESIS)
        {
            pchp->fModWidthOnRun = TRUE;
            por->_csco |= cscoAutospacingParen;
        }
    }

    if (_fExpansionOrCompression)
    {
        pchp->fCompressOnRun = TRUE;
        pchp->fCompressSpace = TRUE; 
        pchp->fCompressTable = TRUE;
        pchp->fExpandOnRun = 0 == (pCF->_bPitchAndFamily & FF_SCRIPT);
        pchp->fExpandSpace = TRUE;
        pchp->fExpandTable = TRUE;
    }

    pchp->idObj = LSOBJID_TEXT;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::SetPOLS
//
//  Synopsis:   We call this function when we assign a CLineServices
//              to a CLSMeasurer.
//
//-----------------------------------------------------------------------------
void
CLineServices::SetPOLS(CLSMeasurer * plsm, CTreePos * ptpContentEnd)
{

    _pFlowLayout = plsm->_pFlowLayout;
    _fIsEditable = !plsm->_fBrowseMode;

    CElement * pElementOwner = _pFlowLayout->ElementOwner();

    _fIsTextLess = pElementOwner->HasFlag(TAGDESC_TEXTLESS);
    _fIsTD = pElementOwner->Tag() == ETAG_TD;
    _pMarkup = _pFlowLayout->GetContentMarkup();
    _fHasSites = FALSE;
    _pci = plsm->_pci;
    _plsline = NULL;
    _chPassword = _pFlowLayout->GetPasswordCh();

    //
    // We have special wrapping rules inside TDs with width specified.
    // Make note so the ILS breaking routines can break correctly.
    //
    
    _xTDWidth = MAX_MEASURE_WIDTH;
    if (_fIsTD)
    {
        const LONG iUserWidth = DYNCAST(CTableCellLayout, _pFlowLayout)->GetSpecifiedPixelWidth(_pci, 
            _pFlowLayout->GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow());

        if (iUserWidth)
        {
            _xTDWidth = iUserWidth;
        }
    }

    ClearLinePropertyFlags();
    
    _treeInfo._cpLayoutFirst = plsm->_cp;
    _treeInfo._cpLayoutLast  = plsm->_cpEnd;
    _treeInfo._ptpLayoutLast = ptpContentEnd;
    _treeInfo._tpFrontier.BindToCp(0);
    
    InitChunkInfo(_treeInfo._cpLayoutFirst);

    _pPFFirst = NULL;
    WHEN_DBG( _cpStart = -1 );
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::ClearPOLS
//
//  Synopsis:   We call this function when we have finished using the measurer.
//
//-----------------------------------------------------------------------------
void
CLineServices::ClearPOLS()
{
    // This assert will fire if we are leaking lsline's.  This happens
    // if somebody calls LSDoCreateLine without ever calling DiscardLine.
    Assert(_plsline == NULL);
    _pMarginInfo = NULL;
    if (_plcFirstChunk)
        DeleteChunks();
    DiscardOneRuns();

    ClearFontCaches();
}

void
CLineServices::ClearFontCaches()
{
    if (_ccsCache.GetBaseCcs())
    {
        _ccsCache.Release();
//        Assert(_pCFCache);
        _pCFCache = NULL;
    }
    if (_ccsAltCache.GetBaseCcs())
    {
        _ccsAltCache.Release();
//        Assert(_pCFAltCache);
        _pCFAltCache = NULL;
        _bCrcFontAltCache = 0;
    }
}

static CCharFormat s_cfBullet;

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetCFSymbol
//
//  Synopsis:   Get the a CF for the symbol passed in and put it in the COneRun.
//
//-----------------------------------------------------------------------------
void
CLineServices::GetCFSymbol(COneRun *por, TCHAR chSymbol, const CCharFormat *pcfIn)
{
    static BOOL s_fBullet = FALSE;

    CCharFormat *pcfOut = por->GetOtherCF();

    Assert(pcfIn && pcfOut);
    if (pcfIn == NULL || pcfOut == NULL)
        goto Cleanup;

    if (!s_fBullet)
    {
        // N.B. (johnv) For some reason, Win95 does not render the Windings font properly
        //  for certain characters at less than 7 points.  Do not go below that size!
        s_cfBullet.SetHeightInTwips( TWIPS_FROM_POINTS ( 7 ) );
        s_cfBullet._bCharSet = SYMBOL_CHARSET;
        s_cfBullet._fNarrow = FALSE;
        s_cfBullet._bPitchAndFamily = (BYTE) FF_DONTCARE;
        s_cfBullet.SetFaceNameAtom(fc().GetAtomWingdings());
        s_cfBullet._bCrcFont = s_cfBullet.ComputeFontCrc();

        s_fBullet = TRUE;
    }

    // Use bullet char format
    *pcfOut = s_cfBullet;

    pcfOut->_ccvTextColor = pcfIn->_ccvTextColor;

    // Important - CM_SYMBOL is a special mode where out WC chars are actually
    // zero-extended MB chars.  This allows us to have a codepage-independent
    // call to ExTextOutA. (cthrash)
    por->SetConvertMode(CM_SYMBOL);

Cleanup:
    return;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetCFNumber
//
//  Synopsis:   Get the a CF for the number passed in and put it in the COneRun.
//
//-----------------------------------------------------------------------------
void
CLineServices::GetCFNumber(COneRun *por, const CCharFormat * pcfIn)
{
    CCharFormat *pcfOut = por->GetOtherCF();
    *pcfOut = *pcfIn;
    pcfOut->_fSubscript = pcfOut->_fSuperscript = FALSE;
    pcfOut->_bCrcFont   = pcfOut->ComputeFontCrc();
}

LONG
CLineServices::GetDirLevel(LSCP lscp)
{
    LONG nLevel;
    COneRun *pHead;

    nLevel = _li._fRTLLn;
    for (pHead = _listCurrent._pHead; pHead; pHead = pHead->_pNext)
    {
        if (lscp >= pHead->_lscpBase)
        {
            if (pHead->IsSyntheticRun())
            {
                SYNTHTYPE synthtype = pHead->_synthType;
                // Since SYNTHTYPE_REVERSE preceeds SYNTHTYPE_ENDREVERSE and only
                // differs in the last bit, we can compute nLevel with bit magic. We
                // have to be sure this condition really exists of course, so we
                // Assert() it above.
                if (IN_RANGE(SYNTHTYPE_DIRECTION_FIRST, synthtype, SYNTHTYPE_DIRECTION_LAST))
                {
                    nLevel -= (((synthtype & 1) << 1) - 1);
                }
            }
        }
        else
            break;
    }

    return nLevel;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineFlags::AddLineFlag
//
//  Synopsis:   Set flags for a given cp.
//
//-----------------------------------------------------------------------------

LSERR
CLineFlags::AddLineFlag(LONG cp, DWORD dwlf)
{
    int c = _aryLineFlags.Size();

    if (!c || cp >= _aryLineFlags[c-1]._cp)
    {
        CFlagEntry fe(cp, dwlf);

        return S_OK == _aryLineFlags.AppendIndirect(&fe)
                ? lserrNone
                : lserrOutOfMemory;
    }
    return lserrNone;
}

LSERR
CLineFlags::AddLineFlagForce(LONG cp, DWORD dwlf)
{
    CFlagEntry fe(cp, dwlf);

    _fForced = TRUE;
    return S_OK == _aryLineFlags.AppendIndirect(&fe)
            ? lserrNone
            : lserrOutOfMemory;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetLineFlags
//
//  Synopsis:   Given a cp, it computes all the flags which have been turned
//              on till that cp.
//
//-----------------------------------------------------------------------------

DWORD
CLineFlags::GetLineFlags(LONG cpMax)
{
    DWORD dwlf;
    LONG i;
    
    dwlf = FLAG_NONE;
    
    for (i = 0; i < _aryLineFlags.Size(); i++)
    {
        if (_aryLineFlags[i]._cp >= cpMax)
        {
            if (_fForced)
                continue;
            else
                break;
        }
        else
            dwlf |= _aryLineFlags[i]._dwlf;
    }

#if DBG==1
    if (!_fForced)
    {
        //
        // This verifies that LS does indeed ask for runs in a monotonically
        // increasing manner as far as cp's are concerned
        //
        for (; i < _aryLineFlags.Size(); i++)
        {
            Assert(_aryLineFlags[i]._cp >= cpMax);
        }
    }
#endif

    return dwlf;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::AddLineCount
//
//  Synopsis:   Adds a particular line count at a given cp. It also checks if the
//              count has already been added at that cp. This is needed to solve
//              2 problems with maintaining line counts:
//              1) A run can be fetched multiple times. In this case we want to
//                 increment the counts just once.
//              2) LS can over fetch runs, in which case we want to disregard
//                 the counts of those runs which did not end up on the line.
//
//-----------------------------------------------------------------------------
LSERR
CLineCounts::AddLineCount(LONG cp, LC_TYPE lcType, LONG count)
{
    CLineCount lc(cp, lcType, count);
    int i = _aryLineCounts.Size();

    while (i--)
    {
        if (_aryLineCounts[i]._cp != cp)
            break;

        if (_aryLineCounts[i]._lcType == lcType)
            return lserrNone;
    }
    
    return S_OK == _aryLineCounts.AppendIndirect(&lc)
            ? lserrNone
            : lserrOutOfMemory;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetLineCount
//
//  Synopsis:   Finds a particular line count at a given cp.
//
//-----------------------------------------------------------------------------
LONG
CLineCounts::GetLineCount(LONG cp, LC_TYPE lcType)
{
    LONG count = 0;

    for (LONG i = 0; i < _aryLineCounts.Size(); i++)
    {
        if (   _aryLineCounts[i]._lcType == lcType
            && _aryLineCounts[i]._cp < cp
           )
        {
            count += _aryLineCounts[i]._count;
        }
    }
    return count;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::GetMaxLineValue
//
//  Synopsis:   Finds a particular line value uptil a given cp.
//
//-----------------------------------------------------------------------------
LONG
CLineCounts::GetMaxLineValue(LONG cp, LC_TYPE lcType)
{
    LONG value = LONG_MIN;

    for (LONG i = 0; i < _aryLineCounts.Size(); i++)
    {
        if (   _aryLineCounts[i]._lcType == lcType
            && _aryLineCounts[i]._cp < cp
           )
        {
            value = max(value, _aryLineCounts[i]._count);
        }
    }
    return value;
}

#define MIN_FOR_LS 1

HRESULT
CLineServices::Setup(
    LONG xWidthMaxAvail,
    LONG cp,
    CTreePos *ptp,
    const CMarginInfo *pMarginInfo,
    const CLineFull * pli,
    BOOL fMinMaxPass )
{
    const CParaFormat *pPF;
    BOOL fWrapLongLines = _fWrapLongLines;
    HRESULT hr = S_OK;
    
    Assert(_pMeasurer);

    if (!_treeInfo._fInited || cp != long(_pMeasurer->GetCp()))
    {
        DiscardOneRuns();
        hr = THR(_treeInfo.InitializeTreeInfo(_pFlowLayout, _fIsEditable, cp, ptp));
        if (hr != S_OK)
            goto Cleanup;
    }

    _lineFlags.InitLineFlags();
    _cpStart     = _cpAccountedTill = cp;
    _pMarginInfo = pMarginInfo;
    _cWhiteAtBOL = 0;
    _cAlignedSitesAtBOL = 0;
    _cAbsoluteSites = 0;
    _cAlignedSites = 0;
    _pNodeForAfterSpace = NULL;
    _fHasVerticalAlign = FALSE;
    _fNeedRecreateLine = FALSE;

    if (_lsMode == LSMODE_MEASURER)
    {
        _pli = NULL;
    } 
    else
    {
        Assert(_lsMode == LSMODE_HITTEST || _lsMode == LSMODE_RENDERER);
        _pli = pli;
        _li._fLookaheadForGlyphing = (_pli ? _pli->_fLookaheadForGlyphing : FALSE);
    }
    
    ClearLinePropertyFlags(); // zero out all flags
    _fWrapLongLines = fWrapLongLines; // preserve this flag when we 0 _dwProps
    
    // We're getting max, so start really small.
    _lMaxLineHeight = LONG_MIN;
    _fFoundLineHeight = FALSE;

    _xWrappingWidth = -1;

    pPF = _treeInfo._pPF;
    _fInnerPFFirst = _treeInfo._fInnerPF;

    // TODO (a-pauln, track bug IE6 1740) some elements are getting assigned a PF from the
    //        wrong branch in InitializeTreeInfo() above. This hack is a
    //        temporary correction of the problem's manifestation until
    //        we determine how to correct it.
    if(!_treeInfo._fHasNestedElement || !ptp)
        _li._fRTLLn = pPF->HasRTL(_fInnerPFFirst);
    else
    {
        pPF = ptp->Branch()->GetParaFormat(LC_TO_FC(_pFlowLayout->LayoutContext()));
        _li._fRTLLn = pPF->HasRTL(_fInnerPFFirst);
    }

    if (    !_pMeasurer->_pdp->GetWordWrap()
        ||  (pPF && pPF->HasPre(_fInnerPFFirst) && !_fWrapLongLines))
    {
        //
        // If we are in min-max mode inside a table cell and the table cell has a specified
        // width and we have the word-wrap property, then we should measure at the
        // _xTDWidth so that we correctly report the max width.
        //
        if (   fMinMaxPass
            && _fIsTD
            && _xTDWidth != MAX_MEASURE_WIDTH
            && _pMeasurer->_fBreaklinesFromStyle
           )
        {
            xWidthMaxAvail = _xTDWidth;
        }
        else
        {
            _xWrappingWidth = xWidthMaxAvail;
            xWidthMaxAvail = MAX_MEASURE_WIDTH;
        }
    }
    else if (xWidthMaxAvail <= MIN_FOR_LS)
    {
        //TODO (SujalP, track bug 4358): Remove hack when LS gets their in-efficient calc bug fixed.
        xWidthMaxAvail = 0;
    }
    
    _xWidthMaxAvail = xWidthMaxAvail;
    if (_xWrappingWidth == -1)
        _xWrappingWidth = _xWidthMaxAvail;

    _fMinMaxPass = fMinMaxPass;
    _pPFFirst = pPF;
    DeleteChunks();
    InitChunkInfo(cp - (_pMeasurer->_fMeasureFromTheStart ? 0 : _pMeasurer->_cchPreChars));

    // Reset layout grid related stuff
    _lCharGridSizeInner = 0;
    _lCharGridSize = 0;
    _lLineGridSizeInner = 0;
    _lLineGridSize = 0;
    _cLayoutGridObj = 0;
    _cLayoutGridObjArtificial = 0;

Cleanup:
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::GetMinDurBreaks (member)
//
//  Synopsis:   Determine the minimum width of the line.  Also compute any
//              adjustments to the maximum width of the line.
//
//-----------------------------------------------------------------------------

LSERR
CLineServices::GetMinDurBreaks( 
    LONG * pdvMin,
    LONG * pdvMaxDelta )
{
    LSERR lserr;

    Assert(_plsline);
    Assert(_fMinMaxPass);
    Assert(pdvMin);
    Assert(pdvMaxDelta);

    //
    // First we call LsGetMinDurBreaks.  This call does the right thing only
    // for text runs, not ILS objects.
    //

    if (!_fScanForCR)
    {
        LONG  dvDummy;
        
        lserr = LsGetMinDurBreaks( GetContext(), _plsline, &dvDummy, pdvMin );
        if (lserr)
            goto Cleanup;
    }
    
    //
    // Now we need to go and compute the true max width.  The current max
    // width is incorrect by the difference in the min and max widths of
    // dobjs for which these values are not the same (e.g. tables).  We've
    // cached the difference in the dobj's, so we need to enumerate these
    // and add them up.  The enumeration callback adjusts the value in
    // CLineServices::dvMaxDelta;
    //

    _dvMaxDelta = 0;

    lserr = LsEnumLine( _plsline,
                        FALSE,        // fReverseOrder
                        FALSE,        // fGeometryNeeded
                        &g_Zero.pt ); // pptOrg

    *pdvMaxDelta = _dvMaxDelta;
    
    if (_fScanForCR)
    {
        *pdvMin = _li._xWidth + _dvMaxDelta;
    }

Cleanup:
    return lserr;
}

void COneRun::Deinit()
{
    if (   _fMustDeletePcf
        && _pCF
       )
    {
        Assert(_pCF != _pCFOriginal);
        delete _pCF;
    }
    _pCF = NULL;
#if DBG == 1
    _pCFOriginal = NULL;
#endif

    _bConvertMode = CM_UNINITED;
    
    if (_pComplexRun)
    {
        delete _pComplexRun;
        _pComplexRun = NULL;
    }

    _cstrRunChars.Free();

    // Finally, clear out all the flags
    _dwProps = 0;
}


#ifdef FASTER_GAOR

//
// This is for the presently unused tweaked GetAvailableOneRuns
//

// Like ReSetup, but just scoots along from where it is.
void 
COneRun::RelativeSetup(CTreePosList *ptpl, 
                       CElement *pelRestricting, 
                       LONG cp, 
                       CFlowLayout *pRunOwner, 
                       BOOL fRight)
{
    Deinit();

    // The cp-threshhold number here is a performance-tuned number.  Any number will work.
    // (It will never do the wrong thing, it just might take a while to do it.)
    // It represents the largest cp-distance that can be covered with Advance that will
    // take the same amount of time as setting one up from scratch.
    if( ptpl != _ptpl || (abs(cp - Cp()) > 100) )
        super::ReSetUp(ptpl,pelRestricting,cp,pRunOwner,fRight);
    {
#if DBG == 1
        COneRun orDebug(this);
        orDebug.ReSetUp(ptpl,pelRestricting,cp,pRunOwner,fRight);
#endif // DBG == 1
        SetRestrictingElement(pelRestricting);
        Advance( cp - Cp() );
        Assert( !memcmp( this, &orDebug, sizeof(this) ) );
    }
}

#endif // FASTER_GAOR

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices destructor
//
//  Synopsis:   Free the COneRun cache
//
//-----------------------------------------------------------------------------

CLineServices::~CLineServices()
{
    _ccsCache.Release();
    _ccsAltCache.Release();
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::DiscardLine (member)
//
//  Synopsis:   The lifetime of a CLineServices object is that of it's
//              containing CDoc.  This function is used to clear state
//              after each use of the object, as opposed to the destructor.
//              This function needs to be called after each measured/rendered
//              line (~CLine.)
//
//-----------------------------------------------------------------------------

void
CLineServices::DiscardLine()
{
    WHEN_DBG( static int nCall = 0 );
    
    TraceTag((tagLSTraceLines,
              "CLineServices::DiscardLine[%d] sn=%d null=%s ",
              nCall++, _nSerial, _plsline ? "true" : "false"));

    if (_plsline)
    {
        LsDestroyLine( _plsc, _plsline );
        _lineFlags.DeleteAll();
        _lineCounts.DeleteAll();
        _plsline = NULL;
    }


    _mbpTopCurrent = _mbpBottomCurrent = 0;
    
    // For now just do this simple thing here. Eventually we will do more
    // complex things like holding onto tree state.
    _treeInfo._fInited = FALSE;

    if (_pBidiLine != NULL)
    {
        delete _pBidiLine;
        _pBidiLine = NULL;
    }

    _aryRubyInfo.DeleteAll();
}


//+----------------------------------------------------------------------------
//
// Member:      InitChunkInfo
//
// Synopsis:    Initializest the chunk info store.
//
//-----------------------------------------------------------------------------
void
CLineServices::InitChunkInfo(LONG cp)
{
    _cpLastChunk = cp;
    _xPosLastChunk = 0;
    _plcFirstChunk = _plcLastChunk = NULL;
    _pElementLastRelative = NULL;
    _fLastChunkSingleSite = FALSE;

    // Note: It would be more precise to initialize _fLastChunkRTL from the line flag,
    // but the line is not available yet. It is OK to make a guess from layout - 
    // if the guess is wrong, and the line is in different direction, it will just 
    // cause an empty chunk in the beginning of a line with relative text.
    _fLastChunkRTL = _pFlowLayout ? _pFlowLayout->IsRTLFlowLayout() : FALSE;
}

//+----------------------------------------------------------------------------
//
// Member:      DeleteChunks
//
// Synopsis:    Delete chunk related information in the line
//
//-----------------------------------------------------------------------------
void
CLineServices::DeleteChunks()
{
    while(_plcFirstChunk)
    {
        CLSLineChunk * plc = _plcFirstChunk;

        _plcFirstChunk = _plcFirstChunk->_plcNext;
        delete plc;
    }
    _plcLastChunk = NULL;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryLinePointPcp (member)
//
//  Synopsis:   Wrapper for LsQueryLinePointPcp
//
//  Returns:    S_OK    - Success
//              S_FALSE - depth was zero
//              E_FAIL  - error
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::QueryLinePointPcp(
    LONG u,                     // IN
    LONG v,                     // IN
    LSTFLOW *pktFlow,           // OUT
    PLSTEXTCELL plstextcell)    // OUT
{
    POINTUV uvPoint;
    CStackDataAry < LSQSUBINFO, 4 > aryLsqsubinfo( Mt(QueryLinePointPcp_aryLsqsubinfo_pv) );
    HRESULT hr;
    DWORD nDepthIn = 4;

    uvPoint.u = u;
    uvPoint.v = v;

    Assert(_plsline);

    #define NDEPTH_MAX 32

    for (;;)
    {
        DWORD nDepth;
        LSERR lserr = LsQueryLinePointPcp( _plsline,
                                           &uvPoint,
                                           nDepthIn,
                                           aryLsqsubinfo,
                                           &nDepth,
                                           plstextcell);

        if (lserr == lserrNone)
        {
            hr = S_OK;
            // get the flow direction for proper x+/- manipulation
            if(nDepth > 0)
            {
                if (   aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_TEXT
                    && aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_GLYPH
                    && aryLsqsubinfo[nDepth - 1].idobj != LSOBJID_EMBEDDED
                   )
                {
                    LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth-1];
                    plstextcell->dupCell = qsubinfo.dupObj;
                    plstextcell->pointUvStartCell = qsubinfo.pointUvStartSubline;
                    plstextcell->cCharsInCell = 0;
                    plstextcell->cpStartCell = qsubinfo.cpFirstSubline;
                    plstextcell->cpEndCell = qsubinfo.cpFirstSubline + qsubinfo.dcpSubline;
                }
                else
                    plstextcell->cCharsInCell = plstextcell->cpEndCell - plstextcell->cpStartCell + 1;
                *pktFlow = aryLsqsubinfo[nDepth - 1].lstflowSubline;

            }
            else if (nDepth == 0)
            {
                // HACK ALERT(MikeJoch):
                // See hack alert by SujalP below. We can run into this case
                // when the line is terminated by a [section break] type
                // character. We should take it upon ourselves to fill in
                // plstextcell and pktFlow when this happens.
                LONG duIgnore;

                plstextcell->cpStartCell = _lscpLim - 1;
                plstextcell->cpEndCell = _lscpLim;
                plstextcell->dupCell = 0;
                plstextcell->cCharsInCell = 1;

                hr = THR(GetLineWidth( &plstextcell->pointUvStartCell.u, &duIgnore) );

                // If we don't have a level, assume that the flow is in the line direction.
                if (pktFlow)
                {
                    *pktFlow = _li._fRTLLn ? fUDirection : 0;
                }

            }
            else
            {
                hr = E_FAIL;
            }
            break;
        }
        else if (lserr == lserrInsufficientQueryDepth ) 
        {
            if (nDepthIn > NDEPTH_MAX)
            {
                hr = E_FAIL;
                break;
            }
            
            nDepthIn *= 2;
            Assert( nDepthIn <= NDEPTH_MAX );  // That would be rediculous

            hr = THR(aryLsqsubinfo.Grow(nDepthIn));
            if (hr)
                break;

            // Loop back.
        }
        else
        {
            hr = E_FAIL;
            break;
        }
    }

    RRETURN1(hr, S_FALSE);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryLineCpPpoint (member)
//
//  Synopsis:   Wrapper for LsQueryLineCpPpoint
//
//  Returns:    S_OK    - Success
//              S_FALSE - depth was zero
//              E_FAIL  - error
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::QueryLineCpPpoint(
    LSCP lscp,                              // IN
    BOOL fFromGetLineWidth,                 // IN
    CDataAry<LSQSUBINFO> * paryLsqsubinfo,  // IN/OUT
    PLSTEXTCELL plstextcell,                // OUT
    BOOL *pfRTLFlow)                        // OUT
{
    CStackDataAry < LSQSUBINFO, 4 > aryLsqsubinfo( Mt(QueryLineCpPpoint_aryLsqsubinfo_pv) );
    HRESULT hr;
    DWORD nDepthIn;
    LSTFLOW ktFlow;
    DWORD nDepth;

    Assert(_plsline);

    if (paryLsqsubinfo == NULL)
    {
        aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.
        paryLsqsubinfo = &aryLsqsubinfo;
    }
    nDepthIn = paryLsqsubinfo->Size();

    #define NDEPTH_MAX 32

    for (;;)
    {
        LSERR lserr = LsQueryLineCpPpoint( _plsline,
                                           lscp,
                                           nDepthIn,
                                           *paryLsqsubinfo,
                                           &nDepth,
                                           plstextcell);

        if (lserr == lserrNone)
        {
            // HACK ALERT(SujalP):
            // Consider the case where the line contains just 3 characters:
            // A[space][blockbreak] at cp 0, 1 and 2 respectively. If we query
            // LS at cp 2, if would expect lsTextCell to point to the zero
            // width cell containing [blockbreak], meaning that
            // lsTextCell.pointUvStartCell.u would be the width of the line
            // (including whitespaces). However, upon being queried at cp=2
            // LS returns a nDepth of ***0*** because it thinks this is some
            // splat garbage. This problem breaks a lot of our callers, hence
            // we attemp to hack around this problem.
            // NOTE: In case LS fixes their problem, be sure that hittest.htm
            // renders all its text properly for it exhibits a problem because
            // of this problem.
            // ORIGINAL CODE: hr = nDepth ? S_OK : S_FALSE;
            if (nDepth == 0)
            {
                LONG duIgnore;
                
                if (!fFromGetLineWidth && lscp >= _lscpLim - 1)
                {
                    plstextcell->cpStartCell = _lscpLim - 1;
                    plstextcell->cpEndCell = _lscpLim;
                    plstextcell->dupCell = 0;

                    hr = THR(GetLineWidth( &plstextcell->pointUvStartCell.u, &duIgnore) );

                }
                else
                    hr = S_FALSE;

                // If we don't have a level, assume that the flow is in the line direction.
                if(pfRTLFlow)
                    *pfRTLFlow = _li._fRTLLn;

            }
            else
            {
                hr = S_OK;
                LSQSUBINFO &qsubinfo = (*paryLsqsubinfo)[nDepth-1];

                if (   qsubinfo.idobj != LSOBJID_TEXT
                    && qsubinfo.idobj != LSOBJID_GLYPH
                    && qsubinfo.idobj != LSOBJID_EMBEDDED
                   )
                {
                    plstextcell->dupCell = qsubinfo.dupObj;
                    plstextcell->pointUvStartCell = qsubinfo.pointUvStartObj;
                    plstextcell->cCharsInCell = 0;
                    plstextcell->cpStartCell = qsubinfo.cpFirstSubline;
                    plstextcell->cpEndCell = qsubinfo.cpFirstSubline + qsubinfo.dcpSubline;
                }

                // if we are going in the opposite direction of the line we
                // will need to compensate for proper xPos

                ktFlow = qsubinfo.lstflowSubline;
                if(pfRTLFlow)
                    *pfRTLFlow = (ktFlow == lstflowWS);
            }
            break;
        }
        else if (lserr == lserrInsufficientQueryDepth ) 
        {
            if (nDepthIn > NDEPTH_MAX)
            {
                hr = E_FAIL;
                break;
            }
            
            nDepthIn *= 2;
            Assert( nDepthIn <= NDEPTH_MAX );  // That would be ridiculous

            hr = THR(paryLsqsubinfo->Grow(nDepthIn));
            if (hr)
                break;

            // Loop back.
        }
        else
        {
            hr = E_FAIL;
            break;
        }
    }

    if (hr == S_OK)
    {
        Assert((LONG) nDepth <= paryLsqsubinfo->Size());
        paryLsqsubinfo->SetSize(nDepth);
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CLineServices::GetLineWidth(LONG *pdurWithTrailing, LONG *pdurWithoutTrailing)
{
    LSERR lserr;
    LONG  duIgnore;
    
    lserr = LsQueryLineDup( _plsline, &duIgnore, &duIgnore, &duIgnore,
                            pdurWithoutTrailing, pdurWithTrailing);
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    return HRFromLSERR(lserr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CLineServices::GetCcs
//
//  Synopsis:   Gets the suitable font (CCcs) for the given COneRun.
//
//  Returns:    CCcs
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::GetCcs(CCcs * pccs, COneRun *por, XHDC hdc, CDocInfo *pdi, BOOL fFontLink)
{
    Assert(pccs);
    
    const CCharFormat *pCF = por->GetCF();
    const BOOL fDontFontLink =    !por->_ptp
                               || !por->_ptp->IsText()
                               || _chPassword
                               || !fFontLink
                               || pCF->_bCharSet == SYMBOL_CHARSET
                               || pCF->_fDownloadedFont
                               || (pdi->_pDoc->_pWindowPrimary && _pMarkup->GetCodePage() == 50000);


    //
    // NB (cthrash) Although generally it will, CCharFormat::_latmFaceName need
    // not necessarily match CBaseCcs::_latmLFFaceName.  This is particularly true
    // when a generic CSS font-family is used (Serif, Fantasy, etc.)  We won't
    // know the actual font properties until we call CCcs::MakeFont.  For this
    // reason, we always compute the _ccsCache first, even though it's
    // possible (not likely, but possible) that we'll never use the font.
    //

           // If we have a different pCF then what _ccsCache is based on,
    if (   pCF != _pCFCache
           // *or* If we dont have a cached _ccsCache
        || !_ccsCache.GetBaseCcs()
           // *or* If we are switching from TT mode to non-TT mode, or vice versa 
        || (!!pccs->GetForceTTFont() ^ !!_ccsCache.GetForceTTFont()) 
       )
    {
        if (fc().GetCcs(pccs, hdc, pdi, pCF))
        {
            if (CM_UNINITED != por->_bConvertMode)
            {
                pccs->SetConvertMode((CONVERTMODE)por->_bConvertMode); 
            }

            _pCFCache = (!por->_fMustDeletePcf ? pCF : NULL);
            _ccsCache.Release();
            _ccsCache = *pccs;
        }
        else
        {
            AssertSz(0, "CCcs failed to be created.");
            goto Cleanup;
        }
    }

    Assert(pCF == _pCFCache || por->_fMustDeletePcf);
    *pccs = _ccsCache;
    
    if (fDontFontLink)
        goto Cleanup;
    else
    {
        BOOL fCheckAltFont;   // TRUE if _pccsCache does not have glyphs needed for sidText
        BOOL fPickNewAltFont; // TRUE if _pccsAltCache needs to be created anew
        SCRIPT_ID sidAlt = 0;
        BYTE bCharSetAlt = 0;
        SCRIPT_ID sidText;
        
        //
        // Check if the _ccsCache covers the sid of the text run
        //

        sidText = por->_sid;

        AssertSz( sidText != sidMerge, "Script IDs should have been merged." );
        AssertSz( sidText != sidAmbiguous || por->_synthType != CLineServices::SYNTHTYPE_NONE, "Script IDs should have been disambiguated." );
        Assert(     por->_lsCharProps.fGlyphBased 
                ||  (   !_pNodeLi && por->_ptp->Sid() == sidHan
                    &&  (   sidText == sidHangul          //
                        ||  sidText == sidBopomofo        // UnunifyHanScript can change sidHan to one of them,
                        ||  sidText == sidKana            // sidDefault when MLang is not loaded
                        ||  sidText == sidHan             //
                        ||  sidText == sidDefault)        //
                    )
                ||  (!_pNodeLi && por->_ptp->Sid() == sidAmbiguous)
                ||  sidText == (!_pNodeLi ? DWORD(por->_ptp->Sid()) : sidAsciiLatin));


        {
            // sidHalfWidthKana has to be treated as sidKana
            if (sidText == sidHalfWidthKana)
                sidText = sidKana;

            const CBaseCcs * pBaseCcs = _ccsCache.GetBaseCcs();
            Assert(pBaseCcs);

            if (sidText == sidDefault)
            {
                fCheckAltFont = FALSE; // Assume the author picked a font containing the glyph.  Don't fontlink.
            }
            else if (sidText == sidEUDC)
            {
                const UINT uiFamilyCodePage = _pMarkup->GetFamilyCodePage();
                SCRIPT_ID sidForPUA;

                fCheckAltFont = ShouldSwitchFontsForPUA( hdc, uiFamilyCodePage, pBaseCcs, pCF, &sidForPUA );
                if (fCheckAltFont)
                {
                    sidText = sidAlt = sidAmbiguous;
                    bCharSetAlt = DefaultCharSetFromScriptAndCodePage( sidForPUA, uiFamilyCodePage );
                }
            }
            else 
            {
                fCheckAltFont = (pBaseCcs->_sids & ScriptBit(sidText)) == sidsNotSet;
            }
        }

        if (!fCheckAltFont)
            goto Cleanup;

        //
        // Check to see if the _ccsAltCache covers the sid of the text run
        //

        if (sidText != sidAmbiguous)
        {
            SCRIPT_IDS sidsFace = fc().EnsureScriptIDsForFont(hdc, _ccsCache.GetBaseCcs(), FC_SIDS_USEMLANG);

            if (IsFESid(sidText))
            {
                // 
                // To render FE characters we need to keep current font if only possible,
                // even if it is used to render non-native characters.
                // So try to pickup the most appropriate charset, because GDI prefers 
                // charset over font face during font creation.
                // In case of FE lang id, use charset appropriate for it. This is because
                // lang id has highest priority font selection in case of FE characters.
                //
                if (pCF->_lcid)
                {
                    bCharSetAlt = CharSetFromLangId(LANGIDFROMLCID(pCF->_lcid));
                    if (!IsFECharset(bCharSetAlt))
                    {
                        bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, _pMarkup->GetFamilyCodePage());
                    }
                }
                else
                    bCharSetAlt = DefaultCharSetFromScriptsAndCodePage(sidsFace, sidText, _pMarkup->GetFamilyCodePage());
            }
            else
                bCharSetAlt = DefaultCharSetFromScriptAndCodePage(sidText, _pMarkup->GetFamilyCodePage());

            if ((sidsFace & ScriptBit(sidText)) == sidsNotSet)
            {
                sidAlt = sidText;           // current face does not cover
            }
            else
            {
                sidAlt = sidAmbiguous;      // current face does cover
            }
        }

        fPickNewAltFont =   !_ccsAltCache.GetBaseCcs()
                         || sidAlt != sidAmbiguous
                         || _pCFAltCache != pCF
                         || _bCrcFontAltCache != pCF->_bCrcFont   // pCF might be equal to _pCFAltCache even if they
                                                                  // point to different objects. It may happen when 
                                                                  // _pCFAltCache is cached in the previous line and memory
                                                                  // is deallocated, so there is a chance to reuse it
                                                                  // for another object in the next line.
                         || _ccsAltCache.GetBaseCcs()->_bCharSet != bCharSetAlt;

        //
        // Looks like we need to pick a new alternate font
        //

        if (!fPickNewAltFont)
        {
            Assert(_ccsAltCache.GetBaseCcs());
            *pccs = _ccsAltCache;
        }
        else
        {
            CCharFormat cfAlt = *pCF;

            // sidAlt of sidAmbiguous at this point implies we have the right facename,
            // but the wrong GDI charset.  Otherwise, lookup in the registry/mlang to
            // determine an appropriate font for the given script id.

            if (sidAlt != sidAmbiguous)
            {
                SelectScriptAppropriateFont( sidAlt, bCharSetAlt, pdi->_pDoc, pdi->_pMarkup, &cfAlt );
            }
            else
            {
                cfAlt._bCharSet = bCharSetAlt;
                cfAlt._bCrcFont = cfAlt.ComputeFontCrc();
            }

            if (fc().GetFontLinkCcs(pccs, hdc, pdi, &_ccsCache, &cfAlt))
            {
                // Remember the pCF from which the pccs was derived.
                _pCFAltCache = pCF;
                _bCrcFontAltCache = pCF->_bCrcFont;
                _ccsAltCache.Release();
                _ccsAltCache = *pccs;
                _ccsAltCache.MergeSIDs(ScriptBit(sidAlt));
            }
        }
    }
    
Cleanup:
    Assert(!pccs->GetBaseCcs() || pccs->GetHDC() == hdc);
    return !!pccs->GetBaseCcs();
}

//-----------------------------------------------------------------------------
//
//  Function:   LineHasNoText
//
//  Synopsis:   Utility function which returns TRUE if there is no text (only nested
//              layout or antisynth'd goop) on the line till the specified cp.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::LineHasNoText(LONG cp)
{
    LONG fRet = TRUE;
    for (COneRun *por = _listCurrent._pHead; por; por = por->_pNext)
    {
        if (por->Cp() >= cp)
            break;

        if (!por->IsNormalRun())
            continue;
        
        if (por->_lsCharProps.idObj == LSOBJID_TEXT)
        {
            fRet = FALSE;
            break;
        }
    }
    return fRet;
}

void
CLineServices::AdjustLineHeightForMBP()
{
    Assert(_fHasMBP);

    COneRun *por;
    LONG cpLast = GetMeasurer()->_cp;
    LONG ld = _yOriginalDescent;        // Line descent
    LONG la = _li._yExtent - ld;        // Line ascent
    LONG rd;                            // Run descent
    LONG ra;                            // Run ascent
    LONG da;                            // Distance from the top of extent to top of run
    LONG dd;                            // Distance from bottom of run to bottom of extent
    LONG mbpa = 0;                      // This much to increase the top of extent by
    LONG mbpd = 0;                      // This much to increase bottom of extent by
    
    por = _listCurrent._pHead;
    while(   por
          && por->Cp() < cpLast
         )
    {
        if (   por->IsNormalRun()
            && (!por->_fNoTextMetrics || por->_fCharsForNestedLayout)
           )
        {
            // If this run is included in the line, then it had better been processed.
            Assert(!por->_fNotProcessedYet);
            
            if (por->_fCharsForNestedLayout || _fHasVerticalAlign)
            {
                ra = la - por->_yProposed;
                rd = por->_yObjHeight - ra;
            }
            else
            {
                const CCharFormat * pCF;
                const CBaseCcs *pBaseCcs;
                CCcs ccs;

                Assert(por->_lsCharProps.idObj == LSOBJID_TEXT);
                pCF = por->GetCF();
                if (!GetCcs(&ccs, por, _pci->_hdc, _pci))
                {
                    goto Cleanup;
                }
                pBaseCcs = ccs.GetBaseCcs();
                rd = pBaseCcs->_yDescent;
                ra = pBaseCcs->_yHeight - rd;
            }
            
            da = la - ra;
            dd = ld - rd;

            // da is the height available to place MBPTop in. If it is insufficient
            // then we will have to increase the extent to satisfy it. Similar for
            // the bottom/descent case.
            mbpa = max(mbpa, por->_mbpTop - da);
            mbpd = max(mbpd, por->_mbpBottom - dd);
        }
        por = por->_pNext;
    }
    _li._yExtent += mbpa + mbpd;
    _li._yHeightTopOff -= mbpa;

Cleanup:    
    return;
}

DeclareTag(tagCharShape, "LineServices", "Char shape information");

void
CLineServices::KernHeightToGlyph(COneRun *por, CCcs *pccs, PLSTXM plsTxMet)
{
    LONG dvA = 0;
    LONG dvD = 0;
    GLYPHMETRICS gm = {0};  // keep compiler happy
    LONG i;
    MAT2 mat;
    DWORD retVal = 0;
    CLSMeasurer &me = *_pMeasurer;
    
    Assert(retVal != GDI_ERROR);
    
    memset(&mat, 0, sizeof(mat));
    mat.eM11.value = 1;
    mat.eM22.value = 1;
    
    FONTIDX hFontOld = pccs->PushFont(pccs->GetHDC());
    
    Assert(por->_pchBase);
    for (i = 0; i < por->_lscch; i++)
    {
        LONG yChAscent;
        LONG yChDescent;

        if (g_dwPlatformID >= VER_PLATFORM_WIN32_NT)
        {
            retVal = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[i], GGO_METRICS, &gm, 0, NULL, &mat);
        }
        else
        {
            // WIN9x does not implement the 'W' version of this function and it also cannot take
            // multibyte values. So we just hack here -- if the value is is in the lower ascii
            // range we do the kerning, else we just forget it.
            if (CanQuickBrkclsLookup(por->_pchBase[i]))
                retVal = GetGlyphOutlineA(pccs->GetHDC(), por->_pchBase[i], GGO_METRICS, &gm, 0, NULL, &mat);
            else
                retVal = GDI_ERROR;
        }

        if (GDI_ERROR == retVal)
        {
            break;
        }

        yChAscent = gm.gmptGlyphOrigin.y;
        dvA = max(dvA, yChAscent);

        yChDescent = gm.gmBlackBoxY - yChAscent;
        dvD = max(dvD, yChDescent);
    }

    me._aryFLSlab.DeleteAll();
    
#ifdef FL_TIGHTWRAP
    if (por->_lscch == 1)
    {
        LONG memAllocSize = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[0], GGO_BITMAP, &gm, 0, NULL, &mat);
        if (memAllocSize != GDI_ERROR)
        {
            BYTE *aBits = (BYTE*)MemAlloc(Mt(GetGlyphOutline), memAllocSize);
            if (aBits != NULL)
            {
                WHEN_DBG(CStr str;)
                LONG nRows = gm.gmBlackBoxY;
                LONG nCols = gm.gmBlackBoxX;
                LONG iRow, iCol, pixel;
                LONG nPixelsPerByte = 8;
                LONG rowStart = 0;

                CFLSlab flSlab;
                LONG xCurrIndent;
                
                LONG nBytesPerRow = memAllocSize / nRows;
                LONG retVal = GetGlyphOutlineW(pccs->GetHDC(), por->_pchBase[0], GGO_BITMAP, &gm, memAllocSize, aBits, &mat);

                flSlab._xWidth = LONG_MAX;
                flSlab._yHeight = 0;
                for (iRow = 0;iRow < nRows; iRow++)
                {
                    WHEN_DBG(str.Free();)
                    xCurrIndent = 0;
                    for (iCol = nCols - 1; iCol >= 0; iCol--)
                    {
                        LONG rowOffset = iCol / nPixelsPerByte;
                        LONG bitOffset = iCol % nPixelsPerByte;
                        pixel = aBits[rowStart + rowOffset] & (1 << (7 - bitOffset));
                        if (pixel)
                        {
                            WHEN_DBG(str.Append(_T("*"));)
                            break;
                        }
                        else
                        {
                            xCurrIndent++;
                            WHEN_DBG(str.Append(_T("_"));)
                        }
                    }
                    flSlab._xWidth = min(flSlab._xWidth, xCurrIndent);
                    flSlab._yHeight++;
                    if ((iRow % 2) != 0)
                    {
                        me._aryFLSlab.AppendIndirect(&flSlab);
                        flSlab._xWidth = LONG_MAX;
                        flSlab._yHeight = 0;
                    }
                    
                    rowStart += nBytesPerRow;
                    TraceTag((tagCharShape, "%S", LPTSTR(str)));
                }
                if ((nRows % 2) != 0)
                {
                    me._aryFLSlab.AppendIndirect(&flSlab);
                }
                
                MemFree(aBits);
            }
        }
    }
#endif

    const CBaseCcs *pBaseCcs = pccs->GetBaseCcs();
    Assert(pBaseCcs);
    if(pBaseCcs->_fScalingRequired)
    {
        dvA *= pBaseCcs->_flScaleFactor;
        dvD *= pBaseCcs->_flScaleFactor;
    }

    if (me._aryFLSlab.Size() == 0)
    {
        CFLSlab flSlab;
        flSlab._xWidth = 0;
        flSlab._yHeight = dvA + dvD;
        me._aryFLSlab.AppendIndirect(&flSlab);
    }
    
    if (retVal != GDI_ERROR)
    {
        plsTxMet->dvAscent = dvA;
        plsTxMet->dvDescent = dvD;
        por->_fKerned = TRUE;
    }
    
    pccs->PopFont(pccs->GetHDC(), hFontOld);
}


//-----------------------------------------------------------------------------
//
//  Function:   CheckSetTables (member)
//
//  Synopsis:   Set appropriate tables for Line Services
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
CLineServices::CheckSetTables()
{
    LSERR lserr;

    lserr = CheckSetBreaking();

    if (   lserr == lserrNone
        && _pPFFirst->_uTextJustify > styleTextJustifyInterWord)
    {
        lserr = CheckSetExpansion();

        if (lserr == lserrNone)
        {
            lserr = CheckSetCompression();
        }
    }

    RRETURN(HRFromLSERR(lserr));
}


//-----------------------------------------------------------------------------
//
//  Function:   CheckForPaddingBorder
//
//  Synopsis: If we going to consume a block element and it has
//              either padding or borders, then the line cannot be a
//              dummy line. To ensure that mark the line as being
//              empty, but having padding or borders. Ideally,
//              CalcBeforeSpace should have marked this, byut there
//              might be intervening spaces which might cause
//              CalcBeforeSpace to not see this end splay tag.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::CheckForPaddingBorder(COneRun *por)
{
    CTreePos *ptp = por->_ptp;
    
    // If it is already marked correctly, the do nothing.
    if (_pMeasurer->_fEmptyLineForPadBord)
        goto Cleanup;

    if (ptp->IsEndElementScope())
    {
        CTreeNode *pNode = ptp->GetBranch();
        CElement  *pElement = pNode->Element();
        LONG       lFontHeight = por->GetCF()->GetHeightInTwips(pElement->Doc());

        Assert(_pFlowLayout->IsElementBlockInContext(pElement));
        
        if (!pElement->_fDefinitelyNoBorders)
        {
            CBorderInfo borderinfo;

            pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper(pNode, _pci, &borderinfo, GBIH_NONE);
            if (!pElement->_fDefinitelyNoBorders)
            {
                if (borderinfo.aiWidths[SIDE_BOTTOM])
                {
                    _pMeasurer->_fEmptyLineForPadBord = TRUE;
                    goto Cleanup;
                }
            }
        }

        if (por->GetFF()->GetLogicalPadding(SIDE_BOTTOM, por->GetCF()->HasVerticalLayoutFlow(), 
                                                         por->GetCF()->_fWritingModeUsed).YGetPixelValue(
                _pci,
                _pci->_sizeParent.cx, 
                lFontHeight))
        {
            _pMeasurer->_fEmptyLineForPadBord = TRUE;
            goto Cleanup;
        }
    }
Cleanup:
    return;
}


//-----------------------------------------------------------------------------
//
//  Function:   ShouldBreakInNOBR
//
//  Synopsis: This function decies whether we should cut up a NOBR or not. We cut
//      up a NOBR only in one situation -- when it has a trailing space and that
//      space causes the NOBR object to overflow the right margin. In this case,
//      we return TRUE and return the width of the overflowing space.
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::ShouldBreakInNOBR(LONG lscpForStartOfNOBR,
                                 LONG lscpForEndOfNOBR,
                                 LONG xOverflowWidth,
                                 LONG xNOBRTermination,
                                 LONG *pxWidthOfSpace)
{
    BOOL fBreak = FALSE;
    COneRun *por = FindOneRun(lscpForEndOfNOBR);

    *pxWidthOfSpace = -1;
    
    if (!por)
        goto Cleanup;

    if (_lsMode != LSMODE_MEASURER)
        goto Cleanup;
    
    while(por)
    {
        if (   s_aSynthData[por->_synthType].idObj != idObjTextChp
            || por->IsAntiSyntheticRun()
           )
        {
            por = por->_pPrev;
        }
        else
        {
            if (por->_fCharsForNestedLayout)
                break;
            AssertSz(!por->_fCharsForNestedElement, "All of these which are not nestedlo's should be antisynth'd");
            if (!por->_lscch)
            {
                por = por->_pPrev;
            }

            // Be sure the you have not crossed over to before the NOBR
            // and that the trailing character is a space character.
            else if (   por->_lscpBase + por->_lscch > lscpForStartOfNOBR

                        // The check below was for isspace, but was made
                        // a comparison with just WCH_SPACE because we do
                        // not want to cause a NBSP to go to the next line
                        // since that may unecessarily give the next line
                        // a height and moreover, an NBSP will contribute
                        // to width on _this_ line. (Bug 106014)
                     && (WCH_SPACE == por->_pchBase[por->_lscch - 1])
                    )
            {
                CCcs  ccs;
                if (GetCcs(&ccs, por, _pci->_hdc, _pci))
                {
                    if (ccs.Include(por->_pchBase[por->_lscch - 1], (long&)*pxWidthOfSpace))
                    {
                        // We break if we are overflowing because of the space's width
                        fBreak = xOverflowWidth >= (xNOBRTermination - *pxWidthOfSpace);
                    }
                }
                break;
            }
            else
            {
                break;
            }
        }
    } // while

    // if the NOBR is followed by a BR, then too we do not want to break since
    // it will cause the next line to have a space and a BR and hence have a height
    if (   fBreak
        && _lineFlags.GetLineFlags(CPFromLSCP(lscpForEndOfNOBR) + 1) & FLAG_HAS_A_BR
       )
        fBreak = FALSE;
    
Cleanup:
    return fBreak;
}

//-----------------------------------------------------------------------------
//
//  Function:   HasVisualContent
//
//  Synopsis:   Returns true if we have any rendered content on the line.
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------

BOOL
CLineServices::HasVisualContent()
{
    BOOL fHasContent = FALSE;
    
    for (COneRun *por = _listCurrent._pHead; por; por = por->_pNext)
    {
        if (por->_lscpBase >= _lscpLim)
            break;

        if (por->IsNormalRun())
        {
            fHasContent = TRUE;
            break;
        }
    }
    return fHasContent;
}

BOOL
CLineServices::HasSomeSpacing(const CCharFormat *pCF)
{
    return (GetLetterSpacing(pCF) || GetWordSpacing(pCF));
}

//-----------------------------------------------------------------------------
//
//  Function:   GetLOrWSpacing
//
//  Synopsis:   Returns the value of letterspacing/wordspacing
//
//  Returns:    int
//
//-----------------------------------------------------------------------------

int
CLineServices::GetLOrWSpacing(const CCharFormat *pCF, BOOL fLetter)
{
    int xSpacing;
    CUnitValue cuvSpacing;

    // CSS Letter-spacing/word-spacing
    cuvSpacing = fLetter ? pCF->_cuvLetterSpacing : pCF->_cuvWordSpacing;
    switch (cuvSpacing.GetUnitType())
    {
        case CUnitValue::UNIT_INTEGER:
                xSpacing = (int)cuvSpacing.GetUnitValue();
        break;

        case CUnitValue::UNIT_ENUM:
                xSpacing = 0;     // the only allowable enum value for l-s is normal=0
        break;

        default:
            xSpacing = (int)cuvSpacing.XGetPixelValue(_pci, 0,
                _pFlowLayout->GetFirstBranch()->GetFontHeightInTwips(&cuvSpacing));
    }

    return xSpacing;
}


//-----------------------------------------------------------------------------
//
//  Function:   HRFromLSERR (global)
//
//  Synopsis:   Utility function to converts a LineServices return value
//              (LSERR) into an appropriate HRESULT.
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
HRFromLSERR( LSERR lserr )
{
    HRESULT hr;

#if DBG==1
    if (lserr != lserrNone)
    {
        char ach[64];

        StrCpyA( ach, "Line Services returned an error: " );
        StrCatA( ach, LSERRName(lserr) );

        AssertSz( FALSE, ach );
    }
#endif
    
    switch (lserr)
    {
        case lserrNone:         hr = S_OK;          break;
        case lserrOutOfMemory:  hr = E_OUTOFMEMORY; break;
        default:                hr = E_FAIL;        break;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   LSERRFromHR (global)
//
//  Synopsis:   Utility function to converts a HRESULT into an appropriate
//              LineServices return value (LSERR).
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------

LSERR
LSERRFromHR( HRESULT hr )
{
    LSERR lserr;

    if (SUCCEEDED(hr))
    {
        lserr = lserrNone;
    }
    else
    {
        switch (hr)
        {
            default:
                AssertSz(FALSE, "Unmatched error code; returning lserrOutOfMemory");
            case E_OUTOFMEMORY:     lserr = lserrOutOfMemory;   break;
        }
    }

    return lserr;
}

#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   LSERRName (global)
//
//  Synopsis:   Return lserr in a string form.
//
//-----------------------------------------------------------------------------

static const char * rgachLSERRName[] =
{
    "None",
    "InvalidParameter",//           (-1L)
    "OutOfMemory",//                (-2L)
    "NullOutputParameter",//        (-3L)
    "InvalidContext",//             (-4L)
    "InvalidLine",//                (-5L)
    "InvalidDnode",//               (-6L)
    "InvalidDeviceResolution",//    (-7L)
    "InvalidRun",//                 (-8L)
    "MismatchLineContext",//        (-9L)
    "ContextInUse",//               (-10L)
    "DuplicateSpecialCharacter",//  (-11L)
    "InvalidAutonumRun",//          (-12L)
    "FormattingFunctionDisabled",// (-13L)
    "UnfinishedDnode",//            (-14L)
    "InvalidDnodeType",//           (-15L)
    "InvalidPenDnode",//            (-16L)
    "InvalidNonPenDnode",//         (-17L)
    "InvalidBaselinePenDnode",//    (-18L)
    "InvalidFormatterResult",//     (-19L)
    "InvalidObjectIdFetched",//     (-20L)
    "InvalidDcpFetched",//          (-21L)
    "InvalidCpContentFetched",//    (-22L)
    "InvalidBookmarkType",//        (-23L)
    "SetDocDisabled",//             (-24L)
    "FiniFunctionDisabled",//       (-25L)
    "CurrentDnodeIsNotTab",//       (-26L)
    "PendingTabIsNotResolved",//    (-27L)
    "WrongFiniFunction",//          (-28L)
    "InvalidBreakingClass",//       (-29L)
    "BreakingTableNotSet",//        (-30L)
    "InvalidModWidthClass",//       (-31L)
    "ModWidthPairsNotSet",//        (-32L)
    "WrongTruncationPoint",//       (-33L)
    "WrongBreak",//                 (-34L)
    "DupInvalid",//                 (-35L)
    "RubyInvalidVersion",//         (-36L)
    "TatenakayokoInvalidVersion",// (-37L)
    "WarichuInvalidVersion",//      (-38L)
    "WarichuInvalidData",//         (-39L)
    "CreateSublineDisabled",//      (-40L)
    "CurrentSublineDoesNotExist",// (-41L)
    "CpOutsideSubline",//           (-42L)
    "HihInvalidVersion",//          (-43L)
    "InsufficientQueryDepth",//     (-44L)
    "InsufficientBreakRecBuffer",// (-45L)
    "InvalidBreakRecord",//         (-46L)
    "InvalidPap",//                 (-47L)
    "ContradictoryQueryInput",//    (-48L)
    "LineIsNotActive",//            (-49L)
    "Unknown"
};

const char *
LSERRName( LSERR lserr )
{
    int err = -(int)lserr;

    if (err < 0 || err >= ARRAY_SIZE(rgachLSERRName))
    {
        err = ARRAY_SIZE(rgachLSERRName) - 1;
    }

    return rgachLSERRName[err];
}

#endif // DBG==1

#if DBG == 1 || defined(DUMPTREE)
void
CLineServices::DumpTree()
{
    GetMarkup()->DumpTree();
}

void
CLineServices::DumpUnicodeInfo(TCHAR ch)
{
    CHAR_CLASS CharClassFromChSlow(WCHAR wch);
    char ab[180];
    UINT u;

    HANDLE hf = CreateFile(
                _T("c:\\x"),
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    
    for (u=0;u<0x10000;u++)
    {
        ch = TCHAR(u);
        
        CHAR_CLASS cc = CharClassFromChSlow(ch);
        SCRIPT_ID sid = ScriptIDFromCharClass(cc);

        if (sid == sidDefault)
        {
            DWORD nbw;
            int i = wsprintfA(ab, "{ 0x%04X, %d },\r", ch, cc );
            WriteFile( hf, ab, i, &nbw, NULL);
        }
    }
}

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

DWORD TestAmb()
{
    int i;

    for (i=0;i<65536;i++)
    {
        SCRIPT_ID sid = ScriptIDFromCh(WCHAR(i));

        if (sid == sidDefault)
        {
            char abBuf[32];
            
            wsprintfA(abBuf, "0x%04x\r\n", i);
            OutputDebugStringA(abBuf);
        }
    }

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\lsobj.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module LSOBJ.CXX -- line services object handlers
 *
 *
 *  Owner: <nl>
 *      Chris Thrasher <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      12/18/97     cthrash created
 *      04/28/99     grzegorz - LayoutGrid object added
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// NB (cthrash) The implemetation here is largely modeled on lscsk.cpp in Quill

#ifndef X_LSOBJ_HXX_
#define X_LSOBJ_HXX_
#include "lsobj.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_TCELL_HXX_
#define X_TCELL_HXX_
#include "tcell.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifdef DLOAD1
extern "C" // MSLS interfaces are plain C
{
#endif

#ifndef X_FMTI_H_
#define X_FMTI_H_
#include <fmti.h>
#endif

#ifndef X_LSFRUN_H_
#define X_LSFRUN_H_
#include <lsfrun.h>
#endif

#ifndef X_OBJDIM_H_
#define X_OBJDIM_H_
#include <objdim.h>
#endif

#ifndef X_LSDNFIN_H_
#define X_LSDNFIN_H_
#include <lsdnfin.h>
#endif

#ifndef X_LSQSUBL_H_
#define X_LSQSUBL_H_
#include <lsqsubl.h>
#endif

#ifndef X_LSDNSET_H_
#define X_LSDNSET_H_
#include <lsdnset.h>
#endif

#ifndef X_PLOCCHNK_H_
#define X_PLOCCHNK_H_
#include <plocchnk.h>
#endif

#ifndef X_LOCCHNK_H_
#define X_LOCCHNK_H_
#include <locchnk.h>
#endif

#ifndef X_POSICHNK_H_
#define X_POSICHNK_H_
#include <posichnk.h>
#endif

#ifndef X_PPOSICHN_H_
#define X_PPOSICHN_H_
#include <pposichn.h>
#endif

#ifndef X_BRKO_H_
#define X_BRKO_H_
#include <brko.h>
#endif

#ifndef X_LSQOUT_H_
#define X_LSQOUT_H_
#include <lsqout.h>
#endif

#ifndef X_LSQIN_H_
#define X_LSQIN_H_
#include <lsqin.h>
#endif

#ifdef DLOAD1
} // extern "C"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include <flowlyt.hxx>
#endif

#define brkcondUnknown BRKCOND(-1)

ExternTag(tagLSCallBack);

DeclareLSTag( tagTraceILSBreak, "Trace ILS breaking");

MtDefine(CDobjBase, LineServices, "CDobjBase")
MtDefine(CNobrDobj, LineServices, "CNobrDobj")
MtDefine(CEmbeddedDobj, LineServices, "CEmbeddedDobj")
MtDefine(CGlyphDobj, LineServices, "CGlyphDobj")
MtDefine(CLayoutGridDobj, LineServices, "CLayoutGridDobj")
MtDefine(CILSObjBase, LineServices, "CILSObjBase")
MtDefine(CEmbeddedILSObj, LineServices, "CEmbeddedILSObj")
MtDefine(CNobrILSObj, LineServices, "CNobrILSObj")
MtDefine(CGlyphILSObj, LineServices, "CGlyphILSObj")
MtDefine(CLayoutGridILSObj, LineServices, "CLayoutGridILSObj")

// Since lnobj is worthless as far as we're concerned, we just point it back
// to the ilsobj.  lnobj's are instantiated once per object type per line.
typedef struct lnobj
{
    PILSOBJ pilsobj;
} LNOBJ;

//-----------------------------------------------------------------------------
//
//  Function:   CreateILSObj (member, LS callback)
//
//  Synopsis:   Create the ILS object for all 'idObj' objects.
//
//  Returns:    lserrNone if the function is successful
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::CreateILSObj(
    PLSC plsc,          // IN:  LS context
    PCLSCBK plscbk,     // IN:  callbacks to client application
    DWORD idObj,        // IN:  id of the object
    PILSOBJ* ppilsobj)  // OUT: object ilsobj
{
    LSTRACE(CreateILSObj);

    switch( idObj )
    {
    case LSOBJID_EMBEDDED:
        *ppilsobj= (PILSOBJ)(new CEmbeddedILSObj(this, plscbk));
        break;
    case LSOBJID_NOBR:
        *ppilsobj= (PILSOBJ)(new CNobrILSObj(this, plscbk));
        break;
    case LSOBJID_GLYPH:
        *ppilsobj= (PILSOBJ)(new CGlyphILSObj(this, plscbk));
        break;
    case LSOBJID_LAYOUTGRID:
        *ppilsobj= (PILSOBJ)(new CLayoutGridILSObj(this, plscbk));
        break;
    default:
        AssertSz(0, "Unknown lsobj_id");
    }

    return *ppilsobj ? lserrNone : lserrOutOfMemory;
}

CILSObjBase::CILSObjBase(CLineServices* pols, PCLSCBK plscbk)
: _pLS(pols)
{
    // We don't need plscbk.
}

CILSObjBase::~CILSObjBase()
{
}

CEmbeddedILSObj::CEmbeddedILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CNobrILSObj::CNobrILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CGlyphILSObj::CGlyphILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CLayoutGridILSObj::CLayoutGridILSObj(CLineServices* pols, PCLSCBK plscbk)
: CILSObjBase(pols,plscbk)
{}

CDobjBase::CDobjBase(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: _pilsobj(pilsobjNew), _plsdnTop(plsdn), _por(por)
{}

CEmbeddedDobj::CEmbeddedDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por)
{}

CNobrDobj::CNobrDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por), _plssubline(NULL)
{}

CGlyphDobj::CGlyphDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por)
{}

CLayoutGridDobj::CLayoutGridDobj(PILSOBJ pilsobjNew, PLSDNODE plsdn, COneRun *por)
: CDobjBase(pilsobjNew, plsdn, por), _plssubline(NULL)
{
    _lscpStart = _lscpStartObj = 0;
    _uSublineOffset = _uSubline = 0;
    _fCanBreak = TRUE;
    ZeroMemory(_brkRecord, NBreaksToSave * sizeof(RBREAKREC));
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyILSObj (member, LS callback)
//
//  Synopsis:   This function is called from Line Services when the 
//              Line Services Context is destroyed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::DestroyILSObj()    // this = pilsobj
{
    LSTRACE(DestroyILSObj);

    delete this;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetDoc (member, LS callback)
//
//  Synopsis:   LsSetDoc calls pfnSetDoc for each non-text object type.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::SetDoc(PCLSDOCINF) // this = pilsobj
{
    LSTRACE(SetDoc);

    // We don't have anything to do.
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CreateLNObj (member, LS callback)
//
//  Synopsis:   Line Services calls pfnCreateLNObj to invoke the object handler.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::CreateLNObj(PLNOBJ* pplnobj)   // this = pcilsobj
{
    LSTRACE(CreateLNObj);

    // All LNobj's are the same object as our ilsobj.
    // This object's lifetime is determined by the ilsobj
    *pplnobj= (PLNOBJ) this;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyLNObj (member, LS callback)
//
//  Synopsis:   This function is called when the line containing the PDOBJ is 
//              destroyed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CILSObjBase::DestroyLNObj() // this= plnobj
{
    LSTRACE(DestroyLNObj);

    // Do nothing, since we never really created one.
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedILSObj::Fmt(  // this = plnobj
    PCFMTIN pfmtin,    // IN:  formatting input
    FMTRES* pfmtres)   // OUT: formatting result
{
    LSTRACE(EmbeddedFmt);

    BOOL            fOwnLine;
    INT             xMinWidth;
    LONG            cchSite;
    LONG            xWidth, yHeight;
    OBJDIM          objdim;
    LSERR           lserr           = lserrNone;
    CLineServices * pLS             = _pLS;
    CFlowLayout   * pFlowLayout     = pLS->_pFlowLayout;
    PLSRUN          plsrun          = PLSRUN(pfmtin->lsfrun.plsrun);
    CLayout       * pLayout         = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() ); 
    CElement      * pElementLayout;
    CTreeNode     * pNodeLayout;
    const CCharFormat  *pCF;
    const CFancyFormat *pFF;
    CEmbeddedDobj* pdobj= new CEmbeddedDobj(this, pfmtin->plsdnTop, plsrun);

    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // pLayout is the guy we're being asked to format here.
    Assert( pLayout && pLayout != pFlowLayout );

    pElementLayout  = pLayout->ElementOwner();
    pNodeLayout     = pElementLayout->GetFirstBranch();
    pCF             = pNodeLayout->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()));
    pFF             = pNodeLayout->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));

    // for overlapping layouts curtail the range of characters measured
    cchSite = pLS->GetNestedElementCch(pElementLayout);

    ZeroMemory( &objdim, sizeof(OBJDIM) );

    // Let's see if this an 'ownline' thingy.  Note that even if the element
    // is not by default and 'ownline' element, we may have morphed it into
    // one -- then too it has to be a block element. If it is not one (like
    // a span, then it will not live on its own line).  Check here.

    fOwnLine = pLS->IsOwnLineSite(plsrun);

    Assert(pElementLayout->IsInlinedElement(LC_TO_FC(pLayout->LayoutContext())));

    // Certain sites that only Microsoft supports can break with any
    // characters, so we hack that in right here.
    // NOTE (cthrash) This is goofy.  We should have a better way to
    // determine this than checking tag types.

    pdobj->_fIsBreakingSite =    pElementLayout->Tag() == ETAG_OBJECT
                              || pElementLayout->Tag() == ETAG_IFRAME
                              || pElementLayout->Tag() == ETAG_MARQUEE

    // This is really unfortunate -- if a site is percent sized then it becomes a breaking
    // site inside table cells. This is primarily for IE4x compat. See IE bug 42336 (SujalP)

                                 // width in parent's coordinate system
                              || pFF->GetLogicalWidth(pNodeLayout->IsParentVertical(), 
                                                      pCF->_fWritingModeUsed).IsPercent()

    // One last thing - if we have a morphed non-ownline element inside
    // a table, it's considered a breaking site.

                              || (!fOwnLine
                              && (!pElementLayout->_fLayoutAlwaysValid || pElementLayout->TestClassFlag(CElement::ELEMENTDESC_NOLAYOUT)));

    // If it's on its own line, and not first on line, FetchRun should have
    // terminated the line before we got here.
    // Assert( !( fOwnLine && !pfmtin->lsfgi.fFirstOnLine) );

    pLS->_pMeasurer->GetSiteWidth( pNodeLayout, pLayout, pLS->_pci,
                                   pLS->_lsMode == CLineServices::LSMODE_MEASURER,
                                   pLS->_xWrappingWidth,
                                   &xWidth, &yHeight, &xMinWidth);

    // v-Dimension computed in VerticalAlignObjects
    // NOTE (cthrash) We have rounding errors in LS; don't pass zero

    objdim.heightsRef.dvAscent = 1;
    objdim.heightsRef.dvDescent = 0;
    objdim.heightsRef.dvMultiLineHeight = 1;
    if (_pLS->_fMinMaxPass)
        objdim.heightsPres = objdim.heightsRef;

    if(pLS->_fIsRuby && !pLS->_fIsRubyText)
    {
        pLS->_yMaxHeightForRubyBase = max(pLS->_yMaxHeightForRubyBase, yHeight);
    }

    // We need to store two widths in the dobj: The width corresponding to
    // the wrapping width (urColumnMax) and the minimum width.  LsGetMinDur,
    // however, does not recognize two widths for ILS objects.  We therefore
    // cache the difference, and account for these in an enumeration callback
    // after the LsGetMinDur pass.

    if (!pLS->_fMinMaxPass)
    {
        LONG lMW = pLS->_pci->GetDeviceMaxX() - 1;
        pdobj->_dvMinMaxDelta = 0;
        // NOTE (SujalP, KTam):
        // We need to subtract the pen width because our max width (from GetDeviceMaxX())
        // is the same as a hardcoded lineservices limit (uLsInfiniteRM), and
        // there might be something else on the line already.
        // We cannot increase our max width beyond the LS limit!
        objdim.dur = max( 0L, min(LONG(lMW - pfmtin->lsfgi.urPen), xWidth) );
        plsrun->_xWidth = objdim.dur;
    }
    else
    {
        LONG lMW = pLS->_pci->GetDeviceMaxX() - 1;
        xWidth = min(lMW, xWidth);
        xMinWidth = min(INT(lMW), xMinWidth);
        
        pdobj->_dvMinMaxDelta = xWidth - xMinWidth;
        objdim.dur = xMinWidth;
        plsrun->_xWidth = xMinWidth;
    }

    // For StrictCSS1 this is a time to check for auto margins on the layout and 
    // adjust line left and right if necessary.

    if (    !pLS->_fMinMaxPass                      // this is a normal calc 
        &&  _pLS->_pMarkup->IsStrictCSS1Document()  // rendering in CSS1 strict mode 
        &&  !pFF->IsAbsolute()                      // skip if position is absolute  
        &&  pElementLayout->DetermineBlockness(pFF) // the element has blockness 
        &&  (pLS->_xWrappingWidth - xWidth) > 0  )  // there is a space left to redistribute 
    {
        const CCharFormat   *pCFParent      = pFlowLayout->GetFirstBranch()->GetCharFormat(LC_TO_FC(pFlowLayout->LayoutContext()));
        const CUnitValue    &uvLeftMargin   = pFF->GetLogicalMargin(SIDE_LEFT, pCFParent->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        const CUnitValue    &uvRightMargin  = pFF->GetLogicalMargin(SIDE_RIGHT, pCFParent->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
        BOOL  fLeftMarginIsAuto  = (uvLeftMargin.GetUnitType()  == CUnitValue::UNIT_ENUM) && (uvLeftMargin.GetUnitValue()  == styleAutoAuto);
        BOOL  fRightMarginIsAuto = (uvRightMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (uvRightMargin.GetUnitValue() == styleAutoAuto);

        if (fLeftMarginIsAuto || fRightMarginIsAuto)
        {
            long xWidthToDistribute = pLS->_xWrappingWidth - xWidth;
            Assert(0 < xWidthToDistribute); 
        
            if (fLeftMarginIsAuto == fRightMarginIsAuto)
            {
                _pLS->_li._xLeft  += xWidthToDistribute / 2;
                _pLS->_li._xRight += xWidthToDistribute - xWidthToDistribute / 2;
            }
            else if (fLeftMarginIsAuto) 
            {
                _pLS->_li._xLeft += xWidthToDistribute;
            }
            else 
            {
                _pLS->_li._xRight += xWidthToDistribute;
            }
        }
    }

    if (pCF->HasCharGrid(TRUE))
    {
        long lCharGridSize = pLS->GetCharGridSize();
        objdim.dur = pLS->GetClosestGridMultiple(lCharGridSize, objdim.dur);
        if (pLS->_fMinMaxPass)
            pdobj->_dvMinMaxDelta = pLS->GetClosestGridMultiple(lCharGridSize, xWidth) - objdim.dur;
    }

    if (fOwnLine)
    {
        // If we are inside a something like say a PRE then too we do
        // not terminate, because if there was a \r right after the ownline site
        // then we will allow that \r to break the line. We do not check if the
        // subsequent char is a \r because there might be goop(comments, hidden
        // stuff etc etc) between this site and the \r. Hence here we just march
        // forward and if we run into text or layout later on we will terminate
        // the line then. This way we will eat up the goop if any in between.
        if (!pLS->_fScanForCR)
        {
            COneRun *porOut;
            COneRun *por = pLS->_listFree.GetFreeOneRun(plsrun);

            if (!por)
            {
                lserr = lserrOutOfMemory;
                goto Cleanup;
            }

            Assert(plsrun->IsNormalRun());
            Assert(plsrun->_lscch == plsrun->_lscchOriginal);
            por->_lscpBase += plsrun->_lscch;

            // If this object has to be on its own line, then it clearly
            // ends the current line.
            lserr = pLS->TerminateLine(por, CLineServices::TL_ADDEOS, &porOut);
            if (lserr != lserrNone)
                goto Cleanup;

            // Free the one run
            pLS->_listFree.SpliceIn(por);
        }
        else
        {
            // Flip this bit so that we will setup pfmtres properly later on
            fOwnLine = FALSE;
        }

        // If we have an 'ownline' site, by definition this is a breaking
        // site, meaning we can (or more precisely should) break on either
        // side of the site.
        pdobj->_fIsBreakingSite = TRUE;

        //
        // NOTE(SujalP): Bug 65906.
        // We originally used to set ourselves up to collect after space only
        // for morphed elements. As it turns out, we want to collect after space
        // from margins of _all_ ownline sites (including morphed elements),
        // because margins for ownline-sites are not accounted for in
        // VerticalAlignObjects (see CLayout::GetMarginInfo for more details --
        // it returns 0 for ownline sites).
        //
        pLS->_pNodeForAfterSpace = pNodeLayout;

        //
        // All ownline sites have their x position to be 0
        //
        if (pElementLayout->HasFlag(TAGDESC_OWNLINE))
        {
            pLayout->SetXProposed(0);
        }
    }

    if (fOwnLine)
    {
        *pfmtres = fmtrCompletedRun;
    }
    else
    {
        const long urWrappingWidth = max(pfmtin->lsfgi.urColumnMax, pLS->_xWrappingWidth);

        *pfmtres = (pfmtin->lsfgi.fFirstOnLine ||
                    pfmtin->lsfgi.urPen + objdim.dur <= urWrappingWidth)
                   ? fmtrCompletedRun
                   : fmtrExceededMargin;
    }

    // This is an accessor to the dnode, telling LS to set the dnode pointing
    // to our dobj.
    lserr = LsdnFinishRegular( pLS->_plsc, cchSite, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj*)pdobj, &objdim);

    //
    // CSS attributes page break before/after support.
    // There are two mechanisms that add to provide full support: 
    // 1. CRecalcLinePtr::CalcBeforeSpace() and CRecalcLinePtr::CalcAfterSpace() 
    //    is used to set CLineCore::_fPageBreakBefore/After flags only(!) for 
    //    nested elements which have no their own layout (i.e. paragraphs). 
    // 2. CEmbeddedILSObj::Fmt() sets CLineCore::_fPageBreakBefore for nested 
    //    element with their own layout that are NOT allowed to break (always) 
    //    and for nested elements with their own layout that ARE allowed to 
    //    break if this is the first layout in the view chain. 
    //
    if (   // this is print view
           pLS->GetLayoutContext() 
        && pLS->GetLayoutContext()->ViewChain()
           // and run is completed one
        && *pfmtres == fmtrCompletedRun )
    {
        if (GET_PGBRK_BEFORE(pFF->_bPageBreaks)) 
        {
            CLayoutBreak *  pLayoutBreak;
            BOOL            fSetPageBreakBefore = !pLayout->ElementCanBeBroken();

            if (!fSetPageBreakBefore)
            {
                pLS->GetLayoutContext()->GetLayoutBreak(pElementLayout, &pLayoutBreak); 
                fSetPageBreakBefore = (pLayoutBreak == NULL);
            }

            if (fSetPageBreakBefore)
            {
                pLS->_li._fPageBreakBefore  = TRUE;
                pLS->_pci->_fPageBreakLeft  |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
                pLS->_pci->_fPageBreakRight |= IS_PGBRK_BEFORE_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 

                pLS->GetLayoutContext()->GetEndingLayoutBreak(pFlowLayout->ElementOwner(), &pLayoutBreak);
                if (pLayoutBreak)
                {
                    DYNCAST(CFlowLayoutBreak, pLayoutBreak)->_pElementPBB = pElementLayout;
                }
            }

        }

        if (GET_PGBRK_AFTER(pFF->_bPageBreaks))
        {
            pLS->_li._fPageBreakAfter   = TRUE;
            pLS->_pci->_fPageBreakLeft  |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakLeft); 
            pLS->_pci->_fPageBreakRight |= IS_PGBRK_AFTER_OF_STYLE(pFF->_bPageBreaks, stylePageBreakRight); 
        }
    }
    
Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrILSObj::Fmt(       // this = plnobj
    PCFMTIN pfmtin,     // IN:  formatting input
    FMTRES* pfmtres)    // OUT: formatting result
{
    LSTRACE(NobrFmt);

    LSERR lserr = lserrNone;
    CLineServices * pLS = _pLS;
    FMTRES subfmtres;
    OBJDIM objdim;
    LSTFLOW lstflowDontcare;
    COneRun* por= (COneRun*) pfmtin->lsfrun.plsrun;
    //LONG lscpStart= pLS->LSCPFromCP(por->Cp());
    LONG lscpStart= por->_lscpBase + 1; // +1 to jump over the synth character
    LSCP lscpLast;
    LSCP lscpUsed;
    BOOL fSuccess;

    CNobrDobj* pdobj = new CNobrDobj(this, pfmtin->plsdnTop, por);
    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pdobj->_plssubline = NULL;
    pdobj->_lscpStart = pfmtin->lsfgi.cpFirst;
    pdobj->_lscpObjStart = lscpStart;
    pdobj->_lscpObjLast = lscpStart;
    pdobj->_fCanBreak = FALSE;

    AssertSz( ! pLS->_fNoBreakForMeasurer, "Can't nest NOBR's");

    pLS->_fNoBreakForMeasurer = TRUE;

    pdobj->_brkcondBefore = brkcondUnknown;
    pdobj->_brkcondAfter = brkcondUnknown;

    // Tell LS to prepare a subline
    lserr= LsCreateSubline(pLS->_plsc, lscpStart, MAX_MEASURE_WIDTH, pfmtin->lsfgi.lstflow, FALSE);
    if (lserr != lserrNone)
    {
        goto Cleanup;
    }

    // Tell LS to populate it.
    do
    {
        PLSDNODE plsdnStart;
        PLSDNODE plsdnEnd;

        // Format as much as we can - note we move max to maximum positive value.
        lserr = LsFetchAppendToCurrentSubline(pLS->_plsc,
                                              0,
                                              &s_lsescEndNOBR[0],
                                              NBREAKCHARS,
                                              &fSuccess,
                                              &subfmtres,
                                              &lscpLast,
                                              &plsdnStart,
                                              &plsdnEnd);

        if (lserr != lserrNone)
        {
            goto Cleanup;
        }
        Assert(subfmtres != fmtrExceededMargin); // we are passing max width!

    } while (   (subfmtres != fmtrCompletedRun)  //Loop until one of the conditions is met.
             && !fSuccess
            );

    *pfmtres = subfmtres;

    lserr = LsFinishCurrentSubline(pLS->_plsc, &pdobj->_plssubline);
    if (lserr != lserrNone)
        goto Cleanup;

    // get Object dimensions.
    lserr = LssbGetObjDimSubline(pdobj->_plssubline, &lstflowDontcare, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;

    // We add 2 to include the two synthetic characters at the beginning and end.
    // That's just how it goes, okay.
    lscpUsed = lscpLast - lscpStart + 2;

    pdobj->_lscpObjLast = lscpLast;
    
    // Tell Line Services we have a special object which (a) is not to be broken,
    // and (b) have different min and max widths due to trailing spaces.

    lserr = LsdnSubmitSublines( pLS->_plsc,
                                pfmtin->plsdnTop,
                                1,
                                &pdobj->_plssubline,
                                TRUE, //pLS->_fExpansionOrCompression,  // fUseForJustification
                                TRUE, //pLS->_fExpansionOrCompression,  // fUseForCompression
                                FALSE,  // fUseForDisplay
                                FALSE,  // fUseForDecimalTab
                                TRUE ); // fUseForTrailingArea  

    // Give the data back to LS.
    lserr = LsdnFinishRegular( pLS->_plsc, lscpUsed,
                               pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj *) pdobj, &objdim);
    
    
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    if (lserr != lserrNone && pdobj)
    {
        if (pdobj->_plssubline)
            LsDestroySubline(pdobj->_plssubline);  // Destroy the subline.
        delete pdobj;
    }

    pLS->_fNoBreakForMeasurer = FALSE;

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphILSObj::Fmt(     // this = plnobj
    PCFMTIN pfmtin,    // IN:  formatting input
    FMTRES* pfmtres)   // OUT: formatting result
{
    LSTRACE(GlyphFmt);
    LSERR           lserr          = lserrNone;
    OBJDIM          objdim;
    PLSRUN          por            = PLSRUN(pfmtin->lsfrun.plsrun);
    CLineServices * pLS            = _pLS;

    CGlyphDobj* pdobj= new CGlyphDobj(this, pfmtin->plsdnTop, por);
    if (!pdobj)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }

    // For breaking we need to know two things:
    //  (a) is this a glyph represnting a no-scope?
    //  (b) if not, is this representing a begin or end tag?

    pdobj->_fBegin = por->_ptp->IsBeginNode();
    pdobj->_fNoScope = FALSE;

    pdobj->_RenderInfo.pImageContext = NULL;
    Assert(pLS->_fIsEditable);
    if (!por->_ptp->ShowTreePos(&pdobj->_RenderInfo))
    {
        AssertSz(0, "Inconsistent info in one run");
        lserr = lserrInvalidRun;
        goto Cleanup;
    }
    Assert(pdobj->_RenderInfo.pImageContext);

    objdim.heightsRef.dvAscent = pdobj->_RenderInfo.height;
    objdim.heightsRef.dvDescent = 0;
    objdim.heightsRef.dvMultiLineHeight = pdobj->_RenderInfo.height;
    objdim.heightsPres = objdim.heightsRef;
    objdim.dur = pdobj->_RenderInfo.width;

    // This is an accessor to the dnode, telling LS to set the dnode pointing
    // to our dobj.
    lserr = LsdnFinishRegular( pLS->_plsc, por->_lscch, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj*)pdobj, &objdim);

    *pfmtres = fmtrCompletedRun;

Cleanup:
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   Fmt (member, LS callback)
//
//  Synopsis:   Line Services calls pfnFmt for the appropriate object each time
//              a run is fetched. This callback computes the position of each 
//              element in the run, and returns when the run is exhausted, or 
//              when a potential line break character is reached after the right 
//              margin is exceeded. 
//              During Fmt() an object handler must do one of the following:
//              1. Create an output dobj (display object) and register it with 
//                 a dnode by calling a Fini routine. This places a pointer to 
//                 dobj into a Line Services dnode. The output dobj should 
//                 contain sufficient data to facilitate line breaking and 
//                 display operations.
//              2. Call a Fini routine that deletes the dnode.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridILSObj::Fmt( // this = plnobj
    PCFMTIN pfmtin,     // IN:  formatting input
    FMTRES* pfmtres)    // OUT: formatting result
{
    LSTRACE(LayoutGridFmt);

    return FmtResume(NULL, 0, pfmtin, pfmtres);
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedILSObj::FmtResume(             // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(EmbeddedFmtResume);
    LSNOTIMPL(FmtResume);

    // I believe that this should never get called for most embedded objects.
    // The only possible exception that comes to mind are marquees, and I do
    // not believe that they can wrap around lines.

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrILSObj::FmtResume(                 // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(NobrFmtResume);
    LSNOTIMPL(FmtResume);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphILSObj::FmtResume(                // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSTRACE(GlyphFmtResume);
    LSNOTIMPL(FmtResume);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FmtResume (member, LS callback)
//
//  Synopsis:   This routine is similar to pfnFmt, except it is used to format 
//              the wrapped portion of the object.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridILSObj::FmtResume(           // this = plnobj
    const BREAKREC* rgBreakRecord,      // IN:  array of break records
    DWORD nBreakRecord,                 // IN:  size of the break records array
    PCFMTIN pfmtin,                     // IN:  formatting input
    FMTRES* pfmtres)                    // OUT: formatting result
{
    LSERR lserr = lserrNone;
    FMTRES subfmtres = fmtrCompletedRun;    // keep compiler happy
    OBJDIM objdim;
    LSTFLOW lstflowDontcare;
    LSCP lscpLast = 0;
    BOOL fSuccess = FALSE;
    LONG lObjWidth;
    LSCP dcp;
    BOOL fFmtResume = nBreakRecord != 0;
    PLSRUN por = PLSRUN(pfmtin->lsfrun.plsrun);

    // Create new object and initialize it
    CLayoutGridDobj* pdobjLG = new CLayoutGridDobj(this, pfmtin->plsdnTop, por);
    if (!pdobjLG)
    {
        lserr = lserrOutOfMemory;
        goto Cleanup;
    }
    pdobjLG->_lscpStart = pfmtin->lsfgi.cpFirst;
    pdobjLG->_lscpStartObj = (fFmtResume ? rgBreakRecord->cpFirst : pfmtin->lsfgi.cpFirst);

    // Calculate maximum width of the object
    lObjWidth = pdobjLG->AdjustColumnMax(pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen);

    while (!fSuccess)
    {
        PLSDNODE    plsdnStart;
        PLSDNODE    plsdnEnd;

        // Tell LS to prepare a subline
        lserr = LsCreateSubline(_pLS->_plsc, pdobjLG->_lscpStart + 1, 
                                lObjWidth, pfmtin->lsfgi.lstflow, FALSE);
        if (lserr != lserrNone)
            goto Cleanup;

        if (fFmtResume)
        {
            lserr = LsFetchAppendToCurrentSublineResume(_pLS->_plsc, &rgBreakRecord[1], 
                            nBreakRecord - 1,
                            0, &s_lsescEndLayoutGrid[0], NBREAKCHARS, 
                            &fSuccess, &subfmtres, &lscpLast, &plsdnStart, &plsdnEnd);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else 
        {
            subfmtres = fmtrTab;
            fSuccess = TRUE;
        }
        while ((subfmtres == fmtrTab) && fSuccess)
        {
            lserr = LsFetchAppendToCurrentSubline(_pLS->_plsc, 
                            0, &s_lsescEndLayoutGrid[0], NBREAKCHARS, 
                            &fSuccess, &subfmtres, &lscpLast, &plsdnStart, &plsdnEnd);
            if (lserr != lserrNone)
                goto Cleanup;
        }

        if (!fSuccess)
        {
            // FetchAppend unsuccessful.
            // Finish and destroy subline, then repeat
            lserr = LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
            if (lserr != lserrNone)
                goto Cleanup;
            lserr = LsDestroySubline(pdobjLG->_plssubline);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
            *pfmtres = subfmtres;
    }

    lserr = LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
    if (lserr != lserrNone)
        goto Cleanup;

    // Get object dimensions.
    lserr = LssbGetObjDimSubline(pdobjLG->_plssubline, &lstflowDontcare, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;
    lObjWidth = _pLS->GetClosestGridMultiple(_pLS->GetCharGridSize(), objdim.dur);
    pdobjLG->_uSublineOffset = (lObjWidth - objdim.dur) / 2;
    pdobjLG->_uSubline = objdim.dur;
    objdim.dur = lObjWidth;

    // We do not submint the subline because object's width has been changed.

    // Set dcp for whole object
    // If we haven't reached right margin we add 1 to include the synthetic 
    // character (WCH_ENDLAYOUTGRID) at the end.
    dcp = lscpLast - pdobjLG->_lscpStart + (subfmtres == fmtrExceededMargin ? 0 : 1);

    // Give the data back to LS.
    lserr = LsdnFinishRegular( _pLS->_plsc, dcp, pfmtin->lsfrun.plsrun,
                               pfmtin->lsfrun.plschp, (struct dobj *) pdobjLG, &objdim);
    if (lserr != lserrNone)
        goto Cleanup;

Cleanup:
    if (lserr != lserrNone && pdobjLG)
    {
        if (pdobjLG->_plssubline)
        {
            // Finish and destroy subline
            LsFinishCurrentSubline(_pLS->_plsc, &pdobjLG->_plssubline);
            LsDestroySubline(pdobjLG->_plssubline);
        }
        delete pdobjLG;
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthPrecedingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthPrecedingChar to determine 
//              amount by which width of the preceding char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetModWidthPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    long* pdurChange)       // OUT: amount by which width of the preceding char is to be changed
{
    LSTRACE(GetModWidthPrecedingChar);

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthPrecedingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthPrecedingChar to determine 
//              amount by which width of the preceding char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::GetModWidthPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    long* pdurChange)       // OUT: amount by which width of the preceding char is to be changed
{
    LSTRACE(NobrGetModWidthPrecedingChar);

    // ????
    // NOTE (cthrash) This is wrong.  We need to determine the MWCLS of the
    // first char of the NOBR and determine how much we should adjust the width.

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthFollowingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthFollowingChar to determine 
//              amount by which width of the following char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetModWidthFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    long* pdurChange)       // OUT: amount by which width of the following char is to be changed
{
    LSTRACE(GetModWidthFollowingChar);

    *pdurChange = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetModWidthFollowingChar (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnGetModWidthFollowingChar to determine 
//              amount by which width of the following char is to be changed.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::GetModWidthFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    PCHEIGHTS heightsRef,   // IN:  height info about character
    WCHAR wch,              // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    long* pdurChange)       // OUT: amount by which width of the following char is to be changed
{
    LSTRACE(NobrGetModWidthFollowingChar);

    // ????
    // NOTE (cthrash) This is wrong.  We need to determine the MWCLS of the
    // last char of the NOBR and determine how much we should adjust the width.
    
    *pdurChange = 0; 

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(TruncateChunk);
    LSERR lserr = lserrNone;
    long idobj;
    
    if (plocchnk->clschnk == 1)
    {
        idobj = 0;
    }
    else
    {
        long urColumnMax;
        long urTotal;
        OBJDIM objdim;

        urColumnMax = PDOBJ(plocchnk->plschnk[0].pdobj)->GetPLS()->_xWrappingWidth;
        urTotal = plocchnk->lsfgi.urPen;

        Assert(urTotal <= urColumnMax);

        for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
        {
            CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
            lserr = pdobj->QueryObjDim(&objdim);
            if (lserr != lserrNone)
                goto Cleanup;

            urTotal += objdim.dur;
            if (urTotal > urColumnMax)
                break;
        }

        Assert(urTotal > urColumnMax);
        Assert(idobj < (long)plocchnk->clschnk);
        if (idobj >= (long)plocchnk->clschnk)
        {
            idobj = 0;
        }
    }

    // Tell it which chunk didn't fit.

    pposichnk->ichnk = idobj;

    // Tell it which cp inside this chunk the break occurs at.
    // In our case, it's always an all-or-nothing proposition.  So include the whole dobj

    pposichnk->dcp = plocchnk->plschnk[idobj].dcp;

    TraceTag((tagTraceILSBreak,
              "Truncate(cchnk=%d cpFirst=%d) -> ichnk=%d",
              plocchnk->clschnk,
              plocchnk->plschnk->cpFirst,
              idobj
             ));

Cleanup:

    return lserr;
}


//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(NOBRTruncateChunk);

    LSERR   lserr = lserrNone;
    long    urColumnMax = plocchnk->lsfgi.urColumnMax;
    long    ur = plocchnk->ppointUvLoc[0].u;
    long    idobj;
    CNobrDobj *pdobjNOBR;
    OBJDIM  objdim = {0};   // keep compiler happy
    LONG    xWidthOfSpace;
    
    AssertSz(ur <= urColumnMax, "TruncateChunk - pen greater than column max");

    for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
        lserr = pdobj->QueryObjDim(&objdim);
        if (lserr != lserrNone)
            goto Cleanup;

        ur = plocchnk->ppointUvLoc[idobj].u + objdim.dur;
        if (ur > urColumnMax)
            break;
    }

    Assert(ur > urColumnMax);
    Assert(idobj < (long)plocchnk->clschnk);
    
    pdobjNOBR = (CNobrDobj*)plocchnk->plschnk[idobj].pdobj;
    
    // Tell it which chunk didn't fit.
    pposichnk->ichnk = idobj;

    if (PDOBJ(pdobjNOBR)->GetPLS()->ShouldBreakInNOBR(pdobjNOBR->_lscpObjStart,
            pdobjNOBR->_lscpObjLast, urColumnMax, ur, &xWidthOfSpace))
    {
        pdobjNOBR->_fCanBreak = TRUE;
        pdobjNOBR->_xShortenedWidth = objdim.dur - xWidthOfSpace;

        Assert(pdobjNOBR->_xShortenedWidth <= urColumnMax);
        
        // Tell it which cp inside this chunk the break occurs at.
        // In our case, before the space, hence one char for
        // the endnobr synth and one for the space.
        pposichnk->dcp = plocchnk->plschnk[idobj].dcp - 2;
    }
    else
    {
        // Tell it which cp inside this chunk the break occurs at.
        // In our case, it's always an all-or-nothing proposition.  So include the whole dobj
        pposichnk->dcp = plocchnk->plschnk[idobj].dcp;
    }

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::TruncateChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
    PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(LayoutGridTruncateChunk);

    LSERR   lserr = lserrNone;
    long    urColumnMax = plocchnk->lsfgi.urColumnMax;
    long    ur = plocchnk->ppointUvLoc[0].u;
    OBJDIM  objdim;
    LSCP    lscp;
    long    idobj;
    CLayoutGridDobj * pdobjLG;
    long    urSublineColumnMax;

    AssertSz(ur <= urColumnMax, "TruncateChunk - pen greater than column max");

    for (idobj = 0; idobj < (long)plocchnk->clschnk; idobj++)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
        lserr = pdobj->QueryObjDim(&objdim);
        if (lserr != lserrNone)
            goto Cleanup;

        ur = plocchnk->ppointUvLoc[idobj].u + objdim.dur;
        if (ur > urColumnMax)
            break;
    }

    Assert(ur > urColumnMax);
    Assert(idobj < (long)plocchnk->clschnk);

    // Found the object where truncation is to occur
    pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[idobj].pdobj;

    // Get the truncation point from the subline
    // We need to subtract offset of the subline (plocchnk->ppointUvLoc[idobj].u) from
    // 'urColumnMax', because if we change subline's width we need to adjust width of 
    // the object one again (in SetBreak()), so we don't care about current offset.
    urSublineColumnMax = pdobjLG->AdjustColumnMax(urColumnMax - plocchnk->ppointUvLoc[idobj].u);
    pdobjLG->_fCanBreak = urSublineColumnMax > 0;
    if (pdobjLG->_fCanBreak)
    {
        lserr = LsTruncateSubline(pdobjLG->_plssubline, urSublineColumnMax, &lscp);
        if (lserr != lserrNone) 
            goto Cleanup;
    }
    else
    {
        // If we set 0 then LS will return an error, so 
        // we set 1 and mark that we can't break
        lscp = pdobjLG->LSCPLocal2Global(1);
    }

    // Format return result
    pposichnk->ichnk = idobj;
    pposichnk->dcp = pdobjLG->LSCPGlobal2Local(lscp);
    Assert(pposichnk->dcp > 0 && pposichnk->dcp <= plocchnk->plschnk[idobj].dcp);

    TraceTag((tagTraceILSBreak,
              "Truncate(cchnk=%d cpFirst=%d) -> ichnk=%d",
              plocchnk->clschnk, plocchnk->plschnk->cpFirst, idobj));

Cleanup:

    return lserr;
}


//-----------------------------------------------------------------------------
//
//  Function:   TruncateChunk (static member, LS callback)
//
//  Synopsis:   From LS docs: Purpose    To obtain the exact position within
//              a chunk where the chunk crosses the right margin.  A chunk is
//              a group of contiguous LS objects which are of the same type.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::TruncateChunk(PCLOCCHNK plocchnk,     // IN:  locchnk to truncate
                          PPOSICHNK pposichnk)    // OUT: truncation point
{
    LSTRACE(GlyphDobjTruncateChunk);
    CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[0].pdobj;
    CLineServices *pLS = PDOBJ(pdobj)->GetPLS();
    LONG idobj = 0;
    LONG minidobj = -1;
    LSERR lserr;
    
    // If we are measuring from the start then there were some glyphs
    // at the BOL which could also have some alogned objects inside them.
    // If that is the case then we can never break between glyphed objects
    // at BOL when they have aligned objects in between them since
    // these glyphed objects have already been "consumed" when we were
    // consuming the aligned objects. If we do break then the aligned object
    // may (will) get measured again -- resulting in bad layout or worse.
    // (See IE5 bug 107056)
    if (pLS->_pMeasurer->_fMeasureFromTheStart)
    {
        for (idobj = 0; idobj < (long)plocchnk->clschnk - 1; idobj++)
        {
            pdobj = (CDobjBase *)plocchnk->plschnk[idobj].pdobj;
            if (pdobj->Por()->Cp() - pLS->_cpStart >= pLS->_cchSkipAtBOL)
            {
                break;
            }
        }
    }
    minidobj = idobj;
    lserr = super::TruncateChunk(plocchnk, pposichnk);
    if (lserr == lserrNone)
    {
        // Our default method returned a berak opportunity _before_
        // the cchSkipAtBOL limit. Lets change it to the minimum
        // index required to skip the the cchSkipAtBOL.
        if (minidobj > pposichnk->ichnk)
        {
            pposichnk->ichnk = minidobj;
            pposichnk->dcp = plocchnk->plschnk[minidobj].dcp;
        }
    }
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CanBreakPair (local helper function)
//
//-----------------------------------------------------------------------------
inline BOOL
CanBreakPair(BRKCOND brkcondBefore, BRKCOND brkcondAfter)
{
    // brkcondPlease = 0
    // brkcondCan    = 1
    // brkcondNever  = 2
    //
    //
    //         | Please |   Can  |  Never
    // --------+--------+--------+---------
    //  Please |  TRUE  |  TRUE  |  FALSE
    // --------+--------+--------+---------
    //  Can    |  TRUE  |  FALSE |  FALSE
    // --------+--------+--------+---------
    //  Never  |  FALSE |  FALSE |  FALSE

    return (int(brkcondBefore) + int(brkcondAfter)) < 2;
}

//-----------------------------------------------------------------------------
//
//  Function:   DumpBrkopt (local helper function)
//
//-----------------------------------------------------------------------------
#if DBG==1
void
DumpBrkopt(
    char *szType,
    BOOL fMinMaxPass,
    PCLOCCHNK plocchnk,
    PCPOSICHNK pposichnk,
    BRKCOND brkcond,
    PBRKOUT pbrkout)
{
    static const char * achBrkCondStr[3] = { "Please", "Can", "Never" };

    // Make sure we don't try to break before the first object on the line.  This is bad.

    AssertSz(   !pbrkout->fSuccessful
             || !plocchnk->lsfgi.fFirstOnLine
             || pbrkout->posichnk.ichnk > 0
             || pbrkout->posichnk.dcp > 0,
             "Bad breaking position.  Cannot break at BOL.");

    TraceTag((tagTraceILSBreak,
              "%s(brkcond=%s cchnk=%d ichnk=%d) minmax=%s urPen=%d "
              "-> %s(%s) on %d(%s)",
              szType,
              achBrkCondStr[brkcond],
              plocchnk->clschnk,
              pposichnk->ichnk,
              fMinMaxPass ? "yes" : "no",
              plocchnk->lsfgi.urPen,
              pbrkout->fSuccessful ? "true" : "false",
              achBrkCondStr[pbrkout->brkcond],
              pbrkout->posichnk.ichnk,
              pbrkout->posichnk.dcp > 0 ? "after" : "before"));
}
#else
#define DumpBrkopt(a,b,c,d,e,f)
#endif

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(EmbeddedFindPrevBreakChunk);

    LSERR           lserr;
    BOOL            fSuccessful;
    BOOL            fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long            ichnk = fBreakAfter
                            ? long(plocchnk->clschnk) - 1L
                            : long(pposichnk->ichnk);
    CEmbeddedDobj * pdobj = (CEmbeddedDobj *)(plocchnk->plschnk[ichnk].pdobj);
    CLineServices * pLS = pdobj->GetPLS();
    // An object may be first on line even though the fFirstOnLine bit is not set.
    // This can happen with synthetics -- since for LS they are actual objects, 
    // it claims that this embedded object is after them on the line and 
    // hence is not first on line -- but for us that synthetic object and 
    // this embedded object are inseparable -- 
    // i.e. we do not want to break before this object under any circumstance.
    BOOL fDontBreakBeforeMe = plocchnk->lsfgi.fFirstOnLine;
    if (!fDontBreakBeforeMe)
    {
        COneRun * por = pdobj->_por->_pPrev;
        while (por && !por->IsNormalRun())
            por = por->_pPrev;

        fDontBreakBeforeMe = !por;
    }
    
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (!pdobj->_fIsBreakingSite)
    {
        if (fBreakAfter)
        {
            //
            // If fBreakAfter is TRUE, we have the following scenario (| represents wrapping width):
            //
            // AAA<IMG><IMG>B|BB
            //

            if (!pLS->_fIsTD || !pLS->_fMinMaxPass || (pLS->_xTDWidth < MAX_MEASURE_WIDTH))
            {
                // If we're not in a TD, we can break after the dobj, the subsequent dobj permitting.
                // If the subsequent dobj is not willing, we can break between the dobjs in this chunk.

                if (brkcond == brkcondPlease)
                {
                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
                else
                {
                    fBreakAfter = FALSE;
                    
                    fSuccessful = ichnk > 0 || !fDontBreakBeforeMe;
                    brkcond = fSuccessful ? brkcondPlease : brkcondNever;
                }
            }
            else
            {
                fSuccessful = FALSE;
                brkcond = brkcondCan;
            }
        }
        else if (ichnk == 0 && fDontBreakBeforeMe)
        {
            // We can never break before the first dobj on the line.

            fSuccessful = FALSE;
            brkcond = brkcondNever;
        }
        else
        {
            //
            // fBreakAfter is FALSE, meaning we're splitting up our dobj chunks
            //
            // AAA<IMG><IM|G>BBB
            //

            if (pLS->_fIsTD)
            {
                if (pLS->_xTDWidth == MAX_MEASURE_WIDTH)
                {
                    // TD has no stated width.
                    
                    if (ichnk == 0)
                    {
                        // To do this correctly in the MinMaxPass, we would need to know the
                        // brkcond of the character preceeding our chunk.  The incoming
                        // brkcond, however, is meaningless unless ichnk==ichnkOutside.
                        
                        fSuccessful = FALSE;//!pLS->_fMinMaxPass;
                        brkcond = brkcondCan;
                    }
                    else
                    {
                        // Our TD has no width, so we can break only if our wrapping width
                        // has been exceeded.  Note we will be called during LsGetMinDurBreaks
                        // even if our wrapping width isn't exceeded, because we don't know
                        // yet what that width is.

                        fSuccessful = !pLS->_fMinMaxPass || ((CEmbeddedDobj *)(plocchnk->plschnk[ichnk-1].pdobj))->_fIsBreakingSite;
                        brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                    }
                }
                else
                {
                    // TD has a stated width.

                    if (pLS->_fMinMaxPass)
                    {
                        if (ichnk == 0)
                        {
                            fSuccessful = plocchnk->lsfgi.urColumnMax > pLS->_xTDWidth;
                            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                        }
                        else
                        {
                            // When we're called from LsGetMinDurBreaks, urColumnMax is the
                            // proposed wrapping width.  If this is greater than the TDs
                            // stated width, we can break.  Otherwise, we can't.

                            fSuccessful = plocchnk->lsfgi.urColumnMax > pLS->_xTDWidth;
                            brkcond = fSuccessful ? brkcondPlease : brkcondNever;
                        }
                    }
                    else
                    {
                        // If we're not in a min-max pass, we reach this point only if this
                        // particular dobj has caused an overflow.  We should break before it.

                        fSuccessful = TRUE;
                        brkcond = brkcondPlease;
                    }
                }
            }
            else
            {
                // We're not in a TD, meaning we will break between the dobjs in our chunks.

                if (ichnk)
                {
                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
                else
                {
                    fSuccessful = TRUE;
                    brkcond = fSuccessful ? brkcondCan : brkcondNever;
                }
            }
        }
    }
    else
    {
        // We have a dobj around which we always break, such as a MARQUEE.
        // We will break as long as we're not at the beginning of the line.

        if (fBreakAfter)
        {
            fSuccessful = brkcond != brkcondNever;
            brkcond = brkcondPlease;
        }
        else
        {
            fSuccessful = ichnk > 0;
            brkcond = fDontBreakBeforeMe ? brkcondNever : brkcondPlease;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(E)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(EmbeddedFindNextBreakChunk);

    LSERR   lserr;
    BOOL    fSuccessful;
    BOOL    fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long    ichnk = fBreakBefore
                    ? 0
                    : pposichnk->ichnk;
    CEmbeddedDobj *pdobj = (CEmbeddedDobj *)(plocchnk->plschnk[ichnk].pdobj);
    CLineServices * pLS = pdobj->GetPLS();

    BOOL fDontBreakBeforeMe = plocchnk->lsfgi.fFirstOnLine;
    if (!fDontBreakBeforeMe)
    {
        COneRun * por = pdobj->_por->_pPrev;
        while (por && !por->IsNormalRun())
            por = por->_pPrev;

        fDontBreakBeforeMe = !por;
    }

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (!pdobj->_fIsBreakingSite)
    {
        if (fBreakBefore)
        {
            fBreakBefore = !fDontBreakBeforeMe;
            fSuccessful = fBreakBefore || (plocchnk->clschnk > 1);
            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
        }
        else
        {
            if (ichnk == (long(plocchnk->clschnk) - 1))
            {
                // If this is the last dobj of the chunk, we need to ask the next
                // object if it's okay to break.

                fSuccessful = FALSE;
                brkcond = brkcondCan;
            }
            else
            {
                if (pLS->_fIsTD && pLS->_xTDWidth == MAX_MEASURE_WIDTH)
                {
                    // We are in TD with no width, so we cannot break between our dobjs.

                    fSuccessful = ((CEmbeddedDobj *)(plocchnk->plschnk[ichnk+1].pdobj))->_fIsBreakingSite;;
                    brkcond = fSuccessful ? brkcondPlease : brkcondCan;
                }
                else
                {
                    // We are not in a TD, or we're in a TD with a width.
                    // We've exceeded the wrapping width, so we can break.

                    fSuccessful = TRUE;
                    brkcond = brkcondPlease;
                }
            }
        }
    }
    else
    {
        if (fBreakBefore)
        {
            fSuccessful = !fDontBreakBeforeMe;
            brkcond = fSuccessful ? brkcondPlease : brkcondCan;
        }
        else
        {
            fSuccessful = TRUE;
            brkcond = brkcondPlease;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(E)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(NobrFindPrevBreakChunk);

    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? long(plocchnk->clschnk) - 1L
                    : long(pposichnk->ichnk);
    LSERR   lserr;
    BOOL    fSuccessful;
    CNobrDobj *pdobj = (CNobrDobj *)(plocchnk->plschnk[ichnk].pdobj);

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (fBreakAfter)
    {
        // break after?

        BRKCOND brkcondNext = brkcond;
        COneRun * por = (COneRun *)plocchnk->plschnk[ichnk].plsrun;

        // compute the brkcond of the last char of the last chunk.

        brkcond = pdobj->GetBrkcondAfter(por, plocchnk->plschnk[ichnk].dcp);

        // can we break immediately after the last NOBR?

        fSuccessful = CanBreakPair(brkcond, brkcondNext);

        if (!fSuccessful)
        {
            fBreakAfter = FALSE;

            if (plocchnk->clschnk > 1)
            {
                // if we have more than one NOBR objects, we can always break between them.

                Assert(!por->_fIsArtificiallyStartedNOBR);

                fSuccessful = TRUE;
                brkcond = brkcondPlease;
            }
            else
            {
                // if we only have one NOBR object, we need to see if we can break before it.

                if (plocchnk->lsfgi.fFirstOnLine)
                {
                    brkcond = brkcondNever;
                    fSuccessful = FALSE;
                }
                else
                {
                    brkcond = pdobj->GetBrkcondBefore(por);
                    fSuccessful = brkcond != brkcondNever;
                }
            }
        }
    }
    else
    {
        if (pdobj->_fCanBreak)
        {
            LONG cpBreak;
            OBJDIM objdimSubline;
            BRKPOS  brkpos;
            
            lserr = LsFindPrevBreakSubline(pdobj->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                       pdobj->LSCPLocal2Global(pposichnk->dcp),
                                       pdobj->_xShortenedWidth, &fSuccessful, 
                                       &cpBreak, &objdimSubline, &brkpos);

            
            long dcp;

            if (brkpos == brkposInside)
                dcp = pposichnk->dcp;
            else
                dcp = pdobj->LSCPGlobal2Local(cpBreak);
            pbrkout->fSuccessful = fSuccessful;
            if (brkcond == brkcondPlease || brkcond == brkcondCan || brkcond == brkcondNever)
                pbrkout->brkcond = brkcond;
            else
                pbrkout->brkcond = brkcondPlease;

            if (fSuccessful)
            {
                pbrkout->posichnk.ichnk = ichnk;
                pbrkout->posichnk.dcp = dcp;
                pbrkout->objdim = objdimSubline;
                pbrkout->objdim.dur = pdobj->_xShortenedWidth;
                goto Cleanup;
            }
        }
        else
        {
            if (ichnk)
            {
                // break in between?

                fSuccessful = TRUE;
                brkcond = brkcondPlease; // IE4 compat: for <NOBR>X</NOBR><NOBR>Y</NOBR> we are always willing to break between X and Y.
            }
            else if (plocchnk->lsfgi.fFirstOnLine)
            {
                fSuccessful = FALSE;
            }
            else
            {
                // break before?

                Assert(ichnk == 0); // It has to be the first object
                brkcond = pdobj->GetBrkcondBefore((COneRun *)plocchnk->plschnk[ichnk].plsrun);
                fSuccessful = FALSE;//brkcond != brkcondNever;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(N)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(NobrFindNextBreakChunk);

    BOOL    fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long    ichnk = fBreakBefore
                    ? 0
                    : pposichnk->ichnk;
    LSERR   lserr;
    BOOL    fSuccessful;

    CNobrDobj *pdobj = (CNobrDobj *)(plocchnk->plschnk[ichnk].pdobj);

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );
    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    if (fBreakBefore)
    {
        // Break before?

        BRKCOND brkcondBefore = brkcond;

        // Determine if we have an appropriate breaking boundary

        brkcond = pdobj->GetBrkcondBefore((COneRun *)plocchnk->plschnk[0].plsrun);
        fSuccessful = CanBreakPair(brkcondBefore, brkcond);

        if (!fSuccessful)
        {
            fBreakBefore = FALSE;

            if (plocchnk->clschnk > 1)
            {
                // if we have more than one NOBR objects, we can always break between them.

                fSuccessful = TRUE;
                brkcond = brkcondPlease;
            }
            else
            {
                // if we only have one NOBR object, we need to see if we can break after it.

                brkcond = pdobj->GetBrkcondAfter((COneRun *)plocchnk->plschnk[0].plsrun, plocchnk->plschnk[0].dcp );
                fSuccessful = FALSE;//brkcond != brkcondNever;
            }
        }
    }
    else
    {
        if (ichnk < (long(plocchnk->clschnk) - 1))
        {
            // if we're not the last NOBR object, we can always break after it.

            fSuccessful = TRUE;
            brkcond = brkcondPlease;
        }
        else
        {
            // break after?

            brkcond = pdobj->GetBrkcondAfter((COneRun *)plocchnk->plschnk[ichnk].plsrun, plocchnk->plschnk[ichnk].dcp );
            fSuccessful = FALSE;
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = brkcond;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(N)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CGlyphDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(GlyphFindPrevBreakChunk);

    BOOL         fSuccessful;
    BOOL         fBreakAfter = (pposichnk->ichnk == ichnkOutside);
    long         ichnk = fBreakAfter
                         ? long(plocchnk->clschnk) - 1L
                         : long(pposichnk->ichnk);
    CGlyphDobj * pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);
    LSERR        lserr;

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );

    if (fBreakAfter)
    {
        //                         Second DOBJ
        //
        //                       TEXT   NOSCOPE   BEGIN    END
        //            --------+-------+--------+--------+--------
        //   First    TEXT    |  n/a  | before | before |  no
        //    DOBJ    NOSCOPE | after | after  | after  | after
        //            BEGIN   |   no  | after  |  no    |  no
        //            END     | after | after  | after  |  no
        //

        BOOL fNextWasEnd = FALSE;

        do
        {
            pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);

            // break after NOSCOPE, or END unless followed by END

            fSuccessful =    pdobj->_fNoScope
                          || (!pdobj->_fBegin && !fNextWasEnd);

            if (fSuccessful)
                break;

            fNextWasEnd = !pdobj->_fBegin;

        } while (ichnk--);

        if (!fSuccessful)
        {
            // break before text and BEGIN

            ichnk = 0;
            fSuccessful = !plocchnk->lsfgi.fFirstOnLine && pdobj->_fBegin;
            fBreakAfter = FALSE;
        }
    }
    else
    {
        if (pdobj->_fNoScope)
        {
            // break before NOSCOPE

            fSuccessful = TRUE;
        }
        else
        {
            // break before BEGIN preceeded by TEXT/END/NOSCOPE

            if (ichnk)
            {
                if (pdobj->_fBegin)
                {
                    CGlyphDobj * pdobjPrev = (CGlyphDobj *)(plocchnk->plschnk[ichnk-1].pdobj);

                    fSuccessful = pdobjPrev->_fNoScope || !pdobjPrev->_fBegin;
                }
                else
                {
                    fSuccessful = FALSE;
                }
            }
            else
            {
                fSuccessful = !plocchnk->lsfgi.fFirstOnLine && pdobj->_fBegin;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = fSuccessful ? brkcondPlease : brkcondNever;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakAfter ? plocchnk->plschnk[ichnk].dcp : 0;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Prev(G)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcond, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CGlyphDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(GlyphFindNextBreakChunk);

    BOOL         fSuccessful;
    BOOL         fBreakBefore = (pposichnk->ichnk == ichnkOutside);
    long         ichnk = fBreakBefore
                         ? 0
                         : long(pposichnk->ichnk);
    CGlyphDobj * pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);
    LSERR        lserr;

    WHEN_DBG( CLineServices * pLS = pdobj->GetPLS() );

    if (fBreakBefore)
    {
        //                         Second DOBJ
        //
        //                       TEXT   NOSCOPE   BEGIN    END
        //            --------+-------+--------+--------+--------
        //   First    TEXT    |  n/a  | before | before |  no
        //    DOBJ    NOSCOPE | after | after  | after  | after
        //            BEGIN   |   no  | after  |  no    |  no
        //            END     | after | after  | after  |  no
        //

        BOOL fPrevWasEnd = TRUE;

        do
        {
            pdobj = (CGlyphDobj *)(plocchnk->plschnk[ichnk].pdobj);

            // break after NOSCOPE, or END unless followed by END

            fSuccessful =    pdobj->_fNoScope
                          || (pdobj->_fBegin && fPrevWasEnd);

            if (fSuccessful)
                break;

            fPrevWasEnd = !pdobj->_fBegin;

        } while (++ichnk < long(plocchnk->clschnk) );

        if (!fSuccessful)
        {
            // break after END

            ichnk = long(plocchnk->clschnk) - 1;
            fSuccessful = !pdobj->_fBegin;
            fBreakBefore = FALSE;
        }
    }
    else
    {
        if (pdobj->_fNoScope)
        {
            // break after NOSCOPE

            fSuccessful = TRUE;
        }
        else
        {
            // break after END followed by TEXT/BEGIN/NOSCOPE

            if (ichnk < (long(plocchnk->clschnk) - 1))
            {
                if (!pdobj->_fBegin)
                {
                    CGlyphDobj * pdobjNext = (CGlyphDobj *)(plocchnk->plschnk[ichnk+1].pdobj);

                    fSuccessful = pdobjNext->_fNoScope || pdobjNext->_fBegin;
                }
                else
                {
                    fSuccessful = TRUE;
                }
            }
            else
            {
                fSuccessful = !pdobj->_fBegin;
            }
        }
    }

    pbrkout->fSuccessful = fSuccessful;
    pbrkout->brkcond = fSuccessful ? brkcondPlease : brkcondNever;
    pbrkout->posichnk.ichnk = ichnk;
    pbrkout->posichnk.dcp = fBreakBefore ? 0 : plocchnk->plschnk[ichnk].dcp;

    lserr = pdobj->QueryObjDim(&pbrkout->objdim);

    DumpBrkopt( "Next(G)", pLS->_fMinMaxPass, plocchnk, pposichnk, brkcond, pbrkout );

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//              It is possible for pfnFindPrevBreakChunk to be called even when 
//              the right margin occurs beyond the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::FindPrevBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break after chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridFindPrevBreakChunk);

    LSERR   lserr = lserrNone;
    BOOL    fSuccessful;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? long(plocchnk->clschnk) - 1L
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? plocchnk->plschnk[ichnk].dcp
                    : pposichnk->dcp;

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (fBreakAfter && brkcond != brkcondNever)
    {
        // Break at end of chunk
        pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineAfter);
        lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, NULL, pbrkout);
    }
    else
    {
        LSCP    cpBreak = 0;
        BRKPOS  brkpos;
        OBJDIM  objdimSubline;

        if (pdobjLG->_fCanBreak)
        {
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

            lserr = LsFindPrevBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                           pdobjLG->LSCPLocal2Global(dcp),
                                           urSublineColumnMax, &fSuccessful, 
                                           &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
        {
            // Cannot break  inside object
            fSuccessful = FALSE;
            brkpos = brkposBeforeFirstDnode;
        }

        // 1. Unsuccessful or break before first DNode
        if (    !fSuccessful 
            ||  (fSuccessful && brkpos == brkposBeforeFirstDnode))
        {
            if (ichnk == 0)
            {
                //
                // First in the chunk, cannot break.
                //
                // If cp of this object is the same as cp of the first run in the line
                // don't allow breaking before this object. In this case set 'brkcondNever'.
                // This allows us to handle following situation:
                // <REV beg><REV end><LG beg><REV beg>some_te|xt<REV end><LF end>
                //
                BRKCOND brkcondNew = brkcondPlease;
                if (pdobjLG->_por->Cp() == pdobjLG->_pilsobj->_pLS->_listCurrent._pHead->Cp())
                    brkcondNew = brkcondNever;

                lserr = pdobjLG->FillBreakData(FALSE, brkcondNew, ichnk, dcp, NULL, pbrkout);
            }
            else 
            {
                // Put break at the end of previous DNode
                --ichnk;
                pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineAfter);
                lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, NULL, pbrkout);
            }
        }
        // 2. Successful break after last DNode
        else if (brkpos == brkposAfterLastDnode)
        {
            if (fBreakAfter && brkcond == brkcondNever) // Can not reset dcp
            {
                // Original position was "outside" and we were not allowed to break "after",
                // so we are trying another previous break if possible

                POSICHNK posichnk;
                posichnk.ichnk = ichnk;
                posichnk.dcp = dcp - 1;

                return FindPrevBreakChunk(plocchnk, &posichnk, brkcond, pbrkout);
            }
            else // Can reset dcp
            {
                // We reset dcp of the break so it happends after object but in break
                // record we remember that we should call SetBreakSubline with brkkindPrev
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, &objdimSubline, pbrkout);
            }
        }
        // 3. Successful break inside subline
        else
        {
            dcp = pdobjLG->LSCPGlobal2Local(cpBreak);

            pdobjLG->SetSublineBreakRecord(brkkindPrev, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, pbrkout->brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
    }

    DumpBrkopt("Prev(LG)", pdobjLG->GetPLS()->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout);

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindNextBreakChunk (static member, LS callback)
//
//  Synopsis:   Line Services calls pfnFindPrevBreakChunk to find a break 
//              opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::FindNextBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    BRKCOND brkcond,        // IN:  recommmendation about the break before chunk
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridFindNextBreakChunk);

    LSERR   lserr = lserrNone;
    OBJDIM  objdimSubline;
    BOOL    fSuccessful;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? 0
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? 1 // 1, not 0, because dcp means "cpLim" of the truncation point
                    : pposichnk->dcp;

    WHEN_DBG( BRKCOND brkcondIn = brkcond );

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (fBreakAfter && brkcond != brkcondNever)
    {
        // Break before the chunk
        ZeroMemory (&objdimSubline, sizeof(objdimSubline));
        dcp = 0;

        lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
    }
    else
    {
        LSCP    cpBreak;
        BRKPOS  brkpos = brkposBeforeFirstDnode; // keep compiler happy

        if (pdobjLG->_fCanBreak)
        {
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

            lserr = LsFindNextBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                           pdobjLG->_lscpStart + dcp - 1,
                                           urSublineColumnMax, &fSuccessful, 
                                           &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
        }
        else
        {
            // Cannot break inside object
            fSuccessful = FALSE;
            cpBreak = 0; // keep compiler happy
        }

        // 1. Unsuccessful
        if (!fSuccessful)
        {
            if (ichnk == (long)plocchnk->clschnk - 1)
            {
                // Last in the chunk, cannot break
                lserr = pdobjLG->FillBreakData(FALSE, brkcondPlease, ichnk, dcp, NULL, pbrkout);
                
                // Break condition is not next => have to store break record
                pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineAfter);
            }
            else 
            {
                // Put break at the end of object
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineAfter);
                lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, NULL, pbrkout);
            }
        }
        // 2. Successful break after last DNode
        else if (brkpos == brkposAfterLastDnode)
        {
            // We reset dcp of the break so it happends after object but in break
            // record we remember that we should call SetBreakSubline
            dcp = plocchnk->plschnk[ichnk].dcp;

            pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
        // 3. Successful break inside subline
        else
        {
            dcp = cpBreak - pdobjLG->_lscpStart;

            pdobjLG->SetSublineBreakRecord(brkkindNext, breakSublineInside);
            lserr = pdobjLG->FillBreakData(TRUE, brkcond, ichnk, dcp, &objdimSubline, pbrkout);
        }
    }

    DumpBrkopt("Next(LG)", pdobjLG->GetPLS()->_fMinMaxPass, plocchnk, pposichnk, brkcondIn, pbrkout);

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   ForceBreakChunk (static member, LS callback)
//
//  Synopsis:   If neither of pfnFindNextBreakChunk or pfnFindPrevBreakChunk 
//              methods returns a valid break and Line Services requires 
//              a break in this chunk, Line Services calls pfnForceBreakChunk 
//              to force a break opportunity.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::ForceBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(ForceBreakChunk);
    TraceTag((tagTraceILSBreak,
              "CDobjBase::ForceBreakChunk(ichnk=%d)",
              pposichnk->ichnk));

    ZeroMemory( pbrkout, sizeof(BRKOUT) );

    pbrkout->fSuccessful = fTrue;

    if (   plocchnk->lsfgi.fFirstOnLine
        && pposichnk->ichnk == 0
        || pposichnk->ichnk == ichnkOutside)
    {
        CDobjBase * pdobj = (CDobjBase *)plocchnk->plschnk[0].pdobj;

        pbrkout->posichnk.dcp = plocchnk->plschnk[0].dcp;
        pdobj->QueryObjDim(&pbrkout->objdim);
    }
    else
    {
        pbrkout->posichnk.ichnk = pposichnk->ichnk;
        pbrkout->posichnk.dcp = 0;
    }

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   ForceBreakChunk(static member, LS callback)
//
//  Synopsis:   If neither of pfnFindNextBreakChunk or pfnFindPrevBreakChunk 
//              methods returns a valid break and Line Services requires 
//              a break in this chunk, Line Services calls pfnForceBreakChunk 
//              to force a break opportunity.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CLayoutGridDobj::ForceBreakChunk(
    PCLOCCHNK plocchnk,     // IN:  locchnk to break
    PCPOSICHNK pposichnk,   // IN:  place to start looking for break
    PBRKOUT pbrkout)        // OUT: results of breaking
{
    LSTRACE(LayoutGridForceBreakChunk);
    TraceTag((tagTraceILSBreak,
              "CLayoutGridDobj::ForceBreakChunk(ichnk=%d)",
              pposichnk->ichnk));

    LSERR   lserr = lserrNone;
    OBJDIM  objdimSubline;
    BOOL    fBreakAfter = pposichnk->ichnk == ichnkOutside;
    long    ichnk = fBreakAfter
                    ? 0
                    : long(pposichnk->ichnk);
    LSDCP   dcp   = fBreakAfter
                    ? 1 // 1, not 0, because dcp means "cpLim" of the truncation point
                    : pposichnk->dcp;

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;

    if (plocchnk->lsfgi.fFirstOnLine && (ichnk == 0))
    {
        // Object is the first on line (can not break before)

        Assert(dcp >= 1 && dcp <= plocchnk->plschnk[ichnk].dcp);

        BOOL fEmpty = TRUE;
        lserr = LssbFIsSublineEmpty(pdobjLG->_plssubline, &fEmpty);

        if (fEmpty || !pdobjLG->_fCanBreak)
        {
            // Can not ForceBreak empty subline
            ichnk = 0;
            pdobjLG = (CLayoutGridDobj *)plocchnk->plschnk[ichnk].pdobj;
            dcp = plocchnk->plschnk[ichnk].dcp;

            pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineAfter);
            lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, NULL, pbrkout);
        }
        else
        {
            // Subline is not empty => do force break
            LSCP    cpBreak;
            BRKPOS  brkpos;
            long    urSublineColumnMax = pdobjLG->AdjustColumnMax(plocchnk->lsfgi.urColumnMax);

            lserr = LsForceBreakSubline(pdobjLG->_plssubline, plocchnk->lsfgi.fFirstOnLine,
                                        pdobjLG->_lscpStart + dcp - 1,
                                        urSublineColumnMax, 
                                        &cpBreak, &objdimSubline, &brkpos);
            if (lserr != lserrNone)
                goto Cleanup;
    
            Assert(brkpos != brkposBeforeFirstDnode);

            if (brkpos == brkposAfterLastDnode)
            {
                // We reset dcp so that closing brace stays on the same line
                dcp = plocchnk->plschnk[ichnk].dcp;

                pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);
            }
            else
            {
                // ForceBreak inside subline.
                dcp = cpBreak - pdobjLG->_lscpStart;

                pdobjLG->SetSublineBreakRecord(brkkindForce, breakSublineInside);
                lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);
            }
        }
    }
    else
    {
        // Can break before ichnk
        ZeroMemory (&objdimSubline, sizeof(objdimSubline));
        dcp = 0;

        lserr = pdobjLG->FillBreakData(TRUE, brkcondPlease, ichnk, dcp, &objdimSubline, pbrkout);

        // Do not need to save break record when break "before", because it will be
        // translated by manager to SetBreak (previous_dnode, ImposeAfter)
    }

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::SetBreak(
    PDOBJ pdobj,                    // IN:  dobj which is broken
    BRKKIND brkkind,                // IN:  Previous/Next/Force/Imposed was chosen
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: actual number of used elements in array
{
    LSTRACE(SetBreak);

    // This function is called telling us that a new break has occured
    // in the line that we're in.  This is so we can adjust our geometry
    // for it.  We're not gonna do that.  So we ignore it.
    // This function is actually a lot like a "commit" saying that the
    // break is actually being used.  The break is discovered using
    // findnextbreak and findprevbreak functions, and truncate and stuff
    // like that.

    return lserrNone;
}


//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::SetBreak(
    PDOBJ pdobj,                    // IN:  dobj which is broken
    BRKKIND brkkind,                // IN:  Previous/Next/Force/Imposed was chosen
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: actual number of used elements in array
{
    LSTRACE(NOBRSetBreak);
    LSERR lserr = lserrNone;

    CNobrDobj *pdobjNOBR = (CNobrDobj*)pdobj;

    if (pdobjNOBR->_fCanBreak)
    {
        if (nBreakRecord < 1)
        {
            lserr = lserrInsufficientBreakRecBuffer;
            goto Cleanup;
        }

        lserr = LsSetBreakSubline(  pdobjNOBR->_plssubline, brkkind, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        (*pnActualBreakRecord) += 1;

        rgBreakRecord[0].idobj = CLineServices::LSOBJID_NOBR;
        rgBreakRecord[0].cpFirst = pdobjNOBR->_lscpStart;
    }
    
Cleanup:    
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   SetBreak(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to notify you to break an object because 
//              it is straddling the margin.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::SetBreak(
    PDOBJ pdobj,                    // IN:  subline context
    BRKKIND brkkind,                // IN:  Prev/Next/Force/Imposed
    DWORD nBreakRecord,             // IN:  size of array
    BREAKREC* rgBreakRecord,        // OUT: array of break records
    DWORD* pnActualBreakRecord)     // OUT: number of used elements of the array
{
    LSTRACE(LayoutGridSetBreak);

    LSERR lserr = lserrNone;
    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;

    if (nBreakRecord < 1) 
        return lserrInsufficientBreakRecBuffer;
    
    if (    brkkind == brkkindImposedAfter
        ||  pdobjLG->GetSublineBreakRecord(brkkind) == breakSublineAfter)
    {
        // Break is ater DNone
        lserr = LsSetBreakSubline(  pdobjLG->_plssubline, brkkindImposedAfter, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        if (lserr != lserrNone) 
            goto Cleanup;

        Assert (*pnActualBreakRecord == 0);
    }
    else
    {
        OBJDIM  objdimSubline;
        LSTFLOW lstflowDontCare;
        LONG    lObjWidth;

        lserr = LsSetBreakSubline(  pdobjLG->_plssubline, brkkind, 
                                    nBreakRecord-1, &rgBreakRecord[1], 
                                    pnActualBreakRecord);
        if (lserr != lserrNone) 
            goto Cleanup;

        (*pnActualBreakRecord) += 1;

        rgBreakRecord[0].idobj = CLineServices::LSOBJID_LAYOUTGRID;
        rgBreakRecord[0].cpFirst = pdobjLG->_lscpStartObj;

        // Update subline information
        lserr = LssbGetObjDimSubline(pdobjLG->_plssubline, &lstflowDontCare, &objdimSubline);
        if (lserr != lserrNone) 
            goto Cleanup;
        lObjWidth = pdobjLG->GetPLS()->GetClosestGridMultiple(  pdobjLG->GetPLS()->GetCharGridSize(), 
                                                                objdimSubline.dur);
        pdobjLG->_uSublineOffset = (lObjWidth - objdimSubline.dur) / 2;
        pdobjLG->_uSubline = objdimSubline.dur;
    }

Cleanup:

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSpecialEffectsInside(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to get the special effects flags for 
//              the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::GetSpecialEffectsInside(
    PDOBJ pdboj,        // IN:  dobj
    UINT* pEffectsFlag) // OUT: Special effects inside of this object
{
    LSTRACE(GetSpecialEffectsInside);

    *pEffectsFlag = 0;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetSpecialEffectsInside(static member, LS callback)
//
//  Synopsis:   Called by LsCreateLine to get the special effects flags for 
//              the object.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::GetSpecialEffectsInside(
    PDOBJ pdobj,        // IN:  dobj
    UINT* pEffectsFlag) // OUT: Special effects inside of this object
{
    LSTRACE(LayoutGridGetSpecialEffectsInside);

    return LsGetSpecialEffectsSubline(((CLayoutGridDobj *)pdobj)->_plssubline, pEffectsFlag);
}

//-----------------------------------------------------------------------------
//
//  Function:   FExpandWithPrecedingChar(static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::FExpandWithPrecedingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the preceding char
    WCHAR wchar,            // IN:  preceding character
    MWCLS mwcls,            // IN:  ModWidth class of preceding character
    BOOL* pfExpand)         // OUT: expand preceding character?
{
    LSTRACE(FExpandWithPrecedingChar);

    *pfExpand = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   FExpandWithFollowingChar(static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::FExpandWithFollowingChar(
    PDOBJ pdobj,            // IN:  dobj
    PLSRUN plsrun,          // IN:  plsrun of the object
    PLSRUN plsrunText,      // IN:  plsrun of the following char
    WCHAR wchar,            // IN:  following character
    MWCLS mwcls,            // IN:  ModWidth class of the following character
    BOOL* pfExpand)         // OUT: expand object?
{
    LSTRACE(FExpandWithFollowingChar);

    *pfExpand = TRUE;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine )   // IN:  this object is last visible object on line
{
    LSTRACE(CalcPresentation);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine)    // IN:  this object is last visible object on line
{
    LSTRACE(NobrCalcPresentation);

    // This is taken from the Reverse object's code (in robj.c).

    CNobrDobj* pNobr= (CNobrDobj*)pdobj;

    LSERR lserr;
    BOOL fDone;

    /* Make sure that justification line has been made ready for presentation */
    lserr = LssbFDonePresSubline(pNobr->_plssubline, &fDone);

    if ((lserrNone == lserr) && !fDone)
    {
        lserr = LsMatchPresSubline(pNobr->_plssubline);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CalcPresentation (static member, LS callback)
//
//  Synopsis:   This function is called from LsDisplayLine, only if there is 
//              a custom object on the line.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::CalcPresentation(
    PDOBJ pdobj,                // IN:  dobj
    long dup,                   // IN:  dup of dobj
    LSKJUST lskjust,            // IN:  current justification mode
    BOOL fLastVisibleOnLine)    // IN:  this object is last visible object on line
{
    LSTRACE(LayoutGridCalcPresentation);

    LSERR lserr;
    BOOL fDone;
    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;

    // Make sure that justification line has been made ready for presentation
    lserr = LssbFDonePresSubline(pdobjLG->_plssubline, &fDone);
    if ((lserrNone == lserr) && !fDone)
    {
        lserr = LsMatchPresSubline(pdobjLG->_plssubline);
    }

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CreateQueryResult(static member)
//
//  Synopsis:   Common routine to fill in query output record for Query methods.
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR 
CDobjBase::CreateQueryResult(
    PLSSUBL plssubl,        // IN:  subline of ruby
    long dupAdj,            // IN:  u offset of start of subline
    long dvpAdj,            // IN:  v offset of start of subline
    PCLSQIN plsqin,         // IN:  query input
    PLSQOUT plsqout)        // OUT: query output
{
    // I agree with my dimensions reported during formatting
    ZeroMemory(plsqout, sizeof(LSQOUT));
    plsqout->heightsPresObj = plsqin->heightsPresRun;
    plsqout->dupObj = plsqin->dupRun;
    // I am not terminal object and here is my subline for you to continue querying
    plsqout->plssubl = plssubl;
    // My subline starts with offset
    plsqout->pointUvStartSubline.u += dupAdj;
    plsqout->pointUvStartSubline.v += dvpAdj;

    // I am not terminal, so textcell should not be filled by me.
    ZeroMemory(&plsqout->lstextcell, sizeof(plsqout->lstextcell));

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(EmbeddedQueryPointPcp);

    CLineServices* pLS = pdobj->GetPLS();
    CFlowLayout * pFlowLayout = pLS->_pFlowLayout;
    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);
    CLayout * pLayout = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() );
    long xWidth;

    ZeroMemory( plsqOut, sizeof(LSQOUT) );

    pLS->_pMeasurer->GetSiteWidth( pLayout->ElementOwner()->GetFirstBranch(), pLayout, pLS->_pci, FALSE, 0, &xWidth);

    plsqOut->dupObj  = xWidth;
    plsqOut->plssubl = NULL;

    // Element conent may be NULL in empty container.
    // TODO LRECT 112511: are we doing the right thing in that case?
    CElement *pElementContent = pLayout->ElementContent();
    if (pElementContent)
    {
        plsqOut->lstextcell.cpStartCell = pElementContent->GetFirstCp();
        plsqOut->lstextcell.cpEndCell   = pElementContent->GetLastCp();
    }

    plsqOut->lstextcell.dupCell      = xWidth;
    plsqOut->lstextcell.pCellDetails = NULL;

    return lserrNone;
}


//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(NobrQueryPointPcp);

    CNobrDobj * pdobjNB = (CNobrDobj *)pdobj;
    return CreateQueryResult(pdobjNB->_plssubline, 0, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(GlyphQueryPointPcp);
    CGlyphDobj *pGlyphdobj = DYNCAST(CGlyphDobj, pdobj);

    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);

    ZeroMemory( plsqOut, sizeof(LSQOUT) );

    plsqOut->dupObj  = pGlyphdobj->_RenderInfo.width;
    plsqOut->plssubl = NULL;

    plsqOut->lstextcell.cpStartCell = plsrun->_lscpBase;
    plsqOut->lstextcell.cpEndCell   = plsrun->_lscpBase + 1;

    plsqOut->lstextcell.dupCell      = pGlyphdobj->_RenderInfo.width;
    plsqOut->lstextcell.pCellDetails = NULL;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryPointPcp (static member, LS callback)
//
//  Synopsis:   ...
//
//  Returns:    lserrNone
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::QueryPointPcp(
    PDOBJ pdobj,            // IN:  dobj to query
    PCPOINTUV pptuvQuery,   // IN:  query point (uQuery,vQuery)
    PCLSQIN plsqIn,         // IN:  query input
    PLSQOUT plsqOut)        // OUT: query output
{
    LSTRACE(LayoutGridQueryPointPcp);

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;
    return CreateQueryResult(pdobjLG->_plssubline, pdobjLG->_uSublineOffset, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
// It's not documented, but I'm guessing that this routine is asking for
// a bounding box around the foreign object.
// From the quill code:
//    "Given a CP, we return the dimensions of the object.
//     Because we have a simple setup where there is only one dobj per CP,
//     it is easy to do."
LSERR WINAPI
CEmbeddedDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(EmbeddedQueryCpPpoint);

    CLineServices* pLS = pdobj->GetPLS();
    CFlowLayout * pFlowLayout = pLS->_pFlowLayout;

    PLSRUN plsrun = PLSRUN(plsqIn->plsrun);  // why do I have to cast this?
    CLayout * pLayout = plsrun->GetLayout(pFlowLayout, pLS->GetLayoutContext() );
    long xWidth;
    pLS->_pMeasurer->GetSiteWidth( pLayout->ElementOwner()->GetFirstBranch(), pLayout, pLS->_pci, FALSE, 0, &xWidth);

    // Do we need to set cpStartCell and cpEndCell?

    plsqOut->plssubl= NULL;
    plsqOut->lstextcell.dupCell= xWidth;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN: rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(NobrQueryCpPpoint);

    CNobrDobj * pdobjNB = (CNobrDobj *)pdobj;
    return CreateQueryResult(pdobjNB->_plssubline, 0, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(GlyphQueryCpPpoint);
    CGlyphDobj *pGlyphdobj = DYNCAST(CGlyphDobj, pdobj);

    // Do we need to set cpStartCell and cpEndCell?
    plsqOut->plssubl= NULL;
    plsqOut->lstextcell.dupCell= pGlyphdobj->_RenderInfo.width;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryCpPpoint (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::QueryCpPpoint(
    PDOBJ pdobj,            // IN:  dobj to query
    LSDCP dcp,              // IN:  dcp for the query
    PCLSQIN plsqIn,         // IN:  rectangle info of querying dnode
    PLSQOUT plsqOut)        // OUT: rectangle info of this cp
{
    LSTRACE(LayoutGridQueryCpPpoint);

    CLayoutGridDobj * pdobjLG = (CLayoutGridDobj *)pdobj;
    return CreateQueryResult(pdobjLG->_plssubline, pdobjLG->_uSublineOffset, 0, plsqIn, plsqOut);
}

//-----------------------------------------------------------------------------
//
//  Function:   Enum (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CDobjBase::Enum(
    PDOBJ pdobj,                // IN:  dobj to enumerate
    PLSRUN plsrun,              // IN:  from DNODE
    PCLSCHP plschp,             // IN:  from DNODE
    LSCP cpFirst,               // IN:  from DNODE
    LSDCP dcp,                  // IN:  from DNODE
    LSTFLOW lstflow,            // IN:  text flow
    BOOL fReverseOrder,         // IN:  enumerate in reverse order
    BOOL fGeometryNeeded,       // IN:
    const POINT * pptStart,     // IN:  starting position, iff fGeometryNeeded
    PCHEIGHTS pheightsPres,     // IN:  from DNODE, relevant iff fGeometryNeeded
    long dupRun)                // IN:  from DNODE, relevant iff fGeometryNeeded
{
    LSTRACE(Enum);

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Enum (static member, LS callback)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::Enum(
    PDOBJ pdobj,                // IN:  dobj to enumerate
    PLSRUN plsrun,              // IN:  from DNODE
    PCLSCHP plschp,             // IN:  from DNODE
    LSCP cpFirst,               // IN:  from DNODE
    LSDCP dcp,                  // IN:  from DNODE
    LSTFLOW lstflow,            // IN:  text flow
    BOOL fReverseOrder,         // IN:  enumerate in reverse order
    BOOL fGeometryNeeded,       // IN:
    const POINT * pptStart,     // IN:  starting position, iff fGeometryNeeded
    PCHEIGHTS pheightsPres,     // IN:  from DNODE, relevant iff fGeometryNeeded
    long dupRun)                // IN:  from DNODE, relevant iff fGeometryNeeded
{
    LSTRACE(EmbeddedEnum);

    CLineServices *pLS = pdobj->GetPLS();

    //
    // During a min-max pass, we set the width of the dobj to the minimum
    // width.  The maximum width therefore is off by the delta amount.
    //

    pLS->_dvMaxDelta += ((CEmbeddedDobj *)pdobj)->_dvMinMaxDelta;

    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CEmbeddedDobj::Display(      // this = PDOBJ pdobj,
    PDOBJ pdobj,             // IN:  dobj to display
    PCDISPIN pdispin)        // IN:  input display info
{
    LSTRACE(EmbeddedDisplay);

    PLSRUN plsrun = PLSRUN(pdispin->plsrun);
    CEmbeddedILSObj *pEmbeddedILSObj = DYNCAST(CEmbeddedILSObj, DYNCAST(CEmbeddedDobj, pdobj)->_pilsobj);
    CLSRenderer  *pRenderer = pEmbeddedILSObj->_pLS->GetRenderer();

    //
    // Ignore the return value of this, but the call updates the _xAccumulatedWidth
    // if the run needs to be skipped. This allows following runs to be displayed
    // correctly if they are relatively positioned (Bug 46346).
    // NOTE RTL (alexmog, 1/19/00): _xAccumulatedWidth is debug-only now.
    //
    pRenderer->ShouldSkipThisRun(plsrun, pdispin->dup);
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI 
CNobrDobj::Display(         // this = PDOBJ pdobj,
    PDOBJ pdobj,            // IN:  dobj to display
    PCDISPIN pdispin)       // IN:  input display info
{
    LSTRACE(NobrDisplay);

    CNobrDobj* pNobr= (CNobrDobj *)pdobj;

    return LsDisplaySubline(pNobr->_plssubline, // The subline to be drawn
                            &pdispin->ptPen,    // The point at which to draw the line
                            pdispin->kDispMode, // Draw in transparent mode
                            pdispin->prcClip    // The clipping rectangle
                           );
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::Display(         // this = PDOBJ pdobj,
    PDOBJ pdobj,             // IN:  dobj to display
    PCDISPIN pdispin)        // IN:  input display info
{
    LSTRACE(GlyphDisplay);

    CGlyphRenderInfoType *pRenderInfo = &(DYNCAST(CGlyphDobj, pdobj)->_RenderInfo);
    extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);

    if (pRenderInfo->pImageContext)
    {
        CRect rc;
        PLSRUN plsrun = PLSRUN(pdispin->plsrun);
        CGlyphILSObj *pGlyphILSObj = DYNCAST(CGlyphILSObj, DYNCAST(CGlyphDobj, pdobj)->_pilsobj);
        CLSRenderer  *pRenderer = pGlyphILSObj->_pLS->GetRenderer();

        if (pRenderer->ShouldSkipThisRun(plsrun, pdispin->dup))
            goto Cleanup;

        pRenderer->_ptCur.x = rc.left = pdispin->ptPen.x - pRenderer->GetChunkOffsetX();
        rc.right = rc.left + pRenderInfo->width;

        rc.bottom = pdispin->ptPen.y + pRenderer->_li._yHeight - pRenderer->_li._yDescent;
        rc.top    = rc.bottom - pRenderInfo->height;

        if (!rc.FastIntersects(pRenderer->_pDI->_rcClip))
            goto Cleanup;

        // TODO TEXT 112556 (grzegorz): we want to either wrap this (and deal with bitmap rotation),
        //                        or to use a TT font for glyphs. The latter may not be an option
        //                        if we have client-customizable glyphs
        HDC rawHDC = 0; // keep compiler happy
        CSize sizeTranslate = g_Zero.size; // keep compiler happy
        if (pRenderer->_hdc.GetTranslatedDC(&rawHDC, &sizeTranslate))
        {
            CRect rcTranslated(rc);
            rcTranslated.OffsetRect(sizeTranslate);
            pRenderInfo->pImageContext->Draw(rawHDC, &rcTranslated);
        }
        else
        {
            // TODO TEXT 112556 donmarsh (9/14/99): For now, we handle translation, but not scaling or rotation.
            //                          In the future, we will rev the IImgCtx interface to accept a
            //                          matrix along with the HDC.  We will query for the enhanced interface
            //                          here.  If we are in a rotated or scaled context, we will only render
            //                          if we can call the enhanced interface.
            // AssertSz(FALSE, "Can't display glyph with complex transformation");
            // HACKHACK (grzegorz): To support glyphs in case of complex transformations
            // we need this BIG HACK. This is safe to do, because we know implementation details.
            ((CImgCtx*)pRenderInfo->pImageContext)->Draw(pRenderer->_hdc, &rc);
        }

        if (plsrun->_fSelected)
            DrawTextSelectionForRect(pRenderer->_hdc, &rc, &rc, plsrun->GetCF()->SwapSelectionColors());
    }

Cleanup:
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   Display (static member, LS callback)
//
//  Synopsis:   Calculates the positions of the various lines for the display 
//              and then displays them
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::Display(   // this = PDOBJ pdobj,
    PDOBJ pdobj,            // IN:  dobj to display
    PCDISPIN pdispin)       // IN:  input display info
{
    LSTRACE(LayoutGridDisplay);

    CLayoutGridDobj* pdobjLG= (CLayoutGridDobj *)pdobj;

    // The subline needs to be shifted in U direction
    POINT ptPenNew = pdispin->ptPen;
    ptPenNew.y += (pdispin->lstflow & fUVertical) ? pdobjLG->_uSublineOffset : 0;
    ptPenNew.x += (pdispin->lstflow & fUVertical) ? 0 : pdobjLG->_uSublineOffset;

    return LsDisplaySubline(pdobjLG->_plssubline, // The subline to be drawn
                            &ptPenNew,            // The point at which to draw the line
                            pdispin->kDispMode,   // Draw in transparent mode
                            pdispin->prcClip      // The clipping rectangle
                           );
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CEmbeddedDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(EmbeddedDestroyDObj);
    delete (CEmbeddedDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CNobrDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(NobrDestroyDObj);
    LsDestroySubline(((CNobrDobj *)pdobj)->_plssubline);
    delete (CNobrDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CGlyphDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(GlyphDestroyDObj);
    delete (CGlyphDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   DestroyDObj (static member, LS callback)
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLayoutGridDobj::DestroyDObj(
    PDOBJ pdobj)        // IN:  dobj to destroy
{
    LSTRACE(LayoutGridDestroyDObj);
    LsDestroySubline(((CLayoutGridDobj *)pdobj)->_plssubline);
    delete (CLayoutGridDobj *)pdobj;
    return lserrNone;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBrkcondBefore (member)
//
//-----------------------------------------------------------------------------
BRKCOND
CNobrDobj::GetBrkcondBefore(COneRun * por)
{
    if (_brkcondBefore == brkcondUnknown)
    {
        if (!por->_fIsArtificiallyStartedNOBR)
        {
            CLineServices::BRKCLS brkcls, dummy;

            // find the first character of the nobr.
            while (!por->IsNormalRun())
            {
                por = por->_pNext;
            }

            if (por->_pchBase != NULL)
            {
                GetPLS()->GetBreakingClasses( por, por->_lscpBase, por->_pchBase[0], &brkcls, &dummy );
                _brkcondBefore = CLineServices::s_rgbrkcondBeforeChar[brkcls];
            }
            else
            {
                _brkcondBefore = brkcondPlease;
            }
        }
        else
        {
            _brkcondBefore = brkcondNever;
        }               
    }

    return _brkcondBefore;
}

//-----------------------------------------------------------------------------
//
//  Function:   GetBrkcondAfter (member)
//
//-----------------------------------------------------------------------------
BRKCOND
CNobrDobj::GetBrkcondAfter(COneRun * por, LONG dcp)
{
    if (_brkcondAfter == brkcondUnknown)
    {
        if (!por->_fIsArtificiallyTerminatedNOBR)
        {
            CLineServices::BRKCLS brkcls, dummy;
            COneRun * porText = por;

            // find the last character of the nobr.
            // the last cp is the [endnobr] character, which we're not interested in; hence
            // the loop stops at 1

            while (dcp > 1)
            {
                if (por->IsNormalRun())
                    porText = por;

                dcp -= por->_lscch;
                por = por->_pNext;
            };

            if (porText->_pchBase != NULL)
            {
                GetPLS()->GetBreakingClasses( porText, porText->_lscpBase+porText->_lscch-1, porText->_pchBase[porText->_lscch-1], &brkcls, &dummy );
                _brkcondAfter = CLineServices::s_rgbrkcondAfterChar[brkcls];
            }
            else
            {
                _brkcondAfter = brkcondPlease;
            }
        }
        else
        {
            _brkcondAfter = brkcondNever;
        }
    }

    return _brkcondAfter;
}

//-----------------------------------------------------------------------------
//
//  Function:   QueryObjDim (member)
//
//  Synopsis:   Calculates object's dimention.
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR 
CDobjBase::QueryObjDim(POBJDIM pobjdim)
{
    return LsdnQueryObjDimRange(GetPLS()->_plsc, _plsdnTop, _plsdnTop, pobjdim);
}

//-----------------------------------------------------------------------------
//
//  Function:   FillBreakData (member)
//
//  Synopsis:   
//
//  Returns:    lserrNone if the function is successful.
//
//-----------------------------------------------------------------------------
LSERR 
CLayoutGridDobj::FillBreakData( BOOL fSuccessful,       // IN
                                BRKCOND brkcond,        // IN
                                LONG ichnk,             // IN
                                LSDCP dcp,              // IN
                                POBJDIM pobjdimSubline, // IN
                                PBRKOUT pbrkout)        // OUT
{
    LSERR lserr = lserrNone;

    pbrkout->fSuccessful = fSuccessful;
    if (brkcond == brkcondPlease || brkcond == brkcondCan || brkcond == brkcondNever)
        pbrkout->brkcond = brkcond;
    else
        pbrkout->brkcond = brkcondPlease;


    if (fSuccessful)
    {
        pbrkout->posichnk.ichnk = ichnk;
        pbrkout->posichnk.dcp = dcp;
    }

    if (pobjdimSubline)
    {
        pbrkout->objdim = *pobjdimSubline;
        pbrkout->objdim.dur = GetPLS()->GetClosestGridMultiple(GetPLS()->GetCharGridSize(), pobjdimSubline->dur);
    }
    else
    {
        lserr = QueryObjDim(&pbrkout->objdim);
    }
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AdjustColumnMax (member)
//
//  Synopsis:   Reduces passed width to closest grid multiplication.
//
//  Returns:    calculated width.
//
//-----------------------------------------------------------------------------
LONG 
CLayoutGridDobj::AdjustColumnMax(LONG urColumnMax)
{
    LONG lGridSize = GetPLS()->GetCharGridSize();
    LONG urNewColumnMax = GetPLS()->GetClosestGridMultiple(lGridSize, urColumnMax);
    if (urColumnMax != urNewColumnMax)
    {
        // Adjusted width has to be not greated then 'urColumnMax', 
        // so we need to decrease it.
        urNewColumnMax -= lGridSize;
    }
    return urNewColumnMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\onerun.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module ONERUN.CXX -- line services one run interface.
 *
 *
 *  Owner: <nl>
 *      Sujal Parikh <nl>
 *
 *  History: <nl>
 *      5/6/97     sujalp created
 *
 *  Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LINESRV_HXX_
#define X_LINESRV_HXX_
#include "linesrv.hxx"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_LSRENDER_HXX_
#define X_LSRENDER_HXX_
#include "lsrender.hxx"
#endif

#ifndef X_ONERUN_HXX_
#define X_ONERUN_HXX_
#include "onerun.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X__UNIWBK_H_
#define X__UNIWBK_H_
#include "uniwbk.h"
#endif

ExternTag(tagLSCallBack);

#if DBG == 1 || defined(DUMPRUNS)
long COneRunFreeList::s_NextSerialNumber = 0;
MtDefine(CLineServicesDumpList_aryLsqsubinfo_pv, Locals, "CLineServices::DumpList::aryLsqsubinfo_pv");
#endif

//-----------------------------------------------------------------------------
//
//  Function:   Deinit
//
//  Synopsis:   This function is called during the destruction of the
//              COneRunFreeList. It frees up any allocated COneRun objects.
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
COneRunFreeList::Deinit()
{
    COneRun *por;
    COneRun *porNext;

    por = _pHead;
    while (por)
    {
        Assert(por->_pCF == NULL);
        Assert(por->_pCFOriginal == NULL);
        Assert(por->_pComplexRun == NULL);
        porNext = por->_pNext;
        delete por;
        por = porNext;
    }
}

//-----------------------------------------------------------------------------
//
//  Function: Clone
//
//  Synopsis: Clones a one run object making copies of all the stuff which
//            is needed.
//
//  Returns:  The cloned run -- either this or NULL depending upon if we could
//            allocate mem for subobjects.
//
//-----------------------------------------------------------------------------
COneRun *
COneRun::Clone(COneRun *porClone)
{
    COneRun *porRet = this;

    // Copy over all the memory
    memcpy (this, porClone, sizeof(COneRun));
    
    _pchBase = NULL;

    // If we have a pcf then it needs to be cloned too
    if (_fMustDeletePcf)
    {
        Assert(porClone->GetCF() != NULL);
        _pCF = new CCharFormat(*(porClone->GetCF()));
        if (!_pCF)
        {
            _fMustDeletePcf = FALSE;
            porRet = NULL;
            goto Cleanup;
        }
    }

    // Clone the CStr properly.
    memset (&_cstrRunChars, 0, sizeof(CStr));
    _cstrRunChars.Set(porClone->_cstrRunChars);

    // Cloned runs do not inherit their selection status from the guy
    // it clones from
    _fSelected = FALSE;
    
    // Setup the complex run related stuff properly
    porRet->_pComplexRun = NULL;
    porRet->_lsCharProps.fGlyphBased = FALSE;
    porRet->SetSidFromTreePos(porClone->_ptp);

    // Structure stuff should not copy
    porRet->_pNext = porRet->_pPrev = NULL;

Cleanup:
    return porRet;
}

//-----------------------------------------------------------------------------
//
//  Function: GetFreeOneRun
//
//  Synopsis: Gets a free one run object. If we already have some in the free
//            list, then we need to use those, else allocate off the heap.
//            If porClone is non-NULL then we will clone in that one run
//            into the newly allocated one.
//
//  Returns:  The run
//
//-----------------------------------------------------------------------------
COneRun *
COneRunFreeList::GetFreeOneRun(COneRun *porClone)
{
    COneRun *por = NULL;

    if (_pHead)
    {
        por = _pHead;
        _pHead = por->_pNext;
    }
    else
    {
        por = new COneRun();
    }
    if (por)
    {
        if (porClone)
        {
            if (por != por->Clone(porClone))
            {
                SpliceIn(por);
                por = NULL;
                goto Cleanup;
            }
        }
        else
        {
            memset(por, 0, sizeof(COneRun));
            por->_bConvertMode = CM_UNINITED;
        }
        
#if DBG == 1 || defined(DUMPRUNS)
        por->_nSerialNumber = s_NextSerialNumber++;
#endif
    }
Cleanup:    
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceIn
//
//  Synopsis:   Returns runs which are no longer needed back to the free list.
//              It also uninits all the runs.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunFreeList::SpliceIn(COneRun *pFirst)
{
    Assert(pFirst);
    COneRun *por = pFirst;
    COneRun *porLast = NULL;
    
    // Clear out the runs when they are put into the free list.
    while(por)
    {
        porLast = por;
        por->Deinit();

        // TODO(SujalP): por->_pNext is valid after Deinit!!!! Change this so
        // that this code does not depend on this.
        por = por->_pNext;
    }

    Assert(porLast);
    porLast->_pNext = _pHead;
    _pHead = pFirst;
}

//-----------------------------------------------------------------------------
//
//  Function:   Init
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::Init()
{
    _pHead = _pTail = NULL;
}

//-----------------------------------------------------------------------------
//
//  Function:   Deinit
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::Deinit()
{
    Assert(_pHead == NULL && _pTail == NULL);
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceOut
//
//  Synopsis:   Removes a chunk of runs from pFirst to pLast from the current list.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::SpliceOut(COneRun *pFirst, COneRun *pLast)
{
    Assert(pFirst && pLast);
    
    //
    // If the first node being removed is the head node then
    // let us deal with that
    //
    if (pFirst->_pPrev == NULL)
    {
        Assert(pFirst == _pHead);
        _pHead = pLast->_pNext;
    }
    else
    {
        pFirst->_pPrev->_pNext = pLast->_pNext;
    }

    //
    // If the last node being removed is the tail node then
    // let us deal with that
    //
    if (pLast->_pNext == NULL)
    {
        Assert(pLast == _pTail);
        _pTail = pFirst->_pPrev;
    }
    else
    {
        pLast->_pNext->_pPrev = pFirst->_pPrev;
    }

    //
    // Clear the next and prev pointers in the spliced out portion
    //
    pFirst->_pPrev = NULL;
    pLast->_pNext = NULL;
}

#if DBG==1
//-----------------------------------------------------------------------------
//
//  Function:   VerifyStuff
//
//  Synopsis:   A debug only function which verifies that the state of the
//              current onerun list is good.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::VerifyStuff(CLineServices *pLS)
{
    COneRun *por = _pHead;
    LONG lscp;
    LONG cchSynths;
    
    if (!por)
        goto Cleanup;
    lscp = por->_lscpBase;
    cchSynths = por->_chSynthsBefore;
    
    while (por)
    {
        Assert(por->_lscch == por->_lscchOriginal);
        Assert(por->_lscpBase == lscp);
        lscp += (por->IsAntiSyntheticRun() ? 0 : por->_lscch);
        
        Assert(cchSynths == por->_chSynthsBefore);
        cchSynths += por->IsSyntheticRun() ? por->_lscch : 0;
        cchSynths -= por->IsAntiSyntheticRun() ? por->_lscch : 0;

        // NestedElement should be true if NestedLayout is true.
        Assert(!por->_fCharsForNestedLayout || por->_fCharsForNestedElement);
        // Nestedlayout should be true if nestedrunowner is true.
        Assert(!por->_fCharsForNestedRunOwner || por->_fCharsForNestedLayout);
        
        // NOTE: non Pseudo MBP one runs can have a _iPEI.
        Assert((por->_fIsPseudoMBP) ? (por->GetFF()->_iPEI >= 0) : TRUE);
        
        por = por->_pNext;
    }

    por = _pTail;
    Assert(por);
    if (por->_fNotProcessedYet)
    {
        // Only one not processed yet run at the end
        por = por->_pPrev;
        while (por)
        {
            Assert(!por->_fNotProcessedYet);
            por = por->_pPrev;
        }
    }
    
Cleanup:
    return;
}
#endif

//-----------------------------------------------------------------------------
//
//  Function:   SpliceInAfterMe
//
//  Synopsis:   Adds pFirst into the currentlist after the position
//              indicated by pAfterMe. If pAfterMe is NULL its added to the head.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
#if DBG==1
COneRunCurrList::SpliceInAfterMe(CLineServices *pLS, COneRun *pAfterMe, COneRun *pFirst)
#else
COneRunCurrList::SpliceInAfterMe(COneRun *pAfterMe, COneRun *pFirst)
#endif
{
    COneRun **ppor;
#if DBG==1
    COneRun *pOldTail = _pTail;
#endif
    
    WHEN_DBG(VerifyStuff(pLS));
    
    ppor = (pAfterMe == NULL) ? &_pHead : &pAfterMe->_pNext;
    pFirst->_pNext = *ppor;
    *ppor = pFirst;
    pFirst->_pPrev = pAfterMe;
    
    COneRun *pBeforeMe = pFirst->_pNext;
    ppor = pBeforeMe == NULL ? &_pTail : &pBeforeMe->_pPrev;
    *ppor = pFirst;

#if DBG==1    
    {
        LONG chSynthsBefore = 0;

        if (pOldTail != NULL)
        {
            chSynthsBefore = pOldTail->_chSynthsBefore;

            chSynthsBefore += pOldTail->IsSyntheticRun()     ? pOldTail->_lscch : 0;
            chSynthsBefore -= pOldTail->IsAntiSyntheticRun() ? pOldTail->_lscch : 0;
        }
        
        Assert(chSynthsBefore == pFirst->_chSynthsBefore);
    }
#endif
}

//-----------------------------------------------------------------------------
//
//  Function:   SpliceInBeforeMe
//
//  Synopsis:   Adds the onerun identified by pFirst before the run
//              identified by pBeforeMe. If pBeforeMe is NULL then it
//              adds it at the tail.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
COneRunCurrList::SpliceInBeforeMe(COneRun *pBeforeMe, COneRun *pFirst)
{
    COneRun **ppor;

    ppor = pBeforeMe == NULL ? &_pTail : &pBeforeMe->_pPrev;
    pFirst->_pPrev = *ppor;
    *ppor = pFirst;
    pFirst->_pNext = pBeforeMe;

    COneRun *pAfterMe = pFirst->_pPrev;
    ppor = pAfterMe == NULL ? &_pHead : &pAfterMe->_pNext;
    *ppor = pFirst;
}

//-----------------------------------------------------------------------------
//
//  Function:   DiscardOneRuns
//
//  Synopsis:   Removes all the runs from the current list and gives them
//              back to the free list.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
void
CLineServices::DiscardOneRuns()
{
    COneRun *pFirst = _listCurrent._pHead;
    COneRun *pTail  = _listCurrent._pTail;
    
    if (pFirst)
    {
        _listCurrent.SpliceOut(pFirst, pTail);
        _listFree.SpliceIn(pFirst);
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   AdvanceOneRun
//
//  Synopsis:   This is our primary function to get the next run at the
//              frontier.
//
//  Returns:    The one run.
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::AdvanceOneRun(LONG lscp)
{
    COneRun *por;
    BOOL fRet = FALSE;
    
    //
    // Get the memory for a one run
    //
    por = _listFree.GetFreeOneRun(NULL);
    if (!por)
        goto Cleanup;

    // Setup the lscp...
    por->_lscpBase = lscp;
    
    if (!_treeInfo._fHasNestedElement)
    {
        //
        // If we have run out of characters in the tree pos then we need
        // advance to the next tree pos.
        //
        if (!_treeInfo.GetCchRemainingInTreePos())
        {
            if (!_treeInfo.AdvanceTreePos(LC_TO_FC(GetLayoutContext())))
                goto Cleanup;
            por->_fCannotMergeRuns = TRUE;
        }

        //
        // If we have run out of characters in the text then we need
        // to advance to the next text pos
        //
        if (!_treeInfo._cchValid)
        {
            if (!_treeInfo.AdvanceTxtPtr())
                goto Cleanup;
            por->_fCannotMergeRuns = TRUE;
        }

        Assert(_treeInfo._lscpFrontier == lscp);
    }

    //
    // If we have a nested run owner then the number of characters given to
    // the run are the number of chars in that nested run owner. Else the
    // number of chars is the minimum of the chars in the tree pos and that
    // in the text node.
    //
    if (!_treeInfo._fHasNestedElement)
    {
        por->_lscch = min(_treeInfo.GetCchRemainingInTreePosReally(),
                          _treeInfo._cchValid);

        if (_lsMode == LSMODE_MEASURER)
        {
            por->_lscch = min(por->_lscch, MAX_CHARS_FETCHRUN_RETURNS);
        }
        else
        {
            // NB Additional 5 chars corresponds to a fudge factor.
#if DBG==1
            if (!((CDisplay*)_pMeasurer->_pdp)->_fBuildFontList)
#endif
                por->_lscch = min(por->_lscch, LONG(_pMeasurer->_li._cch + 5));
        }
        AssertSz(por->_lscch > 0 || _treeInfo.IsNonEdgePos(), "Cannot measure 0 or -ve chars!");

        por->_pchBase = _treeInfo._pchFrontier;
    }
    else
    {
        //
        // NOTE(SujalP): The number of characters _returned_ to LS will not be
        // _lscch. We will catch this case in FetchRun and feed only a single
        // char with the pch pointing to a valid location so that LS does not
        // choke on it.
        //
        CElement *pElemNested = _treeInfo._ptpFrontier->Branch()->Element();

        por->_lscch = GetNestedElementCch(pElemNested);
        por->_fCannotMergeRuns = TRUE;
        por->_pchBase = NULL;
        por->_fCharsForNestedElement  = TRUE;
        por->_fCharsForNestedLayout   = _treeInfo._fHasNestedLayout;
        por->_fCharsForNestedRunOwner = _treeInfo._fHasNestedRunOwner;
    }

    //
    // Update all the other information in the one run
    //
    por->_fIsNonEdgePos = _treeInfo.IsNonEdgePos();
    por->_chSynthsBefore = _treeInfo._chSynthsBefore;
    por->_lscchOriginal = por->_lscch;
    por->_pchBaseOriginal = por->_pchBase;
    por->_ptp = _treeInfo._ptpFrontier;
    por->SetSidFromTreePos(por->_ptp);
    por->_mbpTop = _mbpTopCurrent;
    por->_mbpBottom = _mbpBottomCurrent;
    
    por->_pCF = (CCharFormat *)_treeInfo._pCF;
#if DBG == 1
    por->_pCFOriginal = por->_pCF;
#endif
    por->_fInnerCF = _treeInfo._fInnerCF;
    por->_pPF = _treeInfo._pPF;
    por->_fInnerPF = _treeInfo._fInnerPF;
    por->_pFF = _treeInfo._pFF;
    
    //
    // At last let us go and move out frontier
    //
    _treeInfo.AdvanceFrontier(por);
    
    fRet = TRUE;
    
Cleanup:
    if (!fRet && por)
    {
        delete por;
        por = NULL;
    }
    
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   CanMergeTwoRuns
//
//  Synopsis:   Decided if the 2 runs can be merged into one
//
//  Returns:    BOOL
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::CanMergeTwoRuns(COneRun *por1, COneRun *por2)
{
    BOOL fRet;
    
    if (   por1->_dwProps
        || por2->_dwProps
        || por1->_pCF != por2->_pCF
        || por1->_bConvertMode != por2->_bConvertMode
        || por1->_ccvBackColor.GetRawValue() != por2->_ccvBackColor.GetRawValue()
        || por1->_pComplexRun
        || por2->_pComplexRun
        || (por1->_pchBase + por1->_lscch != por2->_pchBase) // happens with passwords.
       )
        fRet = FALSE;
    else
        fRet = TRUE;
    return fRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   MergeIfPossibleIntoCurrentList
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::MergeIfPossibleIntoCurrentList(COneRun *por)
{
    COneRun *pTail = _listCurrent._pTail;
    if (   pTail != NULL
        && CanMergeTwoRuns(pTail, por)
       )
    {
        Assert(pTail->_lscpBase + pTail->_lscch == por->_lscpBase);
        Assert(pTail->_pchBase  + pTail->_lscch == por->_pchBase);
        Assert(!pTail->_fNotProcessedYet); // Cannot merge into a run not yet processed
        
        pTail->_lscch += por->_lscch;
        pTail->_lscchOriginal += por->_lscchOriginal;
        
        //
        // Since we merged our por into the previous one, let us put the
        // present one back on the free list.
        //
        _listFree.SpliceIn(por);
        por = pTail;
    }
    else
    {
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, pTail, por);
#else
        _listCurrent.SpliceInAfterMe(pTail, por);
#endif
    }
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   SplitRun
//
//  Synopsis:   Splits a single run into 2 runs. The original run remains
//              por and the number of chars it has is cchSplitTill, while
//              the new split off run is the one which is returned and the
//              number of characters it has is cchOriginal-cchSplit.
//
//  Returns:    The 2nd run (which we got from cutting up por)
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::SplitRun(COneRun *por, LONG cchSplitTill)
{
    LONG cchDelta;
    
    //
    // Create an exact copy of the run
    //
    COneRun *porNew = _listFree.GetFreeOneRun(por);
    if (!porNew)
        goto Cleanup;
    por->_lscch = cchSplitTill;
    cchDelta = por->_lscchOriginal - por->_lscch;
    por->_lscchOriginal = por->_lscch;
    Assert(por->_lscch);
    
    //
    // Then setup the second run so that it can be spliced in properly
    //
    porNew->_pPrev = porNew->_pNext = NULL;
    porNew->_lscpBase += por->_lscch;
    porNew->_lscch = cchDelta;
    porNew->_lscchOriginal = porNew->_lscch;
    porNew->_pchBase = por->_pchBaseOriginal + cchSplitTill;
    porNew->_pchBaseOriginal = porNew->_pchBase;
    porNew->_fGlean = TRUE;
    porNew->_fNotProcessedYet = TRUE;
    porNew->_fIsBRRun = FALSE;
    Assert(porNew->_lscch);
    
#if DBG==1
    if (por->_fSelected)
    {
        Assert(!porNew->_pComplexRun);
        Assert(!porNew->_fSelected);
    }
#endif

    //
    // New run needs original CCharFormat
    //
    if (porNew->_fMustDeletePcf)
    {
        porNew->_fMustDeletePcf = FALSE;
        delete porNew->_pCF;
        porNew->_pCF = (CCharFormat *)porNew->_ptp->GetBranch()->GetCharFormat();
        Assert(porNew->_pCF == porNew->_pCFOriginal);
    }

Cleanup:
    return porNew;
}


//-----------------------------------------------------------------------------
//
//  Function:   AttachOneRunToCurrentList
//
//  Note: We always return the pointer to the run which is contains the
//  lscp for por. Consider the following cases:
//  1) No splitting:
//          If merged then return the ptr of the run we merged por into
//          If not merged then return por itself
//  2) Splitting:
//          Split into por and porNew
//          If por is merged then return ptr of the run we merged por into
//          If not morged then return por itself
//          Just attach/merge porNew
//
//  Returns:    The attached/merged-into run.
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::AttachOneRunToCurrentList(COneRun *por)
{
    COneRun *porRet;

    Assert(por);
    Assert(por->_lscchOriginal >= por->_lscch);

    if (por->_lscchOriginal > por->_lscch)
    {
        Assert(por->IsNormalRun());
        COneRun *porNew = SplitRun(por, por->_lscch);
        if (!porNew)
        {
            porRet = NULL;
            goto Cleanup;
        }

        //
        // Then splice in the current run and then the one we split out.
        //
        porRet = MergeIfPossibleIntoCurrentList(por);

        // can replace this with a SpliceInAfterMe
        MergeIfPossibleIntoCurrentList(porNew);
    }
    else
        porRet = MergeIfPossibleIntoCurrentList(por);

Cleanup:
    return porRet;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendSynth
//
//  Synopsis:   Appends a synthetic into the current one run store.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendSynth(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    COneRun *pTail = _listCurrent._pTail;
    LONG     lscp  = por->_lscpBase;
    LSERR    lserr = lserrNone;
    BOOL     fAdd;
    LONG     lscpLast;
    
    // Atmost one node can be un-processed
    if (pTail && pTail->_fNotProcessedYet)
    {
        pTail = pTail->_pPrev;
    }

    if (pTail)
    {
        lscpLast  = pTail->_lscpBase + (pTail->IsAntiSyntheticRun() ? 0 : pTail->_lscch);
        Assert(lscp <= lscpLast);
        if (lscp == lscpLast)
        {
            fAdd = TRUE;
        }
        else
        {
            fAdd = FALSE;
            while (pTail)
            {
                Assert(pTail->_fNotProcessedYet == FALSE);
                if (pTail->_lscpBase == lscp)
                {
                    Assert(pTail->IsSyntheticRun());
                    *pporOut = pTail;
                    break;
                }
                pTail = pTail->_pNext;
            }

            if (NULL == *pporOut)
            {
                lserr = lserrOutOfMemory;
                AssertSz(*pporOut, "Cannot find the synthetic char which should have been there!");
            }
        }
    }
    else
        fAdd = TRUE;

    if (fAdd)
    {
        COneRun *porNew;
        
        porNew = _listFree.GetFreeOneRun(por);
        if (!porNew)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }

        //
        // Tell our clients which run the synthetic character was added
        //
        *pporOut = porNew;
        
        //
        // Let us change our synthetic run
        //
        porNew->MakeRunSynthetic();
        porNew->FillSynthData(synthtype);
        
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, pTail, porNew);
#else
        _listCurrent.SpliceInAfterMe(pTail, porNew);
#endif
        
        //
        // Now change the original one run itself
        //
        por->_lscpBase++;       // for the synthetic character
        por->_chSynthsBefore++;
        
        //
        // Update the tree info
        //
        _treeInfo._lscpFrontier++;
        _treeInfo._chSynthsBefore++;
    }
    
Cleanup:
    WHEN_DBG(_listCurrent.VerifyStuff(this));
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   FillSynthData
//
//  Synopsis:   Fills information about a synthetic into the run
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------
void
COneRun::FillSynthData(CLineServices::SYNTHTYPE synthtype)
{
    const CLineServices::SYNTHDATA & synthdata = CLineServices::s_aSynthData[synthtype];
    
    _lscch = 1;
    _lscchOriginal = 1;
    _synthType = synthtype;
    _pchBase = (TCHAR *)&synthdata.wch;
    _pchBaseOriginal = _pchBase;
    _fHidden = synthdata.fHidden;
    _lsCharProps.idObj = synthdata.fObjStart ? synthdata.idObj : CLineServices::LSOBJID_TEXT;
    _fIsStartOrEndOfObj = synthdata.fObjStart || synthdata.fObjEnd;
    _fCharsForNestedElement  = FALSE;
    _fCharsForNestedLayout   = FALSE;
    _fCharsForNestedRunOwner = FALSE;

    // We only want the run to be considered processed if it is a true synthetic.
    // For the normal runs with synthetic data, this flag will be turned off
    // later in the FetchRun code.
    _fNotProcessedYet = IsSyntheticRun() ? FALSE : TRUE;
    
    _fCannotMergeRuns = TRUE;
    _fGlean = FALSE;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendAntiSynthetic
//
//  Synopsis:   Appends a anti-synthetic run
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendAntiSynthetic(COneRun *por)
{
    LSERR lserr = lserrNone;
    LONG  cch   = por->_lscch;

    Assert(por->IsAntiSyntheticRun());
    Assert(por->_lscch == por->_lscchOriginal);
    
    //
    // If the run is not in the list yet, please go and add it to the list
    //
    if (   por->_pNext == NULL
        && por->_pPrev == NULL
       )
    {
#if DBG==1
        _listCurrent.SpliceInAfterMe(this, _listCurrent._pTail, por);
#else
        _listCurrent.SpliceInAfterMe(_listCurrent._pTail, por);
#endif
    }

    //
    // This run has now been processed
    //
    por->_fNotProcessedYet = FALSE;

    //
    // Update the tree info
    //
    _treeInfo._lscpFrontier   -= cch;
    _treeInfo._chSynthsBefore -= cch;

    //
    // Now change all the subsequent runs in the list
    //
    por = por->_pNext;
    while(por)
    {
        por->_lscpBase       -= cch;
        por->_chSynthsBefore -= cch;
        por = por->_pNext;
    }
    
    WHEN_DBG(_listCurrent.VerifyStuff(this));
    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Member:     CLineServices::TerminateLine
//
//  Synopsis:   Close any open LS objects. This will add end of object
//              characters to the synthetic store for any open LS objects and
//              also optionally add a synthetic WCH_SECTIONBREAK (fAddEOS).
//              If it adds any synthetic character it will set *psynthAdded to
//              the type of the first synthetic character added. FetchRun()
//              callers should be sure to check the *psynthAdded value; if it
//              is not SYNTHTYPE_NONE then the run should be filled using
//              FillSynthRun() and returned to Line Services.
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::TerminateLine(COneRun * por,
                             TL_ENDMODE tlEndMode,
                             COneRun **pporOut
                            )
{
    LSERR lserr = lserrNone;
    SYNTHTYPE synthtype;
    COneRun *porOut = NULL;
    COneRun *porRet;
    COneRun *pTail = _listCurrent._pTail;

    if (pTail)
    {
        int aObjRef[LSOBJID_COUNT];

        // Zero out the object refcount array.
        ZeroMemory( aObjRef, LSOBJID_COUNT * sizeof(int) );

        // End any open LS objects.
        for (; pTail; pTail = pTail->_pPrev)
        {
            if (!pTail->_fIsStartOrEndOfObj)
                continue;

            synthtype = pTail->_synthType;
            WORD idObj = s_aSynthData[synthtype].idObj;

            // If this synthetic character starts or stops an LS object...
            if (idObj != idObjTextChp)
            {
                // Adjust the refcount up or down depending on whether the object
                // is started or ended.
                if (s_aSynthData[synthtype].fObjEnd)
                {
                    aObjRef[idObj]--;
                }
                if (s_aSynthData[synthtype].fObjStart)
                {
                    aObjRef[idObj]++;
                }

                // If the refcount is positive we have an unclosed object (we're
                // walking backward). Close it.
                if (aObjRef[idObj] > 0)
                {
                    synthtype = s_aSynthData[synthtype].typeEndObj;
                    Assert(synthtype != SYNTHTYPE_NONE &&
                           s_aSynthData[synthtype].idObj == idObj &&
                           s_aSynthData[synthtype].fObjStart == FALSE &&
                           s_aSynthData[synthtype].fObjEnd == TRUE);

                    // If we see an open ruby object but the ruby main text
                    // has not been closed yet, then we must close it here
                    // before we can close off the ruby object by passing
                    // and ENDRUBYTEXT to LS.
                    if(idObj == LSOBJID_RUBY && _fIsRuby && !_fIsRubyText)
                    {
                        synthtype = SYNTHTYPE_ENDRUBYMAIN;
                        _fIsRubyText = TRUE;
                    }

                    lserr = AppendSynth(por, synthtype, &porRet);
                    if (lserr != lserrNone)
                    {
                        //
                        // NOTE(SujalP): The linker (even in debug build) will
                        // not link in DumpList() since it is not called anywhere.
                        // This call here forces the linker to link in the DumpList
                        // function, so that we can use it during debugging.
                        //
                        WHEN_DBG(DumpList());
                        WHEN_DBG(DumpFlags());
                        WHEN_DBG(DumpTree());
                        WHEN_DBG(_lineFlags.DumpFlags());
                        WHEN_DBG(DumpCounts());
                        WHEN_DBG(_lineCounts.DumpCounts());
                        WHEN_DBG(DumpUnicodeInfo(0));
                        WHEN_DBG(DumpSids(sidsAll));
                        WHEN_DBG(fc().DumpFontInfo());
                        goto Cleanup;
                    }

                    //
                    // Terminate line needs to return the pointer to the run
                    // belonging to the first synthetic character added.
                    //
                    if (!porOut)
                        porOut = porRet;
                    
                    aObjRef[idObj]--;
                    
                    Assert(aObjRef[idObj] == 0);
                }
            }
        }

        // All opened objects have been closed. Time to clean up any states.
        _cLayoutGridObjArtificial = 0;
    }

    if (tlEndMode != TL_ADDNONE)
    {
        // Add a synthetic section break character.  Note we add a section
        // break character as this has no width.
        synthtype = tlEndMode == TL_ADDLBREAK ? SYNTHTYPE_LINEBREAK : SYNTHTYPE_SECTIONBREAK;
        lserr = AppendSynth(por, synthtype, &porRet);
        if (lserr != lserrNone)
            goto Cleanup;

        porRet->_fNoTextMetrics = TRUE;

        if (tlEndMode == TL_ADDLBREAK)
        {
            porRet->_fMakeItASpace = TRUE;
            SetRenderingHighlights(porRet);
        }
        
        if (!porOut)
            porOut = porRet;
        
        por->_fIsBRRun = FALSE;
    }
    else
    {
        por->_fIsBRRun = TRUE;
        SetRenderingHighlights(por);
        if (por->IsSelected())
            por->_fMakeItASpace = TRUE;

    }

    // Lock up the synthetic character store. We've terminated the line, so we
    // don't want anyone adding any more synthetics.
    FreezeSynth();

Cleanup:
    *pporOut = porOut;
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::IsSynthEOL
//
//  Synopsis:   Determines if there is some synthetic end of line mark at the
//              end of the synthetic array.
//
//  Returns:    TRUE if the synthetic array is terminated by a synthetic EOL
//              mark; otherwise FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CLineServices::IsSynthEOL()
{
    COneRun *pTail = _listCurrent._pTail;
    SYNTHTYPE synthEnd = SYNTHTYPE_NONE;
    
    if (pTail != NULL)
    {
        if (pTail->_fNotProcessedYet)
            pTail = pTail->_pPrev;
        while (pTail)
        {
            if (pTail->IsSyntheticRun())
            {
                synthEnd = pTail->_synthType;
                break;
            }
            pTail = pTail->_pNext;
        }
    }

    return (   synthEnd == SYNTHTYPE_SECTIONBREAK
            || synthEnd == SYNTHTYPE_ENDPARA1
            || synthEnd == SYNTHTYPE_ALTENDPARA
           );
}

//-----------------------------------------------------------------------------
//
//  Function:   CPFromLSCPCore
//
//-----------------------------------------------------------------------------
LONG
CLineServices::CPFromLSCPCore(LONG lscp, COneRun **ppor)
{
    COneRun *por = _listCurrent._pHead;
    LONG     cp  = lscp;

    Assert(lscp >= por->_lscpBase);

    while (por)
    {
        if (por->IsAntiSyntheticRun())
            cp += por->_lscch;
        else if (   lscp >= por->_lscpBase
                 && lscp <  por->_lscpBase + por->_lscch
                )
            break;
        else if (por->IsSyntheticRun())
            cp--;
        por = por->_pNext;
    }

    if (ppor)
        *ppor = por;

    return cp;
}

//-----------------------------------------------------------------------------
//
//  Function:   LSCPFromCPCore
//
//  FUTURE(SujalP): The problem with this function is that it is computing lscp
//                  and is using it to terminate the loop. Probably the better
//                  approach would be to use Cp's to determine termination
//                  conditions. That would be a radical change and we leave
//                  that to be fixed in IE5+.
//
//                  Another change which we need to make is that we do not
//                  inc/dec the lscp (and cp in the function above) as we
//                  march along the linked list. All the loop has to do is
//                  ensure that we end up with the correct COneRun and from
//                  that it should be pretty easy for us to determine the
//                  lscp/cp to be returned.
//
//-----------------------------------------------------------------------------
LONG
CLineServices::LSCPFromCPCore(LONG cp, COneRun **ppor)
{
    COneRun *por = _listCurrent._pHead;
    LONG lscp = (cp < por->_lscpBase) ? por->_lscpBase : cp;

    while (por)
    {
        if (   lscp >= por->_lscpBase
            && lscp <  por->_lscpBase + por->_lscch
           )
            break;
        if (por->IsAntiSyntheticRun())
            lscp -= por->_lscch;
        else if (por->IsSyntheticRun())
            lscp++;
        por = por->_pNext;
    }

    // If we have stopped at an anti-synthetic it means that the cp is within this
    // run. This implies that the lscp is the same for all the cp's in this run.
    if (por && por->IsAntiSyntheticRun())
    {
        Assert(por->WantsLSCPStop());
        lscp = por->_lscpBase;
    }
    else
    {
        while(por && !por->WantsLSCPStop())
        {
            por = por->_pNext;
            lscp++;
        }
    }
    
    Assert( !por || por->WantsLSCPStop() );

    // It is possible that we can return a NULL por if there is a semi-valid
    // lscp that could be returned.
    if (ppor)
        *ppor = por;

    return lscp;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   FindOneRun
//
//  Synopsis:   Given an lscp, find the one run if it exists in the current list
//
//  Returns:    The one run
//
//-----------------------------------------------------------------------------
COneRun *
CLineServices::FindOneRun(LSCP lscp)
{
    COneRun *por = _listCurrent._pTail;

    if (!por)
    {
        por = NULL;
    }
    else if (lscp >= por->_lscpBase + por->_lscch)
    {
        por = NULL;
    }
    else
    {
        while (por)
        {
            if (   lscp >= por->_lscpBase
                && lscp <  por->_lscpBase + por->_lscch
               )
                break;
            por = por->_pPrev;
        }
    }
    return por;
}

//-----------------------------------------------------------------------------
//
//  Function:   FindPrevLSCP (member)
//
//  Synopsis:   Find the LSCP of the first actual character to preceed lscp.
//              Synthetic characters are ignored.
//
//  Returns:    LSCP of the character prior to lscp, ignoring synthetics. If no
//              characters preceed lscp, or lscp is beyond the end of the line,
//              then lscp itself is returned. Also returns a flag indicating if
//              any reverse objects exist between these two LSCPs.
//
//-----------------------------------------------------------------------------

LSCP
CLineServices::FindPrevLSCP(
    LSCP lscp,
    BOOL * pfReverse)
{
    COneRun * por;
    LSCP lscpPrev = lscp;
    BOOL fReverse = FALSE;

    // Find the por matching this lscp.
    por = FindOneRun(lscp);

    // If lscp was outside the limits of the line just bail out.
    if (por == NULL)
    {
        goto cleanup;
    }

    Assert(lscp >= por->_lscpBase && lscp < por->_lscpBase + por->_lscch);

    if (por->_lscpBase < lscp)
    {
        // We're in the midst of a run. lscpPrev is just lscp - 1.
        lscpPrev--;
        goto cleanup;
    }

    // Loop over the pors
    while (por->_pPrev != NULL)
    {
        por = por->_pPrev;

        // If the por is a reverse object set fReverse.
        if (por->IsSyntheticRun() &&
            s_aSynthData[por->_synthType].idObj == LSOBJID_REVERSE)
        {
            fReverse = TRUE;
        }

        // If the por is a text run then find the last lscp in it and break.
        if (por->IsNormalRun())
        {
            lscpPrev = por->_lscpBase + por->_lscch - 1;
            break;
        }
    }

cleanup:

    Assert(lscpPrev <= lscp);

    if (pfReverse != NULL)
    {
        // If we hit a reverse object but lscpPrev == lscp, then the reverse
        // object preceeds the first character in the line. In this case there
        // isn't actually a reverse object between the two LSCPs, since the
        // LSCPs are the same.
        *pfReverse = (fReverse && lscpPrev < lscp);
    }

    return lscpPrev;
}

//-----------------------------------------------------------------------------
//
//  Function:   FetchRun (member, LS callback)
//
//  Synopsis:   This is a key callback from lineservices.  LS calls this method
//              when performing LsCreateLine.  Here it is asking for a run, or
//              an embedded object -- whatever appears next in the stream.  It
//              passes us cp, and CLineServices (which we fool C++ into getting
//              to be the object of this method).  We return a bunch of stuff
//              about the next thing to put in the stream.
//
//  Returns:    lserrNone
//              lserrOutOfMemory
//
//-----------------------------------------------------------------------------
LSERR WINAPI
CLineServices::FetchRun(
    LSCP lscp,          // IN
    LPCWSTR* ppwchRun,  // OUT
    DWORD* pcchRun,     // OUT
    BOOL* pfHidden,     // OUT
    PLSCHP plsChp,      // OUT
    PLSRUN* pplsrun )   // OUT
{
    LSTRACE(FetchRun);

    LSERR         lserr = lserrNone;
    COneRun      *por;
    COneRun      *pTail;
    LONG          cchDelta;
    COneRun      *porOut;

    AssertSz(_lockRecrsionGuardFetchRun == FALSE,
             "Cannot call FetchRun recursively!");
    WHEN_DBG(_lockRecrsionGuardFetchRun = TRUE;)
            
    ZeroMemory(plsChp, sizeof(LSCHP));  // Otherwise, we're gonna forget and leave some bits on that we shouldn't.
    *pfHidden = FALSE;
    
    if (IsAdornment())
    {
        por = GetRenderer()->FetchLIRun(lscp, ppwchRun, pcchRun);
        CHPFromCF(por, por->GetCF());
        goto Cleanup;
    }

    pTail = _listCurrent._pTail;
    //
    // If this was already cached before
    //
    if (lscp < _treeInfo._lscpFrontier)
    {
        Assert(pTail);
        Assert(_treeInfo._lscpFrontier == pTail->_lscpBase + pTail->_lscch);
        WHEN_DBG(_listCurrent.VerifyStuff(this));
        while (pTail)
        {
            if (lscp >= pTail->_lscpBase)
            {
                //
                // Should never get a AS run since the actual run will the run
                // following it and we should have found that one before since
                // we are looking from the end.
                //
                Assert(!pTail->IsAntiSyntheticRun());
                
                // We should be in this run since 1) if check above 2) walking backwards
                AssertSz(lscp <  pTail->_lscpBase + pTail->_lscch, "Inconsistent linked list");
               
                //
                // Gotcha. Got a previously cached one
                //
                por = pTail;
                Assert(por->_lscchOriginal == por->_lscch);
                cchDelta = lscp - por->_lscpBase;
                if (por->_fGlean)
                {
                    // We never have to reglean a synth or an antisynth run
                    Assert(por->IsNormalRun());

                    //
                    // NOTE(SujalP+MikeJoch):
                    // This can never happen because ls always fetches sequentially.
                    // If this happened it would mean that we were asked to fetch
                    // part of the run which was not gleaned. Hence the part before
                    // this one was not gleaned and hence not fetched. This violates
                    // the fact that LS will fetch all chars before the present one
                    // atleast once before it fetches the present one.
                    //
                    AssertSz(cchDelta == 0, "CAN NEVER HAPPEN!!!!");
#if 0
                    //
                    // If we are going to glean info from a run, then we need
                    // to split out the run if the lscp is not at the beginning
                    // of that run -- this is needed to avoid gleaning chars
                    // in por which are before lscp
                    //
                    if (cchDelta)
                    {
                        
                        // We cannot be asked to split an unprocessed run...
                        Assert(!por->_fNotProcessedYet);
                        
                        Assert(lscp > por->_lscpBase);

                        COneRun *porNew = SplitRun(por, cchDelta);
                        if (!porNew)
                        {
                            lserr = lserrOutOfMemory;
                            goto Cleanup;
                        }
#if DBG==1                        
                        _listCurrent.SpliceInAfterMe(this, por, porNew);
#else
                        _listCurrent.SpliceInAfterMe(por, porNew);
#endif
                        por = porNew;
                    }
#endif // if 0
                    
                    for(;;)
                    {
                        // We still have to be interested in gleaning
                        Assert(por->_fGlean);

                        // We will should never have a anti-synthetic run here
                        Assert(!por->IsAntiSyntheticRun());
                        
                        //
                        // Now go and glean information into the run ...
                        //
                        por->_xWidth = 0;
                        lserr = GleanInfoFromTheRun(por, &porOut);
                        if (lserr != lserrNone)
                            goto Cleanup;

                        //
                        // Did the run get marked as Antisynth. If so then
                        // we need to ignore that run and go onto the next one.
                        //
                        if (por->IsAntiSyntheticRun())
                        {
                            Assert(por == porOut);
                            
                            //
                            // The run was marked as an antisynthetic run. Be sure
                            // that no splitting was requested...
                            //
                            Assert(por->_lscch == por->_lscchOriginal);
                            Assert(por->_fNotProcessedYet);
                            AppendAntiSynthetic(por);
                            por = por->_pNext;
                        }
                        else
                            break;
                        
                        //
                        // If we ran out of already cached runs (all the cached runs
                        // turned themselves into anti-synthetics) then we need to
                        // advance the frontier and fetch new runs from the story.
                        //
                        if (por == NULL)
                            goto NormalProcessing;
                    }

                    //
                    // The only time a different run is than the one passed in is returned is
                    // when the run has not been procesed as yet, and during processing we
                    // notice that to process it we need to append a synthetic character.
                    // The case to handle here is:
                    // <table><tr><td nowrap>abcd</td></tr></table>
                    //
                    Assert(porOut == por || por->_fNotProcessedYet);

                    if (porOut != por)
                    {
                        //
                        // If we added a synthetic, then the present run should not be split!
                        //
                        Assert(por->_lscch == por->_lscchOriginal);
                        Assert(por->_fNotProcessedYet);
                        
                        //
                        // Remember we have to re-glean the information the next time we come around.
                        // However, we will not make the decision to append a synth that time since
                        // the synth has already been added this time and hence will fall into the
                        // else clause of this if and everything should be fine.
                        //
                        // DEPENDING ON WHETHER porOut WAS ADDED IN THE PRESENT GLEAN
                        // OR WAS ALREADY IN THE LIST, WE EITHER RETURN porOut OR por
                        //
                        por->_fGlean = TRUE;
                        por = porOut;
                    }
                    else
                    {
                        por->_fNotProcessedYet = FALSE;

                        //
                        // Did gleaning give us reason to further split the run?
                        //
                        if (por->_lscchOriginal > por->_lscch)
                        {
                            COneRun *porNew = SplitRun(por, por->_lscch);
                            if (!porNew)
                            {
                                lserr = lserrOutOfMemory;
                                goto Cleanup;
                            }

#if DBG==1
                            _listCurrent.SpliceInAfterMe(this, por, porNew);
#else
                            _listCurrent.SpliceInAfterMe(por, porNew);
#endif
                        }
                    }
                    por->_fGlean = FALSE;
                    cchDelta = 0;
                }

                //
                // This is our quickest way outta here! We had already done all
                // the hard work before so just reuse it here
                //
                *ppwchRun  = por->_pchBase + cchDelta;
                *pcchRun   = por->_lscch   - cchDelta;
                goto Cleanup;
            }
            pTail = pTail->_pPrev;
        } // while
        AssertSz(0, "Should never come here!");
    } // if


NormalProcessing:
    for(;;)
    {
        por = AdvanceOneRun(lscp);
        if (!por)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }

        lserr = GleanInfoFromTheRun(por, &porOut);
        if (lserr != lserrNone)
            goto Cleanup;
    
        Assert(porOut);

        if (por->IsAntiSyntheticRun())
        {
            Assert(por == porOut);
            AppendAntiSynthetic(por);
        }
        else
            break;
    }
    
    if (por != porOut)
    {
        *ppwchRun = porOut->_pchBase;
        *pcchRun  = porOut->_lscch;
        por->_fGlean = TRUE;
        por->_fNotProcessedYet = TRUE;
        Assert(por->_lscch == por->_lscchOriginal); // be sure no splitting takes place
        Assert(porOut->_fCannotMergeRuns);
        Assert(porOut->IsSyntheticRun());
        
        if (por->_lscch)
        {
            COneRun *porLastSynth = porOut;
            COneRun *porTemp = porOut;

            //
            // GleanInfoFromThrRun can add multiple synthetics to the linked
            // list, in which case we will have to jump across all of them
            // before we can add por to the list. (We need to add the por
            // because the frontier has already moved past that run).
            //
            while (porTemp && porTemp->IsSyntheticRun())
            {
                porLastSynth = porTemp;
                porTemp = porTemp->_pNext;
            }

            // FUTURE: porLastSynth should equal pTail.  Add a check for this, and
            // remove above while loop.
#if DBG==1        
            _listCurrent.SpliceInAfterMe(this, porLastSynth, por);
#else
            _listCurrent.SpliceInAfterMe(porLastSynth, por);
#endif
        }
        else
        {
            // Run not needed, please do not leak memory
            _listFree.SpliceIn(por);
        }
        
        // Finally remember that por is the run which we give to LS
        por = porOut;
    }
    else
    {
        por->_fNotProcessedYet = FALSE;
        *ppwchRun  = por->_pchBase;
        *pcchRun  = por->_lscch;
        por = AttachOneRunToCurrentList(por);
        if (!por)
        {
            lserr = lserrOutOfMemory;
            goto Cleanup;
        }
    }
    
Cleanup:
    if (lserr == lserrNone)
    {
        Assert(por);
        Assert(por->_lscch);
        
        //
        // We can never return an antisynthetic run to LS!
        //
        Assert(!por->IsAntiSyntheticRun());

        if (por->_fCharsForNestedLayout && !IsAdornment())
        {
            static const TCHAR chConst = _T('A');
            
            // Give LS a junk character in this case. Fini will jump
            // accross the number of chars actually taken up by the
            // nested run owner.
            *ppwchRun = &chConst;
            *pcchRun = 1;
        }
        
        *pfHidden  = por->_fHidden;
        *plsChp    = por->_lsCharProps;
        *(PLSRUN *)pplsrun = por;
    }
    else
    {
        *(PLSRUN *)pplsrun = NULL;
    }
    
    WHEN_DBG(_lockRecrsionGuardFetchRun = FALSE;)
    return lserr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLineServices::AppendILSControlChar
//
//  Synopsis:   Appends an ILS object control character to the synthetic store.
//              This function allows us to begin and end line services objects
//              by inserting the control characters that begin and end them
//              into the text stream. It also keeps track of the state of the
//              object stack at the end of the synthetic store and returns the
//              synthetic type that matches the first added charcter.
//
//              A curiousity of Line Services dictates that ILS objects cannot
//              be overlapped; it is not legal to have:
//
//                  <startNOBR><startReverse><endNOBR><endReverse>
//
//              If this case were to arise the <endNOBR> would get ignored and
//              the NOBR object would continue until the line was terminated
//              by a TerminateLine() call. Furthermore, the behavior of ILS
//              objects is not always inherited; the reverse object inside of
//              a NOBR will still break.
//
//              To get around these problems it is necessary to keep the object
//              stack in good order. We define a hierarchy of objects and make
//              certain that whenever a new object is created any objects which
//              are lower in the heirarchy are closed and reopened after the
//              new object is opened. (Smaller number means higher positioin in
//              hierarchy). The current hierarchy is:
//
//                  Ruby objects        (1)
//                  LayoutGrid objects  (1)
//                  Reverse objects     (2)
//                  NOBR objects        (3)
//                  Embedding objects   (4)
//
//              Additional objects (FE objects) will be inserted into this
//              heirarchy.
//
//              Embedding objects require no special handling due to their
//              special handling (recursive calls to line services).
//
//              If we apply our strategy to the overlapped case above, we will
//              end up with the following:
//
//                  <startNOBR><endNOBR><startReverse><startNOBR><endNOBR><endReverse>
//
//              As can be seen the objects are well ordered and each object's
//              start character is paired with its end character.
//
//              One problem which is introduced by this solution is the fact
//              that a break opprotunity is introduced between the two NOBR
//              objects. This can be fixed in the NOBR breaking code.
//
//  Returns:    An LSERR value. The function also returns synthetic character
//              at lscp in *psynthAdded. This is the first charcter added by
//              this function, NOT necessarily the character that matches idObj
//              and fOpen. For example (again using the case above) when we
//              ask to open the LSOBJID_REVERSE inside the NOBR object we will
//              return SYNTHTYPE_ENDNOBR in *psynthAdded (though we will also
//              append the SYNTHTYPE_REVERSE and START_NOBR to the store).
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendILSControlChar(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    Assert(synthtype > SYNTHTYPE_NONE && synthtype < SYNTHTYPE_COUNT);

    const SYNTHDATA & synthdata = s_aSynthData[synthtype];
    LSERR lserr = lserrNone;

    // We can only APPEND REAL OBJECTS to the store.
    Assert(   synthdata.idObj == LSOBJID_REVERSE
           || synthdata.idObj == LSOBJID_NOBR
           || synthdata.idObj == LSOBJID_RUBY
           || synthdata.idObj == LSOBJID_LAYOUTGRID);
    
    *pporOut = NULL;

    if (IsFrozen())
    {
        // We cannot add to the store if it is frozen.
        goto Cleanup;
    }

    if (synthdata.idObj != LSOBJID_NOBR)
    {
        // Open or close an object.
        lserr = AppendSynthClosingAndReopening(por, synthtype, pporOut);
        if (lserr != lserrNone)
            goto Cleanup;
    }
    else
    {
        // NOBR objects just need to be opened or closed. Note that we cannot
        // close an object unless it has been opened, nor can we open an object
        // if one is already open.
#if DBG == 1
        BOOL fOpen = synthdata.fObjStart;

        Assert(!!_fNoBreakForMeasurer != !!fOpen);

        if (!fOpen)
        {
            COneRun *porTemp = _listCurrent._pTail;
            BOOL fFoundTemp = FALSE;
            
            while (porTemp)
            {
                if (porTemp->IsSyntheticRun())
                {
                    CLineServices::SYNTHTYPE sType = porTemp->_synthType;
                
                    //it's OK to overlap with MBPOPEN/MBPCLOSE because they don't
                    //cause LS to create subline or use ILS object, they are just
                    //'special characters'
                    if (    sType != SYNTHTYPE_NOBR 
                        &&  sType != SYNTHTYPE_MBPOPEN 
                        &&  sType != SYNTHTYPE_MBPCLOSE)
                    {
                        AssertSz(0, "Should have found an STARTNOBR before any other synth");
                    }
                    fFoundTemp = TRUE;
                    break;
                }
                porTemp = porTemp->_pPrev;
            }
            AssertSz(fFoundTemp, "Did not find the STARTNOBR you are closing!");
        }
#endif
        lserr = AppendSynth(por, synthtype, pporOut);
        if (lserr != lserrNone)
            goto Cleanup;
    }

Cleanup:
    // Make sure the store is still in good shape.
    WHEN_DBG(_listCurrent.VerifyStuff(this));

    return lserr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AppendSynthClosingAndReopening
//
//  Synopsis:   Appends a synthetic into the current one run store, but first
//              closes all open LS objects, which are below in object's 
//              hierarchy, and then reopens them afterwards.
//
//  Returns:    LSERR
//
//-----------------------------------------------------------------------------
LSERR
CLineServices::AppendSynthClosingAndReopening(COneRun *por, SYNTHTYPE synthtype, COneRun **pporOut)
{
    Assert(s_aSynthData[synthtype].fObjStart || s_aSynthData[synthtype].fObjEnd);

    LSERR lserr = lserrNone;
    COneRun *porOut = NULL, *porTail;
    CStackDataAry<SYNTHTYPE, 16> arySynths(0);
    int aObjRef[LSOBJID_COUNT];
    int i;

    WORD idObj = s_aSynthData[synthtype].idObj;
    WORD idLevel = s_aSynthData[synthtype].idLevel;
    Assert(idLevel > 0);
    SYNTHTYPE curSynthtype;

    // Zero out the object refcount array.
    ZeroMemory(aObjRef, LSOBJID_COUNT * sizeof(int) );

    *pporOut = NULL;

    // End any open LS objects.
    for (porTail = _listCurrent._pTail; porTail; porTail = porTail->_pPrev)
    {
        if (!porTail->_fIsStartOrEndOfObj)
            continue;

        curSynthtype = porTail->_synthType;
        WORD curIdObj = s_aSynthData[curSynthtype].idObj;

        // If this synthetic character starts or stops an LS object...
        if (curIdObj != idObj)
        {
            // Adjust the refcount up or down depending on whether the object
            // is started or ended.
            if (s_aSynthData[curSynthtype].fObjEnd)
            {
                aObjRef[curIdObj]--;
            }
            if (s_aSynthData[curSynthtype].fObjStart)
            {
                aObjRef[curIdObj]++;
            }

            // If the refcount is positive we have an unclosed object (we're
            // walking backward). Close it, if necessary.
            if (aObjRef[curIdObj] > 0)
            {
                // When closing an object, we want to close any opened objects
                // at the same level. So, bump the level down.
                if (s_aSynthData[synthtype].fObjEnd)
                {
                    --idLevel;
                }

                // If opened object is below in the object's hierarchy (larger idLevel), 
                // close it.
                if (idLevel < s_aSynthData[curSynthtype].idLevel)
                {
                    arySynths.AppendIndirect(&curSynthtype);
                    curSynthtype = s_aSynthData[curSynthtype].typeEndObj;
                    Assert(   curSynthtype != SYNTHTYPE_NONE 
                           && s_aSynthData[curSynthtype].idObj == curIdObj 
                           && s_aSynthData[curSynthtype].fObjStart == FALSE 
                           && s_aSynthData[curSynthtype].fObjEnd == TRUE);

                    lserr = AppendSynth(por, curSynthtype, &porOut);
                    if (lserr != lserrNone)
                    {
                        goto Cleanup;
                    }
                    if (_fNoBreakForMeasurer && curSynthtype == SYNTHTYPE_ENDNOBR)
                    {
                        // We need to mark the starting por that it was artificially
                        // terminated, so we can break appropriate in the ILS handlers.
                        // Can't break after this END-NOBR
                        porTail->_fIsArtificiallyTerminatedNOBR = 1;            
                    }

                    if (*pporOut == NULL) 
                    {
                        *pporOut = porOut;
                    }
                }

                aObjRef[curIdObj]--;
                Assert(aObjRef[curIdObj] == 0);
            }
        }
        else
        {
#if DBG == 1
            if (idObj != LSOBJID_REVERSE)
            {
                // We don't allow object nesting of the same type
                Assert(s_aSynthData[synthtype].fObjStart || s_aSynthData[curSynthtype].fObjStart);
                Assert(s_aSynthData[synthtype].fObjEnd   || s_aSynthData[curSynthtype].fObjEnd);
            }
#endif
            break;
        }
    }

    // Append the synth that was passed in
    lserr = AppendSynth(por, synthtype, &porOut);
    if (lserr != lserrNone)
    {
        goto Cleanup;
    }
    if (*pporOut == NULL) 
    {
        *pporOut = porOut;
    }

    // Re-open the LS objects that we closed
    for (i = arySynths.Size(); i > 0; i--)
    {
        curSynthtype = arySynths[i-1];
        Assert(   curSynthtype != SYNTHTYPE_NONE 
               && s_aSynthData[curSynthtype].fObjStart == TRUE 
               && s_aSynthData[curSynthtype].fObjEnd == FALSE);
        lserr = AppendSynth(por, curSynthtype, &porOut);
        if (lserr != lserrNone)
        {
            goto Cleanup;
        }
        if (_fNoBreakForMeasurer && curSynthtype == SYNTHTYPE_NOBR)
        {
            // Can't break before this BEGIN-NOBR
            porOut->_fIsArtificiallyStartedNOBR = 1;            
        }
    }

Cleanup:
    // Make sure the store is still in good shape.
    WHEN_DBG(_listCurrent.VerifyStuff(this));

    return lserr;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   GetCharWidthClass
//
//  Synopsis:   Determines the characters width class within this run
//
//  Returns:    character width class
//
//-----------------------------------------------------------------------------
COneRun::charWidthClass
COneRun::GetCharWidthClass() const
{
    charWidthClass cwc = charWidthClassUnknown;

    if (_ptp->IsText() && IsNormalRun())
    {
        switch (_ptp->Sid())
        {
        case sidHan:
        case sidHangul:
        case sidKana:
        case sidBopomofo:
        case sidYi:
        case sidHalfWidthKana:
            cwc = charWidthClassFullWidth;
            break;

        case sidHebrew:
        case sidArabic:
            cwc = charWidthClassCursive;
            break;

        default:
            cwc = charWidthClassHalfWidth;
        }
    }
    return cwc;
}
   
//-----------------------------------------------------------------------------
//
//  Function:   GetTextDecorationColorFromAncestor
//
//  Synopsis:   Gets color of specified text decoration type from ancestor
//              of current node.
//
//  Returns:    color
//
//-----------------------------------------------------------------------------
CColorValue
COneRun::GetTextDecorationColorFromAncestor(ULONG td)
{
    CColorValue cv;
    CTreeNode * pNode = _ptp->GetBranch();
    CElement *  pElemTemp;

    do
    {
        // In case of FONT or BASEFONT tags we need to check if 'color'
        // attribute changed text color. If yes we need to use this color.
        // NOTE: CSS 'color' property has higher priority than 'color' attribute
        //       in this case we ignore 'color' attribute
        if (pNode->Tag() == ETAG_FONT || pNode->Tag() == ETAG_BASEFONT)
        {
            CAttrArray ** ppAA = pNode->Element()->GetAttrArray();
            if (*ppAA)
            {
                CAttrValue *pAVColor = (*ppAA)->Find(DISPID_A_COLOR, CAttrValue::AA_Attribute);
                if (pAVColor)
                {
                    // Following condition implies that there is no different color
                    // set through CSS 'color' property.
                    if (pNode->GetCascadedcolor().GetRawValue() == pAVColor->GetLong())
                    {
                        cv = pNode->GetCharFormat()->_ccvTextColor;
                        break;
                    }
                }
            }
        }

        // Get parent (or master, if we should inherit style from master)
        pElemTemp = pNode->Element();
        pNode = pNode->Parent();
        if (!pNode && pElemTemp->HasMasterPtr())
        {
            CElement * pElemMaster  = pElemTemp->GetMasterPtr();
            CDefaults *pDefaults    = pElemMaster->GetDefaults();                
            ELEMENT_TAG etag        = pElemMaster->TagType();

            if (    etag == ETAG_INPUT
                ||  !pDefaults && etag == ETAG_GENERIC
                ||  pDefaults && pDefaults->GetAAviewInheritStyle()
               )
            {
                pNode = pElemMaster->GetFirstBranch();
            }
        }

        // Check if parent has explicit text-decoration.
        if (pNode)
        {
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            if (pFF->HasExplicitTextDecoration(td))
            {
                cv = pNode->GetCharFormat()->_ccvTextColor;
                break;
            }
        }
    } while (pNode);

    // Must find a parent with explicit text decoration or 
    // FONT/BASEFONT tag with 'color' attr
    Assert(pNode);

    return cv;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOtherCF
//
//  Synopsis:   Replace current CF by new one.
//
//  Returns:    new CF
//
//-----------------------------------------------------------------------------
CCharFormat *
COneRun::GetOtherCF()
{
    if (!_fMustDeletePcf)
    {
        _pCF = new CCharFormat();
        if( _pCF != NULL )
            _fMustDeletePcf = TRUE;
    }
    Assert(_pCF != NULL);

    return _pCF;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetOtherCloneCF
//
//  Synopsis:   Replace current CF by new one with the old CF's properties.
//
//  Returns:    new CF
//
//-----------------------------------------------------------------------------
CCharFormat *
COneRun::GetOtherCloneCF()
{
    CCharFormat *pCFOld = _pCF;
    CCharFormat *pCFNew = GetOtherCF();
    if( pCFOld ) 
    {
        *pCFNew = *pCFOld;
    }
    return pCFNew;
}

//-----------------------------------------------------------------------------
//
// Member:      SetCurrentBgColor()
//
// Synopsis:    Set the current background color for the current chunk.
//
//-----------------------------------------------------------------------------
void
COneRun::SetCurrentBgColor(CFlowLayout *pFlowLayout)
{
    CTreeNode * pNode = Branch();
    CElement  * pElementFL = pFlowLayout->ElementOwner();
    const CFancyFormat * pFF;

    while(pNode)
    {
        pFF = pNode->GetFancyFormat();

        if (pFF->_ccvBackColor.IsDefined())
        {
            _ccvBackColor = pFF->_ccvBackColor;
            goto Cleanup;
        }
        else
        {
            if (DifferentScope(pNode, pElementFL))
                pNode = pNode->Parent();
            else
                pNode = NULL;
        }
    }
    
    _ccvBackColor.Undefine();

Cleanup:
    return;
}


//-----------------------------------------------------------------------------
//
//  Function:   Selected
//
//  Synopsis:   Mark the run as being selected. If selected, then also set the
//              background color.
//
//-----------------------------------------------------------------------------
void
COneRun::Selected(CLSRenderer *pRenderer, 
                  CFlowLayout *pFlowLayout, 
                  CPtrAry<CRenderStyle*> *papRenderStyle)
{
    if (!_fSelected)
    {
        _fSelected = TRUE;

        COLORREF crTextColor, crBackColor;
        CColorValue ccvNewTextColor, ccvNewBackColor, ccvDecorationColor;
        CCharFormat *pCF;
        BOOL fDef = FALSE;
        CComplexRun *pCcr = GetComplexRun();

        if( pCcr == NULL )
            pCcr = GetNewComplexRun();

        if( pCcr == NULL )
            return;

        SetCurrentBgColor(pFlowLayout);
        crTextColor = _pCF->_ccvTextColor.GetColorRef();
        crBackColor = GetCurrentBgColor().GetColorRef();
        pRenderer->AdjustColors(_pCF, crTextColor, crBackColor);
        pCF = GetOtherCloneCF();

        if( (*papRenderStyle).Size() ) 
        {
            for(int i=0; i<(*papRenderStyle).Size();i++)
            {
                if( (*papRenderStyle)[i]->GetAAdefaultTextSelection() == TRUE )
                {
                    fDef = TRUE;
                    continue;
                }
                if( ccvNewTextColor.IsNull() == TRUE )
                    ccvNewTextColor = (*papRenderStyle)[i]->GetAAtextColor();
                if( ccvNewBackColor.IsNull() == TRUE )
                    ccvNewBackColor = (*papRenderStyle)[i]->GetAAtextBackgroundColor();
                if( ccvDecorationColor.IsNull() == TRUE )
                    ccvDecorationColor = (*papRenderStyle)[i]->GetAAtextDecorationColor();
                if( pCcr->_RenderStyleProp._lineThroughStyle == styleTextLineThroughStyleUndefined )
                    pCcr->_RenderStyleProp._lineThroughStyle = (*papRenderStyle)[i]->GetAAtextLineThroughStyle();
                if( pCcr->_RenderStyleProp._underlineStyle == styleTextUnderlineStyleUndefined )
                    pCcr->_RenderStyleProp._underlineStyle = (*papRenderStyle)[i]->GetAAtextUnderlineStyle();

                switch( (*papRenderStyle)[i]->GetAAtextDecoration() )
                {
                case styleTextDecorationUnderline:
                    pCcr->_RenderStyleProp._fStyleUnderline = TRUE;
                    break;
                case styleTextDecorationOverline:
                    pCcr->_RenderStyleProp._fStyleOverline = TRUE;
                    break;
                case styleTextDecorationLineThrough:
                    pCcr->_RenderStyleProp._fStyleLineThrough = TRUE;
                    break;
                case styleTextDecorationBlink:
                    pCcr->_RenderStyleProp._fStyleBlink = TRUE;
                    break;
                }
            }

            // Check for a "default" person who wants to reverse the colors
            if( fDef == FALSE )
            {
                if( ccvNewTextColor.IsNull() == FALSE )
                {
                    // Check for transparent
                    if( ccvNewTextColor.IsDefined() == TRUE )
                        crTextColor = ccvNewTextColor.GetColorRef();
                    else
                        crTextColor = _pCF->_ccvTextColor.GetColorRef();
                }
                if( ccvNewBackColor.IsNull() == FALSE )
                {
                    // Check for transparent
                    if( ccvNewBackColor.IsDefined() == TRUE )
                        crBackColor = ccvNewBackColor.GetColorRef();
                    else
                        crBackColor = VALUE_UNDEF;
                }
            }
             
            if( ccvDecorationColor.IsNull() == FALSE )
            {
                // Check for transparent
                if( ccvDecorationColor.IsDefined() == TRUE )
                    pCcr->_RenderStyleProp._ccvDecorationColor = ccvDecorationColor;
                else
                    pCcr->_RenderStyleProp._ccvDecorationColor = GetCurrentBgColor();
            }
            else
                pCcr->_RenderStyleProp._ccvDecorationColor = crTextColor;
        }

        pCF->_ccvTextColor = crTextColor;
        _ccvBackColor = crBackColor;
        _pCF = pCF;
        CheckForUnderLine(FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBP
//
//  Synopsis:   This function computes the actual M/B/P values for this run.
//
//----------------------------------------------------------------------------
BOOL
COneRun::GetInlineMBP(CCalcInfo *pci,
                      DWORD dwFlags,
                      CRect *pResults,
                      BOOL *pfHorzPercentAttr,
                      BOOL *pfVertPercentAttr)
{
    if (_fIsPseudoMBP)
        return GetInlineMBPForPseudo(pci, dwFlags, pResults, pfHorzPercentAttr, pfVertPercentAttr);

    return Branch()->GetInlineMBPContributions(pci, dwFlags, pResults, pfHorzPercentAttr, pfVertPercentAttr);
}

//+---------------------------------------------------------------------------
//
//  Method:     GetInlineMBPForPseudo
//
//  Synopsis:   This function computes the actual M/B/P values for pseudo element.
//
//----------------------------------------------------------------------------
BOOL
COneRun::GetInlineMBPForPseudo(CCalcInfo *pci,
                               DWORD dwFlags,
                               CRect *pResults,
                               BOOL *pfHorzPercentAttr,
                               BOOL *pfVertPercentAttr)
{
    CRect rcEmpty(CRect::CRECT_EMPTY);
    BOOL  fInlineBackground = FALSE;

    if (_pFF->_iPEI >= 0)
    {
        CTreeNode * pNode = Branch();
        CBorderInfo borderinfo;
        const CPseudoElementInfo *pPEI = GetPseudoElementInfoEx(_pFF->_iPEI);
        LONG lFontHeight = _pCF->GetHeightInTwips(pNode->Doc());
        BOOL fVertical = _pCF->HasVerticalLayoutFlow();
        BOOL fWM = _pCF->_fWritingModeUsed;
        Assert(fVertical == pNode->IsParentVertical());
        LONG xParentWidth;

        BOOL fMargin  = (dwFlags & GIMBPC_MARGINONLY ) ? TRUE : FALSE;
        BOOL fBorder  = (dwFlags & GIMBPC_BORDERONLY ) ? TRUE : FALSE;
        BOOL fPadding = (dwFlags & GIMBPC_PADDINGONLY) ? TRUE : FALSE;

        Assert(fMargin || fBorder || fPadding);

        //
        // Handle the borders first
        //
        if (fBorder && GetBorderInfoHelperEx(_pFF, _pCF, pci, &borderinfo, GBIH_PSEUDO))
        {
            pResults->left = borderinfo.aiWidths[SIDE_LEFT];
            pResults->right = borderinfo.aiWidths[SIDE_RIGHT];
            pResults->top = borderinfo.aiWidths[SIDE_TOP];
            pResults->bottom = borderinfo.aiWidths[SIDE_BOTTOM];
        }
        else
        {
            pResults->SetRectEmpty();
        }

        //
        // Handle the padding next (only positive padding allowed)
        //
        if (fPadding || fMargin)
        {
            const CUnitValue & cuvPaddingTop    = pPEI->GetLogicalPadding(SIDE_TOP,    fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingRight  = pPEI->GetLogicalPadding(SIDE_RIGHT,  fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingBottom = pPEI->GetLogicalPadding(SIDE_BOTTOM, fVertical, fWM, _pFF);
            const CUnitValue & cuvPaddingLeft   = pPEI->GetLogicalPadding(SIDE_LEFT,   fVertical, fWM, _pFF);

            const CUnitValue & cuvMarginLeft   = pPEI->GetLogicalMargin(SIDE_LEFT,   fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginRight  = pPEI->GetLogicalMargin(SIDE_RIGHT,  fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginTop    = pPEI->GetLogicalMargin(SIDE_TOP,    fVertical, fWM, _pFF);
            const CUnitValue & cuvMarginBottom = pPEI->GetLogicalMargin(SIDE_BOTTOM, fVertical, fWM, _pFF);

            // If we have horizontal padding in percentages, flag the display
            // so it can do a full recalc pass when necessary (e.g. parent width changes)
            // Also see ApplyLineIndents() where we do this for horizontal indents.
            *pfHorzPercentAttr = (   cuvPaddingLeft.IsPercent()
                                  || cuvPaddingRight.IsPercent()
                                  || cuvMarginLeft.IsPercent()
                                  || cuvMarginRight.IsPercent()
                                 );
            *pfVertPercentAttr = (   cuvPaddingTop.IsPercent()
                                  || cuvPaddingBottom.IsPercent()
                                  || cuvMarginTop.IsPercent()
                                  || cuvMarginBottom.IsPercent()
                                 );

            xParentWidth = (*pfHorzPercentAttr) ? pNode->GetParentWidth(pci, pci->_sizeParent.cx) : pci->_sizeParent.cx;

            //
            // Handle the padding next (only positive padding allowed)
            //
            if (fPadding)
            {
                pResults->left   += max(0l, cuvPaddingLeft.XGetPixelValue(pci, cuvPaddingLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->right  += max(0l, cuvPaddingRight.XGetPixelValue(pci, cuvPaddingRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight));
                pResults->top    += max(0l, cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
                pResults->bottom += max(0l, cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cy, lFontHeight));
            }

            //
            // Finally, handle the margin information
            //
            if (fMargin)
            {
                pResults->left   += cuvMarginLeft.XGetPixelValue(pci, cuvMarginLeft.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->right  += cuvMarginRight.XGetPixelValue(pci, cuvMarginRight.IsPercent() ? xParentWidth : pci->_sizeParent.cx, lFontHeight);
                pResults->top    += cuvMarginTop.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
                pResults->bottom += cuvMarginBottom.YGetPixelValue(pci, pci->_sizeParent.cx, lFontHeight);
            }
        }

        fInlineBackground = _pFF->HasBackgrounds(TRUE);
    }
    else
    {
        *pResults = rcEmpty;
    }
    
    return (   *pResults != rcEmpty
            || fInlineBackground);
}


//+---------------------------------------------------------------------------
//
//  Method:     ConvertToSmallCaps
//
//  Synopsis:   Apply small caps transformation to the run. Will modify _lscch
//              at the first switch from uppercase to lowercase characters,
//              or vice versa.
//
//----------------------------------------------------------------------------
void 
COneRun::ConvertToSmallCaps(TCHAR chPrev)
{
    const CCharFormat* pCF = GetCF();
    long cch = _lscch;
    const TCHAR * pch = _pchBase;
    BOOL fCapitalize = (pCF->_bTextTransform == styleTextTransformCapitalize);
    BOOL fCurrentLowerCase =    !(fCapitalize && IsWordBreakBoundaryDefault(chPrev, *pch)) 
                             && IsCharLower(*pch);
    BOOL fNextLowerCase;

    Assert(pCF->_fSmallCaps);
    Assert(cch > 0);

    //
    // Find first switch point from uppercase to lowercase or vice versa.
    //
    while (--cch > 0)
    {
        chPrev = *pch;
        ++pch;
        fNextLowerCase =    !(fCapitalize && IsWordBreakBoundaryDefault(chPrev, *pch)) 
                         && IsCharLower(*pch);

        if (   (!fNextLowerCase && fCurrentLowerCase)
            || (fNextLowerCase && !fCurrentLowerCase))
        {
            break;
        }
    }

    // If text case is changing inside the run, mark this point 
    // to properly split the run later.
    if (cch)
    {
        _lscch = _lscch - cch;
    }

    //
    // Clone CCharFormat and apply appropriate attributes for small-caps.
    //
    if (GetOtherCloneCF())
    {
        _pCF->_bTextTransform = styleTextTransformUppercase;
        if (fCurrentLowerCase)
            _pCF->_fSCBumpSizeDown = TRUE;            
        _pCF->_bCrcFont = _pCF->ComputeFontCrc();
    }
}

//-----------------------------------------------------------------------------
//
//  Function:   DumpList
//
//-----------------------------------------------------------------------------
#if DBG==1

void
CLineServices::DumpList()
{
    int nCount = 0;
    COneRun *por = _listCurrent._pHead;
    
    if (!InitDumpFile())
        goto Cleanup;

    WriteString( g_f,
                 _T("\r\n------------- OneRunList Dump -------------------------------\r\n" ));
    while(por)
    {
        nCount++;
        WriteHelp(g_f, _T("\r\n[<0d>]: lscp:<1d>, lscch:<2d>, synths:<3d>, ptp:<4d>, width:<5d>, mbpTop:<6d>, mbpBot:<7d>\r\n"),
                          por->_nSerialNumber, por->_lscpBase, por->_lscch,
                          por->_chSynthsBefore, por->_ptp == NULL ? -1 : por->_ptp->_nSerialNumber,
                          por->_xWidth, por->_mbpTop, por->_mbpBottom);
        if (por->IsNormalRun())
            WriteHelp(g_f, _T("Normal, "));
        else if (por->IsSyntheticRun())
            WriteHelp(g_f, _T("Synth, "));
        else if (por->IsAntiSyntheticRun())
            WriteHelp(g_f, _T("ASynth, "));
        if (por->_fGlean)
            WriteHelp(g_f, _T("Glean, "));
        if (por->_fNotProcessedYet)
            WriteHelp(g_f, _T("!Processed, "));
        if (por->_fHidden)
            WriteHelp(g_f, _T("Hidden, "));
        if (por->_fCannotMergeRuns)
            WriteHelp(g_f, _T("NoMerge, "));
        if (por->_fCharsForNestedElement)
            WriteHelp(g_f, _T("NestedElem, "));
        if (por->_fCharsForNestedLayout)
            WriteHelp(g_f, _T("NestedLO, "));
        if (por->_fCharsForNestedRunOwner)
            WriteHelp(g_f, _T("NestedRO, "));
        if (por->_fSelected)
            WriteHelp(g_f, _T("Sel, "));
        if (por->_fNoTextMetrics)
            WriteHelp(g_f, _T("NoMetrics, "));
        if (por->_fMustDeletePcf)
            WriteHelp(g_f, _T("DelCF, "));
        if (por->_lsCharProps.fGlyphBased)
            WriteHelp(g_f, _T("Glyphed, "));
        if (por->_fIsPseudoMBP)
            WriteHelp(g_f, _T("PseudoMBP, "));
        if (   por->_synthType == SYNTHTYPE_MBPOPEN
            || por->_synthType == SYNTHTYPE_MBPCLOSE)
        {
            if (por->_fIsLTR)
                WriteHelp(g_f, _T("LTR"));
            else
                WriteHelp(g_f, _T("RTL"));
        }
        WriteHelp(g_f, _T("\r\nText:'"));
        if(por->_synthType != SYNTHTYPE_NONE)
        {        
            WriteFormattedString(g_f,  s_aSynthData[por->_synthType].pszSynthName, _tcslen(s_aSynthData[por->_synthType].pszSynthName));
        }
        else
        {
            WriteFormattedString(g_f,  (TCHAR*)por->_pchBase, por->_lscch);
        }        

        if(por->_fType == COneRun::OR_NORMAL)
        {
            CStackDataAry<LSQSUBINFO, 4> aryLsqsubinfo(Mt(CLineServicesDumpList_aryLsqsubinfo_pv));
            HRESULT hr;
            LSTEXTCELL lsTextCell;
            aryLsqsubinfo.Grow(4); // Guaranteed to succeed since we're working from the stack.

            hr = THR(QueryLineCpPpoint(por->_lscpBase, FALSE, &aryLsqsubinfo, &lsTextCell, FALSE));

            if(!hr)
            {
                long  nDepth = aryLsqsubinfo.Size() - 1;
                if (nDepth >= 0)
                {
                    const LSQSUBINFO &qsubinfo = aryLsqsubinfo[nDepth];

                    WriteHelp(g_f, _T("\r\nStart: <0d> Dup:<1d>, Flow:<2d>, Level:<3d>"),
                              lsTextCell.pointUvStartCell.u, qsubinfo.dupRun, qsubinfo.lstflowSubline, nDepth);
                }
            }
            else
            {
                WriteString( g_f,
                             _T("\r\nError in QueryLineCpPpoint()" ));
            }

        }

        WriteHelp(g_f, _T("'\r\n"));

        por = por->_pNext;
    }

    WriteHelp(g_f, _T("\r\nTotalRuns: <0d>\r\n"), (long)nCount);

Cleanup:
    CloseDumpFile();
}

void
CLineServices::DumpFlags()
{
    _lineFlags.DumpFlags();
}

void
CLineFlags::DumpFlags()
{
    TCHAR *str;
    int i;
    LONG nCount;
    
    if (!InitDumpFile())
        goto Cleanup;
    
    WriteString( g_f,
                 _T("\r\n------------- Line Flags Dump -------------------------------\r\n" ));

    nCount = _aryLineFlags.Size();
    WriteHelp(g_f, _T("Total Flags: <0d>\r\n"), (long)nCount);
    for (i = 0; i < nCount; i++)
    {
        switch(_aryLineFlags[i]._dwlf)
        {
            case FLAG_NONE              : str = _T("None"); break;
            case FLAG_HAS_INLINEDSITES  : str = _T("Inlined sites"); break;
            case FLAG_HAS_VALIGN        : str = _T("Vertical Align"); break;
            case FLAG_HAS_EMBED_OR_WBR  : str = _T("Embed/Wbr"); break;
            case FLAG_HAS_NESTED_RO     : str = _T("NestedRO"); break;
            case FLAG_HAS_RUBY          : str = _T("Ruby"); break;
            case FLAG_HAS_BACKGROUND    : str = _T("Background"); break;
            case FLAG_HAS_A_BR          : str = _T("BR"); break;
            case FLAG_HAS_RELATIVE      : str = _T("Relative"); break;
            case FLAG_HAS_NBSP          : str = _T("NBSP"); break;
            case FLAG_HAS_NOBLAST       : str = _T("NoBlast"); break;
            case FLAG_HAS_CLEARLEFT     : str = _T("ClearLeft"); break;
            case FLAG_HAS_CLEARRIGHT    : str = _T("ClearRight"); break;
            case FLAG_HAS_LINEHEIGHT    : str = _T("Lineheight"); break;
            case FLAG_HAS_MBP           : str = _T("MBP"); break;
            default                     : str = _T(""); break;
        }
        WriteHelp(g_f, _T("cp=<0d> has <1s>\r\n"), _aryLineFlags[i]._cp, str);
    }
    WriteString(g_f, _fForced ? _T("Forced") : _T("NotForced"));

Cleanup:
    CloseDumpFile();
}

void
CLineServices::DumpCounts()
{
    _lineCounts.DumpCounts();
}

void
CLineCounts::DumpCounts()
{
    LONG nCount;
    int  i;
    
    static WCHAR *g_astr[] = {_T("Undefined"), _T("LineHeight"), _T("Aligned"),
                              _T("Hidden"),    _T("Absolute")};
    
    if (!InitDumpFile())
        goto Cleanup;

    WriteString( g_f,
                 _T("\r\n------------- Line Counts Dump -------------------------------\r\n" ));

    nCount = _aryLineCounts.Size();
    WriteHelp(g_f, _T("Total Counts: <0d>\r\n"), (long)nCount);
    for (i = 0; i < nCount; i++)
    {
        WriteHelp(g_f, _T("cp=<0d> cch=<1d> for <2s>\r\n"),
                  _aryLineCounts[i]._cp,
                  _aryLineCounts[i]._count,
                  g_astr[_aryLineCounts[i]._lcType]);
    }
Cleanup:
    CloseDumpFile();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\seglist.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

#ifndef _X_SLIST_HXX_
#define _X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

MtDefine(CSelectionSaver, Utilities, "CSelectionSaver")


#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}


//+---------------------------------------------------------------------------
//
//  Member:    SaveSelection
//
//  Synopsis:  Store what the current selection is.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionSaver::SaveSelection()
{
    HRESULT                 hr;
    ISegmentList            *pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegment                *pISegment = NULL;
    ISegment                *pISegmentAdded = NULL;
    IMarkupPointer          *pILeft = NULL;
    IMarkupPointer          *pIRight = NULL;
    SELECTION_TYPE          eType;
    IHTMLElement            *pIElement = NULL;
    IElementSegment         *pIElemSegmentAdded = NULL ;
    IElementSegment         *pIElementSegment = NULL ;


    // Get the current segment list, and create an iterator
    IFC( _pDoc->GetCurrentSelectionSegmentList( & pSegmentList ));

    IFC( pSegmentList->GetType(&eType) );
    IFC( pSegmentList->CreateIterator( &pIter ) );

    IFC( SetSelectionType(eType) );
    
    while( pIter->IsDone() == S_FALSE )
    {
        IFC( GetDoc()->CreateMarkupPointer( &pILeft ) );
        IFC( GetDoc()->CreateMarkupPointer( &pIRight ) );

        // Retrieve the position of the current segment
        IFC( pIter->Current( &pISegment ) );

        // Add to our linked list
        if (eType == SELECTION_TYPE_Control)
        {
            IFC( pISegment->QueryInterface(IID_IElementSegment, (void**)&pIElementSegment));
            IFC( pIElementSegment->GetElement(&pIElement));
            IFC( AddElementSegment( pIElement, &pIElemSegmentAdded ));
            Assert( pIElementSegment );
        }
        else
        {
            IFC( pISegment->GetPointers( pILeft, pIRight ) );
            IFC( AddSegment( pILeft, pIRight, &pISegmentAdded ) );
            Assert( pISegmentAdded );
        }
        
        ClearInterface(&pIElement);
        ClearInterface(&pIElementSegment);
        ClearInterface(&pIElemSegmentAdded);
        ClearInterface(&pISegmentAdded);
        ClearInterface(&pILeft);
        ClearInterface(&pIRight);
        ClearInterface(&pISegment);
        
        IFC( pIter->Advance() );
    }

Cleanup:
    ReleaseInterface( pIElement);
    ReleaseInterface( pIElementSegment);
    ReleaseInterface( pIElemSegmentAdded);
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pISegmentAdded );
    ReleaseInterface( pISegment );
    ReleaseInterface( pILeft );
    ReleaseInterface( pIRight );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\text\rclclptr.cxx ===
//+------------------------------------------------------------------------
//
//  Class:      CRecalcLinePtr implementation
//
//  Synopsis:   Special line pointer. Encapsulate the use of a temporary
//              line array when building lines. This pointer automatically
//              switches between the main and the temporary new line array
//              depending on the line index.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifndef X_LSM_HXX_
#define X_LSM_HXX_
#include "lsm.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_RCLCLPTR_HXX_
#define X_RCLCLPTR_HXX_
#include "rclclptr.hxx"
#endif

MtDefine(CRecalcLinePtr, Layout, "CRecalcLinePtr")
MtDefine(CRecalcLinePtr_aryLeftAlignedImgs_pv, CRecalcLinePtr, "CRecalcLinePtr::_aryLeftAlignedImgs::_pv")
MtDefine(CRecalcLinePtr_aryRightAlignedImgs_pv, CRecalcLinePtr, "CRecalcLinePtr::_arRightAlignedImgs::_pv")

#pragma warning(disable:4706) /* assignment within conditional expression */

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::CRecalcLinePtr
//
//  Synopsis:   constructor, initializes (caches) margins for the current
//              display
//
//-------------------------------------------------------------------------

CRecalcLinePtr::CRecalcLinePtr(CDisplay *pdp, CCalcInfo *pci)
    : _aryLeftAlignedImgs(Mt(CRecalcLinePtr_aryLeftAlignedImgs_pv)),
      _aryRightAlignedImgs(Mt(CRecalcLinePtr_aryRightAlignedImgs_pv))
{
    CFlowLayout *   pFlowLayout = pdp->GetFlowLayout();
    CElement *      pElementFL  = pFlowLayout->ElementContent();
    long            lPadding[SIDE_MAX];

    WHEN_DBG( _cAll = -1; )

    _pdp = pdp;
    _pci = pci;
    _iPF = -1;
    _fInnerPF = FALSE;
    _xLeft       =
    _xRight      =
    _yBordTop    =
    _xBordLeft   =
    _xBordRight  =
    _yBordBottom = 0;
    _xPadLeft    =
    _yPadTop     =
    _xPadRight   =
    _yPadBottom  = 0;

    // I am not zeroing out the following because it is not necessary. We zero it out
    // everytime we call CalcBeforeSpace
    // _yBordLeftPerLine = _xBordRightPerLine = _xPadLeftPerLine = _xPadRightPerLine = 0;
    
    ResetPosAndNegSpace();

    _cLeftAlignedLayouts =
    _cRightAlignedLayouts = 0;
    _fIsEditable = pFlowLayout->IsEditable();

    if (    pElementFL->Tag() == ETAG_MARQUEE
        &&  !_fIsEditable
        &&  !pElementFL->IsPrintMedia())
    {
        _xMarqueeWidth = DYNCAST(CMarquee, pElementFL)->_lXMargin;
    }
    else
    {
        _xMarqueeWidth  = 0;
    }

    _pdp->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);
    _xLayoutLeftIndent  = lPadding[SIDE_LEFT];
    _xLayoutRightIndent = lPadding[SIDE_RIGHT];
    _fNoMarginAtBottom = FALSE;
    _ptpStartForListItem = NULL;
    _fMoveBulletToNextLine = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Init
//
//  Synopsis:   Initialize the old and new line array and reset the
//              RecalcLineptr.
//
//-------------------------------------------------------------------------

void CRecalcLinePtr::Init(CLineArray * prgliOld, int iNewFirst, CLineArray * prgliNew)
{
    _prgliOld = prgliOld;
    _prgliNew = prgliNew;
    _xMaxRightAlign = 0;
    Reset(iNewFirst);
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Reset
//
//  Synopsis:   Resets the RecalcLinePtr to use the given offset. Look
//              for all references to line >= iNewFirst to be looked up in the
//              new line array else in the old line array.
//
//-------------------------------------------------------------------------

void CRecalcLinePtr::Reset(int iNewFirst)
{
    _iNewFirst = iNewFirst;
    _iLine = 0;
    _iNewPast = _prgliNew ? _iNewFirst + _prgliNew->Count() : 0;
    _cAll = _prgliNew ? _iNewPast : _prgliOld->Count();
    Assert(_iNewPast <= _cAll);
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::operator
//
//  Synopsis:   returns the line from the old or the new line array based
//              on _iNewFirst.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::operator [] (int iLine)
{
    Assert(iLine < _cAll);
    if (iLine >= _iNewFirst && iLine < _iNewPast)
    {
        return _prgliNew->Elem(iLine - _iNewFirst);
    }
    else
    {
        return _prgliOld->Elem(iLine);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::AddLine
//
//  Synopsis:   Add's a new line at the end of the new line array.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::AddLine()
{
    CLineCore * pLine = _prgliNew ? _prgliNew->Add(1, NULL): _prgliOld->Add(1, NULL);
    if(pLine)
    {
        Reset(_iNewFirst);  // Update _cAll, _iNewPast, etc. to reflect
                            // the correct state after adding line
        pLine->_iLOI = -1;  // to prevent this index to have value 0 (valid cache index)
    }
    
    return pLine;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::InsertLine
//
//  Synopsis:   Inserts a line to the old or new line array before the given
//              line.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::InsertLine(int iLine)
{
    CLineCore * pLine = _prgliNew ? _prgliNew->Insert(iLine - _iNewFirst, 1):
                                _prgliOld->Insert(iLine, 1);
    if(pLine)
    {
        Reset(_iNewFirst);  // Update _cAll, _iNewPast, etc. to reflect
                            // the correct state after the newly inserted line
        pLine->_iLOI = -1;  // to prevent this index to have value 0 (valid cache index)
    }
    return pLine;
}


//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::First
//
//  Synopsis:   Sets the iLine to be the current line and returns it
//
//  Returns:    returns iLine'th line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::First(int iLine)
{
    _iLine = iLine;
    if (_iLine < _cAll)
        return (*this)[_iLine];
    else
        return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Next
//
//  Synopsis:   Moves the current line to the next line, if there is one
//
//  Returns:    returns the next line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::Next()
{
    if (_iLine + 1 < _cAll)
        return (*this)[++_iLine];
    else
        return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CRecalcLinePtr::Prev
//
//  Synopsis:   Moves the current line to the previous line, if there is one
//
//  Returns:    returns the previous line if there is one.
//
//-------------------------------------------------------------------------

CLineCore * CRecalcLinePtr::Prev()
{
    if (_iLine > 0)
        return (*this)[--_iLine];
    else
        return NULL;
}


//+----------------------------------------------------------------------------
//
// Member:      CRecalcLinePtr::InitPrevAfter ()
//
// Synopsis:    Initializes the after spacing of the previous line's paragraph
//
//-----------------------------------------------------------------------------
void CRecalcLinePtr::InitPrevAfter(BOOL *pfLastWasBreak, CLinePtr& rpOld)
{
    int oldLine;

    *pfLastWasBreak = FALSE;

    // Now initialize the linebreak stuff.
    oldLine = rpOld;
    if (rpOld.PrevLine(TRUE, FALSE))
    {
        // If we encounter a break in the previous line, then we
        // need to remember that for the accumulation to work.
        if (rpOld->_fHasBreak)
        {
            *pfLastWasBreak = TRUE;
        }
    }

    rpOld = oldLine;
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyLineIndents
//
//  Synopsis:   Apply left and right indents for the current line.
//
//-------------------------------------------------------------------------
void
CRecalcLinePtr::ApplyLineIndents(
    CTreeNode * pNode,     
    CLineFull * pLineMeasured,
    UINT uiFlags,
    BOOL fPseudoElementEnabled)
{
    LONG        xLeft;      // Use logical units
    LONG        xRight;     // Use logical units
    long        iPF;
    const CParaFormat * pPF;
    CFlowLayout   * pFlowLayout = _pdp->GetFlowLayout();
    CElement      * pElementFL  = pFlowLayout->ElementContent();
    BOOL            fInner      = SameScope(pNode, pElementFL);

    if(!pNode)
	    return;
    pPF = pNode->GetParaFormat();
    iPF = pNode->GetParaFormatIndex(LC_TO_FC(_pci->GetLayoutContext()));
    BOOL fRTLLine = pPF->HasRTL(TRUE);

    if (   _iPF != iPF
        || _fInnerPF != fInner
        || fPseudoElementEnabled
       )
    {
        if (!fPseudoElementEnabled)
        {
            _iPF    = iPF;
            _fInnerPF = fInner;
        }
        LONG xParentWidth = _pci->_sizeParent.cx;
        if (   pPF->_cuvLeftIndentPercent.GetUnitValue()
            || pPF->_cuvRightIndentPercent.GetUnitValue()
           )
        {
            // 
            // (olego, IEv60 31646) CSS1 Strict Mode specific. In this mode _pci->_sizeParent.cx 
            // contains the width of pFlowLayout's parent (in compat mode it is overwritten in 
            // CFlowLayout::CalcTextSize), but pFlowLayout->_sizeProposed is what is expected here. 
            // Since xParentWidth is used only when indent is a percent value, and to minimize 
            // perf impact this code is placed under the if statement, instead of xParentWidth's 
            //  initialization.
            // 
            if (    pElementFL->HasMarkupPtr() 
                &&  pElementFL->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                xParentWidth = pFlowLayout->_sizeProposed.cx;
            }
            xParentWidth = pNode->GetParentWidth(_pci, xParentWidth);
        }
        _xLeft  = pPF->GetLeftIndent(_pci, fInner, xParentWidth);
        _xRight = pPF->GetRightIndent(_pci, fInner, xParentWidth);

        if (_xLeft < 0 || _xRight < 0)
            _pdp->_fHasNegBlockMargins = TRUE;

        // If we have horizontal indents in percentages, flag the display
        // so it can do a full recalc pass when necessary (e.g. parent width changes)
        // Also see CalcBeforeSpace() where we do this for horizontal padding.
        if ( (pPF->_cuvLeftIndentPercent.IsNull() ? FALSE :
              pPF->_cuvLeftIndentPercent.GetUnitValue() )   ||
             (pPF->_cuvRightIndentPercent.IsNull() ? FALSE :
              pPF->_cuvRightIndentPercent.GetUnitValue() ) )
        {
            _pdp->_fContainsHorzPercentAttr = TRUE;
        }
    }

    xLeft = _xLeft;
    xRight = _xRight;

    // (changes in the next section should be reflected in AlignObjects() too)
    
    // Adjust xLeft to account for marquees, padding and borders.
    xLeft += _xMarqueeWidth + _xLayoutLeftIndent;
    xRight += _xMarqueeWidth + _xLayoutRightIndent;
    
    xLeft  += _xPadLeft + _xBordLeft;
    xRight += _xPadRight + _xBordRight;

    if(!fRTLLine)
        xLeft += _xLeadAdjust;
    else
        xRight += _xLeadAdjust;

    // xLeft is now the sum of indents, border, padding.  CSS requires that when
    // possible, this indent is shared with the space occupied by floated/ALIGN'ed
    // elements (our code calls that space "margin").  Thus we want to apply a +ve
    // xLeft only when it's greater than the margin, and the amount applied excludes
    // what's occupied by the margin already.  (We never want to apply a -ve xLeft)
    // Same reasoning applies to xRight.
    // Note that xLeft/xRight has NOT accumulated CSS text-indent values yet;
    // this is because we _don't_ want that value to be shared the way the above
    // values have been shared.  We'll factor in text-indent after this.
    if (_marginInfo._xLeftMargin)
        pLineMeasured->_xLeft = max( 0L, xLeft - _marginInfo._xLeftMargin );
    else
        pLineMeasured->_xLeft = xLeft;

    if (_marginInfo._xRightMargin)
        pLineMeasured->_xRight = max( 0L, xRight - _marginInfo._xRightMargin );
    else
        pLineMeasured->_xRight = xRight;

    // text indent is inherited, so if the formatting node correspond's to a layout,
    // indent the line only if the layout is not a block element. For layout element's
    // the have blockness, text inherited and first line of paragraph's inside are
    // indented.
    if (    uiFlags & MEASURE_FIRSTINPARA
        && (   pNode->Element() == pElementFL
            || !pNode->ShouldHaveLayout(LC_TO_FC(_pci->GetLayoutContext()))
            || !pNode->Element()->IsBlockElement(LC_TO_FC(_pci->GetLayoutContext())))
       )
    {
        if(!fRTLLine)
            pLineMeasured->_xLeft += pPF->GetTextIndent(_pci);
        else
            pLineMeasured->_xRight += pPF->GetTextIndent(_pci);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CalcInterParaSpace
//
//  Synopsis:   Calculate space before the current line.
//
//  Arguments:  [pMe]              --
//              [iLineFirst]       --  line to start calculating from
//              [yHeight]          --  y coordinate of the top of line
//
//
//-------------------------------------------------------------------------
CTreeNode *
CRecalcLinePtr::CalcInterParaSpace(CLSMeasurer * pMe, LONG iPrevLine, UINT *puiFlags)
{
    LONG iLine;
    CLineCore *pPrevLine = NULL;
    CTreeNode *pNodeFormatting;
    BOOL fFirstLineInLayout = *puiFlags & MEASURE_FIRSTLINE ? TRUE : FALSE;

    INSYNC(pMe);
    
    // Get the previous line that's on a different physical line
    // and is not a frame line. Note that the initial value of
    // iPrevLine IS the line before the one we're about to measure.
    for (iLine = iPrevLine; iLine >= 0; --iLine)
    {
        pPrevLine = (*this)[iLine];

        if (pPrevLine->_fForceNewLine && pPrevLine->_cch > 0)
            break;
    }
    
    //pMe->MeasureSetPF(pPF);
    //pMe->_pLS->_fInnerPFFirst = SameScope(pMe->CurrBranch(), _pdp->GetFlowLayoutElement());

    pNodeFormatting = CalcParagraphSpacing(pMe, fFirstLineInLayout);

    // If a line consists of only a BR character and a block tag,
    // fold the previous line height into the before space, too.
    if (pPrevLine && pPrevLine->_fEatMargin)
    {
        //
        // NOTE(SujalP): When we are eating margin we have to be careful to
        // take into account both +ve and -ve values for both LineHeight
        // yBS. The easiest way to envision this is to think both of them
        // as margins which need to be merged -- which is similar to the
        // case where we are computing before and after space. Hence the
        // code here is similar to the code one would seen in CalcBeforeSpace
        // where we set up up _yPosSpace and _yNegSpace.
        //
        // If you have the urge to change this code please make sure you
        // do not change the behaviour of 38561 and 61132.
        //
        LONG yPosSpace;
        LONG yNegSpace;
        LONG yBeforeSpace = pMe->_li._yBeforeSpace;
        
        yPosSpace = max(0L, pPrevLine->_yHeight);
        yPosSpace = max(yPosSpace, yBeforeSpace);

        yNegSpace = min(0L, pPrevLine->_yHeight);
        yNegSpace = min(yNegSpace, yBeforeSpace);

        pMe->_li._yBeforeSpace = (yPosSpace + yNegSpace) - pPrevLine->_yHeight;
    }

    //
    //  Support for WORD-WRAP attribute
    //
    // word wrap should not affect minwidth mode
    if (pNodeFormatting)
    {
        pMe->SetBreakLongLines(pNodeFormatting, puiFlags);
    }
    
    if (pMe->_li._fFirstInPara)
    {
        *puiFlags |= MEASURE_FIRSTINPARA;
        CTreeNode *pNode = pNodeFormatting;
	if(!pNode)
		return NULL;
        if (pNode->GetParaFormat(LC_TO_FC(_pci->GetLayoutContext()))->_fHasPseudoElement)
        {
            const CFancyFormat *pFF;
            pNode = _pdp->GetMarkup()->SearchBranchForBlockElement(pNode, pMe->_pFlowLayout);
            Assert(pMe->_pFlowLayout->IsElementBlockInContext(pNode->Element()));
            pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));
            BOOL fHasFirstLine = pFF->_fHasFirstLine;
            BOOL fHasFirstLetter = pFF->_fHasFirstLetter;

            if (   fHasFirstLetter
                && pNode->ShouldHaveLayout()
                && !SameScope(pNode, pMe->_pFlowLayout->ElementOwner())
               )
            {
                fHasFirstLetter = FALSE;
            }
            
            if (fHasFirstLine || fHasFirstLetter)
            {
                BOOL fFirstLetterFound = FALSE;
                pMe->_cpStopFirstLetter = fHasFirstLetter ? pMe->GetCpOfLastLetter(pNode) : -1;

                if (pMe->_cpStopFirstLetter < pMe->GetCp())
                {
                    fHasFirstLetter = FALSE;
                    pMe->_cpStopFirstLetter = -1;
                }
                
                if (fHasFirstLine)
                {
                    LONG cchFirstLetter = 0;

                    if (iPrevLine >= 0)
                    {
                        CLineCore *pPrevLine = (*this)[iPrevLine];
                        CLineOtherInfo *ploi = pPrevLine ? pPrevLine->oi() : NULL;
                        
                        if (   ploi
                            && ploi->_fHasFirstLine
                            && ploi->_fHasFirstLetter
                            && pPrevLine->IsFrame()
                            && !pPrevLine->_fFrameBeforeText
                            && SameScope(ploi->_pNodeForFirstLetter, pNode)
                           )
                        {
                            cchFirstLetter = ploi->_cchFirstLetter;
                        }
                    }

                    // If this block element (ElemA) begins _BEFORE_ this line, it means
                    // that we have a nested block element (ElemB) inside ElemA and
                    // hence this line is not really the first line in ElemA.
                    // Note: the pMe->_li._cch stores the count of the prechars -- it has
                    // yet to be transferred over to _cchPreChars, which unfortunately
                    // happens after this function.
                    if (pNode->Element()->GetFirstCp() + cchFirstLetter >= (pMe->GetCp() - pMe->_li._cch))
                    {
                        pMe->_li._fHasFirstLine = TRUE;
                        pMe->PseudoLineEnable(pNode);
                    }
                }

                if (fHasFirstLetter)
                {
                    // Walk back over here to pay attention to the "float" line
                    // which contains the first letter. If you find it, then do
                    // no turn on this bit, else do so.
                    iLine = iPrevLine;
                    while (iLine >= 0)
                    {
                        pPrevLine = (*this)[iLine];
                        if (pPrevLine->_fForceNewLine && !pPrevLine->IsClear())
                            break;
                        if (   pPrevLine->IsFrame()
                            && pPrevLine->oi()->_fHasFloatedFL
                            && SameScope(pPrevLine->oi()->_pNodeForFirstLetter, pNode)
                           )
                        {
                            fFirstLetterFound = TRUE;
                            break;
                        }
                        iLine--;
                    }
                    if (   !fFirstLetterFound
                        && pMe->_cpStopFirstLetter >= 0
                        )
                    {

                        pMe->PseudoLetterEnable(pNode);
                        Assert(pMe->_fPseudoLetterEnabled);
                        pMe->_li._fHasFirstLetter = TRUE;
                    }
                }

                if (   pMe->_li._fHasFirstLine
                    || pMe->_li._fHasFirstLetter 
                   )
                {
                    pFF = pNode->GetFancyFormat(LC_TO_FC(_pci->GetLayoutContext()));

                    // If we did not get the clear attribute from the pseudo element
                    // then there is no point in clearing here since it would already
                    // have been cleared.
                    // If we have found the first letter, it means that clearing has
                    // already happened. We do not want to clear the aligned line for
                    // the first letter, now do we?
                    if (   pFF->_fClearFromPseudo
                        && !fFirstLetterFound
                       )
                    {
                        _marginInfo._fClearLeft  |= pFF->_fClearLeft;
                        _marginInfo._fClearRight |= pFF->_fClearRight;
                    }
                    if (fFirstLetterFound)
                    {
                        _marginInfo._fClearLeft = FALSE;
                        _marginInfo._fClearRight = FALSE;
                    }
                }
            }
        }
    }    
    INSYNC(pMe);
    
    return pNodeFormatting;
}

/*
 *  CRecalcLinePtr::NetscapeBottomMargin(pMe, pDI)
 *
 *  This function is called for the last line in the display.
 *  It exists because Netscape displays by streaming tags and it
 *  increases the height of a table cell when an end tag passes
 *  by without determining if there is any more text. This makes
 *  it impossible to have a bunch of cells with headers in them
 *  where the cells are tight around the text, but c'est la vie.
 *
 *  We store the extra space in an intermediary and then add it
 *  into the bottom margin later.
 *
 */
LONG
CRecalcLinePtr::NetscapeBottomMargin(CLSMeasurer * pMe)
{
    if (   _fNoMarginAtBottom
        || _pdp->GetFlowLayout()->ElementContent()->Tag() == ETAG_BODY
       )
    {
        ResetPosAndNegSpace();
        _fNoMarginAtBottom = FALSE;
    }
    
    // For empty paragraphs at the end of a layout, we create a dummy line
    // so we can just use the before space of that dummy line. If there is 
    // no dummy line, then we need to use the after space of the previous 
    // line.
    return pMe->_li._fDummyLine
            ? pMe->_li._yBeforeSpace
            : _lTopPadding + _lNegSpaceNoP + _lPosSpaceNoP;
}


//+------------------------------------------------------------------------
//
//  Member:     RecalcMargins
//
//  Synopsis:   Calculate new margins for the current line.
//
//  Arguments:  [iLineStart]       --  new lines start at
//              [iLineFirst]       --  line to start calculating from
//              [yHeight]          --  y coordinate of the top of line
//              [yBeforeSpace]     --  before space of the current line
//
//-------------------------------------------------------------------------
void CRecalcLinePtr::RecalcMargins(
    int iLineStart,
    int iLineFirst,
    LONG yHeight,
    LONG yBeforeSpace)
{
    LONG            y;
    CLineCore     * pLine;
    int             iAt;
    CFlowLayout   * pFlowLayout = _pdp->GetFlowLayout();
    LONG            xWidth      = pFlowLayout->GetMaxLineWidth();

    // Initialize margins to defaults.
    _marginInfo.Init();
    _fM