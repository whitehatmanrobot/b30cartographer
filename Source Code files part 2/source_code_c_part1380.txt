st = new(Mt(CPrivacyList)) CPrivacyList(_pts);
    if (!_pPrivacyList)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pPrivacyList->Init();

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    // Needed for cookie privacy information to check whether we are in a script context or not
    _cScriptNestingTotal = 0;

Cleanup:
    if (pMarkup)
    {
        pMarkup->Release();
    }
    RRETURN( hr );
}



void
CDoc::SetLoadfFromPrefs()
{
    // Read in the preferences, if we don't already have them
    if( _pOptionSettings == NULL )
    {
        HRESULT hr;
        if (IsPrintDialogNoUI()) 
            hr = THR(UpdateFromRegistry(REGUPDATE_REFRESH));
        else
            hr = THR(UpdateFromRegistry());
        Assert(hr || _pOptionSettings);
    }

    if (_pOptionSettings)
    {
        _dwLoadf =
            ((_pOptionSettings->fShowImages || _fInTrustedHTMLDlg)
                ? DLCTL_DLIMAGES     : 0) |
#ifndef NO_AVI
            (_pOptionSettings->fShowVideos  ? DLCTL_VIDEOS       : 0) |
#endif
            ((_pOptionSettings->fPlaySounds
                         && !IsPrintDialogNoUI())  ? DLCTL_BGSOUNDS     : 0);
    }

    if (DesignMode() || (PrimaryMarkup() && PrimaryMarkup()->DontRunScripts()) )
    {
        _dwLoadf |= DLCTL_NO_SCRIPTS;
    }

    if (_pHostPeerFactory)
    {
        SetCssPeersPossible(); // TODO (alexz) reconsider this
    }

    GetLoadFlag(DISPID_AMBIENT_SILENT);
    GetLoadFlag(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);

    if (_dwFlagsHostInfo & DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8)
        _dwLoadf |= DLCTL_URL_ENCODING_DISABLE_UTF8;
    else if (_dwFlagsHostInfo & DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8)
        _dwLoadf |= DLCTL_URL_ENCODING_ENABLE_UTF8;
}

void
CDoc::ReleaseEditor()
{
    //
    // Tear down the editor
    //
    ReleaseInterface( _pIHTMLEditor );
    _pIHTMLEditor = NULL;

    //
    // Release caret
    //   
    ReleaseInterface( _pCaret );
    _pCaret = NULL;

    //
    // Release editing resource DLL
    //
    if (_hEditResDLL)
    {
        FreeLibrary(_hEditResDLL);
        _hEditResDLL = NULL;
    }
    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void
CDoc::Passivate ( )
{
    //
    // behaviors support
    //

    ClearInterface(&_pIepeersFactory);
    ClearInterface (&_pHostPeerFactory);
    ClearInterface (&_pFilterBehaviorFactory);

    if (_pExtendedTagTableHost)
    {
        _pExtendedTagTableHost->Release();
        _pExtendedTagTableHost = NULL;
    }

    //
    // When my last reference is released, don't accept any excuses
    // while shutting down

    _fForceCurrentElem = TRUE;

    //  Containers are not required to call IOleObject::Close on
    //    objects; containers are allowed to just release all pointers
    //    to an embedded object.  This means that the last reference
    //    to an object can disappear while the object is still in
    //    the OS_RUNNING state.  So, we demote it if necessary.
    //
    //  This duplicates logic in CServer::Passivate, which we don't
    //    call since it also calls CBase::Passivate, which we call
    //    separately.  We transition to the loaded state before
    //    we completely shut down since we can be called back by
    //    controls as they are being unloaded.

    if (_hwndCached)
    {
        Assert(IsWindow(_hwndCached));

        // I would like to assert that there better not be any child windows
        // (of windowed controls on the page) still hanging around at this point.
        // However, this fails in some cases, e.g. a control doesn't destroy its
        // window when going from inplace to running. It is useful to turn this
        // assert on when debugging shutdown problems related to windowed controls.
        //
        // Assert(::GetWindow(_hwndCached, GW_CHILD) == NULL);

        Verify(DestroyWindow(_hwndCached));
        _hwndCached = NULL;
    }

    _aryAccEvents.Passivate();

    Assert(_state <= OS_RUNNING);
    if (_state > OS_LOADED)
    {
        Verify(!TransitionTo(OS_LOADED));
    }

    ClearInterface(&_pTimerDraw);

    NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL);
    ReleaseEditor();

    // Unload the contents of the document

    UnloadContents( FALSE, FALSE );

    Assert( _pElementDefault );

    CElement::ClearPtr( (CElement**)&_pElementDefault );

    if (_pActiveXSafetyProvider &&
        _pActiveXSafetyProvider != (IActiveXSafetyProvider *)-1) {
        _pActiveXSafetyProvider->Release();
    }

    ClearInterface(&_pDownloadNotify);

    FormsFreeString(_bstrUserAgent);
    _bstrUserAgent = NULL;

    if ( _pHostStyleSheets )
    {
        _pHostStyleSheets->Release();
        // we will delete in destructor
    }

    ClearInterface(&_phlbc);

    //  Now, we can safely shut down the form.
    if (_pWindowPrimary)
    {
        _pWindowPrimary->Release();
        _pWindowPrimary = NULL;
    }

    ClearInterface(&_pTravelLog);
    ClearInterface(&_pBrowserSvc);
    ClearInterface(&_pShellBrowser);
    ClearInterface(&_pTridentSvc);
    ClearInterface(&_pTopWebOC);

    GWKillMethodCall(this, ONCALL_METHOD(CServer, SendOnDataChange, sendondatachange), 0);
    GWKillMethodCall(this, NULL, 0);

    ClearInterface(&_pHostUIHandler);
    ClearInterface(&_pBackupHostUIHandler);
    ClearInterface(&_pHostUICommandHandler);
    ClearInterface(&_pSecurityMgr);
    ClearInterface(&_pPrintSecurityMgr);

    if (_hpalDocument)
    {
        DeleteObject(_hpalDocument);
        _hpalDocument = 0;
    }

    if (_pColors)
    {
        CoTaskMemFree(_pColors);
        _pColors = 0;
    }
    // release caches if needed...
    {
#ifndef NODD
        ClearSurfaceCache();
#endif
    }
    ClearInterface(&_pDSL);

    ClearDefaultCharFormat();

    if (_pPrivacyList)
    {
        _pPrivacyList->SetShutDown();
        _pPrivacyList->Release();
        _pPrivacyList = NULL;
    }
    
    NotifySelection( EDITOR_NOTIFY_DOC_ENDED, NULL );

#ifdef TEST_LAYOUT
    // Unload the external layout DLL if it's been loaded
    if ( _hExternalLayoutDLL != INVALID_HANDLE_VALUE )
    {
        FreeLibrary( _hExternalLayoutDLL );
        _hExternalLayoutDLL = (HMODULE) INVALID_HANDLE_VALUE;
    }
#endif

    ClearInterface(&_pCachedDocTearoff);

    CServer::Passivate();

    if(_pdomImplementation)
        _pdomImplementation->Release();

    delete _pWhitespaceManager;


    if (_hDevNames)
    {
        ::GlobalFree(_hDevNames);
        _hDevNames = NULL;
    }
    if (_hDevMode)
    {
        ::GlobalFree(_hDevMode);
        _hDevMode = NULL;
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::UnloadContents
//
//  Synopsis : Frees resources
//
//----------------------------------------------------------

void
CDoc::UnloadContents(BOOL fPrecreated, BOOL fRestartLoad )
{
    // Don't allow WM_PAINT or WM_ERASEBKGND to get processed while
    // the tree is being deleted.  Some controls when deleting their
    // HWNDs will cause WM_ERASEBKGND to get sent to our window.  That
    // starts the paint cycle which is bad news when the site tree is
    // being destroyed.

    CLock   Lock(this, SERVERLOCK_BLOCKPAINT | FORMLOCK_UNLOADING);
    
    // Indicate to anybody who checks that the document has been unloaded
    _cDie++;

    _cStylesheetDownloading         = 0;
    _dwStylesheetDownloadingCookie += 1;

    _aryMarkupNotifyInPlace.DeleteAll();

    UnregisterUrlImgCtxCallbacks();

    delete _pScriptCookieTable;
    _pScriptCookieTable = NULL;

    UpdateInterval(0);

    _recalcHost.Detach();
   
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 0);
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FaultInJG, faultinjg), 0);

    Assert(_aryChildDownloads.Size() == 0); // ExecStop should have emptied.

    // Delete stored focus rect info
    if (_pRectFocus)
    {
        delete _pRectFocus;
        _pRectFocus = NULL;
    }

    ClearInterface(&_pShortcutUserData);

    if (_pvPics != (void *)(LONG_PTR)(-1))
        MemFree(_pvPics);
    _pvPics = NULL;

    ClearInterface(&_pSecurityMgr);

    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
    _fMouseOverTimer = FALSE;

    CTreeNode::ClearPtr( & _pNodeLastMouseOver );
    CTreeNode::ClearPtr( & _pNodeGotButtonDown );

    ReleaseOMCapture();

    // nothing depends on the tree now; release the tree
    //
    // Detach all sites still not detached
    //

    if (PrimaryMarkup())
    {
        if (_pInPlace)
        {
            _pInPlace->_fDeactivating = TRUE;
        }

        _view.Unload();

        // TODO (lmollico): revisit
        {
            CMarkup * pMarkup = PrimaryMarkup();

            delete pMarkup->_pHighlightRenSvcProvider;
            pMarkup->_pHighlightRenSvcProvider = NULL;

            pMarkup->_TxtArray.RemoveAll();
        }
    }

    if (PrimaryMarkup())
        _pElemCurrent = PrimaryMarkup()->Root();

    // reset _fPeersPossible, unless it was set because host supplies peer factory. In that case after refresh
    // we won't be requerying again for any css, namespace, and other information provided by host so the bit
    // can't be turned back on
    if (!_pHostPeerFactory)
        _fCssPeersPossible = FALSE;

    _fContentSavePeersPossible = FALSE;
    _fPageTransitionLockPaint = FALSE;

    // There might be some filter element tasks pending but we don't care

    // If a filter instantiate caused a navigate and unloaded the doc
    // we will be in a bit of trouble.  This doesn't happen today but just in case.
    Assert(!TestLock(FORMLOCK_FILTER));
    
    _fPendingFilterCallback = FALSE;
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0);

    // Delete all entries in our array of pending filter elements.  Each of
    // these elements also has to have its _fHasPendingFilterTask set to false
    // also.

    if (_aryPendingFilterElements.Size() > 0)
    {
        int i = _aryPendingFilterElements.Size();

        while (i > 0)
        {
            i--;

            CElement * pElement = _aryPendingFilterElements[i];

            Assert(pElement != NULL);
            if (pElement == NULL)
                continue;

            pElement->_fHasPendingFilterTask = false;
        }
            
        _aryPendingFilterElements.DeleteAll();
    }

    // Flush the queue of pending expression recalcs
    CleanupExpressionTasks();


    //
    // misc
    //

    delete _pXmlUrnAtomTable;
    _pXmlUrnAtomTable = NULL;

    if (_pInPlace)
    {
        _pInPlace->_fDeactivating = FALSE;
    }

    if (PrimaryMarkup())
    {
        PrimaryMarkup()->UpdateMarkupTreeVersion();
    }   
    
    _fNeedInPlaceActivation = FALSE;
    _fTagsInFrameset = FALSE;
    _fFramesetInBody = FALSE;
    _fRegionCollection = FALSE;
    _fFrameBorderCacheValid = FALSE;
    _fIsUpToDate = TRUE;
    _fHasOleSite = FALSE;
    _fHasBaseTag = FALSE;
    _fInHomePublisherDoc = FALSE;

    GWKillMethodCall(this, ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor), 0);

    {
        LONG c;
        CStr *pcstr;

        for (pcstr = _acstrStatus, c = STL_LAYERS; c; pcstr += 1, c -= 1)
            pcstr->Free();

        _iStatusTop = STL_LAYERS;
        _fSeenDefaultStatus = FALSE;
    }

    ClearInterface(&_pTypInfo);
    ClearInterface(&_pTypInfoCoClass);

    ClearInterface(&_punkMimeOle);
    ClearInterface(&_pOriginalMoniferForMHTML);

    SetPrimaryUrl(_T("about:blank"));

    FlushUndoData();

    if (_pWindowPrimary)
    {
        _pWindowPrimary->Markup()->TearDownMarkup();
        _pWindowPrimary->Release();
        _pWindowPrimary = NULL;
    }

    //
    // Don't delete our attr array outright since we've stored lotsa things
    // in there like prop notify sinks.  We're going to call FreeSpecial to
    // free everything else except these things.
    //

    if (*GetAttrArray())
    {
        (*GetAttrArray())->FreeSpecial();
    }

    _bufferDepth = 0;       // reset the buffer depth
    _triOMOffscreenOK = -1; // reset offscreen to auto

    // NOTE: (jbeda) I'm not sure this is necessary
    // reset SSL security/prompting state
    _sslPrompt = SSL_PROMPT_ALLOW;
    _sslSecurity = SSL_SECURITY_UNSECURE;

    _aryDefunctObjects.DeleteAll();

    if (_fHasOleSite)
    {
        CoFreeUnusedLibraries();
    }
    
    //
    // NOTE(SujalP): Our current usage pattern dictates that at this point there
    // should be no used entries in the cache. However, when we start caching a
    // plsline inside the cache at that point we will have used entries here and
    // then VerifyNonUsed() cannot be called.
    //
    WHEN_DBG( TLS(_pLSCache)->VerifyNoneUsed(); )
    TLS(_pLSCache)->Dispose(TRUE);
    
    NotifySelection( EDITOR_NOTIFY_DOC_ENDED, NULL );

    Assert(_lRecursionLevel == 0);
    Assert(!_aryANotification.Size());
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::RequestReleaseNotify(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CAryElementReleaseNotify * pAryElementReleaseNotify = EnsureAryElementReleaseNotify();

    pAryElementReleaseNotify->Append(pElement);
    pElement->SubAddRef();

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RevokeRequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::RevokeRequestReleaseNotify(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CAryElementReleaseNotify * pAryElementReleaseNotify = GetAryElementReleaseNotify();

    if (pAryElementReleaseNotify)
    {
        LONG idx = pAryElementReleaseNotify->Find(pElement);

        if (0 <= idx)
        {
            pAryElementReleaseNotify->Delete(idx);
            pElement->SubRelease();
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ReleaseNotify
//
//  Synopsis:   Notifies registered elements to release contained objects.
//
//  Notes:      elements must register to get this notification using RequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::ReleaseNotify()
{
    CElement *      pElement;
    CNotification   nf;
    int             c;
    CAryElementReleaseNotify * pAryElementReleaseNotify = GetAryElementReleaseNotify();

    if (pAryElementReleaseNotify)
    {
        while (0 < (c = pAryElementReleaseNotify->Size()))
        {
            pElement = (*pAryElementReleaseNotify)[c - 1];

            pAryElementReleaseNotify->Delete(c - 1);

            if (0 < pElement->GetObjectRefs())
            {
                nf.ReleaseExternalObjects(pElement);
                pElement->Notify(&nf);
            }

            pElement->SubRelease();
        }

        Assert (0 == pAryElementReleaseNotify->Size());
    }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::OnCssChange
//
//---------------------------------------------------------------

HRESULT
CDoc::OnCssChange()
{
    HRESULT     hr;

    hr = THR(ForceRelayout());

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::EnsureXmlUrnAtomTable
//
//
//---------------------------------------------------------------

HRESULT
CDoc::EnsureXmlUrnAtomTable(CXmlUrnAtomTable ** ppXmlUrnAtomTable)
{
    HRESULT     hr = S_OK;

    if (!_pXmlUrnAtomTable)
    {
        _pXmlUrnAtomTable = new CXmlUrnAtomTable();
        if (!_pXmlUrnAtomTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (ppXmlUrnAtomTable)
    {
        *ppXmlUrnAtomTable = _pXmlUrnAtomTable;
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::EnsureScriptCookieTable
//
//
//---------------------------------------------------------------

HRESULT
CDoc::EnsureScriptCookieTable(CScriptCookieTable ** ppScriptCookieTable)
{
    HRESULT     hr = S_OK;

    if (!_pScriptCookieTable)
    {
        _pScriptCookieTable = new CScriptCookieTable();
        if (!_pScriptCookieTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (ppScriptCookieTable)
    {
        *ppScriptCookieTable = _pScriptCookieTable;
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::PrivateQueryInterface
//
//  Synopsis:   QueryInterface on our private unknown
//
//---------------------------------------------------------------

HRESULT
CDoc::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    void * appropdescsInVtblOrder = NULL;
    const IID * const * apIID = NULL;

    // Obsolete (replaced by ITargetContainer)
    Assert(!IsEqualIID(iid, IID_ITargetFrame));

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IServiceProvider, _pUnkOuter)
        QI_TEAROFF(this, IMarqueeInfo, _pUnkOuter)
        QI_TEAROFF(this, IPersistFile, _pUnkOuter)
        QI_TEAROFF2(this, IPersist, IPersistFile, _pUnkOuter)
        QI_TEAROFF(this, IPersistMoniker, _pUnkOuter)
        QI_TEAROFF(this, IMonikerProp, _pUnkOuter)
        QI_TEAROFF(this, IHlinkTarget, _pUnkOuter)
        QI_TEAROFF(this, IPersistStreamInit, _pUnkOuter)
        QI_TEAROFF(this, DataSource, _pUnkOuter)
        QI_TEAROFF(this, ITargetContainer, _pUnkOuter)
        QI_TEAROFF(this, IObjectSafety, _pUnkOuter)
        QI_TEAROFF(this, IShellPropSheetExt, _pUnkOuter)
        QI_TEAROFF(this, IPersistHistory, _pUnkOuter)
        QI_TEAROFF(this, ICustomDoc, _pUnkOuter)
        QI_TEAROFF(this, IObjectIdentity, _pUnkOuter)
        QI_TEAROFF2(this, IMarkupServices, IMarkupServices2, _pUnkOuter)
        QI_TEAROFF(this, IMarkupServices2, _pUnkOuter)
        QI_TEAROFF(this, IHighlightRenderingServices, _pUnkOuter)

       QI_TEAROFF(this, IXMLGenericParse, _pUnkOuter)
#if DBG == 1
        QI_TEAROFF( this, IEditDebugServices, _pUnkOuter )
#endif
       QI_TEAROFF( this, IDisplayServices, _pUnkOuter )
       QI_TEAROFF( this, IIMEServices, _pUnkOuter )
       QI_TEAROFF( this, IPrivacyServices, _pUnkOuter )

     default:
        {
            void *          pvTearoff       = NULL;
            const void *    apfnTearoff     = NULL;
            BOOL            fCacheTearoff  = FALSE;

            if (IsEqualIID(iid, CLSID_HTMLDocument))
            {
                *ppv = this;
                return S_OK;
            }
            else if (DispNonDualDIID(iid) ||
                     IsEqualIID(iid, IID_IHTMLDocument) ||
                     IsEqualIID(iid, IID_IHTMLDocument2))
            {
                if (_pCachedDocTearoff)
                {
                    *ppv = _pCachedDocTearoff;
                    goto Cleanup;
                }
                fCacheTearoff = TRUE;
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument2;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument2;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument3))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument3;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument3;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument4))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument4;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument4;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument5))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument5;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument5;
            }
            else if (IsEqualIID(iid, IID_IDispatchEx) ||
                     IsEqualIID(iid, IID_IDispatch))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIDispatchEx;
                apIID = g_apIID_IDispatchEx;
            }
            else if (   IsEqualIID(iid, IID_IOleItemContainer)
                     || IsEqualIID(iid, IID_IOleContainer)
                     || IsEqualIID(iid, IID_IParseDisplayName))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIOleItemContainer;
            }
            else if (IsEqualIID(iid, IID_IInternetHostSecurityManager))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIInternetHostSecurityManager;
            }
            else if (iid == IID_IConnectionPointContainer)
            {
                *((IConnectionPointContainer **)ppv) = 
                    new CConnectionPointContainer(_pWindowPrimary->Document(), this);
                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
                break;
            }
            else if (IsEqualIID(iid, CLSID_CMarkup) && PrimaryMarkup())
            {
                *ppv = PrimaryMarkup();
                return S_OK;
            }
            else if ((IsEqualIID(iid, IID_IMarkupContainer) || 
                      IsEqualIID(iid, IID_IMarkupContainer2)) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIMarkupContainer2;
            }
            else if (IsEqualIID(iid, IID_IHTMLChangePlayback) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIHTMLChangePlayback;
            }
            else if (IsEqualIID(iid, IID_IMarkupTextFrags) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIMarkupTextFrags;
            }

            // Create the tearoff if we need to
            if (pvTearoff)
            {
                HRESULT hr;

                Assert(apfnTearoff);

                hr = THR(CreateTearOffThunk(
                        pvTearoff,
                        apfnTearoff, 
                        NULL, 
                        ppv, 
                        (IUnknown *) PunkOuter(), 
                        *(void **)(IUnknown *) PunkOuter(),
                        QI_MASK | (fCacheTearoff ? CACHEDTEAROFF_MASK : 0),
                        apIID,
                        appropdescsInVtblOrder));
                if (hr)
                    RRETURN(hr);

                if (fCacheTearoff)
                {
                    Assert(!_pCachedDocTearoff);
                    _pCachedDocTearoff = (IHTMLDocument2*) *ppv;
                }
            }
            else
            {
                RRETURN(CServer::PrivateQueryInterface(iid, ppv));
            }
        }
    }

Cleanup:
    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    DbgTrackItf(iid, "CDoc", FALSE, ppv);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::RunningToLoaded
//
//  Synopsis:   Effects the running to loaded state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method stops all embeddings
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::RunningToLoaded ( )
{
    TraceTag((tagCDoc, "%lx CDoc::RunningToLoaded", this));

    HRESULT         hr;
    CNotification   nf;

    hr = THR(CServer::RunningToLoaded());
    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_RUNNING);
        BroadcastNotify(&nf);
    }
    
    _view.Deactivate();

    // If we are the last CDoc left alive clean up the clipboard
    // We can't do this in DllThreadPassivate because COM is shut
    // down at that point
    {
        THREADSTATE * pts = GetThreadState();

        CTlsDocAry * paryDoc = &(pts->_paryDoc);
        int iDoc, nDoc, nRunning = 0;
        CDoc * pDoc;

        for (iDoc = 0, nDoc = paryDoc->Size(); iDoc < nDoc; iDoc++)
        {
            pDoc = paryDoc->Item(iDoc);
            Assert(pDoc);
            if (pDoc->State() > OS_LOADED)
            {
                nRunning++;
                break;
            }
        }

        if (nRunning==0)
        {
            FormClearClipboard(pts);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HitTestPoint
//
//  Synopsis:   Find site at given position
//
//  Arguments   pt              The position.
//              ppSite          The site, can be null on return.
//              dwFlags         HT_xxx flags
//
//  Returns:    HTC
//
//----------------------------------------------------------------------------

HTC
CDoc::HitTestPoint(CMessage *pMessage,
                   CTreeNode ** ppNodeElement,
                   DWORD dwFlags)
{
    HTC         htc;
    CTreeNode * pNodeElement;

    Assert(pMessage);

    // Ensure that pointers are set for simple code down the line.

    if (ppNodeElement == NULL)
    {
        ppNodeElement = &pNodeElement;
    }


    htc = _view.HitTestPoint(
                        pMessage,
                        ppNodeElement,
                        dwFlags);

    TraceTag((tagDocHitTest, "HitTest (%d,%d) -> HTC: %d  pt: (%d,%d)%d  dn: %x  tn: %ls %x",
                pMessage->pt.x, pMessage->pt.y, htc,
                pMessage->ptContent.x, pMessage->ptContent.y, pMessage->coordinateSystem,
                pMessage->pDispNode,
                (*ppNodeElement ? (*ppNodeElement)->_pElement->TagName() : _T("") ),
                *ppNodeElement));

    return htc;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::Update, IOleObject
//
//  Synopsis:   Update object's view cache
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::Update()
{
    HRESULT         hr;

    hr = THR(super::Update());
    if (hr)
        goto Cleanup;

    if (_fHasOleSite)
    {
        CNotification   nf;

        nf.UpdateViewCache(PrimaryRoot());
        BroadcastNotify(&nf);
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::IsUpToDate, IOleObject
//
//  Synopsis:   Is view cache up to date?
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::IsUpToDate ( )
{
    HRESULT         hr;

    hr = THR(super::IsUpToDate());
    if (hr)
        goto Cleanup;

    if (_fHasOleSite)
    {
        CNotification   nf;
        
        nf.UpdateDocUptodate(PrimaryRoot());
        BroadcastNotify(&nf);
        hr = _fIsUpToDate ? S_OK : S_FALSE;
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    if (!_fFullWindowEmbed)
        *pClsid = *BaseDesc()->_pclsid;
    else
        *pClsid = CLSID_HTMLPluginDocument;

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDoc::Close, IOleObject
//
//  Synopsis:   Close this object
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::Close(DWORD dwSaveOption)
{
    HRESULT hr;

    Assert( !_fIsClosingOrClosed );
    _fIsClosingOrClosed = TRUE;

    if (dwSaveOption == OLECLOSE_NOSAVE)
        _fForceCurrentElem = TRUE;

    // Remove all the posted refresh messages (bug 59289)
    GWKillMethodCall(_pWindowPrimary, ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback), 0);

    hr = THR(super::Close(dwSaveOption));
    if (hr)
        goto Cleanup;

    if (_pWindowPrimary)
        _pWindowPrimary->Markup()->TearDownMarkup(FALSE);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::BroadcastNotify
//
//  Synopsis:   Broadcast this notification through the tree
//
//----------------------------------------------------------------------------

void
CDoc::BroadcastNotify(CNotification *pNF)
{
    Assert (pNF);
    Assert( pNF->Element() ); 
    
    CMarkup *   pMarkup = pNF->Element()->GetMarkup();

    if (pMarkup)
    {
        pMarkup->Notify(pNF);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetClientSite, IOleObject
//
//  Synopsis:   Overridden method so we can initialize our state from
//              ambient properties.
//
//  Arguments:  pClientSite    New client site.
//
//  Returns:    HRESULT obtained from CServer::SetClientSite
//
//  Notes:      Delegates to CServer::SetClientSite for the real work.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDoc::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    HRESULT hr;
    HRESULT hr2;
    IUnknown *          pIThumbNailView;
    IUnknown *          pIRenMailEditor = NULL;
    IUnknown *          pIHTMLEditorViewManager;
    IUnknown *          pUnkVid7Hack;
    IUnknown *          pUnkDefView;
    IUnknown *          pUnkActiveDesktop;
    IUnknown *          pUnkMarsPanel;
    IOleCommandTarget * pCommandTarget;

    // Do not set the client site to the same place more than once

    if (IsSameObject(pClientSite, _pClientSite))
        return S_OK;

    TraceTag((tagCDoc, "%lx CDoc::SetClientSite", this));

    //
    // We delay loading the resource dll until client site is set.
    //

    hr = THR(CServer::SetClientSite(pClientSite));
    if (!OK(hr))
        goto Cleanup;

    // If the client site implements IInternetSecurityManager (e.g. HTML dialogs)
    // we want calls to _pSecurityMgr to delegate to the client site.  Do this by
    // "re"setting the security site now that we've made the client site available
    // by hooking it up via CServer::SetClientSite() above.  NOTE: we deliberately
    // do NOT do this for _pPrintSecurityMgr -- that's the reason it's separate! (KTam)
    if (_pSecurityMgr)
    {
        hr = THR(_pSecurityMgr->SetSecuritySite(&_SecuritySite));
        if (hr)
            goto Cleanup;
    }
  
    // hook up design mode (bug 35089)
    PrimaryMarkup()->_fDesignMode = !_fUserMode;

    if (!_fUIHandlerSet)
    {
        SetHostUIHandler(pClientSite);

        // Cache DocHost flags.
        _dwFlagsHostInfo = 0;
    }

    if (pClientSite)
    {
        OnAmbientPropertyChange(DISPID_UNKNOWN);
    }

    // Get an option settings pointer from the registry, now that we have the
    //  client site
    hr = THR(UpdateFromRegistry());
    if(!OK(hr))
        goto Cleanup;

    if (_fInHTMLDlg)
    {
        // HTML dialogs are assumed to be encoded in cpDefault, and must use
        // a META tag to override this if desired.
        PrimaryMarkup()->SwitchCodePage(g_cpDefault);
    }

    if (pClientSite)
    {
        // AppHack (greglett) (108234)
        // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
        // They then use this ProgressChange to do something that may result in a print.
        // Thus, multiple print dialogs appear until they crash.
        // This hack delays the onafterprint event for HtmlHelp until the template is closing.
        // If we rearchitect to remove this plumbing problem (events fired always, immediately),
        // then we should remove this hack.
        //
        // AppHack (gschneid) (21796)
        // Windows 2000 help is broken because they use the strict doctype switch but there document
        // is not a valid css document. More precisely they use measure specifications without unit 
        // specifier. The hack allows in chm (and only in chm[compressed html]) measure specs without
        // unit specifier.

        {
            IOleWindow *pOleWindow;                
            TCHAR acClass[10];
            HWND hwnd;
            hr2 = pClientSite->QueryInterface(IID_IOleWindow, (void**)&pOleWindow);
            if (SUCCEEDED(hr2))
            {
                hr2 = pOleWindow->GetWindow(&hwnd);
                if (SUCCEEDED(hr2)) {
                    for (;
                         hwnd && !g_fInHtmlHelp;
                         hwnd = GetParent(hwnd))
                    {
                        if (GetClassName(hwnd, acClass, 10) > 0)
                        {
                            g_fInHtmlHelp = (_tcsncmp(acClass, 9, _T("HH Parent"), 9) == 0);
                        }
                    }
                }
                ReleaseInterface(pOleWindow);
            }
        }

        void * pv;
        COleSite * pOleSite;

        // If we are hosted in an object tag, don't fire
        // the WebOC events.
        //
        hr2 = pClientSite->QueryInterface(CLSID_HTMLWindow2, &pv);
        if (S_OK == hr2)
        {
            _fDontFireWebOCEvents = TRUE;
            _fInObjectTag = TRUE;
        }

        IServiceProvider *  pSvcPrvdr;

        hr2 = pClientSite->QueryInterface(IID_IServiceProvider, (void**)&pSvcPrvdr);
        if (SUCCEEDED(hr2)) 
        {
            // If hosted in the object tag, inherit DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK
            // setting from the container.
            if (_fInObjectTag)
            {
                CObjectElement *pObjectElement = NULL;
                // This doesn't AddRef, see comment in COleSite::CClient::QueryService
                if (SUCCEEDED(pSvcPrvdr->QueryService(CLSID_HTMLObjectElement, 
                                CLSID_HTMLObjectElement, (void**)&pObjectElement)))
                {
                    if (pObjectElement->HasMarkupPtr())
                    {
                        CDoc *pDoc = NULL;
                        pDoc = pObjectElement->GetMarkupPtr()->Doc();
                        if (pDoc && (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
                            _dwFlagsHostInfo |= DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK;
                    }
                }
            }

            IUnknown *          pUnkTmp;

            hr2 = pSvcPrvdr->QueryService(SID_QIClientSite, IID_IAxWinHostWindow, (void**)&pUnkTmp);
            if (S_OK == hr2)
            {
                // we are being hosted by the WebOC which is hosted in an ATL app.
                _fATLHostingWebOC = TRUE;
                ReleaseInterface(pUnkTmp);
            }

            // Find out if we are a being viewlinked in the WebOC
            //
            hr2 = pSvcPrvdr->QueryService(CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void **) &pOleSite);
            if (S_OK == hr2)
            {
                _fViewLinkedInWebOC = TRUE;

                if (pOleSite->IsInMarkup())
                {
                    CMarkup * pMarkup = pOleSite->GetMarkup();

                    if (pMarkup->_fIsActiveDesktopComponent)
                        _fIsActiveDesktopComponent = TRUE;

                    if (pMarkup->HasWindowedMarkupContextPtr())
                        pMarkup = pMarkup->GetWindowedMarkupContextPtr();

                    //
                    // Calling GetWindowPending guarantees that we will get a proxy.
                    // If the frame that contains us is restricted, then this CDoc's primary
                    // window also has to be restricted.

                    Assert(pMarkup->GetWindowPending());
                    Assert(pMarkup->GetWindowPending()->Window());

                    _pWindowPrimary->Window()->_fRestricted = pMarkup->GetWindowPending()->Window()->_fRestricted;
                }
            }

            ReleaseInterface(pSvcPrvdr);
        }

        // Get the travel log - retrieve it once. (It shouldn't change.)
        //
        if (!_fScriptletDoc)
        {
            // Note, we need to call InitDocHost after _fViewLinkedInWebOC is set.
            InitDocHost();
        }
        
        // Determine if host is ThumbNailView
        if (OK(pClientSite->QueryInterface(IID_IThumbnailView,
                                            (void **)&pIThumbNailView)))
        {
            _fThumbNailView = TRUE;
            ReleaseInterface(pIThumbNailView);
        }

        // Determine if host is Outlook98
        if (OK( pClientSite->QueryInterface( IID_IRenMailEditor,
                                             (void **) & pIRenMailEditor)))
        {
            ClearInterface( & pIRenMailEditor );
            //
            // Host is Outlook, now see if it's Outlook2000 and greater, or Outlook98
            // NOTE (JHarding): This could be a problem in the future since we don't
            // actually use the interface to see what version we're in.
            //
            if (OK( pClientSite->QueryInterface( IID_IRenVersionCheck,
                                                 (void **) & pIRenMailEditor)))
            {
                pIRenMailEditor->Release();
                _fOutlook2000 = TRUE;
            }
            else
            {
                _fOutlook98 = TRUE;
            }
        }

        // Determine if host is VID
        if (OK(THR_NOTRACE(QueryService(
                SID_SHTMLEditorViewManager,
                IID_IHTMLEditorViewManager,
                (void**) &pIHTMLEditorViewManager))))
        {
            _fVID = TRUE;
            pIHTMLEditorViewManager->Release();
        }

        // Determine if host is VID7
        if (OK(THR_NOTRACE(QueryService(
                SID_SHTMEDDesignerHost,
                IID_IUnknown,
                (void**) &pUnkVid7Hack))))
        {
            _fVID7 = TRUE;
            pUnkVid7Hack->Release();
        }

        // Determine if hosted inside webview/defview.  
        if (OK(THR_NOTRACE(QueryService(
                SID_DefView,
                IID_IUnknown,
                (void**) &pUnkDefView))))
        {
            _fDefView = TRUE;
            pUnkDefView->Release();

            if (OK(THR_NOTRACE(QueryService(
                    SID_SShellDesktop,
                    IID_IUnknown,
                    (void**) &pUnkActiveDesktop))))
            {
                _fActiveDesktop = TRUE;
                pUnkActiveDesktop->Release();
            }
        }

        if (OK(THR_NOTRACE(QueryService(
                SID_SMarsPanel, 
                IID_IUnknown,
                (void **) &pUnkMarsPanel))))
        {
            _fInWindowsXP_HSS = TRUE;
            pUnkMarsPanel->Release();
        }

        // Determine if host listens to progress status text by QSing OLECMDID_SETPROGRESSTEXT

        _fProgressStatus = FALSE;
        
        // IE5 bug 59311: outlook 98 doesn't want progress status

        if (!_fOutlook98 && OK(THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget))))
        {
            OLECMD cmd;
            
            cmd.cmdID = OLECMDID_SETPROGRESSTEXT;
            cmd.cmdf = 0;
            
            if (OK(THR_NOTRACE(pCommandTarget->QueryStatus(NULL, 1, &cmd, NULL))))
            {
                if ((cmd.cmdf & (OLECMDF_ENABLED)) && !(cmd.cmdf & (OLECMDF_INVISIBLE)))
                    _fProgressStatus = TRUE;
            }
                
            ReleaseInterface(pCommandTarget);
        }

        // QS host for behavior factory

        ClearInterface(&_pHostPeerFactory);

        hr2 = THR_NOTRACE(QueryService(
            SID_SElementBehaviorFactory, IID_IElementBehaviorFactory, (void**)&_pHostPeerFactory));
        if (S_OK == hr2 && _pHostPeerFactory)
        {
            SetCssPeersPossible();
        }

        IHostBehaviorInit *pHostBehaviorInit;
        hr2 = THR(QueryService(IID_IHostBehaviorInit, IID_IHostBehaviorInit, (void**)&pHostBehaviorInit));
        if (S_OK == hr2)
        {
            Assert(pHostBehaviorInit);
            IGNORE_HR(pHostBehaviorInit->PopulateNamespaceTable());
            pHostBehaviorInit->Release();
        }

        RefreshStatusUI();
    }

    // TODO: Determine why clearing _pVersions is necessary 
    // with open in new Window with Netdocs
    if (_pVersions)
    {
        _pVersions->Release();
        _pVersions = NULL;
    }

    IGNORE_HR(QueryVersionHost());

Cleanup:
   
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::InitDocHost
//
//  Synopsis:   Sets flags and other info in the host.
//
//---------------------------------------------------------------

void
CDoc::InitDocHost()
{
    HRESULT  hr;

    Assert(!_pBrowserSvc);  // This method should be called only once.

    SetHostNavigation(FALSE);
    
    // Shdcovw-specific data
    //
    hr = THR(QueryService(SID_SShellBrowser, IID_IBrowserService, (void**)&_pBrowserSvc));
    if (hr)
        return;

    IGNORE_HR(_pBrowserSvc->QueryInterface(IID_IShellBrowser, (void**)&_pShellBrowser));

    IGNORE_HR(_pBrowserSvc->QueryInterface(IID_ITridentService, (void**)&_pTridentSvc));
        
    if (!_pTravelLog)
    {
        IGNORE_HR(_pBrowserSvc->GetTravelLog(&_pTravelLog));
    }

    Assert(NULL == _pTopWebOC);
    
    hr = QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**)&_pTopWebOC);

    // try to get to an outer object tag 
    
    if (SUCCEEDED(hr))
    {
        IOleObject *pOleObject = NULL;

        hr = _pTopWebOC->QueryInterface(IID_IOleObject, (void**)&pOleObject);

        if (SUCCEEDED(hr))
        {
            IOleClientSite *pOuterClientSite = NULL;
            hr = pOleObject->GetClientSite(&pOuterClientSite);
            if (SUCCEEDED(hr))
            {
                IServiceProvider *pSP = NULL;
                hr = pOuterClientSite->QueryInterface(IID_IServiceProvider, (void**)&pSP);
                if (SUCCEEDED(hr))
                {
                    CObjectElement * pObjectElement = NULL;

                    // This doesn't AddRef, see comment in COleSite::CClient::QueryService
                    pSP->QueryService(CLSID_HTMLObjectElement, CLSID_HTMLObjectElement, (void**)&pObjectElement);

                    if (pObjectElement != NULL)
                    {
                        _fInWebOCObjectTag = TRUE;
                    }
                    ReleaseInterface(pSP);
                }
                ReleaseInterface(pOuterClientSite);
            }
            ReleaseInterface(pOleObject);
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostNavigation
//
//  Synopsis:   Tells the host who should do the navigation. If 
//              fHostNavigates is TRUE, the host should do the 
//              navigation. Otherwise, we will.
//
//---------------------------------------------------------------

void 
CDoc::SetHostNavigation(BOOL fHostNavigates)
{
    HRESULT  hr;
    CVariant cvarWindow(VT_UNKNOWN);

    // Delegate navigation to host, if aggregated (#102173)
    if (!fHostNavigates && 
        (IsAggregated() || (_fMhtmlDoc && _fViewLinkedInWebOC) || _fIsActiveDesktopComponent))
    {
        fHostNavigates = TRUE;
    }

    if (fHostNavigates == (BOOL)_fHostNavigates)  // Optimization
    {
        goto Cleanup;
    }

    _fHostNavigates = fHostNavigates;
    
    if (!fHostNavigates)  // Trident does the navigation.
    {
        Assert(_pWindowPrimary);

        hr = _pWindowPrimary->QueryInterface(IID_IUnknown,
                                             (void**)&V_UNKNOWN(&cvarWindow));
        if (hr)
            goto Cleanup;
    }
    
    Assert(_pClientSite);
    IGNORE_HR(CTExec(_pClientSite,
                     &CGID_DocHostCmdPriv,
                     DOCHOST_DOCCANNAVIGATE,
                     NULL,
                     fHostNavigates ? NULL : &cvarWindow,
                     NULL));

Cleanup:
    return;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostUIHandler
//
//  Synopsis:   Set _pHostUIHandler by using a passed in client
//              site.
//
//  Returns:    HRESULT, always S_OK
//
//---------------------------------------------------------------
HRESULT
CDoc::SetHostUIHandler(IOleClientSite * pClientSite)
{
    HRESULT             hr = S_OK;

    // First off, get rid of the old interface
    ClearInterface(&_pHostUIHandler);

    if(!pClientSite)
        goto Cleanup;


    if(!OK(pClientSite->QueryInterface(IID_IDocHostUIHandler,
                                       (void **)&_pHostUIHandler)))
    {
        _pHostUIHandler = NULL;
    }
    else
    {
        if (!OK(_pHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                (void**)&_pHostUICommandHandler)))
        _pHostUICommandHandler = NULL;
    }


Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnsureBackupUIHandler
//
//  Synopsis:   Ensure our backup UI handler, or CoCreate one if needed.
//
//  Returns:    HRESULT, always S_OK
//
//---------------------------------------------------------------
HRESULT
CDoc::EnsureBackupUIHandler()
{
    HRESULT            hr = S_OK;

    if (_pBackupHostUIHandler)
        goto Cleanup;

    hr = THR(CoCreateInstance(CLSID_DocHostUIHandler,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDocHostUIHandler,
                              (void**)&_pBackupHostUIHandler));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::SetHostNames(LPCTSTR lpstrCntrApp, LPCTSTR lpstrCntrObj)
{
    //  make copies of the new strings and hold on

    _cstrCntrApp.Set(lpstrCntrApp);

    // It's legal for the container object name to be NULL.

    _cstrCntrObj.Set(lpstrCntrObj);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      returns cached moniker on the most recent
//              text file representation of the document;
//              fails if there is no such
//              The text file may be out of sync with actual
//              document
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
{
    HRESULT     hr = S_OK;

    if (!ppmk)
        RRETURN(E_POINTER);

    if (OLEGETMONIKER_UNASSIGN == dwAssign)
        RRETURN(E_INVALIDARG);

    *ppmk = NULL;

    switch (dwWhichMoniker)
    {
    case OLEWHICHMK_OBJFULL:

        if (PrimaryMarkup()->GetNonRefdMonikerPtr())
        {
            *ppmk = PrimaryMarkup()->GetNonRefdMonikerPtr();
            (*ppmk)->AddRef();
        }
        else
        {
            const TCHAR * pchUrl = GetPrimaryUrl();

            if (pchUrl)
            {
                hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
            }
            else
            {
                Assert(0);
//              hr = THR(super::GetMoniker(dwAssign, dwWhichMoniker, ppmk));
            }
        }

        break;

    case OLEWHICHMK_CONTAINER:
    case OLEWHICHMK_OBJREL:

        hr = THR(super::GetMoniker(dwAssign, dwWhichMoniker, ppmk));

        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ParseDisplayName
//
//  Synopsis:   Method of IParseDisplayName interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::ParseDisplayName(LPBC pbc,
        LPTSTR lpszDisplayName,
        ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut)
{
    *ppmkOut = 0;
    *pchEaten = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnumObjects
//
//  Synopsis:   Method of IOleContainer interface
//
//---------------------------------------------------------------

DECLARE_CPtrAry(CDocEnumObjectsAry, IUnknown *, Mt(CDocEnumObjects_paryUnk), Mt(CDocEnumObjects_paryUnk_pv))

STDMETHODIMP
CDocument::EnumObjects(DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown)
{
    HRESULT             hr;
    CDocEnumObjectsAry *paryUnk = NULL;
    int                 i;
    int                 c;
    CElement          * pElement;
    CCollectionCache  * pCollectionCache;
    CMarkup *           pMarkup = Markup();

    // The defined flags are EMBEDDINGS, LINKS, OTHERS, ONLY_USER, and
    // RUNNING.  We only care about EMBEDDINGS and RUNNING.  Return an
    // enumerator for the site array with the appripriate filters.

    Assert(pMarkup);
    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if ( hr )
        goto Cleanup;

    pCollectionCache = pMarkup->CollectionCache();
    Assert(pCollectionCache);

    c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    paryUnk = new CDocEnumObjectsAry;
    if (!paryUnk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(paryUnk->EnsureSize(c));
    if (hr)
        goto Cleanup;

    // Copy the elements into an array.

    for (i = 0; i < c; i++)
    {
        Verify(!pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, i, &pElement));

        if (grfFlags & OLECONTF_EMBEDDINGS)
        {
            // Skip elements that are not OLE Sites

            // Add the element to the array if it
            // is a framesite or olesite element.
            //
            if (pElement->TestClassFlag(CElement::ELEMENTDESC_FRAMESITE) ||
                (pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE) &&
                   DYNCAST(COleSite, pElement)->PunkCtrl()))
            {
                pElement->AddRef();
                Verify(!paryUnk->Append((IUnknown*)pElement));
            }
        }

#if 0
        //
        // This code doesn't make too much sense anymore.  All olesites
        // pretty much always go into at least the running state.
        // (anandra) 04/07/98
        //

        if (grfFlags & OLECONTF_ONLYIFRUNNING)
        {
            // Skip elements that are not running.

            if (pElement->ShouldHaveLayout() && (S_OK != pElement->Notify(SN_ISATLEASTRUNNING, 0)))
                continue;
        }
#endif
    }

    // create an enumerator that:
    // - makes and maintains addrefs on its contained (IUnknown*)s
    // - allocates its own copy of the array of (IUnknown*)s
    // - deletes its array when it goes away

    hr = THR(paryUnk->EnumElements(IID_IEnumUnknown,
                (void **)ppenumUnknown, TRUE, FALSE, TRUE));
    if (hr)
        goto Cleanup;

    paryUnk = NULL;

Cleanup:

    if (paryUnk)
    {
        paryUnk->ReleaseAll();
        delete paryUnk;
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::LockContainer
//
//  Synopsis:   Method of IOleContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::LockContainer(BOOL fLock)
{
    TraceTag((tagCDoc, "%lx CDoc::LockContainer", this));

    //
    // When we support linking to embedded objects then we need to
    // implement this method.
    //
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetObject
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::GetObject(
        LPTSTR lpszItem,
        DWORD dwSpeedNeeded,
        LPBINDCTX pbc,
        REFIID iid,
        void ** ppv)
{
    *ppv = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetObjectStorage
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::GetObjectStorage(
        LPTSTR lpszItem,
        LPBINDCTX pbc,
        REFIID iid,
        void ** ppvStorage)
{
    *ppvStorage = NULL;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsRunning
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::IsRunning(LPTSTR lpszItem)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetCurrentElem
//
//  Synopsis:   Sets the current element - the element that is or will shortly
//              become UI Active. All keyboard messages and commands will
//              be routed to this element.
//
//  Notes:      Note that this function could be called AFTER _pElemCurrent
//              has been removed from the tree.
//
//  Callee:     If SetCurrentElem succeeds, then the callee should do anything
//              appropriate with gaining currency.  The callee must remember
//              that any action performed here must be cleaned up in
//              YieldCurrency.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetCurrentElem(CElement * pElemNext,
                     long       lSubNext,
                     BOOL *     pfYieldFailed,
                     LONG       lButton,
                     BOOL *     pfDisallowedByEd,
                     BOOL       fFireFocusBlurEvents,
                     BOOL       fMnemonic)
{
    HRESULT             hr              = S_OK;
    CElement *          pElemPrev       = _pElemCurrent;
    BOOL                fFireEvent;
    BOOL                fPrevDetached   = !(pElemPrev && pElemPrev->GetFirstBranch());
    CElement::CLock *   pLockPrev       = NULL;
    CTreeNode::CLock *  pNodeLockPrev   = NULL;
    CElement *          pElemNewDefault = NULL;
    CElement *          pElemOldDefault = NULL;
    long                lSubPrev        = _lSubCurrent;
    BOOL                fSameElem       = (pElemPrev == pElemNext);
    BOOL                fDirty          = FALSE;
    BOOL                fDisallowedByEd = FALSE;
    BOOL                fHasFocus       = HasFocus();
    EVENTINFO evtInfo;
    IHTMLEventObj* pEventObj = NULL ;  
    BOOL                fReleasepNode       = FALSE;
    BOOL                fReleasepNodeFrom   = FALSE;
    BOOL                fReleasepNodeTo     = FALSE;
    
    Assert(pElemNext);

    if (pfYieldFailed)
        *pfYieldFailed = FALSE;

    if( pfDisallowedByEd )
        *pfDisallowedByEd = FALSE;
        
    if (fSameElem && lSubNext == _lSubCurrent )
    {
        // Explicitly destroy the prev site-selection and set the caret
        // (#106326). This would have been done implicitly if the currency
        // really got changed and the editor got notified.

        if (fMnemonic && GetSelectionType() == SELECTION_TYPE_Control)
        {
            CMarkupPointer      ptrStart(this);
            IHTMLElement *      pIElement;

            Verify(S_OK == pElemNext->PrivateQueryInterface(IID_IHTMLElement, (void **)&pIElement));
            if (S_OK == ptrStart.MoveToContent(pIElement, TRUE))
            {
                IMarkupPointer *    pIStart = NULL;

                Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
                Verify(S_OK == Select(pIStart, pIStart, SELECTION_TYPE_Caret));
                pIStart->Release();
            }
            ReleaseInterface(pIElement);
        }

        return S_OK;
    }

    if (!pElemNext || !pElemNext->IsInMarkup())
        return S_FALSE;

    // Someone is trying to set currency to pElemNext from its own onfocus handler (#43161)!
    // Break this loop. Note that it is possible to be in pElemNext's onfocus handler
    // even though pElemNext is the current element.
    if (pElemNext->TestLock(CElement::ELEMENTLOCK_FOCUS))
        return S_OK;

    Assert(this == pElemNext->Doc());

    // We would simply assert here and leave it for the caller to ensure that
    // the element is enabled. Most often, the processing needs to stops way
    // before getting here if the element is disabled. Returning quietly here
    // instead of asserting would hide those bugs.
    Assert(pElemNext->IsEnabled());

    // Prevent attempts to delete the sites.

    Assert( pElemNext->GetFirstBranch() );

    CLock LockForm(this, FORMLOCK_CURRENT);


    if (!fPrevDetached)
    {
        pLockPrev = new CElement::CLock(pElemPrev, CElement::ELEMENTLOCK_DELETE);
        pNodeLockPrev = new CTreeNode::CLock;

        hr = THR( pNodeLockPrev->Init(pElemPrev->GetFirstBranch()) );
        if( hr )
            goto Cleanup;
    }

    {
        CElement::CLock     LockNext(pElemNext, CElement::ELEMENTLOCK_DELETE);
        CTreeNode::CLock    NodeLockNext;

        hr = THR( NodeLockNext.Init( pElemNext->GetFirstBranch() ) );
        if( hr )
            goto Cleanup;
    
        _pElemNext = pElemNext;

        // Fire onbeforedeactivate
        if (!fPrevDetached)
        {
    
            if (    !pElemPrev->Fire_ActivationHelper(lSubPrev, pElemNext, lSubNext, TRUE, TRUE, FALSE,
                                 ( _pIHTMLEditor || ShouldCreateHTMLEditor( EDITOR_NOTIFY_BEFORE_FOCUS, pElemNext )) 
                                 ?& evtInfo : NULL ) && !_fForceCurrentElem
                ||  !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                if (pfYieldFailed)
                    *pfYieldFailed = TRUE;

                hr = S_FALSE;
                goto CanNotYield;
            }
        }

        {
            fFireEvent = !pElemPrev->TestLock(CElement::ELEMENTLOCK_UPDATE);
            CElement::CLock LockUpdate(pElemPrev, CElement::ELEMENTLOCK_UPDATE);

            if (fFireEvent && !fPrevDetached && !fSameElem)
            {
                hr = THR_NOTRACE(pElemPrev->RequestYieldCurrency(_fForceCurrentElem));
                // yield if currency changed to a different or the same element that is
                // going to become current.
                if (FAILED(hr) || _pElemNext != pElemNext || _pElemCurrent == pElemNext)
                    goto CanNotYield;
            }

            if (fMnemonic)
            {
                if (!fPrevDetached)
                {
                    pElemPrev->LostMnemonic(); // tell the element that it's losing focus due to a mnemonic
                }

                // Clear any site-selection (#95823)
                if (GetSelectionType() == SELECTION_TYPE_Control)
                {
                    DestroyAllSelection();
                }
            }

            // Give a chance to the editor to cancel/change currency
            if ( pElemNext->_etag != ETAG_ROOT &&
                 pElemNext->IsInMarkup()        )
            {                
                if ( evtInfo._pParam ) // true once we have an editor/ or should create one. 
                {
                    CEventObj::Create(&pEventObj, this, pElemPrev, NULL, FALSE, NULL, evtInfo._pParam);

                    if(evtInfo._pParam->_pNode)
                    {
                        hr = THR( evtInfo._pParam->_pNode->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNode = TRUE;
                    }
                    if (evtInfo._pParam->_pNodeFrom)
                    {
                        hr = THR( evtInfo._pParam->_pNodeFrom->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNodeFrom = TRUE;
                    }
                    if(evtInfo._pParam->_pNodeTo)
                    {
                        hr = THR( evtInfo._pParam->_pNodeTo->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNodeTo = TRUE;
                    }

                    IUnknown* pUnknown = NULL;
                    IGNORE_HR( pEventObj->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
                        
                    fDisallowedByEd = (S_FALSE == NotifySelection( EDITOR_NOTIFY_BEFORE_FOCUS , pUnknown, lButton , pElemNext ));
                    ReleaseInterface( pUnknown );
                    if (pfDisallowedByEd)
                        *pfDisallowedByEd = fDisallowedByEd;            
                }            
            }

            if (fDisallowedByEd && !_fForceCurrentElem)
            {
                hr = S_FALSE;
                goto Done;
            }

            if (    !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                hr = S_FALSE;
                goto CanNotYield;
            }

            // Fire onbeforeactivate
            if (    !pElemNext->Fire_ActivationHelper(lSubNext, pElemPrev, lSubPrev, TRUE, FALSE, FALSE, NULL) && !_fForceCurrentElem
                ||  !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                hr = S_FALSE;
                goto Done;
            }

            // window onblur will be fired only if body was the current site
            // and we are not refreshing
            if (    !_fForceCurrentElem
                &&  fFireFocusBlurEvents
                &&  _pElemCurrent->IsInMarkup()
                &&  _pElemCurrent == _pElemCurrent->GetMarkup()->GetElementClient()
                &&  _pElemCurrent->GetMarkup()->HasWindow()
               )
            {
                _pElemCurrent->GetMarkup()->Window()->Post_onblur();
            }

            if (!fPrevDetached && !fSameElem)
            {
                fFireEvent = !pElemPrev->TestLock(CElement::ELEMENTLOCK_CHANGE);
                CElement::CLock LockChange(pElemPrev, CElement::ELEMENTLOCK_CHANGE);

                if (fFireEvent) // TODO: Why check for fFireEvent here?
                {
                    hr = THR_NOTRACE(pElemPrev->YieldCurrency(pElemNext));
                    if (hr)
                    {
                        if (pfYieldFailed)
                            *pfYieldFailed = TRUE;

                        goto Error;
                    }

                    // bail out if currency changed
                    if (_pElemNext != pElemNext)
                        goto Error;
               }
            }
        }

        // bail out if the elem to become current is no longer in the tree, due to some event code
        if (!pElemNext->IsInMarkup())
            goto Error;

        _pElemCurrent = pElemNext;
        _lSubCurrent = lSubNext;

        // Set focus to the current element
        if (State() >= OS_UIACTIVE && !_fPopupDoc)
        {
            _view.SetFocus(_pElemCurrent, _lSubCurrent);
        }

        _cCurrentElemChanges++;
        
        // Has currency been set in a non-trivial sense?
        if (!_fCurrencySet && _pElemCurrent->Tag() != ETAG_ROOT && _pElemCurrent->Tag() != ETAG_DEFAULT)
        {
            _fCurrencySet = TRUE;
            GWKillMethodCall(this, ONCALL_METHOD(CDoc, DeferSetCurrency, defersetcurrency), 0);
        }

        //
        // marka TODO. OnPropertyChange is dirtying the documnet
        // which is bad for editing clients (bugs 10161)
        // this will go away for beta2.
        //
        fDirty = !!_lDirtyVersion;
        {
            CMarkup * pMarkupNext = pElemNext->GetMarkup();

            if (pMarkupNext->HasDocument())
                IGNORE_HR(pMarkupNext->Document()->OnPropertyChange(DISPID_CDocument_activeElement, 
                                                                    FORMCHNG_NOINVAL, 
                                                                    (PROPERTYDESC *)&s_propdescCDocumentactiveElement));
        }
        if (    !fDirty
            &&  _lDirtyVersion)
        {
            _lDirtyVersion = 0;
        }

        // We fire the blur event AFTER we change the current site. This is
        // because if the onBlur event handler throws up a dialog box then
        // focus will go to the current site (which, if we donot change the
        // current site to be the new one, will still be the previous
        // site which has just yielded currency!).

        if (!fPrevDetached)
        {
            Assert(pElemPrev);
            Assert(pElemPrev != _pElemCurrent || lSubPrev != _lSubCurrent);
            pElemPrev->Fire_ActivationHelper(lSubPrev, _pElemCurrent, _lSubCurrent, FALSE, TRUE, fFireFocusBlurEvents && fHasFocus);
        }

        if (_pElemCurrent && 
            ( pElemPrev != _pElemCurrent || lSubPrev != _lSubCurrent ))
        {            
            _pElemCurrent->Fire_ActivationHelper(_lSubCurrent,
                                                   pElemPrev,
                                                   lSubPrev,
                                                   FALSE,
                                                   FALSE,
                                                   !_fDontFireOnFocusForOutlook98 && fFireFocusBlurEvents);
        }
    }

Cleanup:
    // if forcing, always change the current site as asked
    if (_fForceCurrentElem &&
        _pElemCurrent != pElemNext)
    {
        _pElemCurrent = pElemNext;
        IGNORE_HR(pElemNext->GetMarkup()->Document()->OnPropertyChange(DISPID_CDocument_activeElement, 
                                                                       0,
                                                                       (PROPERTYDESC *)&s_propdescCDocumentactiveElement));
        hr = S_OK;
    }

    if (pElemNext == _pElemCurrent)
    {
        if (!fSameElem)
        {
            // if the button is already the default or a button
            pElemNewDefault = _pElemCurrent->_fActsLikeButton
                                    ? _pElemCurrent
                                    : _pElemCurrent->FindDefaultElem(TRUE);

            if (    pElemNewDefault
                &&  !pElemNewDefault->_fDefault)
            {
                pElemNewDefault->SendNotification(NTYPE_AMBIENT_PROP_CHANGE, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                pElemNewDefault->_fDefault = TRUE;
                pElemNewDefault->Invalidate();
            }
        }
    }

    if (!fPrevDetached && (pElemPrev != _pElemCurrent))
    {
        // if the button is already the default or a button
        pElemOldDefault = pElemPrev->_fActsLikeButton
                                ? pElemPrev
                                : pElemPrev->FindDefaultElem(TRUE);

        if (    pElemOldDefault
            &&  pElemOldDefault != pElemNewDefault)
        {
            pElemOldDefault->SendNotification(NTYPE_AMBIENT_PROP_CHANGE, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
            pElemOldDefault->_fDefault = FALSE;
            pElemOldDefault->Invalidate();
       }
    }

Done:
    if (pLockPrev)
        delete pLockPrev;
    if (pNodeLockPrev)
        delete pNodeLockPrev;


    ReleaseInterface( pEventObj );  
    if ( pEventObj )
    {
        Assert( evtInfo._pParam);
        if ( evtInfo._pParam->_pNode && fReleasepNode )
        {
            evtInfo._pParam->_pNode->NodeRelease();
        }
        if ( evtInfo._pParam->_pNodeFrom && fReleasepNodeFrom )
        {
            evtInfo._pParam->_pNodeFrom->NodeRelease();
        }
        if ( evtInfo._pParam->_pNodeTo && fReleasepNodeTo )
        {
            evtInfo._pParam->_pNodeTo->NodeRelease();
        }        
    }

    RRETURN1(hr, S_FALSE);

CanNotYield:
    if (pfYieldFailed)
        *pfYieldFailed = TRUE;
    goto Done;

Error:
    hr = E_FAIL;
    goto Cleanup;
}

void BUGCALL
CDoc::DeferSetCurrency(DWORD_PTR dwContext)
{
    BOOL    fWaitParseDone = FALSE;

    // If the currency is already set, or we are not yet inplace active 
    // there is nothing to do... 
    if (_fCurrencySet || (State() < OS_INPLACE))
        return;

    // If we are in a dialog, or webview hosting scenario,
    // If parsing is done, then we can activate the first tabbable object.
    if (_fInHTMLDlg || !_fMsoDocMode
                    || (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG))
    {
        if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
        {
            // Parsing is complete, we know which element is the current element, 
            // we can set that element to be the active element
            CElement *      pElement    = NULL;
            long            lSubNext    = 0;

            FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, NULL, 0, &pElement, &lSubNext);
            if (pElement)
            {
                Assert(pElement->IsTabbable(lSubNext));

                // If we are not UI active yet, only set the current element,
                // do not try to activate and scroll in the element.
                // If we are UI active, then we can activate the current element
                // and scroll it into the view.
                if (State() < OS_UIACTIVE)
                {
                    // if the document is not UI Active, then we should not UI activate
                    // the olesite either. If the Olesite becomes UI active, it will force
                    // the containing document to go UI active too.
                    _fDontUIActivateOleSite = TRUE;

                    IGNORE_HR(pElement->BecomeCurrent(lSubNext, NULL, NULL));

                    // reset flag
                    _fDontUIActivateOleSite = FALSE;
                }
                else
                {
                    if (S_OK == pElement->BecomeCurrentAndActive(lSubNext))
                    {
                        IGNORE_HR(THR(pElement->ScrollIntoView()));
                        _fFirstTimeTab = FALSE;
                    }
                }
            }
        }
        else
        {
            // Parsing is not done yet. 
            fWaitParseDone = TRUE;
        }
    }

    // if the currency is not yet set, then make the element client the 
    // current element.
    if (!_fCurrencySet)
    {
        CMarkup  *  pMarkup     = _pElemCurrent ? _pElemCurrent->GetMarkup() : PrimaryMarkup();
        CElement *  pel         = CMarkup::GetElementTopHelper(pMarkup);
        BOOL        fTakeFocus  = (State() >= OS_UIACTIVE) && 
                                    _pInPlace->_fFrameActive;
    
        // 49336 - work around Outlook98 bug which interprets Element_onFocus
        // event that would get fired in the BecomeCurrent below as indication
        // that Trident window gains focus and turns on an internal flag to that
        // effect. The fix is to not fire this onFocus, when the window does
        // not have focus
        _fDontFireOnFocusForOutlook98 = (   _fOutlook98
                                         && !fTakeFocus
                                         && ::GetFocus() != _pInPlace->_hwnd);

        pel->BecomeCurrent(0, NULL, NULL, fTakeFocus);

        _fDontFireOnFocusForOutlook98 = FALSE;

        // If we are waiting for the parsing to be completed, we have to make sure 
        // that we think the currency is not set when we receive the parse done notification.
        // We will activate the first available object when we receive the parse done
        // notification.
        if (fWaitParseDone)
            _fCurrencySet = FALSE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetUIActiveElement
//
//  Synopsis:   UIActivate a given site, often as part of
//              IOleInPlaceSite::OnUIActivate
//
//---------------------------------------------------------------

HRESULT
CDoc::SetUIActiveElement(CElement *pElemNext)
{
    HRESULT     hr = S_OK;
    CElement *  pElemPrev = _pElemUIActive;
    BOOL        fPrevInDesignMode, fNextInDesignMode;

    // Bail out if we are deactivating from Inplace or UI Active.
    if (_pInPlace->_fDeactivating)
        goto Cleanup;

    Assert(!pElemNext || pElemNext->ShouldHaveLayout() || pElemNext->Tag() == ETAG_ROOT || pElemNext->Tag() == ETAG_DEFAULT);
    Assert(!pElemPrev || pElemPrev->ShouldHaveLayout() || pElemPrev->Tag() == ETAG_ROOT || pElemPrev->Tag() == ETAG_DEFAULT);

    if (pElemNext != pElemPrev)
    {
        _pElemUIActive = pElemNext;

        // Tell the old ui-active guy to remove it's ui.

        if (pElemPrev)
        {
            pElemPrev->YieldUI(pElemNext);

            if (pElemPrev->_fActsLikeButton)
            {
                CNotification   nf;

                nf.AmbientPropChange(pElemPrev, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                pElemPrev->_fDefault = FALSE;
                pElemPrev->Notify(&nf);
            }
        }
    }

    if (_state < OS_UIACTIVE)
    {
        // A site is trying to activate.  Tell CServer not to do any
        // menu or border stuff.

        Assert(!_pInPlace->_fChildActivating);
        _pInPlace->_fChildActivating = TRUE;

        // If an embedding is UI active, then the document must be UI active.

        if (TestLock(SERVERLOCK_TRANSITION))
        {
            // We arrived here because CDoc::InPlaceToUIActive is attempting
            // to UI activate one of its sites.  Since we are already in the
            // middle of CDoc::InPlaceToUIActive, all we need to is is call
            // CServer::InPlaceToUIActive to finish the work.
            hr = THR(CServer::InPlaceToUIActive(NULL));
        }
        else
        {
            // Do the normal transition to the UI active state.
            hr = THR(TransitionTo(OS_UIACTIVE, NULL));
        }

        _pInPlace->_fChildActivating = FALSE;

        if (hr)
            goto Cleanup;
    }
       
    fPrevInDesignMode = pElemPrev && pElemPrev->IsEditable(/*fCheckContainerOnly*/TRUE);
    if (fPrevInDesignMode)
    {
        // Erase the grab handles.

        if (    pElemPrev != PrimaryRoot()
            &&  pElemNext != pElemPrev && pElemPrev->ShouldHaveLayout())
        {
            pElemPrev->GetUpdatedLayout()->Invalidate();
        }
    }        
      
    fNextInDesignMode = pElemNext && pElemNext->IsEditable(/*fCheckContainerOnly*/TRUE);
    if (fNextInDesignMode)
    {
        // Erase the grab handles.

        if (pElemNext != PrimaryRoot() && pElemNext->ShouldHaveLayout())
        {
            pElemNext->GetUpdatedLayout()->Invalidate();        
        }
    }    

    if (fPrevInDesignMode || fNextInDesignMode)
    {
        // Notify selection change.
        if (!_pInPlace->_fDeactivating)
        {
            //
            //  Since we report the UI Active control as the contents of
            //  the selected collection, we need to update the property
            //  frame
            //

            IGNORE_HR(OnSelectChange());
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::DeferUpdateUI, DeferUpdateTitle, SetUpdateTimer
//
//  Synopsis:   Post a request to ourselves to update the UI.
//
//-------------------------------------------------------------------------

void
CDoc::DeferUpdateUI()
{
    TraceTag((tagUpdateUI, "CDoc::DeferUpdateUI"));

    _fNeedUpdateUI = TRUE;

    SetUpdateTimer();
}

void
CDoc::DeferUpdateTitle(CMarkup* pMarkup /*=NULL*/)
{
    if ( ! pMarkup )
    {
        pMarkup = PrimaryMarkup();
    }    
    if ( ! _fInObjectTag && ! _fViewLinkedInWebOC &&
         ! _fInWebOCObjectTag &&
         ( pMarkup->IsPrimaryMarkup() ||
           pMarkup->IsPendingPrimaryMarkup() ) )
    {
        TraceTag((tagUpdateUI, "CDoc::DeferUpdateTitle"));

        _fNeedUpdateTitle = TRUE;
        
        SetUpdateTimer();
    }
}

void
CDoc::SetUpdateTimer()
{
    // If called before we're inplace or have a window, just return.
    if (!_pInPlace || !_pInPlace->_hwnd)
        return;

    if (!_fUpdateUIPending)
    {
        _fUpdateUIPending = TRUE;
        SetTimer(_pInPlace->_hwnd, TIMER_DEFERUPDATEUI, 100, NULL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnUpdateUI
//
//  Synopsis:   Process UpdateUI message.
//
//-------------------------------------------------------------------------

void
CDoc::OnUpdateUI()
{
    IOleCommandTarget * pCommandTarget = NULL;

    TraceTag((tagUpdateUI, "CDoc::OnUpdateUI"));

    Assert(InPlace());

    KillTimer(_pInPlace->_hwnd, TIMER_DEFERUPDATEUI);
    _fUpdateUIPending = FALSE;

    if (_fNeedUpdateUI)
    {
        if (_pHostUIHandler)
        {
           _pHostUIHandler->UpdateUI();
        }

        Assert(_pClientSite);
        if (_pClientSite)
        {
            IGNORE_HR(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget));
        }

        // update container UI.

        if (pCommandTarget)
        {
#ifndef NO_OLEUI
            // update menu/toolbar
            pCommandTarget->Exec(NULL, OLECMDID_UPDATECOMMANDS, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            pCommandTarget->Release();
#endif // NO_OLEUI
        }

        _fNeedUpdateUI = FALSE;
    }

    if (_fNeedUpdateTitle)
    {
        UpdateTitle();
    }
}

void
CDoc::UpdateTitle(CMarkup * pMarkup /* = NULL */)
{
    VARIANTARG var;
    IOleCommandTarget * pCommandTarget = NULL;
    TCHAR szBuf[1024];
    TCHAR achUrl[pdlUrlLen + sizeof(DWORD)/sizeof(TCHAR)];
    DWORD cchUrl;
    HRESULT hr;
    CStr cstrFile;

    TraceTag((tagUpdateUI, "CDoc::UpdateTitle"));

    if (!_pClientSite || (_fDefView && !_fActiveDesktop))
    {
        return;
    }

    hr = _pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);
    if (hr)
        goto Cleanup;

    // update title
    var.vt      = VT_BSTR;
    if (PrimaryMarkup()->GetTitleElement() && 
        PrimaryMarkup()->GetTitleElement()->Length())
    {
        var.bstrVal = PrimaryMarkup()->GetTitleElement()->GetTitle();
    }
    else
    {
        const TCHAR * pchUrl = GetPrimaryUrl();

        if (pchUrl && GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
        {
            TCHAR achFile[MAX_PATH];
            ULONG cchFile = ARRAY_SIZE(achFile);

            hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            hr = THR(cstrFile.Set(achFile)); // need memory format of a BSTR
            if (hr)
                goto Cleanup;

            var.bstrVal = cstrFile;
        }
        else if (pchUrl && !DesignMode())
        {
            // need to unescape the url when setting title

            if (S_OK == CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0,
                                           achUrl + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(achUrl) - sizeof(DWORD) / sizeof(TCHAR),
                                           &cchUrl, 0))
            {
                var.bstrVal = achUrl + sizeof(DWORD) / sizeof(TCHAR);
            }
            else
            {
                var.bstrVal = (TCHAR*) pchUrl;
            }

            *(DWORD *)achUrl = _tcslen(V_BSTR(&var)); 

        }
        else
        {
            *((DWORD *)szBuf)=LoadString(GetResourceHInst(),
                                         IDS_NULL_TITLE,
                                         szBuf+sizeof(DWORD)/sizeof(TCHAR),
                                         ARRAY_SIZE(szBuf) -
                                             sizeof(DWORD) / sizeof(TCHAR));
            Assert(*((DWORD *)szBuf) != 0);
            var.bstrVal = szBuf + sizeof(DWORD) / sizeof(TCHAR);
        }
    }

    pCommandTarget->Exec(
            NULL,
            OLECMDID_SETTITLE,
            MSOCMDEXECOPT_DONTPROMPTUSER,
            &var,
            NULL);

    TraceTag((tagUpdateUI, "CDoc::UpdateTitle to \"%ls\"", var.bstrVal));

    // Fire the WebOC TitleChange event.
    //
    if (pMarkup)
    {
        _webOCEvents.FrameTitleChange(pMarkup->Window());
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    _fNeedUpdateTitle = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetDocCoords, IMarqueeInfo
//
//  Synopsis:   Returns the size information anbout the current doc. This method is
//              called only when the mshtml is hosted inside the marquee control.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::GetDocCoords(LPRECT pViewRect, BOOL bGetOnlyIfFullyLoaded, BOOL *pfFullyLoaded, int WidthToFormatPageTo)
{
    HRESULT     hr     = S_OK;
    SIZE        lsize;
    CSize       size;
    CMarkup *   pMarkup = PrimaryMarkup();
    BOOL        fReady = (pMarkup->GetReadyState() == READYSTATE_COMPLETE);
    CElement *  pElement = CMarkup::GetCanvasElementHelper(pMarkup);

    // Marquee control should support doc host interface, but it does not.
    // Fix things up for it.
    _dwFlagsHostInfo  |= DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_SCROLL_NO;

    *pfFullyLoaded = fReady;

    pViewRect->left   =
    pViewRect->top    =
    pViewRect->right  =
    pViewRect->bottom = 0;

    if (bGetOnlyIfFullyLoaded && !fReady)
        return S_FALSE;

    if (!pMarkup ||
        !pMarkup->GetElementClient() || 
        pMarkup->GetElementClient() == PrimaryRoot())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pElement);
    //
    // Make sure that document is at least running, otherwise CalcSize will assert.
    //

    if (State() < OS_RUNNING)
    {
        hr = THR(TransitionTo(OS_RUNNING, NULL));
        if (hr)
            goto Cleanup;
    }

    if (_view.IsActive())
    {
        _view.Activate();
        _view.SetFlag(CView::VF_FULLSIZE);
    }

    size.cx = WidthToFormatPageTo;
    size.cy = 0;

    // No scrollbars wanted inside the marquee ocx.
    if (!(pMarkup->GetFrameOptions() & FRAMEOPTIONS_SCROLL_NO))
    {
        CElement * pBody = CMarkup::GetElementClientHelper(pMarkup);

        pMarkup->SetFrameOptions(FRAMEOPTIONS_SCROLL_NO);

        // Suppress scrollbar only if doc has a body (no frameset).
        if (pBody && pBody->Tag() == ETAG_BODY)
        {
            IGNORE_HR(pElement->OnPropertyChange(DISPID_A_SCROLL, 
                                                 ELEMCHNG_SIZECHANGED, 
                                                 (PROPERTYDESC *)&s_propdescCBodyElementscroll) );
        }
    }

    _view.SetViewSize(size);
    _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_FORCE);

    if (pElement)
    {
        pElement->GetUpdatedLayout()->GetContentSize(&size, FALSE);
    }

    //
    // Ensure size is a safe minimum and convert to HIMETRIC
    //
    size.Max(CSize(WidthToFormatPageTo,1));
    lsize.cx = HimetricFromHPix(size.cx);       //  Screen device Xform.
    lsize.cy = HimetricFromVPix(size.cy);
    
    //  TODO (greglett) Do we need to update the measuring device on the view here?
    CServer::SetExtent(DVASPECT_CONTENT, &lsize);

    pViewRect->right  = size.cx;
    pViewRect->bottom = size.cy;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetGenericParse, IXMLGenericParse
//
//  Synopsis:   If true, throws tokenizer and stylesheet selector parser into a mode
//              where all unqualified tags are treated as generic tags and real
//              html tags must be prefaced by html: namespace
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetGenericParse(VARIANT_BOOL fDoGeneric)
{
    if (!PrimaryMarkup())
        return E_FAIL;
    PrimaryMarkup()->SetXML(fDoGeneric == VARIANT_TRUE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureHostStyleSheets
//
//  Synopsis:   Ensure the document's stylesheets collection exists, and create it if not
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureHostStyleSheets()
{
    CStyleSheet *   pSS = NULL;
    HRESULT         hr = S_OK;
    
    if (_pHostStyleSheets || !_cstrHostCss)
        return S_OK;

    _pHostStyleSheets = new CStyleSheetArray(this, NULL, 0);
    if (!_pHostStyleSheets || _pHostStyleSheets->_fInvalid)
        return E_OUTOFMEMORY;

    hr = THR(_pHostStyleSheets->CreateNewStyleSheet(NULL, &pSS));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);  // cannot be using predownloaded version...
    hr = S_OK;

    {
        CCSSParser  cssparser(pSS, NULL, PrimaryMarkup()->IsXML(), PrimaryMarkup()->IsStrictCSS1Document());

        cssparser.Write(_cstrHostCss, lstrlen(_cstrHostCss));

        cssparser.Close();
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PreSetErrorInfo
//
//  Synopsis:   Update the UI whenever the form is returned from.
//
//----------------------------------------------------------------------------

void
CDoc::PreSetErrorInfo()
{
    super::PreSetErrorInfo();

    DeferUpdateUI();
}

//+------------------------------------------------------------------------
//
//  Member:     CreateDoc
//
//  Synopsis:   Creates a new doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase * STDMETHODCALLTYPE
CreateDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateDoc");
    pBase = new CDoc(pUnkOuter);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateMhtmlDoc
//
//  Synopsis:   Creates a new MHTML doc instance.  This is identical to
//              a regular doc instance, except that IPersistMoniker::Load
//              first needs to convert the moniker to one that points
//              to actual HTML.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateMhtmlDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateMhtmlDoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_MHTML);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateMhtmlDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHTADoc
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to understand HTA behavior
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateHTADoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateHTADoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_HTA);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateHTADoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreatePopupDoc
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to understand Popup window behavior
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreatePopupDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreatePopupDoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_POPUP);
    PerfDbgLog(tagPerfWatch, NULL, "-CreatePopupDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateDocFullWindowEmbed
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to perform the implicit full-window-embed support
//              for a URL referencing a plugin handled object.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateDocFullWindowEmbed(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateDocFullWindowEmbed");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_FULLWINDOWEMBED);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateDocFullWindowEmbed");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetClassDesc, CBase
//
//  Synopsis:   Return the class descriptor.
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC *
CDoc::GetClassDesc() const
{
    return (CBase::CLASSDESC *)&s_classdesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::SetReadyState
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SetReadyState(long readyState)
{
    HRESULT hr = S_OK;
    
    if (GetReadyState() != readyState)
    {
        if (readyState < GetReadyState())
            goto Cleanup;

        PerfLog2(tagGasGauge, this, "%d 0 0 %ls", 100 + readyState, Url() ? Url() : _T(""));
        PerfDbgLog1(tagPerfWatch, this, "+CDoc::SetReadyState %s",
            readyState == READYSTATE_LOADING ? "LOADING" :
            readyState == READYSTATE_LOADED ? "LOADED" :
            readyState == READYSTATE_INTERACTIVE ? "INTERACTIVE" :
            readyState == READYSTATE_COMPLETE ? "COMPLETE" : "(Unknown)");

        hr = SetAAreadystate(readyState);
        if (hr)
            goto Cleanup;

        if (readyState == READYSTATE_COMPLETE)
        {
            if (Doc()->_fNeedUpdateTitle)
            {
                PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (UpdateTitle)");
                Doc()->UpdateTitle(this);
            }

            if (Doc()->_pDSL)
            {
                PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (_pDSL->dataMemberChanged())");
                Doc()->_pDSL->dataMemberChanged(_T(""));
            }

            if (   g_fInMSWorksCalender
                && GetUrlScheme(Url()) == URL_SCHEME_FILE )
            {
                if (!IsPrimaryMarkup() && !_fLoadingHistory)
                {
                    _pDoc->_webOCEvents.FireDownloadEvents(Window(),
                                                           CWebOCEvents::eFireDownloadComplete);
                }

                _pDoc->_webOCEvents.NavigateComplete2(Window());
            }
        }

        if (HasWindowPending())
        {
            COmWindowProxy *pOmWindow = GetWindowPending();

            if (!(    g_fInMSWorksCalender
                  &&  NULL == _tcsicmp(_T("about:Microsoft%20Works%20HTML%20Print%20Services"), Url())))
            {
                if (pOmWindow->Window()->_pMarkupPending &&
                    readyState == READYSTATE_LOADING &&
                    pOmWindow->Window()->_pMarkup->_LoadStatus == LOADSTATUS_DONE)
                {
                    Assert(pOmWindow->Window()->_pMarkupPending == this);
                    _fDelayFiringOnRSCLoading = TRUE;
                }
                else
                {
                    PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (FirePropertyNotify)");
                    pOmWindow->Document()->FirePropertyNotify(DISPID_READYSTATE, TRUE);

                    PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (Fire_onreadystatechange)");
                    pOmWindow->Document()->Fire_onreadystatechange();
                }
            }
        }

        PerfDbgLog(tagPerfWatch, this, "-CDoc::SetReadyState");
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetSpin
//
//  Synopsis:   Sets the animation state (the spinny globe)
//
//  Arguments:  fSpin: TRUE to spin the globe, FALSE to stop it
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CDoc::SetSpin(BOOL fSpin)
{
    if (!!_fSpin != !!fSpin)
    {
        _fSpin = ENSURE_BOOL(fSpin);
        _fShownSpin = FALSE;

        UpdateLoadStatusUI();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetProgress
//
//  Synopsis:   Sets the position of the progress text+thermometer.
//
//  Arguments:  pchStatusText:  progress string, can be NULL
//              ulProgress:     less than or equal to ulProgressMax
//              ulProgressMax:  if zero, hides the thermometer
//              fFlash:         if TRUE, progress is cleared next time
//                              a SetStatusText string is shown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetProgress(DWORD dwFlags, TCHAR *pchText, ULONG ulPos, ULONG ulMax, BOOL fFlash)
{
    HRESULT hr;

    if (dwFlags & PROGSINK_SET_TEXT)
    {
        hr = THR(_acstrStatus[STL_PROGSTATUS].Set(pchText));
        if (hr)
            goto Cleanup;

        if (_iStatusTop >= STL_PROGSTATUS)
        {
            _iStatusTop = (pchText && *pchText) ? STL_PROGSTATUS : STL_LAYERS;
            _fShownProgText = FALSE;
        }
    }

    if (    (dwFlags & PROGSINK_SET_MAX)
        &&  _ulProgressMax != ulMax)
    {
        _ulProgressMax = ulMax;
        _fShownProgMax = FALSE;
    }

    if (    (dwFlags & PROGSINK_SET_POS)
        &&  _ulProgressPos != ulPos)
    {
        _ulProgressPos = ulPos;
        _fShownProgPos = FALSE;
    }

    _fProgressFlash = fFlash;

    hr = THR(UpdateLoadStatusUI());

Cleanup:
    RRETURN(hr);
}

COmWindowProxy*
CDoc::GetCurrentWindow()
{
    COmWindowProxy * pWindow = NULL;

    if (_pElemCurrent && _pElemCurrent->IsInMarkup())
    {
        CMarkup * pMarkup = _pElemCurrent->GetMarkup()->GetFrameOrPrimaryMarkup();

        if (pMarkup)
        {
            pWindow = pMarkup->Window();
        }
    }
    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
        Assert(pWindow);
    }
    return pWindow;
}

void
CDoc::SetFocusWithoutFiringOnfocus()
{
    if (_fPopupDoc || _fIsPrintWithNoUI)
        return;

    COmWindowProxy *    pWindow                 = GetCurrentWindow();
    BOOL                fOldFiredWindowFocus    = pWindow->_fFiredWindowFocus;
    BOOL                fInhibitFocusFiring     = _fInhibitFocusFiring;

    // Do not fire window onfocus if the inplace window didn't
    // previously have the focus (NS compat)
    if (fInhibitFocusFiring)
        pWindow->_fFiredWindowFocus = TRUE;

    if (RequestFocusFromServer())
        ::SetFocus(_pInPlace->_hwnd);

    // restore the old FiredFocus state
    if (fInhibitFocusFiring)
        pWindow->_fFiredWindowFocus = fOldFiredWindowFocus;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetStatusText
//
//  Synopsis:   Sets status text, remembering it if not in-place active.
//              Passing NULL clears status text.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetStatusText(TCHAR * pchStatusText, LONG statusLayer, CMarkup * pMarkup /* = NULL */)
{
    HRESULT hr = S_OK;
    
    // _fProgressFlash means that next time we have real status to show,
    // the progress text should be cleared (used for "Done"). So if we have
    // real status, clear progress.

    if (_fProgressFlash && pchStatusText && *pchStatusText)
    {
        SetProgress(PROGSINK_SET_TEXT | PROGSINK_SET_POS | PROGSINK_SET_MAX, NULL, 0, 0);
        _fProgressFlash = FALSE;
    }

    // NS compat: after window.defaultStatus has been set, the behavior changes
    if (statusLayer == STL_DEFSTATUS)
        _fSeenDefaultStatus = TRUE;
        
    LONG c;
    CStr *pcstr;

    hr = THR(_acstrStatus[statusLayer].Set(pchStatusText));
    if (hr)
        goto Cleanup;
        
    // Figure out what should be showing on the status bar (_iStatusTop):
    if (pchStatusText && *pchStatusText)
    {
        // NS compat: when nonempty, rollstatus, status, or defaultStatus go directly to the status bar
        // (For NS compat examples, see IE5 bug 65272, 65880)
        
        if (_iStatusTop >= statusLayer || statusLayer <= STL_DEFSTATUS)
        {
            _iStatusTop = statusLayer;
            UpdateStatusText();
        }
    }
    else
    {
        // NS compat: when clearing rollstatus, status, or default status, status bar will show:
        // window.status or lower layers if .defaultStatus has never been set or
        // window.defaultStatus or lower layers if .defaultStatus has been set.
        
        if (_iStatusTop <= statusLayer || statusLayer <= STL_DEFSTATUS)
        {
            LONG startLayer;

            startLayer = (_fSeenDefaultStatus ? STL_DEFSTATUS : STL_TOPSTATUS);
            for (pcstr = _acstrStatus + startLayer, c = STL_LAYERS - startLayer; c; pcstr += 1, c -= 1)
            {
                if (*pcstr && **pcstr)
                    break;
            }

            _iStatusTop = pcstr - _acstrStatus;
            UpdateStatusText();
        }
    }

    if (pMarkup)
    {
        _webOCEvents.FrameStatusTextChange(pMarkup->Window(), pchStatusText);
    }


Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateStatusText
//
//  Synopsis:   Sets status text, remembering it if not in-place active.
//              Passing NULL clears status text.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::UpdateStatusText()
{
    HRESULT hr = S_OK;
    
    if (_pInPlace && _pInPlace->_pFrame)
    {
        TCHAR *pchStatusText;

        // IE5 59311: don't report progress text to Outlook 98

        if (_iStatusTop < STL_LAYERS && (_fProgressStatus || _iStatusTop < STL_PROGSTATUS))
            pchStatusText = _acstrStatus[_iStatusTop];
        else
            pchStatusText = NULL;
        
        hr = THR(_pInPlace->_pFrame->SetStatusText(pchStatusText));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::RefreshStatusUI
//
//  Synopsis:   Causes all status UI to be refreshed; used when becoming
//              in-place active.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CDoc::RefreshStatusUI()
{
    _fShownProgPos  = FALSE;
    _fShownProgMax  = FALSE;
    _fShownProgText = FALSE;

    _fShownSpin     = !_fSpin;
    UpdateLoadStatusUI();
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateStatusUI
//
//  Synopsis:   Updates status text, progress text, progress thermometer,
//              and spinning globe of client.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::UpdateLoadStatusUI()
{
    IOleCommandTarget * pCommandTarget;
    HRESULT hr = S_OK;

    if (_pClientSite)
    {
        VARIANTARG var;

        hr = THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleCommandTarget,
                (void **)&pCommandTarget));
        if (hr)
            goto Cleanup;

        if (!_fShownProgText)
        {
            THR_NOTRACE(UpdateStatusText());
            _fShownProgText = TRUE;
        }

        if (!_fShownProgMax)
        {
            var.vt = VT_I4;
            var.lVal = _ulProgressMax;
            pCommandTarget->Exec(NULL, OLECMDID_SETPROGRESSMAX,
                MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownProgMax = TRUE;
        }

        if (!_fShownProgPos)
        {
            var.vt = VT_I4;
            var.lVal = _ulProgressPos;
            pCommandTarget->Exec(NULL, OLECMDID_SETPROGRESSPOS,
                MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownProgPos = TRUE;
        }

        if (!_fShownSpin)
        {
            var.vt = VT_I4;
            var.lVal = _fSpin;
            pCommandTarget->Exec(NULL, OLECMDID_SETDOWNLOADSTATE,
                    MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownSpin = TRUE;
        }

        pCommandTarget->Release();
    }

Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------
//
//  Member:     CDoc::HandleKeyNavigate
//
//  Synopsis:   Navigate to the next CSite/CElement that can take focus
//              based on the message.
//
//---------------------------------------------------------------

HRESULT
CDoc::HandleKeyNavigate(CMessage * pmsg, BOOL fAccessKeyNeedCycle)
{
    HRESULT         hr       = S_FALSE;
    FOCUS_DIRECTION dir = (pmsg->dwKeyState & FSHIFT) ?
                            DIRECTION_BACKWARD: DIRECTION_FORWARD;
    CElement *      pCurrent = NULL;
    CElement *      pNext = NULL;
    CElement *      pStart = NULL;
    long            lSubNew = _lSubCurrent;
    BOOL            fFindNext = FALSE;
    BOOL            fAccessKey = !(IsTabKey(pmsg) || IsFrameTabKey(pmsg));
    CElement *      pElementClient = CMarkup::GetElementClientHelper(PrimaryMarkup());
    unsigned        cCurrentElemChangesOld;

    // It is possible to have site selection even at browse time, if the user
    // is tabbing in an editable container such as HTMLAREA.
    BOOL            fSiteSelected   = (GetSelectionType() == SELECTION_TYPE_Control);
    BOOL            fSiteSelectMode = ((_pElemCurrent && _pElemCurrent->IsEditable(/*fCheckContainerOnly*/TRUE)) || fSiteSelected);
    BOOL            fYieldFailed    = FALSE;

    if (!pElementClient)
    {
        hr = S_FALSE;
        goto Cleanup;
    }   

    // FrameTab key is used to tab among frames. If this is not a frameset,
    // the usual thing to do is to pass up the message so that it goes to the
    // parent frameset document. However, if pmsg->lParam == 0, then it means
    // that pmsg is passed down from the parent document's CFrameSite, so
    // _pElemClient is activated.
    if (pElementClient->Tag() != ETAG_FRAMESET && IsFrameTabKey(pmsg))
    {
        if (pmsg->lParam)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = THR(pElementClient->BecomeCurrentAndActive(pmsg->lSubDivision, NULL, pmsg, TRUE));
        }
        goto Cleanup;
    }

    //
    // Detect time when this is the first time tabbing into the doc
    // and bail out in that case.  Let the shell take focus.
    //

    if (_fFirstTimeTab)
    {
        // This bit should only be set under certain circumstances.
        hr = S_FALSE;
        _fFirstTimeTab = FALSE;
        goto Cleanup;
    }

    //
    // First find the element from which to start
    //

    if ((!fSiteSelectMode && _pElemCurrent == PrimaryRoot()) ||
        (fAccessKeyNeedCycle && pmsg->message == WM_SYSKEYDOWN) ||
        (IsTabKey(pmsg) && !pmsg->lParam))
    {
        if ((IsTabKey(pmsg)) && (!pmsg->lParam) && (DIRECTION_FORWARD == dir))
        {
            // Raid 61972
            // we just tab down to a frame CBodyElement, need to set the flag
            // so we know we need to tab out when SHIFT+_TAB
            //
            _fNeedTabOut = TRUE;
        }
        pStart = NULL;
        fFindNext = TRUE;
    }
    else if (!fSiteSelectMode && _pElemCurrent->IsTabbable(_lSubCurrent))
    {
        pStart = _pElemCurrent;
        fFindNext = TRUE;
    }
    else if (_pElemCurrent->Tag() != ETAG_ROOT)
    {
        // Tab to the element next to the caret/selection (unless the root element is
        // current - bug #65023)
        //
        // marka - don't force create the editor. Only do the below if we have an editor already.
        //
        IHTMLEditor*    pEditor     = GetHTMLEditor(FALSE);
        CElement *      pElemStart  = NULL;

        if ( pEditor && ((_pCaret && _pCaret->IsVisible() ) || // if caret visible 
                         (GetSelectionType() == SELECTION_TYPE_Text)   || 
                         (GetSelectionType() == SELECTION_TYPE_Control) )  // there is selection, then follow this route
           )
        {
            IHTMLElement *  pIElement   = NULL;
            BOOL            fNext       = TRUE;

            Assert(pEditor);
            if ( pEditor && S_OK == pEditor->GetElementToTabFrom( dir == DIRECTION_FORWARD, &pIElement, &fNext)
                &&  pIElement)
            {
                Verify(S_OK == pIElement->QueryInterface(CLSID_CElement, ( void**) & pElemStart));
                Assert(pElemStart);

                if (pElemStart->HasMasterPtr())
                {
                    pElemStart = pElemStart->GetMasterPtr();
                }
                if (pElemStart)
                {
                    pStart = pElemStart;
                    fFindNext = (   fNext 
                                 || !fAccessKey && !pStart->IsTabbable(_lSubCurrent)
                                 || fAccessKey && !pStart->MatchAccessKey(pmsg, 0)
                                );

                    if (!fFindNext)
                    {
                        pCurrent = pStart;
                    }
                }
                pIElement->Release();
            }
        }
        
        if (!pElemStart)
        {
            pStart = _pElemCurrent;
            fFindNext = TRUE;
        }
    }
    else
    {
        pStart = NULL;
        fFindNext = TRUE;
    }

    if (pStart && pStart == pElementClient && !pStart->IsTabbable(_lSubCurrent))
    {
        pStart = NULL;
    }

    if (fFindNext)
    {
        Assert(!pCurrent);
        FindNextTabOrder(dir, fAccessKey, pmsg, pStart, _lSubCurrent, &pCurrent, &lSubNew);
    }

    hr = S_FALSE;
    if (!pCurrent)
        goto Cleanup;

    // This better not be FrameTab unless the doc is a frameset doc.
    Assert (pElementClient->Tag() == ETAG_FRAMESET || !IsFrameTabKey(pmsg));

    cCurrentElemChangesOld = _cCurrentElemChanges;
    if (!fAccessKey)
    {
        do
        {
            if (pNext)
            {
                pCurrent = pNext;
            }

            pmsg->lSubDivision = lSubNew;

            // Raid 61972
            // Set _fNeedTabOut if pCurrent is a CBodyElement so that we will
            // not try to SHIFT+TAB to CBodyElement again.
            //
            _fNeedTabOut = (!pCurrent->IsEditable(/*fCheckContainerOnly*/FALSE) && (pCurrent->Tag() == ETAG_BODY))
                         ? TRUE : FALSE;

            hr = THR_NOTRACE(pCurrent->HandleMnemonic(pmsg, FALSE, &fYieldFailed));
            Assert(!(hr == S_OK && fYieldFailed));
            if (hr && fYieldFailed)
            {
                hr = S_OK;
            }
            // We do not want to retry if currency was changed, even if to some other element
            if (hr == S_FALSE && cCurrentElemChangesOld != _cCurrentElemChanges)
            {
                hr = S_OK;
            }
        }
        while (hr == S_FALSE &&
               FindNextTabOrder(dir, FALSE, pmsg, pCurrent, pmsg->lSubDivision, &pNext, &lSubNew) &&
               pNext);
    }
    else
    {
        // accessKey case here
        //
        _fNeedTabOut = FALSE;
        do
        {
            if (pNext)
            {
                pCurrent = pNext;
            }


            FOCUS_ITEM fi = pCurrent->GetMnemonicTarget(lSubNew);

            if (fi.pElement)
            {
                if (fi.pElement == pCurrent)
                {
                    pmsg->lSubDivision = fi.lSubDivision;
                    hr = THR_NOTRACE(fi.pElement->HandleMnemonic(pmsg, TRUE, &fYieldFailed));
                }
                else
                {
                    CMessage msg;

                    msg.message = WM_KEYDOWN;
                    msg.wParam = VK_TAB;
                    msg.lSubDivision = fi.lSubDivision;
                    hr = THR_NOTRACE(fi.pElement->HandleMnemonic(&msg, TRUE, &fYieldFailed));
                }
                Assert(!(hr == S_OK && fYieldFailed));
                if (FAILED(hr) && fYieldFailed)
                {
                    hr = S_OK;
                }
                // We do not want to retry if currency was changed, even if to some other element
                if (hr == S_FALSE && cCurrentElemChangesOld != _cCurrentElemChanges)
                {
                    hr = S_OK;
                }
            }

            if (hr == S_FALSE)
            {
               FindNextTabOrder(dir, TRUE, pmsg, pCurrent, pmsg->lSubDivision, &pNext, &lSubNew);
            }
        }
        while (hr == S_FALSE && pNext);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FindNextTabOrder
//
//  Synopsis:   Given an element and a subdivision within it, find the
//              next tabbable item.
//
//----------------------------------------------------------------------------

BOOL
CDoc::FindNextTabOrder(
    FOCUS_DIRECTION     dir,
    BOOL                fAccessKey,
    CMessage *          pmsg,
    CElement *          pCurrent,
    long                lSubCurrent,
    CElement **         ppNext,
    long *              plSubNext)
{
    BOOL fFound = FALSE;
    CMarkup * pMarkup;

    *ppNext = NULL;

    if (    DIRECTION_FORWARD == dir
        &&  pCurrent

        // Don't go into INPUT's slave markup. We know that
        // the INPUT does not have any tabbale elements inside.
        &&  pCurrent->Tag() != ETAG_INPUT
        &&  pCurrent->HasSlavePtr()       
        //
        // marka - dont drill into a master, if it's inside something editable
        //
        
        &&  pCurrent->GetFirstBranch() 
        &&  ! pCurrent->GetFirstBranch()->Parent()->Element()->IsEditable(/*fCheckContainerOnly*/FALSE)  )
    {
        pMarkup = pCurrent->GetSlavePtr()->GetMarkup();
        pCurrent = NULL;
    }
    else if (pCurrent)
        pMarkup = pCurrent->GetMarkup();
    else
    {
        pMarkup = PrimaryMarkup();
    }
    
    while (!*ppNext && pMarkup)
    {
        fFound = pMarkup->FindNextTabOrderInMarkup(dir, fAccessKey, pmsg, pCurrent, lSubCurrent, ppNext, plSubNext);

        if (*ppNext)
        {
            // *plSubNext == -2 means we need to drill in to find the access key target
            if (    (!fAccessKey || -2 == *plSubNext)
                &&  (*ppNext)->HasSlavePtr()
                &&  (*ppNext)->Tag() != ETAG_INPUT
                &&  !((*ppNext)->GetSlavePtr()->GetMarkup()->IsPrintMedia())
               )
            {
                // drill in  if tabbing backwards or if master is not a tabstop

                BOOL fDrillIn = FALSE;

                if (fAccessKey || DIRECTION_BACKWARD == dir)
                {
                    fDrillIn = TRUE;
                }
                else
                {
                    fDrillIn = !(*ppNext)->IsMasterTabStop();
                }
                if (fDrillIn)
                {
                    pMarkup = (*ppNext)->GetSlavePtr()->GetMarkup();
                    pCurrent = NULL;
                    *ppNext = NULL;
                    lSubCurrent = 0;
                    continue;
                }
            }
            break;
        }

        //
        // marka - don't step out of a viewlink at design time.
        //
        if (pMarkup->Root()->HasMasterPtr() && 
            ( pMarkup->Root()->GetMasterPtr()->GetFirstBranch() &&
              ! pMarkup->Root()->GetMasterPtr()->GetFirstBranch()->Parent()->Element()->IsEditable(/*fCheckContainerOnly*/FALSE) ))
        {
            pCurrent = pMarkup->Root()->GetMasterPtr();
            if (DIRECTION_BACKWARD == dir)
            {
                if (fAccessKey)
                {
                    if (pCurrent->MatchAccessKey(pmsg, 0))
                    {
                        FOCUS_ITEM fi = pCurrent->GetMnemonicTarget(0);

                        if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                        {
                            *ppNext = pCurrent;
                            *plSubNext = 0;
                            fFound = TRUE;
                        }
                    }
                }
                else
                {
                    if (pCurrent->IsTabbable(0) && pCurrent->IsMasterTabStop())
                    {
                        *ppNext = pCurrent;
                        *plSubNext = 0;
                        fFound = TRUE;
                    }
                }
            }
            pMarkup = pCurrent->GetMarkup();
        }        
        else
            break;
    }

    return fFound;
}

BOOL
CMarkup::FindNextTabOrderInMarkup(
    FOCUS_DIRECTION     dir,
    BOOL                fAccessKey,
    CMessage *          pmsg,
    CElement *          pCurrent,
    long                lSubCurrent,
    CElement **         ppNext,
    long *              plSubNext)
{
    BOOL        fFound = FALSE;
    CElement *  pElemTemp   = pCurrent;
    long        lSubTemp    = lSubCurrent;     

    // make sure focus cache is up to date    
    if (_fFocusCacheDirty && !fAccessKey)
    {
        CCollectionCache *  pCollCache;
        CElement *          pElement;
        CAryFocusItem     * paryFocusItem;          
        int                 i;
        
        _fFocusCacheDirty = FALSE;
        
        paryFocusItem = GetFocusItems(TRUE);    
        Assert (paryFocusItem);    
        paryFocusItem->DeleteAll();

        EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION);
        pCollCache = CollectionCache();
        if (!pCollCache)
            return FALSE;
            
        for (i = 0; i < pCollCache->SizeAry(CMarkup::ELEMENT_COLLECTION); i++)
        {
            pCollCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, i, &pElement);
            if (pElement)
            {
                InsertFocusArrayItem(pElement);
            }
        }
    }

    for(;;)
    {
        *ppNext    = NULL;
        *plSubNext = 0;

        // When Shift+Tabbing, start the search with those not in the Focus array (because
        // they are at the bottom of the tab order)
        if (fAccessKey || (!pCurrent && DIRECTION_BACKWARD == dir))
            break;

        fFound = SearchFocusArray(dir, pElemTemp, lSubTemp, ppNext, plSubNext);
    
        if (!fFound || !*ppNext || (*ppNext)->IsTabbable(*plSubNext) )
             break;

        Assert(pElemTemp != *ppNext || lSubTemp != *plSubNext);

        pElemTemp   = *ppNext;
        lSubTemp    = *plSubNext;
    }

    if (!*ppNext)
    {
        if (fFound)
        {
            if (DIRECTION_BACKWARD == dir)
            {
                return TRUE;
            }
            else
            {
                //
                // Means pCurrent was in focus array, but next tabbable item is not
                // Just retrieve the first tabbable item from the tree.
                //

                pCurrent = NULL;
                lSubCurrent = 0;
            }
        }

        fFound = SearchFocusTree(dir, fAccessKey, pmsg, pCurrent, lSubCurrent, ppNext, plSubNext);

        //
        // If element was found, but next item is not in
        // the tree and we're going backwards, return the last element in
        // the focus array.
        //

        CAryFocusItem * paryFocusItem = GetFocusItems(TRUE);
        Assert (paryFocusItem);
        if (!*ppNext &&
            !fAccessKey &&
            (fFound || !pCurrent) &&
            dir == DIRECTION_BACKWARD &&
            paryFocusItem->Size() > 0)
        {
            long    lLast = paryFocusItem->Size() - 1;

            while (lLast >= 0)
            {
                pElemTemp = (*paryFocusItem)[lLast].pElement;
                lSubTemp = (*paryFocusItem)[lLast].lSubDivision;
                if (pElemTemp->IsTabbable(lSubTemp))
                {
                    *ppNext = pElemTemp;
                    *plSubNext = lSubTemp;
                    fFound = TRUE;
                    break;
                }
                lLast--;
            }
        }
    }

    return fFound;
}


//+--------------------------------------------------------------
//
//  Member:     CMarkup::DocTraverseGroup
//
//  Synopsis:   Called by (e.g.)a radioButton, this function
//      takes the groupname and queries the markup's collection for the
//      rest of the group and calls the provided CLEARGROUP function on that
//      element. The traversal stops if the visit function returns S_OK or
//      and an error.
//
//---------------------------------------------------------------

HRESULT
CMarkup::MarkupTraverseGroup(
        LPCTSTR                 strGroupName,
        PFN_VISIT               pfn,
        DWORD_PTR               dw,
        BOOL                    fForward)
{
    HRESULT             hr = S_OK;
    long                i, c;
    CElement          * pElement;
    CCollectionCache  * pCollectionCache;
    LPCTSTR             lpName;

    _fInTraverseGroup = TRUE;

    // The control is at the document level. Clear all other controls,
    // also at document level, which are in the same group as this control.

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();
    Assert(pCollectionCache);

    // get size of collection
    c = pCollectionCache->SizeAry(ELEMENT_COLLECTION);

    if (fForward)
        i = 0;
    else
        i = c - 1;

    // if nothing is in the collection, default answer is S_FALSE.
    hr = S_FALSE;

    while (c--)
    {
        hr = THR(pCollectionCache->GetIntoAry(ELEMENT_COLLECTION, i, &pElement));
        if (fForward)
            i++;
        else
            i--;
        if (hr)
            goto Cleanup;

        hr = S_FALSE;                   // default answer again.

        // ignore the element if it is not a site
        if (!pElement->ShouldHaveLayout())
            continue;

        // ignore the element if it is in a form
        if (pElement->GetParentForm())
            continue;

        lpName = pElement->GetAAname();

        // is this item in the target group?
        if ( lpName && FormsStringICmp(strGroupName, lpName) == 0 )
        {
            // Call the function and break out of the
            // loop if it doesn't return S_FALSE.
#ifdef WIN16
            hr = THR( (*pfn)(pElement, dw) );
#else
            hr = THR( CALL_METHOD(pElement, pfn, (dw)) );
#endif
            if (hr != S_FALSE)
                break;
        }
    }

Cleanup:
    _fInTraverseGroup = FALSE;
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CDoc::FindDefaultElem
//
//  Synopsis:   find the default/Cancel button in the Doc
//
//              fCurrent means looking for the current default layout
//
//---------------------------------------------------------------
CElement *
CMarkup::FindDefaultElem(BOOL fDefault, BOOL fCurrent /* FALSE */)
{
    HRESULT             hr      = S_FALSE;
    long                c       = 0;
    long                i       = 0;
    CElement          * pElem   = NULL;
    CCollectionCache  * pCollectionCache;

    hr = THR(EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();
    Assert(pCollectionCache);

    // Collection walker cached the value on the doc, go get it

    // get size of collection
    c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    while (c--)
    {
        hr = THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                        i++,
                        &pElem));

        if (hr)
        {
            pElem = NULL;
            goto Cleanup;
        }

        if (!pElem || pElem->_fExittreePending)
            continue;

        if (fCurrent)
        {
            if (pElem->_fDefault)
                goto Cleanup;
            continue;
        }

        if (pElem->TestClassFlag(fDefault?
                    CElement::ELEMENTDESC_DEFAULT
                    : CElement::ELEMENTDESC_CANCEL)
            && !pElem->GetParentForm()
            && pElem->IsVisible(TRUE)
            && pElem->IsEnabled())
        {
            goto Cleanup;
        }
    }
    pElem = NULL;

Cleanup:
    return pElem;
}

//+----------------------------------------------------------------------
//
//  Member:     CDoc::GetOmWindow
//
//  Synopsis:   returns IDispatch of frame # nFrame;
//              the IDispatch is script window of doc inside the frame
//
//-----------------------------------------------------------------------

HRESULT
CMarkup::GetCWindow(LONG nFrame, IHTMLWindow2 ** ppCWindow)
{
    CElement *  pElem;
    HRESULT     hr;

    hr = THR(EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, nFrame, &pElem));
    if (hr)
        goto Cleanup;

    hr = THR((DYNCAST(CFrameSite, pElem))->GetCWindow(ppCWindow));

Cleanup:
    RRETURN (hr);
}

#ifndef NO_DATABINDING
//+-------------------------------------------------------------------------
//
// Member:              Get Data Bind Task (public)
//
// Synopsis:    return my databind task, creating one if necessary.
//              Used only by databinding code, where the real work is done.
//
//-------------------------------------------------------------------------

CDataBindTask *
CMarkup::GetDataBindTask()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (!pDBTask)
    {
        pDBTask = new CDataBindTask(Doc(), this);

        if (pDBTask)
            pDBTask->SetEnabled(_fDataBindingEnabled);
    }

    IGNORE_HR(SetDBTask(pDBTask));

    return pDBTask;
}

//+-------------------------------------------------------------------------
//
// Member:              Get Simple Data Converter (public)
//
// Synopsis:    return my data converter, creating one if necessary.
//              Used only by databinding code, to handle elements bound with
//              dataFormatAs = localized-text.
//
//-------------------------------------------------------------------------

ISimpleDataConverter *
CMarkup::GetSimpleDataConverter()
{
    AssertSz(GetDBTask(), "SimpleDataConverter used when no databinding present");
    return GetDBTask()->GetSimpleDataConverter();
}

//+-------------------------------------------------------------------------
//
// Member:      SetDataBindingEnabled (public)
//
// Synopsis:    Set the enabled flag on my databind task (if any).
//              If this enables the task, then tell it to run.
//
// Returns:     previous value of enabled flag
//-------------------------------------------------------------------------

BOOL
CMarkup::SetDataBindingEnabled(BOOL fEnabled)
{
    CDataBindTask * pDBTask = GetDBTask();
    BOOL fOldValue = _fDataBindingEnabled;

    _fDataBindingEnabled = fEnabled;
    if (pDBTask)
    {
        pDBTask->SetEnabled(fEnabled);
        if (!fOldValue && fEnabled)
            TickleDataBinding();
    }
    return fOldValue;
}


//+-------------------------------------------------------------------------
//
// Member:              TickleDataBinding (public)
//
// Synopsis:    Ask my databind task to try to bind all the deferred
//              bindings.  This can be called repeatedly, as more bindings
//              enter the world.
//-------------------------------------------------------------------------

void
CMarkup::TickleDataBinding()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (pDBTask)
        pDBTask->DecideToRun();
}


//+-------------------------------------------------------------------------
//
// Member:              ReleaseDataBinding (public)
//
// Synopsis:    Release my databinding resources.
//
//-------------------------------------------------------------------------

void
CMarkup::ReleaseDataBinding()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (pDBTask)
    {
        pDBTask->Terminate();
        pDBTask->Release();
        IGNORE_HR(SetDBTask(NULL));
    }
    SetDataBindingEnabled(FALSE);
}
#endif // ndef NO_DATABINDING

//+------------------------------------------------------------------------
//
// Utility function to force layout on all windows in the thread
//
//-------------------------------------------------------------------------

void
OnSettingsChangeAllDocs(BOOL fNeedLayout)
{
    int i;

    for (i = 0; i < TLS(_paryDoc).Size(); i++)
    {
        TLS(_paryDoc)[i]->OnSettingsChange(fNeedLayout);
    }
}

//+---------------------------------------------------------------------------
//
// OnOptionSettingsChange()
//
//----------------------------------------------------------------------------
HRESULT
CDoc::OnSettingsChange(BOOL fForce /* =FALSE */)
{
    BOOL fNeedLayout = FALSE;

    if (!IsPrintDialogNoUI())
    {
#ifndef NO_SCRIPT_DEBUGGER
        BYTE fDisableScriptDebuggerOld = _pOptionSettings ?
            _pOptionSettings->fDisableScriptDebugger : BYTE(-1);
#endif // NO_SCRIPT_DEBUGGER

        // Invalidate cached script based font info
        if (_pOptionSettings)
            _pOptionSettings->InvalidateScriptBasedFontInfo();

        IGNORE_HR(UpdateFromRegistry(REGUPDATE_REFRESH, &fNeedLayout));

        if (_pOptionSettings)
        {
            THREADSTATE * pts = GetThreadState();

#ifndef NO_SCRIPT_DEBUGGER
            Assert (fDisableScriptDebuggerOld != BYTE(-1));

            if (!_pOptionSettings->fDisableScriptDebugger &&
                 (fDisableScriptDebuggerOld == 1))
            {
                //
                // The user has chosen to enable the script debugger, which had
                // been disabled.  Now any scripts need to be re-parsed, which
                // means that the document needs to be reloaded.
                //
                _pWindowPrimary->ExecRefresh(OLECMDIDF_REFRESH_RELOAD);
            }
            else
            {
                if (_pOptionSettings->fDisableScriptDebugger &&
                    !fDisableScriptDebuggerOld &&
                    PrimaryMarkup()->GetScriptCollection())
                {
                    //
                    // The user has chosen to turn off the script debugger,
                    // which was previously enabled.
                    //

                    DeinitScriptDebugging();
                }
            }
#endif // NO_SCRIPT_DEBUGGER

            if (fNeedLayout || fForce)
            {
                if (_pWindowPrimary)
                {
                    PrimaryMarkup()->BubbleDownClearDefaultCharFormat();
                    PrimaryMarkup()->BubbleDownClearThemeDeterminedFlag();
                    ForceRelayout();
                }
            }

            pts->_iFontHistoryVersion++;

        }
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     SwitchCodePage
//
//  Synopsis:   Change the codepage of the document.  Should only be used
//              when we are already at a valid codepage setting.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::SwitchCodePage(CODEPAGE codepage)
{
    HRESULT hr = S_OK;
    BOOL fReadCodePageSettings;
    UINT uiFamilyCodePage = CP_UNDEFINED;
    CODEPAGESETTINGS * pCodepageSettings = GetCodepageSettings();

    // Remember if we were autodetected
    _fCodePageWasAutoDetect = GetCodePage() == CP_AUTO_JP;

    // If codepage settings don't exist or the information is stale,
    // reset the information, as well as the charformat cache.

    if (pCodepageSettings)
    {
        if (pCodepageSettings->uiFamilyCodePage != codepage)
        {
            uiFamilyCodePage = WindowsCodePageFromCodePage(codepage);

            fReadCodePageSettings = pCodepageSettings->uiFamilyCodePage != uiFamilyCodePage;
        }
        else
        {
            fReadCodePageSettings = FALSE;
        }
    }
    else
    {
        uiFamilyCodePage = WindowsCodePageFromCodePage(codepage);
        fReadCodePageSettings = TRUE;
    }

    if (fReadCodePageSettings)
    {
        // Read the settings from the registry
        // Note that this call modifies CDoc::_codepage.

        hr = THR( ReadCodepageSettingsFromRegistry( codepage, uiFamilyCodePage, FALSE ) );

        // ReadCodepageSettingsFromRegistry will update the code page settings ptr on the
        // markup. Hence we need to refetch the codepage settings ptr from the markup.
        pCodepageSettings = GetCodepageSettings();

        if (pCodepageSettings && (IsPrimaryMarkup() || IsPendingPrimaryMarkup()))
        {
            Doc()->_sBaselineFont = GetCodepageSettings()->sBaselineFontDefault;
        }

        if (GetElementClient())
            GetElementClient()->Invalidate();
        ClearDefaultCharFormat();
        EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    }
        
    // Set the codepage
    hr = SetCodePage(codepage);
    if (hr)
        goto Cleanup;

    hr = SetFamilyCodePage(GetCodepageSettings()->uiFamilyCodePage);
    if (hr)
        goto Cleanup;

    if (HtmCtx())
    {
        HtmCtx()->SetCodePage(codepage);
    }

Cleanup:
    RRETURN(hr);
}

CODEPAGE
CMarkup::GetCodePageCore()
{
    Assert( !_codepage );

    if (IsPrimaryMarkup())
        return g_cpDefault;

    CElement * pElemMaster = Root()->GetMasterPtr();

    if (!pElemMaster)
        return g_cpDefault;

    switch (pElemMaster->Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
        return g_cpDefault;
    default:
        if (!pElemMaster->IsInMarkup())
            return g_cpDefault;
        return pElemMaster->GetMarkup()->GetCodePage();
    }
}

CODEPAGE
CMarkup::GetFamilyCodePageCore()
{
    Assert( !_codepageFamily );

    if (IsPrimaryMarkup())
        return g_cpDefault;

    CElement * pElemMaster = Root()->GetMasterPtr();

    if (!pElemMaster)
        return g_cpDefault;

    switch (pElemMaster->Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
        return g_cpDefault;
    default:
        if (!pElemMaster->IsInMarkup())
            return g_cpDefault;
        return pElemMaster->GetMarkup()->GetFamilyCodePage();
    }
}

void
CMarkup::BubbleDownAction(BUBBLEACTION pfnBA, void *pvArgs)
{
    HRESULT hr;
    IHTMLFramesCollection2 * pFramesCollection = 0;

    CALL_METHOD(this, pfnBA, (pvArgs));

    // get frames collection
    hr = THR(Window()->get_frames(&pFramesCollection));
    if (hr)
        goto Cleanup;

    if (pFramesCollection)
    {
        // get frames count
        long cFrames;
        hr = THR(pFramesCollection->get_length(&cFrames));
        if (hr || (cFrames == 0))
            goto Cleanup;

        hr = THR(EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
        if (hr)
            goto Cleanup;

        for (long i = 0; i < cFrames; i++)
        {
            CElement * pElement;
            
            hr = THR(CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pElement));
            if (hr)
                goto Cleanup;

            CFrameSite *pFrameSite = DYNCAST(CFrameSite, pElement);
            if (pFrameSite)
            {
                // Get the markup associated with the frame.
                CMarkup * pNestedMarkup = pFrameSite->_pWindow ? pFrameSite->_pWindow->Markup() : NULL;
                if (pNestedMarkup)
                {
                    // Bubble down action
                    pNestedMarkup->BubbleDownAction(pfnBA, pvArgs);
                }
            }
        }
    }

Cleanup:
    if (pFramesCollection)
        pFramesCollection->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::IsAvailableOffline
//
//  Synopsis:   Determines if URL is availble when off line.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsAvailableOffline(LPCTSTR pchUrl, CElement *pElementContext)
{
    HRESULT hr;
    BOOL    fResult = FALSE;
    DWORD   f;
    DWORD   dwSize;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpUrl = cBuf;

    if (!pchUrl)
        goto Cleanup;

    // $$anandra Need markup
    hr = THR(CMarkup::ExpandUrl(
            NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpUrl, pElementContext));
    if (hr)
        goto Cleanup;

    hr = THR(CoInternetQueryInfo(pchExpUrl,
            QUERY_USES_NETWORK,
            0,
            &f,
            sizeof(f),
            &dwSize,
            0));

    if (FAILED(hr) || !f)
    {
        fResult = TRUE;
        goto Cleanup;
    }

    hr = THR(CoInternetQueryInfo(pchExpUrl,
            QUERY_IS_CACHED_OR_MAPPED,
            0,
            &f,
            sizeof(f),
            &dwSize,
            0));

    if (FAILED(hr))
        goto Cleanup;

    fResult = f;

Cleanup:
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddRefUrlImgCtx
//
//  Synopsis:   Returns a cookie to the background image specified by the
//              given Url and element context.
//
//  Arguments:  lpszUrl         Relative URL of the background image
//              pElemContext    Element to begin search for nearest <BASE> tag
//
//  Returns:    Cookie which refers to the background image
//
//----------------------------------------------------------------------------

HRESULT
CDoc::AddRefUrlImgCtx(LPCTSTR lpszUrl, CElement *pElemContext, LONG *plCookie, BOOL fForceReload)
{
    CDwnCtx *   pDwnCtx;
    CImgCtx *   pImgCtx;
    URLIMGCTX * purlimgctx;
    LONG        iurlimgctx;
    LONG        iurlimgctxFree = -1;
    LONG        curlimgctx;
    HRESULT     hr;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pszExpUrl   = cBuf;
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;
    BOOL        fPendingRoot;
    CMarkup *   pMarkup = PrimaryMarkup();

    Assert( pElemContext );

    if (pElemContext->IsInMarkup())
        pMarkup = pElemContext->GetMarkup();

    *plCookie = 0;

    hr = THR(CMarkup::ExpandUrl(
            NULL, lpszUrl, ARRAY_SIZE(cBuf), pszExpUrl, pElemContext));
    if (hr)
        goto Cleanup;

    // See if we've already got a background image with this Url

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    // TODO (mohanb / lmollico): The IsOverlapped test is a hack for #64357
    if (    pElemContext->GetMarkup()
        &&  pElemContext->GetMarkup()->_LoadStatus == LOADSTATUS_DONE
        && !pElemContext->IsOverlapped()
        && fForceReload
        && !_fBackgroundImageCache)
    {
        iurlimgctx = curlimgctx;
    }
    else
    {
        for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
        {
            if (purlimgctx->ulRefs == 0)
            {
                purlimgctx->fZombied = FALSE;
                iurlimgctxFree = iurlimgctx;
            }
            else
            {
                const TCHAR *pchSlotUrl;

                pchSlotUrl = purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl;
                Assert(pchSlotUrl);
            
                if (    pchSlotUrl 
                    &&  purlimgctx->pMarkup == pMarkup 
                    &&  StrCmpC(pchSlotUrl, pszExpUrl) == 0)
                {
                    // Found it.  Increment the reference count on this entry and
                    // hand out a cookie to it.

                    purlimgctx->ulRefs += 1;
                    *plCookie = iurlimgctx + 1;

                    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%ld(%ls))",
                        *plCookie, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs,
                        pElemContext->_nSerialNumber, pElemContext->TagName()));

                    hr = THR(purlimgctx->aryElems.Append(pElemContext));

                    goto Cleanup;
                }
            }
        }
    }

    // No luck finding an existing image.  Get a new one and add it to array.

    if (iurlimgctxFree == -1)
    {
        hr = THR(_aryUrlImgCtx.EnsureSize(iurlimgctx + 1));
        if (hr)
            goto Cleanup;

        iurlimgctxFree = iurlimgctx;

        _aryUrlImgCtx.SetSize(iurlimgctx + 1);

        // N.B. (johnv) We need this so that the CPtrAry inside URLIMGCTX
        // gets initialized.
        memset(&_aryUrlImgCtx[iurlimgctxFree], 0, sizeof(URLIMGCTX));
    }

    purlimgctx = &_aryUrlImgCtx[iurlimgctxFree];

    // grab the current security state

    fPendingRoot = pMarkup->IsPendingRoot();

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);
    
    // If the URL is not secure....
    if (sslPrompt == SSL_PROMPT_QUERY && !IsUrlSecure(pszExpUrl))
    {
        // If a query is required, save the url and post a message to start download later
        
        GWPostMethodCallEx(GetThreadState(), (void *)this,
                           ONCALL_METHOD(CDoc, OnUrlImgCtxDeferredDownload, onurlimgctxdeferreddownload),
                           0, FALSE, "CDoc::OnUrlImgCtxDeferredDownload");

        if (!_dwCookieUrlImgCtxDef && CMarkup::GetProgSinkHelper(PrimaryMarkup()))
        {
            CMarkup::GetProgSinkHelper(PrimaryMarkup())->AddProgress(PROGSINK_CLASS_MULTIMEDIA, &_dwCookieUrlImgCtxDef);
            CMarkup::GetProgSinkHelper(PrimaryMarkup())->SetProgress(_dwCookieUrlImgCtxDef, PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_MAX, PROGSINK_STATE_LOADING, NULL, 0, 0, 1);
        }
        
        pImgCtx = NULL;
        hr = THR(purlimgctx->cstrUrl.Set(pszExpUrl));
        if (hr)
            goto Cleanup;
    }
    else if (sslPrompt == SSL_PROMPT_DENY && !IsUrlSecure(pszExpUrl))
    {
        pImgCtx = NULL;
        hr = THR(purlimgctx->cstrUrl.Set(pszExpUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO Pass lpszUrl, not pszExpUrl, due to ExpandUrl bug.
        hr = THR(NewDwnCtx(DWNCTX_IMG, lpszUrl, pElemContext,
                    &pDwnCtx, fPendingRoot, TRUE));
        if (hr)
            goto Cleanup;
            
        pImgCtx = (CImgCtx *)pDwnCtx;

    }

    if (pImgCtx)
    {
        pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(PrimaryMarkup()));
        pImgCtx->SetCallback(OnUrlImgCtxCallback, this);
        // (greglett) Should be IsPrintMedia or is in print media context.
        pImgCtx->SelectChanges((!pElemContext->IsPrintMedia() && _pOptionSettings->fPlayAnimations) ? IMGCHG_COMPLETE|IMGCHG_ANIMATE
            : IMGCHG_COMPLETE, 0, TRUE); // TRUE: disallow prompting
    }

    // _aryUrlImgCtx array could be changed and we can't be sure that purlimgctx point 
    // to the same structure. Refer to bug 30282, we prevent crashing in next line.
    if (purlimgctx != &_aryUrlImgCtx[iurlimgctxFree])
        goto Cleanup;

    hr = THR(purlimgctx->aryElems.Append(pElemContext));
    if (hr)
        goto Cleanup;
        
    purlimgctx->ulRefs   = 1;
    purlimgctx->pImgCtx  = pImgCtx;
    purlimgctx->pMarkup  = pMarkup;
    *plCookie            = iurlimgctxFree + 1;

    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%d(%ls))",
        *plCookie, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs,
        pElemContext->_nSerialNumber, pElemContext->TagName()));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxDeferredDownload
//
//  Synopsis:   Callback to validate security of backround images.
//
//----------------------------------------------------------------------------
void
CDoc::OnUrlImgCtxDeferredDownload(DWORD_PTR dwContext)
{
    // loop through array of urlimgctx's and kick off downloads for all
    // those that have urls without imgctx's.

    CDwnCtx *   pDwnCtx;
    CImgCtx *   pImgCtx;
    LONG        iurlimgctx;
    URLIMGCTX * purlimgctx;
    LONG        curlimgctx;
    HRESULT     hr;
    CStr        cstrUrl;
    
    if (InRootSslPrompt())
    {
        _fNeedUrlImgCtxDeferredDownload = TRUE;
        return;
    }
    
    curlimgctx = _aryUrlImgCtx.Size();

    // structured inefficiently to withstand array motion on reentrancy

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx)
    {
        purlimgctx = _aryUrlImgCtx + iurlimgctx;
        
        if (    purlimgctx->ulRefs > 0 
            &&  purlimgctx->pImgCtx == NULL 
            &&  purlimgctx->cstrUrl
            && !purlimgctx->fZombied)
        {
            CElement *  pElemTest = NULL;
            // make a copy (motivated by stress crash where AddRefUrlImgCtx is called inside pushed message loop of NewDwnCtx)
            
            cstrUrl.Set(purlimgctx->cstrUrl);

            // (jbeda) For fPending root, can we assume that all elemnts are in the same pending
            // root?  What if they have been moved around since we posted?  We can't use
            // pMarkup that we have cached because we aren't addrefing that pointer so
            // lets just grab the first element and use that to see if we are in the pending world
            // or not.
            BOOL fPendingRoot = FALSE;
            if (purlimgctx->aryElems.Size())
            {
                pElemTest = purlimgctx->aryElems[0];
                if (pElemTest->IsInMarkup())
                    fPendingRoot = pElemTest->GetMarkup()->IsPendingRoot();
            }

            hr = THR(NewDwnCtx(DWNCTX_IMG, cstrUrl, NULL, &pDwnCtx, fPendingRoot, FALSE)); // FALSE: allow prompting
            if (!hr)
            {
                // Check for sanity of aryUrlImgCtx after possible pushed message loop in NewDwnCtx (motivated by stress crash)

                if (    iurlimgctx < _aryUrlImgCtx.Size()
                    && !_aryUrlImgCtx[iurlimgctx].pImgCtx
                    && _aryUrlImgCtx[iurlimgctx].cstrUrl
                    && !StrCmpC(cstrUrl, _aryUrlImgCtx[iurlimgctx].cstrUrl))
                {
                    pImgCtx = (CImgCtx *)pDwnCtx;
                    
                    if (pImgCtx)
                    {
                        pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(PrimaryMarkup()));
                        pImgCtx->SetCallback(OnUrlImgCtxCallback, this);
                        // (greglett) Should be IsPrintMedia or is in print media context.
                        pImgCtx->SelectChanges((!(pElemTest && pElemTest->IsPrintMedia()) && _pOptionSettings->fPlayAnimations) ? IMGCHG_COMPLETE|IMGCHG_ANIMATE
                            : IMGCHG_COMPLETE, 0, TRUE);
                            
                        _aryUrlImgCtx[iurlimgctx].cstrUrl.Free();
                    }
                    _aryUrlImgCtx[iurlimgctx].pImgCtx  = pImgCtx;
                }
                else
                {
                    pDwnCtx->Release();
                }
            }
            cstrUrl.Free();
        }
    }

    if (_dwCookieUrlImgCtxDef)
    {
        CMarkup::GetProgSinkHelper(PrimaryMarkup())->DelProgress(_dwCookieUrlImgCtxDef);
        _dwCookieUrlImgCtxDef = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddRefUrlImgCtx
//
//  Synopsis:   Adds a reference to the background image specified by the
//              given cookie.
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

HRESULT
CDoc::AddRefUrlImgCtx(LONG lCookie, CElement * pElem)
{
    HRESULT hr;

    if (!lCookie)
        return S_OK;

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    hr = THR(_aryUrlImgCtx[lCookie-1].aryElems.Append(pElem));
    if (hr)
        goto Cleanup;

    _aryUrlImgCtx[lCookie-1].ulRefs += 1;

    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%ld)",
        lCookie, _aryUrlImgCtx[lCookie-1].pImgCtx ? _aryUrlImgCtx[lCookie-1].pImgCtx->GetUrl() : _aryUrlImgCtx[lCookie-1].cstrUrl,
        _aryUrlImgCtx[lCookie-1].ulRefs, pElem->_nSerialNumber));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetUrlImgCtx
//
//  Synopsis:   Returns the CImgCtx at the specified cookie
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

CImgCtx *
CDoc::GetUrlImgCtx(LONG lCookie)
{
    if (!lCookie)
        return(NULL);

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    return(_aryUrlImgCtx[lCookie-1].pImgCtx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetImgAnimState
//
//  Synopsis:   Returns an IMGANIMSTATE for the specified cookie, null if
//              there is none
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

IMGANIMSTATE *
CDoc::GetImgAnimState(LONG lCookie)
{
    CImgAnim * pImgAnim = GetImgAnim();
    LONG lAnimCookie;

    if (!lCookie || !pImgAnim)
        return(NULL);

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    lAnimCookie = _aryUrlImgCtx[lCookie-1].lAnimCookie;

    if (lAnimCookie)
        return(pImgAnim->GetImgAnimState(lAnimCookie));

    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseUrlImgCtx
//
//  Synopsis:   Releases a reference to the background image specified by
//              the given cookie.
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//              pElem           An element associated with this cookie
//
//----------------------------------------------------------------------------

void
CDoc::ReleaseUrlImgCtx(LONG lCookie, CElement * pElem)
{
    if (!lCookie)
        return;

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    URLIMGCTX * purlimgctx = &_aryUrlImgCtx[lCookie-1];
    Assert(purlimgctx->ulRefs > 0);


    TraceTag((tagUrlImgCtx, "ReleaseUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%d)",
        lCookie, _aryUrlImgCtx[lCookie-1].pImgCtx ? _aryUrlImgCtx[lCookie-1].pImgCtx->GetUrl() : NULL,
        _aryUrlImgCtx[lCookie-1].ulRefs - 1,
        pElem->_nSerialNumber));

    Verify(purlimgctx->aryElems.DeleteByValue(pElem));

    if (--purlimgctx->ulRefs == 0)
    {
        Assert(purlimgctx->aryElems.Size() == 0);

        // Release our animation cookie if we have one
        if (purlimgctx->lAnimCookie)
        {
            CImgAnim * pImgAnim = GetImgAnim();

            if (pImgAnim)
            {
                pImgAnim->UnregisterForAnim(this, purlimgctx->lAnimCookie);
            }
        }

        purlimgctx->aryElems.DeleteAll();
        if (purlimgctx->pImgCtx)
        {
            purlimgctx->pImgCtx->SetProgSink(NULL); // detach download from document's load progress
            purlimgctx->pImgCtx->Disconnect();
            purlimgctx->pImgCtx->Release();
        }
        purlimgctx->cstrUrl.Free();
        memset(purlimgctx, 0, sizeof(*purlimgctx));
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::StopUrlImgCtx
//
//  Synopsis : Stops downloading of all background images
//
//----------------------------------------------------------

void
CDoc::StopUrlImgCtx(CMarkup * pMarkup)
{
    URLIMGCTX * purlimgctx;
    LONG        curlimgctx;

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    for (; curlimgctx > 0; --curlimgctx, ++purlimgctx)
    {
        if (purlimgctx->pMarkup == pMarkup)
        {
            purlimgctx->fZombied = TRUE;
            if (purlimgctx->pImgCtx)
            {
                purlimgctx->pImgCtx->SetLoad(FALSE, NULL, FALSE);
            }
        }
    }

    if (_dwCookieUrlImgCtxDef && CMarkup::GetProgSinkHelper(PrimaryMarkup()))
    {
//        GWKillMethodCallEx(GetThreadState(), this, ONCALL_METHOD(CDoc, OnUrlImgCtxDeferredDownload, onurlimgctxdeferreddownload), 0);
//        _fNeedUrlImgCtxDeferredDownload = FALSE;
        CMarkup::GetProgSinkHelper(PrimaryMarkup())->DelProgress(_dwCookieUrlImgCtxDef);
        _dwCookieUrlImgCtxDef = NULL;
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::UnregisterUrlImageCtxCallbacks
//
//  Synopsis : Cancels any image callbacks for the doc.  Does
//             not release the image context itself.
//
//----------------------------------------------------------

void
CDoc::UnregisterUrlImgCtxCallbacks()
{
    CImgAnim  * pImgAnim = GetImgAnim();
    URLIMGCTX * purlimgctx;
    LONG        iurlimgctx;
    LONG        curlimgctx;

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
    {
        if (purlimgctx->ulRefs)
        {
            // Unregister callbacks from the animation object, if any
            if (pImgAnim && purlimgctx->lAnimCookie)
            {
                pImgAnim->UnregisterForAnim(this, purlimgctx->lAnimCookie);
                purlimgctx->lAnimCookie = 0;
            }

            if (purlimgctx->pImgCtx)
            {
                // Unregister callbacks from the image context
                purlimgctx->pImgCtx->SetProgSink(NULL); // detach download from document's load progress
                purlimgctx->pImgCtx->Disconnect();
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxCallback
//
//  Synopsis:   Callback from background image reporting that it is finished
//              loading.
//
//  Arguments:  pvObj         The pImgCtx that is calling back
//              pbArg         The CDoc pointer
//
//----------------------------------------------------------------------------

void CALLBACK
CDoc::OnUrlImgCtxCallback(void * pvObj, void * pvArg)
{
    CDoc *      pDoc       = (CDoc *)pvArg;
    CImgCtx *   pImgCtx    = (CImgCtx *)pvObj;
    LONG        iurlimgctx;
    LONG        curlimgctx = pDoc->_aryUrlImgCtx.Size();
    URLIMGCTX * purlimgctx = pDoc->_aryUrlImgCtx;
    SIZE        size;
    ULONG       ulState    = pImgCtx->GetState(TRUE, &size);

    pImgCtx->AddRef();

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
    {
        if (pImgCtx && purlimgctx->pImgCtx == pImgCtx)
        {
            TraceTag((tagUrlImgCtx, "OnUrlImgCtxCallback (#%ld,url=%ls,cRefs=%ld)",
                iurlimgctx + 1, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs));

            if (ulState & IMGCHG_ANIMATE)
            {
                // Register for animation callbacks
                CImgAnim * pImgAnim = CreateImgAnim();

                if(pImgAnim)
                {
                    if (!purlimgctx->lAnimCookie)
                    {
                        pImgAnim->RegisterForAnim(pDoc, (DWORD_PTR) pDoc,   // TODO (lmollico): remove the second arg
                                                  pImgCtx->GetImgId(),
                                                  OnAnimSyncCallback,
                                                  (void *)(DWORD_PTR)iurlimgctx,
                                                  &purlimgctx->lAnimCookie);
                    }

                    if (purlimgctx->lAnimCookie)
                    {
                        pImgAnim->ProgAnim(purlimgctx->lAnimCookie);
                    }
                }
            }
            if (ulState & (IMGLOAD_COMPLETE | IMGLOAD_STOPPED | IMGLOAD_ERROR))
            {
                pImgCtx->SetProgSink(NULL); // detach download from document's load progress
            }
            if (ulState & IMGLOAD_COMPLETE)
            {
                pDoc->OnUrlImgCtxChange(purlimgctx, IMGCHG_COMPLETE);
            }

            break;
        }
    }
    pImgCtx->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnAnimSyncCallback
//
//  Synopsis:   Called back on an animation event
//
//----------------------------------------------------------------------------

void
CDoc::OnAnimSyncCallback(void * pvObj, DWORD dwReason, void * pvArg,
                         void ** ppvDataOut, IMGANIMSTATE * pImgAnimState)
{
    CDoc * pDoc  = (CDoc *) pvObj;
    URLIMGCTX * purlimgctx = &pDoc->_aryUrlImgCtx[(LONG)(LONG_PTR)pvArg];

    switch (dwReason)
    {
    case ANIMSYNC_GETIMGCTX:
        *(CImgCtx **) ppvDataOut = purlimgctx->pImgCtx;
        break;

    case ANIMSYNC_GETHWND:
        *(HWND *) ppvDataOut = pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL;
        break;

    case ANIMSYNC_TIMER:
    case ANIMSYNC_INVALIDATE:
        if(purlimgctx->pImgCtx)
            *(BOOL *) ppvDataOut = pDoc->OnUrlImgCtxChange(purlimgctx, IMGCHG_ANIMATE);
        else
            *(BOOL *) ppvDataOut = FALSE;
        break;

    default:
        Assert(FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxChange
//
//  Synopsis:   Called when this image context has changed, does the necessary
//              invalidating.
//
//  Arguments:  purlimgctx    The url image ctx that changed
//              ulState       The reason for the callback
//
//----------------------------------------------------------------------------

MtDefine(CDoc_OnUrlImgCtxChange_aryElemsLocal_pv, CDoc, "CDoc::OnUrlImgCtxChange aryElemsLocal::_pv")

BOOL
CDoc::OnUrlImgCtxChange(URLIMGCTX * purlimgctx, ULONG ulState)
{
    if (!_pInPlace || !purlimgctx->pImgCtx)
        return FALSE;             // no window yet, nothing to do

    BOOL        fSynchronousPaint = TRUE;
    int         n;
    CElement ** ppElem;
    CLayout   * pLayout;
    BOOL        fUpdateSecPrimary = FALSE;
    BOOL        fUpdateSecPending = FALSE;

    TraceTag((tagUrlImgCtx, "OnChange for doc %ls, img %ls, %ld elements",
              GetPrimaryUrl(),
              purlimgctx->pImgCtx->GetUrl(),
              purlimgctx->aryElems.Size()));
    
    // First scan to see which world we are in for updating security icons
    if (ulState & IMGCHG_COMPLETE)
    {
        for (n = purlimgctx->aryElems.Size(), ppElem = purlimgctx->aryElems;
             n > 0;
             n--, ppElem++)
        {
            CElement * pElement = * ppElem;

            if (pElement->IsInMarkup())
            {
                // figure out if we are going to have to update security state
                if (!fUpdateSecPrimary || !fUpdateSecPending)
                {
                    if (pElement->GetMarkup()->IsPendingRoot())
                        fUpdateSecPending = TRUE;
                    else
                        fUpdateSecPrimary = TRUE;
                }
                else
                    break;
            }
        }

         // If the image turned out to be unsecure, blow away the lock icon
        if (fUpdateSecPending)
            OnSubDownloadSecFlags(TRUE, purlimgctx->pImgCtx->GetUrl(), purlimgctx->pImgCtx->GetSecFlags());
        if (fUpdateSecPrimary)
            OnSubDownloadSecFlags(FALSE, purlimgctx->pImgCtx->GetUrl(), purlimgctx->pImgCtx->GetSecFlags());
    }

    {
        // Note: (jbeda) We are now going to go through all of the elements that
        //       depend on this change and perhaps invaldate.  Some of the
        //       result of this is that we may reenter this code and change this
        //       array.  That could be bad.  To get around this, we'll copy the
        //       array and only notify on that.  There should be no need to
        //       addref here as the tree shouldn't be changed during this
        //       operation.
        CStackPtrAry < CElement *, 16 > aryElemsLocal( Mt( CDoc_OnUrlImgCtxChange_aryElemsLocal_pv ) );

        if (OK( aryElemsLocal.Copy(purlimgctx->aryElems, FALSE) ) )
        {
            for (n = aryElemsLocal.Size(), ppElem = aryElemsLocal;
                 n > 0;
                 n--, ppElem++)
            {
                CElement * pElement = * ppElem;
                //
                // marka - check that element still in tree - bug # 15481.
                //
                if (pElement->IsInMarkup())
                {
                    CMarkup * pMarkup = pElement->GetMarkup();

                    if (   pMarkup->IsHtmlLayout()
                        && pMarkup->GetElementClient() == pElement )
                    {
                        CElement * pHtml = pMarkup->GetHtmlElement();
                        if (    pHtml
                            &&  DYNCAST(CHtmlElement, pHtml)->ShouldStealBackground())
                        {
                            pElement = pHtml;                    
                        }
                    }

                    pLayout = pElement->GetFirstBranch()->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

                    //
                    // if the background is on HTML element or any other ancestor of
                    // body/top element, the inval the top element.
                    //
                    if (!pLayout)
                    {
                        CElement * pElemClient = pMarkup->GetElementClient();

                        if(pElemClient)
                        {
                            pLayout  = pElemClient->GetUpdatedLayout();
                            pElement = pLayout->ElementOwner();
                        }
                    }

                    if(pLayout)
                    {
                        if (pLayout->ElementOwner() == pElement)
                        {
                            if (OpenView())
                            {
                                CDispNodeInfo   dni;

                                pLayout->GetDispNodeInfo(&dni);
                                pLayout->EnsureDispNodeBackground(dni);
                            }
                        }


                        // Some elements require a resize, others a simple invalidation
                        if (pElement->_fResizeOnImageChange && (ulState & IMGCHG_COMPLETE))
                        {
                            pElement->ResizeElement();
                            fSynchronousPaint = FALSE;
                        }
                        else
                        {
                            // We can get away with just an invalidate
                            pElement->Invalidate();
                        }
                    }
                }
            }
        }
    }

    return fSynchronousPaint;
}

//+----------------------------------------------------------------
//
//  Member   :  GetActiveFrame
//
//  Arguments:  ppFrame(out)    Pointer to the frame element that 
//                              contains the current element
//
//              pMarkup(in):   Pointer to interesting frameset.  If null/unspecified,
//                              a master frameset is assumed.
//                              The active frame is returned only if it is
//                              within this markup's scope.
//-----------------------------------------------------------------
HRESULT CDoc::GetActiveFrame(CFrameElement **ppFrame, CMarkup *pMarkup)
{   
    CMarkup     *pMarkupTarget;
    CTreeNode   *pNode;
    CElement    *pElement;

    Assert(ppFrame);
    (*ppFrame)    = NULL;

    pMarkupTarget = pMarkup ? pMarkup : PrimaryMarkup();

    Assert(pMarkupTarget);

    // if there is no active element
    if (_pElemCurrent)
    {
        pNode = _pElemCurrent->GetFirstBranch();
        if (!pNode)
            return E_FAIL;

        // Get the master node in the target markup, which enslaves
        // the markup our node is a member of.
        pNode = pNode->GetNodeInMarkup(pMarkupTarget);

        // If we actually found a node in target markup, then try to 
        // return a frame element from it. 
        // Otherwise return S_OK with a NULL pointer.
        if (pNode)
        {
            // This may be a frame element
            pElement = pNode->Element();
            if (pElement->Tag() == ETAG_FRAME || pElement->Tag() == ETAG_IFRAME)
            {
                // It is a FRAME/IFRAME.  Return the element.
                (*ppFrame) = DYNCAST(CFrameElement, pNode->Element());
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RequestReadystateInteractive
//
//  Synopsis:   Request (default is a post) to make the markup interactive.
//              This can be a signal to the host to take us inplace.  It
//              also requests that the new markup to be switched in.
//
//----------------------------------------------------------------------------
void
CMarkup::RequestReadystateInteractive(BOOL fImmediate)
{
    if (!CanNavigate())
    {
        if (!_fInteractiveRequested)
        {
            _fInteractiveRequested = TRUE;
            Doc()->RegisterMarkupForModelessEnable(this);
        }
        return;
    }

    Assert( !_fInteractiveRequested );

    if (fImmediate)
    {
        SetInteractiveInternal(0);
    }
    else
    {
        IGNORE_HR(GWPostMethodCall(this,
            ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal),
            READYSTATE_INTERACTIVE, FALSE, "CMarkup::SetInteractive"));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetInteractiveInternal
//
//  Synopsis:   Changes the readyState of the document to interactive if
//              the document is still being loaded.
//
//----------------------------------------------------------------------------

void BUGCALL
CMarkup::SetInteractiveInternal(DWORD_PTR dwContext)
{
    CMarkup::CLock markupLock(this);

    if (_fIsInSetInteractive || _pDoc->IsShuttingDown())
        goto Cleanup;

    // This is always a posted call, so if we can't do what we want
    // to do now (modeless enabled) than we just put ourselves
    // on the list to get tickled when this situation changes.
    if (!CanNavigate())
    {
        RequestReadystateInteractive();
        goto Cleanup;
    }

    {
        CDoc::CLock docLock( _pDoc );

        _fIsInSetInteractive = TRUE;

        // If any markups go interactive, we want to make sure that we
        // are OS_INPLACE.  We do that by taking the readystate markup
        // interactive.  This is the markup that is used in 
        // CDocument::get_readyState
        if (_pDoc->State() < OS_INPLACE)
        {
            CWindow * pWindowPrimary = _pDoc->_pWindowPrimary->Window();
            CMarkup * pMarkupReadystate = pWindowPrimary->_pMarkupPending 
                                          ? pWindowPrimary->_pMarkupPending 
                                          : pWindowPrimary->_pMarkup;

            if (this != pMarkupReadystate)
                RequestReadystateInteractive(TRUE);
        }

        // Take this interactive
        if (GetReadyState() < READYSTATE_INTERACTIVE)
        {
            COmWindowProxy * pPendingWindowPrxy = GetWindowPending();

            if (_fWindowPending)
            {
                Assert(pPendingWindowPrxy);

                THR(pPendingWindowPrxy->SwitchMarkup(this,
                                                     IsActiveDesktopComponent(),
                                                     COmWindowProxy::TLF_UPDATETRAVELLOG));

                // SwitchMarkup could actually cause our load to get aborted -
                // Ex: IFRAME being held onto by undo queue, but in the middle of 
                // navigating.  SwitchMarkup flushes the undo queue, passivates the
                // IFrame, and nukes us.
                if ( ! HasWindowPending())
                        return;
            }

            // We have to fire NavigateComplete2 even if 
            // _fWindowPending is FALSE. This will occur if the 
            // navigation has come from the address bar or if
            // we are creating a frame.
            //
            if (   pPendingWindowPrxy 
                && !(pPendingWindowPrxy->IsPassivating() || pPendingWindowPrxy->IsPassivated())
                && HtmCtx()
                && (S_OK == HtmCtx()->GetBindResult())
                    // let this event firing happen in SetReadyState when status == Done
                    // for print markups, just do the normal thing
                && !(   g_fInMSWorksCalender
                     && (   GetUrlScheme(Url()) == URL_SCHEME_ABOUT
                         || GetUrlScheme(Url()) == URL_SCHEME_FILE
                     )  )
               )
            {
                if (!_fInRefresh && !_fMarkupServicesParsing && !_pDoc->_fDefView)
                {
                    if (!IsPrimaryMarkup() && !_fLoadingHistory)
                    {
                        _pDoc->_webOCEvents.FireDownloadEvents(pPendingWindowPrxy,
                                                               CWebOCEvents::eFireDownloadComplete);
                    }

                    if (!_fNewWindowLoading)
                    {
                        _pDoc->_webOCEvents.NavigateComplete2(pPendingWindowPrxy);
                    }
                }
            }

            // Fire onRSC for LOADING, if we could not fire earlier, due to the old markup
            // not having completely gone through the shutdown sequence (i.e until onUnload
            // is fired in switchMarkup
            if (_fDelayFiringOnRSCLoading && pPendingWindowPrxy)
            {
                _fDelayFiringOnRSCLoading = FALSE;
                pPendingWindowPrxy->Document()->FirePropertyNotify(DISPID_READYSTATE, TRUE);
                pPendingWindowPrxy->Document()->Fire_onreadystatechange();
            }

            SetReadyState(READYSTATE_INTERACTIVE);        
            ProcessPeerTasks(0);
        }

        _fIsInSetInteractive = FALSE;
    }

Cleanup:    
    ShowWaitCursor(FALSE); // No waiting
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CLock::CLock
//
//  Synopsis:
//
//----------------------------------------------------------------------------

CDoc::CLock::CLock(CDoc * pDoc, WORD wLockFlags)
    : CServer::CLock(pDoc, wLockFlags)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pScriptCollection = ( pDoc->_pWindowPrimary )
                            ? pDoc->_pWindowPrimary->Markup()->GetScriptCollection(FALSE)
                            : NULL;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        if (_pScriptCollection)
            _pScriptCollection->AddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}

CDoc::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        if (_pScriptCollection)
            _pScriptCollection->Release();
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PostAAEvent
//
//  Synopsis:   Translate our trident event into an Accessibility event and
//      post it to the window.
//
//----------------------------------------------------------------------------
typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG);
NOTIFYWINEVENTPROC g_pfnNotifyWinEvent=NULL;
#define DONOTHING_NOTIFYWINEVENT (NOTIFYWINEVENTPROC )1

#define ACCEVTARRAYSIZE_MIN  4
#define ACCEVTARRAYSIZE_MAX  32

//
//
//
HRESULT
CDoc::CAccEvtArray::Init()
{
    HRESULT hr;

    _lCurIndex = 0;
    _lCurSize = 0;

    hr = THR(_aryEvtRefs.EnsureSize(ACCEVTARRAYSIZE_MIN));

    if (!hr)
        _lCurSize = ACCEVTARRAYSIZE_MIN;

    RRETURN(hr);
}

//
//
//
void
CDoc::CAccEvtArray::Passivate()
{
    // walk through the array and cleanup existing entries
    
    for (int i=0; i < _aryEvtRefs.Size() ; i++)
    {
        // if the slot still contains information
        if (_aryEvtRefs[i])
        {
            CBase * pObj = _aryEvtRefs[i]->pObj;
            
            // free memory
            delete _aryEvtRefs[i];
            _aryEvtRefs[i] = 0;
            
            // dereference the object 
            pObj->PrivateRelease();                
        }
    }

    // if this ever fires, we will leak.  To fix: add a do-while(!IsEmpty) around the for loop.
    Assert(IsEmpty(_aryEvtRefs));
}

//
//  This method is called to clean up defunked enteries in _aryEvtRefs.
//  That is references to elements that do not have markup
//

void
CDoc::CAccEvtArray::Flush()
{
    CElement * pElement = NULL;
    CWindow  * pWindow  = NULL;

    // We are getting into problems when CDoc is passivated before the Markup
    // We need not worry about flushing in such a case, because we passivate 
    // When CDoc passivates.

    if (_pMyCDoc->IsPassivating() || _pMyCDoc->IsPassivated())
    {
        return;
    }

    // walk through the array and defunked entries
    for (int i=0; i < _aryEvtRefs.Size() ; i++)
    {
        // if the slot still contains information check 
        if (_aryEvtRefs[i])
        {
            // if window
            if (_aryEvtRefs[i]->fWindow)
            {
                pWindow = DYNCAST(CWindow,_aryEvtRefs[i]->pObj);
                
                // Check to make sure we are not the primary window
                // Cannot use IsPrimaryWindow() because it can be fooba at this point
                // if slot is defunked free it
                // removed pWindow->_pMarkup == NULL check.  That'll never happen in The New World.
                Assert( _pMyCDoc->_pWindowPrimary && _pMyCDoc->_pWindowPrimary->_pCWindow );
                
                if (pWindow->_pWindowParent == NULL && _pMyCDoc->_pWindowPrimary->_pCWindow != pWindow)
                {
                    delete _aryEvtRefs[i];
                    _aryEvtRefs[i]=0;
                    
                    // dereference the object 
                    pWindow->PrivateRelease();
                }
            }
            // it is a element
            else
            {
                pElement = DYNCAST(CElement,_aryEvtRefs[i]->pObj);
                
                // if slot is defunked free it
                if (pElement->GetFirstBranch() == NULL)
                {
                    // We have to null out the slot first because 
                    // there can be a slave markup that is passivated.
                    delete _aryEvtRefs[i];
                    _aryEvtRefs[i]=0;
                    
                    // dereference the object 
                    pElement->PrivateRelease();
                    
                }
            } 
        }
    }
}
//
//
//

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif
HRESULT 
CDoc::CAccEvtArray::AddAccEvtSource(ACCEVTRECORD * pAccEvtRec, long * pnCurIndex)
{
    HRESULT     hr = S_OK;
    CWindow  *  pWindow  = NULL;

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    Assert(pAccEvtRec);

    //
    // Make sure the document isn't passivating otherwise all the pointer are foobaa
    //
    if (_pMyCDoc->IsPassivating() || _pMyCDoc->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If your a child window and passivating we don't want to add your event to the queue
    //
    if (pAccEvtRec->fWindow)
    {
        pWindow = DYNCAST(CWindow,pAccEvtRec->pObj);

        // Check to make sure we are not the primary window
        // Cannot use IsPrimaryWindow() because it can be fooba at this point
        //

        if (_pMyCDoc->_pWindowPrimary->_pCWindow != pWindow)
        {
            if ((pWindow->IsPassivating()) || (pWindow->IsPassivated()))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    // now the _lCurIndex is pointing to the next location we will write
    if (_lCurSize > _aryEvtRefs.Size())
    {
        Assert( _lCurIndex < ACCEVTARRAYSIZE_MAX);

        hr = _aryEvtRefs.Append(pAccEvtRec);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // If the array is full and we have a full slot in hand, clean it up and 
        // reuse it.
        if ((_aryEvtRefs.Size() == ACCEVTARRAYSIZE_MAX) && _aryEvtRefs[_lCurIndex])
        {
            while(_aryEvtRefs[_lCurIndex])
            {
#if DBG
                ACCEVTRECORD *  pDbg1 = _aryEvtRefs[_lCurIndex];
#endif
                CBase * pObj = _aryEvtRefs[_lCurIndex]->pObj;
                // Clean up before releasing to prevent reentry
                delete _aryEvtRefs[_lCurIndex];
                _aryEvtRefs[_lCurIndex] = 0;
                
                // release the reference on the object
                // CAUTION: this is side effecting!  We can reenter this function!
                pObj->PrivateRelease();
            }
        }

        Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

        Assert(0 == _aryEvtRefs[_lCurIndex]);

        // set the pointer value in this slot
        _aryEvtRefs[_lCurIndex] = pAccEvtRec;
    }

    // add a reference to the object we are adding to the array
    pAccEvtRec->pObj->PrivateAddRef();

    // return the current index and increment the position.
    // the index we return is 1 based, so it is ok to increment before returning.
    *pnCurIndex = ++_lCurIndex;

    // this assert is different - _lCurIndex can be equal to _lCurSize
    Assert(_lCurIndex >= 0 && _lCurIndex <= _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    // if we have reached the end of the allocated size,
    if (_lCurIndex == _lCurSize)
    {
        // if we have room to grow, 
        if (_lCurSize < ACCEVTARRAYSIZE_MAX)
        {
            hr = _aryEvtRefs.EnsureSize(_lCurSize * 2);

            if (SUCCEEDED(hr))
            {
                _lCurSize = _lCurSize * 2;
            }
            else
            {
                _lCurIndex = 0; // could not grow, reset position
            }
        }
        else
        {
            _lCurIndex = 0; // reached max size, reset position
        }
    }


Cleanup:
    if (hr)
    {
        *pnCurIndex = 0;
    }

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);
    RRETURN(hr);
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//
//
//
HRESULT
CDoc::CAccEvtArray::GetAccEvtSource(long lIndex, ACCEVTRECORD * pAccEvtRec)
{
    HRESULT hr = S_OK;

    if (!pAccEvtRec)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // index has to be larger than 0
    // index has to be less then or equal to the total number of elements 
    // currently in the array. (since the lIndex is 1 based)
    // There has to be a non-zero value in the slot the index will refer to
    if (!lIndex || 
        (lIndex > _aryEvtRefs.Size()) || 
        !_aryEvtRefs[lIndex-1])
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Copy the contents of the structure that is pointed by the array entry
    // to the structure which we received the address of.

    memcpy( pAccEvtRec, _aryEvtRefs[lIndex-1], sizeof(ACCEVTRECORD));

Cleanup:
    RRETURN(hr);
}

extern BOOL g_fIsWinEventHookInstalled;

HRESULT 
CDoc::FireAccessibilityEvents(DISPID dispidEvent, CBase * pBaseObj, BOOL fWindow)
{
    HRESULT hr  = S_OK;
    long    lElemId;
    
    // map of trident events to the accesiblity events.

//
//FerhanE:
//  This is list is searched using a linear search algo. However, to make the 
//  search faster, events that are fired more often are at the top of the list.
//  Be careful when adding things in here.
    static const struct { DISPID a;
                          DWORD  b; } aEventTable[] = {
                              { NULL,                          EVENT_OBJECT_STATECHANGE},
                              { DISPID_EVMETH_ONFOCUS,         EVENT_OBJECT_FOCUS},
                              { DISPID_EVMETH_ONBLUR,          EVENT_OBJECT_STATECHANGE},
                              { DISPID_EVMETH_ONLOAD,          EVENT_OBJECT_CREATE},
                              { DISPID_EVMETH_ONUNLOAD,        EVENT_OBJECT_DESTROY},
                              { DISPID_IHTMLELEMENT_INNERHTML, EVENT_OBJECT_REORDER},
                              { DISPID_IHTMLELEMENT_OUTERHTML, EVENT_OBJECT_REORDER},
                              { DISPID_ONCONTROLSELECT,        EVENT_OBJECT_FOCUS},
                        };
    
    // do we have enabled accessiblity?
    if (g_pfnNotifyWinEvent != DONOTHING_NOTIFYWINEVENT &&
        _pInPlace && g_fIsWinEventHookInstalled)
    {
        if (!g_pfnNotifyWinEvent )
        {
            HMODULE hmod = GetModuleHandle(TEXT("USER32"));

            if (hmod)
                g_pfnNotifyWinEvent = (NOTIFYWINEVENTPROC)GetProcAddress(
                                                            hmod,
                                                            "NotifyWinEvent");

            if (!g_pfnNotifyWinEvent)
            {
                g_pfnNotifyWinEvent = DONOTHING_NOTIFYWINEVENT;
                goto Cleanup;
            }
        }        
        
        // if the object that was passed in was not the primary window
        // then we have to get a cookie to send out.
        if (pBaseObj != OBJID_WINDOW)
        {
            ACCEVTRECORD * pAccEvtRec = new ACCEVTRECORD( pBaseObj, fWindow);
            
            if (!pAccEvtRec)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            // Add the object into the array and get a cookie back.
            hr = _aryAccEvents.AddAccEvtSource(pAccEvtRec,&lElemId);
            
            if (hr != S_OK)
            {
                hr = S_OK;
                goto Cleanup;
            }
            Assert(lElemId);
        }
        else
        {
            lElemId = OBJID_WINDOW;
        }

        // we have a fx Ptr
        for (int iPos=0; iPos < ARRAY_SIZE(aEventTable); iPos++)
        {            
            // If we can map this event, send the message and leave
           if (aEventTable[iPos].a == dispidEvent)
           {
                // make the event notification call.       
                (* g_pfnNotifyWinEvent)( aEventTable[iPos].b,   // the Accesibility event id
                                         _pInPlace->_hwnd,      // the inplace hwnd
                                         lElemId,               // parent?
                                         CHILDID_SELF);         // child id

                break;
           }
        }

    }

Cleanup:
    RRETURN(hr);
}

//TODO: remove pDoc first param later, after NATIVE_FRAME is enabled, don't do it now to avoid pdlparser dependency
HRESULT
CDocument::FireEvent(CDoc *pDoc,
        DISPID      dispidEvent,
        DISPID      dispidProp,
        LPCTSTR     pchEventType,
        BOOL *      pfRet)
{
    RRETURN(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, pchEventType, pfRet));
}

HRESULT
CDocument::fireEvent(BSTR bstrEventName, VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
{
    CDoc *pDoc = Doc();
    HRESULT hr = S_OK;
    const PROPERTYDESC *ppropdesc;
    EVENTPARAM *pParam = NULL;
    BOOL fCreateLocal = FALSE;
    CEventObj *pSrcEventObj = NULL;
    IHTMLEventObj *pIEventObject = NULL;
    DISPID dispidEvent;
    DISPID dispidProp;
    BOOL fRet;
    
    if (!bstrEventName || !*bstrEventName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //TODO(sramani): what about Case sensitivity?
    ppropdesc = FindPropDescForName(bstrEventName);
    if (!ppropdesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    dispidEvent = (DISPID)(((const PROPERTYDESC_BASIC *)ppropdesc)->c);
    dispidProp = ((const PROPERTYDESC_BASIC *)ppropdesc)->b.dispid;

    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH && V_DISPATCH(pvarEventObject))
    {
        pIEventObject = (IHTMLEventObj *)V_DISPATCH(pvarEventObject);

        hr = THR(pIEventObject->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        // event object passed in already pushed on stack --- we are inside an event handler, copy it locally and use.
        if (pParam->_fOnStack)
            fCreateLocal = TRUE;
    }
    else // no event obj passed in, create one implicitly on the stack and init it.
    {
        fCreateLocal = TRUE;
    }

    if (fCreateLocal)
    {
        EVENTPARAM param(pDoc, NULL, Markup(), !pParam, TRUE, pParam);

        param.SetType(ppropdesc->pstrName + 2); // all events start with on...
        param.fCancelBubble = FALSE;
        V_VT(&param.varReturnValue) = VT_EMPTY;

        hr = THR(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, NULL, &fRet));
    }
    else // explicitly created event object passed in, re-use it by locking it on stack
    {
        Assert(pIEventObject);
        Assert(pParam);

        pParam->SetType(ppropdesc->pstrName + 2); // all events start with on...
        pParam->fCancelBubble = FALSE;
        V_VT(&pParam->varReturnValue) = VT_EMPTY;

        CEventObj::COnStackLock onStackLock(pIEventObject);

        hr = THR(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, NULL, &fRet));
    }

    if (pfCancelled && !FAILED(hr))
    {
        if (ppropdesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_CANCELABLE)
            *pfCancelled = (fRet) ? VB_TRUE : VB_FALSE;
        else
            *pfCancelled = VB_TRUE;
    
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEvent
//
//  Synopsis:   Lock the document while firing an event. Central event firing routine
//              that supports non-bubbling, cancelable\non-cancelable events for any
//              object derived from CBase.
//
//  Arguments:  [pDoc]          -- The current document
//              [dispidEvent]   -- DISPID of event to fire
//              [dispidProp]    -- Dispid of prop storing event function
//              [pchEventType]  -- String of type of event; if NULL, caller needs to
//                                 push EVENTPARAM on stack, else this function does
//              [pfRet]         -- if specified event is Cancelable, result returned as bool
//                                 (false(0)==canceled, true(1)==default, vice-versa for onmouseover)
//              [fBubble]       -- does the event bubble? i.e is it called from BubbleEventHelper?
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CBase::FireEvent(
    CDoc *      pDoc,
    CElement *  pElement,
    CMarkup *   pMarkup,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    LPCTSTR     pchEventType,
    BOOL *      pfRet,
    BOOL        fBubble,
    IDispatch * pdispThis,
    EVENTINFO* pEvtInfo /*=NULL*/ )
{
    HRESULT         hr = S_OK;
    CVariant        varRet;
    IHTMLEventObj  *pEventObj = NULL;
    CScriptCollection * pScriptCollection;

    CDoc::CLock     Lock(pDoc);

    if (!pMarkup && pElement)
        pMarkup = pElement->GetMarkup();

    pScriptCollection = pMarkup ? pMarkup->GetScriptCollection() : NULL;

    if (pScriptCollection)
        pScriptCollection->AddRef();

    // EVENTPARAM not pushed if pchEventType==NULL, caller will push.
    EVENTPARAM param(pchEventType ? pDoc : NULL, pElement, pMarkup, TRUE);

    // Don't fire Doc events before init is complete.
    if (pDoc->_state < OS_LOADED) 
        goto Cleanup;


    if (pchEventType)
    {
        Assert(pDoc->_pparam == &param);
        param.SetType(pchEventType);
    }

    // Get the eventObject.
    Assert(pDoc->_pparam);
    CEventObj::Create(&pEventObj, pDoc, pElement, pMarkup);

    if ( pEvtInfo )
    {
        pEvtInfo->_dispId = dispidEvent;
        pEvtInfo->_pParam = new EVENTPARAM( pDoc->_pparam );

        if ( pEvtInfo->_fDontFireEvent )
            goto Cleanup;
    }

    hr = InvokeEvent(dispidEvent, dispidProp, pEventObj, &varRet, NULL, NULL, NULL, NULL, pdispThis);

    if (pfRet)
    {
        // if no event type passed in, caller should have pushed EVENTPARAM
        Assert(!pchEventType && pDoc->_pparam || pDoc->_pparam == &param);
        VARIANT_BOOL vb;
        if (fBubble && V_VT(&varRet) == VT_EMPTY)
            goto Cleanup;

        vb = (V_VT(&varRet) == VT_BOOL) ? V_BOOL(&varRet) : VB_TRUE;
        *pfRet = (VB_TRUE == vb) && (fBubble ? TRUE : !pDoc->_pparam->IsCancelled());
    }

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();
    ReleaseInterface(pEventObj);
    RRETURN(hr);
}

void
CDoc::FlushUndoData()
{
    // Nuke undo/redo stacks.  Release references.

    UndoManager()->DiscardFrom(NULL);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryCreateUndo
//
//  Synopsis:   Query whether to create undo or not.  Also dirties 
//              the doc if fFlushOnError.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
BOOL 
CDoc::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( fDirtyChange )
    {
        switch( TLS(nUndoState) )
        {
        case UNDO_BASESTATE:
            if( _lDirtyVersion < 0 )
                // If someone has reset the dirty version and then called undo
                // multiple times, a regular action will make us permenantly dirty.
                _lDirtyVersion = MAXLONG;
            else
                _lDirtyVersion++;
            break;
        case UNDO_UNDOSTATE:
            _lDirtyVersion--;
            break;
        case UNDO_REDOSTATE:
            _lDirtyVersion++;
            break;
        }
    }

    return super::QueryCreateUndo( fRequiresParent, fDirtyChange, pfTreeSync );
}
#endif // NO_EDIT


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnFrameOptionScrollChange
//
//  Synopsis:   Called after scrolling of Frame option  has changed
//
//----------------------------------------------------------------------------
HRESULT
CDoc::OnFrameOptionScrollChange(void)
{
    ITargetFrame *  pTargetFrame = NULL;

    // Update Cached Frame flags.
    if (OK(THR_NOTRACE(QueryService(
            IID_ITargetFrame,
            IID_ITargetFrame,
            (void**)&pTargetFrame))))
    {
        CMarkup * pMarkup = PrimaryMarkup();
        DWORD dwFrameOptionsOld = pMarkup->GetFrameOptions();
        DWORD dwFrameOptionsNew;

        THR(pTargetFrame->GetFrameOptions(&dwFrameOptionsNew));
        pTargetFrame->Release();

        if (dwFrameOptionsNew != dwFrameOptionsOld)
        {
            CBodyElement * pBody;

            IGNORE_HR(pMarkup->GetBodyElement(&pBody));
    
            pMarkup->SetFrameOptions(dwFrameOptionsNew);

            //  For a BODY (not FRAMESET) document, resize the canvas.
            if (pBody)
            {
                CElement * pCanvas = pMarkup->GetCanvasElement();

                Assert(pCanvas);
                pCanvas->ResizeElement(NFLAGS_FORCE);
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallBackEnumChild
//
//  Synopsis:   Called from EnumChildWindows, used to determine if
//              we have child windows
//
//----------------------------------------------------------------------------

static BOOL CALLBACK
CallBackEnumChild(HWND hwnd, LPARAM lparam)
{
    *(BOOL *)lparam = (::GetFocus() == hwnd);

    return !(*(BOOL *)lparam);
}

BOOL
CDoc::HasFocus()
{
    BOOL    fHasFocus = FALSE;

    if (_pInPlace && _pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        //
        // TODO: think about nested Popup
        //
        if (_fPopupDoc)
        {
            fHasFocus = TRUE;
        }
        else
        {
            fHasFocus = (::GetFocus() == _pInPlace->_hwnd);
        }
        if (!fHasFocus)
        {
            EnumChildWindows(_pInPlace->_hwnd, CallBackEnumChild, (LPARAM)&fHasFocus);
        }
    }

    return fHasFocus;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnterStylesheetDownload
//
//  Synopsis:   Note that a stylesheet is being downloaded
//
//--------------------------------------------------------------------

void
CDoc::EnterStylesheetDownload(DWORD * pdwCookie)
{
    if (*pdwCookie != _dwStylesheetDownloadingCookie)
    {
        *pdwCookie = _dwStylesheetDownloadingCookie;
        _cStylesheetDownloading++;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::LeaveStylesheetDownload
//
//  Synopsis:   Note that stylesheet is finished downloading
//
//--------------------------------------------------------------------

void
CDoc::LeaveStylesheetDownload(DWORD * pdwCookie)
{
    if (*pdwCookie == _dwStylesheetDownloadingCookie)
    {
        *pdwCookie = 0;
        _cStylesheetDownloading--;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetActiveXSafetyProvider
//
//  Synopsis:   Get an IActiveXSafetyProvider pointer, or return NULL if
//              there isn't one installed.
//
//-------------------------------------------------------------------------

HRESULT
   CDoc::GetActiveXSafetyProvider(IActiveXSafetyProvider **ppProvider)
{
    HRESULT hr;
    LONG l;
    HKEY hKey;

    if (_pActiveXSafetyProvider) {
        if (_pActiveXSafetyProvider == (IActiveXSafetyProvider *)-1) {
            //
            // A previous call has determined that there is no safety
            // provider installed.  Return S_OK, but set *ppProvider to NULL.
            //
            *ppProvider = NULL;
        } else {
            //
            // Use the cached ActiveXSafetyProvider.
            //
            *ppProvider = _pActiveXSafetyProvider;
        }
        TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider returning cached value 0x%x", *ppProvider));
        return S_OK;
    }

    //
    // See if an IActiveXSafetyProvider is present by peeking into the
    // registry.
    //
    l = RegOpenKeyA(HKEY_CLASSES_ROOT,
                    "CLSID\\{aaf8c6ce-f972-11d0-97eb-00aa00615333}",
                    &hKey
                   );
    if (l != ERROR_SUCCESS) {
        //
        // No ActiveXSafetyProvider installed.  Cache this information.
        //
        _pActiveXSafetyProvider = (IActiveXSafetyProvider *)-1;
        *ppProvider = NULL;
        TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider - provider not installed"));
        return S_OK;
    }
    else
        RegCloseKey(hKey);

    //
    // Call OLE to instantiate the ActiveXSafetyProvider.  If this fails,
    // _pActiveXSafetyProvider will remain NULL, so the operation will
    // be retried next time someone calls this routine.
    //
    hr = CoCreateInstance(CLSID_IActiveXSafetyProvider,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IActiveXSafetyProvider,
                          (void **)&_pActiveXSafetyProvider
                         );

    *ppProvider = _pActiveXSafetyProvider;
    TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider - caching provider 0x%x", *ppProvider));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::GetWindowForBinding
//
//  Synopsis:   Gets a window for binding UI
//
//--------------------------------------------------------------------

void
CDoc::GetWindowForBinding(HWND * phwnd)
{
    IOleWindow *        pOleWindow = NULL;

    // try in-place window
    *phwnd = GetHWND();

    // try client site window
    if (!*phwnd && _pClientSite)
        if (!_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pOleWindow))
            IGNORE_HR(pOleWindow->GetWindow(phwnd));

    // resort to desktop window
    if (!*phwnd)
        *phwnd = GetDesktopWindow();

    ReleaseInterface(pOleWindow);
}



//+-------------------------------------------------------------------
//
//  Member:     CDoc::GetWindow, IWindowForBindingUI
//
//  Synopsis:   Default implementation of the IWindowForBindingUI
//              service
//
//--------------------------------------------------------------------

HRESULT
CDoc::GetWindowBindingUI(REFGUID rguidReason, HWND * phwnd)
{
    if (IsPrintDialogNoUI())
    {
        *phwnd = HWND_DESKTOP;
        return S_OK;
    }

    if (_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        return(S_FALSE);
    }

    GetWindowForBinding(phwnd);

    return S_OK;
}



//+-------------------------------------------------------------------
//
//  Member:     CDoc::Authenticate, IAuthenticate
//
//  Synopsis:   Default implementation of the IAuthenticate service
//
//--------------------------------------------------------------------

HRESULT
CDoc::Authenticate(HWND * phwnd, LPWSTR * ppszUsername, LPWSTR * ppszPassword)
{
    if (_dwLoadf & DLCTL_SILENT)
        *phwnd = (HWND)-1;
    else
    {
        GetWindowForBinding(phwnd);
    }

    *ppszUsername = NULL;
    *ppszPassword = NULL;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ShowLoadError
//
//  Synopsis:   Shows a message box stating that the document could
//              not be loaded, the URL, and the reason.
//
//--------------------------------------------------------------------

HRESULT
CDoc::ShowLoadError(CHtmCtx *pHtmCtx)
{
    TCHAR *pchMessage = NULL;
    TCHAR achReason[256];
    TCHAR *pchReason;
    HRESULT hr;

    // If there was an explicit error-reason message, show it
    pchReason = pHtmCtx->GetErrorString();

    // Otherwise, format up a generic error message based on GetBindResult
    if (!pchReason)
    {
        hr = THR(GetErrorText(pHtmCtx->GetBindResult(), achReason, ARRAY_SIZE(achReason)));
        if (hr)
            goto Cleanup;

        pchReason = achReason;
    }

    // Internet Explorer cannot open the internet site <url>.\n<reason>

    hr = THR(Format(FMT_OUT_ALLOC,
           &pchMessage,
           64,
           MAKEINTRESOURCE(IDS_CANNOTLOAD),
           GetPrimaryUrl(),
           pchReason));
    if (hr)
        goto Cleanup;

    hr = THR(ShowMessageEx(NULL,
                  MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                  NULL,
                  0,
                  pchMessage));
    if (hr)
        goto Cleanup;

Cleanup:
    MemFree(pchMessage);

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::MoveSystemCaret
//
//  Synopsis:   Decides if the system caret should be moved to track
//              user moves ---  for accessibility purposes.
//
//--------------------------------------------------------------------
extern BOOL g_fScreenReader;

BOOL
CDoc::MoveSystemCaret()
{
    BOOL fMove = g_fScreenReader;

    //
    // If the screen reader is installed, then ignore what the registry says,
    // and always move the system caret.
    //
    if (!fMove)
    {
        //
        // If screen reader is not installed, then we need to look at what
        // registry has to say about moving the system caret.
        //
        HRESULT hr = THR(UpdateFromRegistry());
        if (hr)
            goto Cleanup;

        fMove = _pOptionSettings->fMoveSystemCaret;
    }

Cleanup:
    return fMove;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::suspendRecalc
//
//--------------------------------------------------------------------
STDMETHODIMP
CDoc::suspendRecalc(BOOL fSuspend)
{
    RRETURN(_recalcHost.SuspendRecalc(!!fSuspend));
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::SetCpAutoDetect 
//
//  Synopsis:   Set the flag that indicates cp is to be auto-detected
//              [review] this also refresh the 'autodetect' reg entry
//                       could we find better place to do this?
//
//  Returns:    S_OK - if auto detect is flipped
//
//--------------------------------------------------------------------
static const TCHAR s_szAutoDetect[] = TEXT("AutoDetect");
static const TCHAR s_szDefaultCodepage[] = TEXT("Default_CodePage");
HRESULT
CDoc::SetCpAutoDetect(BOOL fSet)
{
    HRESULT hr = S_OK;

    if (_pOptionSettings)
    {
        if (_pOptionSettings->fCpAutoDetect != fSet)
        {
            DWORD dwWrite;
            CStr  cstrPath;

            hr = THR(cstrPath.Set(NULL, _tcslen(_pOptionSettings->achKeyPath)+_tcslen(s_szPathInternational)+1));
            if (hr)
                goto Cleanup;

            _tcscpy(cstrPath, _pOptionSettings->achKeyPath);
            _tcscat(cstrPath, s_szPathInternational);

            dwWrite = fSet ? 1 : 0;

            hr =  SHSetValue(HKEY_CURRENT_USER, cstrPath,  s_szAutoDetect, REG_DWORD, 
                             (void*)&dwWrite,  sizeof(dwWrite));

            if (hr == NO_ERROR)
            {
                _pOptionSettings->fCpAutoDetect = !!fSet;
            }
        }
    }
    else
        hr = E_FAIL;
Cleanup:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsCpAutoDetect 
//
//  Synopsis:   Get the flag that indicates cp is to be auto-detected
//
//  Returns:    BOOL true if auto mode is set
//
//--------------------------------------------------------------------

BOOL
CDoc::IsCpAutoDetect(void)
{
    BOOL bret;

    if (_pOptionSettings)
        bret = (BOOL)_pOptionSettings->fCpAutoDetect;
    else
        bret = FALSE;

    return bret;
}

HRESULT
CDoc::SaveDefaultCodepage(CODEPAGE cp)
{
    HRESULT hr = S_OK;
    if (_pOptionSettings)
    {
        if ( _pOptionSettings->codepageDefault != cp)
        {
            CStr cstrPath;
            hr = THR(cstrPath.Set(NULL, _tcslen(_pOptionSettings->achKeyPath)+_tcslen(s_szPathInternational)+1));
            if (hr)
                goto Cleanup;

            _tcscpy(cstrPath, _pOptionSettings->achKeyPath);
            _tcscat(cstrPath, s_szPathInternational);

            hr =  SHSetValue(HKEY_CURRENT_USER, cstrPath, s_szDefaultCodepage, 
                                               REG_BINARY, (void *)&cp, sizeof(cp));
            if (hr == NO_ERROR)
                _pOptionSettings->codepageDefault = cp;
        }
    }
Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::QueryVersionHost
//
//  Synopsis:   Sets up the local or global CVersions object
//
//----------------------------------------------------------------------------

HRESULT
CDoc::QueryVersionHost()
{
    HRESULT hr = S_OK;
    IVersionHost *pVersionHost = NULL;
    IVersionVector *pVersionVector = NULL;
    BOOL fUseLocal = FALSE;
    CVersions *pVersions = NULL;

    HKEY hkey = NULL;

    // This code use to return S_OK if there is a _pVersion, however, there 
    // should no longer be path that calls QueryVersionHost in such a case
    Assert(!_pVersions);

    if (!OK(THR_NOTRACE(QueryService(
            SID_SVersionHost,
            IID_IVersionHost,
            (void**)&pVersionHost))))
    {
        pVersionHost = NULL;

        pVersions = GetGlobalVersions();
        if (!pVersions)
            fUseLocal = TRUE;
    }
    else
    {
        hr = THR(pVersionHost->QueryUseLocalVersionVector(&fUseLocal));
        if (hr)
            goto Cleanup;

        if (!fUseLocal)
        {
            pVersions = GetGlobalVersions();
        }
    }

    if (!pVersions)
    {
        pVersions = new CVersions();
        if (pVersions == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pVersions->Init());
        if (hr)
            goto Cleanup;

        hr = THR(pVersions->GetVersionVector(&pVersionVector));
        if (hr)
            goto Cleanup;

        // Enumerate through the HKLM\Software\Microsoft\Internet Explorer\Version Vector key
        // setting versions.
        // We should always find at least "IE", "x.x.xxxx", which is registered in selfreg.inx.
        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Internet Explorer\\Version Vector"),
                &hkey) == ERROR_SUCCESS)
        {
            for (int iValue = 0; ;iValue++)
            {
                OLECHAR    wszValue[256];
                OLECHAR    wszVersion[256];
                DWORD      dwType;
                DWORD      cchValue = ARRAY_SIZE(wszValue);
                DWORD      cchVersion = ARRAY_SIZE(wszVersion);

                if (SHEnumValueW(hkey, iValue, wszValue, &cchValue, 
                                 &dwType, wszVersion, &cchVersion)==ERROR_SUCCESS)
                {
                    // TODO (alexz) in IE5, we disable VML for OE4 and Outlook98, per IE5 bug 69437
                    if ((_fOE4 || _fOutlook98) && wszValue && 0 == StrCmpIC(_T("VML"), wszValue))
                        continue;

                    hr = pVersionVector->SetVersion(wszValue, wszVersion);
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    break;
                }
            }
        }

        // Now give the host a chance to set some version vector info.
        if (pVersionHost)
        {
            hr = THR(pVersionHost->QueryVersionVector(pVersionVector));
            if (hr)
                goto Cleanup;
        }

        if (!fUseLocal)
        {
            if (!SuggestGlobalVersions(pVersions))
            {
                // Another thread has won the race to supply a global version; get it
                pVersions->Release();
                pVersions = GetGlobalVersions();
                Assert(pVersions);
            }
        }
    }
    Assert(pVersions);

    _pVersions = pVersions;
    pVersions = NULL;

Cleanup:
    if (pVersions)
        pVersions->Release();
    ReleaseInterface(pVersionHost);
    ReleaseInterface(pVersionVector);

    if (hkey != NULL)
        RegCloseKey(hkey);
        
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CDoc::FaultInUSP
//
//  Synopsis:   Async callback to JIT install UniScribe (USP10.DLL)
//
//  Arguments:  DWORD (CDoc *)  The current doc from which the hWnd can be gotten
//
//  Returns:    none
//
//-----------------------------------------------------------------------------

void CDoc::FaultInUSP(DWORD_PTR dwContext)
{
    HRESULT hr;
    uCLSSPEC classpec;
    CStr cstrGUID;
    ULONG cDie = _cDie;
    BOOL  fRefresh = FALSE;

    PrivateAddRef();

    g_csJitting.Enter();

    Assert(g_bUSPJitState == JIT_PENDING);

    // Close the door. We only want one of these running.
    g_bUSPJitState = JIT_IN_PROGRESS;

    // Set the GUID for USP10 so JIT can lookup the feature
    cstrGUID.Set(TEXT("{b1ad7c1e-c217-11d1-b367-00c04fb9fbed}"));

    // setup the classpec
    classpec.tyspec = TYSPEC_CLSID;
    hr = CLSIDFromString((BSTR)cstrGUID, &classpec.tagged_union.clsid);

    if(hr == S_OK)
    {
        hr = THR(FaultInIEFeatureHelper(GetHWND(), &classpec, NULL, 0));
    }

    // if we succeeded or the document navigated away (process was killed in
    // CDoc::UnloadContents) set state to JIT_OK so IOD can be attempted
    // again without having to restart the host.
    if(hr == S_OK)
    {
        g_bUSPJitState = JIT_OK;
        if(cDie == _cDie)
            fRefresh = TRUE;
    }
    else
    {
        // The user cancelled or aborted. Don't ask for this again
        // during this session.
        g_bUSPJitState = JIT_DONT_ASK;
    }

    g_csJitting.Leave();
    
    // refresh the view if we have just installed.
    if(fRefresh)
    {
        _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_FORCE);
    }

    PrivateRelease();
}

//-----------------------------------------------------------------------------
//
//  Function:   CDoc::FaultInJG
//
//  Synopsis:   Async callback to JIT install JG ART library for AOL (JG*.DLL)
//
//-----------------------------------------------------------------------------

void CDoc::FaultInJG(DWORD_PTR dwContext)
{
    HRESULT hr;
    uCLSSPEC classpec;
    CStr cstrGUID;

    if (g_bJGJitState != JIT_PENDING)
        return;

    // Close the door. We only want one of these running.
    g_bJGJitState = JIT_IN_PROGRESS;

    HWND hWnd = GetHWND();
    // Set the GUID for JG*.dll so JIT can lookup the feature
    cstrGUID.Set(_T("{47f67d00-9e55-11d1-baef-00c04fc2d130}"));

    // setup the classpec
    classpec.tyspec = TYSPEC_CLSID;
    hr = CLSIDFromString((BSTR) cstrGUID, &classpec.tagged_union.clsid);

    if (hr == S_OK)
    {
        hr = THR(FaultInIEFeatureHelper(hWnd, &classpec, NULL, 0));
    }

    // if we succeeded or the document navigated away (process was killed in
    // CDoc::UnloadContents) set state to JIT_OK so IOD can be attempted
    // again without having to restart the host.
    if (hr == S_OK)
    {
        g_bJGJitState = JIT_OK;
    }
    else
    {
        // The user cancelled or aborted. Don't ask for this again
        // during this session.
        g_bJGJitState = JIT_DONT_ASK;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::ExpandedRelativeUrlInVariant
//
//  Synopsis:   Used by CBase::getAttribute to expand an URL if the property
//              retrieved is an URL and the GETMEMBER_ABSOLUTE is specified.
//
//----------------------------------------------------------------------------

HRESULT
CBase::ExpandedRelativeUrlInVariant(VARIANT *pVariantURL)
{
    HRESULT         hr = S_OK;
    TCHAR           cBuf[pdlUrlLen];
    TCHAR          *pchUrl = cBuf;

    if (pVariantURL && V_VT(pVariantURL) == VT_BSTR)
    {
        BSTR            bstrURL;
        IHTMLElement   *pElement;
        CElement       *pCElement;

        // Are we really an element?
        if (!PrivateQueryInterface(IID_IHTMLElement, (void **)&pElement))
        {
            ReleaseInterface(pElement);

            pCElement = DYNCAST(CElement, this);

            hr = CMarkup::ExpandUrl(
                pCElement->GetMarkup(), V_BSTR(pVariantURL), 
                ARRAY_SIZE(cBuf), pchUrl, pCElement);
            if (hr)
                goto Cleanup;

            hr = FormsAllocString(pchUrl, &bstrURL);
            if (hr)
                goto Cleanup;

            VariantClear(pVariantURL);

            V_BSTR(pVariantURL) = bstrURL;
            V_VT(pVariantURL) = VT_BSTR;
        }
    }
    else
        hr = S_OK;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DeferSetCursor
//
//  Synopsis:   After scrolling we want to post a setcursor message to our
//              window so that the cursor shape will get updated. However,
//              because of nested scrolls, we might end up with multiple
//              setcursor calls. To avoid this, we will post a method call
//              to the function which actually does the postmessage. During
//              the setup of the method call we will delete any existing
//              callbacks, and hence this will delete any existing callbaks.
//
//----------------------------------------------------------------------------
void
CDoc::DeferSetCursor()
{
    if ( _fDisableReaderMode )
        return;
        
    GWKillMethodCall (this, ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor), 0);
    IGNORE_HR(GWPostMethodCall (this,
                                ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor),
                                0, FALSE, "CDoc::SendSetCursor"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SendMouseMessage
//
//  Synopsis:   This function actually posts the message to our window.
//
//----------------------------------------------------------------------------
void
CDoc::SendSetCursor(DWORD_PTR dwContext)
{
    // First be sure that we are all OK
    // Do this only if we have focus. We don't want to generate mouse events
    // when we do not have focus (bug 9144)
    
    if (    _pInPlace
        &&  _pInPlace->_hwnd
        &&  HasFocus() )
    {
        CPoint  pt;
        CRect   rc;

        ::GetCursorPos(&pt);
        ::ScreenToClient(_pInPlace->_hwnd, &pt);
        ::GetClientRect(_pInPlace->_hwnd, &rc);

        // Next be sure that the mouse is in our client rect and only then
        // post ourselves the message.
        if (rc.Contains(pt))
        {
            ::PostMessage(_pInPlace->_hwnd, WM_SETCURSOR, (WORD)_pInPlace->_hwnd, HTCLIENT);
        }
    }
}


//+====================================================================================
//
// Method: SetClick
//
// Synopsis: Enable the Setting and passing of click messages
//
//------------------------------------------------------------------------------------

VOID
CDoc::SetClick(CMessage* pMessage)
{
    pMessage->SetNodeClk(pMessage->pNodeHit);
}


//+==========================================================
//
// Method: UpdateCaret
//
// Synopsis: Informs the caret that it's position has been
//           changed externally.
//
//-----------------------------------------------------------

HRESULT
CDoc::UpdateCaret(
    BOOL        fScrollIntoView,    //@parm If TRUE, scroll caret into view if we have
                                    // focus or if not and selection isn't hidden
    BOOL        fForceScroll,       //@parm If TRUE, scroll caret into view regardless
    CDocInfo *  pdci )
{
    HRESULT hr = S_OK;

    if( _pCaret )
        hr = _pCaret->UpdateCaret( fScrollIntoView, fForceScroll, pdci );

    RRETURN( hr );
}

//+==========================================================
//
// Method: UpdateCaretPosition
//
// Synopsis: Repositions the caret at the given point.
//
//-----------------------------------------------------------

HRESULT
CDoc::UpdateCaretPosition(CLayout *pLayout, POINTL ptlScreen)
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pElement = NULL;
    IDisplayPointer     *pDispCaret = NULL;

    if (_pCaret)
    {
        CPoint          pt;

        Assert(pLayout && pLayout->ElementContent());
        Assert(_pInPlace && _pInPlace->_hwnd);

        //  Convert from screen coordinates.
        pt.x = ptlScreen.x;
        pt.y = ptlScreen.y;

        ScreenToClient( _pInPlace->_hwnd, (POINT*) & pt );

        pLayout->TransformPoint( &pt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );
        IFC( pLayout->ElementContent()->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );

        //  Create a display pointer at the new caret position
        IFC( CreateDisplayPointer( & pDispCaret ));
        
        g_uiDisplay.DocPixelsFromDevice(&pt);
        IFC( pDispCaret->MoveToPoint(pt, COORD_SYSTEM_CONTENT, pElement, 0, NULL) );

        //  Move the caret to the display pointer
        _pCaret->MoveCaretToPointerEx( pDispCaret, _pCaret->IsVisible(), FALSE, CARET_DIRECTION_INDETERMINATE );
    }

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispCaret);
    RRETURN( hr );
}

//+==========================================================
//
// Method: HandleSelectionMessage
//
// Synopsis: Dispatch a message to the Selection Manager if it exists.
//
//
//-----------------------------------------------------------
HRESULT
CDoc::HandleSelectionMessage(
            CMessage   *pMessage,
            BOOL        fForceCreate ,
            EVENTINFO  *pEvtInfo ,
            HM_TYPE     eHMType )
{
    BOOL            fNeedToSetEditContext   = FALSE;
    BOOL            fAllowSelection         = TRUE;
    IHTMLEventObj * pEventObj               = NULL;
    HRESULT         hr                      = S_FALSE;
    HRESULT         hr2;
    BOOL            fReleasepNode           = FALSE;
    BOOL            fReleasepNodeHit        = FALSE;
    IHTMLEditor   * ped                     = NULL;
    CElement      * pEditElement            = NULL;

    if (pMessage->fSelectionHMCalled)
        goto Cleanup;

    if ( (pMessage->pNodeHit) &&
         (pMessage->pNodeHit->Element() == PrimaryRoot() ) )
        goto Cleanup;

    if ( pMessage->pNodeHit )
        pEditElement = pMessage->pNodeHit->Element();
    else
        pEditElement = NULL;

    AssertSz( !_pDragStartInfo || ( _pDragStartInfo && pMessage->message != WM_MOUSEMOVE ),
              "Sending a Mouse Message to the tracker during a drag !");

    //
    // We just got a mouse down. If the element is not editable,
    // we need to set the Edit Context ( as SetEditContext may not have already happened)
    // If we don't do this the manager may not have a tracker for the event !
    //
    // 

    //
    // Don't set edit context on mouse down in scrollbars - as TranslateAccelerator in the editor
    // will ignore these messages anyway.
    //
    //
    // marka - this is ok - as we will move the SetEditContext code into the editor anyway.
    //
    
    fNeedToSetEditContext = (pEditElement  && 
                             _pElemCurrent && _pElemCurrent->_etag != ETAG_ROOT &&
                            (ShouldSetEditContext( pMessage ) && 
                             pMessage->htc != HTC_VSCROLLBAR && 
                             pMessage->htc != HTC_HSCROLLBAR  )) ; 
               
    if ( fNeedToSetEditContext )             // we only check if we think we need to set the ed. context
        fAllowSelection = pEditElement && ! pEditElement->DisallowSelection() ;

   ped = GetHTMLEditor( fForceCreate || ( fNeedToSetEditContext && fAllowSelection ) );


    // Block selection handling for layout rects;  we don't want
    // the editor drilling into our contained content.
    if ( pEditElement && pEditElement->IsLinkedContentElement() )
        goto Cleanup;

    if ( ped && (pMessage->pNodeHit == NULL || !pMessage->pNodeHit->IsDead()) &&
                (pEvtInfo->_pParam->_pNode == NULL || !pEvtInfo->_pParam->_pNode->IsDead()) )
    {   
        //
        // NOTE. We set the _lButton based on the message type
        // Some automation harnesses (VID) - cookup messages without setting the mouse button
        //
        
        switch( pMessage->message )
        {
            case WM_LBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 1;
            break;

            case WM_RBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 2;
            break;

            case WM_MBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 4;
            break;
        }

        //
        // NOTE - hide the root - to show the Master if we're viewlinked.
        // 
        if ( pEditElement &&
             pEditElement->_etag == ETAG_ROOT &&
             pEditElement->HasMasterPtr() )
        {
            Assert( pEditElement->GetFirstBranch() == pEvtInfo->_pParam->_pNode ||
                    pEditElement->GetMasterPtr()->GetFirstBranch() == pEvtInfo->_pParam->_pNode);
            
            pEditElement = pEditElement->GetMasterPtr();
            pEvtInfo->_pParam->SetNodeAndCalcCoordinates(pEditElement->GetFirstBranch(), TRUE);
            // pEvtInfo->_pParam->SetNodeAndCalcCoordinates(pEditElement->GetFirstBranch(), TRUE);
        }
        
        CEventObj::Create(&pEventObj, this, pEditElement, NULL, FALSE, NULL, pEvtInfo->_pParam);

        ped->AddRef();

        if(pMessage->pNodeHit)
        {
            hr2 = THR( pMessage->pNodeHit->NodeAddRef() );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
            fReleasepNodeHit = TRUE;
        }
        if(pEvtInfo->_pParam->_pNode)
        {
            hr2 = THR( pEvtInfo->_pParam->_pNode->NodeAddRef() );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
            fReleasepNode = TRUE;
        }

        switch( eHMType )
        {
            case HM_Pre:
            hr = THR( ped->PreHandleEvent( pEvtInfo->_dispId, pEventObj ));
            if ( hr != S_FALSE )
            {
                pMessage->fSelectionHMCalled = TRUE;                
            }
            break;

            case HM_Post:
            hr = THR( ped->PostHandleEvent( pEvtInfo->_dispId, pEventObj ));
            pMessage->fSelectionHMCalled = TRUE;                
            break;

            case HM_Translate:
            hr = THR( ped->TranslateAccelerator( pEvtInfo->_dispId, pEventObj ));
            if ( hr != S_FALSE )
            {
                pMessage->fSelectionHMCalled = TRUE;                
            }                
            break;
            
        }

        //
        // Check the return value and pass it back
        // to WndProc
        // 
        // TODO: 
        // I will only do it for IME RECONVERSION 
        // messages currently. However We should 
        // always check for return value and set it
        // This can be reconsidered and modified in
        // the future. 
        // (zhenbinx)
        //
#if !defined(NO_IME)            
        #ifndef WM_IME_REQUEST
        #define WM_IME_REQUEST 0x0288
        #endif
        if (S_OK == hr)
        {
            switch (pMessage->message)
            {
            case WM_IME_REQUEST:
                {
                    TraceTag((tagEdSelMan, "Pass lresult back to WndProc"));
                    VARIANT  v;
                    VariantInit(&v);    
                    THR( pEventObj->get_returnValue(&v) );
                    switch (V_VT(&v))
                    {
                        case    VT_I2:
                                pMessage->lresult = V_I2(&v);
                                break;
                                
                        case    VT_I4:
                                pMessage->lresult = V_I4(&v);
                                break;
                                
                        case    VT_BOOL:
                                pMessage->lresult = (LRESULT)(
                                        V_BOOL(&v) == VARIANT_TRUE ? TRUE : FALSE 
                                            );
                                break;
                    }
                    TraceTag((tagEdSelMan, "pMessage->lresult = %d - %x", pMessage->lresult, pMessage->lresult));
                    VariantClear(&v);
                }
                
            }
        }
#endif
        ped->Release();
    }

Cleanup:
    if( pMessage->pNodeHit && fReleasepNodeHit )
    {
        pMessage->pNodeHit->NodeRelease();
    }
    
    if( pEvtInfo->_pParam->_pNode && fReleasepNode )
    {
        // Windows security push bug 536319 
        // pNode is pointing to a garbage now since HandleSelection Message
        // is the only one AddRef pNode so we know it has to be a garbage now
        // if it is dead. 
        // 
        BOOL fDeadNode = pEvtInfo->_pParam->_pNode->IsDead();
        pEvtInfo->_pParam->_pNode->NodeRelease();
        if (fDeadNode)
        {
            pEvtInfo->_pParam->_pNode = NULL;
            // STOP routing message to editor as well since the event node will be a garbage
            pMessage->fSelectionHMCalled = TRUE;
        }
    }

    ReleaseInterface( pEventObj );
    RRETURN1( hr, S_FALSE );
}

#if !defined(NO_IME)
#ifndef WM_IME_REQUEST
#define WM_IME_REQUEST 0x0288
#endif
#endif

HRESULT
CDoc::CreateIMEEventInfo(CMessage * pMessage, EVENTINFO * pEvtInfo, CElement * pElement) 
{
    HRESULT hr = S_OK ;
    EVENTPARAM *pparam = NULL;
    LPTSTR pchType = NULL;    

    Assert(  pMessage &&
             ( pMessage->message == WM_IME_STARTCOMPOSITION ||
               pMessage->message == WM_IME_ENDCOMPOSITION || 
               pMessage->message == WM_IME_COMPOSITIONFULL ||
               pMessage->message == WM_IME_CHAR ||
               pMessage->message == WM_IME_COMPOSITION ||
               pMessage->message == WM_IME_NOTIFY ||
               pMessage->message == WM_INPUTLANGCHANGE ||
               pMessage->message == WM_IME_REQUEST ) );
               
    switch(pMessage->message)
    {
    case WM_IME_STARTCOMPOSITION:
        pchType = _T("startComposition");
        break;

    case WM_IME_ENDCOMPOSITION:
        pchType = _T("endComposition");
        break;

    case WM_IME_COMPOSITIONFULL:
        pchType = _T("compositionFull");
        break;

    case WM_IME_CHAR:
        pchType = _T("char");
        break;

    case WM_IME_COMPOSITION:
        pchType = _T("composition");
        break;

    case WM_IME_NOTIFY:
        pchType = _T("notify");
        break;

    case WM_INPUTLANGCHANGE:
        pchType = _T("inputLangChange");
        break;
        
    case WM_IME_REQUEST:
        pchType = _T("imeRequest");
        break;
    }

    if (pchType)
    {
        pparam = new EVENTPARAM(this, pElement, NULL, FALSE, FALSE);
        if (!pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        switch(pMessage->message)
        {
        case WM_IME_COMPOSITION:
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_IME_NOTIFY:
            pparam->_wParam = pMessage->wParam;
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_INPUTLANGCHANGE:
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_IME_REQUEST:
            pparam->_wParam = pMessage->wParam;
            pparam->_lParam = pMessage->lParam;
            break;
            
        }

        pparam->SetType(pchType);
        
        Assert(!pEvtInfo->_pParam);
        pEvtInfo->_pParam = pparam;
        pEvtInfo->_dispId = 0;
    }

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::CreateDblClickInfo
//
//  Synopsis:   Creates an "internal" double-click message so the editor is
//              able to synchronize with the real windows LBUTTONDBLCLK message
//              instead of Trident's delayed DBLCLICK event.  See CDoc::PumpMessage
//              or bug 86923 for more details.
//
//  Arguments:  pMessage = CMessage corresponding to LBUTTONDBLCLK
//              pEvtInfo = Event info struct to fill out
//              pElement = Element where event was fired
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CDoc::CreateDblClickInfo(   CMessage    *pMessage, 
                            EVENTINFO   *pEvtInfo, 
                            CTreeNode   *pNodeContext,
                            CTreeNode   *pNodeEvent /* = NULL */ )
{
    HRESULT     hr = S_OK ;
    EVENTPARAM  *pparam = NULL;         // Event parameters
    POINT       ptScreen;               // Screen coords
    
    CTreeNode   *pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;
    
    Assert( pMessage && pMessage->message == WM_LBUTTONDBLCLK && pNodeSrcElement && pNodeContext );
               
    //
    // Create new event param
    //
    pparam = new EVENTPARAM(this, pNodeContext->Element(), NULL, FALSE, FALSE);
    if (!pparam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptScreen.x = pMessage->pt.x;
    ptScreen.y = pMessage->pt.y;

    //
    // Setup the parameters that this event will use.  These may or 
    // may not be used by the editor, but just in case, we should have
    // them.  Modeled after CElement::FireStdEvent_MouseHelper()
    // 
    pparam->_htc = pMessage->htc;
    pparam->_lBehaviorCookie = pMessage->lBehaviorCookie;
    pparam->_lBehaviorPartID = pMessage->lBehaviorPartID;

    pparam->_pLayoutContext = pMessage->pLayoutContext;
    
    pparam->SetNodeAndCalcCoordinates(pNodeSrcElement);

    //
    // Setup the coordinates of this event
    //
    pparam->SetClientOrigin(pNodeContext->Element(), &pMessage->pt);

    if( _pInPlace )
        ClientToScreen( _pInPlace->_hwnd, &ptScreen );
        
    pparam->_screenX = ptScreen.x;
    pparam->_screenY = ptScreen.y;

    //
    // Misc information about keyboard states
    //
    pparam->_sKeyState = VBShiftState();

    pparam->_fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
    pparam->_fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
    pparam->_fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

    pparam->_lButton = VBButtonState( (short)pMessage->wParam );

    // Name of our internal hacky event
    pparam->SetType(_T("intrnlDblClick"));
    
    Assert(!pEvtInfo->_pParam);
    pEvtInfo->_pParam = pparam;
    pEvtInfo->_dispId = 0;

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: 'Select from here to here' a wrapper to the selection manager.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::Select( ISegmentList* pSegmentList )
{
    HRESULT             hr = S_OK; 
    ISelectionObject2   *pISelObject = NULL;       
            
    hr = THR( GetSelectionObject2( &pISelObject ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( pISelObject->Select( pSegmentList ));  
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: 'Select from here to here' a wrapper to the selection manager.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::Select( 
                IMarkupPointer* pStart, 
                IMarkupPointer* pEnd, 
                SELECTION_TYPE eType )
{
    HRESULT             hr = S_OK;
    IHTMLEditServices   *pIServices = NULL;

    hr = THR( GetEditServices( &pIServices ) );
    if ( hr )
        goto Cleanup;
       
    hr = THR( pIServices->SelectRange( pStart, pEnd, eType ));  
        
Cleanup:
    ReleaseInterface( pIServices );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: EmptySelection
//
// Synopsis: Empties the current selection and hides the caret
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::EmptySelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->EmptySelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );  
}

//+====================================================================================
//
// Method:      DestroyAllSelection
//
// Synopsis:    Removes the current selection
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DestroyAllSelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->DestroyAllSelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );

}

//+====================================================================================
//
// Method:      DestroySelection
//
// Synopsis:    Removes the current selection, and clears adorners
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DestroySelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->DestroySelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteselectable
//
// Synopsis: Determine if a given elemnet is site selectable by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementSiteSelectable( CElement* pCurElement, CElement** ppSelectThis /* = NULL*/ )
{
    HRESULT hr = S_OK;
    HRESULT hrSiteSelectable = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    IHTMLElement* pISelectThis = NULL;
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ppSelectThis )
        *ppSelectThis = NULL;
        
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrSiteSelectable = pIEditingServices->IsElementSiteSelectable( pICurElement, 
                                                                       ppSelectThis ? & pISelectThis : NULL  );

        if ( hrSiteSelectable == S_OK  && ppSelectThis )
        {
            Assert( pISelectThis );

            hr = THR( pISelectThis->QueryInterface( CLSID_CElement, (void**) ppSelectThis ));
            if ( hr)
                goto Cleanup;            
        }
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pISelectThis );
    ReleaseInterface( pIEditingServices);
    
    return ( hrSiteSelectable == S_OK );
}

//+====================================================================================
//
// Method: IsElementUIActivatable
//
// Synopsis: Determine if a given elemnet is site selectable by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementUIActivatable( CElement* pCurElement)
{
    HRESULT hr = S_OK;
    HRESULT hrActivatable = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrActivatable = pIEditingServices->IsElementUIActivatable( pICurElement );
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pIEditingServices);
    
    return ( hrActivatable  == S_OK );
}

//+====================================================================================
//
// Method: IsElementSiteselected
//
// Synopsis: Determine if a given elemnet is currently site selected 
//
//------------------------------------------------------------------------------------
BOOL
CDoc::IsElementSiteSelected( CElement* pCurElement)
{
    HRESULT                 hr = S_OK;
    SELECTION_TYPE          eType;
    ISegmentList            *pISegmentList = NULL;
    ISegment                *pISegment = NULL;
    IElementSegment         *pIElementSegment = NULL;   
    IHTMLElement            *pIElement = NULL;
    ISegmentListIterator    *pIIter = NULL;
    IObjectIdentity         *pIIdent = NULL;
    BOOL                    fSelected = FALSE;
    BOOL                    fEmpty;
    
    hr = THR( GetCurrentSelectionSegmentList(&pISegmentList) );
    if( FAILED(hr) )
        goto Cleanup;

    hr = THR( pCurElement->QueryInterface( IID_IObjectIdentity, (void **)&pIIdent));
    if( FAILED(hr) )
        goto Cleanup;

    // Make sure something is selected, and that the type of 
    // selection is control (otherwise, nothing can be site
    // selected)
    hr = THR( pISegmentList->IsEmpty(&fEmpty) );
    if( FAILED(hr) || fEmpty )
        goto Cleanup;

    hr = THR( pISegmentList->GetType(&eType) );
    if( FAILED(hr) || (eType != SELECTION_TYPE_Control) )
        goto Cleanup;
    
    hr = THR( pISegmentList->CreateIterator( &pIIter ) );
    if( FAILED(hr) )
        goto Cleanup;

    while( (pIIter->IsDone() == S_FALSE) && (fSelected == FALSE) )
    {
        // Retrieve the current segment
        hr = THR( pIIter->Current( &pISegment ) );
        if( FAILED(hr) )
            goto Cleanup;

        // QI for the IHTMLElement (should not fail if we have
        // a control tracker )
        hr = THR( pISegment->QueryInterface( IID_IElementSegment, (void **)&pIElementSegment ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pIElementSegment->GetElement( &pIElement ) );
        if( FAILED(hr) )
            goto Cleanup;

        // Check to see if our object is equal
        if( pIIdent->IsEqualObject( pIElement ) == S_OK )
        {
            fSelected = TRUE;
        }
        
        ClearInterface( &pISegment );
        ClearInterface( &pIElementSegment );
        ClearInterface( &pIElement );

        hr = pIIter->Advance();
        if( FAILED(hr) )
            goto Cleanup;
    }
   
Cleanup:
    ReleaseInterface( pISegmentList );
    ReleaseInterface( pISegment );
    ReleaseInterface( pIElement );
    ReleaseInterface( pIIter );
    ReleaseInterface( pIIdent );
    ReleaseInterface( pIElementSegment );
    
    return(fSelected);
}



//+====================================================================================
//
// Method: IsElementAtomic
//
// Synopsis: Determine if a given elemnet is atomic by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementAtomic( CElement* pCurElement)
{
    HRESULT hr = S_OK;
    HRESULT hrAtomic = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrAtomic = pIEditingServices->IsElementAtomic( pICurElement );
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pIEditingServices);
    
    return ( hrAtomic == S_OK );
}

HRESULT
CDoc::NotifySelectionHelper( EDITOR_NOTIFICATION eSelectionNotification,
                        CElement* pElementNotify,
                        DWORD dword /* = 0*/,
                        CElement* pElement /*=NULL*/)
{
    IUnknown* pUnk = NULL;
    HRESULT hr;
    
    hr = THR( pElementNotify->QueryInterface(IID_IUnknown, (void**) & pUnk ));
    if ( hr )
        goto Cleanup;

    hr = THR( NotifySelection( eSelectionNotification, pUnk, dword, pElement ));
    
Cleanup:
    ReleaseInterface( pUnk );
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method:NotifySelection
//
// Synopsis: Notify the HTMLEditor that "something" happened.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::NotifySelection(
                        EDITOR_NOTIFICATION eSelectionNotification,
                        IUnknown* pUnknown,
                        DWORD dword /* = 0*/,
                        CElement* pElement /*=NULL*/)
{
    HRESULT hr = S_OK;

    IHTMLEditor * ped = NULL;

    //
    // If we get a timer tick - when the doc is shut down this is very bad
    //
    Assert( ! ( (  eSelectionNotification == EDITOR_NOTIFY_TIMER_TICK )
            && (_ulRefs == ULREF_IN_DESTRUCTOR)) );

    if( _pIHTMLEditor == NULL && ! ShouldCreateHTMLEditor( eSelectionNotification , pElement ))
        goto Cleanup;    // Nothing to do

    if (eSelectionNotification == EDITOR_NOTIFY_LOSE_FOCUS)
    {
        if (_pCaret)
            _pCaret->LoseFocus();         
    }

    ped = GetHTMLEditor( (eSelectionNotification != EDITOR_NOTIFY_DOC_ENDED 
                         && eSelectionNotification != EDITOR_NOTIFY_CONTAINER_ENDED)
                       );

    if ( ped )
    {
        hr = ped->Notify( eSelectionNotification, pUnknown, dword );
    }

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


//+====================================================================================
//
// Method:  GetSelectionType
//
// Synopsis:Check the current selection type of the selection manager
//
//------------------------------------------------------------------------------------


SELECTION_TYPE
CDoc::GetSelectionType()
{
    ISegmentList    *pISegList = NULL;  
    SELECTION_TYPE  theType = SELECTION_TYPE_None;

    if( GetHTMLEditor(FALSE) )
    {
        GetCurrentSelectionSegmentList(&pISegList);
        Assert( pISegList );
        
        pISegList->GetType(&theType);

        ReleaseInterface( pISegList );
    }
    
    return theType;
}

//+====================================================================================
//
// Method: HasTextSelection
//
// Synopsis: Is there a "Text Selection"
//
//------------------------------------------------------------------------------------


BOOL
CDoc::HasTextSelection()
{
    return ( GetHTMLEditor(FALSE) && GetSelectionType() == SELECTION_TYPE_Text );
}


//+====================================================================================
//
// Method: HasSelection
//
// Synopsis: Is there any form of Selection ?
//
//------------------------------------------------------------------------------------

BOOL
CDoc::HasSelection()
{
    return ( GetHTMLEditor(FALSE) && GetSelectionType() != SELECTION_TYPE_None );
}


BOOL
CDoc::IsEmptySelection()
{
    ISegmentList    *pISegList = NULL; 
    ISegmentListIterator *pIIter = NULL;
    ISegment*       pISegment = NULL;
    IMarkupPointer* pIStart = NULL;
    IMarkupPointer* pIEnd = NULL;
    
    HRESULT hr;
    BOOL fEmpty = FALSE;
    
    if ( GetHTMLEditor(FALSE ) && GetSelectionType() == SELECTION_TYPE_Text )
    {
        IFC( GetCurrentSelectionSegmentList(&pISegList));
        IFC( pISegList->CreateIterator( & pIIter ));   
            
        IFC( CreateMarkupPointer( & pIStart ));
        IFC( CreateMarkupPointer( & pIEnd ));

        fEmpty = TRUE;
        
        while( pIIter->IsDone() == S_FALSE && fEmpty )
        {
            // Retrieve the current segment
            IFC( pIIter->Current( &pISegment ) );
            IFC( pISegment->GetPointers( pIStart, pIEnd ));

            IFC( pIStart->IsEqualTo( pIEnd, & fEmpty ));
            
            IFC( pIIter->Advance());

            ClearInterface( & pISegment );
        }        
    }
    
Cleanup:
    ReleaseInterface( pISegList );
    ReleaseInterface( pISegment );
    ReleaseInterface( pIStart );
    ReleaseInterface( pIEnd );
    ReleaseInterface( pIIter );

    return fEmpty;
}


//+====================================================================================
//
// Method: PointInSelection
//
// Synopsis: Is the given point in a Selection ? Returns false if there is no selection
//
//------------------------------------------------------------------------------------

BOOL
CDoc::IsPointInSelection(POINT pt, CTreeNode* pNode, BOOL fPtIsContent )
{
    // TODO (MohanB) This function does not check for clipping, because
    // MovePointerToPoint always does virtual hit-testing. We should pass
    // in an argument fDoVirtualHitTest to MovePointerToPoint() and set that
    // argument to FALSE when calling from this function.

    HRESULT hr = S_OK;
    
    IDisplayPointer* pDispPointer = NULL;
    BOOL fPointInSelection = FALSE;
    IHTMLElement* pIElementOver = NULL;
    CElement* pElement = NULL;
    SELECTION_TYPE eType = GetSelectionType() ;
    ISelectionObject2 *pISelObject = NULL;
    
    //
    // Illegal to call for content coordinates without a tree node
    //
    Assert( pNode || !fPtIsContent );
    
    if ( eType == SELECTION_TYPE_Control || eType == SELECTION_TYPE_Text )
    {
        //
        // marka TODO - consider making this take the node - and work out the pointer more directly
        //
        hr = THR( CreateDisplayPointer( & pDispPointer ));
        if ( hr )
            goto Cleanup;

        if ( pNode )
        {
            pElement = pNode->Element();

            if ( pElement )
            {
                hr = THR( pElement->QueryInterface( IID_IHTMLElement, ( void**) & pIElementOver));
                if ( hr )
                    goto Cleanup;
            }
        }
        
        //
        // One of two cases.  pNode is NOT null, in which case we retrieved
        // our element above.  Otherwise, if pNode Is NULL, pIElementOver will
        // not have been set, but we should be in the global coord system (via the
        // assert) so the display pointer should be able to handle it.
        //

        g_uiDisplay.DocPixelsFromDevice(&pt);
        
        IFC( pDispPointer->MoveToPoint(pt, 
                                       fPtIsContent ? COORD_SYSTEM_CONTENT : COORD_SYSTEM_GLOBAL,
                                       pIElementOver,
                                       0,
                                       NULL) );

        IGNORE_HR( GetSelectionObject2( &pISelObject ) );
        Assert( pISelObject );

        hr = THR( pISelObject->IsPointerInSelection( pDispPointer, &fPointInSelection , &pt, pIElementOver));       
    }

Cleanup :
    ReleaseInterface( pISelObject );
    ReleaseInterface( pDispPointer );
    ReleaseInterface( pIElementOver );
    return fPointInSelection;
    
}

//+========================================================================
//
// Method: ShouldCreateHTMLEditor
//
// Synopsis: Certain messages require the creation of a selection ( like Mousedown)
//           For these messages return TRUE.
//
//          Or if the Host will host selection Manager - return TRUE.
//-------------------------------------------------------------------------

BOOL
CDoc::ShouldCreateHTMLEditor( CMessage* pMessage )
{
    // If this is a MouseDown message, we should force a TSR to be created
    // Per Bug 18568 we should also force a TSR for down/up/right/left arrows
    switch(pMessage->message)
    {
        case WM_LBUTTONDOWN:
        /*case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:*/
            return TRUE;

        //
        // marka TODO - this may not be required anymore.
        //
        case WM_KEYDOWN:
            switch(pMessage->wParam)
            {
            case VK_LEFT:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
                return TRUE;

            }
        default:
            return FALSE;
    }
}


//+====================================================================================
//
// Method:ShouldCreateHTMLEditor
//
// Synopsis: Should we force the creation of a selection manager for this type of notify ?
//
//------------------------------------------------------------------------------------


BOOL
CDoc::ShouldCreateHTMLEditor( EDITOR_NOTIFICATION eSelectionNotification, CElement* pElement /*=NULL*/ )
{
    BOOL   fCreate = FALSE;
   
    if( eSelectionNotification == EDITOR_NOTIFY_BEFORE_FOCUS)
    {
        CMarkup* pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
        CElement* pRootElement = pMarkup->Root();
        
        // check the element is editable or its parent (container) is editable
        if ( ( pElement && ( pElement->IsEditable(FALSE) || pElement->IsEditable(TRUE) ) ) 

             ||
        
             ( pRootElement && 
               pRootElement->HasMasterPtr() && 
               pRootElement->GetMasterPtr()->IsParentEditable() ) )
        {
            fCreate = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    return fCreate;        
}

//+========================================================================
//
// Method: ShouldSetEditContext.
//
// Synopsis: On Mouse Down we should always set a new EditContext
//
//-------------------------------------------------------------------------

inline BOOL
CDoc::ShouldSetEditContext( CMessage* pMessage )
{
     switch(pMessage->message)
    {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            return TRUE;

        default:
            return FALSE;
    }
}

//+====================================================================================
//
// Method: GetEditingServices
//
// Synopsis: Get a ref-counted IHTMLEditingServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetEditingServices( IHTMLEditingServices **ppIServices )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void**) ppIServices));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: GetEditServices
//
// Synopsis: Get a ref-counted IHTMLEditServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetEditServices( IHTMLEditServices **ppIServices )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditServices, (void**) ppIServices));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: GetSelectionObject2
//
// Synopsis: Get a ref-counted ISelectionObject2, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetSelectionObject2( ISelectionObject2 **ppISelObject )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_ISelectionObject2, (void**)ppISelObject ));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: GetSelectionServices
//
// Synopsis: Get a ref-counted ISelectionServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------


HRESULT 
CDoc::GetSelectionServices( ISelectionServices **ppIServices )
{
    HRESULT hr = S_OK;
    IHTMLEditServices* pEdSvc = NULL;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditServices, ( void**) & pEdSvc ));
        if ( hr )
        {
            goto Cleanup;
        }
        
        hr = THR( pEdSvc->GetSelectionServices( NULL, ppIServices ));
    }
    else
    {
        hr = E_FAIL;
    }
Cleanup:
    ReleaseInterface( pEdSvc );
    
    RRETURN ( hr );
}

HRESULT
CDoc::GetSelectionMarkup( CMarkup **ppMarkup )
{
    HRESULT             hr = S_OK;
    ISelectionServices  *pISelServ = NULL;
    IMarkupContainer    *pIContainer = NULL;
    
    Assert( ppMarkup != NULL );

    *ppMarkup = NULL;

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionServices(&pISelServ) );
        if( hr )
            goto Cleanup;

        hr = THR( pISelServ->GetMarkupContainer( &pIContainer ) );
        if( hr )
            goto Cleanup;

        hr = THR( pIContainer->QueryInterface(CLSID_CMarkup, (void **)ppMarkup) );
        Assert( hr == S_OK && *ppMarkup );
    }


Cleanup:
    ReleaseInterface( pISelServ );
    ReleaseInterface( pIContainer );
    
    RRETURN( hr );
}

    
//+-------------------------------------------------------------------------
//  Method:     CDoc::GetEditResourceLibrary
//
//  Synopsis:   Loads and cache's the HINSTANCE for the editing resource DLL.
//
//  Arguments:  hResourceLibrary = OUTPUT - HINSTANCE for DLL
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT 
CDoc::GetEditResourceLibrary(HINSTANCE *hResourceLibrary)
{    
    //
    // Load the editing resource DLL if it hasn't already been loaded
    //
    if(!_hEditResDLL)
    {
        _hEditResDLL = MLLoadLibrary(_T("mshtmler.dll"), g_hInstCore, ML_CROSSCODEPAGE);
    }

    *hResourceLibrary = _hEditResDLL;

    if (!_hEditResDLL)
        return E_FAIL; // TODO: can we convert GetLastError() to an HRESULT?

    return S_OK;
}

//+-------------------------------------------------------------------------
//  Method:     CDoc::GetEditingString
//
//  Synopsis:   Loads a string from the editing DLL.
//
//  Arguments:  uiStringId = String ID to load
//              pchBuffer = I/O - Buffer to receive string
//              cchBuffer = Length of buffer
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CDoc::GetEditingString(UINT uiStringId , TCHAR* pchBuffer, long cchBuffer /*=NULL*/)
{
    HRESULT     hr = S_OK;
    HINSTANCE   hinstEditResDLL;
    INT         iResult;
    long        cch = cchBuffer ? cchBuffer : ARRAY_SIZE(pchBuffer);
           
    hr = GetEditResourceLibrary(&hinstEditResDLL) ;        
    if (hr)
        goto Cleanup;
      
    iResult = LoadString( hinstEditResDLL, uiStringId, pchBuffer, cch );
   
    if (!iResult)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    return hr; 
}


//+==========================================================
//
// Method: GetHTMLEditor
//
// Synopsis: This is the real GetHTMLEditor
//                QueryService on the Host for the HTMLEditor Service
//              if it's there - we QI the host for it.
//              if it's not there - we cocreate the HTMLEditor in Mshtmled
//
//-----------------------------------------------------------


IHTMLEditor* 

CDoc::GetHTMLEditor( BOOL fForceCreate /* = TRUE */ )
{
    HRESULT hr = S_OK;

    // If we have an editor already, just return it

    if( _pIHTMLEditor )
        goto Cleanup;


        
    if( fForceCreate )
    {

        // IE Bug 32346 (mharper) check that the _pWindowPrimary is valid
        if (!_pWindowPrimary)
            goto Error;

        // If the host doesn't want to be the editor, mshtmled sure does!
        MtAdd( Mt( LoadMSHTMLEd ), +1 , 0 );
        hr = ::CoCreateInstance(CLSID_HTMLEditor,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IHTMLEditor ,
                                (void**) &_pIHTMLEditor );
        
        if( FAILED( hr ) || _pIHTMLEditor == NULL )
            goto Error;
    
        //
        // Use a weak-ref to all doc interfaces. Use _OmDocument for CView while it
        // doesn't exist...
        //
        hr = THR(_pIHTMLEditor->Initialize(
                (IUnknown *)_pWindowPrimary->Document(),
                (IUnknown *)_pWindowPrimary->Document()->Markup()));
        if ( FAILED(hr) )
            goto Error;
            
    }   // fForceCreate
    
                                            
    goto Cleanup;
    
Error:
    AssertSz(0,"Unable to create Editor");
    ClearInterface( & _pIHTMLEditor );


Cleanup:
    AssertSz( ! ( fForceCreate && _pIHTMLEditor == NULL ) , "IHTMLEditor Not Found or Allocated on Get!" );

    return( _pIHTMLEditor );    
}


HRESULT 
CDoc::BeginSelectionUndo()
{
    HRESULT hr= S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pISelServListener = NULL;

    if ( GetHTMLEditor( FALSE ))
    {
        IGNORE_HR( NotifySelection( EDITOR_NOTIFY_BEGIN_SELECTION_UNDO, NULL ));
        
        //
        // Only bother with notifying sel serv - if there's already an editor.
        //
        hr = THR( GetSelectionServices( & pSelServ ));
        if ( hr )
            goto Cleanup;

        if ( SUCCEEDED( pSelServ->GetSelectionServicesListener( & pISelServListener )))
        {
            Assert( pISelServListener );
            hr = THR( pISelServListener->BeginSelectionUndo() );
        }            
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pISelServListener );
    
    RRETURN( hr );
}

HRESULT 
CDoc::EndSelectionUndo()
{
    HRESULT hr = S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pISelServListener = NULL;

    if ( GetHTMLEditor( FALSE ))
    {
        hr = THR( GetSelectionServices( & pSelServ ));
        if ( hr )
            goto Cleanup;

        if( SUCCEEDED( pSelServ->GetSelectionServicesListener( & pISelServListener )) )
        {
            Assert( pISelServListener );
            hr = THR( pISelServListener->EndSelectionUndo() );
        }            
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pISelServListener );
    
    RRETURN( hr );
}
    
HRESULT
CDoc::GetMarkupFromHighlightSeg(IHighlightSegment *pISegment, CMarkup **ppMarkup)
{
    HRESULT             hr;
    CHighlightSegment   *pSegment = NULL;

    Assert( pISegment && ppMarkup );

    *ppMarkup = NULL;

    //
    // Retrieve the markup from the highlight segment
    //
    hr = THR( pISegment->QueryInterface( CLSID_CHighlightSegment, (void **)&pSegment) );
    if( FAILED(hr) || !pSegment )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppMarkup = pSegment->GetMarkup();
    Assert( *ppMarkup );

Cleanup:
    RRETURN(hr);
}

HRESULT 
CDoc::AddSegment(   IDisplayPointer     *pIDispStart, 
                    IDisplayPointer     *pIDispEnd,
                    IHTMLRenderStyle    *pIRenderStyle,
                    IHighlightSegment   **ppISegment )  
{
    HRESULT             hr;
    CMarkup             *pMarkup;
    CDisplayPointer     *pDisplayPointer = NULL;

    Assert( pIDispStart && pIDispEnd && pIRenderStyle && ppISegment );

    //
    // Retrieve the CDisplayPointer
    hr = THR( pIDispStart->QueryInterface( CLSID_CDisplayPointer, (void **)&pDisplayPointer ) );
    if( FAILED(hr) || !pDisplayPointer )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Retrieve the markup
    //
    pMarkup = pDisplayPointer->Markup();
    Assert( pMarkup );
    if( !pMarkup )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
      
    hr = THR( pMarkup->AddSegment( pIDispStart, pIDispEnd, pIRenderStyle, ppISegment ) );

Cleanup:
    RRETURN ( hr );            
}

HRESULT 
CDoc::MoveSegmentToPointers(IHighlightSegment   *pISegment,
                            IDisplayPointer     *pIDispStart, 
                            IDisplayPointer     *pIDispEnd )
{
    HRESULT hr = E_INVALIDARG;
    CMarkup *pMarkup;

    Assert( pISegment && pIDispStart && pIDispEnd  );

    if( pISegment && pIDispStart && pIDispEnd )
    {
        hr = THR( GetMarkupFromHighlightSeg( pISegment, &pMarkup ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pMarkup->MoveSegmentToPointers(   pISegment, 
                                                    pIDispStart, 
                                                    pIDispEnd ) );
    }
    
Cleanup:

    RRETURN ( hr );        
}    
    
HRESULT 
CDoc::RemoveSegment( IHighlightSegment *pISegment )
{
    HRESULT hr = E_INVALIDARG;
    CMarkup *pMarkup;

    Assert( pISegment );

    if( pISegment )
    {
        hr = THR( GetMarkupFromHighlightSeg( pISegment, &pMarkup ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pMarkup->RemoveSegment(pISegment) );
    }
    
Cleanup:

    RRETURN ( hr );        
}


//+====================================================================================
//
// Method: GetSelectionDragDropSource
//
// Synopsis: If this doc is the source of a drag/drop, and we are drag/dropping a selection
//           return the CSelDragDropSrcInfo. Otherwise return NULL.
//
//------------------------------------------------------------------------------------


CSelDragDropSrcInfo* 
CDoc::GetSelectionDragDropSource()
{
    if ( _fIsDragDropSrc   &&
         _pDragDropSrcInfo &&
         _pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
    {
        return DYNCAST( CSelDragDropSrcInfo, _pDragDropSrcInfo );
    }
    else
        return NULL;
}


//+---------------------------------------------------------------------------
//
// Helper Function: IsNumPadKey
//
//      lParam      bit 16-23  ScanCode
//----------------------------------------------------------------------------
#ifndef SCANCODE_NUMPAD_FIRST
#define SCANCODE_NUMPAD_FIRST 0x47
#endif
#ifndef SCANCODE_NUMPAD_LAST
#define SCANCODE_NUMPAD_LAST  0x52
#endif
BOOL 
IsNumpadKey(CMessage *pmsg)
{
    UINT uScanCode = LOBYTE(HIWORD(pmsg->lParam));
    return (uScanCode >= SCANCODE_NUMPAD_FIRST &&
            uScanCode <= SCANCODE_NUMPAD_LAST
           );
}


//+---------------------------------------------------------------------------
//
// Helper Function: IsValidAccessKey
//
//----------------------------------------------------------------------------
BOOL
IsValidAccessKey(CDoc * pDoc, CMessage * pmsg)
{
    //
    // Bug 105346/104194
    // Alt+Numpad input has to be treated as CHAR
    // [zhenbinx]
    //
    return (    (   (pmsg->message == WM_SYSKEYDOWN && !IsNumpadKey(pmsg))
                 || (pDoc->_fInHTMLDlg && pmsg->message == WM_CHAR)
                )
            &&
                (pmsg->wParam != VK_MENU)
            );
}

BOOL IsFrameTabKey(CMessage * pMessage);
BOOL IsTabKey(CMessage * pMessage);

//+---------------------------------------------------------------------------
//
//  Member:     PerformTA
//
//  Synopsis:   Handle any accelerators
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//----------------------------------------------------------------------------
HRESULT
CDoc::PerformTA(CMessage * pMessage, EVENTINFO *pEvtInfo)
{
    HRESULT     hr    = S_FALSE;

    Assert(State() >= OS_INPLACE);

    // WinUser.h better not change! We are going to assume the order of the
    // navigation keys (Left/Right/Up/Down/Home/End/PageUp/PageDn), so let's
    // assert about it.
    Assert(VK_PRIOR + 1 == VK_NEXT);
    Assert(VK_NEXT  + 1 == VK_END);
    Assert(VK_END   + 1 == VK_HOME);
    Assert(VK_HOME  + 1 == VK_LEFT);
    Assert(VK_LEFT  + 1 == VK_UP);
    Assert(VK_UP    + 1 == VK_RIGHT);
    Assert(VK_RIGHT + 1 == VK_DOWN);

    if (WM_KEYDOWN == pMessage->message || WM_SYSKEYDOWN == pMessage->message ||
        WM_KEYUP == pMessage->message   || WM_SYSKEYUP == pMessage->message
        )
    {
        // Handle accelerator here.
        //  1. Pass any accelerators that the editor requires
        //  2. Bubble up the element chain starting from _pElemCurrent (or capture elem)
        //     and call PerformTA on them
        //  3. Perform key navigation for TAB and accesskey

        //
        // marka - pump all messages to the editor. It makes the determination on 
        // what it wants to handle in TA.
        //
        if ( pEvtInfo->_pParam != NULL )
        {
            hr = THR(HandleSelectionMessage(pMessage, FALSE, pEvtInfo , HM_Translate));
        }                
        if (hr != S_FALSE)
            goto Cleanup;


        CElement *  pElemTarget         = _pElemCurrent;

        CTreeNode * pNodeTarget         = pElemTarget->GetFirstBranch();
        BOOL        fGotEnterKey        = (pMessage->message == WM_KEYDOWN && pMessage->wParam == VK_RETURN);
        BOOL        fTranslateEnterKey  = FALSE;

        while (pNodeTarget && pElemTarget && pElemTarget->Tag() != ETAG_ROOT)
        {
            // Hack for tabbing between the button and text regions of InputFile
            if (WM_KEYDOWN == pMessage->message && VK_TAB == pMessage->wParam && pElemTarget->Tag() == ETAG_INPUT)
            {
                CInput * pInput = DYNCAST(CInput, pElemTarget);

                if (pInput->GetType() == htmlInputFile)
                {
                    hr = pInput->HandleFileMessage(pMessage);
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }

            hr = pElemTarget->PerformTA(pMessage);
            if (hr != S_FALSE)
                goto Cleanup;

            // Navigation keys are dealt with in HandleMessage, but we need to
            // treat them as accelerators (because many hosts such as HomePublisher
            // and KatieSoft Scroll expect us to - IE5 66735, 63774).

            if (    WM_KEYDOWN  == pMessage->message
                &&  VK_PRIOR    <= pMessage->wParam
                &&  VK_DOWN     >= pMessage->wParam
               )
            {
                // On the other hand, VID6.0 wants the fist shot at some of them if
                // there is a site-selection (they should fix this in VID6.1)
                if (    _fVID
                    &&  pMessage->wParam >= VK_LEFT
                    &&  GetSelectionType() == SELECTION_TYPE_Control)
                {
                    // let go to the host
                }
                else
                {
                    hr = pElemTarget->HandleMessage(pMessage);
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }

            // Raid 44891
            // Some hosts like AOL, CompuServe and MSN eat up the Enter Key in their
            // TranslateAccelerator, so we never get it in our WindowProc. We work around
            // by explicitly translating WM_KEYDOWN+VK_RETURN to WM_CHAR+VK_RETURN
            //
            if (fGotEnterKey && !pElemTarget->IsEditable(TRUE))
            {
                if (pElemTarget->_fActsLikeButton)
                {
                    fTranslateEnterKey = TRUE;
                }
                else
                {
                    switch (pElemTarget->Tag())
                    {
                    case ETAG_A:
                    case ETAG_IMG:
                    case ETAG_TEXTAREA:
                        fTranslateEnterKey = TRUE;
                        break;
                    }
                }
                if (fTranslateEnterKey)
                    break;
            }

            // Find the next target
            pNodeTarget = pNodeTarget->Parent();
            if (pNodeTarget)
            {
                pElemTarget = pNodeTarget->Element();
            }
            else
            {
                pElemTarget = pElemTarget->GetMasterPtr();
                pNodeTarget = (pElemTarget) ? pElemTarget->GetFirstBranch() : NULL;
            }
        }
        // Pressing 'Enter' should activate the default button
        // (unless the focus is on a SELECT - IE5 #64133)
        if (fGotEnterKey && !fTranslateEnterKey && !pElemTarget->IsEditable(/*fCheckContainerOnly*/FALSE) && _pElemCurrent->Tag() != ETAG_SELECT)
        {
             fTranslateEnterKey = !!_pElemCurrent->FindDefaultElem(TRUE);
        }
        if (fTranslateEnterKey)
        {
            ::TranslateMessage(pMessage);
            hr = S_OK;
            goto Cleanup;
        }

        Assert(hr == S_FALSE);

        if (IsFrameTabKey(pMessage)
            || IsTabKey(pMessage)
            || IsValidAccessKey(this, pMessage))
        {
            hr = HandleKeyNavigate(pMessage, FALSE);

            if (hr != S_FALSE)
                goto Cleanup;

            // Comment (jenlc). Say that the document has two frames, the
            // first frame has two controls with access keys ALT+A and ALT+B
            // respectively while the second frame has a control with access
            // key ALT+A. Suppose currently the focus is on the control with
            // access key ALT+B (the second control of the first frame) and
            // ALT+A is pressed, which control should get the focus? Currently
            // Trident let the control in the second frame get the focus.
            //
            if (IsTabKey(pMessage) || IsFrameTabKey(pMessage))
            {
                BOOL fYieldFailed = FALSE;

                IGNORE_HR(PrimaryRoot()->BecomeCurrentAndActive(0, &fYieldFailed, NULL, TRUE, 0, TRUE));
                if (fYieldFailed)
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }
    // Raid 63207
    // If we call IOleControSite::TranslateAccelerator() here for WM_CHAR
    // in HTML Dialog, this would cause WM_CHAR message to be re-dispatched
    // back to us, which is an infinite loop.
    //
    if (hr == S_FALSE &&
            (!_fInHTMLDlg || pMessage->message != WM_CHAR))
    {
        hr = CallParentTA(pMessage);
    }

    if (IsFrameTabKey(pMessage)
        || IsTabKey(pMessage)
        || IsValidAccessKey(this, pMessage))
    {
        if (hr == S_OK)
        {
            _pElemUIActive = NULL;
        }
        else if (hr == S_FALSE)
        {
            hr = HandleKeyNavigate(pMessage, TRUE);

            if (hr == S_FALSE && pMessage->message != WM_SYSKEYDOWN)
            {
                CElement *pElement = CMarkup::GetElementClientHelper(PrimaryMarkup());

                if (pElement)
                {
                    pElement->BecomeCurrentAndActive(pMessage->lSubDivision, NULL, NULL, TRUE);
                    hr = S_OK;  
                }
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


BOOL
CDoc::FCaretInPre()
{
    if (_pCaret)
    {
        CTreeNode * pNode = _pCaret->GetNodeContainer(MPTR_SHOWSLAVE);

        if (pNode)
        {
            const CParaFormat * pPF = pNode->GetParaFormat();
            if (pPF)
            {
                return pPF->_fPre;
            }
        }
    }

    return FALSE;
}

#if DBG==1
BOOL    
CDocExtra::AreLookasidesClear( void *pvKey, int nLookasides)
{
    DWORD * pdwKey = (DWORD*)pvKey;

    for ( ; nLookasides > 0; nLookasides--, pdwKey++ )
    {
        if (_HtPvPv.IsPresent( pdwKey ))
            return FALSE;
    }

    return TRUE;
}
BOOL    
CDocExtra::AreLookasides2Clear( void *pvKey, int nLookasides)
{
    DWORD * pdwKey = (DWORD*)pvKey;

    for ( ; nLookasides > 0; nLookasides--, pdwKey++ )
    {
        if (_HtPvPv2.IsPresent( pdwKey ))
            return FALSE;
    }

    return TRUE;
}
#endif


// Aggregration helper for XML MimeViewer
// RETURN true if we're being aggregated by the XML MimeViewer
extern "C" const IID IID_IXMLViewerIdentity;
BOOL CDoc::IsAggregatedByXMLMime()
{
    if (IsAggregated())
    {
        IUnknown *pXMLViewer = NULL;
        HRESULT hr = PunkOuter()->QueryInterface(IID_IXMLViewerIdentity, (void **)&pXMLViewer);
        if (hr == S_OK)
        {
            pXMLViewer->Release();
            return TRUE;
        }
    }
    return FALSE;
}

void 
CDoc::AddExpressionTask(CElement *pElement)
{
    // Don't create expression tasks for elements in print media
    if ( pElement->IsPrintMedia() )
        return;

    if ( !pElement->_fHasPendingRecalcTask )
    {
        if (!_aryPendingExpressionElements.Append ( pElement ))
        {
            pElement->_fHasPendingRecalcTask = TRUE;
            PostExpressionCallback();
        }
    }
}

void
CDoc::RemoveExpressionTask(CElement *pElement)
{
    if ( pElement->_fHasPendingRecalcTask )
    {
        INT i;
        i = _aryPendingExpressionElements.Find ( pElement );
        if ( i >= 0 )
        {
            _aryPendingExpressionElements [ i ] = NULL;
        }
        // Next recalc pass will delete the entry
        pElement->_fHasPendingRecalcTask = FALSE;
    }
}

void
CDoc::ExpressionCallback(DWORD_PTR)
{
    ExecuteExpressionTasks();
}

void
CDoc::ExecuteExpressionTasks()
{
    //
    // This function is re-entrant. Code may run in setStyleExpression, which may cause us to re-enter 
    // (e.g. a call to setExpression)
    //
    // A key architectural point is that expressions never get removed from the queue, if in
    // setStyleExpressions, code runs that calls removeExpression(), note that this merely sets
    // the array entry to null
    //

    if (_recalcHost._fInRecalc)
    {
        // This is a very bad time to be making changes to the dependency graph
        // Just return.  EngineRecalcAll will pick up any pending work when it finishes.
        return;
    }

    if (!TestLock(FORMLOCK_EXPRESSION))
    {
        INT i,size;
        CElement *pElem;
        CLock lock(this, FORMLOCK_EXPRESSION);

        
        if ( !_fPendingExpressionCallback )
        {
            // Nothing to do
            Assert ( _aryPendingExpressionElements.Size() == 0 ); // to get here there must be elements in the queue
            return;
        }

        _fPendingExpressionCallback = FALSE;

        size = _aryPendingExpressionElements.Size();

        Assert ( size > 0 ); // to get here there must be elements in the queue

        for ( i = 0 ; i < size ; i++ )
        {
            pElem = _aryPendingExpressionElements [i];
            //
            // A call to removeExpression, e.g. in CElement::Passive & CElement::ExitTree(),
            // sets the array entry to null
            //
            if ( pElem && pElem->GetFirstBranch() )
            {
                Assert ( pElem->_fHasPendingRecalcTask );

                pElem->_fHasPendingRecalcTask = FALSE;
                _aryPendingExpressionElements [i] = NULL;

                // If  a new recalc task is added for this element during this callback, 
                // it will be added to the end of the list, beyond size

                _recalcHost.setStyleExpressions(pElem); // *** This call may cause re-entrancy to this function ***

                pElem->_fHasExpressions = TRUE;

                // And if tasks where added during the upper loop, a call to _fPendingExpressionCallback has
                // been made and will kick off another ExecuteExpressionTasks() when its serviced     
            }        
        }

        // Clear up completed tasks
        if ( size > 0 )
            _aryPendingExpressionElements.DeleteMultiple(0, size - 1);

        if ( !_fPendingExpressionCallback )
        {
            // If the flag is still false, no more tasks were added in the loop above
            // So as an optimization, kill the posted method call if it was outstanding 

            Assert ( _aryPendingExpressionElements.Size() == 0 ); // if flag is off, queue must be empty

            GWKillMethodCall(this, ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0);
        }
    }
}

void
CDoc::PostExpressionCallback()
{
    if (!_fPendingExpressionCallback)
    {
        _fPendingExpressionCallback = 
            SUCCEEDED(GWPostMethodCall(this,ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0, FALSE, "CDoc::FilterCallback"));
        Assert(_fPendingExpressionCallback);
    }
}

void
CDoc::CleanupExpressionTasks()
{
    _aryPendingExpressionElements.DeleteAll();
    if ( _fPendingExpressionCallback )
    {
        GWKillMethodCall(this, ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0);
        _fPendingExpressionCallback = FALSE;
    }
}

BOOL
CDoc::AddFilterTask(CElement *pElement)
{
    if (!pElement->_fHasPendingFilterTask)
    {
        TraceTag((tagFilter, "Adding filter task for element %08x", pElement));

        Assert(_aryPendingFilterElements.Find(pElement) == -1);

        pElement->_fHasPendingFilterTask = SUCCEEDED(_aryPendingFilterElements.Append(pElement));

        PostFilterCallback();
    }

    return pElement->_fHasPendingFilterTask;
}

void
CDoc::RemoveFilterTask(CElement *pElement)
{
    if (pElement->_fHasPendingFilterTask)
    {
        int i = _aryPendingFilterElements.Find(pElement);

        Assert(i >= 0);
        if (i >= 0)
        {
            _aryPendingFilterElements[i] = NULL;
            pElement->_fHasPendingFilterTask = FALSE;

            TraceTag((tagFilter, "%08x Removing filter task", pElement));

            // We don't delete anything from the array, that will happen when the
            // ExecuteFilterTasks is called.

            Assert(_fPendingFilterCallback);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteSingleFilterTask
//
//  Synopsis:   Execute pending filter hookup for a single element
//
//              Can be called at anytime without worrying about trashing
//              the queue array
//
//----------------------------------------------------------------------------

BOOL
CDoc::ExecuteSingleFilterTask(CElement *pElement)
{
    if (!pElement->_fHasPendingFilterTask)
        return FALSE;

    int i = _aryPendingFilterElements.Find(pElement);

    Assert(i >= 0);

    if (i < 0)
        return FALSE;

    Assert(_aryPendingFilterElements[i] == pElement);

    // This function doesn't actually delete the entry, it simply nulls it out
    // The array is cleaned up when ExecuteFilterTasks is complete
    _aryPendingFilterElements[i] = NULL;

    pElement->_fHasPendingFilterTask = FALSE;

    TraceTag((tagFilter, "%08x demand executing filter task", pElement));
    pElement->AddFilters();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     ExecuteFilterTasks
//
//  Synopsis:   Execute pending filter hookup
//
//  Notes;      This code is 100% re-entrant safe.  Call it whenever, however
//              you want and it must do the right thing.  Re-entrancy into
//              other functions (like ComputeFormats) is the responsibility
//              of the caller :-)
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CDoc::ExecuteFilterTasks(BOOL * pfHaveAddedFilters/* = NULL */)
{
    TraceTag((tagFilter, "+ExecuteFilterTasks"));

    if(pfHaveAddedFilters)
        *pfHaveAddedFilters = FALSE;

    // We don't want to do this while we're painting
    if (   TestLock(SERVERLOCK_BLOCKPAINT))
    {
        if (_aryPendingFilterElements.Size())
        {
            TraceTag((tagFilter, "In the middle of Painting, will do the filters later"));
            PostFilterCallback();
            return FALSE;
        }

        return TRUE;    // No tasks means that they all got done, right?
    }


    // If we're in the middle of doing this (for whatever reason), don't start again
    // The primary reason for not starting again has to do with trying to cleanup the
    // array, otherwise this code is re-entrant safe
    if (!TestLock(FORMLOCK_FILTER))
    {
        CLock lock(this, FORMLOCK_FILTER);

        // Sometimes this gets called on demand.  We may have a posted callback, get rid of it now.
        if (_fPendingFilterCallback)
        {
            _fPendingFilterCallback = FALSE;
            GWKillMethodCall(this, ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0);
        }


        // We're only going to do as many elements as are there when we start
        int c = _aryPendingFilterElements.Size();

        if (c > 0)
        {
            for (int i = 0 ; i < c ; i++)
            {
                CElement *pElement = _aryPendingFilterElements[i];

                if (pElement)
                {
                   if(pElement->IsConnectedToPrimaryMarkup())
                    {
                        // This calls out to external code, anything could happen?
                        HRESULT hr = pElement->AddFilters();

                        if (hr == E_PENDING)
                        {
                            Assert(pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER));
                            TraceTag((tagFilter, "%08x Skipping the task, because attaching a Peer", pElement));
                            continue;
                        }

                        if (pfHaveAddedFilters)
                            *pfHaveAddedFilters = TRUE;

                        _aryPendingFilterElements[i] = NULL;

                        Assert(pElement->_fHasPendingFilterTask);
                        pElement->_fHasPendingFilterTask = FALSE;

                        TraceTag((tagFilter, "%08x Executing filter task from filter task list (also removes)", pElement));
                    }
                    else
                    {
                        // Not connected to the primary markup, we will create the filters later, after the merkup is switched
                        TraceTag((tagFilter, "%08x element is not connected to the primary markup, try again later", pElement));
                    }
                }
            }

            // Adding filters occasionally causes more filter
            // work.  Rather than doing it immediately, we'll
            // just wait until next time.
            Assert(_aryPendingFilterElements.Size() >= c);

            if (_aryPendingFilterElements.Size() > c)
            {
                PostFilterCallback();
            }

            // Now delete all the processed elements from the array
            for (int i = _aryPendingFilterElements.Size() - 1; i >= 0; i--)
            {
                if(!_aryPendingFilterElements[i])
                    _aryPendingFilterElements.Delete(i);
            }

#if DBG == 1
            if(_aryPendingFilterElements.Size() > 0)
            {
                TraceTag(( tagFilter, "Still have %d filters to add when exiting ExecuteFilterTasks", _aryPendingFilterElements.Size()));
            }
#endif
        }
    }

    TraceTag((tagFilter, "-ExecuteFilterTasks"));
    return (_aryPendingFilterElements.Size() == 0);
}

void
CDoc::PostFilterCallback()
{
    if (!_fPendingFilterCallback)
    {
        TraceTag((tagFilter, "PostFilterCallback"));
        _fPendingFilterCallback = SUCCEEDED(GWPostMethodCall(this,ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0, FALSE, "CDoc::FilterCallback"));
        Assert(_fPendingFilterCallback);
    }
}

void
CDoc::FilterCallback(DWORD_PTR)
{
    Assert(_fPendingFilterCallback);
    if (_fPendingFilterCallback)
    {
        TraceTag((tagFilter, "FilterCallback"));
        _fPendingFilterCallback = FALSE;
        ExecuteFilterTasks();
    }
}


//+---------------------------------------------------------------
//
// Helper Function: DocIsDeskTopItem
//
// Test if Trident is a desktop iframe. There is a agreement during
// IE4 stage that desktop iframe will have CDoc::_pDocParent to be
// NULL, this prevents Trident from making CBodyElement in desktop
// iframe a tab stop. Need to way to separate this situation.
//
//----------------------------------------------------------------
BOOL
DocIsDeskTopItem(CDoc * pDoc)
{
    BOOL    fResult = FALSE;
    HRESULT hr;

    IServiceProvider * pSP1 = NULL;
    IServiceProvider * pSP2 = NULL;

    if (!pDoc->_pClientSite)
        goto Cleanup;

    hr = pDoc->_pClientSite->QueryInterface(
            IID_IServiceProvider,
            (void **) &pSP1);

    if (!hr && pSP1)
    {
        hr = pSP1->QueryService(
                SID_STopLevelBrowser,
                IID_IServiceProvider,
                (void **) &pSP2);
        if (!hr && pSP2)
        {
            ITargetFrame2 * pTF2 = NULL;

            hr = pSP2->QueryService(
                    IID_ITargetFrame2,
                    IID_ITargetFrame2,
                    (void **) &pTF2);
            if (!hr && pTF2)
            {
                DWORD dwOptions;

                hr = pTF2->GetFrameOptions(&dwOptions);
                if (!hr && (dwOptions & FRAMEOPTIONS_DESKTOP))
                {
                    fResult = TRUE;
                }
                pTF2->Release();
            }
            pSP2->Release();
        }
        pSP1->Release();
    }

Cleanup:
    return fResult;
}

HRESULT 
CDocument::createRenderStyle(BSTR v, IHTMLRenderStyle** ppIHTMLRenderStyle)
{
    HRESULT hr;
    CRenderStyle *pRenderStyle;
    
    pRenderStyle = new CRenderStyle( Doc() );
    if (!pRenderStyle)
    {
        hr = E_OUTOFMEMORY;
        *ppIHTMLRenderStyle = NULL;
        goto Error;
    }
    
    hr = THR(pRenderStyle->QueryInterface(IID_IHTMLRenderStyle, (void **)ppIHTMLRenderStyle));

Error:
   
    if(pRenderStyle)
        pRenderStyle->PrivateRelease();

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsAboutHomeOrNonAboutURL
//
//  Synopsis : Returns TRUE if the URL is about:home or a non about: URL.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsAboutHomeOrNonAboutUrl(LPCTSTR lpszUrl)
{
    BOOL fIsAboutHomeOrNonAboutURL = TRUE;

    Assert(lpszUrl);
    
    // Is it "about:home"?
    //
    if (0 != StrCmpNIC(ABOUT_HOME, lpszUrl, ARRAY_SIZE(ABOUT_HOME) - 1))
    {
        // We also want to return TRUE if the
        // scheme was NOT an about: URL.
        //
        fIsAboutHomeOrNonAboutURL = (URL_SCHEME_ABOUT != GetUrlScheme(lpszUrl));
    }

    return fIsAboutHomeOrNonAboutURL;            
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsSameUrl
//
//  Synopsis : Determines if the url of the old markup is the same as the 
//             url of the new markup.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsSameUrl(CMarkup * pMarkupOld, CMarkup * pMarkupNew)
{
    Assert(pMarkupOld);
    Assert(pMarkupNew);
    
    return IsSameUrl(CMarkup::GetUrl(pMarkupOld),
                     CMarkup::GetUrlLocation(pMarkupOld),
                     CMarkup::GetUrl(pMarkupNew),
                     CMarkup::GetUrlLocation(pMarkupNew),
                     (pMarkupNew->GetDwnPost() != NULL));
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsSameUrl
//
//  Synopsis : Determines if the url of the old markup is the same as the 
//             url of the new markup.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsSameUrl(LPCTSTR lpszOldUrl,
                LPCTSTR lpszOldLocation,
                LPCTSTR lpszNewUrl,
                LPCTSTR lpszNewLocation,
                BOOL    fIsPost)
{
    HRESULT hr;
    BOOL    fIsSameUrl = FALSE;
    TCHAR   szOldUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR   szNewUrl[INTERNET_MAX_URL_LENGTH];

    if (fIsPost)
    {
        goto Cleanup;
    }

    hr = FormatUrl(lpszOldUrl,
                   lpszOldLocation,
                   szOldUrl,
                   ARRAY_SIZE(szOldUrl));
    if (hr)
        goto Cleanup;

    hr = FormatUrl(lpszNewUrl,
                   lpszNewLocation,
                   szNewUrl,
                   ARRAY_SIZE(szNewUrl));
    if (hr)
        goto Cleanup;

    Assert(szNewUrl);
    Assert(szOldUrl);

    fIsSameUrl = !StrCmpI(szNewUrl, szOldUrl);

Cleanup:
    return fIsSameUrl;
}       

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateTravelLog
//
//  Synopsis : Updates the travel log, adds a new entry, and updates
//             the state of the back and forward buttons.
//
//----------------------------------------------------------------------------

void
CDoc::UpdateTravelLog(CWindow * pWindow,
                      BOOL      fIsLocalAnchor,
                      BOOL      fAddEntry,            /* = TRUE */
                      BOOL      fDontUpdateIfSameUrl, /* = TRUE */
                      CMarkup * pMarkupNew,           /* = NULL */
                      BOOL      fForceUpdate          /* = FALSE */)
{
    Assert(pWindow);

    //
    // don't add to tlog - if we were called from location.replace.
    //

    if (!_pTravelLog || ( pMarkupNew && pMarkupNew->_fReplaceUrl ) )
    {
        goto Cleanup;
    }
    
    //
    // don't update travel log for error pages we said not to update for.
    //
    if ( pWindow->_fHttpErrorPage && _fDontUpdateTravelLog )
    {
        goto Cleanup;
    }
    
    if ( !pWindow->_fHttpErrorPage
         && (  _fDontUpdateTravelLog
             || ((_fShdocvwNavigate || (_fDefView && !_fActiveDesktop)) && pWindow->IsPrimaryWindow())))
    {
        goto Cleanup;
    }

    if (   fDontUpdateIfSameUrl
        && pMarkupNew
        && !pMarkupNew->_fLoadingHistory
        && ( IsSameUrl(pWindow->_pMarkup, pMarkupNew) || pMarkupNew->_fInRefresh ) )
    {
        goto Cleanup;
    }

    LPCTSTR pchUrl = CMarkup::GetUrl(pWindow->_pMarkup);
    if (IsAboutHomeOrNonAboutUrl(pchUrl))
    {
        // Security QFE, don't want script urls running in history context
        if (IsSpecialUrl(pchUrl)) 
            goto Cleanup;

        // If the window's markup is the primary markup, we 
        // delegate the updating of the travel log to the
        // client site. Otherwise, if the window is a frame,
        // we update the travel log ourselves.
        //
        if (pWindow->Markup()->IsPrimaryMarkup())
        {
            TraceTag((tagCDoc, "TRAVELLOG: delegating to shdocvw for %ls", CMarkup::GetUrl(pWindow->_pMarkup)));

            CVariant cvar(VT_I4);
            long lVal = 0;

            if (fIsLocalAnchor)
                lVal |= TRAVELLOG_LOCALANCHOR;

            if (fForceUpdate)
                lVal |= TRAVELLOG_FORCEUPDATE;

            V_I4(&cvar) = lVal;

            Assert(_pClientSite);
            CTExec(_pClientSite, &CGID_Explorer, SBCMDID_UPDATETRAVELLOG, 0, &cvar, NULL);
        }
        else
        {
            TraceTag((tagCDoc, "TRAVELLOG: updating for frame (%ls). fAddEntry: %ls", 
                      CMarkup::GetUrl(pWindow->_pMarkup), fAddEntry ? _T("True") : _T("False")));

            IUnknown * pUnk = DYNCAST(IHTMLWindow2, pWindow);

            UpdateTravelEntry(pUnk, fIsLocalAnchor);

            if (fAddEntry)
                AddTravelEntry(pUnk, fIsLocalAnchor);

        }

        UpdateBackForwardState();
    }

Cleanup:
    _fDontUpdateTravelLog = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateTravelEntry
//
//  Synopsis : Updates the current entry in the travel log.
//
//----------------------------------------------------------------------------

void
CDoc::UpdateTravelEntry(IUnknown * punk, BOOL fIsLocalAnchor)
{
    Assert(punk);

    if (_pTravelLog && LoadStatus() != LOADSTATUS_UNINITIALIZED)
    {
        _pTravelLog->UpdateEntry(punk, fIsLocalAnchor);
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::AddTravelEntry
//
//  Synopsis : Adds an entry to the travel log.
//
//----------------------------------------------------------------------------

void
CDoc::AddTravelEntry(IUnknown * punk, BOOL fIsLocalAnchor) const
{
    Assert(punk);

    if (_pTravelLog)
    {
        _pTravelLog->AddEntry(punk, fIsLocalAnchor);
    }
}        

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::Travel
//
//  Synopsis : Navigates to an offset within the travel log
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::Travel(int iOffset) const
{
    HRESULT hr = S_OK;
    IBrowserService * pBrowserSvc = NULL;

    // If we are viewlinked in a WebOC, we must pass
    // the IBrowserService of the top frame browser 
    // to ITravelLog::Travel. Otherwise, in the case
    // of choosing back/forward from the context menu,
    // we won't go anywhere.
    //
    if (_pTravelLog && _pBrowserSvc)
    {
        if (_fViewLinkedInWebOC)
        {
            hr = IUnknown_QueryService(_pBrowserSvc, SID_STopFrameBrowser,
                                       IID_IBrowserService, (void**)&pBrowserSvc);
            if (hr)
                goto Cleanup;
        }
        else 
        {
            pBrowserSvc = _pBrowserSvc;
            pBrowserSvc->AddRef();
        }

        Assert(pBrowserSvc);

        hr = THR(_pTravelLog->Travel(pBrowserSvc, iOffset));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pBrowserSvc);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::Travel
//
//  Synopsis : Navigates to the specified URL in the travel log.
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::Travel(CODEPAGE uiCP, LPOLESTR pszUrl) const
{
    ITravelLogEx * pTravelLogEx;
    HRESULT        hr = S_OK;

    if (_pTravelLog && _pBrowserSvc)
    {
        hr = _pTravelLog->QueryInterface(IID_ITravelLogEx, (void**)&pTravelLogEx);

        if (!hr)
        {
            hr = pTravelLogEx->TravelToUrl(_pBrowserSvc, uiCP, pszUrl);
            pTravelLogEx->Release();
        }
    }

    return hr;
}        

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::NumTravelEntries
//
//  Synopsis : Returns the number of entries in the travel log.
//
//----------------------------------------------------------------------------

DWORD 
CDoc::NumTravelEntries() const
{
    DWORD dwNumEntries = 0;

    if (_pTravelLog && _pBrowserSvc)
    {
        dwNumEntries = _pTravelLog->CountEntries(_pBrowserSvc);
    }

    return dwNumEntries;
}


//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateBackForwardState
//
//  Synopsis : Updates the state of the back/forward buttons, ctx menu, etc.
//
//----------------------------------------------------------------------------

void 
CDoc::UpdateBackForwardState() const
{
    if (_pBrowserSvc)
    {
        _pBrowserSvc->UpdateBackForwardState();
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::EnsureFilterBehaviorFactory()
//
//  Synopsis : Creates the FilterBehaviorFactory if needed
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::EnsureFilterBehaviorFactory()
{
    HRESULT     hr = S_OK;
    
    if(!_pFilterBehaviorFactory)
    {
        // Create the factory
        hr = THR(CoCreateInstance( CLSID_DXTFilterFactory, NULL, CLSCTX_INPROC_SERVER,
                     IID_IElementBehaviorFactory, (void **)&_pFilterBehaviorFactory));
    }

    RRETURN(hr);
}


VOID
CDoc::InitEventParamForKeyEvent(
                                EVENTPARAM* pParam , 
                                CTreeNode * pNodeContext, 
                                CMessage *pMessage, 
                                int *piKeyCode, 
                                const PROPERTYDESC_BASIC **ppDesc )
{
    // $$ktam: is it meaningful to have a layout context in the message 
    // at this point?  it's often null.
    pParam->_pLayoutContext = pMessage->pLayoutContext;
    pParam->SetNodeAndCalcCoordinates(pNodeContext);
    pParam->_lKeyCode = (long)*piKeyCode;

    if (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
    {
        pParam->_fShiftLeft = (LOBYTE(HIWORD(pMessage->lParam)) == OEM_SCAN_SHIFTLEFT);
    }

    switch (pMessage->message)
    {
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        // the 30th bit of the lparam indicates whether this is a repeated WM_
        pParam->fRepeatCode = !!(HIWORD(pMessage->lParam) & KF_REPEAT);
        *ppDesc = &s_propdescCElementonkeydown;
        break;
    
    case WM_SYSKEYUP:
    case WM_KEYUP:
        *ppDesc = &s_propdescCElementonkeyup;
        break;

    case WM_CHAR:
        *ppDesc = &s_propdescCElementonkeypress;
        break;

    default:
        AssertSz(0, "Unknown Key stroke");
        return;
    }

    pParam->SetType((*ppDesc)->a.pstrName + 2);
    
}

#ifdef V4FRAMEWORK

MtDefine(CExternalFrameworkSite, Mem, "CExternalFrameworkSite")

void
CDoc::ReleaseFrameworkDoc()
{    
    if ( _pFrameworkDoc )
    {
        _pFrameworkDoc->SetSite(NULL);
        _pFrameworkDoc->Release();
        _pFrameworkDoc = NULL;
    }
}

HRESULT CExternalFrameworkSite::SetLongRenderProperty ( long lRef, long propertyType, long lValue )
{
    HRESULT hr=S_OK;
    CElement *pElement = (CElement *)lRef;
    CAttrArray **ppAry;
    DISPID dispID;
    VARIANT varNew;
    PROPERTYDESC *pDesc = NULL;


    varNew.vt = VT_I4;
    varNew.lVal = (long)lValue;

    // For now - going to get much smarter than this
    
    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
        goto Cleanup;

    switch ( propertyType )
    {
    case 0: // BackColor
        dispID = DISPID_BACKCOLOR;
        pDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundColor;
        break;

    case 1: // TextColor
        dispID = DISPID_A_COLOR;
        pDesc = (PROPERTYDESC *)&s_propdescCStylecolor;
        break;

    case 2: // Display (used to be 'rectangular' prop, now 'display:inline-block')
        dispID = DISPID_A_DISPLAY;
        pDesc = (PROPERTYDESC *)&s_enumdescstyleDisplay;
        break;

    case 3: // LayoutType 
        {
        CPeerHolder *pPH = pElement->GetPeerHolder();
        if ( pPH )
        {
            pPH->_pLayoutBag->_lLayoutInfo = lValue;
        }
        goto Cleanup;
        }
        break;

    case 4: // Positioning
        dispID = DISPID_A_POSITION;
        pDesc = (PROPERTYDESC *)&s_propdescCStyleposition;
        break;

    default:
        goto Cleanup;
    } 

    hr = THR(CAttrArray::Set ( ppAry, dispID, &varNew, NULL, CAttrValue::AA_StyleAttribute, 0 ) );
    if (hr)
        goto Cleanup;

    if (pDesc)
        hr = THR(pElement->OnPropertyChange(dispID, pDesc->GetdwFlags()));

Cleanup:
    return hr;
}

HRESULT CExternalFrameworkSite::SetStringRenderProperty ( long lRef, long propertyType, BSTR bstrValue )
{
    HRESULT hr=S_OK;
 
    CElement *pElement = (CElement *)lRef;

    return hr;
}

HRESULT CExternalFrameworkSite::ReleaseElement ( long lRef )
{
    CElement *pElement = (CElement *)lRef;
    CDoc *pDoc = pElement->Doc();

    // Remove our own artificial AddRef() - element should now go away
    pElement->Release();

    Assert(lExternalElems>0);

    if (--lExternalElems == 0 )
    {
        pDoc->ReleaseFrameworkDoc();
    }
    return S_OK;
}

HRESULT CExternalFrameworkSite::AddTagsHelper(long lNamespaceCookie, LPTSTR pchTags, BOOL fLiteral)
{
    IElementNamespace *pNamespace = (IElementNamespace *)lNamespaceCookie;
    TCHAR *pchTag;
    TCHAR chOld;
    HRESULT hr = S_OK;

    while(pchTags && *pchTags)
    {
        pchTag = pchTags;
        while(*pchTags && *pchTags != _T(','))
            pchTags++;
        chOld = *pchTags;
        *pchTags = _T('\0');
        hr = THR(pNamespace->AddTag(pchTag, fLiteral ? ELEMENTDESCRIPTORFLAGS_LITERAL : 0));
        *pchTags = chOld;
        if (chOld)
            pchTags++;
    }

    RRETURN(hr);
}

HRESULT CExternalFrameworkSite::AddLiteralTags(long lNamespaceCookie, BSTR bstrLiteralTags)
{
    RRETURN(AddTagsHelper(lNamespaceCookie, bstrLiteralTags, TRUE));
}

IExternalDocument *CDoc::EnsureExternalFrameWork()
{
    HRESULT hr = S_OK;
    CLSID clsid;
    IExternalDocumentSite *pSite = NULL;

    if (_pFrameworkDoc || GetObjectRefs() == 0)
    {
        goto Cleanup;
    }
    
    // For now it's called CElement - need to change the COM+ Code <g>
    hr = THR(CLSIDFromProgID( TEXT("System.UI.Html.Impl.DocThunk"), &clsid));
    if ( hr )
        goto Cleanup;

    hr = CoCreateInstance(clsid, NULL,
                          CLSCTX_INPROC_SERVER, IID_IExternalDocument,
                          (void **)&_pFrameworkDoc);
    if (hr)
        goto Cleanup;

    hr = _extfrmwrkSite.QueryInterface (IID_IExternalDocumentSite, (void**)&pSite);
    if (hr)
        goto Cleanup;

    hr = _pFrameworkDoc->SetSite ( pSite );
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSite);
    return _pFrameworkDoc;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CExternalFrameworkSite::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IUnknown *)this, IUnknown)
        QI_INHERITS2(this, IDispatch, IExternalDocumentSite)
    default:
        if ( iid == IID_IExternalDocumentSite )
        {
            *ppv = (IExternalDocumentSite *)this;  
        }
        break;
    }

    if (*ppv)
        ((IUnknown *)*ppv)->AddRef();
    else if (!hr)
        hr = E_NOINTERFACE;

    DbgTrackItf(iid, "CExternalFrameworkSite", FALSE, ppv);

    return hr;
}
#endif V4FRAMEWORK



#ifdef V4FRAMEWORK
// Expanded the SUBOBJECT Macro so I can debug the calls properly
CDoc * CExternalFrameworkSite::Doc()                           
{                                                               
    return CONTAINING_RECORD(this, CDoc, _extfrmwrkSite);         
}                                                               
inline BOOL CExternalFrameworkSite::IsMyParentAlive(void)                          
    { return Doc()->GetObjectRefs() != 0; }              
STDMETHODIMP_(ULONG) CExternalFrameworkSite::AddRef( )                             
    { return Doc()->SubAddRef(); }                       
STDMETHODIMP_(ULONG) CExternalFrameworkSite::Release( )                            
    { return Doc()->SubRelease(); }
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT
CExternalFrameworkSite::SetElementPosition (DISPID dispID,
                 long lValue, CAttrArray **ppAttrArray,
                 BOOL * pfChanged)
{
    CUnitValue          uvValue;
    HRESULT             hr = S_OK;
    long                lRawValue;

    Assert(pfChanged);
    uvValue.SetNull();

    Assert(ppAttrArray);
    
    if (*ppAttrArray)
    {
        (*ppAttrArray)->GetSimpleAt(
            (*ppAttrArray)->FindAAIndex(dispID, CAttrValue::AA_Attribute),
            (DWORD*)&uvValue );
    }

    lRawValue = uvValue.GetRawValue(); // To see if we've changed

    uvValue.SetValue(lValue, CUnitValue::UNIT_PIXELS );
    
    if ( uvValue.GetRawValue() == lRawValue ) // Has anything changed ??
        goto Cleanup;

    hr = THR(CAttrArray::AddSimple ( ppAttrArray, dispID, uvValue.GetRawValue(),
                                     CAttrValue::AA_StyleAttribute ));

    if (hr)
        goto Cleanup;

    *pfChanged = TRUE;

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::PositionElement(long lRefElement, long nTop, long nLeft, long nWidth, long nHeight)
{
    /* Call this code if I want to keey the legacy OM in sync ???
    CAttrArray **ppAry;
    BOOL fChanged = FALSE;
    CElement *pElement = (CElement *)lRefElement;
    HRESULT hr = S_OK;

    Assert(pElement->Tag()==ETAG_GENERIC);

    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(SetElementPosition(STDPROPID_XOBJ_TOP, nTop, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_LEFT, nLeft, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_WIDTH, nWidth, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_HEIGHT, nHeight, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;
    */
    CElement *pElement = (CElement *)lRefElement;
    HRESULT hr = S_OK;
    CLayout   * pLayout;

    pLayout = pElement->GetUpdatedLayout();
    if ( !pLayout )
        goto Cleanup;

    {

        CFlowLayout *pFlowLayout = DYNCAST(CFlowLayout, pElement->GetUpdatedParentLayout());
        Assert( pFlowLayout );

        CCalcInfo CI(pLayout);

        pLayout->EnsureDispNode(&CI, TRUE /*??*/);

        pFlowLayout->AddLayoutDispNode( &CI, pLayout->ElementOwner()->GetFirstBranch(), nTop, nLeft, NULL );

        //pLayout->SetPosition(nTop, nLeft);
        pLayout->SizeDispNode(&CI, nWidth, nHeight, TRUE /*??*/ );
    }

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::ParentElement(long lRefElement, long *lParentRef)
{
    HRESULT hr = S_OK;
    CGenericElement::COMPLUSREF cpRef;

    CElement *pElem = (CElement *)lRefElement;
    CTreeNode *pNode;

    Assert(pElem);
    Assert(pElem->Tag()==ETAG_GENERIC);

    if (!lParentRef)
    {
        hr=E_POINTER;
        goto Cleanup;
    }
    *lParentRef=0;

    pNode = pElem->GetFirstBranch(); // Ignore overlapping for now

    Assert( !pNode || !pNode->IsDead() );

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    pNode = pNode->Parent();

    // TODO need to sort out the last condition here - what to do with HTML tags!!
    if (!pNode || pNode->Tag() == ETAG_ROOT || pNode->Tag() != ETAG_GENERIC)
        goto Cleanup;

    pElem = pNode->Element();

    hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    *lParentRef = (long)cpRef; // again ignore overlapping

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::MoveElement(long lRefElement, long nTop, long nLeft)
{
    CAttrArray **ppAry;
    BOOL fChanged = FALSE;
    HRESULT hr = S_OK;

    CElement *pElement = (CElement *)lRefElement;

    Assert(pElement->Tag()==ETAG_GENERIC);

    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(SetElementPosition(STDPROPID_XOBJ_TOP, nTop, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_LEFT, nLeft, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    if ( fChanged )
    {
        pElement->RemeasureElement( NFLAGS_FORCE );
    }

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::SizeElement(long lRefElement, long Width, long Height)
{
    return S_OK;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::ZOrderElement(long lRefElement, long ZOrder)
{
    return S_OK;
}
#endif V4FRAMEWORK


HRESULT
CDocument::get_media(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    if (!pbstr)
        RRETURN (E_POINTER);

    Assert(Markup());
    hr = STRINGFROMENUM( mediaType, Markup()->GetMedia(), pbstr );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

HRESULT
CDocument::put_media(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert(Markup());
    if (!Markup()->IsPrintTemplate())
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }
    
    hr = putMediaHelper(bstr);

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

HRESULT
CDocument::putMediaHelper(BSTR bstr)
{
    HRESULT hr = S_OK;
    mediaType type;

    hr = ENUMFROMSTRING( mediaType, bstr, (long *) & type);
    if (hr)
        goto Cleanup;

    Assert(Markup());
    Markup()->SetMedia(type);

    // TODO (KTam): It doesn't look like format cache clearing works via
    // CDocument::OnPropertyChange (only formats on the root element get cleared;

    // we don't go through ClearRunCaches or anything like it).  That's OK since
    // CMarkup::SetMedia now does an EnsureFormatsCacheChange (like CElement::OnPropertyChange),
    IGNORE_HR(OnPropertyChange(DISPID_CDocument_media, 
                               ELEMCHNG_CLEARCACHES|FORMCHNG_LAYOUT, 
                               (PROPERTYDESC *)&s_propdescCDocumentmedia));
    
Cleanup:
    return hr;
}

#if DBG
void
CDocExtra::DumpLayoutRects( BOOL fDumpLines /*=TRUE*/ )
{
    CTreeNode *pNodeIter = NULL;
    CTreeNode *pInnerNodeIter = NULL;
    CElement *pElementIter = NULL;
    CElement *pInnerElementIter = NULL;
    CLayoutInfo *pLayoutIter = NULL;
    CLayoutInfo *pInnerLayoutIter = NULL;
    CElement *pElementSlave = NULL;
    CMarkup *pPrimaryMarkup = ((CDoc*)(this))->PrimaryMarkup();
    CChildIterator outerIter( pPrimaryMarkup->Root(), NULL, CHILDITERATOR_DEEP );

    // TODO: Reorganize output.  One idea: dump all layout rects first
    // so we have defining context information for them all.  Then dump
    // layouts of slave markups.  Do this by pushing slave markups onto
    // a stack as we walk.  Also handle device rects (and whatever else
    // defines context).

    if (!InitDumpFile())
        return;

    WriteString( g_f,
        _T("\r\n------------- LAYOUT RECTS -------------------------------\r\n" ));

    while ( (pNodeIter = outerIter.NextChild()) != NULL )
    {
        pElementIter = pNodeIter->Element();
        if ( pElementIter->IsLinkedContentElement() )
        {
            Assert( pElementIter->CurrentlyHasAnyLayout() );
            pLayoutIter = pElementIter->GetLayoutInfo();
            Assert( pLayoutIter );

            WriteHelp(g_f, _T("<0s>: 0x<1x> ID=<2s>\r\n"), pElementIter->TagName(), pElementIter, pElementIter->GetAAid());

            pLayoutIter->DumpLayoutInfo( fDumpLines );

            pElementSlave = pElementIter->GetSlaveIfMaster();

            // GetSlaveIfMaster() returns "this" if no slave
            if ( pElementSlave != pElementIter )
            {
                // ..we have a slave
                Assert( pElementIter->HasSlavePtr() );
                CChildIterator innerIter( pElementSlave, NULL, CHILDITERATOR_DEEP );
                while ( (pInnerNodeIter = innerIter.NextChild()) != NULL )
                {
                    pInnerElementIter = pInnerNodeIter->Element();
                    if ( pInnerElementIter->CurrentlyHasAnyLayout() )
                    {
                        WriteHelp(g_f, _T("<0s>: 0x<1x>\r\n"), pInnerElementIter->TagName(), pInnerElementIter);
                        pInnerLayoutIter = pInnerElementIter->GetLayoutInfo();
                        Assert( pInnerLayoutIter );
                        pInnerLayoutIter->DumpLayoutInfo( fDumpLines );
                    }
                }
            }
            else
            {
                WriteString(g_f, _T(" -- no slave on this layout rect --\r\n"));
            }
        }
    }

    WriteString( g_f,
        _T("\r\n--- END LAYOUT RECTS -------------------------------\r\n" ));

    CloseDumpFile();
}
#endif


BOOL
CDoc::DesignMode()
{ 
    CMarkup * pMarkup = PrimaryMarkup();
    return pMarkup ? pMarkup->_fDesignMode : FALSE; 
}


//+====================================================================================
//
// Method: SetEditBitsForMarkup
//
// Synopsis: Set the default values of editing bits - based on what was in the registry
//
//------------------------------------------------------------------------------------


VOID
CDoc::SetEditBitsForMarkup( CMarkup* pMarkup )
{
    if ( _fShowAlignedSiteTags ||
         _fShowCommentTags ||
         _fShowStyleTags ||
         _fShowAreaTags ||
         _fShowUnknownTags ||
         _fShowMiscTags ||
         _fShowWbrTags )
    {
        pMarkup->GetGlyphTable()->_fShowAlignedSiteTags = _fShowAlignedSiteTags;
        pMarkup->GetGlyphTable()->_fShowCommentTags = _fShowCommentTags;
        pMarkup->GetGlyphTable()->_fShowStyleTags = _fShowStyleTags;
        pMarkup->GetGlyphTable()->_fShowAreaTags = _fShowAreaTags;
        pMarkup->GetGlyphTable()->_fShowUnknownTags = _fShowUnknownTags;
        pMarkup->GetGlyphTable()->_fShowMiscTags = _fShowMiscTags;
        pMarkup->GetGlyphTable()->_fShowWbrTags = _fShowWbrTags;
    }

    if ( _fShowZeroBorderAtDesignTime )
    {
        SET_EDIT_BIT( pMarkup,_fShowZeroBorderAtDesignTime , _fShowZeroBorderAtDesignTime);
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ResetProgressData
//
//  Synopsis:   Resets the progress bar data.
//
//---------------------------------------------------------------

void
CDoc::ResetProgressData()
{
    _ulProgressPos  = 0;
    _ulProgressMax  = 0;
    _fShownProgPos  = FALSE;
    _fShownProgMax  = FALSE;
    _fShownProgText = FALSE;
    _fProgressFlash = FALSE;
}

COmWindowProxy *
CDoc::GetOuterWindow()
{
    COleSite * pOleSite;
    
    Assert(_fViewLinkedInWebOC);

    if (S_OK == IUnknown_QueryService(_pClientSite, CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void **) &pOleSite))
        return pOleSite->GetWindowedMarkupContext()->GetWindowPending();

    return NULL;
}

//
//  Called by shdocvw to transfer it's privacy info to Trident's list
//
HRESULT
CDoc::AddPrivacyInfoToList( LPOLESTR  pUrl, 
                            LPOLESTR  pPolicyRefURL, 
                            LPOLESTR  pP3PHeader,
                            LONG      dwReserved,
                            DWORD     privacyFlags)
{
    HRESULT           hr              = S_OK;
    TCHAR           * pLocalP3PHeader = NULL;
    unsigned long     ulLen           = 0;
    CMarkup         * pMarkup         = NULL;

    hr = AddToPrivacyList(pUrl, pPolicyRefURL, privacyFlags);

    if (pUrl && *pUrl)
    {
        if (pP3PHeader)
        {
            ulLen = _tcslen(pP3PHeader);
            pLocalP3PHeader = new TCHAR[ulLen + 1];
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _tcscpy(pLocalP3PHeader, pP3PHeader);
        }
        
        pMarkup = PendingPrimaryMarkup();
        if (!pMarkup)
            pMarkup = PrimaryMarkup();
        if (pMarkup && pLocalP3PHeader)
            hr = pMarkup->SetPrivacyInfo(&pLocalP3PHeader);
    }
    
Cleanup:
    if (FAILED(hr))
        delete [] pLocalP3PHeader;

    RRETURN(hr);
}

HRESULT
CDoc::AddToPrivacyList(const TCHAR * pchUrl, const TCHAR * pchPolicyRef /* =NULL */, DWORD dwFlags /* =0 */, BOOL fPending /* =TRUE*/)
{

    TraceTag((tagPrivacyAddToList, "url %ls being added to privacy list with policyRef %ls, privacyFlags %x", pchUrl, pchPolicyRef, dwFlags));

    HRESULT       hr       = S_OK;

    if (!_pPrivacyList)
    {
        TraceTag((tagPrivacyAddToList, "No privacy list on the doc, cannot add"));
        goto Cleanup;
    }

    if (_fBlockNonPending && !fPending)
    {
        TraceTag((tagPrivacyAddToList, "Blocked %ls from being added to privacy list", pchUrl));
        goto Cleanup;
    }

    BOOL oldState = _pPrivacyList->GetPrivacyImpacted();

    hr = THR(_pPrivacyList->AddNode(pchUrl, pchPolicyRef, dwFlags));
        
    if (SUCCEEDED(hr) && !oldState)
    {
        BOOL newState = _pPrivacyList->GetPrivacyImpacted();

        // Fire a change so we can show the impacted icon, clearing this icon is done in ResetPrivacyList
        if (newState  &&  _pTridentSvc)
        {
            GWPostMethodCallEx(_pts, (void*)this, ONCALL_METHOD(CDoc, OnPrivacyImpactedStateChange, onprivacyimpactedstatechange),
                               NULL, TRUE, "CDoc::OnPrivacyImpactedStateChange");
            TraceTag((tagPrivacyAddToList, "POSTED PrivacyImpactedStateChange call for state - %x", newState));
        }
    }

Cleanup:
    RRETURN(hr);
}

void
CDoc::OnPrivacyImpactedStateChange(DWORD_PTR pdwImpacted)
{
    // don't do anything if we are shutting down
    if (IsShut())
        return;

    ITridentService2 * pTridentSvc2 = NULL;
    HRESULT            hr = THR(_pTridentSvc->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2));

    if (hr == S_OK)
    {
        pTridentSvc2->FirePrivacyImpactedStateChange(_pPrivacyList->GetPrivacyImpacted());
    }
    else
    {
        TraceTag((tagPrivacyAddToList,"Failed to fire PrivacyStateChange event."));
    }

    ReleaseInterface(pTridentSvc2);
}

HRESULT
CDoc::ResetPrivacyList()
{
    TraceTag((tagPrivacyAddToList,"Privacy list was reset"));

    if (!_pPrivacyList)
    {
        RRETURN(S_OK);
    }
    
    BOOL oldState = _pPrivacyList->GetPrivacyImpacted();
    HRESULT hr = THR(_pPrivacyList->ClearNodes());

    //This is guaranteed to be called on the UI thread, so fire the change here directly
    if (SUCCEEDED(hr) && oldState && _pTridentSvc)
        OnPrivacyImpactedStateChange(0);

    _fBlockNonPending = TRUE;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\fpropdlg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       fpropdlg.cxx
//
//  Contents:   Display property dialog.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifdef NEVER

        #ifndef X_ELEMENT_HXX_
        #define X_ELEMENT_HXX_
        #include "element.hxx"
        #endif

        #ifndef X_COMMCTRL_H_
        #define X_COMMCTRL_H_
        #include "commctrl.h"
        #endif

        #ifndef X_MSHTMLRC_H_
        #define X_MSHTMLRC_H_
        #include "mshtmlrc.h"
        #endif

        #ifndef X_SITEGUID_H_
        #define X_SITEGUID_H_
        #include "siteguid.h"
        #endif

        #ifndef X_CGUID_H_
        #define X_CGUID_H_
        #include <cguid.h>
        #endif

        #ifdef UNIX
        #include <mainwin.h>
        #endif

        #ifndef NO_HTML_DIALOG
        class CPropertyDialog;

        MtDefine(CPropertyPageSite, Dialogs, "CPropertyPageSite")
        MtDefine(ShowPropertyDialog, Dialogs, "ShowPropertyDialog (temp array)")
        MtDefine(CPropertyDialog, Dialogs, "CPropertyDialog")
        MtDefine(CPropertyDialog_arySite_pv, Dialogs, "CPropertyDialog::_arySite::_pv")

        //+---------------------------------------------------------------------------
        //
        //  Class:      CPropertyPageSite
        //
        //  Synopsis:   Manage single page in property dialog.
        //
        //----------------------------------------------------------------------------

        class CPropertyPageSite :
            public IPropertyPageSite,
            public IServiceProvider
        {
        public:

            DECLARE_MEMCLEAR_NEW_DELETE(Mt(CPropertyPageSite))

            CPropertyPageSite()
                { _ulRefs = 1; }

            ~CPropertyPageSite()
                { Close(); }

            DECLARE_FORMS_STANDARD_IUNKNOWN(CPropertyPageSite)

            void    Close();
            HRESULT Show();
            void    Hide();
            HRESULT Init(CPropertyDialog *pFrame, int iLevel, CLSID *pclsid);

            // IPropertyPageSite methods

            STDMETHOD(OnStatusChange)   (DWORD dw);
            STDMETHOD(GetLocaleID)      (LCID * pLocaleID);
            STDMETHOD(GetPageContainer) (LPUNKNOWN * ppUnk);
            STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

            // IServiceProvider methods

            STDMETHOD(QueryService)(REFGUID, REFIID, void **);

            // Data members

            CPropertyDialog *   _pDialog;
            CLSID               _clsid;
            IPropertyPage *     _pPage;
            PROPPAGEINFO        _ppi;
            BOOL                _fActive;
            int                 _iLevel;
        };


        //+---------------------------------------------------------------------------
        //
        //  Class:      CPropertyDialog
        //
        //  Synopsis:   Run the property dialog.
        //
        //----------------------------------------------------------------------------

        class CPropertyDialog
        {
        public:

            DECLARE_MEMALLOC_NEW_DELETE(Mt(CPropertyDialog))
            // Construct / destruct

            ~CPropertyDialog()
                { Close(); }

            // Helper functions

            HRESULT         GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca);
            void            SetPage(int i, BOOL fSetTab = TRUE);
            void            UpdateApplyButton();
            HRESULT         CreatePageSites(int iLevel, int cUnk, IUnknown **apUnk);
            void            UpdateTabs(int iLevel);
            BOOL            Apply();
            void            Close();
            HRESULT         PreTranslateMessage(LPMSG);
            HRESULT         TranslateTabCtrlAccelerators(LPMSG);

            // Dialog procedure

            static BOOL CALLBACK DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
            BOOL OnInitDialog(HWND);
            void OnNotify(int idiCtrl, LPNMHDR lpnmhdr);
            void OnCommand(WORD wNotifyCode, WORD idi, HWND hwnd);

            HWND                _hwndDialog;    // dialog window
            HWND                _hwndTabs;      // tab control window
            HWND                _hwndCombo;     // combo box window
            HWND                _hwndTopParent; // top level parent window to be reenabled before close
            RECT                _rcPage;
            int                 _iPage;
            LCID                _lcid;

            BOOL                _fApplyWasHit;

            IUnknown **         _apUnk;
            int                 _cUnk;
            IUnknown *          _apUnkLevel[32];
            int                 _cUnkLevel;

            IServiceProvider *  _pServiceProvider;
            int                 _aiPageLevel[32];
            HRESULT             _hr;
            BOOL                _fMessageTranslated;
            IUnknown *          _punkBrowseDefault; // Not NULL implies we're in browse
                                                    //  mode

            DECLARE_CPtrAry(CArySite, CPropertyPageSite *, Mt(Mem), Mt(CPropertyDialog_arySite_pv))
            CArySite            _arySite;

        };


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Init
        //
        //  Synopsis:   Initialize the page.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::Init(CPropertyDialog *pDialog, int iLevel, CLSID *pclsid)
        {
            HRESULT         hr;
            IClassFactory * pCF = NULL;

            _pDialog = pDialog;
            _iLevel = iLevel;

            //
            // First try getting a local class object.  If that fails, then
            // go out to OLE and the registry.
            //

            hr = THR_NOTRACE(LocalGetClassObject(
                    *pclsid,
                    IID_IClassFactory,
                    (void **)&pCF));
            if (!hr)
            {
                hr = THR(pCF->CreateInstance(
                        NULL,
                        IID_IPropertyPage,
                        (void **)&_pPage));
            }
            else
            {
                hr = THR(CoCreateInstance(
                        *pclsid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IPropertyPage,
                        (void **) &_pPage));
            }
            if (hr)
                goto Cleanup;

            hr = THR(_pPage->SetPageSite(this));
            if (hr)
                goto Cleanup;

            _ppi.cb = sizeof(PROPPAGEINFO);

            hr = THR(_pPage->GetPageInfo(&_ppi));
            if (hr)
                goto Cleanup;

        Cleanup:
            ReleaseInterface(pCF);
            RRETURN(hr);
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Close
        //
        //  Synopsis:   Release everything.  Called at frame exit.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyPageSite::Close()
        {
            if (_pPage)
            {
                if (_fActive)
                {
                    IGNORE_HR(_pPage->Deactivate());
                }
                IGNORE_HR(_pPage->SetPageSite(NULL));
            }

            CoTaskMemFree(_ppi.pszTitle);
            _ppi.pszTitle = NULL;

            CoTaskMemFree(_ppi.pszDocString);
            _ppi.pszDocString = NULL;

            CoTaskMemFree(_ppi.pszHelpFile);
            _ppi.pszHelpFile = NULL;

            //  TODO (laszlog) : Shouldn't we call SetObjects(0,NULL) here to ensure
            //                   robust refcounting?
            //                   See Help for IPropertyPage::SetObjects


            ClearInterface(&_pPage);

            _pDialog = NULL;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Show
        //
        //  Synopsis:   Activates a page, passing it the current set of objects
        //              and showing it.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::Show()
        {
            HRESULT hr = S_OK;

            if (!_fActive)
            {
                if (_iLevel == 0)
                {
                    hr = THR(_pPage->SetObjects(
                            _pDialog->_cUnk,
                            _pDialog->_apUnk));
                }
                else
                {
                    hr = THR(_pPage->SetObjects(
                            1,
                            &_pDialog->_apUnkLevel[_iLevel]));
                }

                if (hr)
                    goto Cleanup;
                hr = THR(_pPage->Activate(_pDialog->_hwndTabs, &_pDialog->_rcPage, FALSE));
                if (hr)
                    goto Cleanup;

                _fActive = TRUE;
            }

            hr = THR(_pPage->Show(SW_SHOWNA));
            if (hr)
                goto Cleanup;

        Cleanup:
            RRETURN(hr);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Hide
        //
        //  Synopsis:   Hide the page
        //
        //-------------------------------------------------------------------------

        void
        CPropertyPageSite::Hide()
        {
            IGNORE_HR(_pPage->Show(SW_HIDE));
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::QueryInterface, IUnknown
        //
        //  Synopsis:   Per IUnknown.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::QueryInterface(REFIID iid, void ** ppv)
        {
            if (iid == IID_IUnknown || iid == IID_IPropertyPageSite)
            {
                *ppv = (IPropertyPageSite *) this;
            }
            else if (iid == IID_IServiceProvider)
            {
                *ppv = (IServiceProvider *) this;
            }
            else
            {
                *ppv = 0;
                RRETURN(E_NOINTERFACE);
            }

            (*(IUnknown **)ppv)->AddRef();
            return S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::OnStatusChange, IPropertyPageSite
        //
        //  Synopsis:   Note that status changed.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::OnStatusChange(DWORD dw)
        {
            if (!_pDialog || !_pPage)
                RRETURN(E_UNEXPECTED);

            if (dw & PROPPAGESTATUS_DIRTY)
            {
                _pDialog->UpdateApplyButton();
            }
            return S_OK;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::GetLocaleID
        //
        //  Synopsis:   Returns the current locale ID.
        //
        //-------------------------------------------------------------------------

        STDMETHODIMP
        CPropertyPageSite::GetLocaleID(LCID * plcid)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            *plcid = _pDialog->_lcid;
            return S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::GetPageContainer, IPropertyPageSite
        //
        //  Synopsis:   Per IPropertyPageSite, not supported.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::GetPageContainer(IUnknown ** ppUnk)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            *ppUnk = NULL;
            return E_NOTIMPL;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::TranslateAccelerator, IPropertyPageSite
        //
        //  Synopsis:   Handle accelerator.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::TranslateAccelerator(LPMSG pmsg)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            _pDialog->_fMessageTranslated = TRUE;
            return IsDialogMessage(_pDialog->_hwndDialog, pmsg) ? S_OK : S_FALSE;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::QueryService, IServiceProvider
        //
        //  Synopsis:   Per IServiceProvider.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::QueryService(REFGUID guid, REFIID iid, void **ppv)
        {
            HRESULT hr;

            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            if (_pDialog->_pServiceProvider)
            {
                hr = THR(_pDialog->_pServiceProvider->QueryService(guid, iid, ppv));
            }
            else
            {
                hr = E_FAIL;
            }

            RRETURN(hr);
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::Close
        //
        //  Synopsis:   Cleanup for shutdown.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::Close()
        {
            int i;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i])
                {
                    _arySite[i]->Close();
                    _arySite[i]->Release();
                    _arySite[i] = 0;
                }
            }
            _arySite.SetSize(0);

            while (_cUnkLevel--)
            {
                ClearInterface(&_apUnkLevel[_cUnkLevel]);
            }
            _cUnkLevel = 0;

            if ( _hwndTopParent )
            {
                ::EnableWindow(_hwndTopParent, TRUE);
            }

            if (_hwndDialog)
            {
                DestroyWindow(_hwndDialog);
                _hwndDialog = 0;
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::UpdateAppyButton
        //
        //  Synopsis:   Enable apply button based on page dirty.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::UpdateApplyButton()
        {
            int     i;
            BOOL    fEnable = FALSE;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (S_OK == _arySite[i]->_pPage->IsPageDirty())
                {
                    fEnable = TRUE;
                    break;
                }
            }

            EnableWindow(GetDlgItem(_hwndDialog, IDC_PROPFRM_APPLY), fEnable);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::UpdateTabs
        //
        //  Synopsis:   Set tabs to page titles.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::UpdateTabs(int iLevel)
        {
            int     i;
            TC_ITEM item;

            TabCtrl_DeleteAllItems(_hwndTabs);

            memset(&item, 0, sizeof(item));
            item.mask = TCIF_TEXT;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i]->_iLevel == iLevel)
                {
                    item.pszText = _arySite[i]->_ppi.pszTitle;
                    Verify(TabCtrl_InsertItem(_hwndTabs, i, &item) != -1);
                }
            }
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::Apply
        //
        //  Synopsis:   Applies changes to dirty pages.
        //
        //  Returns:    True if all ok.
        //
        //-------------------------------------------------------------------------

        BOOL
        CPropertyDialog::Apply()
        {
            int i;
            HRESULT hr = S_OK;
            IPropertyPage *pPage;

            for (i = 0; i < _arySite.Size(); i++)
            {
                pPage = _arySite[i]->_pPage;
                if (S_OK == pPage->IsPageDirty())
                {
                    hr = THR(pPage->Apply());
                    if (hr)
                    {
                        // TODO (garybu) Need to display error message.
                        SetPage(i);
                        break;
                    }
                }
            }

            UpdateApplyButton();

            return hr == S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::SetPage
        //
        //  Synopsis:   Changes the current page.
        //
        //  Arguments:  i Index of page to activate
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::SetPage(int iPage, BOOL fSetTab)
        {
            HRESULT hr = S_OK;
            int     iLevel;

            if (iPage == _iPage)
                return;

            if (_iPage >= 0)
            {
                _arySite[_iPage]->Hide();
                iLevel = _arySite[_iPage]->_iLevel;
            }
            else
            {
                iLevel = -1;
            }

            _iPage = iPage;

            if (_iPage >= 0)
            {
                if (_arySite[_iPage]->_iLevel != iLevel)
                {
                    iLevel = _arySite[_iPage]->_iLevel;
                    UpdateTabs(iLevel);
                    SendMessage(_hwndCombo, CB_SETCURSEL, iLevel, 0);
                }
                if (fSetTab)
                {
                    TabCtrl_SetCurSel(_hwndTabs, _iPage - _aiPageLevel[iLevel]);
                }
                IGNORE_HR(_arySite[_iPage]->Show());
            }
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::GetCommonPages
        //
        //  Synopsis:   Find common property pages for selected objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca)
        {
            HRESULT                hr;
            int                    i;
            UINT                   iScan, iFill, iCompare;
            BOOL                   fFirst = TRUE;
            CAUUID                 caCurrent;
            IUnknown *             pUnk;
            ISpecifyPropertyPages *pSPP;

            pca->cElems = 0;
            pca->pElems = NULL;

            //
            // If _punkBrowseDefault is set, then we show the properties on that
            // object only if no other objects in the list have any pages.
            //
            // Loop one more time than the number of elements to get pages on
            // _punkBrowseDefault if necessary.
            for (i = 0; i <= cUnk; i++)
            {
                if (i == cUnk && _punkBrowseDefault && pca->cElems == 0)
                {
                    // Force the default object's page(s) to be loaded because the
                    // other object(s) did not provide any.
                    pUnk = _punkBrowseDefault;
                    fFirst = TRUE;
                }
                else if (i < cUnk)
                {
                    pUnk = apUnk[i];
                }
                else
                {
                    break;
                }

                if (OK(THR(pUnk->QueryInterface(
                        IID_ISpecifyPropertyPages,
                        (void **)&pSPP))))
                {
                    hr = THR(pSPP->GetPages(fFirst ? pca : &caCurrent));
                    pSPP->Release();
                    if (hr)
                        continue;

                    if (fFirst)
                    {
                        fFirst = FALSE;
                    }
                    else
                    {
                        for (iScan = 0, iFill = 0; iScan < pca->cElems; iScan++)
                        {
                            for (iCompare = 0; iCompare < caCurrent.cElems; iCompare++)
                            {
                                if (caCurrent.pElems[iCompare] == pca->pElems[iScan])
                                    break;
                            }
                            if (iCompare != caCurrent.cElems)
                            {
                                pca->pElems[iFill++] = pca->pElems[iScan];
                            }
                        }
                        pca->cElems = iFill;

                        CoTaskMemFree(caCurrent.pElems);
                    }
                }
            }

            return S_OK;
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::CreatePageSites
        //
        //  Synopsis:   Create page sites for the specified objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::CreatePageSites(int iLevel, int cUnk, IUnknown **apUnk)
        {
            HRESULT hr;
            ULONG   i;
            CAUUID  ca      = { 0, 0 };
            CPropertyPageSite *pSite;

            _aiPageLevel[iLevel] = _arySite.Size();

            // Compute pages to load.

            hr = THR(GetCommonPages(cUnk, apUnk, &ca));
        #if DBG==1    
            if (hr)
            {
                   // put in a blank page in arySites()
                ca.cElems = 1;
                ca.pElems = (GUID *)&CLSID_CCDGenericPropertyPage;
            }
        #endif // DBG==1    

            // Create the sites.

            hr = THR(_arySite.EnsureSize(_arySite.Size() + ca.cElems));
            if (hr)
                goto Cleanup;

            for (i = 0; i < ca.cElems; i++)
            {
                pSite = new CPropertyPageSite();
                if (!pSite)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(pSite->Init(this, iLevel, &ca.pElems[i]));
                if (hr)
                {
                    // If we can't initalize the page, then ignore it.
                    pSite->Close();
                    pSite->Release();
                }
                else
                {
                    _arySite.Append(pSite);
                }

            }

        Cleanup:
            CoTaskMemFree(ca.pElems);
            RRETURN(hr);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::TranslateWndAccelerator
        //
        //  Synopsis:   Handle accelerators for the tab control.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::TranslateTabCtrlAccelerators(LPMSG pmsg)
        {
            HRESULT hr = S_FALSE;
            int iPage;
            int iLevel;
            int d;

            if ((pmsg->message == WM_KEYDOWN || pmsg->message == WM_SYSKEYDOWN) &&
                pmsg->wParam == VK_TAB &&
                (GetKeyState(VK_CONTROL) & 0x8000) &&
                (GetKeyState(VK_MENU) & 0x8000) == 0)
            {
                d = (GetKeyState(VK_SHIFT) & 0x8000) ? -1 : 1;

                iPage = _iPage + d;
                iLevel = _arySite[_iPage]->_iLevel;
                if (iPage >= _arySite.Size() ||
                    iPage < 0 ||
                    _arySite[iPage]->_iLevel != iLevel)
                {
                    if (d > 0)
                    {
                        for (iPage = 0;
                            _arySite[iPage]->_iLevel != iLevel;
                            iPage++)
                            ;
                    }
                    else
                    {
                        for (iPage = _arySite.Size() - 1;
                            _arySite[iPage]->_iLevel != iLevel;
                            iPage--)
                            ;
                    }
                }

                if (_iPage != iPage)
                {
                    SetPage(iPage);
                }

                hr = S_OK;
            }

            RRETURN1(hr, S_FALSE);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::PreTranslateMessage
        //
        //  Synopsis:   Handle accelerators
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::PreTranslateMessage(LPMSG pmsg)
        {
            HRESULT hr;
            HWND hwndFocus, hwndBeforePage, hwndAfterPage;

            if (pmsg->message < WM_KEYFIRST || pmsg->message > WM_KEYLAST)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            // CDK pages eat the keys we use for flipping pages.
            // Handle these keys first.

            hr = THR(TranslateTabCtrlAccelerators(pmsg));
            if (hr != S_FALSE)
                goto Cleanup;

            hwndFocus      = GetFocus();
            hwndBeforePage = _hwndTabs;
            hwndAfterPage  = _hwndCombo;

            if (GetParent(hwndFocus) != _hwndDialog ||
                    (hwndFocus == hwndBeforePage &&
                        pmsg->wParam == VK_TAB &&
                        pmsg->message == WM_KEYDOWN &&
                        (GetKeyState(VK_SHIFT) & 0x8000) == 0) ||
                    (hwndFocus == hwndAfterPage &&
                        pmsg->wParam == VK_TAB &&
                        pmsg->message == WM_KEYDOWN &&
                        (GetKeyState(VK_SHIFT) & 0x8000)))
            {
                // The focus is in the property page or we are about
                // to tab into the property page.  We let the property
                // page handle the accelerator first.

                _fMessageTranslated = FALSE;
            }
            else
            {
                // Focus is in our child. We get first crack at the message.

                hr = IsDialogMessage(_hwndDialog, pmsg) ? S_OK : S_FALSE;
                if (hr != S_FALSE)
                    goto Cleanup;

                _fMessageTranslated = TRUE;
            }

            // Give the property page a chance to handle the message.

            if (_iPage >= 0)
            {
                hr = THR(_arySite[_iPage]->_pPage->TranslateAccelerator(pmsg));
                if (hr != S_FALSE)
                    goto Cleanup;
            }

            // The CDK pages don't always bubble messages up to the
            // site.  Handle the message now if we have not seen it
            // before.

            if (!_fMessageTranslated)
            {
                hr = IsDialogMessage(_hwndDialog, pmsg) ? S_OK : S_FALSE;
            }

        Cleanup:
            RRETURN1(hr, S_FALSE);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::OnCommand
        //
        //  Synopsis:   Handle WM_COMMAND message
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::OnCommand(WORD wNotifyCode, WORD idiCtrl, HWND hwndCtrl)
        {
            switch (idiCtrl)
            {
            case IDCANCEL:
                _hr = _fApplyWasHit ? S_OK : S_FALSE;
                Close();
                break;

            case IDI_PROPDLG_APPLY:
                if (Apply())
                {
                    _fApplyWasHit = TRUE;
                }
                break;

            case IDOK:
                if (Apply())
                {
                    Close();
                }
                break;

            case IDI_PROPDLG_COMBO:
                if (wNotifyCode == CBN_SELCHANGE)
                {
                    int i = SendMessage(_hwndCombo, CB_GETCURSEL, 0, 0);

                    if (i >= 0 && i <= _cUnkLevel)
                    {
                        SetPage(_aiPageLevel[i]);
                    }
                }
                break;
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::OnNotify
        //
        //  Synopsis:   Handle WM_NOTIFY message
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::OnNotify(int idiCtrl, LPNMHDR lpnmhdr)
        {
            int i;

            if (idiCtrl == IDI_PROPDLG_TABS &&
                    lpnmhdr->code == TCN_SELCHANGE &&
                    _iPage >= 0)
            {
                i = TabCtrl_GetCurSel(_hwndTabs);
                SetPage(_aiPageLevel[_arySite[_iPage]->_iLevel] + i, FALSE);
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::InitDialog
        //
        //  Synopsis:   Initialize the dialog
        //
        //-------------------------------------------------------------------------

        BOOL
        CPropertyDialog::OnInitDialog(HWND hwnd)
        {
            static int aidiButtons[] =
                { IDOK, IDCANCEL, IDI_PROPDLG_APPLY, IDI_PROPDLG_COMBO };

            HRESULT         hr = S_OK;
            GDIRECT         rcMax;
            GDIRECT         rc;
            int             i;
            int             dx, dy;
            IHTMLElement *  pElement;
            CElement *      pElem;

            _hwndDialog = hwnd;
            _hwndTabs = GetDlgItem( _hwndDialog, IDI_PROPDLG_TABS );
            _hwndCombo = GetDlgItem( _hwndDialog, IDI_PROPDLG_COMBO );

            _fApplyWasHit = FALSE;

            // Crawl up the parent chain.

            _apUnkLevel[0] = _apUnk[ 0 ];
            _apUnkLevel[0]->AddRef();       // Keeps the cleanup code simple.

            //
            // Don't walk the tree in browse mode
            //
            if (!_punkBrowseDefault)
            {
                for ( _cUnkLevel = 1 ; !hr && _cUnkLevel < ARRAY_SIZE(_apUnkLevel) ; )
                {
                    hr =
                        THR(
                            _apUnkLevel [ _cUnkLevel - 1 ]->QueryInterface(
                                IID_IHTMLElement, (void * *) & pElement ) );

                    if (OK(hr))
                    {
                        //
                        // Get parent of this element
                        //

                        hr =
                            THR(
                                pElement->get_parentElement(
                                    (IHTMLElement **) & _apUnkLevel [ _cUnkLevel ] ) );

                        if ( !hr )
                        {
                            hr =
                                _apUnkLevel [ _cUnkLevel ]->QueryInterface (
                                    CLSID_CElement, (void * *) & pElem );

                            if (!hr)
                            {
                                // Ignore the HTML tag
                                if ( pElem->Tag() == ETAG_HTML )
                                {
                                    _apUnkLevel[ _cUnkLevel ]->Release();
                                    _apUnkLevel[ _cUnkLevel ] = NULL;
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    _cUnkLevel++;
                                }
                            }
                        }

                        pElement->Release();
                    }
                }
            }
            else
            {
                //
                // In browse mode we hide the combo-box and the apply button.
                //
                _cUnkLevel = 1;
                ::EnableWindow(_hwndCombo, FALSE);
                ::ShowWindow(_hwndCombo, SW_HIDE);
                hwnd = GetDlgItem(_hwndDialog, IDI_PROPDLG_APPLY);
                ::ShowWindow(hwnd, SW_HIDE);
            }

            // Load pages for base objects.

            hr = THR(CreatePageSites(0, _cUnk, (IUnknown **) _apUnk));
            if (hr)
                goto Cleanup;

            // Load pages for parent objects.

            for (i = 1; i < _cUnkLevel; ++i)
            {
                hr = THR(CreatePageSites(i, 1, (IUnknown **) &_apUnkLevel[i]));
            }

            // Combobox is hidden, no need to load.
            // Load combobox when _apUnkLevel[i] is (IHTMLDocument2 *) pDoc will set
            // hr to E_FAIL, and eventually fails IDM_PROPERTIES.
            //
            if (!(_punkBrowseDefault))
            {
                // Load the combo box

                for (i = 0; i < _cUnkLevel; ++i)
                {
                    BSTR           bstrTagName = 0;
                    IHTMLElement * pElement;

                    if (OK(_apUnkLevel[i]->QueryInterface(IID_IHTMLElement, (void **)&pElement)))
                    {
                        hr = THR(pElement->get_tagName(&bstrTagName));
                        pElement->Release();
                    }
                    else
                    {
                        hr = E_FAIL;
                    }

                    // TODO Pick default name here?
                    if (hr)
                        break;

                    SendMessage(_hwndCombo, CB_ADDSTRING, 0, (LPARAM) bstrTagName);
                    SysFreeString(bstrTagName);
                }
            }

            // Compute maximum page size.

            memset(&rcMax, 0, sizeof(rcMax));

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i]->_ppi.size.cx > rcMax.right)
                    rcMax.right = _arySite[i]->_ppi.size.cx;

                if (_arySite[i]->_ppi.size.cy > rcMax.bottom)
                    rcMax.bottom = _arySite[i]->_ppi.size.cy;
            }

            // Load titles into tabs.

            UpdateTabs(0);

            // Move controls to where they belong based on max page rectangle.

            TabCtrl_AdjustRect(_hwndTabs, TRUE, &rcMax);
            GetWindowRect(_hwndTabs, &rc);
            dx = rcMax.right - rcMax.left - rc.right + rc.left;
            dy = rcMax.bottom - rcMax.top - rc.bottom + rc.top;

            // Allow Trident to shrink the properties dialog in browse mode to honor
            // the size given by PMs.
            //
            if (dx < 0 && !_punkBrowseDefault) dx = 0;
            if (dy < 0 && !_punkBrowseDefault) dy = 0;

            MapWindowPoints(NULL, _hwndDialog, (GDIPOINT *)&rc, 2);
            rc.right += dx;
            rc.bottom += dy;
            MoveWindow(_hwndTabs, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, FALSE);

            _rcPage.left = 0;
            _rcPage.right = rc.right - rc.left;
            _rcPage.top = 0;
            _rcPage.bottom = rc.bottom - rc.top;

            TabCtrl_AdjustRect(_hwndTabs, FALSE, (GDIRECT *) ENSUREOLERECT(&_rcPage));
	        
            GetWindowRect(_hwndDialog, &rc);

            GDIRECT rcDesktop;
            LONG lWidth, lHeight;

            GetWindowRect(GetDesktopWindow(), &rcDesktop);
            lWidth  = rc.right - rc.left + dx;
            lHeight = rc.bottom - rc.top + dy;
            MoveWindow(_hwndDialog,
                    rcDesktop.left + (rcDesktop.right - rcDesktop.left - lWidth) / 2,
                    rcDesktop.top + (rcDesktop.bottom - rcDesktop.top - lHeight) / 2,
                    lWidth,
                    lHeight,
                    FALSE);

            //
            // Move the OK and Cancel buttons over in browse mode since we hide
            // the Apply button.
            //
            if (_punkBrowseDefault)
            {
                GDIRECT rc2;
                hwnd = GetDlgItem(_hwndDialog, IDI_PROPDLG_APPLY);
                GetWindowRect(hwnd, &rc);
                hwnd = GetDlgItem(_hwndDialog, IDCANCEL);
                GetWindowRect(hwnd, &rc2);
                dx += (rc.right - rc.left) + (rc.left - rc2.right);
            }

            for (i = 0; i < ARRAY_SIZE(aidiButtons); i++)
            {
                hwnd = GetDlgItem(_hwndDialog, aidiButtons[i]);
                GetWindowRect(hwnd, &rc);
                MapWindowPoints(NULL, _hwndDialog, (GDIPOINT *)&rc, 2);
                OffsetRect(&rc, aidiButtons[i] != IDI_PROPDLG_COMBO ? dx : 0, dy);
                MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, FALSE);
            }

            // Activate the first page.

            if (_arySite.Size() > 0)
            {
                SetPage(0);
            }

            //  Disable the top-level parent, makes the propdialog modal.

            ::EnableWindow(_hwndTopParent, FALSE);

        Cleanup:
            _hr = hr;
            return FALSE;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::DlgProc
        //
        //  Synopsis:   Dialog procedure.
        //
        //-------------------------------------------------------------------------

        BOOL CALLBACK
        CPropertyDialog::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
        {
            CPropertyDialog *pDialog = (CPropertyDialog *)GetWindowLong(hwnd, DWL_USER);

            switch (msg)
            {
            case WM_INITDIALOG:
                SetWindowLong(hwnd, DWL_USER, lParam);
                pDialog = (CPropertyDialog *)lParam;
                return pDialog->OnInitDialog(hwnd);
                break;

            case WM_CLOSE:
                pDialog->Close();
                break;

            case WM_NOTIFY:
                pDialog->OnNotify((int)wParam, (LPNMHDR)lParam);
                break;

            case WM_COMMAND:
                pDialog->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                   GET_WM_COMMAND_ID(wParam, lParam), 
                                   GET_WM_COMMAND_HWND(wParam, lParam));
                break;

            default:
                return FALSE;
            }

            return TRUE;
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     ShowPropertyDialog
        //
        //  Synopsis:   Show the property dialog for the given objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        ShowPropertyDialog(
                int                 cUnk,
                IUnknown **         apUnk,
                HWND                hwndOwner,
                IServiceProvider *  pServiceProvider,
                LCID                lcid,
                IUnknown *          punkBrowseDefault)
        {
            if (!cUnk)
                return S_OK;

            IDispatch *         pDispBase = NULL;
            CPropertyDialog     Dialog;
            MSG                 msg;
            HWND                hwndTop;
            HWND                hwnd;
    
            memset(&Dialog, 0, sizeof(Dialog));

            Dialog._iPage               = -1;
            Dialog._cUnk                = cUnk;
            Dialog._apUnk               = apUnk;
            Dialog._pServiceProvider    = pServiceProvider;
            Dialog._lcid                = lcid;
            Dialog._punkBrowseDefault   = punkBrowseDefault;

            //  compute top-level parent

            for ( hwnd = hwndTop = hwndOwner;
                  hwnd;
                  hwnd = GetParent(hwnd) )
            {
                hwndTop = hwnd;
            }
            Dialog._hwndTopParent    = hwndTop;

            if (!CreateDialogParam(
                    GetResourceHInst(),
                    MAKEINTRESOURCE(IDR_PROPERTIES_DIALOG),
                    hwndOwner,
                    &CPropertyDialog::DlgProc,
                    (LPARAM)&Dialog))
            {
                Dialog._hr = E_FAIL;
                goto Cleanup;
            }

        #ifdef UNIX
            // IEUNIX: Need to tell window manager that I'm modal
            MwSetModalPopup(Dialog._hwndDialog, TRUE);
        #endif

            ShowWindow(Dialog._hwndDialog, SW_SHOWNA);

            while (Dialog._hwndDialog)
            {
                GetMessage(&msg, NULL, 0, 0);

                if (Dialog.PreTranslateMessage(&msg) != S_OK)
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }


        Cleanup:
            RRETURN1(Dialog._hr, S_FALSE);
        }
        #endif // NO_HTML_DIALOG

#endif NEVER


//----------------------------------------------------------------------------
//  WARNING - We don't want to "taint" the property dialog with with any
//  knowledge of our internals.  This so that our hosts can duplicate our
//  UI from clean interfaces.  So don't move this include any higher in this
//  file and don't put any new functions below this line.
//

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ShowPropertyDialog
//
//  Synopsis:   Show the property dialog for the given array of sites.
//
//----------------------------------------------------------------------------


HRESULT
CDoc::ShowPropertyDialog(CDocument * pDocument, int cElements, CElement ** apElement)
{
#ifdef NO_HTML_DIALOG
    return S_OK;
#else        
    HRESULT             hr = E_FAIL;   
    SAFEARRAY         * psafearray = NULL;
    IUnknown * HUGEP  * apUnk = NULL;
    IOleCommandTarget * pBackupHostUICommandHandler = NULL;  
    EVENTPARAM          param(this, NULL, NULL, TRUE);
    VARIANT             varIn;
    int                 i;           
    HWND                hwnd = NULL;
    HWND                hwndParent;

    Assert(cElements >= 0);
    Assert(apElement || cElements==0);
    VariantInit(&varIn);

    psafearray = SafeArrayCreateVector(VT_UNKNOWN, 0, cElements);
    if (!psafearray)        
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // fill the safe array with punks
    if (cElements)
    {
        hr = SafeArrayAccessData(psafearray, (void HUGEP* FAR*)&apUnk);
        if (hr)
            goto Cleanup;
        Assert(apUnk);
        
        for (i = 0; i < cElements; ++i)
        {
            Assert(apElement[i]);           
            apUnk[i] = apElement[i]->PunkInner();
            apUnk[i]->AddRef();
        }
    }

    {
        CDoEnableModeless   dem(this, pDocument->MyCWindow());
    
        if (!dem._hwnd)
        {
            hr = E_FAIL;
            goto Cleanup;
        }    
     
        hwnd = dem._hwnd;

        // set up expandos         
        param.SetType(_T("propertysheet"));             
        param.propertysheetParams.paPropertysheetPunks     = psafearray;
        
        V_VT(&varIn) = VT_UNKNOWN;    

        pDocument->QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varIn));

        //V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *)this;
        //V_UNKNOWN(&varIn)->AddRef();
        
        // Query host to show dialog    
        if (_pHostUICommandHandler)               
        {                             
            hr = _pHostUICommandHandler->Exec(                
                &CGID_DocHostCommandHandler,                        
                OLECMDID_PROPERTIES,                        
                0,                                           
                &varIn,                                            
                NULL);              
            if (SUCCEEDED(hr))
                goto Cleanup;        
        }
            
        // Let backup show dialog                                            
        EnsureBackupUIHandler();                            
        if (_pBackupHostUIHandler)                                        
        {                                                                                                  
            hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,                                            
                (void **) &pBackupHostUICommandHandler);                                                            
            if (hr)                                                                         
                goto Cleanup;                                            
                        
            hr = pBackupHostUICommandHandler->Exec(                                
                &CGID_DocHostCommandHandler,                                            
                OLECMDID_PROPERTIES,                                            
                0,                                            
                &varIn,                                            
                NULL);                                                                                   
        }
    }
    
Cleanup:
    // need to re-focus parent frame, since OleCreatePropertyFrameIndirect
    // does not return focus to its window owner
    if (hwnd)
    {
        for(hwndParent = GetParent(hwnd); 
            hwndParent;
            hwndParent = GetParent(hwnd) )
            hwnd = hwndParent;
        SetActiveWindow(hwnd);
    }
    SetFocus(TRUE);
    
    if (psafearray)
    {
        if (apUnk)
            SafeArrayUnaccessData(psafearray);
        SafeArrayDestroy(psafearray);
    }

    ReleaseInterface(pBackupHostUICommandHandler);
    VariantClear(&varIn);   

    RRETURN1(hr, S_FALSE);
#endif // NO_HTML_DIALOG
}


STDAPI CreateHTMLPropertyPage(       
        IMoniker *          pmk,
        IPropertyPage **    ppPP)
{
    HRESULT             hr = E_FAIL;    
    HTMLDLGINFO         dlginfo;
    CEnsureThreadState  ets;
       
    Assert(pmk);
    Assert(ppPP);       
  
    if (ppPP)
        *ppPP = NULL;

    if (!pmk || !ppPP)
        goto Cleanup;    

    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;    
        
    dlginfo.pmk             = pmk;
    dlginfo.fPropPage       = TRUE;

    hr = THR(CHTMLDlg::CreateHTMLDlgIndirect(NULL, &dlginfo, IID_IPropertyPage, (void**)ppPP));
    if (hr)
        goto Cleanup;   

Cleanup:    
    if (hr && ppPP)    
    {
        ReleaseInterface(*ppPP);   
        *ppPP = NULL;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\fpersist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Contains the saving and loading code for the form
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"   // for databinding
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"  // for _pimganim
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_WINCRYPT_H_
#define X_WINCRYPT_H_
#include "wincrypt.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include <dwnnot.h>
#endif

#ifndef X_EVENTOBJ_H_
#define X_EVENT_OBJ_H_
#include "eventobj.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_SHFOLDER_HXX_
#define X_SHFOLDER_HXX_
#define _SHFOLDER_
#include "shfolder.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#define _hxx_
#include "hedelems.hdl"

#include <platform.h>

// N.B. taken from shlguidp.h of shell enlistment fame
// Consider: include this file instead (but note that this is a private guid)
#define WSZGUID_OPID_DocObjClientSite _T("{d4db6850-5385-11d0-89e9-00a0c90a90ac}")

extern "C" const CLSID CLSID_HTMLPluginDocument;

HRESULT CreateStreamOnFile(LPCTSTR    lpstrFile,
                           DWORD      dwSTGM,
                           LPSTREAM * ppstrm);

BOOL IsInIEBrowser(CDoc * pDoc);

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];

//+---------------------------------------------------------------
//  Debugging support
//---------------------------------------------------------------

DeclareTag(tagFormP,            "FormPersist", "Form Persistence");
DeclareTag(tagDocRefresh,       "Doc",          "Trace ExecRefresh");
ExternTag(tagMsoCommandTarget);
ExternTag(tagPageTransitionTrace);
PerfDbgExtern(tagPushData)
PerfDbgExtern(tagPerfWatch)
DeclareTag(tagDontOverrideCharset, "Markup",   "Don't override Meta Charset tag");
DeclareTag(tagDontRewriteDocType, "Markup", "Don't rewrite DocType tag");

MtDefine(CDocSaveToStream_aryElements_pv, Locals, "CDoc::SaveToStream aryElements::_pv")
MtDefine(CDocSaveSnapShotDocument_aryElements_pv, Locals, "CDoc::SaveSnapShotDocument aryElements::_pv")
MtDefine(LoadInfo_pchSearch, Locals, "CDoc::LOADINFO::pchSearch")
MtDefine(NewDwnCtx, Dwn, "CDoc::NewDwnCtx")
WHEN_DBG( void DebugSetTerminalServer(); )

//+---------------------------------------------------------------
//  Sturcture used in creating a desktop item.
//---------------------------------------------------------------

typedef struct {
    LPCTSTR pszUrl;
    HWND hwnd;
    DWORD dwItemType;
    int x;
    int y;
} CREATEDESKITEM;

static HRESULT CreateDesktopItem(LPCTSTR pszUrl, HWND hwnd, DWORD dwItemType, int x, int y);
MtDefine(SetAsDesktopItem, Utilities, "Set As Desktop Item...")

//+---------------------------------------------------------------
//
//   IsGlobalOffline
//
// Long term - This should call UrlQueryInfo so that wininet is
// not loaded unless needed
//
//---------------------------------------------------------------
extern BOOL IsGlobalOffline(void);

// IEUNIX: Needs to know filter type and save file with filter type.
#ifdef UNIX
//
// I'm taking this out temporarily during my merge.
// To coordinate with steveshi about putting it back - v-olegsl.
//
#if 0 // Move it back temporary. #if 1
#define MwFilterType(pIn, bSet) ""
#else
extern "C" char* MwFilterType(char*, BOOL);
#endif
#endif /** UNIX **/

BOOL
IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    HMODULE hModuleHandle = GetModuleHandleA("wininet.dll");

    if(!hModuleHandle)
        return FALSE;

    // Call InternetQueryOption when INTERNET_OPTION_LINE_STATE
    // implemented in WININET.
    if(InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

static BOOL
IsNotConnected()
{
#ifdef WIN16
    //BUGWIN16: Ned to implement the new wininet APIs
    return FALSE;
#else
    DWORD dwConnectedStateFlags;

    return(     !InternetGetConnectedState(&dwConnectedStateFlags, 0)       // Not connected
            &&  !(dwConnectedStateFlags & INTERNET_CONNECTION_MODEM_BUSY)); // Not dialed out to another connection
#endif
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsFrameOffline
//
//---------------------------------------------------------------

BOOL
CDoc::IsFrameOffline(DWORD *pdwBindf)
{
    BOOL fIsFrameOffline = FALSE;
    DWORD dwBindf = 0;

    if (_dwLoadf & DLCTL_FORCEOFFLINE)
    {
        fIsFrameOffline = TRUE;
        dwBindf = BINDF_OFFLINEOPERATION;
    }
    else if (_dwLoadf & DLCTL_OFFLINEIFNOTCONNECTED)
    {
        if (IsNotConnected())
        {
            fIsFrameOffline = TRUE;
            dwBindf = BINDF_OFFLINEOPERATION;
        }
        else
            dwBindf = BINDF_GETFROMCACHE_IF_NET_FAIL;
    }

    if (pdwBindf)
        *pdwBindf = dwBindf;

    return fIsFrameOffline;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsOffline
//
//---------------------------------------------------------------

BOOL
CDoc::IsOffline()
{
    // Call InternetQueryOption when INTERNET_OPTION_LINE_STATE
    // implemented in WININET.
    return ((IsFrameOffline()) || (IsGlobalOffline()) );
}

HRESULT
CDoc::SetDirtyFlag(BOOL fDirty)
{
    if( fDirty )
        _lDirtyVersion = MAXLONG;
    else
        _lDirtyVersion = 0;
    
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsDirty
//
//  Synopsis:   Method of IPersist interface
//
//  Notes:      We must override this method because we are a container.
//              In addition to normal base processing we must pass this
//              call recursively to our embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::IsDirty(void)
{
    HRESULT  hr = S_OK;

    // NOTE: (rodc) Never dirty in browse mode.
    if (!DesignMode())
        return S_FALSE;

    if (_lDirtyVersion != 0)
        return S_OK;

    if (PrimaryMarkup() && 
        (PrimaryMarkup()->_fHasFrames || _fHasOleSite))
    {
        hr = PrimaryMarkup()->Document()->IsDirty();
    }

    if (_lDirtyVersion == 0)
        return S_FALSE;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetCurFile, IPersistFile
//
//----------------------------------------------------------------------------

HRESULT
CDoc::GetCurFile(LPOLESTR *ppszFileName)
{
    //delegate to the top level document
    RRETURN(THR(PrimaryMarkup()->Document()->GetCurFile(ppszFileName)));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetClassID, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetClassID(CLSID *pclsid)
{
    // This method can be deleted if we can make IPersistFile a tearoff interface.
    if (pclsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    if (!_fFullWindowEmbed)
        *pclsid = *BaseDesc()->_pclsid;
    else
        *pclsid = CLSID_HTMLPluginDocument;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetCurMoniker, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetCurMoniker(IMoniker **ppmkName)
{
    RRETURN(THR(PrimaryMarkup()->Document()->GetCurMoniker(ppmkName)));
}

//+---------------------------------------------------------------------------
//
//  Helper:     ReloadAndSaveDocInCodePage
//
//  Synopsis:   Helper to encapsulate reloading a document and saving it.
//              Save the URL pszUrl in the file pszPath, in character set
//              codepage.
//----------------------------------------------------------------------------
static HRESULT
ReloadAndSaveDocInCodePage(LPTSTR pszUrl, LPTSTR pszPath, CODEPAGE codepage,
    CODEPAGE codepageLoad, CODEPAGE codepageLoadURL)
{
    CDoc::LOADINFO LoadInfo = { 0 };
    MSG         msg;
    HRESULT     hr  = S_OK;
    CMarkup   * pMarkup;

    // No container, not window enabled, not MHTML.
    CDoc *pTempDoc = new CDoc(NULL);

    if (!pTempDoc)
        goto Cleanup;

    pTempDoc->Init();

    // Don't execute scripts, we want the original.
    pTempDoc->_dwLoadf |= DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD |
                          DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_CLIENTPULL |
                          DLCTL_SILENT | DLCTL_NO_JAVA | DLCTL_DOWNLOADONLY;

    hr = CreateURLMoniker(NULL, LPTSTR(pszUrl), &LoadInfo.pmk);
    if (hr || !LoadInfo.pmk)
        goto Cleanup;

    LoadInfo.pchDisplayName = pszUrl;
    LoadInfo.codepageURL = codepageLoadURL;
    LoadInfo.codepage = codepageLoad;

    hr = pTempDoc->LoadFromInfo(&LoadInfo);
    if (hr)
        goto Cleanup;

    // TODO Arye: I don't like having a message loop here,
    // Neither does Dinarte, nor Gary. But no one has a better
    // idea that can be implemented in a reasonable length of
    // time, so we'll do this for now so that Save As ... is a
    // synchronous operation.
    //
    // Process messages until we've finished loading.

    for (;;)
    {
        GetMessage(&msg, NULL, 0, 0);
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        if (pTempDoc->LoadStatus() >= LOADSTATUS_PARSE_DONE)
            break;
    }

    pMarkup = pTempDoc->PrimaryMarkup();

    hr = pMarkup->SetCodePage(codepage);                            // codepage of the doc
    if (hr)
        goto Cleanup;
    hr = pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(codepage));  // family codepage of the doc
    if (hr)
        goto Cleanup;

    pMarkup->_fDesignMode = TRUE;          // force to save from the tree.

    IGNORE_HR(pTempDoc->Save(pszPath, FALSE));

Cleanup:
    ReleaseInterface(LoadInfo.pmk);

    if (pTempDoc)
    {
        pTempDoc->Close(OLECLOSE_NOSAVE);
        pTempDoc->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PromptSave
//
//  Synopsis:   This function saves the document to a file name selected by
//              displaying a dialog. It changes current document name to given
//              name.
//
//              NOTE: for this version, Save As will not change the
//              current filename.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::PromptSave(CMarkup *pMarkup, BOOL fSaveAs, BOOL fShowUI /* = TRUE */, TCHAR * pchPathName /* = NULL */)
{
    HRESULT                 hr = S_OK;
    TCHAR                   achPath[MAX_PATH];
    TCHAR *                 pchPath;
    CElement *              pElem;
    PARSEDURL               puw = {0};
    int                     cchUrl;
    TCHAR *                 pchQuery;
    CCollectionCache *      pCollectionCache;

    Assert(fShowUI || (!fShowUI && pchPathName));
    Assert (pMarkup);

    // Save image files as native file type
    if (pMarkup->IsImageFile())
    {
        Assert(fSaveAs); // image files are not editable       

        // Locate the image element
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION));
        if (hr)
            goto Cleanup;

        pCollectionCache = pMarkup->CollectionCache();
        Assert(pCollectionCache);

        // We must have exactly one image in this document
        if (1 != pCollectionCache->SizeAry(CMarkup::IMAGES_COLLECTION))
        {
            Assert(FALSE);
            goto Cleanup;
        }

        hr = THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, 0, &pElem));
        if (hr)
            goto Cleanup;
        Assert(pElem->Tag() != ETAG_INPUT);
        hr = THR(DYNCAST(CImgElement, pElem)->_pImage->PromptSaveAs(achPath, MAX_PATH));
        if (hr)
            goto Cleanup;
        pchPath = achPath;
    }
    else
    {
        CODEPAGE codepage = pMarkup->GetCodePage();

        if (fSaveAs)
        {
            if (!fShowUI)
            {
                pchPath = pchPathName;
            }
            else
            {
                achPath[0] = 0;

                if (pchPathName)
                {
                    _tcsncpy(achPath, pchPathName, MAX_PATH);
                    achPath[MAX_PATH - 1] = 0;
                }
                else
                {
                    // Get file name from _cstrUrl
                    // Note that location is already stripped out from the URL
                    // before it is copied into _cstrUrl. If _cstrUrl ends in '/',
                    // we assume that it does not have a file name at the end
                    const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);
                    if (pchUrl)
                    {
                        cchUrl = _tcslen(pchUrl);
                        if (cchUrl && pchUrl[cchUrl - 1] != _T('/'))
                        {
                            puw.cbSize = sizeof(PARSEDURL);
                            if (SUCCEEDED(ParseURL(pchUrl, &puw)))
                            {
                                // Temporarily, null out the '?' in the url
                                pchQuery = _tcsrchr(puw.pszSuffix, _T('?'));
                                if (pchQuery)
                                    *pchQuery = 0;
                                _tcsncpy(achPath, PathFindFileName(puw.pszSuffix), MAX_PATH);
                                if (pchQuery)
                                    *pchQuery = _T('?');

                                achPath[MAX_PATH - 1] = 0;
                            }
                        }
                    }
                }
                if (!achPath[0])
                {
                    LoadString(GetResourceHInst(), IDS_UNTITLED_MSHTML,
                               achPath, ARRAY_SIZE(achPath));
                }

                {
                    CDoEnableModeless   dem(this, pMarkup->GetWindowedMarkupContextWindow());

                    if (dem._hwnd)
                    {
                        hr = RequestSaveFileName(achPath, ARRAY_SIZE(achPath), &codepage);
                    }

                    if ( hr || !dem._hwnd)
                        goto Cleanup;
                }
                
                pchPath = achPath;
            }
        }
        else
        {
            pchPath = NULL;
        }

        if (pMarkup->GetCodePage() != codepage && fSaveAs)
        {
            if (pMarkup->_fDesignMode)
            {
                // TODO (johnv) This is a bit messy.  CDoc::Save should
                // take a codepage parameter.
                // Save from the tree, but in a different codepage.
                CODEPAGE codepageInitial = pMarkup->GetCodePage();
                CODEPAGE codepageFamilyInitial = pMarkup->GetFamilyCodePage();

                IGNORE_HR(pMarkup->SetCodePage(codepage));
                IGNORE_HR(pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(codepage)));
                hr = THR(SaveHelper(pMarkup, pchPath, pMarkup->_fDesignMode));
                IGNORE_HR(pMarkup->SetCodePage(codepageInitial));
                IGNORE_HR(pMarkup->SetFamilyCodePage(codepageFamilyInitial));
                IGNORE_HR(pMarkup->UpdateCodePageMetaTag(codepageInitial));

                if (hr)
                    goto Cleanup;
            }
            else
            {
                // Create a separate document, loading it in without
                // actually running any scripts.
                hr = THR(ReloadAndSaveDocInCodePage ((TCHAR *) CMarkup::GetUrl(pMarkup),
                            pchPath, codepage, pMarkup->GetCodePage(), NavigatableCodePage(pMarkup->GetURLCodePage())));

                if (hr)
                    goto Cleanup;
            }

        }
        else
        {
            hr = THR(SaveHelper(pMarkup, pchPath, pMarkup->_fDesignMode));
            if (hr)
                goto Cleanup;
        }
    }
    hr = THR(SaveCompletedHelper(pMarkup, pchPath));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PromptSaveImgCtx
//
//----------------------------------------------------------------------------

HRESULT
CDoc::PromptSaveImgCtx(const TCHAR * pchCachedFile, const MIMEINFO * pmi,
                       TCHAR * pchFileName, int cchFileName)
{
    HRESULT hr;
    TCHAR * pchFile;
    TCHAR * pchFileExt;
    int     idFilterRes = IDS_SAVEPICTUREAS_ORIGINAL;

    Assert(pchCachedFile);

    // If there is no save directory then save
    // to the "My Pictures" Dir.
    {
        // NB: to keep from eating up too much stack, I'm going
        // to temporarily use the pchFileName buffer that is passed
        // in to construct the "My Pictures" dir string.

        // Also if the directory doesn't exist, then just leave g_achSavePath
        // NULL and we will default to the desktop

        LOCK_SECTION(g_csFile);

        if (!*g_achSavePath)
        {
            hr = SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, 0, pchFileName);
            if (hr == S_OK && PathFileExists(pchFileName))
            {
                _tcscpy(g_achSavePath, pchFileName);
            }
        }
    }

    pchFile = _tcsrchr(pchCachedFile, _T(FILENAME_SEPARATOR));
    if (pchFile && *pchFile)
        _tcsncpy(pchFileName, ++pchFile, cchFileName - 1);
    else
        _tcsncpy(pchFileName, pchCachedFile, cchFileName - 1);
    pchFileName[cchFileName - 1] = _T('\0');

#ifndef UNIX // UNIX needs extension name if available.
    pchFileExt = _tcsrchr(pchFileName, _T('.'));
//    if (pchFileExt)
//        *pchFileExt = _T('\0');
#endif

    if (pmi && pmi->ids)
        idFilterRes = pmi->ids;

    {
        // TODO: We need to pass window context down here
        CDoEnableModeless   dem(this, NULL);
        
        if (dem._hwnd)
        {
            hr = FormsGetFileName(TRUE,  // indicates SaveFileName
                                  dem._hwnd,
                                  idFilterRes,
                                  pchFileName,
                                  cchFileName, (LPARAM)0);
        }
        else
            hr = E_FAIL;
    }
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveImgCtxAs
//
//----------------------------------------------------------------------------

void
CDoc::SaveImgCtxAs(CImgCtx *    pImgCtx,
                   CBitsCtx *   pBitsCtx,
                   int          iAction,
                   TCHAR *      pchFileName /*=NULL*/,
                   int          cchFileName /*=0*/)
{
#ifndef WINCE
    HRESULT hr = S_OK;
    TCHAR achPath1[MAX_PATH];
    TCHAR achPath2[MAX_PATH];
    TCHAR * pchPathSrc = NULL;
    TCHAR * pchPathDst = NULL;
    TCHAR * pchAlloc = NULL;
    int idsDefault;
    BOOL fSaveAsBmp;

    if (pBitsCtx)
    {
        idsDefault = IDS_ERR_SAVEPICTUREAS;

        hr = pBitsCtx->GetFile(&pchAlloc);
        if (hr)
            goto Cleanup;

        hr = PromptSaveImgCtx(pchAlloc, pBitsCtx->GetMimeInfo(), achPath1, ARRAY_SIZE(achPath1));
        if (hr)
            goto Cleanup;

        pchPathSrc = pchAlloc;
        pchPathDst = achPath1;
        fSaveAsBmp = FALSE;
    }
    else if (pImgCtx)
    {
        switch(iAction)
        {
            case IDM_SETWALLPAPER:
                idsDefault = IDS_ERR_SETWALLPAPER;

                hr = SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, achPath2);
                if (hr)
                    goto Cleanup;

                _tcscat(achPath2, _T("\\Microsoft"));
                if (!PathFileExists(achPath2) && !CreateDirectory(achPath2, NULL))
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }
                _tcscat(achPath2, _T("\\Internet Explorer"));
                if (!PathFileExists(achPath2) && !CreateDirectory(achPath2, NULL))
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }

                hr = Format(0, achPath1, ARRAY_SIZE(achPath1), MAKEINTRESOURCE(IDS_WALLPAPER_BMP), achPath2);
                if (hr)
                    goto Cleanup;

                pchPathDst = achPath1;
                fSaveAsBmp = TRUE;
                break;

            case IDM_SETDESKTOPITEM:
            {
                LPCTSTR lpszURL = pImgCtx->GetUrl();

                idsDefault = IDS_ERR_SETDESKTOPITEM;
                fSaveAsBmp = FALSE;
                if(lpszURL)
                    hr = CreateDesktopItem( lpszURL,
                                            //(_pInPlace ? _pInPlace->_hwnd : GetDesktopWindow()), //Parent window for the UI dialog boxes
                                            GetDesktopWindow(), // If you set _pInPlace->hwnd as the parent, it gets disabled.
                                            COMP_TYPE_PICTURE,          // Desktop item type is IMG.
                                            COMPONENT_DEFAULT_LEFT,     // Default position of top left corner
                                            COMPONENT_DEFAULT_TOP );    // Default position of top
                else
                    hr = E_FAIL;

                if(hr)
                    goto Cleanup;
                break;
            }

            case IDM_SAVEPICTURE:
            default:
                const MIMEINFO * pmi = pImgCtx->GetMimeInfo();

                idsDefault = IDS_ERR_SAVEPICTUREAS;

                hr = pImgCtx->GetFile(&pchAlloc);
                if (hr)
                {
                    if (!LoadString(GetResourceHInst(), IDS_UNTITLED_BITMAP, achPath2, ARRAY_SIZE(achPath2)))
                    {
                        hr = GetLastWin32Error();
                        goto Cleanup;
                    }

                    pmi = GetMimeInfoFromMimeType(CFSTR_MIME_BMP);
                    fSaveAsBmp = TRUE;
                    pchPathSrc = achPath2;
                }
                else
                {
                    fSaveAsBmp = FALSE;
                    pchPathSrc = pchAlloc;
                    _tcsncpy(achPath2, pchAlloc, ARRAY_SIZE(achPath2)-1);
                    achPath2[ARRAY_SIZE(achPath2)-1] = NULL;
                    PathUndecorate(achPath2);
                }

                hr = PromptSaveImgCtx(achPath2, pmi, achPath1, ARRAY_SIZE(achPath1));
                if (hr)
                    goto Cleanup;

                pchPathDst = achPath1;

                if (!fSaveAsBmp)
                {
#ifdef UNIX // IEUNIX uses filter to know save-type
                    fSaveAsBmp = !_strnicmp(".bmp", MwFilterType(NULL, FALSE), 4);
#else
                    TCHAR * pchFileExt = _tcsrchr(pchPathDst, _T('.'));
                    fSaveAsBmp = pchFileExt && _tcsnipre(_T(".bmp"), 4, pchFileExt, -1);
#endif
                }
                break;
        }
    }
    else
    {
        Assert(FALSE);
        return;
    }

    if(iAction != IDM_SETDESKTOPITEM)
    {
        Assert(pchPathDst);
        Assert(fSaveAsBmp || pchPathSrc);

        if (fSaveAsBmp)
        {
            IStream *pStm = NULL;

            hr = THR(CreateStreamOnFile(pchPathDst,
                                    STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
                                    &pStm));
            if (hr)
                goto Cleanup;

            hr = pImgCtx->SaveAsBmp(pStm, TRUE);
            ReleaseInterface(pStm);

            if (hr)
            {
                DeleteFile(pchPathDst);
                goto Cleanup;
            }
        }
        else if (!CopyFile(pchPathSrc, pchPathDst, FALSE))
        {
            hr = GetLastWin32Error();
            goto Cleanup;
        }

        if (pchFileName && cchFileName > 0)
        {
            _tcsncpy(pchFileName, pchPathDst, cchFileName - 1);
            pchFileName[cchFileName - 1] = 0; // _tcsncpy doesn't seem to do this
        }

        if (iAction == IDM_SETWALLPAPER)
        {
            if (!SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, pchPathDst,
                                  SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE))
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    if (FAILED(hr))
    {
        SetErrorInfo(hr);
        THR(ShowLastErrorInfo(hr, idsDefault));
    }
    return;
#endif // WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::RequestSaveFileName
//
//  Synopsis:   Provides the UI for the Save As.. command.
//
//  Arguments:  pszFileName    points to the buffer accepting the file name
//              cchFileName    the size of the buffer
//
//----------------------------------------------------------------------------

HRESULT
CDoc::RequestSaveFileName(LPTSTR pszFileName, int cchFileName, CODEPAGE *pCodePage)
{
    HRESULT  hr;

    Assert(pszFileName && cchFileName);

    hr = FormsGetFileName(TRUE,  // indicates SaveFileName
                          _pInPlace ? _pInPlace->_hwnd : 0,
                          IDS_HTMLFORM_SAVE,
                          pszFileName,
                          cchFileName, (LPARAM)pCodePage);
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     SetFilename
//
//  Synopsis:   Sets the current filename of the document.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetFilename(CMarkup *pMarkup, const TCHAR *pchFile)
{
    TCHAR achUrl[pdlUrlLen];
    ULONG cchUrl = ARRAY_SIZE(achUrl);
    HRESULT hr;

#ifdef WIN16
    Assert(0);
#else
    hr = THR(UrlCreateFromPath(pchFile, achUrl, &cchUrl, 0));
    if (hr)
#endif
        goto Cleanup;

    hr = THR(SetUrl(pMarkup, achUrl));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     SetUrl
//
//  Synopsis:   Sets the current url of the document and updates the moniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetUrl(CMarkup *pMarkup, const TCHAR *pchUrl, BOOL fKeepDwnPost)
{
    IMoniker *pmk = NULL;
    HRESULT hr;

    hr = THR(CreateURLMoniker(NULL, pchUrl, &pmk));
    if (hr)
        goto Cleanup;

    hr = THR(CMarkup::SetUrl(pMarkup, pchUrl));
    if (hr)
        goto Cleanup;

    DeferUpdateTitle(pMarkup);

    hr = THR( pMarkup->ReplaceMonikerPtr( pmk ) );
    if( hr )
        goto Cleanup;

    if (!fKeepDwnPost)
        pMarkup->ClearDwnPost();

    MemSetName((this, "CMarkup SSN=%d URL=%ls", _ulSSN, CMarkup::GetUrl(pMarkup)));

Cleanup:
    ClearInterface(&pmk);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//   Static : CreateSnapShotDocument
//
//   Synopsis : as the name says...
//
//+-------------------------------------------------------------------------

static HRESULT
CreateSnapShotDocument(CDoc * pSrcDoc, CDoc ** ppSnapDoc)
{
    HRESULT         hr = S_OK;
    IStream       * pstmFile = NULL;
    MSG             msg;
    TCHAR         * pstrFile = NULL;
    CDoc          * pSnapDoc = NULL;

    if (!ppSnapDoc)
        return E_POINTER;
    if (!pSrcDoc)
        return E_INVALIDARG;

    *ppSnapDoc = NULL;

    // No container, not window enabled, not MHTML.
    pSnapDoc = new CDoc(NULL);
    if (!pSnapDoc)
        goto Cleanup;

    pSnapDoc->Init();

    // Don't execute scripts, we want the original.
    pSnapDoc->_dwLoadf |= DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD |
                          DLCTL_NO_CLIENTPULL |
                          DLCTL_SILENT | DLCTL_NO_JAVA | DLCTL_DOWNLOADONLY;

    pSnapDoc->PrimaryMarkup()->_fDesignMode = TRUE;          // force to save from the tree.

    pSrcDoc->PrimaryMarkup()->GetFile(&pstrFile);

    hr = THR(CreateStreamOnFile(pstrFile,
                STGM_READ | STGM_SHARE_DENY_NONE, &pstmFile));
    if (hr)
        goto Cleanup;

    hr = THR(pSnapDoc->Load(pstmFile));
    if (hr)
        goto Cleanup;
    //
    // Process messages until we've finished loading.
    do
    {
        if (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } while ( pSnapDoc->LoadStatus() < LOADSTATUS_PARSE_DONE );

    // transfer doc to out parameter
    *ppSnapDoc = pSnapDoc;
    pSnapDoc = NULL;

Cleanup:
    ReleaseInterface(pstmFile);
    if (pSnapDoc)
    {
        // we are here due to an error
        pSnapDoc->Close(OLECLOSE_NOSAVE);
        pSnapDoc->Release();
    }
    if (pstrFile)
    {
        MemFreeString(pstrFile);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//   Member :SaveSnapShotDocument
//
//   Synopsis : entry point for the snapshot save logic.  called from
//          IPersistfile::save
//
//+---------------------------------------------------------------------------
HRESULT
CDoc::SaveSnapShotDocument(IStream * pstmSnapFile)
{
    HRESULT              hr = S_OK;
    CDoc               * pSnapDoc = NULL;
    IPersistStreamInit * pIPSI = NULL;
    IUnknown           * pDocUnk = NULL;

    if (!pstmSnapFile)
        return E_INVALIDARG;

    // create our design time document,
    hr = CreateSnapShotDocument(this, &pSnapDoc);
    if (hr)
        goto Cleanup;

    hr = THR(pSnapDoc->QueryInterface(IID_IUnknown, (void**)&pDocUnk));
    if (hr)
        goto Cleanup;

    // fire the save notification and let the peers transfer their
    // element's state into the design doc
    hr = THR(SaveSnapshotHelper( pDocUnk ));
    if (hr)
        goto Cleanup;

    // and now save the design doc.
    hr = THR(pSnapDoc->QueryInterface(IID_IPersistStreamInit, (void**)&pIPSI));
    if (hr)
        goto Cleanup;

    hr = THR(pIPSI->Save(pstmSnapFile, TRUE));

Cleanup:
    ReleaseInterface(pDocUnk);
    ReleaseInterface(pIPSI);
    if (pSnapDoc)
        pSnapDoc->Release();

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member : CDoc::SaveSnapshotHelper( IUnknown * pDocUnk)
//
//  Synopsis : this helper function does the task of firing the save 
//      notification and letting the peers put their element's state into
//      the design time document.  It is called by SaveSnapshotDocument 
//      (a save to stream operation) and by Exec::switch(IDM_SAVEASTHICKET)
//      the save-as call, will return this document to the browser where it
//      will be thicketized.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::SaveSnapshotHelper( IUnknown * pDocUnk, BOOL fVerifyParameters /* ==False */)
{
    HRESULT          hr = S_OK;
    IHTMLDocument2 * pIHTMLDoc = NULL;
    IPersistFile   * pIPFDoc   = NULL;
    TCHAR          * pstrFile = NULL;

    // SaveSnapshotDocument() is internal and has already done the work, 
    // Exec() has not.
    if (fVerifyParameters)
    {
        BSTR bstrMode = NULL;

        if (!pDocUnk)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // dont do the snapshot (runtime) save while we are in design mode
        //  there may be no work to do at all.
        if (!PrimaryMarkup()->MetaPersistEnabled((long)htmlPersistStateSnapshot) ||
            PrimaryMarkup()->_fDesignMode)
        {
            goto Cleanup;
        }

        // now we need to verify that this is indeed a 1> document, 2> loaded with 
        // current base file, and 3> in design mode.
        hr = THR(pDocUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pIHTMLDoc));
        if (hr)
            goto Cleanup;

        hr = THR(pIHTMLDoc->get_designMode(&bstrMode));
        if (hr)
            goto Cleanup;

        if (! _tcsicmp(bstrMode, L"Off"))
            hr = E_INVALIDARG;

        SysFreeString(bstrMode);
        if ( hr )
            goto Cleanup;
    }

    // and finally do the work of the call to transfer the state 
    // from the current document into the (design) output doc
    {
        CNotification   nf;
        long            i;
        CStackPtrAry<CElement *, 64>  aryElements(Mt(CDocSaveSnapShotDocument_aryElements_pv));

        nf.SnapShotSave(PrimaryRoot(), &aryElements);
        BroadcastNotify(&nf);

        for (i = 0; i < aryElements.Size(); i++)
        {
            aryElements[i]->TryPeerSnapshotSave(pDocUnk);
        }
    }

Cleanup:
    ReleaseInterface( pIHTMLDoc );
    ReleaseInterface( pIPFDoc );
    if (pstrFile)
    {
        MemFreeString(pstrFile);
    }
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Load, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    LOADINFO LoadInfo = { 0 };

    LoadInfo.pchFile = (TCHAR *)pszFileName;
    LoadInfo.codepageURL = g_cpDefault;

    RRETURN(LoadFromInfo(&LoadInfo));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Save, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    RRETURN(THR(PrimaryMarkup()->Document()->Save(pszFileName, fRemember)));
}

HRESULT
CDoc::SaveHelper(CMarkup *pMarkup, LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr;
    
    Assert(pMarkup);
    hr = THR(pMarkup->Save(pszFileName, fRemember));
    if (fRemember)
        _lDirtyVersion = 0;
    RRETURN(hr);
}

HRESULT
CMarkup::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
#ifdef WINCE
    return S_OK;
#else
    HRESULT                 hr = S_OK;
    IStream *               pStm = NULL;
    LPCOLESTR               pszName;
    BOOL                    fBackedUp;
    BOOL                    fRestoreFailed = FALSE;
    TCHAR                   achBackupFileName[MAX_PATH];
    TCHAR                   achBackupPathName[MAX_PATH];
    TCHAR                   achFile[MAX_PATH];
    ULONG                   cchFile;
    const TCHAR *           pszExt;

    if (!pszFileName)
    {
        const TCHAR * pchUrl = CMarkup::GetUrl( this );

        if (!pchUrl || GetUrlScheme(pchUrl) != URL_SCHEME_FILE)
            return E_UNEXPECTED;

        cchFile = ARRAY_SIZE(achFile);

        hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
        if (hr)
            RRETURN(hr);

        pszName = achFile;
    }
    else
    {
        pszName = pszFileName;
    }

    //
    // Point to the extension of the file name
    //
    pszExt = pszName + _tcslen(pszName);

    while (pszExt > pszName && *(--pszExt) != _T('.'))
        ;

    fBackedUp =
        GetTempPath(ARRAY_SIZE(achBackupPathName), achBackupPathName) &&
        GetTempFileName(achBackupPathName, _T("trb"), 0, achBackupFileName) &&
        CopyFile(pszName, achBackupFileName, FALSE);

#if 0
    if (!StrCmpIC(_T(".rtf"), pszExt) && RtfConverterEnabled())
    {
        CRtfToHtmlConverter * pcnv = new CRtfToHtmlConverter(this);

        if (!pcnv)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = THR(pcnv->InternalHtmlToExternalRtf(pszName));

        delete pcnv;

        if (hr)
            goto Error;
    }
    else
#endif
    {
        //
        // Create a stream on the file and save
        //
        hr = THR(CreateStreamOnFile(
                pszName,
                STGM_READWRITE | STGM_READWRITE | STGM_CREATE,
                &pStm));
        if (hr)
            goto Error;

#ifdef UNIX // Unix uses filter type as save-type
        if (!_strnicmp(".txt", MwFilterType(NULL, FALSE), 4))
#else
        if (!StrCmpIC(_T(".txt"), pszExt))
#endif
        {
            BOOL fWasPlainTextSave = Doc()->_fPlaintextSave;
            // Plaintext save should not touch the dirty bit
            Doc()->_fPlaintextSave = TRUE; // smuggle the text-ness to CDoc::SaveToStream(IStream *pStm)
            hr = THR(SaveToStream(pStm, WBF_SAVE_PLAINTEXT|WBF_FORMATTED,
                GetCodePage()));

            Doc()->_fPlaintextSave = fWasPlainTextSave;

            if (hr)
                goto Error;
        }
        else
        {
            // dont do the snapshot (runtime) save while we are in design mode
            if (    _fDesignMode
                ||  Doc()->_fSaveTempfileForPrinting
                ||  !MetaPersistEnabled((long)htmlPersistStateSnapshot) )
            {
                hr = THR(SaveToStream(pStm));
            }
            else
            {
                // for Snapshot saving, after we save, we need to
                // reload what we just saved.
                if (pszName)
                {
                    hr = THR(Doc()->SaveSnapShotDocument(pStm));
                }
            }
            if (hr)
                goto Error;
        }

        if (fRemember)
        {
            if (pszFileName)
            {
                hr = THR(Doc()->SetFilename(this, pszFileName));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:

    ReleaseInterface(pStm);

    if (!fRestoreFailed)
    {
        // Delete backup file only if copy succeeded.
        DeleteFile(achBackupFileName);
    }

    RRETURN(hr);

Error:

    ClearInterface(&pStm);     // necessary to close pszFileName

    if (fBackedUp)
    {
        //Setting fRestoreFailed to false if the copy fails ensures that 
        //the backup file does not get deleted above.
        fRestoreFailed = CopyFile(achBackupFileName, pszName, FALSE);
    }

    goto Cleanup;
#endif // WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveCompleted, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::SaveCompleted(LPCOLESTR pszFileName)
{
    RRETURN(THR(SaveCompletedHelper(PrimaryMarkup(), pszFileName)));
}

HRESULT
CDoc::SaveCompletedHelper(CMarkup *pMarkup, LPCOLESTR pszFileName)
{
    HRESULT     hr = S_OK;

    Assert(pMarkup);
    if (pszFileName && pMarkup->_fDesignMode)
    {
        hr = THR(SetFilename(pMarkup, pszFileName));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Load, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Load(BOOL fFullyAvailable, IMoniker *pmkName, IBindCtx *pbctx,
    DWORD grfMode)
{
    PerfDbgLog1(tagPerfWatch, this, "+CDoc::Load (IPersistMoniker pbctx=%08lX)", pbctx);

    HRESULT     hr = E_INVALIDARG;
    TCHAR *pchURL = NULL;

    LOADINFO LoadInfo = { 0 };
    LoadInfo.pmk    = pmkName;
    LoadInfo.pbctx  = pbctx;

    if( pmkName == NULL )
        goto Cleanup;

    // Get the URL from the display name of the moniker:
    hr = pmkName->GetDisplayName(pbctx, NULL, &pchURL);
    if (FAILED(hr))
        goto Cleanup;

    LoadInfo.pchDisplayName  = pchURL;

    hr = LoadFromInfo(&LoadInfo);

Cleanup:
    CoTaskMemFree(pchURL);

    PerfDbgLog(tagPerfWatch, this, "-CDoc::Load (IPersistMoniker)");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Save, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::Save(IMoniker *pmkName, LPBC pBCtx, BOOL fRemember)
{
    RRETURN(THR(PrimaryMarkup()->Document()->Save(pmkName, pBCtx, fRemember)));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveCompleted, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SaveCompleted(IMoniker *pmkName, LPBC pBCtx)
{
    RRETURN(THR(PrimaryMarkup()->Document()->SaveCompleted(pmkName, pBCtx)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PutProperty, IMonikerProp
//
//  Synopsis:   QI'ed by urlmon to store the content type, so
//              we don't need to issue a synchronous request
//              to rediscover the content type for full window
//              embeddings. 
//
//----------------------------------------------------------------------------
HRESULT CDoc::PutProperty(MONIKERPROPERTY mkp, LPCWSTR wzValue)
{
    if (_fFullWindowEmbed && mkp == MIMETYPEPROP)
    {
        _cstrPluginContentType.Set(wzValue);
    }

    if (_fFullWindowEmbed && mkp == USE_SRC_URL)
    {
        _fUseSrcURL = !_tcsicmp(wzValue, L"1");
    }

    // Currently, no reason to ever return anything other than S_OK
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFromStream, CServer
//
//  Synopsis:   Loads the object's persistent state from a stream. Called
//              from CServer implementation of IPersistStream::Load
//              and IPersistStorage::Load
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromStream(IStream * pstm)
{
    BOOL fSync = _fPersistStreamSync;

    _fPersistStreamSync = FALSE;
    TraceTag((tagFormP, " LoadFromStream"));
#ifdef DEBUG
    CDataStream ds(pstm);
    ds.DumpStreamInfo();
#endif

    RRETURN(LoadFromStream(pstm, fSync));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFromStream
//
//  Synopsis:   Loads the object's persistent state from a stream. Called
//              from CServer implementation of IPersistStream::Load
//              and IPersistStorage::Load
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromStream(IStream * pstm, BOOL fSync, CODEPAGE cp)
{
    LOADINFO LoadInfo = { 0 };

    LoadInfo.pstm = pstm;
    LoadInfo.fSync = fSync;
    LoadInfo.codepage = cp;

    RRETURN(LoadFromInfo(&LoadInfo));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveToStream, CServer
//
//  Synopsis:   Saves the object's persistent state to a stream.  Called
//              from CServer implementation of IPersistStream::Save
//              and IPersistStorage::Save.
//
//----------------------------------------------------------------------------

#define BUF_SIZE 8192 // copy in chunks of 8192

HRESULT
CDoc::SaveToStream( IStream * pstm )
{
    if( PrimaryMarkup() )
        RRETURN( PrimaryMarkup()->SaveToStream( pstm ) );
    else
        RRETURN( S_OK );
}

HRESULT
CMarkup::SaveToStream(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = WBF_FORMATTED;
    IStream * pStmDirty = GetStmDirty();

    // There are three interesting places to save from:
    //  1) The tree if we're in design-mode and we're dirty or when we are saving
    //          to a temporary file for printing purposes, or when we are saving
    //          to html when the original file was plaintext. In the printing case we use the
    //          base tag that we have inserted to the tree to print images.
    //  2) The dirty stream if we're in run-mode and the dirty stream exists.
    //  3) The original source otherwise.
    //  4) We are in design mode, and not dirty and do not have original source,
    //          then save from the tree.

    if (    (_fDesignMode && Doc()->IsDirty() != S_FALSE ) 
        ||  Doc()->_fSaveTempfileForPrinting
        ||  (HtmCtx() && HtmCtx()->GetMimeInfo() == g_pmiTextPlain && !Doc()->_fPlaintextSave))  // Case 1
    {
        TraceTag((tagFormP, " SaveToStream Case 1"));
        // don't save databinding attributes during printing, so that we
        // print the current content instead of re-binding
        if (Doc()->_fSaveTempfileForPrinting)
        {
            dwFlags |= WBF_SAVE_FOR_PRINTDOC | WBF_NO_DATABIND_ATTRS;
            if ( IsXML() )
                dwFlags |= WBF_SAVE_FOR_XML;
        }

        hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
        CDataStream ds(pStm);
        ds.DumpStreamInfo();
#endif
    }
    else if (!_fDesignMode && pStmDirty)       // Case 2
    {
        ULARGE_INTEGER  cb;
        LARGE_INTEGER   liZero = {0, 0};

        cb.LowPart = ULONG_MAX;
        cb.HighPart = ULONG_MAX;

        TraceTag((tagFormP, " SaveToStream Case 2"));

        Verify(!pStmDirty->Seek(liZero, STREAM_SEEK_SET, NULL));
        hr = THR(pStmDirty->CopyTo(pStm, cb, NULL, NULL));

#if DBG==1
        CDataStream ds(pStm);
        ds.DumpStreamInfo();
#endif
    }
    else                                        // Case 3
    {
        if (HtmCtx() && !_fDesignMode)
        {
            if (!HtmCtx()->IsSourceAvailable())
            {
                TraceTag((tagFormP, " SaveToStream Case 3, no source available"));
                hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
                CDataStream ds(pStm);
                ds.DumpStreamInfo();
#endif
            }
            else
            {
                TraceTag((tagFormP, " SaveToStream Case 3, source available"));
                hr = THR(HtmCtx()->CopyOriginalSource(pStm, 0));
#if DBG==1
                CDataStream ds(pStm);
                ds.DumpStreamInfo();
#endif
            }
        }
        else
        {
            // Case 4:
            TraceTag((tagFormP, " SaveToStream Case 4"));
            hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
            CDataStream ds(pStm);
            ds.DumpStreamInfo();
#endif
        }
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CMarkup::WriteDocHeader(CStreamWriteBuff* pStm)
{
    // Write "<!DOCTYPE... >" stuff
    HRESULT hr = S_OK;
    DWORD dwFlagSave = pStm->ClearFlags(WBF_ENTITYREF);

    // Do not write out the header in plaintext mode.
    if(     Doc()->_fDontWhackGeneratorOrCharset
        WHEN_DBG( || IsTagEnabled( tagDontRewriteDocType ) )
       ||   pStm->TestFlag(WBF_SAVE_PLAINTEXT) )
        goto Cleanup;

    pStm->SetFlags(WBF_NO_WRAP);

    {
        CElement * pEC = GetElementClient();

        hr = pStm->Write((pEC && pEC->Tag() == ETAG_FRAMESET)

                            ? IsStrictCSS1Document()
                                ? _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3c.org/TR/1999/REC-html401-19991224/frameset.dtd\">")
                                : _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Frameset//EN\">")
                            : IsStrictCSS1Document()
                                ? _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd\">")
                                : _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">")
                            );                    
    }

    // If we are saving "pseudoXML" (<HTML:HTML><HTML:HEAD>) set the directive
    // so that the Trident that later reads the file knows to interpret it as such.
    if (    (dwFlagSave & WBF_SAVE_FOR_PRINTDOC)
        &&  (dwFlagSave & WBF_SAVE_FOR_XML) )
    {
        hr = pStm->Write(_T("<?PXML />"));
        if( hr )
            goto Cleanup;
    }

    hr = pStm->NewLine( );
    if( hr )
        goto Cleanup;

Cleanup:
    pStm->RestoreFlags(dwFlagSave);

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveToStream(pStm, dwFlags, codepage)
//
//  Synopsis:   Helper method to save to a stream passing flags to the
//              saver.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SaveToStream(IStream *pStm, DWORD dwStmFlags, CODEPAGE codepage)
{
    if( PrimaryMarkup() )
        RRETURN( PrimaryMarkup()->SaveToStream( pStm, dwStmFlags, codepage ) );
    else
        RRETURN( S_OK );
}

HRESULT
CMarkup::SaveToStream(IStream *pStm, DWORD dwStmFlags, CODEPAGE codepage)
{
    HRESULT          hr = S_OK;
    CStreamWriteBuff StreamWriteBuff(pStm, codepage);

    hr = THR( StreamWriteBuff.Init() );
    if( hr )
        goto Cleanup;

    StreamWriteBuff.SetFlags(dwStmFlags);

    // Srinib, we have just created the stream buffer. But just to make sure
    // that we don't save DOCTYPE during plaintext save.
    if(!StreamWriteBuff.TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // Write out the unicode signature if necessary
        if(     codepage == NATIVE_UNICODE_CODEPAGE 
            ||  codepage == NATIVE_UNICODE_CODEPAGE_BIGENDIAN
            ||  codepage == NONNATIVE_UNICODE_CODEPAGE
            ||  codepage == NONNATIVE_UNICODE_CODEPAGE_BIGENDIAN
            ||  codepage == CP_UTF_8
            ||  codepage == CP_UTF_7 )
        {
            // TODO: We have to write more or less data depending on whether
            //         non-native support is 2* sizeof(TCHAR) or sizeof(TCHAR) / 2
            TCHAR chUnicodeSignature = NATIVE_UNICODE_SIGNATURE;
            StreamWriteBuff.Write( (const TCHAR *) &chUnicodeSignature, 1 );
        }
        if (!StreamWriteBuff.TestFlag(WBF_SAVE_FOR_PRINTDOC) &&
            !Doc()->_fDontWhackGeneratorOrCharset
            WHEN_DBG( && !IsTagEnabled(tagDontOverrideCharset) ))
        {
            // Update or create a meta tag for the codepage on the doc
            IGNORE_HR( UpdateCodePageMetaTag( codepage ) );
        }

        WriteDocHeader(&StreamWriteBuff);
    }

    // TODO (paulpark) Should advance the code-page meta tag to the front of the head, or
    // at least make sure we save it first.

    {
        Assert( Root() );
        CTreeSaver ts( Root(), &StreamWriteBuff );

        ts.SetTextFragSave( TRUE );
        hr = ts.Save();
        if( hr ) 
            goto Cleanup;
    }

    if(!StreamWriteBuff.TestFlag(WBF_SAVE_PLAINTEXT))
        hr = StreamWriteBuff.NewLine();

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::SaveHtmlHead(CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT hr = S_OK;

    // If plaintext, don't write out the head.
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        goto Cleanup;

    // If we are saving for printing, we need to do a few things:
    // Save out codepage metatag.
    // We also need to have a BASE tag or we have little hope of printing
    // any images.  It may be of general use, though, to save the BASE
    // from whence the document orginally came.
    // TODO (KTam): Is it possible that we can use the BASE we're saving
    // as the URL for security checks?  I doubt it.
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CODEPAGE codepage = pStreamWriteBuff->GetCodePage();
        TCHAR achCharset[MAX_MIMECSET_NAME];
        TCHAR * pchBaseUrl = NULL;

        CODEPAGESETTINGS * pCodepageSettings = GetCodepageSettings();
        hr = THR(CMarkup::GetBaseUrl(this, &pchBaseUrl));

        if (hr)
            goto Cleanup;

        hr = GetMlangStringFromCodePage(codepage, achCharset, ARRAY_SIZE(achCharset));
        if (hr)
            goto Cleanup;

        hr = WriteTagNameToStream(pStreamWriteBuff, _T("META"), FALSE, FALSE);
        if (hr)
            goto Cleanup;
       
        hr = WriteTagToStream(pStreamWriteBuff, _T(" content=\"text/html; charset="));
        if (hr)
            goto Cleanup;
        
        hr = WriteTagToStream(pStreamWriteBuff, achCharset);
        if (hr)
            goto Cleanup;
        
        hr = WriteTagToStream(pStreamWriteBuff, _T("\" http-equiv=Content-Type>"));
        if (hr)
            goto Cleanup;
        
        hr = pStreamWriteBuff->NewLine();
        if (hr)
            goto Cleanup;


        if (pchBaseUrl)
        {
            hr = WriteTagNameToStream(pStreamWriteBuff, _T("BASE"), FALSE, FALSE);
            if (hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, _T(" HREF=\"")));
            if(hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, pchBaseUrl));
            if (hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, _T("\">")));
            if (hr)
                goto Cleanup;

            // 43859: For Athena printing, save font information if available
            //        NOTE that this must be the first FONT style tag so that
            //        any others can override it.
            //        NOTE that we only do this for the root document, since
            //        this is the only one for which Athena has set the font
            //        correctly. any sub-frames have _Trident_'s default font.
            if (   pCodepageSettings
                && pCodepageSettings->latmPropFontFace)
            {
                hr = THR(pStreamWriteBuff->NewLine());
                if (hr)
                    goto Cleanup;

                pStreamWriteBuff->BeginPre();

                hr = WriteTagNameToStream(pStreamWriteBuff, _T("STYLE"), FALSE, TRUE);
                if (hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, _T(" HTML { font-family : \"")));
                if(hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, (TCHAR *)fc().GetFaceNameFromAtom(pCodepageSettings->latmPropFontFace)));
                if(hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, _T("\" } ")));
                if(hr)
                    goto Cleanup;

                hr = WriteTagNameToStream(pStreamWriteBuff, _T("STYLE"), TRUE, TRUE);
                if (hr)
                    goto Cleanup;

                pStreamWriteBuff->EndPre();
            }
        }
    }

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::WriteTagToStream
//
//  Synopsis:   Writes given HTML tag to the stream turning off the entity
//               translation mode of the stream. If the WBF_SAVE_PLAINTEXT flag
//               is set in the stream nothing is done.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::WriteTagToStream(CStreamWriteBuff *pStreamWriteBuff, LPTSTR szTag)
{
    HRESULT hr = S_OK;
    DWORD dwOldFlags;

    Assert(szTag != NULL && *szTag != 0);

    if(!pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // Save the state of the flag that controls the conversion of entities
        // and change the mode to "no entity translation"
        dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

        hr = THR(pStreamWriteBuff->Write(szTag));

        // Restore the entity translation mode
        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }

     RRETURN(hr);
}


HRESULT 
CMarkup::WriteTagNameToStream(CStreamWriteBuff *pStreamWriteBuff, LPTSTR szTagName, BOOL fEnd, BOOL fClose)
{
    HRESULT hr = THR(WriteTagToStream(pStreamWriteBuff, fEnd ? _T("</") : _T("<")));
    if (hr)
        goto Cleanup;

    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_XML))
    {
        hr = THR(WriteTagToStream(pStreamWriteBuff, _T("HTML:")));
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(WriteTagToStream(pStreamWriteBuff, szTagName));
    if (hr)
        goto Cleanup;

    if (fClose)
        hr = THR(WriteTagToStream(pStreamWriteBuff, _T(">")));

Cleanup:
    RRETURN(hr);
}




//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryRefresh
//
//  Synopsis:   Called to discover if refresh is supported
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::QueryRefresh(DWORD * pdwFlags)
{
    CMarkup * pMarkup = Markup();
    TraceTag((tagMsoCommandTarget, "CMarkup::QueryRefresh"));

    *pdwFlags = (!pMarkup->_fDesignMode &&
        (CMarkup::GetUrl(pMarkup) || pMarkup->GetNonRefdMonikerPtr() || pMarkup->GetStmDirty() ||
        (pMarkup->HtmCtx() && pMarkup->HtmCtx()->WasOpened())))
            ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::ExecStop
//
//  Synopsis:   Stop form
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::ExecStop(BOOL fFireOnStop /* = TRUE */, BOOL fSoftStop /* = TRUE */, BOOL fSendNot /* = TRUE */)
{
    int             i;
    CNotification   nf;
    CDoc * pDoc = Doc();
    CDataBindTask * pDBTask = GetDBTask();

    // If we are in the middle of a page transition, stop the transition first
    CDocument * pDocument = Document();
    if(pDocument && pDocument->HasPageTransitionInfo())
    {
        if(pDocument->GetPageTransitionInfo()->GetPageTransitionState() > CPageTransitionInfo::PAGETRANS_APPLIED)
        {
            TraceTag((tagPageTransitionTrace, "  PGTRANS: Executing a stop with fSoftStop set to %d", fSoftStop));
            pDocument->CleanupPageTransitions(0);

            // If the STOP button is pressed, kill the transistion but don't stop the download.
            // We will stop the download if the user presses the STOP button again.
            if (fSoftStop)
                return S_OK;
        }
    }

    if (HasWindowPending())
    {
        CWindow *pWindow = GetWindowPending()->Window();
        if (pWindow && pWindow->_pMarkup)
            pWindow->_pMarkup->ShowWaitCursor(FALSE);
    }
    
    _fHardStopDone = !fSoftStop;

    _fStopDone = TRUE;

    if (pDBTask)
    {
        pDBTask->Stop();
    }

    if (HtmCtx())
    {
        // fFireOnStop indicates that Stop button was pressed.
        if (fSoftStop)
        {
            // If the document was opened through script, don't let the stop
            // button interfere pressed.
            if (HtmCtx()->IsOpened())
            {
                return(S_OK);
            }
            HtmCtx()->DoStop(); // Do a "soft" stop instead of a "hard" SetLoad(FALSE)
        }
        else
        {
            HtmCtx()->SetLoad(FALSE, NULL, FALSE);

        }
    }

    if (    pDoc->_pWindowPrimary
        &&  !pDoc->_pWindowPrimary->IsPassivating()
        &&  IsPrimaryMarkup())
    {
        pDoc->StopUrlImgCtx(this);

        if (TLS(pImgAnim))  // TODO (lmollico): should stop animation for this markup only
        {
            TLS(pImgAnim)->SetAnimState((DWORD_PTR) pDoc, ANIMSTATE_STOP);   // Stop img animation
        }

        for (i = 0; i < pDoc->_aryChildDownloads.Size(); i++)
        {
            pDoc->_aryChildDownloads[i]->Terminate();
        }
        pDoc->_aryChildDownloads.DeleteAll();
    }

    StopPeerFactoriesDownloads();
    if (fSendNot && Root())
    {
        if (pDoc->_fBroadcastStop || 
            pDoc->_fHasViewSlave ||
            (GetProgSinkC() && GetProgSinkC()->GetClassCounter((DWORD)-1)))
        {
            nf.Stop1(Root());
            Notify(&nf);
        }
    }

    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal), 0);
    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }
    
    IGNORE_HR(pDoc->CommitDeferredScripts(0, this));    // TODO (lmollico): fix this

    if (fFireOnStop && pDocument)
        pDocument->Fire_onstop();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecRefreshCallback
//
//  Synopsis:   ExecRefresh, but in a GWPostMethodCall compatible format
//
//--------------------------------------------------------------------------

void
COmWindowProxy::ExecRefreshCallback(DWORD_PTR dwOleCmdidf)
{
    IGNORE_HR(ExecRefresh((LONG) dwOleCmdidf));
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecRefresh
//
//  Synopsis:   Refresh form
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::ExecRefresh(LONG lOleCmdidf)
{
    IStream *   pStream     = NULL;
    DWORD       dwBindf;
    HRESULT     hr          = S_OK;
    CMarkup *   pMarkupNew  = NULL;
    CMarkup *   pMarkupOld  = Markup();
    CDoc *      pDoc        = pMarkupOld->_pDoc;
    LPCTSTR     pchCreatorUrl;
    CMarkup*    pSelectionMarkup;
    IMoniker *  pMoniker = NULL;

    #if DBG==1
    TraceTag((tagDocRefresh, "ExecRefresh(%lX) %ls", lOleCmdidf,
        CMarkup::GetUrl(pMarkupOld) ? CMarkup::GetUrl(pMarkupOld) : g_Zero.ach));
    TraceTag((tagDocRefresh, "    %s",
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_NORMAL) ?
            "OLECMDIDF_REFRESH_NORMAL (!! AOL Compat)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_NO_CACHE) ?
            "OLECMDIDF_REFRESH_NO_CACHE (F5)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_COMPLETELY) ?
            "OLECMDIDF_REFRESH_COMPLETELY (ctrl-F5)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_IFEXPIRED) ?
            "OLECMDIDF_REFRESH_IFEXPIRED (same as OLECMDIDF_REFRESH_RELOAD)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_CONTINUE) ?
            "OLECMDIDF_REFRESH_CONTINUE (same as OLECMDIDF_REFRESH_RELOAD)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_RELOAD) ?
            "OLECMDIDF_REFRESH_RELOAD (no forced cache validation)" :
            "?? Unknown OLECMDIDF_REFRESH_* level"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_PROMPTIFOFFLINE)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_PROMPTIFOFFLINE"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_CLEARUSERINPUT)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_CLEARUSERINPUT"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_THROUGHSCRIPT)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_THROUGHSCRIPT"));    
    #endif

    pMarkupOld->AddRef();

    if (pDoc->_fInHTMLDlg || !Fire_onbeforeunload()) // No refresh in dialog
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if ((lOleCmdidf & OLECMDIDF_REFRESH_PROMPTIFOFFLINE) && pDoc->_pClientSite)
    {
        CTExec(pDoc->_pClientSite, NULL, OLECMDID_PREREFRESH, 0, NULL, NULL);
    }

    switch (lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK)
    {
        case OLECMDIDF_REFRESH_NORMAL:
            dwBindf = BINDF_RESYNCHRONIZE;
            break;
        case OLECMDIDF_REFRESH_NO_CACHE:
            dwBindf = BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE;
            break;
        case OLECMDIDF_REFRESH_COMPLETELY:
            dwBindf = BINDF_GETNEWESTVERSION|BINDF_PRAGMA_NO_CACHE;
            break;
        default:
            dwBindf = 0;
            break;
    }

    pDoc->_fFirstTimeTab = IsInIEBrowser(pDoc);

    //
    // The Java VM needs to know when a refresh is
    // coming in order to clear its internal cache
    //

    if (pDoc->_fHasOleSite)
    {
        CNotification   nf;

        nf.BeforeRefresh(pMarkupOld->Root(), (void *)(DWORD_PTR)(lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK));
        pMarkupOld->Notify(&nf);
    }

    //
    // Save the current doc state into a history stream
    //

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    // note that ECHOHEADERS only has an effect if the original response for this page was a 449 response

    hr = THR(pMarkupOld->SaveHistoryInternal(pStream,
                SAVEHIST_ECHOHEADERS |
                ((lOleCmdidf & OLECMDIDF_REFRESH_CLEARUSERINPUT) ? 0 : SAVEHIST_INPUT)));
    if (hr)
        goto Cleanup;

    // Stop the current bind
    hr = THR(pMarkupOld->ExecStop(FALSE, FALSE, FALSE));
    if( hr )
        goto Cleanup;

    // If this is a top level navigation, then 
    // 1. If it is user initiated, reset the list ELSE
    // 2. Add a blank record to demarcate the set of urls pertaining to this new top level url
    if (pMarkupOld->IsPrimaryMarkup() && !pDoc->_fViewLinkedInWebOC)
    {
        if (lOleCmdidf & OLECMDIDF_REFRESH_THROUGHSCRIPT)
            THR(pDoc->AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
        else
            THR(pDoc->ResetPrivacyList());
    }

    IGNORE_HR(pDoc->GetSelectionMarkup(&pSelectionMarkup));
    if (    pMarkupOld->IsPrimaryMarkup()
        ||  (pDoc->_pElemCurrent && pDoc->_pElemCurrent->IsConnectedToThisMarkup(pMarkupOld))
        ||  (pSelectionMarkup    && pSelectionMarkup->GetElementTop()->IsConnectedToThisMarkup(pMarkupOld)))
    {
        pDoc->_fForceCurrentElem = TRUE;         // make sure next call succeeds
        pMarkupOld->Root()->BecomeCurrent(0);
        pDoc->_fForceCurrentElem = FALSE;
    }

    if (_fFiredOnLoad)
    {
        _fFiredOnLoad = FALSE;

        {
            COmWindowProxy::CLock Lock(this);
            Fire_onunload();
    
            if (!pMarkupOld->Window())
            {
                // The old markup has been navigated. Just bail out!
                goto Cleanup;
            }
        }
    }

    hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkupOld->Window());
    if (hr)
        goto Cleanup;

    pMarkupNew->_fInRefresh = TRUE;

    pchCreatorUrl = pMarkupOld->GetAAcreatorUrl();
    if (pchCreatorUrl && *pchCreatorUrl)
        pMarkupNew->SetAAcreatorUrl(pchCreatorUrl);

    pMoniker = pMarkupOld->GetNonRefdMonikerPtr();
    if (pMoniker)
        pMoniker->AddRef();

    SwitchMarkup(pMarkupNew);

    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, NULL, dwBindf, pMoniker, NULL, NULL, 0));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);
    ReleaseInterface(pMoniker);
    pMarkupOld->Release();
    if (pMarkupNew)
    {
        pMarkupNew->_fSafeToUseCalcSizeHistory = FALSE;
        pMarkupNew->Release();
    }
    RRETURN1(hr,S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::UpdateCodePageMetaTag
//
//  Synopsis:   Update or create a META tag for the document codepage.
//
//---------------------------------------------------------------

static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}

HRESULT
CMarkup::UpdateCodePageMetaTag(CODEPAGE codepage)
{
    HRESULT        hr = S_OK;
    TCHAR          achContentNew [ 256 ];
    TCHAR          achCharset[ MAX_MIMECSET_NAME ];
    CMetaElement * pMeta;
    AAINDEX        iCharsetIndex;

    hr = GetMlangStringFromCodePage(codepage, achCharset,
                                    ARRAY_SIZE(achCharset));
    if (hr)
        goto Cleanup;

    hr = THR(
        LocateOrCreateHeadMeta(LocateCodepageMeta, &pMeta, FALSE));

    if (hr || !pMeta)
        goto Cleanup;

    // If the meta tag is already for the same codepage, leave the original form
    //  intact.
    if( pMeta->GetCodePageFromMeta( ) == codepage )
        goto Cleanup;

    hr = THR(
        pMeta->AddString(
            DISPID_CMetaElement_httpEquiv, _T( "Content-Type" ),
            CAttrValue::AA_Attribute ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Format(
            0, achContentNew, ARRAY_SIZE( achContentNew ),
            _T( "text/html; charset=<0s>" ), achCharset ) );

    if (hr)
        goto Cleanup;

    hr = THR( pMeta->SetAAcontent( achContentNew ) );

    if (hr)
        goto Cleanup;

    // If the meta was of the form <META CHARSET=xxx>, convert it to the new form.
    iCharsetIndex = pMeta->FindAAIndex( DISPID_CMetaElement_charset, CAttrValue::AA_Attribute );
    if( iCharsetIndex != AA_IDX_UNKNOWN )
    {
        pMeta->DeleteAt( iCharsetIndex );
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::HaveCodePageMetaTag
//
//  Synopsis:   Returns TRUE if the doc has a meta tag specifying
//              a codepage.
//
//---------------------------------------------------------------

BOOL
CMarkup::HaveCodePageMetaTag()
{
    CMetaElement *pMeta;

    return LocateHeadMeta(LocateCodepageMeta, &pMeta) == S_OK &&
           pMeta;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InitNew, IPersistStreamInit
//
//  Synopsis:   Initialize ole state of control. Overriden to allow this to
//              occur after already initialized or loaded (yuck!). From an
//              OLE point of view this is totally illegal. Required for
//              MSHTML classic compat.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InitNew()
{
    LOADINFO LoadInfo = { 0 };
    CROStmOnBuffer stm;
    HRESULT hr;

    if (_fPopupDoc)
    {
        hr = THR(stm.Init((BYTE *)"<html><body></body></html>", 26));
    }
    else if (GetDefaultBlockTag() == ETAG_DIV)
    {
        hr = THR(stm.Init((BYTE *)"<div>&nbsp;</div>", 17));
    }
    else
    {
        hr = THR(stm.Init((BYTE *)"<p>&nbsp;</p>", 13));
    }

    if (hr)
        goto Cleanup;

    LoadInfo.pstm  = &stm;
    LoadInfo.fSync = TRUE;

    hr = THR(LoadFromInfo(&LoadInfo));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnsureDirtyStream
//
//  Synopsis:   Save to dirty stream if needed. Create the dirty stream
//              if it does not already exist.
//
//---------------------------------------------------------------

HRESULT
CMarkup::EnsureDirtyStream()
{
    CDoc * pDoc = Doc();
    HRESULT hr = S_OK;

    // if we're in design mode and we're dirty
    if (_fDesignMode)
    {
        IStream * pStmDirty = GetStmDirty();

        if (pDoc->IsDirty() != S_FALSE)
        {        
            // Since we are dirty in design mode we have to persist
            // ourselves out to a temporary file

            //
            // If the stream is read only, release it because we'll
            // want to create a read-write one in a moment.
            //

            if (pStmDirty)
            {
                STATSTG stats;

                hr = THR(pStmDirty->Stat(&stats, STATFLAG_DEFAULT));

                if (stats.grfMode == STGM_READ || FAILED(hr))
                {
                    ReleaseInterface(pStmDirty);
                    hr = SetStmDirty(NULL);
                    if (hr)
                        goto Cleanup;
                }
            }

            //
            // If we don't have a stream, create a read-write one.
            //

            if (!GetStmDirty())
            {
                TCHAR achFileName[MAX_PATH];
                TCHAR achPathName[MAX_PATH];
                DWORD dwRet;

                dwRet = GetTempPath(ARRAY_SIZE(achPathName), achPathName);
                if (!(dwRet && dwRet < ARRAY_SIZE(achPathName)))
                    goto Cleanup;

                if (!GetTempFileName(achPathName, _T("tri"), 0, achFileName))
                    goto Cleanup;

                hr = THR(CreateStreamOnFile(
                         achFileName,
                         STGM_READWRITE | STGM_SHARE_DENY_WRITE |
                                 STGM_CREATE | STGM_DELETEONRELEASE,
                         &pStmDirty));
                if (hr)
                    goto Cleanup;

                hr = SetStmDirty(pStmDirty);
                if (hr)
                    goto Cleanup;
            }

            ULARGE_INTEGER   luZero = {0, 0};

            hr = THR(pStmDirty->SetSize(luZero));
            if (hr)
                goto Cleanup;

            hr  = THR(SaveToStream(pStmDirty));
        }
        else
        {
            // Since we are in design mode, and are not dirty, our dirty
            // stream is probably stale.  Clear it here.
            ReleaseInterface(pStmDirty);
            hr = SetStmDirty(NULL);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetHtmSourceText
//
//  Synopsis:   Get the decoded html source text specified
//
//---------------------------------------------------------------
HRESULT
CDoc::GetHtmSourceText(ULONG ulStartOffset, ULONG ulCharCount, WCHAR *pOutText, ULONG *pulActualCharCount)
{
    HRESULT hr;

    Assert(CMarkup::HtmCtxHelper(PrimaryMarkup()));

    if (!CMarkup::HtmCtxHelper(PrimaryMarkup()))
    {
        RRETURN(E_FAIL);
    }

    hr = THR(CMarkup::HtmCtxHelper(PrimaryMarkup())->ReadUnicodeSource(pOutText, ulStartOffset, ulCharCount,
                pulActualCharCount));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetDownloadNotify
//
//  Synopsis:   Sets the Download Notify callback object
//              to be used next time the document is loaded
//
//---------------------------------------------------------------
HRESULT
CDoc::SetDownloadNotify(IUnknown *punk)
{
    IDownloadNotify *pDownloadNotify = NULL;
    HRESULT hr = S_OK;

    if (punk)
    {
        hr = THR(punk->QueryInterface(IID_IDownloadNotify, (void**) &pDownloadNotify));
        if (hr)
            goto Cleanup;
    }

    ReleaseInterface(_pDownloadNotify);
    _pDownloadNotify = pDownloadNotify;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetViewSourceFileName
//
//  Synopsis:   Get the fully qualified name of the file to display when the
//              user wants to view source.
//
//---------------------------------------------------------------

HRESULT
CDoc::GetViewSourceFileName(TCHAR * pszPath, CMarkup * pMarkup)
{
    Assert(pszPath);

    HRESULT hr;
    IStream *pstm = NULL;
    TCHAR achFileName[MAX_PATH];
    TCHAR * pchFile = NULL;
    CStr cstrVSUrl;
    IStream * pStmDirty = NULL;

    hr = THR(pMarkup->EnsureDirtyStream());
    if (hr)
        RRETURN(hr);

    pStmDirty = pMarkup->GetStmDirty();

    achFileName[0] = 0;

    if (pStmDirty)
    {
        STATSTG statstg;

        hr = THR(pStmDirty->Stat(&statstg, STATFLAG_DEFAULT));
        if (SUCCEEDED(hr) && statstg.pwcsName)
        {
            _tcscpy(pszPath, statstg.pwcsName);
            CoTaskMemFree( statstg.pwcsName );
        }
    }
    else if (pMarkup->HtmCtx())
    {
        // Use original filename, if it exists, Otherwise, use temporily file name
        if (IsAggregatedByXMLMime())
            hr = pMarkup->HtmCtx()->GetPretransformedFile(&pchFile);
        else
            hr = pMarkup->HtmCtx()->GetFile(&pchFile);
        if (!hr)
        {
            //
            //  If URL "file:" protocol and the document wasn't document.open()ed
            //  then use the original file name and path.Otherwise, use temp path
            //
            if (    !pMarkup->HtmCtx()->WasOpened()
                &&  GetUrlScheme(CMarkup::GetUrl(pMarkup)) == URL_SCHEME_FILE
                )
            {
                _tcsncpy(pszPath, pchFile, MAX_PATH);
                pszPath[MAX_PATH-1] = _T('\0');
                goto Cleanup;
            }
        }
        else
        {
            // Continue
            hr = S_OK;
        }
    }
    else
    {
        AssertSz(0, "EnsureDirtyStream failed to create a stream when no original was available.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // We have either a pstmDirty or a pHtmCtx, but no file yet,
    // so create a temp file and write into it
    //
    cstrVSUrl.Set(_T("view-source:"));
    cstrVSUrl.Append(CMarkup::GetUrl(pMarkup));
    if (!CreateUrlCacheEntry(cstrVSUrl, 0, NULL, achFileName, 0))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CreateStreamOnFile(
             achFileName,
             STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
             &pstm));
    if (hr)
        goto Cleanup;

    if (pStmDirty)
    {
        ULARGE_INTEGER uliSize;

        hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_END, &uliSize));
        if (hr)
            goto Cleanup;

        hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        if (hr)
            goto Cleanup;

        hr = THR(pStmDirty->CopyTo(pstm, uliSize, NULL, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert(pMarkup->HtmCtx());
        if (!pMarkup->HtmCtx()->IsSourceAvailable())
        {
            hr = THR(SaveToStream(pstm, 0, pMarkup->GetCodePage()));
        }
        else
        {
            DWORD dwFlags = HTMSRC_FIXCRLF | HTMSRC_MULTIBYTE;
            if (IsAggregatedByXMLMime())
                dwFlags |= HTMSRC_PRETRANSFORM;
            hr = THR(pMarkup->HtmCtx()->CopyOriginalSource(pstm, dwFlags));
        }
        if (hr)
            goto Cleanup;
    }

    _tcscpy(pszPath, achFileName);

    hr = CloseStreamOnFile(pstm);
    if (hr)
        goto Cleanup;

    FILETIME fileTime;
    fileTime.dwLowDateTime = 0;
    fileTime.dwHighDateTime = 0;
    if (!CommitUrlCacheEntry(cstrVSUrl,
                             achFileName,
                             fileTime,
                             fileTime,
                             NORMAL_CACHE_ENTRY,
                             NULL,
                             0,
                             NULL,
                             0))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    MemFreeString(pchFile);
    ReleaseInterface(pstm);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SavePretransformedSource
//
//  Synopsis:   Save the pre-transformed, pre-html file if any. For mime filters.
//
//---------------------------------------------------------------
HRESULT
CDoc::SavePretransformedSource(CMarkup * pMarkup, BSTR bstrPath)
{
    HRESULT hr = E_FAIL;

    if (    CMarkup::HtmCtxHelper(pMarkup)
        &&  CMarkup::HtmCtxHelper(pMarkup)->IsSourceAvailable())
    {
        IStream *pIStream = NULL;
        LPTSTR pchPathTgt = bstrPath;
        LPTSTR pchPathSrc = NULL;

        // first see if it's the same file, we can't both create a read and write stream, so do nothing
        // both files should be canonicalized
        hr = CMarkup::HtmCtxHelper(pMarkup)->GetPretransformedFile(&pchPathSrc);
        if (hr)
            goto CleanUp;

        if (0 == StrCmpI(pchPathTgt, pchPathSrc))
        {
            hr = S_OK;
            goto CleanUp;
        }

        // create the output stream
        hr = THR(CreateStreamOnFile(pchPathTgt, STGM_READWRITE | STGM_CREATE, &pIStream));
        if (hr)
            goto CleanUp;
            
        // copy the pretransformed source into it
        hr = THR(CMarkup::HtmCtxHelper(pMarkup)->CopyOriginalSource(pIStream, HTMSRC_PRETRANSFORM));

CleanUp:
        ReleaseInterface(pIStream);
        MemFreeString(pchPathSrc);
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     LoadFromInfo
//
//  Synopsis:   Workhorse method which loads (or reloads) the document.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromInfo(LOADINFO * pLoadInfo, CMarkup** ppMarkup )
{
    LOADINFO            LoadInfo          = *pLoadInfo;
    DWORD               dwBindf           = 0;
    CDwnBindInfo *      pDwnBindInfo      = NULL;
    HRESULT             hr;
    CROStmOnBuffer *    prosOnBuffer      = NULL;
    TCHAR *             pchTask           = NULL;
    const TCHAR *       pchUrl;
    CMarkup *           pMarkup           = PrimaryMarkup();
    TCHAR *             pszCookedHTML     = NULL;
    BSTR                bstrUrlOrig       = NULL;
    int                 cbCookedHTML;

    Assert(_pWindowPrimary);

    LoadInfo.fCDocLoad = TRUE;

    // Don't allow re-entrant loading of the document

    if (TestLock(FORMLOCK_LOADING))
        return(E_PENDING);

    CLock Lock(this, FORMLOCK_LOADING);

    PerfDbgLog(tagPerfWatch, this, "+CDoc::LoadFromInfo");
    TraceTag((tagCDoc, "%lx CDoc::LoadFromInfo URL=%ls", this, pLoadInfo->pchDisplayName));

    //
    // Grab refs before any "goto Cleanup"s
    // Don't put any failure code above these addrefs
    //

    if (LoadInfo.pstm)
        LoadInfo.pstm->AddRef();
    if (LoadInfo.pmk)
        LoadInfo.pmk->AddRef();

    if (    pMarkup->_LoadStatus != LOADSTATUS_UNINITIALIZED
        ||  pMarkup->IsStreaming())
    {
        BOOL fDesignModeOld = pMarkup->_fDesignMode;

        // freeze the old markup and nuke any pending readystate changes
        pMarkup->ExecStop(FALSE, FALSE);

        hr = CreateMarkup(&pMarkup, NULL, NULL, FALSE, _pWindowPrimary);
        if (hr)
            goto Cleanup;

        // Check to see if this is a window.open case. If so,
        // switch the markup now so that we won't have any
        // issues with accessing the window object's OM
        // after calling window.open.
        //
        if (LoadInfo.pbctx)
        {
            IUnknown * punkBindCtxParam = NULL;

            hr = LoadInfo.pbctx->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
            if (SUCCEEDED(hr))
            {
                punkBindCtxParam->Release();

                LoadInfo.fShdocvwNavigate = TRUE;
                pMarkup->_fNewWindowLoading = TRUE;

                // HACKHACK (jbeda) IE5.5 110944
                // If PICS is turned on we want
                // to do this navigation async.  This
                // opens up places where the OM isn't
                // consistent, but we have no other option
                // this late in the game.
                if (_pClientSite && !(_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
                {
                    VARIANT varPics = {0};
                    IGNORE_HR(CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_ISPICSENABLED, 
                                     0, NULL, &varPics));
                    if (V_VT(&varPics) == VT_BOOL && V_BOOL(&varPics) == VARIANT_TRUE)
                    {
                        CMarkup * pPrimary = PrimaryMarkup();

                        LoadInfo.fStartPicsCheck = TRUE;

                        if (pPrimary)
                        {
                            // Set a flag on this special blank markup
                            pPrimary->_fPICSWindowOpenBlank = TRUE;
                        }
                            
                    }
                }
                
                if (!LoadInfo.fStartPicsCheck)
                    _pWindowPrimary->SwitchMarkup(pMarkup);
            }
        }

        // if this is an HTA document, the newly created markup should be trusted.
        pMarkup->SetMarkupTrusted(_fHostedInHTA);

        pMarkup->_fDesignMode = fDesignModeOld;

        pMarkup->Release();
    }
    else if (_fInTrustedHTMLDlg)
    {
        pMarkup->SetMarkupTrusted(TRUE);
    }

    //
    // Take ownership of any memory passed in before "goto Cleanup"s
    // Don't put any failure code above these assignments
    //
    pLoadInfo->pbRequestHeaders = NULL;
    pLoadInfo->cbRequestHeaders = 0;

    //
    //
    // Handle FullWindowEmbed special magic:
    //
    if (_fFullWindowEmbed && LoadInfo.pchDisplayName && !LoadInfo.pstmDirty)
    {
        // Synthesize the html which displays the plugin imbedded:
        // Starts with a Unicode BOM (byte order mark) to identify the buffer
        // as containing Unicode.
        static TCHAR altData[] =
         _T(" <<html><<body leftmargin=0 topmargin=0 scroll=no> <<embed width=100% height=100% fullscreen=yes src=\"<0s>\"><</body><</html>");
        altData[0] = NATIVE_UNICODE_SIGNATURE;

        // Create our cooked up HTML, which is an embed tag with src attr set to the current URL
        hr = Format( FMT_OUT_ALLOC, &pszCookedHTML, 0, altData, LoadInfo.pchDisplayName );
        if( FAILED( hr ) )
            goto Cleanup;
        cbCookedHTML = _tcslen( pszCookedHTML );

        // Create a stream onto that string.  Note that this CROStmOnBuffer::Init() routine
        // duplicates the string and owns the new version.  Thus it is safe to pass it this
        // local scope string buffer.
        prosOnBuffer = new CROStmOnBuffer;
        if (prosOnBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = prosOnBuffer->Init( (BYTE*)pszCookedHTML, cbCookedHTML*sizeof(TCHAR) );
        if (hr)
            goto Cleanup;

        // We may need some information stored in CDwnBindInfo when we
        // start loading up the plugin site.
        if (LoadInfo.pbctx)
        {
            IUnknown *pUnk = NULL;
            LoadInfo.pbctx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);
            if (pUnk)
            {
                pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);
                ReleaseInterface(pUnk);
            }
            if (pDwnBindInfo)
            {
                // Get content type and cache filename of plugin data.
                _cstrPluginContentType.Set(pDwnBindInfo->GetContentType());
                _cstrPluginCacheFilename.Set(pDwnBindInfo->GetCacheFilename());
                pDwnBindInfo->Release();
                pDwnBindInfo = NULL;
            }
        }

        Assert( LoadInfo.pstmDirty == NULL );
        ReleaseInterface( LoadInfo.pstmDirty );  // just in case.
        LoadInfo.pstmDirty = prosOnBuffer;
    }

    dwBindf = LoadInfo.dwBindf;

    // Extract the client site from the bind context and set it (if available).
    // It is not an error not to be able to do this.

    if (LoadInfo.pbctx)
    {
        IUnknown* pUnkParam = NULL;
        LoadInfo.pbctx->GetObjectParam(WSZGUID_OPID_DocObjClientSite,
                                        &pUnkParam);
        if( pUnkParam )
        {
            IOleClientSite* pOleClientSite = NULL;

            pUnkParam->QueryInterface(IID_IOleClientSite,
                                       (void**)&pOleClientSite);
            ReleaseInterface(pUnkParam);

            if (pOleClientSite)
            {
                hr = THR(SetClientSite(pOleClientSite));
                pOleClientSite->Release();
                if (FAILED(hr))
                    goto Cleanup;
            }
        }

        //
        // Detect if shdocvw CoCreated trident if so then the bctx with have the
        // special string __PrecreatedObject.  If that is so then we don't want
        // to blow away the expando when the document is actually loaded (just
        // in case expandos were created on the window prior to loading).
        //
        hr = LoadInfo.pbctx->GetObjectParam(_T("__PrecreatedObject"), &pUnkParam);
        if (!hr)
        {
            ReleaseInterface(pUnkParam);

            // Signal we were precreated.
            pMarkup->_fPrecreated = TRUE;
        }
    }

    Assert(!LoadInfo.pchUrlOriginal);
    if (_pTridentSvc)
    {
        // Get the original url from shdocvw and store it in pchUrlOriginal
        if (S_OK == _pTridentSvc->GetPendingUrl(&bstrUrlOrig))
        {
            LoadInfo.pchUrlOriginal = bstrUrlOrig;
        }
    }

    // Load preferences from the registry if we haven't already
    if (!_fGotAmbientDlcontrol)
    {
        SetLoadfFromPrefs();
    }

    // Create CVersions object if we haven't already
    if (!_pVersions)
    {
        hr = THR(QueryVersionHost());
        if (hr)
            goto Cleanup;
    }

    if (_pWindowPrimary->_fFiredOnLoad)
    {
        _pWindowPrimary->_fFiredOnLoad = FALSE;
        {
            CDoc::CLock Lock(this);
            _pWindowPrimary->Fire_onunload();
        }
    }

    // Free the undo buffer before unload the contents

    FlushUndoData();

    // We are during loading and codepage might not be updated yet.
    // Clear this flag so we won't ignore META tag during reloading.
    if (    pMarkup->GetDwnDoc()
        &&  !(pMarkup->GetDwnDoc()->GetLoadf() & DLCTL_NO_METACHARSET))
    {
        LoadInfo.fNoMetaCharset = FALSE;
    }

    //
    // At this point, we should be defoliated.  Start up a new tree.
    //

    Assert(PrimaryRoot());

    // Right now the globe should not be spinning.
    //
    if (_fSpin)
    {
        SetSpin(FALSE);
    }

    // It's a go for loading, so say we're loaded

    if (_state < OS_LOADED)
        _state = OS_LOADED;

#if DBG==1
    DebugSetTerminalServer();
#endif

    // Set the document's URL and moniker

    if (!pMarkup->HasUrl())
    {
        if (!LoadInfo.pmk)
        {
            hr = THR(SetUrl(pMarkup, _T("about:blank")));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchTask));
            if (hr)
                goto Cleanup;

            // now chop of #location part, if any
            TCHAR *pchLoc = const_cast<TCHAR *>(UrlGetLocation(pchTask));
            if (pchLoc)
                *pchLoc = _T('\0');

            hr = THR(SetUrl(pMarkup, pchTask));
            if (hr)
                goto Cleanup;

            DeferUpdateTitle();

            hr = THR( pMarkup->ReplaceMonikerPtr( LoadInfo.pmk ) );
            if( hr )
                goto Cleanup;
        }
    }
    pchUrl = GetPrimaryUrl();

    Assert(!!pchUrl);
    MemSetName((this, "CDoc SSN=%d URL=%ls", _ulSSN, pchUrl));

    IGNORE_HR(CompatBitsFromUrl((TCHAR *) pchUrl, &_dwCompat));

    // The default document direction is LTR. Only set this if the document is RTL
    _pWindowPrimary->Document()->_eHTMLDocDirection = (unsigned) LoadInfo.eHTMLDocDirection;

    _fInIEBrowser = IsInIEBrowser(this);

    hr = THR(pMarkup->LoadFromInfo(&LoadInfo, NULL, LoadInfo.pchUrlOriginal));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

Cleanup:
    if ( ppMarkup && hr == S_OK )
    {
        *ppMarkup = pMarkup;
    }
    
    SysFreeString(bstrUrlOrig);
    ReleaseInterface(LoadInfo.pstm);
    ReleaseInterface(LoadInfo.pmk);
    ReleaseInterface((IBindStatusCallback *)pDwnBindInfo);
    ReleaseInterface(prosOnBuffer);
    ReleaseInterface((IUnknown *)LoadInfo.pDwnPost);
    MemFree(LoadInfo.pbRequestHeaders);
    MemFree(LoadInfo.pchSearch);
    CoTaskMemFree(pchTask);
    delete pszCookedHTML;

    //
    // If everything went A-OK, transition to the running state in
    // case we haven't done so already. Set active object if the
    // doc is ui-activate (fix for #49313, #51062)

    if (OK(hr))
    {
        if (State() < OS_RUNNING)
        {
            IGNORE_HR(TransitionTo(OS_RUNNING));
        }
        else if (State() >= OS_UIACTIVE)
        {
            SetActiveObject();
        }
    }

    PerfDbgLog(tagPerfWatch, this, "-CDoc::LoadFromInfo");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveSelection
//
//  Synopsis:   saves the current selection into
//              a file. The created file is an independent
//              .HTM file on it's own
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SaveSelection(TCHAR *pszFileName)
{
    HRESULT     hr = E_FAIL;
    IStream     *pStm = NULL;

    if (pszFileName && HasTextSelection())
    {
        // so there is a current selection, go and create a stream
        // and call the stream helper

        hr = THR(CreateStreamOnFile(
                pszFileName,
                STGM_READWRITE | STGM_READWRITE | STGM_CREATE,
                &pStm));
        if (hr)
            goto Cleanup;

        hr = THR(SaveSelection(pStm));

        ReleaseInterface(pStm);
    }

Cleanup:

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveSelection
//
//  Synopsis:   saves the current selection into
//              a stream. The created stream is saved in HTML format//
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SaveSelection(IStream *pstm)
{
    HRESULT                 hr = E_FAIL;
    ISelectionServices      *pSelSvc = NULL;
    ISegment                *pISegment = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegmentList            *pSegmentList = NULL;
    
    if (pstm  && HasTextSelection())
    {
        DWORD dwFlags = RSF_SELECTION | RSF_CONTEXT;
        CMarkup * pMarkup = GetCurrentMarkup();

        hr = GetSelectionServices( &pSelSvc );
        if( hr || pSelSvc == NULL )
            goto Cleanup;

        hr = pSelSvc->QueryInterface( &pSegmentList );
        if( hr || pSegmentList == NULL )
            goto Cleanup;
            
        // so there is a current selection, go and get the text...
        // if there is a selection, we can safely assume (because
        // it is already checked in IsThereATextSelection)
        // that _pElemCurrent exists and is a txtSite
        
#if DBG == 1
        {
            BOOL fEmpty = FALSE;
            SELECTION_TYPE eType = SELECTION_TYPE_None;
            IGNORE_HR( pSegmentList->GetType( &eType ));
            IGNORE_HR( pSegmentList->IsEmpty( &fEmpty ) );
            Assert( eType == SELECTION_TYPE_Text && !fEmpty );
        }
#endif // DBG == 1

        {
            CStreamWriteBuff StreamWriteBuff(pstm, pMarkup->GetCodePage());

            hr = THR( StreamWriteBuff.Init() );
            if( hr )
                goto Cleanup;

            StreamWriteBuff.SetFlags(WBF_SAVE_SELECTION);

            // don't save databinding attributes during printing, so that we
            // print the current content instead of re-binding
            if (_fSaveTempfileForPrinting)
            {
                StreamWriteBuff.SetFlags(WBF_SAVE_FOR_PRINTDOC | WBF_NO_DATABIND_ATTRS);
                if (PrimaryMarkup() && PrimaryMarkup()->IsXML())
                    StreamWriteBuff.SetFlags(WBF_SAVE_FOR_XML);
            }

            if (!StreamWriteBuff.TestFlag(WBF_SAVE_FOR_PRINTDOC))
            {
                // HACK (cthrash) Force META tag persistance.
                //
                // Save any html header information needed for the rtf converter.
                // For now this is <HTML> and a charset <META> tag.
                //
                TCHAR achCharset[MAX_MIMECSET_NAME];

                if (GetMlangStringFromCodePage(pMarkup->GetCodePage(), achCharset,
                                               ARRAY_SIZE(achCharset)) == S_OK)
                {
                    DWORD dwOldFlags = StreamWriteBuff.ClearFlags(WBF_ENTITYREF);

                    StreamWriteBuff.Write(_T("<META CHARSET=\""));
                    StreamWriteBuff.Write(achCharset);
                    StreamWriteBuff.Write(_T("\">"));
                    StreamWriteBuff.NewLine();

                    StreamWriteBuff.RestoreFlags(dwOldFlags);
                }
            }

            // Create an interator for the segments
            hr = THR( pSegmentList->CreateIterator(&pIter) );
            if( hr || (pIter == NULL) )
                goto Cleanup;
            //
            // Save the segments using the range saver
            //
            while( pIter->IsDone() == S_FALSE )
            {
                CMarkupPointer mpStart(this), mpEnd(this);

                hr = THR( pIter->Current( &pISegment ) );
                if( FAILED(hr) )
                    goto Error;

                // Get the next element, because of continues in the 
                // while loop
                hr = THR( pIter->Advance() );
                if( FAILED(hr) )
                    goto Error;
                    
                hr = THR( pISegment->GetPointers( &mpStart, &mpEnd ) );
                if (S_OK == hr)
                {
                    // Skip saving text of password inputs.
                    CTreeNode * pNode = mpStart.Branch();
                    CElement * pElementContainer = pNode ? pNode->Element()->GetMasterPtr() : NULL;
                    if (   pElementContainer
                        && pElementContainer->Tag() == ETAG_INPUT
                        && htmlInputPassword == DYNCAST(CInput, pElementContainer)->GetType())
                    {
                        continue;
                    }
                }

                //
                // TODO - need to make range saver here use ISegmentList based saver
                //

                CRangeSaver rs( &mpStart, &mpEnd, dwFlags, &StreamWriteBuff, mpStart.Markup() );

                hr = THR( rs.Save());
                if (hr)
                    goto Error;

                ClearInterface( &pISegment );                    
            }

Error:
            StreamWriteBuff.Terminate();
        }
    }

Cleanup:
    ReleaseInterface( pSelSvc );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pISegment );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ClearDwnPost()
//
//  Synopsis:   Used to discard original post data that lead to the page.
//              Called after moniker has changed or after HTTP redirect.
//
//----------------------------------------------------------------------------

void
CMarkup::ClearDwnPost()
{
    CDwnPost * pDwnPost = GetDwnPost();

    if (pDwnPost)
    {
        pDwnPost->Release();
        IGNORE_HR(SetDwnPost(NULL));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::RestartLoad
//
//  Synopsis:   Reloads a doc from a DwnBindData in progress.
//
//-------------------------------------------------------------------------

HRESULT COmWindowProxy::RestartLoad(IStream *pstmLeader, CDwnBindData *pDwnBindData, CODEPAGE codepage)
{
    CStr cstrUrl;
    HRESULT hr;
    IStream * pStream = NULL;
    IStream * pstmRefresh;
    CMarkup * pMarkupNew = NULL;
    CMarkup * pMarkupOld = Markup();
    CDoc *    pDoc = pMarkupOld->Doc();
    CDwnDoc * pDwnDoc;

    hr = THR(cstrUrl.Set(CMarkup::GetUrl(pMarkupOld)));
    if (hr)
        goto Cleanup;

    //  are we going to a place already in the history?
    if (    pMarkupOld->HtmCtx()
        && ((pstmRefresh = pMarkupOld->HtmCtx()->GetRefreshStream()) != NULL))
    {
        hr = THR(pstmRefresh->Clone(&pStream));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        //
        // Save the current doc state into a history stream
        //

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkupOld->SaveHistoryInternal(pStream, 0));    //  Clear user input
        if (hr)
            goto Cleanup;

        hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        if (hr)
            goto Cleanup;
    }

    IGNORE_HR(pMarkupOld->ExecStop(FALSE, FALSE));

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkupOld->Window());
    if (hr)
        goto Cleanup;

    // Move the pics target over to the new markup if we are doing the first load
    // pics check.  If we aren't doing the first load check, we should have been cleared
    // by now when the post parser saw that we were restarting.
    if (pMarkupOld->HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = pMarkupOld->GetTransNavContext();
        if (ptnc->_pctPics)
        {
            IGNORE_HR(pMarkupNew->SetPicsTarget(ptnc->_pctPics));

            pMarkupOld->SetPicsTarget(NULL);
        }
    }

    pDwnDoc = pMarkupOld->GetDwnDoc();
    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, 
                                             NULL, 
                                             pDwnDoc ? (pDwnDoc->GetBindf() & BINDF_GETNEWESTVERSION) : 0, 
                                             pMarkupOld->GetNonRefdMonikerPtr(), 
                                             pstmLeader, 
                                             pDwnBindData, 
                                             codepage,
                                             NULL,
                                             CDoc::FHL_RESTARTLOAD));

    if (pMarkupOld->HasWindow())
        pMarkupOld->Window()->Window()->_fRestartLoad = TRUE;

    if (hr)
        goto Cleanup;

    if (pDoc->IsPrintDialog())
    {
        pMarkupNew->SetPrintTemplate(pMarkupOld->IsPrintTemplate());
        pMarkupNew->SetPrintTemplateExplicit(pMarkupOld->IsPrintTemplateExplicit());
    }

    SwitchMarkup(pMarkupNew, FALSE, 0, 0, TRUE);

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }
    ReleaseInterface(pStream);
    RRETURN(hr);
}

BOOL
CDoc::IsLoading()
{
    return (    CMarkup::HtmCtxHelper(PrimaryMarkup())
            &&  CMarkup::HtmCtxHelper(PrimaryMarkup())->IsLoading());
}

HRESULT
CDoc::NewDwnCtx(UINT dt, LPCTSTR pchSrc, CElement * pel, CDwnCtx ** ppDwnCtx, BOOL fPendingRoot, BOOL fSilent, DWORD dwProgsinkClass)
{
    HRESULT     hr;
    DWNLOADINFO dli       = { 0 };
    BOOL        fLoad     = TRUE;
    TCHAR   *   pchExpUrl = new TCHAR[pdlUrlLen];
    CMarkup *   pMarkup   = pel ? pel->GetMarkupForBaseUrl() : NULL;

    if (!pMarkup)
        pMarkup = PrimaryMarkup();

    if (pchExpUrl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppDwnCtx = NULL;

    if (pchSrc == NULL)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( pMarkup->InitDownloadInfo(&dli) );
    if( hr )
        goto Cleanup;

    hr = THR(CMarkup::ExpandUrl(
                pMarkup, pchSrc, pdlUrlLen, pchExpUrl, pel));
    if (hr)
        goto Cleanup;
        
    dli.pchUrl = pchExpUrl;
    dli.dwProgClass = dwProgsinkClass;

    if (!pMarkup->ValidateSecureUrl(fPendingRoot, (LPTSTR)dli.pchUrl, FALSE, fSilent))
    {
        hr = E_ABORT;
        goto Cleanup;
    }

    if (pMarkup && pMarkup->HtmCtx())
    {
        *ppDwnCtx = pMarkup->HtmCtx()->GetDwnCtx(dt, dli.pchUrl);

        if (*ppDwnCtx)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    if (dt == DWNCTX_IMG && !(_dwLoadf & DLCTL_DLIMAGES))
        fLoad = FALSE;

    if (pMarkup && pMarkup->LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        UINT uScheme = GetUrlScheme(dli.pchUrl);

        // (jbeda) 85899 
        // Don't do this for pluggable protocols since we have no way to verify modification times.
        if (uScheme == URL_SCHEME_FILE || uScheme == URL_SCHEME_HTTP || uScheme == URL_SCHEME_HTTPS)
        {
            // (dinartem) 39144
            // This flag tells the download mechanism not use the CDwnInfo cache until it has at
            // least verified that the modification time of the underlying bits is the same as the
            // cached version.  Normally we allow connection to existing images if they are on the
            // same page and have the same URL.  Once the page is finished loading and script makes
            // changes to SRC properties, we perform this extra check.

            dli.fResynchronize = TRUE;
        }
    }

    dli.fPendingRoot = fPendingRoot;

    hr = THR(::NewDwnCtx(dt, fLoad, &dli, ppDwnCtx));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pchExpUrl != NULL)
        delete pchExpUrl;
    RRETURN(hr);
}


HRESULT
CMarkup::InitDownloadInfo(DWNLOADINFO * pdli)
{
    HRESULT hr = S_OK;

    memset(pdli, 0, sizeof(DWNLOADINFO));
    pdli->pInetSess = TlsGetInternetSession();
    pdli->pDwnDoc = GetWindowedMarkupContext()->GetDwnDoc();

    if( !pdli->pDwnDoc )
        hr = E_UNEXPECTED;

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member: LocalAddDTI()
//
//  Synopsis:
//      Local helper function to call IActiveDesktop interface to add a
//      desktop item at the given location.
//
//-------------------------------------------------------------------------
#ifndef WINCE

static HRESULT LocalAddDTI(LPCTSTR pszUrl, HWND hwnd, int x, int y, int nType)
{
    HRESULT hr;
    IActiveDesktop * pad;
    COMPONENT comp = {
        sizeof(COMPONENT),  // Size of this structure
        0,                  // For Internal Use: Set it always to zero.
        nType,              // One of COMP_TYPE_*
        TRUE,               // Is this component enabled?
        FALSE,              // Had the component been modified and not yet saved to disk?
        FALSE,              // Is the component scrollable?
        {
            sizeof(COMPPOS),//Size of this structure
            x,              //Left of top-left corner in screen co-ordinates.
            y,              //Top of top-left corner in screen co-ordinates.
            (DWORD)-1,      // Width in pixels.
            (DWORD)-1,      // Height in pixels.
            10000,          // Indicates the Z-order of the component.
            TRUE,           // Is the component resizeable?
            TRUE,           // Resizeable in X-direction?
            TRUE,           // Resizeable in Y-direction?
            -1,             // Left of top-left corner as percent of screen width
            -1              // Top of top-left corner as percent of screen height
        },                  // Width, height etc.,
        _T("\0"),           // Friendly name of component.
        _T("\0"),           // URL of the component.
        _T("\0"),           // Subscrined URL.
        IS_NORMAL           // ItemState
    };

    StrCpyN(comp.wszSource, pszUrl, ARRAY_SIZE(comp.wszSource));
    StrCpyN(comp.wszFriendlyName, pszUrl, ARRAY_SIZE(comp.wszFriendlyName));
    StrCpyN(comp.wszSubscribedURL, pszUrl, ARRAY_SIZE(comp.wszSubscribedURL));

    if(SUCCEEDED(hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID *) &pad)))
    {
        hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);

        if (pad)
            pad->Release();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member: _CreateDeskItem_ThreadProc
//
//  Synopsis:
//        Local function that serves as the threadProc to add desktop item.
//      We need to start a thread to do this because it may take a while and
//      we don't want to block the UI thread because dialogs may be displayed.
//
//-------------------------------------------------------------------------

static DWORD CALLBACK _CreateDeskItem_ThreadProc(LPVOID pvCreateDeskItem)
{
    CREATEDESKITEM * pcdi = (CREATEDESKITEM *) pvCreateDeskItem;

    HRESULT hres = OleInitialize(0);
    if (SUCCEEDED(hres))
    {
        hres = LocalAddDTI(pcdi->pszUrl, pcdi->hwnd, pcdi->x, pcdi->y, pcdi->dwItemType);
        OleUninitialize();
    }

    if(pcdi->pszUrl)
        MemFree((void *)(pcdi->pszUrl));
    MemFree((void *)pcdi);
    return 0;
}
#endif //WINCE
//+------------------------------------------------------------------------
//
//  Member:     CreateDesktopComponents
//
//  Synopsis:
//        Create Desktop Components for one item.  We need to start
//    a thread to do this because it may take a while and we don't want
//    to block the UI thread because dialogs may be displayed.
//
//-------------------------------------------------------------------------

static HRESULT CreateDesktopItem(LPCTSTR pszUrl, HWND hwnd, DWORD dwItemType, int x, int y)
{
    HRESULT hr = E_OUTOFMEMORY;
#ifndef WINCE
    //The following are allocated here; But, they will be freed at the end of _CreateDeskComp_ThreadProc.
    CREATEDESKITEM * pcdi = (CREATEDESKITEM *)MemAlloc(Mt(SetAsDesktopItem), sizeof(CREATEDESKITEM));
    LPTSTR  lpszURL = (LPTSTR)MemAlloc(Mt(SetAsDesktopItem), sizeof(TCHAR)*(_tcslen(pszUrl)+1));

    // Create Thread....
    if (pcdi && lpszURL)
    {
        _tcscpy(lpszURL, pszUrl); //Make a temporary copy of the URL
        pcdi->pszUrl = (LPCTSTR)lpszURL;
        pcdi->hwnd = hwnd;
        pcdi->dwItemType = dwItemType;
        pcdi->x = x;
        pcdi->y = y;

        SHCreateThread(_CreateDeskItem_ThreadProc, pcdi, CTF_INSIST, NULL);
        hr = S_OK;
    }
    else
    {   
        // This fixes Prefix bug 7799 in which we can leak one of these or the other
        MemFree((void *) pcdi);
        MemFree((void *) lpszURL);
    }

#endif //WINCE
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\grab.cxx ===
//+------------------------------------------------------------------------
//
//  File:       grab.cxx
//
//  Contents:   Grab handle utilities
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifdef UNIX
extern "C" COLORREF MwGetTrueRGBValue(COLORREF crColor);
#endif

template < class T > void swap ( T & a, T & b ) { T t = a; a = b; b = t; }

struct HTCDSI
{
    short   htc;
    short   dsi;
};

static const HTCDSI s_aHtcDsi[] =
{
    {HTC_TOPLEFTHANDLE,     DSI_NOTOPHANDLES    | DSI_NOLEFTHANDLES     },
    {HTC_TOPHANDLE,         DSI_NOTOPHANDLES                            },
    {HTC_TOPRIGHTHANDLE,    DSI_NOTOPHANDLES    | DSI_NORIGHTHANDLES    },
    {HTC_LEFTHANDLE,                              DSI_NOLEFTHANDLES     },
    {HTC_RIGHTHANDLE,                             DSI_NORIGHTHANDLES    },
    {HTC_BOTTOMLEFTHANDLE,  DSI_NOBOTTOMHANDLES | DSI_NOLEFTHANDLES     },
    {HTC_BOTTOMHANDLE,      DSI_NOBOTTOMHANDLES                         },
    {HTC_BOTTOMRIGHTHANDLE, DSI_NOBOTTOMHANDLES | DSI_NORIGHTHANDLES    },
};

//+------------------------------------------------------------------------
//
//  Function:   ColorDiff
//
//  Synopsis:   Computes the color difference amongst two colors
//
//-------------------------------------------------------------------------
DWORD ColorDiff (COLORREF c1, COLORREF c2)
{
#ifdef UNIX
    if ( CColorValue(c1).IsMotifColor() ) {
        c1 = MwGetTrueRGBValue( c1 );
    }

    if ( CColorValue(c2).IsMotifColor() ) {
        c2 = MwGetTrueRGBValue( c2 );
    }
#endif

#define __squareit(n) ((DWORD)((n)*(n)))
    return (__squareit ((INT)GetRValue (c1) - (INT)GetRValue (c2)) +
            __squareit ((INT)GetGValue (c1) - (INT)GetGValue (c2)) +
            __squareit ((INT)GetBValue (c1) - (INT)GetBValue (c2)));
#undef __squareit
}

//+------------------------------------------------------------------------
//
//  Function:   PatBltRectH & PatBltRectV
//
//  Synopsis:   PatBlts the top/bottom and left/right.
//
//-------------------------------------------------------------------------
static void
PatBltRectH(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBlt(
            hDC,
            prc->left,
            prc->top,
            prc->right - prc->left,
            cThick,
            dwRop);

    PatBlt(
            hDC,
            prc->left,
            prc->bottom - cThick,
            prc->right - prc->left,
            cThick,
            dwRop);
}

static void
PatBltRectV(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBlt(
            hDC,
            prc->left,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            dwRop);

    PatBlt(
            hDC,
            prc->right - cThick,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            dwRop);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetGrabRect
//
//  Synopsis:   Compute grab rect for a given area.
//
//  Notes:      These diagrams show the output grab rect for handles and
//              borders.
//
//              -----   -----   -----               -------------
//              |   |   |   |   |   |               |           |
//              | TL|   | T |   |TR |               |     T     |
//              ----|-----------|----           ----|-----------|----
//                  |           |               |   |           |   |
//              ----| Input     |----           |   | Input     |   |
//              |   |           |   |           |   |           |   |
//              |  L|   RECT    |R  |           |  L|   RECT    |R  |
//              ----|           |----           |   |           |   |
//                  |           |               |   |           |   |
//              ----|-----------|----           ----|-----------|----
//              | BL|   | B |   |BR |               |     B     |
//              |   |   |   |   |   |               |           |
//              -----   -----   -----               -------------
//
//----------------------------------------------------------------------------

static void
GetGrabRect(HTC htc, RECT * prcOut, RECT * prcIn, LONG cGrabSize)
{
    switch (htc)
    {
    case HTC_TOPLEFTHANDLE:
    case HTC_LEFTHANDLE:
    case HTC_BOTTOMLEFTHANDLE:
    case HTC_GRPTOPLEFTHANDLE:
    case HTC_GRPLEFTHANDLE:
    case HTC_GRPBOTTOMLEFTHANDLE:
    case HTC_LEFTBORDER:
    case HTC_GRPLEFTBORDER:
        prcOut->left = prcIn->left - cGrabSize;
        prcOut->right = prcIn->left;
        break;

    case HTC_TOPHANDLE:
    case HTC_BOTTOMHANDLE:
    case HTC_GRPTOPHANDLE:
    case HTC_GRPBOTTOMHANDLE:
        prcOut->left = ((prcIn->left + prcIn->right) - cGrabSize) / 2;
        prcOut->right = prcOut->left + cGrabSize;
        break;

    case HTC_TOPRIGHTHANDLE:
    case HTC_RIGHTHANDLE:
    case HTC_BOTTOMRIGHTHANDLE:
    case HTC_GRPTOPRIGHTHANDLE:
    case HTC_GRPRIGHTHANDLE:
    case HTC_GRPBOTTOMRIGHTHANDLE:
    case HTC_RIGHTBORDER:
    case HTC_GRPRIGHTBORDER:
        prcOut->left = prcIn->right;
        prcOut->right = prcOut->left + cGrabSize;
        break;

    case HTC_TOPBORDER:
    case HTC_BOTTOMBORDER:
    case HTC_GRPTOPBORDER:
    case HTC_GRPBOTTOMBORDER:
        prcOut->left = prcIn->left;
        prcOut->right = prcIn->right;
        break;

    default:
        Assert(FALSE && "Unsupported HTC_ value in GetHandleRegion");
        return;
    }

    switch (htc)
    {
    case HTC_TOPLEFTHANDLE:
    case HTC_TOPHANDLE:
    case HTC_TOPRIGHTHANDLE:
    case HTC_GRPTOPLEFTHANDLE:
    case HTC_GRPTOPHANDLE:
    case HTC_GRPTOPRIGHTHANDLE:
    case HTC_TOPBORDER:
    case HTC_GRPTOPBORDER:
        prcOut->top = prcIn->top - cGrabSize;
        prcOut->bottom = prcIn->top;
        break;

    case HTC_LEFTHANDLE:
    case HTC_RIGHTHANDLE:
    case HTC_GRPLEFTHANDLE:
    case HTC_GRPRIGHTHANDLE:
        prcOut->top = ((prcIn->top + prcIn->bottom) - cGrabSize) / 2;
        prcOut->bottom = prcOut->top + cGrabSize;
        break;

    case HTC_BOTTOMLEFTHANDLE:
    case HTC_BOTTOMHANDLE:
    case HTC_BOTTOMRIGHTHANDLE:
    case HTC_GRPBOTTOMLEFTHANDLE:
    case HTC_GRPBOTTOMHANDLE:
    case HTC_GRPBOTTOMRIGHTHANDLE:
    case HTC_BOTTOMBORDER:
    case HTC_GRPBOTTOMBORDER:
        prcOut->top = prcIn->bottom;
        prcOut->bottom = prcOut->top + cGrabSize;
        break;

    case HTC_LEFTBORDER:
    case HTC_RIGHTBORDER:
    case HTC_GRPLEFTBORDER:
    case HTC_GRPRIGHTBORDER:
        prcOut->top = prcIn->top;
        prcOut->bottom = prcIn->bottom;
        break;

    default:
        Assert(FALSE && "Unsupported HTC_ value in GetHandleRegion");
        return;
    }

    if (prcOut->left > prcOut->right)
    {
        swap(prcOut->left, prcOut->right);
    }
    if (prcOut->top > prcOut->bottom)
    {
        swap(prcOut->top, prcOut->bottom);
    }
}


//+---------------------------------------------------------------------------
//
//  Global helpers.
//
//----------------------------------------------------------------------------

void
PatBltRect(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBltRectH(hDC, prc, cThick, dwRop);

    PatBltRectV(hDC, prc, cThick, dwRop);
}

void
DrawDefaultFeedbackRect(XHDC hDC, RECT * prc)
{
#ifdef NEVER
    HBRUSH  hbrOld = NULL;
    HBRUSH  hbr = GetCachedBmpBrush(IDR_FEEDBACKRECTBMP);

    hbrOld = (HBRUSH) SelectObject(hDC, hbr);
    if (!hbrOld)
        goto Cleanup;

    PatBltRect(hDC, prc, FEEDBACKRECTSIZE, PATINVERT);

Cleanup:
    if (hbrOld)
        SelectObject(hDC, hbrOld);
#endif        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\hedelems.cxx ===
//+---------------------------------------------------------------------
//
//   File:      hedelems.cxx
//
//  Contents:   Elements that are normally found in the HEAD of an HTML doc
//
//  Classes:    CMetaElement, CLinkElement, CIsIndexElement, CBaseElement, CNextIdElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_BUFFER_HXX_
#define X_BUFFER_HXX_
#include "buffer.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "hedelems.hdl"

MtDefine(CTitleElement,   Elements, "CTitleElement")
MtDefine(CMetaElement,    Elements, "CMetaElement")
MtDefine(CBaseElement,    Elements, "CBaseElement")
MtDefine(CIsIndexElement, Elements, "CIsIndexElement")
MtDefine(CNextIdElement,  Elements, "CNextIdElement")
MtDefine(CHeadElement,    Elements, "CHeadElement")
MtDefine(CHtmlElement,    Elements, "CHtmlElement")

//+------------------------------------------------------------------------
//
//  Class:      CHtmlElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

// The HTML element needs its own accelerator key table in strict CSS1 mode.
// We borrow the BODY's browse mode table definition.  <g>
// Since HTML layout is never used in design mode, it does not need a design mode set.
// Having a table should not impact the backwards compatible case.  (greglett) (ashrafm)
CElement::ACCELS CHtmlElement::s_AccelsHtmlRun    = CElement::ACCELS (&CElement::s_AccelsElementRun, IDR_ACCELS_BODY_RUN);

// NOTE (greglett)
// In BackCompat, HTML should never have a layout, hence the ELEMENTDESC_NOLAYOUT
// In CSS1 Strict Doctypes, it should always have a layout.
// This layoutness is hardwired into the ShouldHaveLayout functions.
const CElement::CLASSDESC CHtmlElement::s_classdesc =
{
    {
        &CLSID_HTMLHtmlElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLElement,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLElement,
    &CHtmlElement::s_AccelsHtmlRun          // _pAccelsRun
};


//+----------------------------------------------------------------
//
//  Member:   CHtmlElement::CreateElement
//
//---------------------------------------------------------------

HRESULT
CHtmlElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CHtmlElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CHtmlElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLHtmlElement, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+----------------------------------------------------------------
//
//  Member:   ApplyDefaultFormat
//
//  Synopsis: this is only interesting for the HTML element. in That
//            case, we apply in the attrarray from the document. this
//            allows for default values (like from the HTMLDlg code)
//            to be incorparated at this early point.
//
//---------------------------------------------------------------

HRESULT
CHtmlElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    BOOL            fHTMLLayout = GetMarkup()->IsHtmlLayout();

    Assert(pCFI && pCFI->_pNodeContext && SameScope(pCFI->_pNodeContext, this));

    // if we have history that saved document direction we begin the chain here
    // if direction has been explicitly set, this will be overridden.
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();
    if(GetMarkup() && GetMarkup()->Window())
    {
        WORD wDocDir = GetMarkup()->Document()->_eHTMLDocDirection;
        pCFI->_cf()._fRTL = (wDocDir == htmlDirRightToLeft);
        pCFI->_ff().SetExplicitDir(wDocDir != htmlDirNotSet);
    }
    else
    {
        pCFI->_cf()._fRTL = FALSE;
        pCFI->_ff().SetExplicitDir(FALSE);
    }
    pCFI->UnprepareForDebug();

          
    // In the strict CSS1 document, the HTML element owns the "canvas" node
    // with the outer 3D border & document scrollbar.
    if (fHTMLLayout)
    {
        BOOL  fSlaveBody  = GetMarkup()->Root()->HasMasterPtr();
        CElement * pBody  = GetMarkup()->GetElementClient();

        pCFI->PrepareFancyFormat();

        //
        // Default BORDER COLOR properties.
        //
        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);

        //
        //  Default SCROLLING properties
        //
        if (!pBody)
        {            
            // A BODY/FRAMESET does not exist yet.
            // Leave it as not set;
        }
        else if (pBody->Tag() == ETAG_FRAMESET)
        {
            // FRAMESET should always be auto
            pCFI->_ff().SetOverflowX(styleOverflowAuto);
            pCFI->_ff().SetOverflowY(styleOverflowAuto);
        }
        // BODY logic
        else if (   !fSlaveBody
                 && !DocIsDeskTopItem(pDoc)
                 && !(pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_SCROLL_NO | DOCHOSTUIFLAG_DIALOG)))
        {
            switch (((CBodyElement *)pBody)->GetAAscroll())
            {
            case bodyScrollno:
            case bodyScrollyes:
            case bodyScrollauto:
                break;

            default:
                // Body is always horizontal.
                pCFI->_ff().SetOverflowX(styleOverflowAuto);
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
                break;
            }
        }

        pCFI->UnprepareForDebug();
    }

    //  Override with CElement/CSS values.   
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    if (fHTMLLayout)
    {
        if (IsInViewLinkBehavior(FALSE))
        {
            CElement * pElemMaster = GetMarkup()->Root()->GetMasterPtr();

            Assert(pElemMaster);
            if (pElemMaster->IsInMarkup())
            {
                CTreeNode *             pNode   = pElemMaster->GetFirstBranch();
                const CFancyFormat *    pFF     = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
                const CCharFormat  *    pCF     = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
                BOOL                    fVLF    = pCF->HasVerticalLayoutFlow();
                BOOL                    fWMU    = pCF->_fWritingModeUsed;

                pCFI->PrepareFancyFormat();
                if (!pFF->GetLogicalWidth(fVLF, fWMU).IsNullOrEnum())
                {
                    CUnitValue uv;
                
                    uv.SetPercent(100);
                    pCFI->_ff().SetWidth(uv);
                    pCFI->_ff().SetWidthPercent(TRUE);
                }
                if (!pFF->GetLogicalHeight(fVLF, fWMU).IsNullOrEnum())
                {
                    CUnitValue uv;
                
                    uv.SetPercent(100);
                    pCFI->_ff().SetHeight(uv);
                    pCFI->_ff().SetHeightPercent(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        else
        {
            pCFI->PrepareFancyFormat();       
            pCFI->_ff().SetHeightPercent(TRUE);
            pCFI->_ff().SetWidthPercent(TRUE);

            //
            // if we are in print preview, and this is the contentbody of
            // a layout rect then we need to make sure scrollbars are turned 
            // off.  (110464)
            if (IsInViewLinkBehavior(TRUE))
            {
                Assert(   GetMarkup()
                       && GetMarkup()->Root()
                       && GetMarkup()->Root()->HasMasterPtr()
                       && GetMarkup()->Root()->GetMasterPtr()->IsLinkedContentElement() 
                       );

                pCFI->_ff().SetOverflowX(styleOverflowVisible);
                pCFI->_ff().SetOverflowY(styleOverflowVisible);
            }

            pCFI->UnprepareForDebug();
        }

    }

    if (    pDoc->_fInHTMLDlg
        &&  GetMarkup()->IsPrimaryMarkup()  )
    {
        // we are in a HTML Dialog, so get its AttrArray to use
        //  in computing our values.
        IUnknown *      pUnkHTMLDlg = NULL;

        hr = THR_NOTRACE(pDoc->QueryService(IID_IHTMLDialog, IID_IUnknown, 
                                (void**)&pUnkHTMLDlg));
        if (hr)
            goto Cleanup;

        if (pUnkHTMLDlg)
        {
            CHTMLDlg *  pHTMLDlg;

            // weak QI
            hr = THR(pUnkHTMLDlg->QueryInterface(CLSID_HTMLDialog, (void**)&pHTMLDlg));
            Assert (!hr && pHTMLDlg);

            CAttrArray **ppAA = pHTMLDlg->GetAttrArray();
            if (ppAA)
            {
                hr = THR(ApplyAttrArrayValues( pCFI, ppAA ));
            }
        }

        ReleaseInterface (pUnkHTMLDlg);
    }

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->PrepareParaFormat();
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(pDoc);
    pCFI->UnprepareForDebug();
  
Cleanup:
    return (hr);
}

//+----------------------------------------------------------
//
//  Member :  OnPropertyChange
//
//  Synopsis  for the HTML element if we get one of the 
//            "interesting" properties changed in its style sheet
//            then if we are in an HTMLDlg that dialog needs to be 
//            notified in order to update its size. the Doc's OPC
//            will do just this.  More accuratly,the doc's OPC calls
//            CServers which does a PropertyNotification to the 
//            sinks, and a HTMLDlg registers a sink to catch this            
//
//-----------------------------------------------------------

HRESULT
CHtmlElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    hr = THR(super::OnPropertyChange( dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    switch(dispid)
    { 
        case DISPID_A_FONT :
        case DISPID_A_FONTSIZE :
        case DISPID_A_FONTWEIGHT :
        case DISPID_A_FONTFACE :
        case DISPID_A_FONTSTYLE :
        case DISPID_A_FONTVARIANT :
        case STDPROPID_XOBJ_TOP : 
        case STDPROPID_XOBJ_LEFT :
        case STDPROPID_XOBJ_WIDTH :
        case STDPROPID_XOBJ_HEIGHT :
        case DISPID_A_DIR :
        case DISPID_A_DIRECTION:
            {
                CMarkup *pMarkup = GetMarkup();
                CDocument *pDocument = NULL;

                if (pMarkup->_fWindowPending)
                    goto Cleanup;

                hr = THR(pMarkup->EnsureDocument(&pDocument));
                if (hr)
                    goto Cleanup;
 
                hr = THR(pDocument->OnPropertyChange(dispid, dwFlags, ppropdesc));
                if (hr)
                    goto Cleanup;
                break;
            }

        case DISPID_BACKCOLOR:
        case DISPID_A_BACKGROUNDIMAGE:
            {   
                CMarkup *pMarkup = GetMarkup();
                CBodyElement * pElement = NULL;

                if (    !pMarkup->IsHtmlLayout()
                    &&  pMarkup->GetBodyElement(&pElement)
                    &&  pElement )                          // Unneccessary: returns S_FALSE                        
                {
                    CLayoutInfo * pLayoutInfo = pElement->GetUpdatedNearestLayoutInfo();
                    if (pLayoutInfo)
                    {
                        pLayoutInfo->OnPropertyChange(dispid, dwFlags);   
                    }
               
                    pElement->Invalidate();
                }
                else
                    Invalidate();
            }


        default:
            break;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//-------------------------------------------------------------------------

void
CHtmlElement::Notify ( CNotification * pNF )
{
    super::Notify(pNF);

    // When we persist a file out for printing, we stash the original URL in an expando
    // on the HTML element.  Here we pull it out and push over the markup's URL; by spoofing
    // the URL like this, we make things like security checks work based on the original URL.
    switch ( pNF->Type() )
    {
        case NTYPE_ELEMENT_ENTERTREE:
            {
                CMarkup * pMarkup = GetMarkup();
                AssertSz( pMarkup, "Better have a markup, we just entered it!" );

                HRESULT     hr = E_FAIL;
                CVariant    var(VT_EMPTY);
               
                // (greglett) WARNING!
                //            If it ever becomes possible to run scripts in a PrintMedia markup, this is a security hole!
                //            We're spoofing the URL below to pretend like we're the original content document site.
                if ( IsPrintMedia() )
                {
                    AssertSz(pMarkup->DontRunScripts(), "This is a potential security hole!");

                    hr = PrimitiveGetExpando( _T("__IE_DisplayURL"), &var );

                    if ( SUCCEEDED(hr) && (V_VT(&var) == VT_BSTR) )
                    {
                        CMarkup::SetUrl( pMarkup, V_BSTR(&var) );
                        // Since we're spoofing the URL, we need to update our
                        // proxy's security ID too.
                        // TODO (KTam): this only updates the mondo proxy.
                        // If there are other outstanding proxies, they'll just
                        // get access denied errors; we can fix this by a)
                        // ensuring no proxies get handed out before this spoof
                        // (could be hard, depends on timing of script etc) or
                        // b) do this spoof earlier (at markup load time?)
                        // (this involves reworking how we persist print docs
                        // and their associated "real" URLs).
                        pMarkup->UpdateSecurityID();
                    }
                }

                {
                    BOOL fHtmlLayout = pMarkup->IsHtmlLayout();
                    // If we are CSS1 compatible, we should inheriting format like the body used to.
                    // If we expect to run more in CSS1 compatible mode, we should change the default and turn the bit off instead of on.
                    _fInheritFF = fHtmlLayout;

                    //if (fHtmlLayout)
                    //    s_classdesc._pAccels = CHtmlElement::s_AccelsHtmlRun
                }

            }
            break;

        default:
            break;
    }
}

//+-------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetBorderInfo
//
//  Synopsis:   Function to get canvas border info.
//              Should be factored out & accessible from the HTML/(BODY/FRAMESET)
//
//--------------------------------------------------------------------
#define WIDTH_3DBORDER 2

inline void Set3DBorderEdgeInfo(BOOL fNeedBorderEdge, int cEdge,
                CBorderInfo * pborderinfo)
{
    if (fNeedBorderEdge)
    {
        pborderinfo->abStyles[cEdge] = fmBorderStyleSunken;
        pborderinfo->aiWidths[cEdge] = WIDTH_3DBORDER;
    }
}

extern BOOL
ShouldCallGetFrameOptions(CDoc * pDoc, CWindow * pWindow, CMarkup * pMarkup);

DWORD
CHtmlElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (    IsInViewLinkBehavior( TRUE )
        ||  !GetMarkup()->IsHtmlLayout() )
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }

    DWORD     dwRet = 0;
    CDoc    * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    // TODO (greglett) Simplify this code!  Unify the BODY and FRAMESET rules.

    // Primary element client is a BODY.
    // Use BODY logic to determine border
    // (code originally copied from CBody::GetBorderInfo)
    if (    !pMarkup->GetElementClient()
        ||  pMarkup->GetElementClient()->Tag() == ETAG_BODY)
    {
        CWindow * pWindow = pMarkup->Window() ? pMarkup->Window()->Window() : NULL;

        // if host says no border, then we have no border.
        // if the frame options say no border, we want no border. However (85696) in
        // design mode, if there are no borders, then there is no way to wysiwyg resize
        // and so VS/VID/et. al. want this turned off.  
        if (    ShouldCallGetFrameOptions(pDoc, pWindow, pMarkup)
            &&  (   (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
            &&  (   (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0
                  || (   pDoc->_fScriptletDoc                                   // a scriptlet doc with an iframe
                      && pMarkup->Root()->HasMasterPtr()                        //    should still have a border on the
                      && pMarkup->Root()->GetMasterPtr()->Tag() == ETAG_IFRAME  //    IFRAME (100612)
                )    )
            &&  pWindow
            &&  !   (   pMarkup->IsPrintMedia()
                    &&  !pWindow->_pWindowParent
            )       )
        {
            // raid 41791 3D border
            // For a (nested) frameset HTML document, Trident will draw 3D border
            // for the top-level frameset (pDocRoot->_pSiteRoot->_pElemClient is
            // a CFrameSetSite), so we don't need to draw 3D border edge(s) if
            // it (they) overlaps with top-level 3D borders.
            //
            BYTE b3DBorder;

            if (!pWindow->_pWindowParent)
            {
                pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                                 | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
            }
            else
                pWindow->_pWindowParent->CheckDoc3DBorder(pWindow);

            b3DBorder = pWindow->_b3DBorder;

            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_TOP) != 0,
                    SIDE_TOP,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_LEFT) != 0,
                    SIDE_LEFT,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_BOTTOM) != 0,
                    SIDE_BOTTOM,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_RIGHT) != 0,
                    SIDE_RIGHT,
                    pborderinfo);

            pborderinfo->wEdges = BF_RECT;

            // Unless we're the top, add space for the frame highlighting area
            if (pWindow->_pWindowParent)
            {
                pborderinfo->xyFlat = CFrameSetSite::iPixelFrameHighlightWidth;
                pborderinfo->aiWidths[SIDE_TOP]    += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_RIGHT]  += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_BOTTOM] += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_LEFT]   += pborderinfo->xyFlat;
                pborderinfo->acrColors[SIDE_TOP][1]
                        = pborderinfo->acrColors[SIDE_RIGHT][1]
                        = pborderinfo->acrColors[SIDE_BOTTOM][1]
                        = pborderinfo->acrColors[SIDE_LEFT][1]
                        = (pDoc->_state < OS_UIACTIVE)
                                ? GetInheritedBackgroundColor()
                                : RGB(0,0,0); // black, for now
            }
        }

        dwRet = super::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    }

    // Primary element client is a FRAMESET.
    // Use FRAMESET logic to determine border
    // (code originally copied from CFrameSetSite::GetBorderInfo)
    else
    {
        Assert(GetMarkup()->GetElementClient()->Tag() == ETAG_FRAMESET);
        
        if  (   (   pMarkup == Doc()->PrimaryMarkup()
                 || (   IsInViewLinkBehavior(TRUE)
                     && !IsInViewLinkBehavior(FALSE) ))
             && ((pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
             && ((pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DBORDER) == 0))
        {
            // set border style and border space for top-level frameset
            //
            pborderinfo->abStyles[SIDE_TOP]
                    = pborderinfo->abStyles[SIDE_RIGHT]
                    = pborderinfo->abStyles[SIDE_BOTTOM]
                    = pborderinfo->abStyles[SIDE_LEFT]
                    = fmBorderStyleSunken;
            pborderinfo->aiWidths[SIDE_TOP]
                    = pborderinfo->aiWidths[SIDE_RIGHT]
                    = pborderinfo->aiWidths[SIDE_BOTTOM]
                    = pborderinfo->aiWidths[SIDE_LEFT]
                    = 2;
            pborderinfo->wEdges = BF_RECT;
        }

        dwRet = super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    }

    return dwRet;
}

CBase *
CHtmlElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup /* = NULL */)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if  (   dispID == DISPID_EVPROP_ONSCROLL
        &&  pMarkup
        &&  pMarkup->IsHtmlLayout() )
    {        
        if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}


HRESULT
CHtmlElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;
    BOOL    fExpando = FALSE;;
    CMarkup * pMarkup = GetMarkup();


    if (    !fEnd
        &&  Doc()->_fSaveTempfileForPrinting )
    {
        CVariant cvarProp;
        V_VT(&cvarProp)     = VT_BSTR;
        V_BSTR(&cvarProp)   = SysAllocString(CMarkup::GetUrl(pMarkup));

        fExpando = pMarkup->_fExpando;
        pMarkup->_fExpando = TRUE;
        
        PrimitiveSetExpando(_T("__IE_DisplayURL"), cvarProp);
    }

    hr = THR(super::Save(pStreamWrBuff, fEnd));

    if (    !fEnd
        &&  Doc()->_fSaveTempfileForPrinting )
    {
        WHEN_DBG(HRESULT hrDbg =)  PrimitiveRemoveExpando(_T("__IE_DisplayURL"));
        Assert(!hrDbg);

        pMarkup->_fExpando = fExpando;
    }

    RRETURN1(hr, S_FALSE);
}




//+------------------------------------------------------------------------
//
//  Class:      CHeadElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CHeadElement::s_classdesc =
{
    {
        &CLSID_HTMLHeadElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLElement,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLElement,
};


HRESULT
CHeadElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CHeadElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CHeadElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CHeadElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLHeadElement, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Class:      CTitleElement
//
//  Synopsis:   Push new parser specifically for TITLE text
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CTitleElement::s_classdesc =
{
    {
        &CLSID_HTMLTitleElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLTitleElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTitleElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT
CTitleElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CTitleElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

#define ISSPACE(ch) (((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)
#define ISNSPAC(ch) (ch && !((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)

#if DBG == 1
CTitleElement::~ CTitleElement ( )
{
}
#endif

HRESULT
CTitleElement::SetTitle(TCHAR *pchTitle)
{
    // NOTE (dbau) Netscape doesn't allow document.title to be set!

    // In a <TITLE> tag, Netscape eliminates multiple spaces, etc, as follows:

    HRESULT hr;
    TCHAR pchURLSite[INTERNET_MAX_URL_LENGTH];
    TCHAR *pchTemp = NULL;
    TCHAR *pch;
    TCHAR *pchTo;
    CDoc *  pDoc = Doc();

    IWebBrowser2 *      pWebBrowser = NULL;
    hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
    if (!hr)
    {
        VARIANT_BOOL vfAddressBar = VARIANT_TRUE;
        hr = pWebBrowser->get_AddressBar(&vfAddressBar);
        if (vfAddressBar != VARIANT_TRUE)
        {
            pchTemp = pchURLSite + 2; // Move pointer with 2 positions so we can insert '//' if necessary
            DWORD dw = INTERNET_MAX_URL_LENGTH-6;
            int insertPos = 0;
            if (SUCCEEDED(UrlGetPart(CMarkup::GetUrl(GetMarkup()), pchTemp, &dw, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME)) && dw>0)
            {
                // Insert "//" after protocol name
                LPCTSTR protocols[] = {_T("http:"), _T("https:"), _T("ftp:")};
                for (int index=0; index<ARRAY_SIZE(protocols); index++)
                {
                    if (_tcsncicmp(pchTemp, protocols[index],  _tcslen(protocols[index]))==0)
                    {
                        insertPos = _tcslen(protocols[index]);
                        pchTemp = pchURLSite;
                        StringCchCopy(pchTemp, insertPos+1, protocols[index]);
                        pchURLSite[insertPos]=_T('/');
                        pchURLSite[insertPos+1]=_T('/');
                        break;
                    }
                }

                // Put pchURLSite before pchTitle
                if (pchTitle)
                {
                    StringCchCat(pchTemp, INTERNET_MAX_URL_LENGTH - 8, _T(" - "));
                    StringCchCat(pchTemp, INTERNET_MAX_URL_LENGTH - 8, pchTitle);
                }
                pchTitle = pchTemp;
            }
        }
        ReleaseInterface(pWebBrowser);
    }


    if (!pchTitle)
        goto NULLSTR;

    hr = THR(MemAllocString(Mt(CTitleElement), pchTitle, &pchTemp));
    if (hr)
        goto Cleanup;

    pch = pchTo = pchTemp;
    
    // remove leading spaces
    goto LOOPSTART;

    do
    {
        *pchTo++ = _T(' ');
        
LOOPSTART:
        while (ISNSPAC(*pch))
            *pchTo++ = *pch++;

        // remove multiple/trailing spaces
        while (ISSPACE(*pch))
            pch++;
            
    } while (*pch);
    
    *pchTo = _T('\0');

NULLSTR:
    hr = THR(_cstrTitle.Set(pchTemp));
    if (hr)
        goto Cleanup;
    if (IsInMarkup() && GetMarkup()->HasWindow())
    {
        IGNORE_HR(GetMarkup()->Document()->OnPropertyChange(
            DISPID_CDocument_title, SERVERCHNG_NOVIEWCHANGE, (PROPERTYDESC *)&s_propdescCDocumenttitle));
    }
    pDoc->DeferUpdateTitle( GetMarkup() );

Cleanup:
    MemFreeString(pchTemp);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHeadElement::Save
//
//  Synopsis:   Standard element saver.  Includes hook for saving out
//              additional tags for printing such as BASE and STYLE tag
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CHeadElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr || fEnd)
        goto Cleanup;

    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if( GetMarkup() )
            hr = THR( GetMarkup()->SaveHtmlHead( pStreamWriteBuff ) );
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTitleElement::Save
//
//  Synopsis:   standard element saver
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CTitleElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DWORD   dwOld;

    // if no title string and synthetic, don't save tags
    if ( _fSynthesized && !_cstrTitle.Length())
        goto Cleanup;

    // Save tagname and attributes.
    hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr)
        goto Cleanup;

    // Tell the write buffer to just write this string
    // literally, without checking for any entity references.
    
    dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
    
    // Tell the stream to now not perform any fancy indenting
    // or such stuff.
    pStreamWriteBuff->BeginPre();

    if (!fEnd)
    {
        hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrTitle));
        if (hr)
            goto Cleanup;
    }
        
    pStreamWriteBuff->EndPre();
    pStreamWriteBuff->SetFlags(dwOld);
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Class: CMetaElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CMetaElement::s_classdesc =
{
    {
        &CLSID_HTMLMetaElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLMetaElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLMetaElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CMetaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CMetaElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CMetaElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CMetaElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLMetaElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CMetaElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;
        
#if 0 // commented out to fix bug 54067: allow meta-http-equiv to work inside the BODY
    if (SearchBranchToRootForTag(ETAG_HEAD))
#endif
    {
        CDoc *  pDoc = Doc();
        LPCTSTR pchHttpEquiv;
        LPCTSTR pchName;
        LPCTSTR pchContent;

        if (    pDoc
            &&  _pAA )
        {
            if(    
                   pContext->_pTargetMarkup && 
                   _pAA->FindString(DISPID_CMetaElement_httpEquiv, &pchHttpEquiv)
               &&  pchHttpEquiv
               &&  pchHttpEquiv[0]
               &&  _pAA->FindString(DISPID_CMetaElement_content, &pchContent)
               &&  pchContent)
            {
                pContext->_pTargetMarkup->ProcessHttpEquiv(pchHttpEquiv, pchContent);
            }
            else if (    _pAA->FindString(DISPID_CMetaElement_name, &pchName)
                     &&  pchName
                     &&  pchName[0]
                     &&  _pAA->FindString(DISPID_CMetaElement_content, &pchContent)
                     &&  pchContent)
            {
                pDoc->ProcessMetaName(pchName, pchContent);
            }

        }
    }

Cleanup:
    RRETURN(hr);
}

static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}

HRESULT
CMetaElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    CMetaElement * pMeta;

    // NOTE: (jbeda) It looks like the intention of this code is that when the
    //       WBF_NO_CHARSET_META flag is specified that codepage meta tags not
    //       be saved.  Instead, it looks like there is an issue with the parens
    //       where no meta tage will be saved in this case.  This is only used
    //       right now for saving to the clipboard and printing (I think) so it
    //       isn't worth risking to change it.

    // NOTE: (jbeda) When saving for treesync we don't want to do the head
    //       search as the tree may be in a wacky state so just always save this
    //       guy out.

    if (    IsCodePageMeta() 
        &&  (   !pStmWrBuff->TestFlag( WBF_FOR_TREESYNC ) 
            &&  IsInMarkup() 
            &&  GetMarkup()->LocateHeadMeta(LocateCodepageMeta, &pMeta) == S_OK 
            &&  pMeta != this )
        ||  pStmWrBuff->TestFlag(WBF_NO_CHARSET_META) )
    {
        // Only write out the first charset meta tag in the head
        return S_OK;
    }

    return super::Save(pStmWrBuff, fEnd);
}

BOOL
CMetaElement::IsCodePageMeta( )
{
    return ( GetAAhttpEquiv() && !StrCmpIC(GetAAhttpEquiv(), _T("content-type")) &&
             GetAAcontent()) || 
             GetAAcharset();
}

CODEPAGE
CMetaElement::GetCodePageFromMeta( )
{
    if( GetAAhttpEquiv() && StrCmpIC( GetAAhttpEquiv( ), _T("content-type") ) == 0 &&
        GetAAcontent() )
    {
        // Check if we are of the form:
        //  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=xxx">
        return CodePageFromString( (LPTSTR) GetAAcontent(), TRUE );
    }
    else if ( GetAAcharset() )
    {
        // Check if we are either:
        //  <META HTTP-EQUIV CHARSET=xxx> or <META CHARSET=xxx>
        return CodePageFromString( (LPTSTR) GetAAcharset(), FALSE );
    }

    // Either this meta tag does not specify a codepage, or the codepage specified
    //  is unrecognized.
     return CP_UNDEFINED;
}

//+----------------------------------------------------------------------------+
//
// IsGalleryMeta:
//      returns
//      true  : if <META Name="ImageToolbar" CONTENT="yes">
//      false : if <META Name="ImageToolbar" CONTENT="no">
//      true  : otherwise
//
//+----------------------------------------------------------------------------+
 
BOOL
CMetaElement::IsGalleryMeta()
{
    if(     GetAAname()
        &&  StrCmpIC(GetAAname(), _T("ImageToolbar")) == 0
        &&  GetAAcontent()
        &&  StrCmpIC(GetAAcontent(), _T("No")) == 0)
    {
            return FALSE;
    }
    return TRUE;
} 

//+----------------------------------------------------------------------------+
//
// TestThemeMeta:
//      returns
//      1 : if <META HTTP-EQUIV="MSThemeCompatible" CONTENT="yes">
//      0 : if <META HTTP-EQUIV="MSThemeCompatible" CONTENT="no">
//     -1 : otherwise
//
//+----------------------------------------------------------------------------+

int
CMetaElement::TestThemeMeta( )
{
    if(     GetAAhttpEquiv()
        &&  StrCmpIC( GetAAhttpEquiv( ), _T("MSThemeCompatible") ) == 0
        &&  GetAAcontent())
    {
        if (StrCmpIC( GetAAcontent( ), _T("Yes") ) == 0)
        {
            return 1;
        }
        else if (StrCmpIC( GetAAcontent( ), _T("No") ) == 0)
        {
            return 0;
        }
    }
    return -1;
}
       
BOOL
CMetaElement::IsPersistMeta(long eState)
{
    BOOL fRes = FALSE;

    if (GetAAname() &&  GetAAcontent() &&
            (StrCmpNIC(GetAAname(), 
                        PERSISTENCE_META, 
                        ARRAY_SIZE(PERSISTENCE_META))==0))
    {
        int         cchNameLen = 0;
        LPCTSTR     pstrNameStart = NULL;
        CDataListEnumerator   dleContent(GetAAcontent(), _T(','));


        // for each name token in the content string check to see if
        //   it specifies the persistence type we are intereseted in
        while (dleContent.GetNext(&pstrNameStart, &cchNameLen))
        {
            switch (eState)
            {
            case 1:     // favorite
                fRes = (0 == _tcsnicmp(_T("favorite"), 8, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            case 2:     // History
                fRes = (0 == _tcsnicmp(_T("history"), 7, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            case 3:     // Snapshot
                fRes = (0 == _tcsnicmp(_T("snapshot"), 8, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            default:
                fRes = FALSE;
                break;
            }

            // if we still don't have it, give the "all" type a chance
            if (!fRes)
                fRes = (0 == _tcsnicmp(_T("all"), 3, (LPTSTR)pstrNameStart, cchNameLen));
        }

    }

    return fRes;
}

HRESULT
CMetaElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    if( dispid == DISPID_CMetaElement_content &&
        IsCodePageMeta() )
    {
        CODEPAGE cp = GetCodePageFromMeta();

        if( cp != CP_UNDEFINED )
        {
            // TODO (johnv) What should we do when we get this message?
        }
    }

    hr = THR(super::OnPropertyChange( dispid, dwFlags, ppropdesc ));
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Class: CBaseElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CBaseElement::s_classdesc =
{
    {
        &CLSID_HTMLBaseElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBaseElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBaseElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBaseElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CBaseElement(pht->GetTag(), pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

HRESULT SetUrlDefaultScheme(const TCHAR *pchHref, CStr *pStr)
{
    HRESULT hr = S_OK;
    TCHAR achQualifiedHref[pdlUrlLen];
    DWORD cchQualifiedHref = ARRAY_SIZE(achQualifiedHref);

    if (pchHref)
    {
        hr = UrlApplyScheme(pchHref, achQualifiedHref, &cchQualifiedHref,
            URL_APPLY_GUESSSCHEME | URL_APPLY_GUESSFILE | URL_APPLY_DEFAULT);
    }

    if (hr || !pchHref)
        hr = THR(pStr->Set(pchHref));
    else
        hr = THR(pStr->Set(achQualifiedHref));

    RRETURN(hr);
}

HRESULT
CBaseElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    hr = SetUrlDefaultScheme(GetAAhref(), &_cstrBase);

Cleanup:
    RRETURN(hr);
}

void
CBaseElement::Notify( CNotification * pNF )
{
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        // we might be in the head...tell doc to look
        Doc()->_fHasBaseTag = TRUE;

        // only send the notification when the element is entering 
        // because of non-parsing related calls
        if ( !(pNF->DataAsDWORD() & ENTERTREE_PARSE) )
            BroadcastBaseUrlChange();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if ( !(pNF->DataAsDWORD() & EXITTREE_DESTROY) )
            BroadcastBaseUrlChange();
        break;
    }
}

HRESULT
CBaseElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_CBaseElement_href)
    {
        hr = SetUrlDefaultScheme(GetAAhref(), &_cstrBase);
        if (hr)
            goto Cleanup;

        // send notification to the descendants, if we
        // are in a markup
        if ( IsInMarkup() )
            BroadcastBaseUrlChange();
    }

    hr = super::OnPropertyChange(dispid, dwFlags, ppropdesc);

Cleanup:
    RRETURN(hr);
}

void 
CBaseElement::BroadcastBaseUrlChange( )
{
    CNotification   nf;
    CDoc *          pDoc = Doc();

    // send the notification to change non-cached properties.
    SendNotification( NTYPE_BASE_URL_CHANGE );
        
    // Force a re-render
    THR(pDoc->ForceRelayout() );

    // and force recomputing behavior on the markup that contains this 
    // base element.
    nf.RecomputeBehavior( MarkupRoot() );
    
    pDoc->BroadcastNotify(&nf);
}


//+------------------------------------------------------------------------
//
//  Class: CIsIndexElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CIsIndexElement::s_classdesc =
{
    {
        &CLSID_HTMLIsIndexElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLIsIndexElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLIsIndexElement,    // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CIsIndexElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CIsIndexElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CIsIndexElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CIsIndexElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLIsIndexElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Class: CNextIdElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CNextIdElement::s_classdesc =
{
    {
        &CLSID_HTMLNextIdElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLNextIdElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLNextIdElement,     // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CNextIdElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CNextIdElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\fscroll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scroll.cxx
//
//  Contents:   Contains CDoc methods related to scrolling behavior.
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Scroll
//
//  Synopsis:   Scrolls the form.
//
//  Note:       A single scroll event is fired.
//
//--------------------------------------------------------------------------

#if 0
STDMETHODIMP
CDoc::Scroll(VARIANT varXAction, VARIANT varYAction)
{

    HRESULT             hr = S_OK;
    VARIANT *           pvar;
    VARIANT             var;
    UINT                uCode;
    long                lPos;
    int                 i;
    BOOL                fScroll;
    long                dxl = 0;
    long                dyl = 0;
    fmScrollAction      xAction = fmScrollActionNoChange;
    fmScrollAction      yAction = fmScrollActionNoChange;

    for (i = 0; i < 2; i++)
    {
        lPos = 0;
        fScroll = TRUE;

        pvar = (i == 0 ? &varXAction : &varYAction);
        if (pvar->vt == VT_ERROR)
            continue;

        VariantInit(&var);
        hr = THR(VariantChangeTypeSpecial(&var, pvar, VT_I4));
        if (hr)
            goto Cleanup;

        if (i == 0)
        {
            xAction = (fmScrollAction) V_I4(&var);
        }
        else
        {
            yAction = (fmScrollAction) V_I4(&var);
        }

        switch(V_I4(&var))
        {
        case fmScrollActionLineUp:
            uCode = SB_LINEUP;
            break;

        case fmScrollActionLineDown:
            uCode = SB_LINEDOWN;
            break;

        case fmScrollActionPageUp:
            uCode = SB_PAGEUP;
            break;

        case fmScrollActionPageDown:
            uCode = SB_PAGEDOWN;
            break;

        case fmScrollActionBegin:
            uCode = SB_THUMBPOSITION;
            break;

        case fmScrollActionEnd:
            uCode = SB_THUMBPOSITION;
            lPos = LONG_MAX;
            break;

        case fmScrollActionNoChange:
            fScroll = FALSE;
            break;

        case fmScrollActionAbsoluteChange:
            uCode = SB_THUMBPOSITION;
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (fScroll)
        {
            DYNCAST(C2DSite, _RootSite._pElemClient)->OnScrollHelper(
                    i,
                    uCode,
                    lPos,
                    (i == 0 ? &dxl : &dyl));
        }
    }

    hr = THR(_RootSite.ScrollBy(dxl, dyl, xAction, yAction));

Cleanup:
    RRETURN(SetErrorInfo(hr));
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\getid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       getid.cxx
//
//  Contents:   GetUniqueID service and usage
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_ACTIVDBG_H_
#define X_ACTIVDBG_H_
#include <activdbg.h>
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef NO_DDRAW
#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif
#endif // NO_DDRAW

#ifndef NO_SCRIPT_DEBUGGER
extern interface IDebugApplication *g_pDebugApp;
#endif // NO_SCRIPT_DEBUGGER

extern CGlobalCriticalSection    g_csOscCache;

extern HRESULT EnsureAccWindow( CWindow * pWindow );

extern "C" const GUID SID_SHTMLEditServices;

//
//  CDoc methods
//


DeclareTag(tagNoQS, "Form", "Obstruct all QueryService to container")
MtExtern(CEnumPrivacyRecords)


//+------------------------------------------------------------------------
//
//  Member:     CDoc::QueryService
//
//  Synopsis:   QueryService for the form.  Delegates to the form's
//              own site.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDoc::QueryService(
        REFGUID guidService,
        REFIID iid,
        void ** ppv)
{
    HRESULT             hr;

#if DBG == 1
    if (IsTagEnabled(tagNoQS))
        hr = E_NOINTERFACE;
    else
#endif
    //
    // Certain services should never be bubbled up through 
    // the client site
    // SID_SContainerDispatch   -   Always provide container's IDispatch
    // SID_SLocalRegistry       -   Never bubble due to security concerns.
    //                              License manager is per document.
    // SID_SBindHost            -   We provide the service but might also
    //                              forward some calls to an outer bindhost,
    //                              if any.
    //

    // TODO (alexz) these "ifs" are redundant to "ifs" inside CreateService
    if (SID_SContainerDispatch == guidService ||
        SID_SLocalRegistry == guidService ||
        SID_SBindHost == guidService ||
        CLSID_HTMLDocument == guidService ||
        IID_IDebugApplication == guidService ||
        IID_IInternetHostSecurityManager == guidService ||
        IID_IDocHostUIHandler == guidService ||
        SID_SHTMLProperyPageArg == guidService ||
        IID_IAccessible == guidService ||
        IID_ISelectionServices == guidService ||
        SID_SHTMLEditServices == guidService || 
        IID_IElementNamespaceTable== guidService ||
        IID_IEnumPrivacyRecords == guidService ||
        IID_IPrivacyServices == guidService)
    {
        hr = THR_NOTRACE(CreateService(guidService, iid, ppv));
    }
    else
    {
        hr = THR_NOTRACE(CServer::QueryService(guidService, iid, ppv));
        if (hr)
        {
            hr = THR_NOTRACE(CreateService(guidService, iid, ppv));
        }
    }
    
    RRETURN_NOTRACE(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CreateService, public
//
//  Synopsis:   Creates the requested service. Only called if our container
//              does not provide the service.
//
//  Arguments:  [guidService] -- Service being asked for.
//              [iid]         -- IID needed on that service.
//              [ppv]         -- Place to put pointer.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CreateService(REFGUID guidService, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    *ppv = NULL;

#ifndef NO_EDIT
    if (guidService == SID_SOleUndoManager)
    {
        hr = CreateUndoManager();
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(_pUndoMgr->QueryInterface(iid, ppv));
    }
    else 
#endif // NO_EDIT
#ifndef NO_DDRAW
    if (guidService == SID_SDirectDraw3)
    {
        extern HRESULT InitSurface();
        extern IDirectDraw* g_pDirectDraw;
        LOCK_SECTION(g_csOscCache);
        hr = InitSurface();
        if (SUCCEEDED(hr))
            hr = THR_NOTRACE(g_pDirectDraw->QueryInterface(iid, ppv));
    } 
    else 
#endif //ndef NO_DDRAW
    if (guidService == SID_STimerService)
    {
        CTimerMan *pTimerMan;
        hr = THR(GetTimerManager(&pTimerMan));
        if (SUCCEEDED(hr))
        {
            hr = THR_NOTRACE(pTimerMan->QueryInterface(iid, ppv));

            if (SUCCEEDED(hr))
            {
                if (!_pTimerDraw)
                {
                    // Init NAMEDTIMER_DRAW which gets frozen for controls during paints.
                    // Not a problem if this fails as the results are not catastrophic.

                    IGNORE_HR(pTimerMan->GetNamedTimer(NAMEDTIMER_DRAW, &_pTimerDraw));
                }
                
                pTimerMan->Release();
            }
        }
    }
    else if (guidService == SID_SContainerDispatch)
    {
        hr = THR_NOTRACE(QueryInterface(iid, ppv));
    }
    else if (guidService == SID_SLocalRegistry)
    {
        //
        // Respond with license manager if one is available.
        //
        
        if (_pWindowPrimary->Window()->_pLicenseMgr)
        {
            hr = THR(_pWindowPrimary->Window()->_pLicenseMgr->QueryInterface(iid, ppv));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else if (guidService == SID_SUrlHistory) 
    {
        // Our container is not shdocvw --- we need to handle geting the
        // history container ourself. It would be nice to be able to
        // assert that shdocvw is not the host though to make sure we 
        // are not in the situation where we have a problem and don't
        // detect it.

        hr = THR(CoCreateInstance(CLSID_CUrlHistory, NULL,  CLSCTX_INPROC_SERVER, iid, ppv));
    }
    else if (   guidService == CLSID_HTMLDocument )
    {
        hr = THR(PrivateQueryInterface(iid, ppv));
    }
    else if ( guidService == IID_IInternetHostSecurityManager )
    {
        // delegate to the top level document object.

        Assert(_pWindowPrimary->Document());

        hr = THR(_pWindowPrimary->Document()->QueryInterface(iid, ppv));

    }
#ifndef NO_SCRIPT_DEBUGGER
    else if ((IID_IDebugApplication == guidService) && g_pDebugApp)
    {
        hr = THR_NOTRACE(g_pDebugApp->QueryInterface (iid, ppv));
    }
#endif
#ifndef NO_PROPERTY_PAGE
    else if (guidService == SID_SHTMLProperyPageArg)
    {
        COptionsHolder *    pcoh = new COptionsHolder(GetCurrentWindow()->Window());

        hr = 
            THR(pcoh->put_anythingAfterFrameset( 
            (VARIANT_BOOL) _fTagsInFrameset));

        hr = THR_NOTRACE(pcoh->QueryInterface(iid,ppv));
        ReleaseInterface(pcoh);
    }
#endif
    else if (guidService == IID_IAuthenticate && iid == IID_IAuthenticate)
    {
        hr = THR(CreateTearOffThunk(this, s_apfnIAuthenticate, NULL, ppv));

        if (hr == S_OK)
        {
            ((IUnknown *)(*ppv))->AddRef();
        }
    }
    else if (guidService == IID_IWindowForBindingUI && iid == IID_IWindowForBindingUI)
    {
        hr = THR(CreateTearOffThunk(this, s_apfnIWindowForBindingUI, NULL, ppv));

        if (hr == S_OK)
        {
            ((IUnknown *)(*ppv))->AddRef();
        }
    }
    else if ( guidService == IID_IAccessible )
    {
        // delegate to the top level document's QueryService handling code.
        
        // Should we protect against a passivation situation ?? (FerhanE)
        Assert(_pWindowPrimary);

        hr = THR(_pWindowPrimary->Document()->QueryService(guidService, iid, ppv));
    }
    else if ( guidService == IID_IDocHostUIHandler )
    {
        if (!_pHostUIHandler)
        {
            hr = E_NOINTERFACE;
            goto Cleanup;
        }

        *ppv = _pHostUIHandler;
        _pHostUIHandler->AddRef();
        hr = S_OK;
    }    
    else if (guidService == IID_ISelectionServices && iid == IID_ISelectionServices )
    {
        AssertSz(FALSE, "QueryServices for IID_ISelectionServices no longer support");
        hr = E_INVALIDARG;
    }
    else if (guidService == SID_SHTMLEditServices && iid == IID_IHTMLEditServices )
    {
        IHTMLEditor *pEd = GetHTMLEditor(TRUE);

        if (pEd != NULL)
            hr = THR( pEd->QueryInterface( IID_IHTMLEditServices, (void**) ppv ));
        else
        {
            *ppv = NULL ;
            hr = E_FAIL;
            goto Cleanup;
        }    
    }    
    else if (IID_IElementNamespaceTable == guidService)
    {
        hr = THR(EnsureExtendedTagTableHost());
        if (hr)
            goto Cleanup;

        hr = THR(_pExtendedTagTableHost->QueryInterface(iid, ppv));
    }
    else if (IID_IEnumPrivacyRecords == guidService)
    {
        *ppv = (void*)new(Mt(CEnumPrivacyRecords)) CEnumPrivacyRecords(_pPrivacyList);
        if (!*ppv)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = S_OK;
        goto Cleanup;
    }
    else if (   guidService == IID_IPrivacyServices )
    {
        hr = THR(PrivateQueryInterface(iid, ppv));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

#if DBG==1
    if (guidService != CLSID_HTMLDocument)
    {
        DbgTrackItf(iid, "CDoc::QS", FALSE, ppv);
    }
#endif

Cleanup:
    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetUniqueIdentifier
//
//  Synopsis:   Gets a unique ID for the control.  If possible, the form
//              coordinates with its container through the IGetUniqueID
//              service to get an ID unique within the container.
//
//  Arguments:  [pstr]      The string to set into
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDoc::GetUniqueIdentifier(CStr *pstr)
{
    TCHAR   ach[64];
    HRESULT hr;

    memset(ach, 0, sizeof(ach));

    // Prefix with id_ because scriptlet code
    // doesn't currently like ID's that are all digits
    hr = THR(Format(0, ach, ARRAY_SIZE(ach), UNIQUE_NAME_PREFIX _T("<0d>"), (long)++_ID));
    if (hr)
        goto Cleanup;

    hr = THR(pstr->Set(ach));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\history.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       history.cxx
//
//  Contents:   Implementation of COmLocation, COmHistory and COmNavigator objects.
//
//  Synopsis:   CWindow uses instances of this class to provide expando properties
//              to the browser impelemented window.location, window.history, and
//              window.navigator objects.
//
//              The typelib for those objects are in mshtml.dll which we use via the
//              standard CBase mechanisms and the CLASSDESC specifiers.
//              The browser's implementation of those objects are the only interface
//              to those objects that is ever exposed externally.  The browser delegates
//              to us for the few calls that require our expando support.
//
//              Instances of these classes are also used to provide minimal implementation
//              for non-browser scenarios like Athena
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "history.hdl"

MtDefine(COmLocation, ObjectModel, "COmLocation")
MtDefine(COmLocationGetUrlComponent, Utilities, "COmLocation::GetUrlComponent")
MtDefine(COmHistory, ObjectModel, "COmHistory")
MtDefine(COmNavigator, ObjectModel, "COmNavigator")
MtDefine(COpsProfile, ObjectModel, "COpsProfile")
MtDefine(CPlugins, ObjectModel, "CPlugins")
MtDefine(CMimeTypes, ObjectModel, "CMimeTypes")

//+-------------------------------------------------------------------------
//
//  COmLocation - implementation for the window.location object
//
//--------------------------------------------------------------------------

COmLocation::COmLocation(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;
}

ULONG COmLocation::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmLocation::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT
COmLocation::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLLocation, NULL)
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

const COmLocation::CLASSDESC COmLocation::s_classdesc =
{
    &CLSID_HTMLLocation,                 // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IHTMLLocation,                  // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};



HRESULT
COmLocation::GetUrlComponent(BSTR *pstrComp, URLCOMP_ID ucid, TCHAR **ppchUrl, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    TCHAR    cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl = cBuf;
    CStr     cstrFullUrl;

    // make sure we have at least one place to return a value
    Assert(!(pstrComp && ppchUrl));
    if (!pstrComp && !ppchUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ppchUrl)
        *ppchUrl = NULL;
    else
        *pstrComp = NULL;

    // Get the expanded string
    //
    hr = _pWindow->_pDocument->GetMarkupUrl(&cstrFullUrl, TRUE);
    if (hr)
        goto Cleanup;

    // Should we call this even if URLCOMP_WHOLE is requested.  I'm not
    // sure what shdocvw did...
    //
    hr = CMarkup::ExpandUrl(
            _pWindow->_pMarkup,
            cstrFullUrl,
            ARRAY_SIZE(cBuf), pchNewUrl, NULL);

    if (hr || !*pchNewUrl)
        goto Cleanup;

    // if asking for whole thing, just set return param
    if (ucid == URLCOMP_WHOLE)
    {
        if (ppchUrl)
        {
            hr = THR(MemAllocString(Mt(COmLocationGetUrlComponent),
                        pchNewUrl, ppchUrl));
            pchNewUrl = NULL;          // to avoid cleanup
        }
        else
        {
            hr = THR(FormsAllocString(pchNewUrl, pstrComp));
        }
    }
    else
    {
        // we want a piece, so split it up.
        CStr cstrComponent;
        BOOL fUseOmLocationFormat = ((_pWindow->Doc()->_pTopWebOC && _pWindow->_pMarkup->IsPrimaryMarkup()) || _pWindow->GetFrameSite());

        hr = THR(GetUrlComponentHelper(pchNewUrl, &cstrComponent, dwFlags, ucid, fUseOmLocationFormat));
        if (hr)
            goto Cleanup;

        if (ppchUrl)
        {
            if (cstrComponent)
                hr = THR(MemAllocString(Mt(COmLocationGetUrlComponent),
                        cstrComponent, ppchUrl));
            else
                *ppchUrl = NULL;
        }
        else
        {
            hr = THR(cstrComponent.AllocBSTR(pstrComp));
        }
    }

Cleanup:
    RRETURN (hr);
}

//+-----------------------------------------------------------
//
//  Member  : SetUrlComponenet
//
//  Synopsis    : field the various component setting requests
//
//-----------------------------------------------------------

HRESULT
COmLocation::SetUrlComponent(const BSTR bstrComp,
                             URLCOMP_ID ucid,
                             BOOL fDontUpdateTravelLog, /*=FALSE*/
                             BOOL fReplaceUrl /*=FALSE*/)
{
    HRESULT hr;

    // if set_href, just set it
    if (ucid == URLCOMP_WHOLE)
    {
        hr = THR(_pWindow->FollowHyperlinkHelper(bstrComp, 0, CDoc::FHL_SETURLCOMPONENT |
                                                              ( fDontUpdateTravelLog ?  CDoc::FHL_DONTUPDATETLOG : 0 ) |
                                                              ( fReplaceUrl ? CDoc::FHL_REPLACEURL : 0 ) ));
    }
    else
    {
        TCHAR * pchOldUrl = NULL;
        TCHAR   achUrl[pdlUrlLen];

        // get the old url
        hr = THR(GetUrlComponent(NULL, URLCOMP_WHOLE, &pchOldUrl, 0));

        if (hr || !pchOldUrl)
            goto Cleanup;

        // expand it if necessary
        if ((ucid != URLCOMP_HASH) && (ucid != URLCOMP_SEARCH))
        {
            // and set the appropriate component
            hr = THR(SetUrlComponentHelper(pchOldUrl,
                                           achUrl,
                                           ARRAY_SIZE(achUrl),
                                           &bstrComp,
                                           ucid));
        }
        else
        {
            hr = THR(ShortCutSetUrlHelper(pchOldUrl,
                                   achUrl,
                                   ARRAY_SIZE(achUrl),
                                   &bstrComp,
                                   ucid,
                                   TRUE));  // use OmLocation format that is
                                            // compatible with SHDOCVW 5.01 implementation
        }

        // free the old url.
        if (pchOldUrl)
            MemFreeString(pchOldUrl);

        if (hr)
            goto Cleanup;

        hr = THR(_pWindow->FollowHyperlinkHelper(achUrl, 0, CDoc::FHL_SETURLCOMPONENT |
                                                            ( fDontUpdateTravelLog ?  CDoc::FHL_DONTUPDATETLOG : 0 ) |
                                                            ( fReplaceUrl ? CDoc::FHL_REPLACEURL : 0 ) ));
        if (hr)
            goto Cleanup;

        IGNORE_HR(_pWindow->Document()->Fire_PropertyChangeHelper(DISPID_CDocument_location,
                                                                  0,
                                                                  (PROPERTYDESC *)&s_propdescCDocumentlocation));
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmLocation::put_href(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE)));
}

HRESULT COmLocation::put_hrefInternal(BSTR v, BOOL fDontUpdateTravelLog, BOOL fReplaceUrl )
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE, fDontUpdateTravelLog , fReplaceUrl )));
}


HRESULT COmLocation::get_href(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_WHOLE, NULL, 0)));
}

HRESULT COmLocation::put_protocol(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PROTOCOL)));
}

HRESULT COmLocation::get_protocol(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PROTOCOL, NULL, 0)));
}

HRESULT COmLocation::put_host(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HOST)));
}

HRESULT COmLocation::get_host(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HOST, NULL, 0)));
}

HRESULT COmLocation::put_hostname(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HOSTNAME)));
}

HRESULT COmLocation::get_hostname(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HOSTNAME, NULL, 0)));
}

HRESULT COmLocation::put_port(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PORT)));
}

HRESULT COmLocation::get_port(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PORT, NULL, 0)));
}

HRESULT COmLocation::put_pathname(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PATHNAME)));
}

HRESULT COmLocation::get_pathname(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PATHNAME, NULL, 0)));
}

HRESULT COmLocation::put_search(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_SEARCH)));
}

HRESULT COmLocation::get_search(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_SEARCH, NULL, 0)));
}

HRESULT COmLocation::put_hash(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HASH)));
}

HRESULT COmLocation::get_hash(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HASH, NULL, 0)));
}

HRESULT COmLocation::reload(VARIANT_BOOL flag)
{
    LONG lOleCmdidf;

    if (flag)
        lOleCmdidf = OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_CLEARUSERINPUT|OLECMDIDF_REFRESH_THROUGHSCRIPT;
    else
        lOleCmdidf = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT|OLECMDIDF_REFRESH_THROUGHSCRIPT;

        // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
        // released while running script
        RRETURN(SetErrorInfo(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                              ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                              lOleCmdidf, FALSE, "COmWindowProxy::ExecRefreshCallback")));
}

HRESULT COmLocation::replace(BSTR bstr)
{
    HRESULT hr = S_OK;

    // 5.0 compat, don't allow location.replace if we are in a dialog
    if (   _pWindow
        && _pWindow->_pMarkup
        && !_pWindow->_pMarkup->Doc()->_fInHTMLDlg)
    {
        hr = THR(put_hrefInternal(bstr, TRUE, TRUE  ));
    }

    RRETURN( hr );
}

HRESULT COmLocation::assign(BSTR bstr)
{
    RRETURN(put_href(bstr));
}

HRESULT COmLocation::toString(BSTR * pbstr)
{
    RRETURN(get_href(pbstr));
}

//+-------------------------------------------------------------------------
//
//  COmHistory - implementation for the window.history object
//
//--------------------------------------------------------------------------

COmHistory::COmHistory(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;
}

ULONG COmHistory::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmHistory::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT COmHistory::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)

    default:
        if (iid == IID_IOmHistory)
            hr = THR(CreateTearOffThunk(this, COmHistory::s_apfnIOmHistory, NULL, ppv));
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

const COmHistory::CLASSDESC COmHistory::s_classdesc =
{
    &CLSID_HTMLHistory,                  // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IOmHistory,                     // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::get_length
//
//  Synopsis : Returns the number of entries in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::get_length(short * pLen)
{
    *pLen = (short)_pWindow->Doc()->NumTravelEntries();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::back
//
//  Synopsis : Navigates back in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::back(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    IGNORE_HR(_pWindow->Doc()->Travel(TLOG_BACK));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::forward
//
//  Synopsis : Navigates forward in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::forward(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    IGNORE_HR(_pWindow->Doc()->Travel(TLOG_FORE));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::go
//
//  Synopsis : Navigates to the offset or URL in the history as
//             specified by pvarDistance
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::go(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    // Parameter is optional.  If not present, just refresh.
    if (VT_ERROR == pvarDistance->vt || DISP_E_PARAMNOTFOUND == pvarDistance->scode)
    {
        // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
        // released while running script
        IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                              ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                              OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
        goto Cleanup;
    }

    // Change type to short if possible.
    //
    if (!VariantChangeType(pvarDistance, pvarDistance, NULL, VT_I2))
    {
        //
        // If 0, just call Refresh
        //
        if (0 == pvarDistance->iVal)
        {
            // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
            // released while running script
            IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                                  ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                  OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
            goto Cleanup;
        }

        IGNORE_HR(_pWindow->Doc()->Travel(pvarDistance->iVal));
    }
    else
    {
        // Now see if it's a string.
        //
        if (VT_BSTR == pvarDistance->vt)
        {
            // Refresh if the URL wasn't specified
            if (!pvarDistance->bstrVal)
            {
                // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
                // released while running script
                IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                                      ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                      OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
                goto Cleanup;
            }

            IGNORE_HR(_pWindow->Doc()->Travel(_pWindow->_pMarkup->GetCodePage(), pvarDistance->bstrVal));
        }
    }

Cleanup:
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  COmNavigator - implementation for the window.navigator object
//
//--------------------------------------------------------------------------

COmNavigator::COmNavigator(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;

    _pPluginsCollection = NULL;
    _pMimeTypesCollection = NULL;
    _pOpsProfile = NULL;
}

COmNavigator::~COmNavigator()
{
    super::Passivate();
    delete _pPluginsCollection;
    delete _pMimeTypesCollection;
    delete _pOpsProfile;
}

ULONG COmNavigator::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmNavigator::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT
COmNavigator::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (iid == IID_IOmNavigator)
            hr = THR(CreateTearOffThunk(this, COmNavigator::s_apfnIOmNavigator, NULL, ppv));
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

const COmNavigator::CLASSDESC COmNavigator::s_classdesc =
{
    &CLSID_HTMLNavigator,                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IOmNavigator,                   // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};

void DeinitUserAgentString(THREADSTATE *pts)
{
    pts->cstrUserAgent.Free();
}

HRESULT EnsureUserAgentString()
{
    HRESULT hr = S_OK;
    TCHAR   szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
    DWORD   dwSize = MAX_PATH;

    szUserAgent[0] = '\0';

    if (!TLS(cstrUserAgent))
    {
        hr = ObtainUserAgentStringW(0, szUserAgent, &dwSize);
        if (hr)
            goto Cleanup;

        hr = (TLS(cstrUserAgent)).Set(szUserAgent);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_appCodeName(BSTR *p)
{
    HRESULT hr;
    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    hr = THR(FormsAllocStringLen(TLS(cstrUserAgent), 7, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_appName(BSTR *p)
{
    HRESULT hr;
    // TODO (sramani): Need to replace hard coded string with value from registry when available.
    hr = THR(FormsAllocString(_T("Microsoft Internet Explorer"), p));
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_appVersion(BSTR *p)
{
    HRESULT hr;
    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    hr = THR(FormsAllocString(TLS(cstrUserAgent) + 8, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_userAgent(BSTR *p)
{
    HRESULT hr;

    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    (TLS(cstrUserAgent)).AllocBSTR(p);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_cookieEnabled(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    BOOL    fAllowed;

    if (p)
    {
        hr = THR(_pWindow->_pMarkup->ProcessURLAction(URLACTION_COOKIES_ENABLED, &fAllowed)); //which markup?
        if (!hr)
            *p = fAllowed ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
        hr = E_POINTER;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
COmNavigator::javaEnabled(VARIANT_BOOL *enabled)
{
    HRESULT hr;
    BOOL    fAllowed;

    hr = THR(_pWindow->_pMarkup->ProcessURLAction(URLACTION_JAVA_PERMISSIONS, &fAllowed));
    if (hr)
        goto Cleanup;

    if (enabled)
    {
        *enabled = fAllowed ?  VARIANT_TRUE : VARIANT_FALSE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
COmNavigator::taintEnabled(VARIANT_BOOL *penabled)
{
    HRESULT hr = S_OK;

    if(penabled != NULL)
    {
        *penabled = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    RRETURN(hr);
}


HRESULT COmNavigator::toString(BSTR * pbstr)
{
    RRETURN(super::toString(pbstr));
}

//+-----------------------------------------------------------------
//
//  members : get_mimeTypes
//
//  synopsis : IHTMLELement implementaion to return the mimetypes collection
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_mimeTypes(IHTMLMimeTypesCollection **ppMimeTypes)
{
    HRESULT     hr;

    if (ppMimeTypes == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppMimeTypes = NULL;

    if(_pMimeTypesCollection == NULL)
    {
        // create the collection
        _pMimeTypesCollection = new CMimeTypes();
        if (_pMimeTypesCollection == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(_pMimeTypesCollection->QueryInterface(IID_IHTMLMimeTypesCollection,
        (VOID **)ppMimeTypes));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  members : get_plugins
//
//  synopsis : IHTMLELement implementaion to return the filter collection
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_plugins(IHTMLPluginsCollection **ppPlugins)
{
    HRESULT     hr;

    if (ppPlugins == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppPlugins = NULL;

    //Get existing Plugins Collection or create a new one
    if (_pPluginsCollection == NULL)
    {
        _pPluginsCollection = new CPlugins();
        if (_pPluginsCollection == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR_NOTRACE(_pPluginsCollection->QueryInterface(IID_IHTMLPluginsCollection,
        (VOID **)ppPlugins));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
COmNavigator::get_userProfile(IHTMLOpsProfile **ppOpsProfile)
{
    return  get_opsProfile(ppOpsProfile);
}

//+-----------------------------------------------------------------
//
//  members : get_opsProfile
//
//  synopsis : IHTMLOpsProfile implementaion to return the profile object.
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_opsProfile(IHTMLOpsProfile **ppOpsProfile)
{
    HRESULT     hr;

    if (ppOpsProfile == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppOpsProfile = NULL;

    //Get existing opsProfile object or create a new one

    if (_pOpsProfile == NULL)
    {
        _pOpsProfile = new COpsProfile();
        if (_pOpsProfile == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR_NOTRACE(_pOpsProfile->QueryInterface(IID_IHTMLOpsProfile,
        (VOID **)ppOpsProfile));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_cpuClass(BSTR *p)
{
    HRESULT hr = S_OK; // For Now
    DWORD dwArch = 0;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    SYSTEM_INFO SysInfo;
    ::GetSystemInfo(&SysInfo);

    // mihaii NOTE:
    // I temporarly changed the switch statement below into
    // an if-then-else because of an optimization bug
    // in the 64 bit compiler

    /*
    switch(SysInfo.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *p = SysAllocString(_T("x86"));
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        *p = SysAllocString(_T("AMD64"));
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        *p = SysAllocString(_T("IA64"));
        break;
    default:
        *p = SysAllocString(_T("Other"));
        break;
    }
    */

    dwArch = SysInfo.wProcessorArchitecture;

    if (dwArch == PROCESSOR_ARCHITECTURE_INTEL)
    {
        *p = SysAllocString(_T("x86"));
    }
    else if (dwArch == PROCESSOR_ARCHITECTURE_AMD64)
    {
        *p = SysAllocString(_T("AMD64"));
    }
    else if (dwArch == PROCESSOR_ARCHITECTURE_IA64)
    {
        *p = SysAllocString(_T("IA64"));
    }
    else
    {
        *p = SysAllocString(_T("Other"));
    }

    if(*p == NULL)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_systemLanguage(BSTR *p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(::GetSystemDefaultLCID(), p));

Cleanup:
    RRETURN(hr);
}

HRESULT
COmNavigator::get_browserLanguage(BSTR *p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(MAKELCID(MLGetUILanguage(), SORT_DEFAULT), p));

Cleanup:
    RRETURN(hr);
}


HRESULT
COmNavigator::get_userLanguage(BSTR *p)
{
    HRESULT hr;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(::GetUserDefaultLCID(), p));

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_platform(BSTR *p)
{
    HRESULT hr = S_OK;

    // Nav compatability item, returns the following in Nav:-
    // Win32,Win16,Unix,Motorola,Max68k,MacPPC
    TCHAR *pszPlatform =
#ifdef WIN16
        _T("Win16");
#else
#ifdef WINCE
        _T("WinCE");    // Invented - obviously not a Nav compat issue!
#else
#ifndef UNIX
        _T("Win32");
#else
#ifndef ux10
        *p = SysAllocString ( L"SunOS");
#else
        *p = SysAllocString ( L"HP-UX");
#endif // ux10
#endif // unix

#endif // WINCE
#endif // WIN16

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;

    hr = THR(FormsAllocString ( pszPlatform, p ));
Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_appMinorVersion(BSTR *p)
{
    HKEY hkInetSettings;
    long lResult;
    HRESULT hr = S_FALSE;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;

    lResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                        &hkInetSettings );

    if( ERROR_SUCCESS == lResult )
    {
        DWORD dwType;
        DWORD size = pdlUrlLen;
        BYTE  buffer[pdlUrlLen];

        // If this is bigger than MAX_URL_STRING the registry is probably hosed.
        lResult = RegQueryValueEx( hkInetSettings, _T("MinorVersion"), 0, &dwType, buffer, &size );

        RegCloseKey(hkInetSettings);

        if( ERROR_SUCCESS == lResult && dwType == REG_SZ )
        {
            // Just figure out the real length since 'size' is ANSI bytes required.
            *p = SysAllocString( (LPCTSTR)buffer );
            hr = *p ? S_OK : E_OUTOFMEMORY;
        }
    }

    if ( hr )
    {
        *p = SysAllocString ( L"0" );
        hr = *p ? S_OK : E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_connectionSpeed(long *p)
{
    *p = NULL;
    RRETURN(E_NOTIMPL);
}

extern BOOL IsGlobalOffline();

HRESULT COmNavigator::get_onLine(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = (IsGlobalOffline()) ? VB_FALSE : VB_TRUE;

Cleanup:
     RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  CPlugins implementation.
//
//-------------------------------------------------------------------

const CBase::CLASSDESC CPlugins::s_classdesc =
{
    &CLSID_CPlugins,                    // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLPluginsCollection,        // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};

HRESULT
CPlugins::get_length(LONG *pLen)
{
    HRESULT hr = S_OK;
    if(pLen != NULL)
        *pLen = 0;
    else
        hr =E_POINTER;

    RRETURN(hr);
}

HRESULT
CPlugins::refresh(VARIANT_BOOL fReload)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member  : CPlugins::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CPlugins::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if (iid == IID_IHTMLPluginsCollection)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLPluginsCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


const CBase::CLASSDESC CMimeTypes::s_classdesc =
{
    &CLSID_CMimeTypes,                  // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLMimeTypesCollection,      // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};



HRESULT
CMimeTypes::get_length(LONG *pLen)
{
    HRESULT hr = S_OK;
    if(pLen != NULL)
        *pLen = 0;
    else
        hr = E_POINTER;

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : CMimeTypes::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CMimeTypes::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if ( iid == IID_IHTMLMimeTypesCollection )
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLMimeTypesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+-----------------------------------------------------------------
//
//  COpsProfile implementation.
//
//-------------------------------------------------------------------

const CBase::CLASSDESC COpsProfile::s_classdesc =
{
    &CLSID_COpsProfile,                 // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLOpsProfile,               // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};


HRESULT
COpsProfile::getAttribute(BSTR name, BSTR *value)
{
    HRESULT hr = S_OK;
    // Should never get called.

    // But this gets called right now and
    // is likely to not get called once this
    // is implemented in the new shdocvw.dll.

    if ( value != NULL)
    {
        *value = NULL;
    }
    else
    {
        hr = E_POINTER;
    }
    RRETURN(hr);
}

HRESULT
COpsProfile::setAttribute(BSTR name, BSTR value, VARIANT prefs, VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
COpsProfile::addReadRequest(BSTR name, VARIANT reserved, VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}


HRESULT
COpsProfile::addRequest(BSTR name, VARIANT reserved, VARIANT_BOOL *p)
{
    return addReadRequest(name,reserved,p);
}

HRESULT
COpsProfile::clearRequest()
{
    return S_OK;
}

HRESULT
COpsProfile::doRequest(VARIANT usage, VARIANT fname,
                       VARIANT domain, VARIANT path, VARIANT expire,
                       VARIANT reserved)
{
    return S_OK;
}

HRESULT
COpsProfile::doReadRequest(VARIANT usage, VARIANT fname,
                           VARIANT domain, VARIANT path, VARIANT expire,
                           VARIANT reserved)
{
    return S_OK;
}

HRESULT
COpsProfile::commitChanges(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
COpsProfile::doWriteRequest(VARIANT_BOOL *p)
{
    return commitChanges(p);
}



//+---------------------------------------------------------------
//
//  Member  : COpsProfile::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COpsProfile::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if (iid == IID_IHTMLOpsProfile)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLOpsProfile, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\gsecdn16.cxx ===
// copy of GetSecurityDomainFromURL from 32bit shdocvw
// Why is that in shdocvw? Shouldn't it be in shlwapi?
// This uses MemAlloc for it's mem allocation, so use MemFree to free it.

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define MAX_URL_STRING 1024
#define ASSERT Assert

// HRESULT GetSecurityDomainFromURL(WCHAR *pchURL, WCHAR **ppchDomain);
//
// The pchURL argument is the URL of a page. A string representing
// the security domain of the URL is returned in ppchDomain.
// The caller is responsible for freeing the string using CoTaskMemFree.
// The caller can compare security domains using wcscmp (case sensitive compare).
// The security domain string always begins with "<url scheme>:".
// If the scheme is HTTP or HTTPS and the host is specified as an IP address,
// then the second component of the security domain string is the IP address.
//
// If the scheme is HTTP or HTTPS and the host is specified as a domain name,
// then the second component of the security domain is the host's second
// level domain name.  For example, if the host is "www.microsoft.com",
// then the second level domain name is "microsoft.com".
// If the URL is a is a UNC file name, then the second component is the
// server name.
// If the URL is a file name rooted at a drive letter and the driver letter
// is mapped to a server, then the second component is the server name.
// If the URL is a local file, then the second component is the empty string.
// If the URL uses some other scheme not mentioned above, then the second
// component is the empty string.

STDAPI GetSecurityDomainFromURL(LPCTSTR pchURL, TCHAR **ppchDomain)
{
    HRESULT hres;
    *ppchDomain = NULL;

    // BUGWIN16 this needs more apis from urlmon, so until then.....
    CHAR szIn[MAX_URL_STRING];
#ifdef WIN16
    strncpy(szIn, pchURL, MAX_URL_STRING);
#else
    UnicodeToAnsi(pchURL, szIn, ARRAYSIZE(szIn));
#endif
    CHAR szInC[MAX_URL_STRING];
    DWORD cchT = ARRAYSIZE(szInC);
    hres = UrlCanonicalize(szIn, szInC, &cchT, 0); 

    if (SUCCEEDED(hres)) {
    
        CHAR * const pszOut = szIn; // re-use
        LPTSTR pszT;

        // Find the protocol and prefix
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        hres = ParseURL(szInC, &pu);

        if (SUCCEEDED(hres))
        {
            // Copy the protocol + separator. Make it zero-terminated.
            lstrcpyn(pszOut, pu.pszProtocol, pu.cchProtocol+2);
    
            // Copy additional protocol specific data
            if (pu.nScheme==URL_SCHEME_HTTP || pu.nScheme==URL_SCHEME_HTTPS)
            {
                LPCSTR pszSep = pu.pszSuffix;
                // skip '/'s
                while(*pszSep=='/') pszSep++;
    
                // Find the separator '/' and truncate the rest.
                pszT = strchr(pszSep, '/');
                if (pszT) {
                    *pszT = '\0';
                }
    
                // Copy the remaining.
#ifdef WIN16
                pszT = strrchr(pszSep, '.');
                if (pszT)
                {
                    // check if it's an IP address...
                    // fast check--only check last byte of address (x.x.x.lastbyte)                    
                    LPTSTR pszT2 = pszT;
                    while (*pszT2)
                    {
                        if (*pszT2 < '0' || *pszT2 > '9')
                        {
                            break;
                        }
                    }
                    if (*pszT2)
                    {
                        // not an IP address
                        // Find the second last dot.
                        while (pszT > pszSep && *pszT != '.')
                        { 
                            pszT--;
                        }
                        if (*pszT == '.')
                        {
                            pszSep = pszT + 1;
                        }
                    }
                }
#else
                if (!_IsThisIPAddress(pszSep)) {
                    // Find the last dot.
                    pszT = StrRChrA(pszSep, NULL, '.');
                    if (pszT) {
                        // Find the second last dot.
                        pszT = StrRChrA(pszSep, pszT, '.');
                        if (pszT) {
                            // Copy the "microsoft.com" portion only.
                            pszSep = pszT+1;
                        }
                    } 
                }
#endif // win16 else
                strncat(pszOut, pszSep, ARRAYSIZE(szIn));
    
                //TraceMsg(DM_SDOMAIN, "HTTP + %s", pszSep);
    
            } else if (pu.nScheme==URL_SCHEME_FILE) {
                CHAR szPath[MAX_PATH];
                cchT = MAX_PATH; //ARRAYSIZE(szPath);
                hres = PathCreateFromUrl(szInC, szPath, &cchT, 0);
    
                // Copy the server name.
                if (SUCCEEDED(hres)) {
                    if (PathIsUNC(szPath)) {
                        ASSERT(szPath[0]=='\\');
                        ASSERT(szPath[1]=='\\');
                        // Find the separator '\\' and truncate the rest.
                        LPSTR pszT = strchr(szPath+2, '\\');
                        if (pszT) {
                            *pszT = '\0';
                        }
                        strncat(pszOut, szPath, ARRAYSIZE(szIn));
                    }
                }
            }

            if (SUCCEEDED(hres)) {
#ifdef WIN16
                *ppchDomain = (char *)CoTaskMemAlloc(strlen(pszOut)+1);
                strcpy(*ppchDomain, pszOut);
#else
                TraceMsg(DM_SDOMAIN, "Returning %s", pszOut);
                *ppchDomain = MakeWideStrFromAnsi(pszOut, STR_OLESTR);
#endif
                if (*ppchDomain==NULL) {
                    hres = E_OUTOFMEMORY;
                }
            }
        } else {
            hres = E_INVALIDARG;
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\hlink.cxx ===
//+------------------------------------------------------------------------
//
//  File:       hlink.cxx
//
//  Contents:   CDoc hyperlinking support.
//              FollowHyperlink() for linking out
//              IHlinkTarget for linking in
//              ITargetFrame for frame targeting
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"    // for cbindtask
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"        // for std hyperlink object
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"     // for ez hyperlink api
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"   // for url caching api
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"  // for _pcollectioncache
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for itargetframe, itargetembedding
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"     // for iwebbrowserapp
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx" // for IHtmlLoadOptions, et al..
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_USER32_HXX_
#define X_USER32_HXX_
#include "user32.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif




extern BOOL g_fInAutoCad;
extern BOOL g_fInLotusNotes;

ExternTag(tagSecurityContext);
PerfDbgTag(tagNavigate, "Doc", "Measure FollowHyperlink");
MtDefine(FindTargetWindow, Locals, "FindTargetWindow (base target string)")
MtDefine(HlinkBaseTarget, Locals, "Hlink (base target string)")
MtDefine(CTaskLookForBookmark, Utilities, "CTaskLookForBookmark")

///////////////////////////////////////

DYNLIB g_dynlibSHDOCVW = { NULL, NULL, "SHDOCVW.DLL" };

#define WRAPIT_SHDOCVW(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibSHDOCVW, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

WRAPIT_SHDOCVW(HlinkFrameNavigate,
    (DWORD                   grfHLNF,
    LPBC                    pbc,
    IBindStatusCallback *   pibsc,
    IHlink *                pihlNavigate,
    IHlinkBrowseContext *   pihlbc),
    (grfHLNF, pbc, pibsc, pihlNavigate, pihlbc))

WRAPIT_SHDOCVW(HlinkFrameNavigateNHL,
    (DWORD grfHLNF,
    LPBC pbc,
    IBindStatusCallback *pibsc,
    LPCWSTR pszTargetFrame,
    LPCWSTR pszUrl,
    LPCWSTR pszLocation),
    (grfHLNF, pbc, pibsc, pszTargetFrame, pszUrl, pszLocation))

WRAPIT_SHDOCVW(HlinkFindFrame,
    (LPCWSTR pszFrameName,
    LPUNKNOWN *ppunk),
    (pszFrameName, ppunk))

#pragma warning(disable:4706)   // assignment within conditional expression.

BOOL
IsSpecialUrl(LPCTSTR pszURL)
{
    UINT uProt = GetUrlScheme(pszURL);

    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT   == uProt ||
            URL_SCHEME_ABOUT      == uProt);
}

BOOL
IsScriptUrl(LPCTSTR pszURL)
{
    UINT uProt = GetUrlScheme(pszURL);

    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT   == uProt);
}

//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

HRESULT
UnescapeAndTruncateUrl(TCHAR * pchURL, BOOL fRemoveUnescaped /* = TRUE */)
{
    HRESULT   hr = S_OK;
    CStr      cstrSafeUrl;
    TCHAR   * pch;
    TCHAR     achUrl[pdlUrlLen];
    DWORD     dwSize;
    TCHAR *   pchPos = NULL;

    if (!pchURL)
        return S_OK;

    if (IsSpecialUrl(pchURL))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // Copy the URL so we can munge it.
        //
        cstrSafeUrl.Set(pchURL);

        // someone could put in a string like this:
        //     %2501 OR %252501 OR %25252501
        // which, depending on the number of decoding steps, will bypass security
        // so, just keep decoding while there are %s and the string is getting shorter
        UINT uPreviousLen = 0;
        while ((uPreviousLen != cstrSafeUrl.Length()) && _tcschr(cstrSafeUrl, _T('%')))
        {
            uPreviousLen = cstrSafeUrl.Length();
            int nNumPercents;
            int nNumPrevPercents = 0;

            // Reduce the URL
            //
            for (;;)
            {
                // Count the % signs.
                //
                nNumPercents = 0;

                pch = cstrSafeUrl;
                while (pch = _tcschr(pch, _T('%')))
                {
                    pch++;
                    nNumPercents++;
                }

                if (nNumPercents > 0)
                {
                    // QFE 2735 (Georgi XDomain): [alanau]
                    //
                    // If the special URL contains an %00 sequence, then it will be converted to a Null char when
                    // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
                    // sequence, and display a "Permission Denied" script error.
                    //
                    // Moved from above to catch %2500, %252500 ....
                    //
                    pchPos = _tcsstr((TCHAR*) cstrSafeUrl, _T("%00"));

                    if (pchPos)
                    {
                        *pchPos = NULL;
                        hr = E_ACCESSDENIED;
                        goto Cleanup;
                    }
                }

                // If the number of % signs has changed, we've reduced the URL one iteration.
                //
                if (nNumPercents != nNumPrevPercents)
                {
                    // Encode the URL 
                    hr = THR(CoInternetParseUrl(cstrSafeUrl, 
                        PARSE_ENCODE, 
                        0, 
                        achUrl, 
                        ARRAY_SIZE(achUrl), 
                        &dwSize,
                        0));

                    cstrSafeUrl.Set(achUrl);

                    nNumPrevPercents = nNumPercents;
                }
                else
                {
                    // The URL is fully reduced.  Break out of loop.
                    //
                    break;
                }
            }
        }
    }    

Cleanup:

    if (cstrSafeUrl.Length() && 
        (fRemoveUnescaped || cstrSafeUrl.Length() != (unsigned)lstrlen(pchURL)))
    {
        pchPos = _tcsstr(cstrSafeUrl, _T("\1"));

        if (pchPos)
        {
            hr = E_ACCESSDENIED;
            pchURL[pchPos-cstrSafeUrl] = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
WrapSpecialUrl(TCHAR *pchURL, CStr *pcstrExpandedUrl, const TCHAR *pchDocUrl, BOOL fNonPrivate, BOOL fIgnoreUrlScheme)
{
    HRESULT   hr = S_OK;
    CStr      cstrSafeUrl;
    TCHAR   * pch, * pchPrev;

    if (IsSpecialUrl(pchURL) || fIgnoreUrlScheme)
    {

        hr = UnescapeAndTruncateUrl(pchURL);

        hr = THR(pcstrExpandedUrl->Set(pchURL));
        if (hr)
            goto Cleanup;

        hr = THR(pcstrExpandedUrl->Append( fNonPrivate ? _T("\1\1") : _T("\1")));
        if (hr)
            goto Cleanup;


        // Now copy the pchDocUrl
        //
        cstrSafeUrl.Set(pchDocUrl);


        // Scan the URL to ensure it appears un-spoofed.
        //
        // There may legitimately be multiple '\1' characters in the URL.  However, each one, except the last one
        // should be followed by a "special" URL (javascript:, vbscript: or about:).
        //
        pchPrev = cstrSafeUrl;
        pch = _tcschr(cstrSafeUrl, _T('\1'));
        while (pch)
        {
            pch++;                              // Bump past security marker
            if (*pch == _T('\1'))               // (Posibly two security markers)
                pch++;
                
            if (!IsSpecialUrl(pchPrev))         // If URL is not special
            {
                hr = E_ACCESSDENIED;            // then it's spoofed.
                goto Cleanup;
            }
            pchPrev = pch;
            pch = _tcschr(pch, _T('\1'));
        }

        // Look for escaped %01 strings in the Security Context.
        //
        pch = cstrSafeUrl;
        while (pch = _tcsstr(pch, _T("%01")))
        {
            pch[2] = _T('2');  // Just change the %01 to %02.
            pch += 3;          // and skip over
        }

        hr = THR(pcstrExpandedUrl->Append(cstrSafeUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pcstrExpandedUrl->Set(pchURL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

#pragma warning(default:4706)   // assignment within conditional expression.

//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CanNavigateFramesAccrossDomains(COmWindowProxy * pWindow, 
                                const TCHAR *    pchTarget, 
                                const TCHAR *    pchUrlContext)
{
    HRESULT hr = S_OK;

    if (!pWindow->AccessAllowedToNamedFrame(pchTarget))
    {
        CStr cstrCallerUrl;
        DWORD dwPolicy = 0;
        DWORD dwContext = 0;
        DWORD dwPUAF = 0;

        if (pchUrlContext)
        {
            cstrCallerUrl.Set(pchUrlContext);
        }
        else
        {
            cstrCallerUrl.Set(CMarkup::GetUrl(pWindow->Markup()));
        }

        Assert(pWindow->Window());

        if (pWindow->Window()->_fRestricted)
            dwPUAF |= PUAF_ENFORCERESTRICTED;

        if ( !hr && !SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                          URLACTION_HTML_SUBFRAME_NAVIGATE, dwPUAF, NULL))
            ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
        {
            hr = E_ACCESSDENIED;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// IsErrorPageToSpecialUrl
//
// If we are navigating from a special Url from a special Url
// Check to see if the source page is an error page.
//
// If we are an error page we have lost the LocationContext,
// because we have a new instance of Trident. The error page
// has local machine zone and Internet zone can have a 
// reference to the page.
//
//---------------------------------------------------------------------------+

BOOL IsErrorPageToSpecialUrl(COmWindowProxy* pWindow,
                             LPCTSTR pchUrl,
                             LPCTSTR pchUrlContext)
{
    if (pWindow && pWindow->Markup())
    {
        LPCTSTR pszSourceUrl  = NULL;

        pszSourceUrl = pWindow->Markup()->Url();

        UINT uProt = GetUrlScheme(pszSourceUrl);

        if ((uProt == URL_SCHEME_RES) &&
            IsSpecialUrl(pchUrl))
        {
            BOOL fIsError = TRUE;

            // If we don't have trident services we could not have trident error pages
            // and we are not hosted in IE. That is why I fail to false
            if (pWindow->Markup()->Doc()->_pTridentSvc)
            {
                HRESULT hr = THR(pWindow->Markup()->Doc()->_pTridentSvc->IsErrorUrl(pszSourceUrl, &fIsError));

                if (FAILED(hr))
                {
                    fIsError = TRUE;
                }

                if (fIsError)
                {
                    if ((pchUrlContext == NULL) ||
                        (_tcslen(pchUrlContext) == 0))
                    {
                        // This is javascript from the error page itself
                        return FALSE;
                    }

                    return TRUE;
                }
            }
        }
    }
    else
    {
        AssertSz(0,"Why do not we have a target window with a markup?");
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FollowHyperlink
//
//  Synopsis:   Hyperlinks the specified target frame to the requested url
//              using ITargetFrame/IHyperlinkTarget of host if possible
//
//  Arguments:  pchURL            : the relative URL
//              pchTarget         : the target string
//              pElementContext   : element whose base should be searched for
//                                  a target name is pchTarget is null.
//              pDwnPost          : CDwnPost to use to post data.
//              fSendAsPost       : TRUE if post should be used.
//              fOpenInNewWindow  : TRUE to open in a new window
//              pWindow           : The window proxy to navigate.
//              ppWindowOut       : output window
//              dwBindf           : options to use while binding, used to
//                                  control refresh for frames
//              dwSecurityCode    : Used to give the appropriate alert when
//                                  sending data over the network.
//              fReplace          : TRUE replaces the current entry in 
//                                  the travel log.
//              ppHTMLWindow2     : The new window to use for navigation.
//              fOpenInNewBrowser : TRUE opens a new browser window.
//              dwFlags           : Misc. FHL_* control flags (this fn has way too many params already!)
//              pchName           : The window name.
//              pStmHistory       : History stream to load.
//              pElementMaster    : Element that will be master of newly created markup/window
//
//----------------------------------------------------------------------------

HRESULT
CDoc::FollowHyperlink(LPCTSTR           pchURL,
                      LPCTSTR           pchTarget,           /* = NULL */
                      CElement *        pElementContext,     /* = NULL */
                      CDwnPost *        pDwnPost,            /* = NULL */
                      BOOL              fSendAsPost,         /* = FALSE */
                      LPCTSTR           pchExtraHeaders,     /* = NULL */
                      BOOL              fOpenInNewWindow,    /* = FALSE */
                      COmWindowProxy  * pWindow,             /* = NULL */
                      COmWindowProxy ** ppWindowOut,         /* = NULL */
                      DWORD             dwBindf,             /* = 0 */
                      DWORD             dwSecurityCode,      /* = ERROR_SUCCESS */
                      BOOL              fReplace,            /* = FALSE */
                      IHTMLWindow2 **   ppHTMLWindow2,       /* = NULL */
                      BOOL              fOpenInNewBrowser,   /* = FALSE */
                      DWORD             dwFlags,             /* = 0 */
                      const TCHAR *     pchName,             /* = NULL */
                      IStream *         pStmHistory,         /* = NULL */
                      CElement *        pElementMaster,      /* = NULL */
                      LPCTSTR           pchUrlContext,       /* = NULL */
                      BOOL *            pfLocalNavigation,   /* = NULL */
                      BOOL *            pfProtocolNavigates, /* = NULL */
                      LPCTSTR           pchLocation,         /* = NULL */
                      LPCTSTR           pchAlternativeCaller /* = NULL */)
{
    PerfDbgLog1(tagNavigate, this, "+CDoc::FollowHyperlink \"%ls\"", pchURL);

    TCHAR *          pchBaseTarget       = NULL;
    IBindCtx *       pBindCtx            = NULL;
    CDwnBindInfo *   pDwnBindInfo        = NULL;
    BOOL             fProtocolNavigates  = TRUE;
    CStr             cstrExpandedUrl;
    CStr             cstrLocation;
    LPCTSTR          pchSubReferer;
    CDwnDoc *        pDwnDocOld          = NULL;
    HRESULT          hr;
    IHTMLWindow2   * pTargetHTMLWindow   = NULL;
    COmWindowProxy * pTargetOmWindow     = NULL;
    IHTMLDocument2 * pDocument           = NULL;
    TARGET_TYPE      eTargetType;
    IUnknown       * pUnkDwnBindInfo     = NULL;
    CMarkup *        pMarkup             = NULL;
    CStr             cstrUrlOriginal;
    BOOL             doZoneCheck         = TRUE;

    LPCTSTR pchCallerUrl = NULL;

    //
    // TODO (yinxie) this is a temporary solution until we clear all the
    // doudt about navigating inside popups
    // if this is a popup doc, no navigation allowed, even inside iframes
    //

    if (_fPopupDoc)
    {
        RRETURN(SetErrorInfo(E_NOTIMPL));
    }

    SetHostNavigation(FALSE);
    _fDelegatedDownload = FALSE;
	
    Assert(pElementContext || pWindow);
  
    if (!pWindow)
    {
        // This is a stress bug fix. pElementContext should be NULL only
        // in stress situations. Therefore, do not remove the above Assert.
        //
        if (pElementContext)
        {
            pMarkup = pElementContext->GetFrameOrPrimaryMarkup();
            pWindow = pMarkup->GetWindowPending();
        }

        // pWindow would be NULL if the Markup for pElementContext is switched
        // thus clearing its Window.
        if (!(pElementContext && pWindow))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else 
    {
        pMarkup = pWindow->Markup();
    }

    Assert (pWindow && pMarkup);

    //
    //  Error pages always have local zone
    //  and special URls inherit there zone from 
    //  the context. If no context is specified, then
    //  the context is that of the souce window.
    //
    
    if (IsErrorPageToSpecialUrl(pWindow,pchURL,pchUrlContext))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    if (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT | FHL_FRAMECREATION))
        dwBindf |= BINDF_HYPERLINK;

    if ((dwFlags & (FHL_FRAMECREATION | FHL_FRAMENAVIGATION)) && pWindow->Window()->_fRestricted)
        dwBindf |= BINDF_ENFORCERESTRICTED;

    if (pDwnPost)
    {
        // this flag is set when posting through this API, no matter if
        // we ultimately do a POST or a GET
        dwBindf |= BINDF_FORMS_SUBMIT;
        dwFlags |= FHL_FORMSUBMIT;
    }

    // Remember the subreferer of this doc

    pDwnDocOld    = pMarkup->GetDwnDoc();
    pchSubReferer = pDwnDocOld ? pDwnDocOld->GetSubReferer() : NULL;

    // If we are given a location, we will use
    // that instead of parsing the URL for it.
    //
    if (pchLocation && *pchLocation)
    {
        IGNORE_HR(THR(cstrLocation.Set(pchLocation)));
    }

    // Determine the expanded url and location.
    hr = THR(DetermineExpandedUrl(
                pchURL,

                // do not expand url if this came from shdocvw (#105737)
                !(dwFlags & FHL_SHDOCVWNAVIGATE),

                pElementContext,
                pMarkup,
                pDwnPost,
                fSendAsPost,
                dwSecurityCode,
                &cstrExpandedUrl,
                &cstrLocation,
                &cstrUrlOriginal,
                &fProtocolNavigates,
                (!pchLocation || !*pchLocation)));  // don't parse the location if we are given one.
    if (hr)
        goto Cleanup;

    // See Windows Bug 491140
    if (GetUrlScheme(LPTSTR(cstrExpandedUrl)) == URL_SCHEME_FILE)
    {
        TCHAR       * expandedUrlTemp = NULL;
        TCHAR       * pchExt = NULL;
        BOOL          allowNav = TRUE;
        TCHAR       * pchQuery = _tcschr(LPTSTR(cstrExpandedUrl), _T('?'));

        expandedUrlTemp = cstrExpandedUrl.TakePch();

        if (pchQuery != NULL)
        {
            *pchQuery = _T('\0');
        }
        pchExt = _tcsrchr(expandedUrlTemp, _T('.'));
        if (pchExt)
        {
            if (_tcsnicmp(pchExt, -1, _T(".url"), 4) == 0)
            {
                allowNav = AllowNavigationToLocalInternetShortcut(expandedUrlTemp);
            }
        }     
        if (pchQuery)
        {
            *pchQuery = _T('?');
        }
        
        cstrExpandedUrl.SetPch(expandedUrlTemp);

        if (allowNav == FALSE)
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    //
    // Check to see if you need to do a Zone elevation check.  Zone elevation check is
    // done for all cases except for top level navigations.
    if ((dwFlags & FHL_NOLOCALMACHINECHECK) || 
        (dwFlags & FHL_SHDOCVWNAVIGATE) || 
        (dwFlags & FHL_LOADHISTORY) ||
        (dwFlags & FHL_SETTARGETPRINTMEDIA) ||
        (dwFlags & FHL_CREATEDOCUMENTFROMURL))
    {
        doZoneCheck = FALSE;
    }

    if (doZoneCheck)
    {
        if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, pchUrlContext, cstrExpandedUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    eTargetType = GetTargetType(pchTarget);

    if (   (TARGET_SEARCH == eTargetType)
        || (TARGET_MEDIA  == eTargetType))
    {
        // Need to block special URLs in case they fail a src/dest
        // security check.
        if (IsSpecialUrl(pchURL))
        {
            if (!pWindow->AccessAllowedToNamedFrame(pchTarget))
           {
               hr = E_ACCESSDENIED;
               goto Cleanup;
           }
        }

        hr = QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
        if (hr)
            goto Cleanup;

        CLSID clsid = {0};
        if (TARGET_SEARCH == eTargetType)
        {
            clsid = CLSID_SearchBand;
        }
        else if (TARGET_MEDIA == eTargetType)
        {
            clsid = CLSID_MediaBand;
        }

        if (S_OK == NavigateInBand(pDocument,
                            pWindow->_pWindow,
                            clsid,
                            pchURL,
                            cstrExpandedUrl,
                            ppHTMLWindow2))
        {
            goto Cleanup;  // Navigation is complete.
        }
        else
        {
            if (TARGET_MEDIA == eTargetType)
            {
                fOpenInNewBrowser = TRUE;
                pchTarget = NULL;
            }
            else
            {
                pchTarget = _T("_self");
            }
        }
    }

    if (!fOpenInNewBrowser && fProtocolNavigates)
    {
        IWebBrowser2 * pTopWebOC = NULL;

        FindTargetWindow(&pchTarget,
                         &pchBaseTarget,
                         pElementContext,
                         &fOpenInNewBrowser,
                         pWindow,
                         &pTargetOmWindow,
                         &pTargetHTMLWindow,
                         &pTopWebOC,
                         dwFlags);

        // Check if we have security rights to target the top level window the 
        // name belongs to. Even if the name belongs to a frame, it is the top level
        // window that counts.
        hr = THR(CanNavigateFramesAccrossDomains(pWindow, pchTarget, pchUrlContext));
        if (hr)
            goto Cleanup;

        // There was an error finding the target window. This is 
        // usually due to the fact that a link in a band window
        // was clicked that targets the main window and the main
        // window contains a non-html file.
        //
        if (pTopWebOC)
        {
            CVariant cvarUrl(VT_BSTR);

            cstrExpandedUrl.AllocBSTR(&cvarUrl.bstrVal);

            pTopWebOC->Navigate2(&cvarUrl, NULL, NULL, NULL, NULL);
            pTopWebOC->Release();

            goto Cleanup;
        }

        if (ppHTMLWindow2)
        {
            if (pTargetHTMLWindow)
            {
                *ppHTMLWindow2 = pTargetHTMLWindow;
                (*ppHTMLWindow2)->AddRef();
            }  
            else if (pTargetOmWindow)
            {
                hr = THR(pTargetOmWindow->QueryInterface(IID_IHTMLWindow2, (void **) ppHTMLWindow2));
            }
        }

        //
        // If we are not being asked to not find existing windows and we find one, 
        // and if the initial url we received was an empty string, then bail out
        // for compat reasons.
        // We don't want to navigate an existing window to an about:blank if the URL
        // is NULL or empty.
        //
        if ((pTargetOmWindow || pTargetHTMLWindow) && 
            (!pchURL || !*pchURL) && 
            !(dwFlags & CDoc::FHL_HYPERLINKCLICK))
        {
            goto Cleanup;
        }
    }

    // 
    // Clicking on a link within a restricted frame :
    //      - Always open in new window, no in place navigation
    //      - Special URLs can not even open in new window, they fail right away
    //
    if (pWindow->Window() && pWindow->Window()->_fRestricted && (dwFlags & FHL_HYPERLINKCLICK))
    {
        if (IsSpecialUrl(cstrExpandedUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        fOpenInNewBrowser = TRUE;
    }

    // Found target window out of process (hence pTargetHTMLWindow vs. pTargetOmWindow)
    if (pTargetHTMLWindow)
    {
        AssertSz( !pTargetOmWindow, "Shouldn't have both pTargetHTMLWindow and pTargetOmWindow" );        
        Assert((dwFlags & CDoc::FHL_HYPERLINKCLICK) || (pchURL && *pchURL));

        //
        // prepare BindCtx
        //

        // Set up the bind info + context.
        hr = THR(SetupDwnBindInfoAndBindCtx(
                    cstrExpandedUrl,
                    pchSubReferer,
                    pchUrlContext,
                    pDwnPost,
                    fSendAsPost,
                    pchExtraHeaders,
                    pMarkup,
                    &dwBindf,
                    &pDwnBindInfo,
                    &pBindCtx,
                    dwFlags));
        if (hr)
            goto Cleanup;

        hr = THR(DoNavigateOutOfProcess(pTargetHTMLWindow,
                                        cstrExpandedUrl,
                                        cstrLocation,
                                        cstrUrlOriginal,
                                        pBindCtx,
                                        dwFlags));
    }
    else
    {
        if (pTargetOmWindow)
        {
            // make pWindow the navigation target window
            pWindow = pTargetOmWindow;
        }
        else if (ppHTMLWindow2)
        {
            fOpenInNewBrowser = TRUE;
        }

        // Set up the bind info + context.
        hr = THR(SetupDwnBindInfoAndBindCtx(
                    cstrExpandedUrl,
                    pchSubReferer,
                    pchUrlContext,
                    pDwnPost,
                    fSendAsPost,
                    pchExtraHeaders,
                    pMarkup,
                    &dwBindf,
                    &pDwnBindInfo,
                    &pBindCtx,
                    dwFlags));
        if (hr)
            goto Cleanup;
        
        if (pchUrlContext)
        {
            pchCallerUrl = pchUrlContext;
        }
        else if (pchAlternativeCaller) 
        {
            pchCallerUrl = pchAlternativeCaller;
        }
        else
        {
            pchCallerUrl = CMarkup::GetUrl(pWindow->Markup());
        }

        // Finally, navigate to the URL.
        hr = THR(DoNavigate(
                    &cstrExpandedUrl,
                    &cstrLocation,
                    pDwnBindInfo,
                    pBindCtx,
                    pchURL,
                    pchTarget,
                    pWindow,
                    ppWindowOut,
                    fOpenInNewWindow,
                    fProtocolNavigates,
                    fReplace,
                    fOpenInNewBrowser,
                    ppHTMLWindow2,
                    eTargetType,
                    dwFlags,
                    pchName,
                    fSendAsPost,
                    pchExtraHeaders,
                    pStmHistory,
                    cstrUrlOriginal,
                    pElementMaster, 
                    pfLocalNavigation,
                    pchCallerUrl));
    }        

Cleanup:
    if ( pfProtocolNavigates )
    {
        *pfProtocolNavigates = fProtocolNavigates; 
    }
    ReleaseInterface(pUnkDwnBindInfo);
    ReleaseInterface(pBindCtx);
    ReleaseInterface(pTargetHTMLWindow);
    ReleaseInterface(pDocument);
    MemFreeString(pchBaseTarget);

    // Do not release pTargetOmWindow. It's not AddRef'ed

    if (pDwnBindInfo)
        pDwnBindInfo->Release();

    if (S_FALSE == hr)
        hr = S_OK;

    PerfDbgLog(tagNavigate, this, "-CDoc::FollowHyperlink");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DetermineExpandedUrl
//
//  Synopsis:   determines the extended url
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::DetermineExpandedUrl(LPCTSTR           pchURL,
                           BOOL              fExpand,
                           CElement *        pElementContext,
                           CMarkup *         pMarkup,
                           CDwnPost *        pDwnPost,
                           BOOL              fSendAsPost,
                           DWORD             dwSecurityCode,
                           CStr *            pcstrExpandedUrl,
                           CStr *            pcstrLocation,
                           CStr *            pcstrUrlOriginal,
                           BOOL *            pfProtocolNavigates,
                           BOOL              fParseLocation
                          )
{
    HRESULT hr;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpandedUrl = cBuf;
    UINT    uProt;
    CStr    cstrTmp;

    Assert(pcstrExpandedUrl && pcstrLocation && pfProtocolNavigates);
    Assert(pMarkup || pElementContext);

    if (fExpand)
    {
        hr = THR(CMarkup::ExpandUrl(pMarkup, pchURL, ARRAY_SIZE(cBuf), 
                                    pchExpandedUrl, pElementContext));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO (MohanB) need to canonicalize the url here?
        _tcscpy(pchExpandedUrl, pchURL);
    }

    // If there no submit data to append, set the display url to be the expanded url
    // w/o removing the location
    if (fSendAsPost || !pDwnPost)
    {
        if (pcstrUrlOriginal)
        {
            hr = pcstrUrlOriginal->Set(pchExpandedUrl);
            if (hr)
                goto Cleanup;

            // If the original URL does not contain a location
            // and we have been given one, append it to the
            // original URL.
            //
            if (!fParseLocation)
            {
                Assert(pcstrLocation && *pcstrLocation);
                Assert(!_tcschr(pchExpandedUrl, '#'));

                // If there is no hash, add one.
                //
                if (*pcstrLocation[0] != _T('#'))
                {
                    pcstrUrlOriginal->Append(_T("#"));
                }

                pcstrUrlOriginal->Append(*pcstrLocation);
            }
        }
    }

    // Apply the checks for our old friend %01 hack. We don't want to set the URL
    // of the markup to a URL that contains a %01 hack since it will effect the
    // security ID operation.
    hr = cstrTmp.Set(pchExpandedUrl);
    if (hr)
        goto Cleanup;
    hr = THR(UnescapeAndTruncateUrl(cstrTmp));
    if (hr)
        goto Cleanup;

    // Opaque URL?
    if (!UrlIsOpaque(pchExpandedUrl))
    {
        LPTSTR pch;

        if (fParseLocation)
        {
            pch = (LPTSTR)UrlGetLocation(pchExpandedUrl);

            // Bookmark?
            if (pch)
            {
                // Yes (But is it really a bookmark).
                Assert(*pch == _T('#'));

                hr = THR(pcstrLocation->Set(pch));
                if (hr)
                    goto Cleanup;

                // So remove bookmark from expanded URL, remember bookmark has been
                // copied to cstrLocation.
                *pch = _T('\0');
            }
        }
#ifdef DBG
        else
        {
            Assert(!_tcschr(pchExpandedUrl, '#'));
        }
#endif

        // chop of '?' part if we are going to append '?'
        // TODO: use UrlGetQuery instead of searching for '?' ourselves
        if (!fSendAsPost && pDwnPost)
        {
            pch = _tcschr(pchExpandedUrl, _T('?'));
            if (pch)
                *pch = _T('\0');
        }
    }
    
    hr = THR(pcstrExpandedUrl->Set(pchExpandedUrl));
    if (hr)
        goto Cleanup;

    // Check for security violation, of sending (POSTING) data
    // to a server without a secure channel protocol (SSL/PCT).

    uProt = GetUrlScheme(*pcstrExpandedUrl);
    if (pDwnPost && URL_SCHEME_HTTPS != uProt)
    {
        // warn when submitting over a nonsecure connection
        if (dwSecurityCode)
        {
            DWORD dwPolicyTo;
            DWORD dwPolicyFrom;
            BOOL  fAllow;

            // step 1: silently check if form submission is allowed or should be queried
            hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_TO,
                                                &fAllow, 
                                                PUAF_NOUI | PUAF_WARN_IF_DENIED, 
                                                &dwPolicyTo, 
                                                *pcstrExpandedUrl));

            // The next four if statements are structured to avoid ia64 optimization problems
            // Please check the ia64 retail free builds of the Browser and MSHTMPAD before changing.

            if (hr)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            if (GetUrlPolicyPermissions(dwPolicyTo) == URLPOLICY_DISALLOW)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_FROM,
                                                &fAllow, PUAF_NOUI | PUAF_WARN_IF_DENIED, &dwPolicyFrom));

            if (hr)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            if (GetUrlPolicyPermissions(dwPolicyFrom) == URLPOLICY_DISALLOW)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            // step 2: if needed and allowed, query the user once, giving precedence to "To"
            // if this is a mailto, we ALWAYS pop up our security alert dialog

            if (URL_SCHEME_MAILTO == uProt)
            {
                int     nResult;

                hr = ShowMessage(&nResult, MB_OKCANCEL | MB_ICONWARNING, 0, IDS_MAILTO_SUBMITALERT);
                if (hr || nResult != IDOK)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }
            else if (GetUrlPolicyPermissions(dwPolicyTo) == URLPOLICY_QUERY)
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_TO,
                                                    &fAllow, 0, NULL, *pcstrExpandedUrl));
                if (hr || !fAllow)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }
            else if (GetUrlPolicyPermissions(dwPolicyFrom) == URLPOLICY_QUERY)
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_FROM, &fAllow));

                if (hr || !fAllow)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }

            // If we make it to here, it's allowed
        }
    }

    // Tack on the GET data if needed
    //
    hr = AppendGetData(pMarkup, pcstrExpandedUrl, pDwnPost, pchExpandedUrl, fSendAsPost);
    if (hr)
        goto Cleanup;

    // If there is submit data to append, set the display url to be the same as the navigate url
    if (!fSendAsPost && pDwnPost)
    {
        if (pcstrUrlOriginal)
        {
            hr = pcstrUrlOriginal->Set(*pcstrExpandedUrl);
            if (hr)
                goto Cleanup;
        }
    }

    // MHTML hook for outlook express
    // also fix for Lotus Notes - NATIVE FRAMES regression (IE 6 bug # 36342)
    if (_pHostUIHandler && !g_fInLotusNotes)
    {
        OLECHAR *pchURLOut = NULL;

        hr = _pHostUIHandler->TranslateUrl(0, *pcstrExpandedUrl, &pchURLOut);

        if (S_OK == hr
            && pchURLOut && _tcslen(pchURLOut))
        {
            // Replace the URL with the one we got back from Athena.
            pcstrExpandedUrl->Set(pchURLOut);
            CoTaskMemFree(pchURLOut);
        }
        else if (E_ABORT == hr)
        {
            // If we get back E_ABORT, it means Athena is taking over and we bail.
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    {
        DWORD dwNavigate, dwDummy;

        // Are we navigating? (mailto protocol)
        hr = THR(CoInternetQueryInfo(
                    *pcstrExpandedUrl,
                    QUERY_CAN_NAVIGATE,
                    0,
                    (LPVOID)&dwNavigate,
                    4,
                    &dwDummy,
                    0));

        if (!hr && !dwNavigate)
        {
            *pfProtocolNavigates = FALSE;
        }

        hr = S_OK;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member  : CDoc::AppendPostData
//
//  Synopsis: Appends GET data to an URL.
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::AppendGetData(CMarkup  * const pMarkup,
                    CStr     * const pcstrExpandedUrl,
                    CDwnPost * const pDwnPost,
                    LPCTSTR          pchExpandedUrl,
                    BOOL             fSendAsPost)
{
    HRESULT hr = S_OK;

    if (    pDwnPost
        &&  !fSendAsPost
        &&  pDwnPost->GetItemCount() > 0
        &&  !IsSpecialUrl(pchExpandedUrl))
    {
        CPostItem * pPostItem = pDwnPost->GetItems();

        if (pPostItem->_ePostDataType == POSTDATA_LITERAL)
        {
            UINT    cp        = NavigatableCodePage(pMarkup->GetCodePage());
            int     cchPrefix = pcstrExpandedUrl->Length() + 1; // len + '?'
            LPSTR   pszPost   = pPostItem->_pszAnsi;
            UINT    cbPost    = pszPost ? strlen(pszPost) : 0;
            UINT    cchPost   = 0;
            CStr    cstrT;

            hr = THR(mlang().ConvertStringToUnicode(NULL, cp, pszPost, &cbPost, NULL, &cchPost));
            if (FAILED(hr))
                goto Cleanup;

            // cchPost == 0 means the conversion failed
            Assert(cchPost > 0 || cbPost == 0);

            hr = THR(cstrT.Set(NULL, cchPrefix + cchPost + 1));
            if (FAILED(hr))
               goto Cleanup;

            _tcscpy(cstrT, *pcstrExpandedUrl);
            _tcscat(cstrT, _T("?"));

            hr = THR(mlang().ConvertStringToUnicode(NULL, cp, pszPost, &cbPost, (TCHAR *)cstrT + cchPrefix, &cchPost));
            if (hr != S_OK)
                goto Cleanup;

            cstrT[cchPrefix + cchPost] = 0;

            hr = THR(pcstrExpandedUrl->Set(cstrT));
            if (hr != S_OK)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CDoc::AllowNavigationToLocalInternetShortcut
//
//  Synopsis:   Block navigation to local .url files either from the address bar or from the links
//              Ignore the query string to find the extension correctly. # is valid in a file name so
//              we don't have to look for that. If this file url did have a # at the end, the navigation
//              will fail.
//
//  Arguments:  pchExpandedUrl - original expanded url
//------------------------------------------------------------------------------
BOOL            
CDoc::AllowNavigationToLocalInternetShortcut(TCHAR * pchExpandedUrl)
{
    BOOL        bAllowNav = FALSE;
    TCHAR       szDecodedURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cchDecodedURL = ARRAY_SIZE(szDecodedURL);
    size_t      initialLen = _tcslen(pchExpandedUrl);
    TCHAR       tempChar = _T('\0');

    // PathCreateFromUrl only accepts null terminated strings upto INTERNET_MAX_URL_LENGTH
    // but Trident uses pdlUrlLen which is 4K
    if (initialLen >= INTERNET_MAX_URL_LENGTH)
    {
        tempChar = pchExpandedUrl[INTERNET_MAX_URL_LENGTH];
        pchExpandedUrl[INTERNET_MAX_URL_LENGTH] = _T('\0');
    }

    if (SUCCEEDED(PathCreateFromUrl(pchExpandedUrl, 
                                    szDecodedURL, 
                                    &cchDecodedURL,
                                    NULL)))
    {
        TCHAR     * pwzMimeOut  = NULL;
        HRESULT     hrMime      = S_OK;           
        HANDLE      hFile       = INVALID_HANDLE_VALUE;
        ULONG       cb          = 0;
        // If this is a regular BindToStorage/Object bind,  read in either 2048 bytes 
        // or the entire file whichever is lesser into the buffer. (This is the urlmon behavior, 
        // the sniffing tries to get at least 256 but passes in a buffer big enough for 2048 
        // and the file:// protocol does a ReadFile for the entire chunk.)
        // For a fastbind we use 200 bytes of data to get mime info, see GetMimeInfoFromData()
        char        achFileBuf[2048];

        hFile = CreateFile(szDecodedURL,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                //  security descriptor
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }

        if (FILE_TYPE_DISK != GetFileType(hFile))
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }

        //  Here the file should be open and ripe for consumption
        if ( !ReadFile(hFile, achFileBuf, sizeof(achFileBuf), &cb, NULL) )
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }


CloseFile:
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            Verify(CloseHandle(hFile));
            if (SUCCEEDED(hrMime))
            {
                hrMime = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                              pchExpandedUrl,   // url - can be null                                              
                                              achFileBuf,       // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                              cb,               // size of buffer                                                 
                                              NULL,             // proposed mime if - can be null                                 
                                              0,                // will be defined                                                
                                              &pwzMimeOut,      // the suggested mime                                             
                                              0));
                if (SUCCEEDED(hrMime) && pwzMimeOut)
                {
                    if (_tcsnicmp(pwzMimeOut, -1, TEXT("text/html"), 9) != 0)
                        bAllowNav = TRUE;
                }
            }
        }

    }
    
    if (initialLen >= INTERNET_MAX_URL_LENGTH)
    {
        pchExpandedUrl[INTERNET_MAX_URL_LENGTH] = tempChar;
    }
        
    return bAllowNav;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CDoc::FindTargetWindow
//
//  Synopsis:   Searches for and returns the target window. If the target
//              window is found in the current process, a ptr to its proxy
//              is placed in ppTargOmWindowPrxy. If the target window is
//              found in another process, a ptr to its IHTMLWindow2 is 
//              placed in ppTargHTMLWindow. If the window is not found,
//              both these parameters will be null upon return.
//
//  Arguments:  pchTarget           - name of the target window
//              pElementContext     - element whose base should be searched for
//                                    a target name is pchTarget is null.
//              pfOpenInNewBrowser  - flag that indicates whether or not a
//                                    new browser window should be opened. This
//                                    will be TRUE if the target window is not
//                                    found.
//              pWindow             - window to use as a starting point for
//                                    the target search.
//              ppTargOmWindowPrxy  - COmWindowProxy of the found window. This
//                                    parameter will be non-null if the target
//                                    window is in this process.
//              ppTargHTMLWindow    - IHTMLWindow2 of the found window. This 
//                                    parameter will be non-null if the target
//                                    window is in a separate process.
//              ppTopWebOC          - the WebOC of the top-level browser. This
//                                    is set if there is a failure retrieving
//                                    the main window.
//              dwFlags             - FHL flags (FollowHyperlink)
//
//------------------------------------------------------------------------------

void
CDoc::FindTargetWindow(LPCTSTR *         ppchTarget,
                       TCHAR **          ppchBaseTarget,
                       CElement *        pElementContext,
                       BOOL *            pfOpenInNewBrowser,
                       COmWindowProxy *  pWindow,
                       COmWindowProxy ** ppTargOmWindowPrxy,
                       IHTMLWindow2   ** ppTargHTMLWindow,
                       IWebBrowser2   ** ppTopWebOC,
                       DWORD             dwFlags)
{
    HRESULT hr = S_OK;
    CWindow * pCWindow;

    Assert(ppTargHTMLWindow);

    if (ppTargOmWindowPrxy)
        *ppTargOmWindowPrxy = NULL;

    *ppTargHTMLWindow   = NULL;

    if (pfOpenInNewBrowser)
        *pfOpenInNewBrowser = FALSE;

    // The only callers to this function are DoNavigate() and FollowHyperlink()
    // and neither of them should ever pass in a NULL window.  Leaving the
    // check anyway since we're in lockdown and want to minimize changes.
    Assert(pWindow);
    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
    }
    
    pCWindow = pWindow->Window();    

    //  If we don't have a specific target, check if one is defined in a base
    //
    if (    !(dwFlags & FHL_IGNOREBASETARGET)
        &&  (NULL == *ppchTarget || 0 == **ppchTarget))
    {
        hr = THR(CMarkup::GetBaseTarget(ppchBaseTarget, pElementContext));
        if (hr)
            goto Cleanup;

        *ppchTarget = *ppchBaseTarget;
    }

    if (NULL == *ppchTarget || 0 == **ppchTarget)
    {
        if (    (dwFlags & FHL_HYPERLINKCLICK)
            &&  (_fIsActiveDesktopComponent || (_fActiveDesktop && !_fViewLinkedInWebOC))
            &&  !pCWindow->_pWindowParent)
        {
            hr = THR(MemAllocString(Mt(FindTargetWindow), _T("_desktop"), ppchBaseTarget));
            if (hr)
                goto Cleanup;

            *ppchTarget = *ppchBaseTarget;
        }
        else
            goto Cleanup;
    }

    Assert(pWindow);
    Assert(pCWindow);
        
    hr = pCWindow->FindWindowByName(*ppchTarget,
                                    ppTargOmWindowPrxy,
                                    ppTargHTMLWindow,
                                    ppTopWebOC);

    if (hr && (ppTopWebOC && !*ppTopWebOC) && pfOpenInNewBrowser)
    {
        *pfOpenInNewBrowser = TRUE;
    }

Cleanup:;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetupDwnBindInfoAndBindCtx
//
//  Synopsis:   creates and sets up the bind task
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::SetupDwnBindInfoAndBindCtx(LPCTSTR           pchExpandedUrl,
                                 LPCTSTR           pchSubReferer,
                                 LPCTSTR           pchUrlContext,
                                 CDwnPost *        pDwnPost,
                                 BOOL              fSendAsPost,
                                 LPCTSTR           pchExtraHeaders,
                                 CMarkup *         pMarkup,
                                 DWORD *           pdwBindf,
                                 CDwnBindInfo **   ppDwnBindInfo,
                                 IBindCtx **       ppBindCtx,
                                 DWORD             dwFlags)
{
    CDwnDoc * pDwnDoc = NULL;
    HRESULT hr = S_OK;
    DWORD dwOfflineFlag;
    const TCHAR * pchUrlCreator;
    CStr cstrBindCtxUrl;

    Assert(pdwBindf && ppDwnBindInfo && ppBindCtx);

    *ppDwnBindInfo = new CDwnBindInfo;

    if (!*ppDwnBindInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    MemSetName((*ppDwnBindInfo, "DwnBindInfo %ls", pchExpandedUrl));

    pDwnDoc = new CDwnDoc;

    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppDwnBindInfo)->SetDwnDoc(pDwnDoc);

    // The referer of the new document is the same as the sub referer
    // of this document.  Which should be the same as _cstrUrl, by the way.

    //
    // we should only set the referer if we are not coming from a supernavigate
    // or a history load.
    //
    if (pchSubReferer && (dwFlags & CDoc::FHL_SETDOCREFERER))
    {
        //
        // If we are navigating an existing frame using the src attribute, then
        // we want the referer to contain the URL of the parent window of the frame.
        // Otherwise, we use the current page's subreferer as the next page's referer.
        //
        if ((dwFlags & CDoc::FHL_FRAMENAVIGATION) && !(dwFlags & CDoc::FHL_FRAMECREATION))
        {
            // set the doc referer to the parent window's URL.
            Assert(pMarkup->Root()->HasMasterPtr());
            Assert(pMarkup->Root()->GetMasterPtr()->IsInMarkup());

            hr = THR(pDwnDoc->SetDocReferer(CMarkup::GetUrl(pMarkup->Root()->GetMasterPtr()->GetMarkup())));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pDwnDoc->SetDocReferer(pchSubReferer));

            if (hr)
                goto Cleanup;
        }
    }

    // The referer of items within the new document is the fully expanded
    // URL which we are hyperlinking to.

    hr = THR(pDwnDoc->SetSubReferer(pchExpandedUrl));
    if (hr)
        goto Cleanup;

    // Tell CDwnBindInfo that this is going to be a document binding.  That
    // lets it pick the correct referer to send in the HTTP headers.

    (*ppDwnBindInfo)->SetIsDocBind();

    // Set the accept language header if one was specified.
    if (_pOptionSettings->fHaveAcceptLanguage)
    {
        hr = THR(pDwnDoc->SetAcceptLanguage(_pOptionSettings->cstrLang));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pDwnDoc->SetUserAgent(_bstrUserAgent));
    if (hr)
        goto Cleanup;

    hr = THR(pDwnDoc->SetExtraHeaders(pchExtraHeaders));
    if (hr)
        goto Cleanup;

    // Post data is passed in
    if (pDwnPost && fSendAsPost)
    {
        (*ppDwnBindInfo)->SetDwnPost(pDwnPost);
    }

    IsFrameOffline(&dwOfflineFlag);
    *pdwBindf |= dwOfflineFlag;

    // Now set up bind context.
    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, ppBindCtx, 0));
    if (hr)
        goto Cleanup;

    pDwnDoc->SetBindf(*pdwBindf);
    pDwnDoc->SetDocBindf(*pdwBindf);
    if ( IsCpAutoDetect() )
        pDwnDoc->SetDocCodePage(CP_AUTO);
    else
        pDwnDoc->SetDocCodePage(
            NavigatableCodePage(_pOptionSettings->codepageDefault));

    // In case of navigating from shdocvw, set URL codepage to
    // the default codepage (to keep IE5 compatibility).
    // Encoding of current page, shouldn't affect URL encoding of
    // a new URL when navigating from the address bar.
    if (dwFlags & FHL_SHDOCVWNAVIGATE)
        pDwnDoc->SetURLCodePage(NavigatableCodePage(g_cpDefault));
    else
    {
        CODEPAGE codepage = pMarkup->GetCodePage();

        // Dmitryt: check for CP_UCS_2 prevents us from sending raw Unicode bytes (which is bad) 
        // in case we don't have "Always use UTF-8 checked"
        // In this case, we should try to convert to default codepage of the machine.
        // about:blank is Unicode page, so when we renavigate about:blank, we need this behavior
        pDwnDoc->SetURLCodePage(
            NavigatableCodePage((IsAutodetectCodePage(codepage) || codepage == CP_UCS_2) ? g_cpDefault : codepage));
    }

    // TODO (dmitryt) this load flags are not used for navigation. later, we create a new pDwnDoc
    // and don't bother to transfer this loadf, rather we get it from CDoc::SetLoadfFromPrefs
    // and this flags are lost anyway. Consider to remove this line.
    pDwnDoc->SetLoadf(_dwLoadf & (DLCTL_URL_ENCODING_DISABLE_UTF8 | DLCTL_URL_ENCODING_ENABLE_UTF8));
    // TODO (lmollico): This is for IE5 #52877. Maybe we should just set _dwLoadf completely.


    // Set up HtmlLoadOptions
    if (_pShortcutUserData && *_cstrShortcutProfile)
    {
        COptionArray *phlo = new COptionArray(IID_IHtmlLoadOptions);

        if (SUCCEEDED(hr) && phlo)
        {
            BOOL fHyperlink = TRUE;
            phlo->SetOption(HTMLLOADOPTION_HYPERLINK, &fHyperlink, sizeof(fHyperlink));
       
            if (_pShortcutUserData && *_cstrShortcutProfile)
            {
                VARIANT varName;

                V_VT(&varName) = VT_BSTR;
                _cstrShortcutProfile.AllocBSTR(&V_BSTR(&varName));

                // deliberately ignore failures here
                if (V_BSTR(&varName))
                {
                    phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                V_BSTR(&varName),
                                (lstrlenW(V_BSTR(&varName)) + 1)*sizeof(WCHAR));
                    VariantClear(&varName);
                }
            }

            hr = THR((*ppBindCtx)->RegisterObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM,
                                                   (IOptionArray *)phlo));
            phlo->Release();
        }

        if (hr)
            goto Cleanup;
    }


    hr = THR((*ppBindCtx)->RegisterObjectParam(SZ_DWNBINDINFO_OBJECTPARAM,
                (IBindStatusCallback *)*ppDwnBindInfo));
    if (hr)
        goto Cleanup;

    //  Add the document's URL to the bind context as a parameter. The URL will be
    //  used as a security ID later in the chain.

    pchUrlCreator = pMarkup->GetAAcreatorUrl();

    TraceTag((tagSecurityContext, 
                "CDoc::SetupDwnBindInfoAndBindCtx- Markup: 0x%x URL: %ws CreatorUrl: %ws", 
                pMarkup, 
                pchExpandedUrl, 
                pchUrlCreator));

    //
    // If we have a creatorUrl ourselves for this markup, windows that are opened
    // from this markup should also contain that as the base domain.
    // Else the window that is created from this markup should have this markup's URL
    // as its base domain.
    //
    if (pchUrlCreator)
    {
        if (pchUrlContext)
        {
            TraceTag((tagSecurityContext, "                                - Creator exists, Use context URL: %ws", pchUrlContext ));

            hr = THR(cstrBindCtxUrl.Set(pchUrlContext));
        }
        else if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)) || 
            (dwFlags & CDoc::FHL_ERRORPAGE))
        {
            TraceTag((tagSecurityContext, "                                - Creator exists, Carry over the creator url of the markup"));

            hr = THR(cstrBindCtxUrl.Set(pchUrlCreator));
        }
        else
        {
            TraceTag((tagSecurityContext, "                                - Creator Exists, Use markup's URL"));
            hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));
        }
    }
    else
    {
        //
        // if this is a frame navigation and the URL we are going to is a special URL,
        // then the creator should be set to the parent of this frame, as it would be 
        // if we were loading this URL the first time.
        //
        if (!(dwFlags & CDoc::FHL_FRAMENAVIGATION))
        {
            if (pchUrlContext)
            {
                TraceTag((tagSecurityContext, "                                - No Creator, not frame nav. context is available, Using nav.context URL"));
                hr = THR(cstrBindCtxUrl.Set(pchUrlContext));
            }
            else
            {
                TraceTag((tagSecurityContext, "                                - No Creator, not frame nav., Using Markup's URL"));
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));
            }
        }
        else if (IsSpecialUrl(pchExpandedUrl))
        {
            TraceTag((tagSecurityContext, "                                - Frame navigation and special URL"));

            //
            // If we are creating a new frame, pMarkup points to the markup that contains
            // the frame/iframe tag. pMarkup may point to a pending markup, but it's OK.
            //
            // If we are navigating a frame, then we should have a window for existing 
            // frames and that window will take us to the parent window's URL.
            //
            // If the frame is being created/navigated in the ether, our only chance
            // is to check the markup creator.

            if (dwFlags & CDoc::FHL_FRAMECREATION)
            {
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));                               
                TraceTag((tagSecurityContext, "                                - Frame creation. Use Markup's URL"));
            }
            else if (pMarkup->Window())
            {
                CWindow * pWindowParent = NULL;

                pWindowParent = pMarkup->Window()->Window()->_pWindowParent;

                // get the parent
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pWindowParent->Markup())));

                TraceTag((tagSecurityContext, "                                - Frame navigation/not creation, special URL. Use parent's URL"));
            }

            if (!cstrBindCtxUrl.Length() && pMarkup->HasWindowedMarkupContextPtr())
            {
                AssertSz(FALSE, "Why do we have this code path at all ? Creation of a frame in the ether ?");

                CMarkup * pMarkupCreator;
                // This is a markup being created in the ether. 

                pMarkupCreator = pMarkup->GetWindowedMarkupContextPtr();

                Assert(pMarkupCreator);

                pchUrlCreator = pMarkupCreator->GetAAcreatorUrl();

                if (pchUrlCreator)
                {
                    hr = THR(cstrBindCtxUrl.Set(pchUrlCreator));
                }
                else
                {
                    hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkupCreator)));
                }
            }
        }
    }
    if (hr)
        goto Cleanup;

    hr = THR(AddBindContextParam(*ppBindCtx, &cstrBindCtxUrl));
    if (hr)
        goto Cleanup;

Cleanup:

    
    if (pDwnDoc)
        pDwnDoc->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     PrepareURLForExternalApp
//
//  Synopsis:
//
//   Decodes and strips, if needed, file:// prefix
//
//  COMPAT - for IE30 compatibility reasons, we have to Unescape all Urls - zekel - 1-JUL-97
//  before passing them to an APP.  this does limit their use, but
//  people already depend on this behavior.  specifically MS Chat.
//
//+---------------------------------------------------------------------------

BOOL PrepareURLForExternalApp (LPCWSTR psz, 
                               LPWSTR  pszOut,
                               DWORD   nBufferSize,
                               LPDWORD pcchOut)
{
    BOOL fQuoteURL = TRUE;

    if ((pcchOut == NULL) || (psz == NULL) || (psz == NULL))
    {
        if (pcchOut)
        {
            (*pcchOut) = 0;
        }

        if (pszOut)
        {
            (*pszOut) = 0;
        }

        return FALSE;
    }

    switch(GetUrlScheme(psz))
    {
    case URL_SCHEME_FILE:
        if (!SUCCEEDED(PathCreateFromUrl(psz, pszOut, pcchOut, 0)))
        {
            return FALSE;
        }
        break;
    case URL_SCHEME_NEWS:
        fQuoteURL = FALSE;  // never quote the news protocol
    default:
        if (!SUCCEEDED(UrlUnescape((LPWSTR)psz, pszOut, pcchOut, 0)))
        {
            return FALSE;
        }
        // check if we really need to quote the url or not
        if (fQuoteURL && !StrChr(pszOut, _T(' ')))
            fQuoteURL = FALSE;
    }

    // We only check for the first quote because if they aren't matched
    // The execute will fail as being bogus anyway.

    if (((*pszOut) == '"') || ((*pszOut) == '\'') || ((*pszOut) == 0) || !fQuoteURL)
    {
        return TRUE;
    }

    // Don't forget the NULL and the quotes
    if (((*pcchOut) + 3) > nBufferSize)
    {
        return FALSE;
    }

    LPWSTR pTempBuffer;
    BOOL fResult;

    pTempBuffer = new WCHAR[nBufferSize];

    (*pTempBuffer) = '"';
    fResult = StringCchCopyW(pTempBuffer+1,nBufferSize,pszOut);

    if (SUCCEEDED(fResult))
    {
        (*(pTempBuffer + (*pcchOut) + 1)) = '"';
        (*(pTempBuffer + (*pcchOut) + 2)) = 0;

        fResult = SUCCEEDED(StringCchCopyW(pszOut,nBufferSize,pTempBuffer));
        
        if (SUCCEEDED(fResult))
        {
            (*pcchOut) = (*pcchOut) + 2;
        }
        else
        {
            (*pcchOut) = 0;
            (*pszOut)  = 0;
        }
    }

    delete[] pTempBuffer;
    
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     ShouldShellExecURL
//
//  Synopsis:   See if the URL is of a type that we should
//              ShellExecute()
//
//  Notes:      Moved from shodcvw.
//
//+---------------------------------------------------------------------------

BOOL ShouldShellExecURL( LPCTSTR pszURL )
{
    BOOL fRet = FALSE;
    TCHAR sz[MAX_PATH];
    DWORD cch = ARRAY_SIZE(sz);
    HKEY hk;

    if (SUCCEEDED(UrlGetPart(pszURL, sz, &cch, URL_PART_SCHEME, 0))
     && SUCCEEDED(AssocQueryKey(0, ASSOCKEY_CLASS, sz, NULL, &hk)))
    {
        if (lstrlen(pszURL) <= 230 ||
                (StrCmpI(sz, _T("telnet")) && 
                 StrCmpI(sz, _T("rlogin")) &&
                 StrCmpI(sz, _T("tn3270"))))
        {
            fRet = (NOERROR == RegQueryValueEx(hk, TEXT("URL Protocol"), NULL, NULL, NULL, NULL));
        }

        RegCloseKey(hk);
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DoNavigate
//
//  Synopsis:   navigates to a url for FollowHyperlink
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::DoNavigate(CStr *            pcstrInExpandedUrl,
                 CStr *            pcstrLocation,
                 CDwnBindInfo *    pDwnBindInfo,
                 IBindCtx *        pBindCtx,
                 LPCTSTR           pchURL,
                 LPCTSTR           pchTarget,
                 COmWindowProxy  * pWindow,     // Opener window
                 COmWindowProxy ** ppWindowOut,
                 BOOL              fOpenInNewWindow,
                 BOOL              fProtocolNavigates,
                 BOOL              fReplace,
                 BOOL              fOpenInNewBrowser,
                 IHTMLWindow2 **   ppHTMLWindow2,
                 TARGET_TYPE       eTargetType,
                 DWORD             dwFlags, /* FollowHyperlink flags, FHL_* */
                 const TCHAR *     pchName,
                 BOOL              fSendAsPost,       /* = FALSE */
                 LPCTSTR           pchExtraHeaders,
                 IStream *         pStmHistory,       /* = NULL  */
                 LPCTSTR           pchUrlOriginal,    /* = NULL  */
                 CElement *        pElementMaster,    /* = NULL  */
                 BOOL   *          pfLocalNavigation, /* = NULL  */
                 LPCTSTR           pchCallerUrl       /* = NULL  */)
{
    IMoniker  *    pMoniker          = NULL;
    IHlink *       pHlink            = NULL;
    IHlinkFrame *  pHlinkFrame       = NULL;
    HRESULT        hr                = S_OK;
    ULONG          cDie              = _cDie;
    CMarkup   *    pMarkup           = NULL;
    BOOL           fCancel           = FALSE;
    BOOL           fInFrmOrFrmTarget = FALSE;
    BOOL           fFrameTarget      = FALSE;
    BOOL           fLocalNavigation  = FALSE;
    BSTR           bstrMedia         = NULL;
    CDocument *    pTargetDocument   = NULL;
    CWindow   *    pCWindow          = NULL;
    IHTMLWindow2 * pTargetHTMLWindow = NULL;
    BOOL           fForceNewBrowser;
    BOOL           fForceUpdate      = FALSE;
    CVariant       cvarUrl(VT_BSTR);
    CVariant       cvarContinue(VT_BOOL);
    BOOL           fIsPrimaryMarkup  = FALSE;

    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
    }

    fIsPrimaryMarkup = pWindow->Markup()->IsPrimaryMarkup();

    // Unfortunately, we have to reset _fDontFireWebOCEvents
    // here so that BeforeNavigate2 will fire and we have 
    // to reset it in CMarkup::LoadFromInfo() because that 
    // method is sometimes called directly. See the comment
    // in CMarkup::LoadFromInfo() about why we check
    // _fInObjectTag and _fInHTMLDlg.
    //
    if (!_fInObjectTag && !_fInHTMLDlg && !(dwFlags & FHL_CREATEDOCUMENTFROMURL)) 
    {
        _fDontFireWebOCEvents = !!(dwFlags & FHL_DONTFIREWEBOCEVENTS);
    }

    pCWindow = pWindow->Window();

    if (!(dwFlags & FHL_FRAMECREATION) && !fOpenInNewBrowser)
    {
        pCWindow->ClearWindowData();
    }

    // need to clear this flag so that we do not inadvertently print the new markup
    // instead of the old.
    _fPrintJobPending = FALSE;


    // Figure out if this is a local navigation.  If that is the
    // case, we don't want to do a navigation at all, really, 
    // just scroll the screen to that element.
    // TODO: (jbeda) shdocvw doesn't do this if it can't use the cache
    if (    pcstrLocation 
        &&  pcstrLocation->Length() 
        &&  (   !pchTarget 
            ||  !_tcscmp(_T("_unspecifiedFrame"), pchTarget)
            ||  eTargetType == TARGET_SELF
            ||  eTargetType == TARGET_FRAMENAME)
       )
    {
        DWORD   cchWindowUrl = pdlUrlLen;
        TCHAR   achWindowUrl[pdlUrlLen];

        // Get the window's URL for comparison
        if (pcstrInExpandedUrl->Length())
        {
            // We were passing a NULL URL occasionally and tripping an assert,
            // so instead we continue with the return value that we would have gotten
            // had we made the call
            LPCTSTR pchTempUrl = pCWindow->_pMarkup->Url();
            if (pchTempUrl)
            {
                hr = THR(UrlCanonicalize(
                            pchTempUrl,
                            (LPTSTR) achWindowUrl,
                            &cchWindowUrl,
                            URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE));
            }
            else
            {
                hr = E_INVALIDARG;
            }
            if (hr)
                goto Cleanup;
        }

        //
        // If we refresh an http error page, then the pending markup will 
        // be server 404 error and the achWindowUrl will be the same page
        // as our current page.  We can't do location navigation for
        // this case, so we check here.
        //

        if (!pCWindow->_fHttpErrorPage)
        {
            //
            // If expanded URL's are equal, do location navigation.
            //

            if (   !pcstrInExpandedUrl->Length() 
                || !UrlCompare(achWindowUrl, *pcstrInExpandedUrl, TRUE))
            {
                fLocalNavigation = TRUE;
            }
        }
    }

    // We want to open a new window under two conditions:
    // 1) fOpenInNewBrowser is TRUE.
    // 2) The DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION is not set
    //    and the following conditions are true:
    //    a) We are not opening a frame window (fOpenInNewWindow == FALSE)
    //    b) We are not targeting a frame (pchTarget == NULL or is empty)
    //    c) We are not navigating within a frame (i.e, pWindow does
    //       not contain the primary markup.)
    //

    fFrameTarget = pchTarget && *pchTarget && eTargetType == TARGET_FRAMENAME;

    if (fOpenInNewWindow
        || !fIsPrimaryMarkup
        || fFrameTarget)
    {
        fInFrmOrFrmTarget = TRUE;
    }

    if (!_pTopWebOC && (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT)))
    {
        IGNORE_HR(QueryService(SID_SHlinkFrame, IID_IHlinkFrame, (void **) &pHlinkFrame));

        if (!pHlinkFrame)
        {
            if (_pInPlace && _pInPlace->_pFrame)
            {
                IGNORE_HR(_pInPlace->_pFrame->QueryInterface(IID_IHlinkFrame, (void **) &pHlinkFrame));
            }
        }

        if (pHlinkFrame)
        {
            if ((dwFlags & FHL_SHDOCVWNAVIGATE) && (URL_SCHEME_FILE == GetUrlScheme(*pcstrInExpandedUrl)))
            {
                hr = THR(CreateURLMonikerEx(NULL, *pcstrInExpandedUrl, &pMoniker, URL_MK_NO_CANONICALIZE));
            }
            else
            {
                hr = THR(CreateURLMoniker(NULL, *pcstrInExpandedUrl, &pMoniker));
            }
            if (hr)
                goto Cleanup;

            hr = THR(HlinkCreateFromMoniker(pMoniker, *pcstrLocation, NULL,
                     NULL, 0, NULL, IID_IHlink, (LPVOID *) &pHlink));
            if (hr)
                goto Cleanup;

            // only set the target if there's something to set
            if (fOpenInNewBrowser && pchTarget && *pchTarget)
            {
                hr = THR(pHlink->SetTargetFrameName(pchTarget));
                if (hr)
                    goto Cleanup;
            }

            hr = THR(pHlinkFrame->Navigate(fOpenInNewBrowser ? HLNF_OPENINNEWWINDOW : 0,
                                           pBindCtx,
                                           pDwnBindInfo,
                                           pHlink));
            goto Cleanup;
        }
    }

    // We want to open a new window under two conditions:
    // 1) fOpenInNewBrowser is TRUE.
    // 2) The DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION is not set
    //    and the following conditions are true:
    //    a) We are not opening a frame window (fOpenInNewWindow == FALSE)
    //    b) We are not targeting a frame (pchTarget == NULL or is empty)
    //    c) We are not navigating within a frame (i.e, pWindow does
    //       not contain the primary markup.)
    //

    fForceNewBrowser =      !fInFrmOrFrmTarget
                        &&  !(_dwFlagsHostInfo & DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION)
                        &&  !_pTopWebOC
                        &&  !fLocalNavigation
                        &&  !(dwFlags & FHL_METAREFRESH);

    if (fProtocolNavigates && (fOpenInNewBrowser || fForceNewBrowser))
    {
        if ((!pchTarget || !*pchTarget) && fForceNewBrowser)
        {
            pchTarget = _T("_unspecifiedFrame");            

            FindTargetWindow(&pchTarget,
                             NULL,
                             NULL,
                             NULL,
                             pWindow,
                             NULL,
                             &pTargetHTMLWindow,
                             NULL,
                             dwFlags);

            if (pTargetHTMLWindow)
            {
                hr = THR(DoNavigateOutOfProcess(pTargetHTMLWindow,
                                                *pcstrInExpandedUrl,
                                                *pcstrLocation,
                                                (TCHAR *) pchUrlOriginal,
                                                pBindCtx,
                                                dwFlags));
                goto Cleanup;
            }
        }
        
        // If running on NT5, we must call AllowSetForegroundWindow
        // so that the new window will be shown in the foreground.
        // 
        if (VER_PLATFORM_WIN32_NT == g_dwPlatformID
           && g_dwPlatformVersion >= 0x00050000)
        {
            // TODO (scotrobe): Pass -1 to AllowSetForegroundWindow
            // to specify that all processes can set the foreground
            // window. We should really pass ASFW_ANY but at this point
            // Trident is being built with _WIN32_WINNT set to version 4
            // so this constant doesn't get included. When we start using
            // NT5 headers, the -1 should be changed to ASFW_ANY
            //
            AllowSetForegroundWindow((DWORD) -1);
        }

        CStr    strTemp;
        LPCTSTR pszURLOpen;

        if (pchURL && *pchURL)
        {
            hr = strTemp.Set(*pcstrInExpandedUrl);
            if (hr)
                goto Cleanup;

            hr = strTemp.Append(*pcstrLocation);
            if (hr)
                goto Cleanup;
            
            pszURLOpen = strTemp;
        }
        else
        {
            pszURLOpen = _T("about:blank");
        }

        hr = OpenInNewWindow(pszURLOpen,
                             pchTarget,
                             pDwnBindInfo,
                             pBindCtx,
                             pWindow,
                             fReplace,
                             ppHTMLWindow2);
    }
    else
    {
        COmWindowProxy * pWindowForEvents = pWindow;

        if (    _fDefView
            &&  !_fActiveDesktop
            &&  !(dwFlags & FHL_FRAMENAVIGATION)
            &&  !IsSpecialUrl(*pcstrInExpandedUrl))
        {
            NotifyDefView(*pcstrInExpandedUrl);
            goto Cleanup;
        }

        // 1. Reset the list only for top level navigations iff
        // (1) a new window is not being opened AND
        // (2) this is not a local navigation AND
        // (3) this is not a navigate call from a diff browser window
        // (4) this is either a shdocvw navigation (address bar, Go to, Favorites) or history OR
        //     ( if it is a hyperlink navigation at the top level AND 
        //       not in viewlink WebOC AND
        //       is not initiated by script AND
        //       it is not a script url in the href which can potentially just show a msgbox and not navigate)
        // 2. If this is top level navigation but script initiated, then add a blank record to 
        //    demarcate the set of urls pertaining to this new top level url

        if (   !fOpenInNewWindow 
            && !fLocalNavigation 
            && !(dwFlags & FHL_EXTERNALNAVIGATECALL) )
        {
            if ( dwFlags & FHL_SHDOCVWNAVIGATE )
                THR(ResetPrivacyList());
            else if (fIsPrimaryMarkup && !_fViewLinkedInWebOC && !IsScriptUrl(*pcstrInExpandedUrl))
            {
                if ((dwFlags & FHL_HYPERLINKCLICK) && !_cScriptNestingTotal)
                    THR(ResetPrivacyList());
                else if (_cScriptNestingTotal)
                    THR(AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
            }
        }

        
        // If this is a top-level navigation and the host is supposed to it
        // (as is the case if we are aggregated), then delegate to the host now.
        if (    _fHostNavigates
            &&  _pTopWebOC
            &&  (dwFlags & FHL_HYPERLINKCLICK)
            &&  !fOpenInNewWindow
            &&  (fIsPrimaryMarkup && !_fViewLinkedInWebOC)
            &&  !IsSpecialUrl(*pcstrInExpandedUrl)
           )
        {
            if (!fLocalNavigation)
            {
                if (_pClientSite)
                    CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_SETNAVIGATABLECODEPAGE, 0, NULL, NULL);

                hr = DelegateNavigation(INET_E_TERMINATED_BIND, *pcstrInExpandedUrl, *pcstrLocation, NULL, pDwnBindInfo, NULL);
                goto Cleanup;
            }
            else
            {
                fForceUpdate = TRUE;
            }
        }

        if (fOpenInNewWindow)
        {
            CFrameSite * pFrameSite = NULL;

            // Last argument is debug flag saying this markup will get a window.
            hr = CreateMarkup(&pMarkup, NULL, NULL, FALSE, NULL DBG_COMMA WHEN_DBG(TRUE));
            if (hr)
                goto Cleanup;

            // This markup will be trusted if it is the content of a trusted frame
            // (i.e a frame with APPLICATION=yes specified and whose parent frame is also trusted).
            if (pElementMaster)
            {
                Assert(pElementMaster->Tag() == ETAG_IFRAME || pElementMaster->Tag() == ETAG_FRAME);
                pFrameSite = DYNCAST(CFrameSite, pElementMaster);
            }

            // The markup trusted has to be called before the window is created for this markup. 
            // DO NOT change the order here.
            
            // set the markup trust bit if applicable
            if (IsHostedInHTA() || _fInTrustedHTMLDlg)
            {
                if (pFrameSite)
                {
                    pMarkup->SetMarkupTrusted(pFrameSite->_fTrustedFrame);
                }
                else
                {
                    // we hit this codepath from CreateDocumentFromUrl, 
                    // which is only available through binary, so it's 
                    // likely that it's safe to set this to TRUE. however,
                    // there may be other codepaths involved, so I'm doing
                    // the safe thing and setting it to FALSE
                    pMarkup->SetMarkupTrusted(FALSE);
                }
            }

            // create a window associate it with this markup
            hr = THR(pMarkup->CreateWindowHelper());
            if (hr)
                goto Cleanup;

            pWindowForEvents = pMarkup->Window();
            if (dwFlags & FHL_CREATEDOCUMENTFROMURL)
                pWindowForEvents->Window()->_fCreateDocumentFromUrl = TRUE;


            // if this is a frame and the frame is marked as restricted, carry
            // the information through the window object.
            Assert( !pElementMaster || pFrameSite);
            if (pElementMaster && pFrameSite->_fRestrictedFrame)
            {
                pWindowForEvents->Window()->_fRestricted = TRUE;
            }

            if (dwFlags & FHL_FRAMECREATION)
            {
                pWindowForEvents->Window()->_pWindowParent = pCWindow;
                pWindowForEvents->Window()->_pWindowParent->SubAddRef();
            }
        }
        
        //
        // The logic here needs to be done in two phases:
        //   1) Find the window which needs to be navigated.  
        //      Potentially this might need to be marshalled over somewhere.  
        //   2) Navigate that window doing the active view pending view thing.
        //      So, each window will have two views.  
        //

        // Fire the BeforeNavigate2 event.
        //
        if (!pStmHistory && (!(dwFlags & FHL_SHDOCVWNAVIGATE) || !pWindowForEvents->Window()->IsPrimaryWindow()))
        {
            BYTE *    pPostData = NULL;
            DWORD     cbPostData = 0;
            TCHAR *   pchHeaders = NULL;

            GetHeadersAndPostData(pDwnBindInfo, &pPostData, &cbPostData, &pchHeaders);

            _webOCEvents.BeforeNavigate2(pWindowForEvents,
                                         &fCancel,
                                         *pcstrInExpandedUrl,
                                         pcstrLocation ? *pcstrLocation : NULL,
                                         pchName ? pchName : pWindowForEvents->Window()->_cstrName,
                                         pPostData, 
                                         cbPostData, 
                                         pchHeaders, 
                                         (!(dwFlags & FHL_FRAMECREATION) &&
                                          !(dwFlags & CDoc::FHL_RESTARTLOAD)));

            MemFreeString(pchHeaders);

            // Save whether we are in a frame creation on the window so we can access it when we complete the navigation

            if  ((dwFlags & FHL_FRAMECREATION) || (dwFlags & FHL_RESTARTLOAD))             
                pWindowForEvents->Window()->_fNavFrameCreation = TRUE;
            else
                pWindowForEvents->Window()->_fNavFrameCreation = FALSE;

            if (!fLocalNavigation && !pWindowForEvents->Window()->IsPrimaryWindow())
            {
                _webOCEvents.FireDownloadEvents(pWindowForEvents,
                                                CWebOCEvents::eFireDownloadBegin);
            }
        }

        // If fCancel is true we can return, but only if 
        // we are not creating a new window. In the case where
        // we are creating a new window and the navigation is
        // canceled, we must still create the window but
        // nat navigate it to the URL.
        //
        if (!fOpenInNewWindow && fCancel)
        {
            goto Cleanup;
        }

        if (ppWindowOut)
        {
            *ppWindowOut = NULL;
        }

        // Check if the browser is offline. If so, only
        // navigate if the page is in the cache or if 
        // the user has chosen to connect to the Web.
        //
        hr = pcstrInExpandedUrl->AllocBSTR(&V_BSTR(&cvarUrl));
        if (hr)
            goto Cleanup;

        V_BOOL(&cvarContinue) = VARIANT_TRUE;

        Assert(_pClientSite);
        IGNORE_HR(CTExec(_pClientSite, &CGID_ShellDocView, 
                         SHDVID_CHECKINCACHEIFOFFLINE, 0, &cvarUrl, &cvarContinue));

        if (VARIANT_FALSE == V_BOOL(&cvarContinue))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        Assert(pcstrInExpandedUrl && pcstrLocation);

        // If the URL is a reference to a bookmark in this CDoc don't
        // reload -- just navigate to that bookmark (except when navigation is
        // done for a form submission).
        // TODO: (jbeda) shdocvw doesn't do this if it can't use the cache
        //
        if (!fCancel && !(dwFlags & FHL_FORMSUBMIT) && fLocalNavigation)
        {
            // Update the travel log. The window data must be
            // updated before navigating because the window 
            // can actually change and the window stream 
            // will be incorrect. The travel log is only updated
            // if the navigation is successful.
            //
            DWORD dwPositionCookie;

            BOOL fIsSameUrl = IsSameUrl(CMarkup::GetUrl(pCWindow->_pMarkup),
                                        CMarkup::GetUrlLocation(pCWindow->_pMarkup),
                                        *pcstrInExpandedUrl,
                                        *pcstrLocation,
                                        fSendAsPost);

            IGNORE_HR(pCWindow->GetPositionCookie(&dwPositionCookie));
            pCWindow->UpdateWindowData(dwPositionCookie);

            hr = CMarkup::SetUrlOriginal(pCWindow->_pMarkup, pchUrlOriginal);
            if (hr)
                goto Cleanup;

            hr = THR(pCWindow->_pMarkup->NavigateHere(dwFlags, *pcstrLocation, 0, TRUE));

            // if success, done
            if (!hr)
            {
                _fShdocvwNavigate = !!(dwFlags & FHL_SHDOCVWNAVIGATE);

                if (!fIsSameUrl)
                    UpdateTravelLog(pCWindow, TRUE, TRUE, TRUE, NULL, fForceUpdate);
            }

            // NOTE - if IsSameUrl and the bookmark name is not in the local document
            // we are not turning the metarefresh timer back on (108105). this seems 
            // to be safe since the url is the same, the document is fully loaded, and the url 
            // wasn't found.. so this is actually an optimization

            // for 5.0 compat we need to fire these event regarless of sucess/failure
            _webOCEvents.NavigateComplete2(pWindowForEvents);
            _webOCEvents.DocumentComplete(pWindowForEvents, 
                                          CMarkup::GetUrl(pWindowForEvents->Window()->_pMarkup),
                                          CMarkup::GetUrlLocation(pWindowForEvents->Window()->_pMarkup));

            // In any case, we don't want to do a real navigate
            hr = S_OK;
                
            goto Cleanup;
        }

        // If we were asked to set the target's media property, do it now, before loading from URL
        if (dwFlags & FHL_SETTARGETPRINTMEDIA)
        {
            pTargetDocument = pMarkup->Document();
            Assert(pTargetDocument);

            bstrMedia = SysAllocString(_T("print"));

            if (bstrMedia)
            {
                IGNORE_HR(pTargetDocument->putMediaHelper(bstrMedia));
            }
        }

        if (!fCancel)
        {
            // At this point we know that we are going to at least start a non-local navigation
            // of the Doc. I don't want to do this in SwitchMarkup, because of the special handling 
            // of MIME types.

            _fMhtmlDocOriginal = FALSE;


            if ((dwFlags & FHL_SHDOCVWNAVIGATE) && (URL_SCHEME_FILE == GetUrlScheme(*pcstrInExpandedUrl)))
            {
                hr = THR(CreateURLMonikerEx(NULL, *pcstrInExpandedUrl, &pMoniker, URL_MK_NO_CANONICALIZE));
            }
            else
            {
                hr = THR(CreateURLMoniker(NULL, *pcstrInExpandedUrl, &pMoniker));
            }
            if (hr)
                goto Cleanup;

            // If the protocol doesn't navigate (such as mailto:), just bind to the moniker
            if (!fProtocolNavigates)
            {
                IUnknown *pUnknown = NULL;
                IBindStatusCallback *pPreviousBindStatusCallback = NULL;
                BOOL fAddToHistory = FALSE;
                HRESULT hrBind;

                hr = THR( RegisterBindStatusCallback( pBindCtx, pDwnBindInfo,
                    &pPreviousBindStatusCallback, 0) );
                if (hr)
                    goto Cleanup;
            
                ReleaseInterface(pPreviousBindStatusCallback);
                hrBind = (pMoniker->BindToObject(
                        pBindCtx, NULL, IID_IUnknown, (void**)&pUnknown));

                if (hrBind == INET_E_UNKNOWN_PROTOCOL)
                {
                    // Here we check to see if it is a URL we really want to shell execute
                    // so it is handled by helper apps.....else it really is an error
                    
                    if (ShouldShellExecURL(pchURL))
                    {
                        TCHAR            szDecodedURL[INTERNET_MAX_URL_LENGTH];
                        DWORD            cchDecodedURL = ARRAY_SIZE(szDecodedURL);

                        if (PrepareURLForExternalApp(pchURL, 
                                                     szDecodedURL, 
                                                     INTERNET_MAX_URL_LENGTH,
                                                     &cchDecodedURL))
                        {
                            SHELLEXECUTEINFO sei = {0};

                            sei.cbSize = sizeof(sei);
                            sei.lpFile = szDecodedURL;
                            sei.nShow  = SW_SHOWNORMAL;

                            fAddToHistory = ShellExecuteEx(&sei);
                        }
                    }
                }
                else
                    fAddToHistory = !FAILED(hrBind);
                
                // Successfully navigated to that protocol
                if (   fAddToHistory
                    && (FHL_HYPERLINKCLICK & dwFlags)
                   )
                {
                    hr = EnsureUrlHistory();
                    if (S_OK == hr)
                    {
                        _pUrlHistoryStg->AddUrl(pchURL,
                                                NULL, // pchTitle
                                                ADDURL_ADDTOHISTORYANDCACHE);
                    }
                }
                ReleaseInterface(pUnknown);
                goto Cleanup;
            }

            if (!fOpenInNewWindow)
            {
                if (!pWindow->Fire_onbeforeunload())
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                if (dwFlags & FHL_LOADHISTORY)
                {
                    // freeze the old markup and nuke any pending readystate changes
                    pCWindow->_pMarkup->ExecStop(TRUE, FALSE);
                }
            }
        }

        if (!pMarkup)
        {
            if (dwFlags & FHL_LOADHISTORY)
            {
                Assert(!fOpenInNewWindow);

                if (pWindow->Window()->_pMarkupPending)
                    pMarkup = pWindow->Window()->_pMarkupPending;
                else
                    pMarkup = pWindow->Window()->_pMarkup;

                pMarkup->_fHardStopDone = FALSE;
                pMarkup->AddRef();
            }
            else
            {
                // Last argument is debug flag saying this markup will get a window.
                hr = pWindow->Window()->Doc()->CreateMarkup(&pMarkup, NULL, NULL, FALSE, fOpenInNewWindow ? NULL : pWindow DBG_COMMA WHEN_DBG(TRUE));
                if (hr)
                    goto Cleanup;
            }

            pWindow->Window()->ClearMetaRefresh();
        }

        pMarkup->_fInRefresh = !! ( dwFlags & FHL_REFRESH );        

        if (   !fCancel
            && pMarkup)
        {
            // these are used in LoadStatusINteractive to add this url
            // to the history stream.
            hr = EnsureUrlHistory();

            if (   !FAILED(hr)
                && (FHL_HYPERLINKCLICK & dwFlags))
            {
                // (109771) for redirected links we need to call this here for the cache.
                Assert(_pUrlHistoryStg);
                _pUrlHistoryStg->AddUrl(*pcstrInExpandedUrl, NULL, ADDURL_ADDTOCACHE);

                pMarkup->_fNavFollowHyperLink = TRUE;
            }
        }

        if (!fCancel)
        {
            LOADINFO    LoadInfo = { 0 };
            CStr        cstrSearch;

            LoadInfo.pmk   = pMoniker;
            LoadInfo.pbctx = pBindCtx;
            LoadInfo.pchUrlOriginal = const_cast<TCHAR*>(pchUrlOriginal);
            LoadInfo.pElementMaster  = pElementMaster;
            LoadInfo.pchExtraHeaders = (TCHAR *) pchExtraHeaders;
            // For "file://" URLs, we need to ask for the query string explicitly (#90338)
            // shdocvw does not give it to us 
            if (GetUrlScheme(*pcstrInExpandedUrl) == URL_SCHEME_FILE)
            {
                hr = GetUrlComponentHelper(
                                    *pcstrInExpandedUrl,
                                    &cstrSearch,
                                    0,
                                    URLCOMP_SEARCH,
                                    TRUE);
                if (hr)
                    goto Cleanup;
                LoadInfo.pchSearch = cstrSearch;
            }


            if (   pDwnBindInfo
                && pDwnBindInfo->GetDwnDoc()
                && (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT | FHL_FRAMECREATION)))
            {
                // Before Native Frames, shdocvw would start the navigation using this BindInfo
                // and then abort it.  However, it was enough to get Urlmon to start bringing
                // down the new bits if this flag was out.  Because we don't do this bind now,
                // we have to prop this flag through the loadinfo.

                // This line was anding out BINDF_NEEDFILE which we need if it was set
                // TODO: Investigate which other flags might be need.
                LoadInfo.dwBindf |= pDwnBindInfo->GetDwnDoc()->GetBindf() & (BINDF_HYPERLINK | BINDF_FORMS_SUBMIT);

                // When a frame is being created, the frame window is not created until
                // DoNavigate, but the dwBindf flags are set at the top of FollowHyperlink.
                // This is the last place we can set the flags for a frame page itself so
                // we can relay the information that it is security=restricted to the binding code.
                if (pWindowForEvents->Window()->_fRestricted)
                    LoadInfo.dwBindf |= BINDF_ENFORCERESTRICTED;
            }

            if (!fOpenInNewWindow)
            {
                LoadInfo.fStartPicsCheck = TRUE;
            }

            LoadInfo.fShdocvwNavigate = !!(dwFlags & FHL_SHDOCVWNAVIGATE);
            LoadInfo.fMetaRefresh = !!(dwFlags & FHL_METAREFRESH);
            LoadInfo.fDontUpdateTravelLog = !!(dwFlags & FHL_DONTUPDATETLOG);
            LoadInfo.fCreateDocumentFromUrl = !!(dwFlags & FHL_CREATEDOCUMENTFROMURL);
            if (!LoadInfo.fCreateDocumentFromUrl)
                LoadInfo.fDontFireWebOCEvents = !!(dwFlags & FHL_DONTFIREWEBOCEVENTS);

            pMarkup->_fReplaceUrl = !! ( dwFlags & FHL_REPLACEURL ); 
            
            if (pStmHistory)
            {
                DWORD dwBindf;

                pMarkup->_fLoadingHistory = TRUE;

                if (   pDwnBindInfo
                    && pDwnBindInfo->GetDwnDoc()
                   )
                {
                    dwBindf = pDwnBindInfo->GetDwnDoc()->GetBindf();
                }
                else
                {
                    dwBindf = BINDF_FWD_BACK;
                }

                // When a frame is being created, the frame window is not created until
                // DoNavigate, but the dwBindf flags are set at the top of FollowHyperlink.
                // This is the last place we can set the flags for a frame page itself so
                // we can relay the information that it is security=restricted to the binding code.
                if (pWindowForEvents->Window()->_fRestricted)
                    dwBindf |= BINDF_ENFORCERESTRICTED;

                hr = THR(pMarkup->LoadHistoryInternal(pStmHistory,
                                                      pBindCtx,
                                                      dwBindf,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      0,
                                                      pElementMaster,
                                                      dwFlags,
                                                      pchName));

                if (hr)
                    goto Cleanup;
            }

            if (hr || !pStmHistory)
            {
                LoadInfo.fErrorPage = !!(dwFlags & FHL_ERRORPAGE);
                LoadInfo.fFrameTarget = fFrameTarget;

                hr = THR(pMarkup->LoadFromInfo(&LoadInfo, NULL ,pchCallerUrl));
                if (hr)
                {   
                    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)  // 0x04c7
                    {
                        // If this error gets bubbled up to a script, we get
                        // a script error.  For compat with 5.01, we need to
                        // suppress the error code.
                        hr = S_OK;
                    }
                    goto Cleanup;
                }
            }

            if( !fOpenInNewWindow && !(dwFlags & FHL_LOADHISTORY))
            {
                // freeze the old markup and nuke any pending readystate changes
                pCWindow->_pMarkup->ExecStop(TRUE, FALSE);
            }
        }

        if (fOpenInNewWindow)
        {
            if (ppWindowOut)
            {
                *ppWindowOut = pMarkup->Window();
                (*ppWindowOut)->AddRef();
            }
        }
        else
        {
            pCWindow->UpdateWindowData(NO_POSITION_COOKIE);
        }

        if (fCancel)
            goto Cleanup;
            
        // Start up the task to navigate to the hyperlink
        // Shdocvw does this when we go interactive but this should work
        if (pcstrLocation->Length())
        {
            // Apphack for Autocad (see IE6 bug # 31485) - do not spawn task for error pages
            if ( g_fInAutoCad && (dwFlags & FHL_ERRORPAGE) && (dwFlags & FHL_SHDOCVWNAVIGATE) )
                goto Cleanup;

            // NB: Don't call NavigateHere because that will EnsureWindow and cause us
            // to increment _cDie and hence return E_ABORT.  Instead, just start up
            // the task to run later.
            IGNORE_HR( pMarkup->StartBookmarkTask(*pcstrLocation, dwFlags) );
        }
    }


    
Cleanup:

    if ( pfLocalNavigation )
    {
        *pfLocalNavigation = fLocalNavigation; 
    }
    
    // If the navigation was synchronous (e.g. as in Outlook9, see bug 31960),
    // the old document is destroyed at this point! All the callers in the
    // call stack above this function need to handle this gracefully. Set hr
    // to E_ABORT so that these callers abort furhter processing and return
    // immediately.
    if (_cDie != cDie)
        hr = E_ABORT;

    ReleaseInterface(pMoniker);
    ReleaseInterface(pHlink);
    ReleaseInterface(pHlinkFrame);
    ReleaseInterface(pTargetHTMLWindow);
    SysFreeString(bstrMedia);

    if (pMarkup)
    {
        pMarkup->Release();
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::DoNavigateOutOfProcess(IHTMLWindow2 * pTargetHTMLWindow,
                             TCHAR * pchExpandedUrl,
                             TCHAR * pchLocation,
                             TCHAR * pchUrlOriginal,
                             IBindCtx * pBindCtx,
                             DWORD dwFlags)
{
    HRESULT                 hr;
    BSTR                    bstrUrl       = NULL;
    BSTR                    bstrLocation  = NULL;
    BSTR                    bstrOriginal = NULL;
    IHTMLPrivateWindow2  *  pIPrivWin2    = NULL;

    hr = FormsAllocString(pchExpandedUrl, &bstrUrl);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchLocation, &bstrLocation);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchUrlOriginal, &bstrOriginal);
    if (hr)
        goto Cleanup;

    // Need this in the target window to determine whether to reset the privacy list or not
    dwFlags |= FHL_EXTERNALNAVIGATECALL;

    // If the target window is a Trident window call NavigateEx.
    // Otherwise it is a shell window most likely showing a folder without web view turned on.
    // We should call IHTMLWindow2::navigate directly in that case
    //
    hr = THR(pTargetHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pIPrivWin2));
    if (!hr)
    {
        hr = THR(pIPrivWin2->NavigateEx(bstrUrl, bstrOriginal, bstrLocation, NULL, pBindCtx, 0, dwFlags));
    }
    else
    {
        CStr    cstrTmp;

        // Clear the bind context param structure if there is one. Normally, the receiving Trident 
        // instance clears this. But this call path does not hit Trident and we will leak it if 
        // we don't take it out of the bind context here. 
        IGNORE_HR(GetBindContextParam(pBindCtx, &cstrTmp));

        hr = THR(pTargetHTMLWindow->navigate(bstrOriginal));
    }
    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrUrl);
    SysFreeString(bstrLocation);
    SysFreeString(bstrOriginal);
    ReleaseInterface(pIPrivWin2);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::StartBookmarkTask
//
//+---------------------------------------------------------------------------

HRESULT
CMarkup::StartBookmarkTask(LPCWSTR wzJumpLocation, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CTaskLookForBookmark * pBMTask = NULL;

    // First kill of any previous task
    TerminateLookForBookmarkTask();

    // Create the new task
    pBMTask = new CTaskLookForBookmark(this);
    if (pBMTask == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        CMarkupTransNavContext * ptnc = EnsureTransNavContext();
        if (!ptnc)
        {
            pBMTask->Terminate();
            pBMTask->Release();
            pBMTask = NULL;
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }
        ptnc->_pTaskLookForBookmark = pBMTask;
    }

    // Set the jump location
    hr = THR(pBMTask->_cstrJumpLocation.Set(wzJumpLocation));
    if (hr)
    {
        TerminateLookForBookmarkTask();
        goto Cleanup;
    }

    pBMTask->_dwFlags = dwFlags;

    // and here is the magic that acutally sets the # information for the OM string
    // see CDoc:get_URL for a discussion on why this is here
    //-----------------------------------------------------------------------------
    if (wzJumpLocation[0] !=_T('#'))
    {
        CStr cstr;
        cstr.Set(_T("#"));
        cstr.Append(wzJumpLocation);

        IGNORE_HR(SetUrlLocation(this, cstr));
    }
    else
    {
        IGNORE_HR(SetUrlLocation(this, wzJumpLocation));
    }

Cleanup:
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NotifyDefView
//
//  Synopsis:   Notifies the defview folder of our navigation.
//
//+---------------------------------------------------------------------------

void
CDoc::NotifyDefView(TCHAR * pchUrl)
{
    if (!_pClientSite)
        return;

    Assert(_fDefView);

    CVariant cvarUrl(VT_BSTR);

    // Do not pass the original URL to DefView. 
    // The encoded URL must be sent. When you click on 
    // a link to "My Documents", for example, the original
    // url is file:///::clsid, where clsid is the clsid of the
    // folder. Sending this URL to DefView causes it to show a 
    // blank page because there is an extra /. Encoding the URL
    // removes the extra /.
    //

    FormsAllocString(pchUrl, &V_BSTR(&cvarUrl));

    IGNORE_HR(CTExec(_pClientSite, &CGID_DocHostCmdPriv,
                     DOCHOST_DOCHYPERLINK, NULL, &cvarUrl, NULL));

    UpdateTitle();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRootFrame
//
//  Synopsis:   Finds the root frame of the specified frame
//              by climing up parents.
//
//----------------------------------------------------------------------------
HRESULT
GetRootFrame(IUnknown *pUnkFrame, IUnknown **ppUnkRootFrame)
{
    IUnknown *pUnkScan = pUnkFrame;
    ITargetFrame2 *pTargetFrameRoot = NULL;
    HRESULT hr;

    pUnkScan->AddRef();

    // run up to target root
    for (;;)
    {
        hr = THR(pUnkScan->QueryInterface(IID_ITargetFrame2, (void**)&pTargetFrameRoot));
        if (hr)
            goto Cleanup;

        pUnkScan->Release();
        pUnkScan = NULL;

        hr = THR(pTargetFrameRoot->GetParentFrame(&pUnkScan));
        if (hr)
            pUnkScan = NULL;

        if (!pUnkScan)
            break;

        pTargetFrameRoot->Release();
        pTargetFrameRoot = NULL;
    }
    Assert(!pUnkScan);
    Assert(pTargetFrameRoot);

    hr = THR(pTargetFrameRoot->QueryInterface(IID_IUnknown, (void**)ppUnkRootFrame));

Cleanup:
    ReleaseInterface(pUnkScan);
    ReleaseInterface(pTargetFrameRoot);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FollowHistory
//
//  Synopsis:   Goes forward or backward in history via automation on the
//              hosting shdocvw
//
//----------------------------------------------------------------------------
HRESULT
CDoc::FollowHistory(BOOL fForward)
{
    HRESULT             hr;
    ITargetFrame      * pTargetFrameSource = NULL;
    IUnknown          * pUnkSource = NULL;
    IUnknown          * pUnkTarget = NULL;
    IServiceProvider  * pServiceTarget = NULL;
    IWebBrowserApp    * pWebBrowserApp = NULL;

    hr = THR(QueryService(IID_ITargetFrame, IID_ITargetFrame, (void**)&pTargetFrameSource));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrameSource->QueryInterface(IID_IUnknown, (void**)&pUnkSource));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrameSource->FindFrame(_T("_top"), pUnkSource, FINDFRAME_JUSTTESTEXISTENCE, &pUnkTarget));
    if (!pUnkTarget)
        hr = E_FAIL;
    if (hr)
        goto Cleanup;

    hr = THR(pUnkTarget->QueryInterface(IID_IServiceProvider, (void**)&pServiceTarget));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceTarget->QueryService(IID_IWebBrowserApp, IID_IWebBrowserApp,(void**)&pWebBrowserApp));
    if (hr)
        goto Cleanup;

    if (fForward)
        pWebBrowserApp->GoForward();
    else
        pWebBrowserApp->GoBack();

Cleanup:
    ReleaseInterface(pTargetFrameSource);
    ReleaseInterface(pUnkSource);
    ReleaseInterface(pUnkTarget);
    ReleaseInterface(pServiceTarget);
    ReleaseInterface(pWebBrowserApp);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureUrlHistory
//
//  Synopsis:   populates the _pUrlHistoryStg variable.
//              returns S_OK if variable is valid, otherwise error code.
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::EnsureUrlHistory()
{
    HRESULT hr;
        
    if(!_pUrlHistoryStg)
    {
        hr = QueryService(SID_SUrlHistory, IID_IUrlHistoryStg, (LPVOID*)&_pUrlHistoryStg);

        if(FAILED(hr))
        {
            goto Cleanup;
        }
        if (!_pUrlHistoryStg)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    hr = S_OK;
Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::IsVisitedHyperlink
//
//  Synopsis:   returns TRUE if the given url is in the Hisitory
//
//              Currently ignores #location information
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsVisitedHyperlink(LPCTSTR pchURL, CElement *pElementContext)
{
    HRESULT     hr              = S_OK;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR*      pchExpandedUrl  = cBuf;
    BOOL        result          = FALSE;
    TCHAR *     pch;

    // fully resolve URL
    hr = THR(CMarkup::ExpandUrl(
            NULL, pchURL, ARRAY_SIZE(cBuf), pchExpandedUrl, pElementContext));
    if (hr)
        goto Cleanup;

    pch = const_cast<TCHAR *>(UrlGetLocation(pchExpandedUrl));

    Assert(!pchExpandedUrl[0] || pchExpandedUrl[0] > _T(' '));

    // Use the history cache-container from wininet

    hr = EnsureUrlHistory();
    if (hr)
    {
        result = FALSE;
        goto Cleanup;
    }

    Assert(_pUrlHistoryStg);

    if (pchExpandedUrl)
    {
        hr = _pUrlHistoryStg->QueryUrl(pchExpandedUrl, 0, NULL);
        result = (SUCCEEDED(hr));
    }
    else
    {
        result = FALSE;
    }

Cleanup:

    return result;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetBrowseContext, IHlinkTarget
//
//  Synopsis:   Hosts calls this when we're being hyperlinked to in order
//              to supply us with the browse context.
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    ReplaceInterface(&_phlbc, pihlbc);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetBrowseContext, IHlinkTarget
//
//  Synopsis:   Returns our browse context
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    *ppihlbc = _phlbc;
    if (_phlbc)
    {
        _phlbc->AddRef();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateOutside, helper
//
//  Synopsis:   called when there is no client site for the doc; e.g., if
//              the doc is created inside Word or Excel as doc supporting
//              a hyperlink. In this case we launch an IE instance through
//              call to shdocvw.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::NavigateOutside(DWORD grfHLNF, LPCWSTR pchLocation)
{
#if !defined(WINCE) && !defined(WIN16)

    HRESULT   hr     = E_FAIL;
    IHlink  * pHlink = NULL;
    CMarkup * pMarkupPrimary = PrimaryMarkup(); 
    IBindCtx* pbc = NULL;

    // TODO: IE 3/4 classic implements an empty hlink site; we pass NULL.
    if (pMarkupPrimary)
    {
        hr = THR(HlinkCreateFromMoniker(pMarkupPrimary->GetNonRefdMonikerPtr(), pchLocation, NULL,
                 NULL, 0, NULL, IID_IHlink, (LPVOID*) &pHlink));
        if (hr)
            goto Cleanup;

        pbc = pMarkupPrimary->HtmCtx()->GetBindCtx();
        hr = THR(HlinkFrameNavigate(0, pbc, NULL, pHlink, _phlbc));
    }

Cleanup:
    ReleaseInterface(pHlink);

    RRETURN (hr);
#else // !WINCE
    RRETURN (E_FAIL);
#endif // !WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateNow, helper
//
//  Synopsis:   Forces a recalc up until the position specified in the
//              current bookmark task, if any.
//
//----------------------------------------------------------------------------

void
CMarkup::NavigateNow(BOOL fScrollBits)
{
    if (!HasTransNavContext())
        return;

    CTaskLookForBookmark * pBMTask = GetTransNavContext()->_pTaskLookForBookmark;

    if (    pBMTask
        &&  !pBMTask->_cstrJumpLocation
        &&  LoadStatus() >= LOADSTATUS_INTERACTIVE
        &&  Doc()->_view.IsActive()
        &&  GetElementClient()
        &&  GetElementClient()->Tag() == ETAG_BODY)
    {
        CFlowLayout *   pFlowLayout = GetElementClient()->HasFlowLayout();
        RECT            rc;
        Assert(pFlowLayout);

        pFlowLayout->GetClientRect(&rc);
        pFlowLayout->WaitForRecalc(-1, pBMTask->_dwScrollPos + rc.bottom - rc.top);

        NavigateHere(0, NULL, pBMTask->_dwScrollPos, fScrollBits);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateHere, helper
//
//  Synopsis:   Called when the document lives inside IE (shdocvw).
//              If wzJumpLocation is not NULL, treat it as a bookmark and jump
//              there. Otheriwse, scroll the document to dwScrollPos.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::NavigateHere(DWORD grfHLNF, LPCWSTR wzJumpLocation, DWORD dwScrollPos, BOOL fScrollBits)
{
    HRESULT     hr                  = S_OK;
    CElement *  pElemBookmark;
    TCHAR    *  pBookmarkName;
    LONG        iStart, iStartAll;
    LONG        iHeight;
    BOOL        fBookmark;
    BOOL        fCreateTask         = FALSE;
    CDoc *      pDoc                = Doc();
    BOOL        fPrinting           = IsPrintMedia();
    CElement    * pElementClient    = GetCanvasElement();
    CMarkupTransNavContext * ptnc   = GetTransNavContext();
    CTaskLookForBookmark * pBMTask  = ptnc ? ptnc->_pTaskLookForBookmark : NULL;
    BOOL        fDontAdvanceStart   = FALSE;

    CCollectionCache * pCollectionCache;

    Assert( HasWindowPending() );
    Assert(!wzJumpLocation || dwScrollPos == 0);

    // Don't create bookmark task for print documents.
    if (fPrinting)
        goto Cleanup;

    fBookmark = (wzJumpLocation != NULL);

    if (!fBookmark)
    {
        if (!pElementClient) // not yet created
            fCreateTask = TRUE;
        else if (!IsScrollingElementClient(pElementClient)) // don't bother
            goto Cleanup;
        else
        {
            CElement * pElementScrolling = pElementClient;
            CLayout  * pLayoutScrolling  = pElementScrolling->GetUpdatedLayout();

            if (pLayoutScrolling)
            {
                RECT rc;
                pLayoutScrolling->GetClientRect(&rc);
                iHeight = rc.bottom - rc.top;
            }
            else
            {
                iHeight = 0;
            }
        
            if (    pDoc->State() < OS_INPLACE
                ||  (   (    LoadStatus() < LOADSTATUS_PARSE_DONE
                         ||  !pLayoutScrolling->FRecalcDone()
                        )
                    &&  pLayoutScrolling->GetContentHeight() < ((long)dwScrollPos + iHeight)
                    )
               )
            {
                fCreateTask = TRUE;
            }
            else
            {
                CDocInfo DCI(pElementScrolling);

                OnLoadStatus(LOADSTATUS_INTERACTIVE);
                pLayoutScrolling->ScrollToY(dwScrollPos, fScrollBits ? 0 : -1);
            }
        }

        // Perf optimization:
        // We don't a need a task to scroll to top. The only time we need to scroll
        // AND dwScrollPos is 0 is when we are navigating upward within the same
        // document (bug 37614). However, in this case the doc (or at leats its top)
        // is already loaded.
        if (fCreateTask && dwScrollPos == 0)
            goto Cleanup;

        pCollectionCache = CollectionCache();

        // Clear any existing OM string for the jump location
        SetUrlLocation(this, NULL);
    }
    else
    {
        if (_tcslen(wzJumpLocation) == 0)
            goto Cleanup;

        // and here is the magic that acutally sets the # information for the OM string
        // see CDoc:get_URL for a discussion on why this is here
        //-----------------------------------------------------------------------------
        if (wzJumpLocation[0] !=_T('#'))
        {
            CStr cstr;
            cstr.Set(_T("#"));
            cstr.Append(wzJumpLocation);

            IGNORE_HR(SetUrlLocation(this, cstr));
        }
        else
        {
            IGNORE_HR(SetUrlLocation(this, wzJumpLocation));
        }


        // Now continue on with the effort of determining where to scroll to
        //prepare the anchors' collection
        hr = EnsureCollectionCache(CMarkup::ANCHORS_COLLECTION);
        if (hr)
            goto Cleanup;

        pCollectionCache = CollectionCache();
        pBookmarkName = (TCHAR *)wzJumpLocation;

        iStart = iStartAll = 0;

        // Is this the same location we had stashed away? If yes then
        // do the incremental search, else search from the beginning
        if (pBMTask)
        {
            CStr cstrTemp;

            cstrTemp.Set(wzJumpLocation);
            if (pBMTask->_cstrJumpLocation.Compare(&cstrTemp))
            {
                // Check the collections' cookie because they might been changed
                if(pBMTask->_lColVer == pCollectionCache->GetVersion(CMarkup::ANCHORS_COLLECTION))
                {
                    // Continue the search
                    iStart = pBMTask->_iStartSearchingAt;
                    iStartAll = pBMTask->_iStartSearchingAtAll;
                }
                else
                {
                    // Restart the search from the beginning
                    iStart = iStartAll = 0;
                }
            }
        }

        // Find the element with given name attribute in the anchors' collection
        hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ANCHORS_COLLECTION,
            pBookmarkName, FALSE, &pElemBookmark, iStart));
        if(FAILED(hr) || !pElemBookmark)
        {
            // Try to search without the starting #
            if(pBookmarkName[0] == _T('#') && pBookmarkName[1])
            {
                pBookmarkName++;
                hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ANCHORS_COLLECTION,
                    pBookmarkName, FALSE, &pElemBookmark, iStart));

                // If not found try to search all element collection
                if(FAILED(hr) || !pElemBookmark)
                {
                    // Restore the bookmark name pointer
                    pBookmarkName--;

                    // prepare the elements' collection
                    hr = EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION);
                    if (hr)
                        goto Cleanup;

                    hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                        pBookmarkName, FALSE, &pElemBookmark, iStartAll));
                    if(FAILED(hr) || !pElemBookmark)
                    {
                        // Try to search without the starting #
                        if(pBookmarkName[0] == _T('#') && pBookmarkName[1])
                        {
                            pBookmarkName++;
                            hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                                pBookmarkName, FALSE, &pElemBookmark, iStartAll));
                        }
                    }
                }
            }
         }


        // treat mutliple anchors with the same name as okay
        if (FAILED(hr))
        {
            // DISP_E_MEMBERNOTFOUND is the only E_ hr that GetIntoAry may return
            Assert(hr == DISP_E_MEMBERNOTFOUND);

            // '#top' and the '#' bookmark are a special case.  '#' is necesary for 
            // ie4/NS compat
            if (    (StrCmpIC(pBookmarkName, _T("top")) == 0) 
                ||  (StrCmpIC(pBookmarkName, _T("#"))   == 0))
            {
                // Scroll to the top of the document
                if (pElementClient)
                {
                    // TODO (jbeda) go interactive here?
                    pElementClient->GetUpdatedLayout()->
                        ScrollElementIntoView(NULL, SP_TOPLEFT, SP_TOPLEFT);
                }
            }
            else if (LoadStatus() < LOADSTATUS_PARSE_DONE)
            {
                fCreateTask = TRUE;
            }
        }
        else
        {
            // If for some reason we cannot show the element yet, then return.
            // Note: we keep _iStartSearchAt the same in this case and hence
            // we will be able to find this bookmark again.
            if (!pElemBookmark->CanShow())
            {
                fCreateTask = TRUE;
                fDontAdvanceStart = TRUE;
            }
            else
            {
                BOOL fSetCurrencyAndCaret = FALSE;
                
                OnLoadStatus(LOADSTATUS_INTERACTIVE);

                if (GetReadyState() < READYSTATE_INTERACTIVE)
                    goto Ret;
                
                // Mark the anchor current, but only if the currency is already
                // in this markup (#67170)
                if (    (grfHLNF & CDoc::FHL_HYPERLINKCLICK)
                    ||  !pDoc->_pElemCurrent
                    ||  !pDoc->_pElemCurrent->IsInMarkup()
                    ||  pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup(this)
                   )
                {
                    fSetCurrencyAndCaret = TRUE;
                    hr = THR(pElemBookmark->BubbleBecomeCurrent(0));
                    if (hr)
                        goto Cleanup;
                }
                hr = pElemBookmark->ScrollIntoView(SP_TOPLEFT, SP_MINIMAL, fScrollBits);
                if (hr)
                    goto Cleanup;

                // Fire the necessary navigation events. 
                //
    
                if (!_pDoc->_fHostNavigates && HasWindowPending())
                {
                    _pDoc->_webOCEvents.FireDownloadEvents(GetWindowPending(),
                                                           CWebOCEvents::eFireBothDLEvents);
                }

                if (    fSetCurrencyAndCaret
                    &&  pElemBookmark != pDoc->_pElemCurrent
                    &&  S_OK == pDoc->GetCaret(NULL)
                    &&  pDoc->_pCaret
                   )
                {
                    // Position the caret at the beginning of the bookmark, so that the
                    // next tab would go to the expected place (IE5 63832)
                    CMarkupPointer      ptrStart(pDoc);
                    IMarkupPointer *    pIStartBookmark; 
                    IDisplayPointer *   pDispStartBookmark;

                    Assert( pElemBookmark->GetMarkup() == this );

                    hr = ptrStart.MoveToCp(pElemBookmark->GetFirstCp(), pElemBookmark->GetMarkup());
                    if (hr)
                        goto Cleanup;

                    // TODO: make sure the type of selection isn't caret here
                    if (SUCCEEDED(ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStartBookmark)))
                    {
                        if (SUCCEEDED(_pDoc->CreateDisplayPointer(&pDispStartBookmark)))
                        {
                            if (SUCCEEDED(pDispStartBookmark->SetDisplayGravity(DISPLAY_GRAVITY_NextLine)))
                            {
                                if (SUCCEEDED(pDispStartBookmark->MoveToMarkupPointer(pIStartBookmark, NULL)))
                                {
                                    IGNORE_HR(_pDoc->_pCaret->MoveCaretToPointer(pDispStartBookmark, FALSE, CARET_DIRECTION_INDETERMINATE));
                                }
                            }
                            pDispStartBookmark->Release();
                        }
                        pIStartBookmark->Release();
                    }

                    pDoc->_fFirstTimeTab = FALSE;

                }
            }
        }
    }

    if (fCreateTask)
    {

        // Start the task that periodically wakes up and checks if we
        // can jump to the desired location.
        if (!pBMTask)
        {
            pBMTask = new CTaskLookForBookmark(this);
            if (pBMTask == NULL)
            {
                goto Ret;
            }

            {
                CMarkupTransNavContext * ptnc = EnsureTransNavContext();
                if (!ptnc)
                {
                    pBMTask->Terminate();
                    pBMTask->Release();
                    pBMTask = NULL;
                    goto Cleanup;
                }
                ptnc->_pTaskLookForBookmark = pBMTask;
            }
        }
        else
        {
            // Check if this is the last time this task needs to be tried.
            // For bookmarks, we can stop when the doc is fully loaded.
            // For setting scroll position, we need to also wait for the
            // doc to go in-place and the body site to get fully recalc'ed.
            if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
            {
                if (fBookmark)
                    goto Cleanup;
                
                if (   pDoc->State() >= OS_INPLACE
                    && LoadStatus() >= LOADSTATUS_DONE
                    && IsScrollingElementClient(pElementClient)
                   )
                {
                    CLayout *pLayoutScrolling = pElementClient->GetUpdatedLayout();
                    if (pLayoutScrolling->FRecalcDone())
                        goto Cleanup;
                }
            }
        }

        if (fBookmark)
        {
            pBMTask->_dwScrollPos = 0;
            pBMTask->_cstrJumpLocation.Set(wzJumpLocation);

            // prepare the anchors' collection
            hr = EnsureCollectionCache(CMarkup::ANCHORS_COLLECTION);
            if (hr)
                goto Cleanup;

            if (S_OK != pCollectionCache->GetLength (CMarkup::ANCHORS_COLLECTION, &iStart))
            {
                // Cannot find the length for some reason, we should
                // start searching from the beginning.
                iStart = 0;
            }
            
            if (!fDontAdvanceStart)
                pBMTask->_iStartSearchingAt = iStart;
                
            if (S_OK != pCollectionCache->GetLength (CMarkup::ELEMENT_COLLECTION, &iStartAll))
            {
                // Cannot find the length for some reason, we should
                // start searching from the beginning.
                iStartAll = 0;
            }
            pBMTask->_iStartSearchingAtAll = iStartAll;

            // Save the version of the collections
            pBMTask->_lColVer = pCollectionCache->GetVersion(CMarkup::ANCHORS_COLLECTION);
        }
        else
        {
            pBMTask->_dwScrollPos = dwScrollPos;
            pBMTask->_cstrJumpLocation.Free();

            if (pBMTask->_dwTimeGotBody)
            {
                // Delay interactivity for no more than five seconds after creating the body
                if (GetTickCount() - pBMTask->_dwTimeGotBody > 5000)
                {
                    OnLoadStatus(LOADSTATUS_INTERACTIVE);
                }
            }
            else if (IsScrollingElementClient(pElementClient))
            {
                pBMTask->_dwTimeGotBody = GetTickCount();
            }
        }
        goto Ret;
    }

Cleanup:
    TerminateLookForBookmarkTask();

Ret:
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Navigate, IHlinkTarget
//
//  Synopsis:   Called to tell us which jump-location we need to navigate to.
//              We may not have loaded the anchor yet, so we need to save
//              the location and only jump once we find the anchor.
//              Note that when we support IHlinkTarget, containers simply
//              call Navigate instead of IOleObject::DoVerb(OLEIVERB_SHOW)
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    HRESULT hr = S_OK;
    CDoc*   pDoc = Doc();

    if (pDoc->_pClientSite)
    {
        // TODO - we should defer SHOW until there is something to show
        // TODO (jbeda) is this right for NATIVE_FRAME?
        IGNORE_HR(pDoc->DoVerb(OLEIVERB_SHOW, NULL, pDoc->_pClientSite, 0, NULL, NULL));

        if (wzJumpLocation)
            hr = THR(NavigateHere(grfHLNF, wzJumpLocation, 0, TRUE));
    }
    else
    {
        hr = THR(pDoc->NavigateOutside(grfHLNF, wzJumpLocation));
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    HRESULT hr;

    hr = THR( PrimaryMarkup()->Navigate( grfHLNF, wzJumpLocation ) );
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetMonikerHlink, IHlinkTarget
//
//  Synopsis:   Called to supply our moniker...
//              NOTE: this is renamed from GetMoniker to avoid multiple
//              inheritance problem with IOleObject::GetMoniker
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetMonikerHlink(LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation)
{
    if( !ppimkLocation )
        return E_INVALIDARG;

    *ppimkLocation = PrimaryMarkup()->GetNonRefdMonikerPtr();
    if (*ppimkLocation)
    {
        (*ppimkLocation)->AddRef();
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFriendlyName, IHlinkTarget
//
//  Synopsis:   Returns a friendly name for the fragment
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetFriendlyName(LPCWSTR pchLocation, LPWSTR *pchFriendlyName)
{
    if (!pchLocation)
        RRETURN (E_POINTER);

    // to do: figure out where this string goes; perhaps fix it

    // for now: friendly-name = location-string
    RRETURN(TaskAllocString(pchLocation, pchFriendlyName));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFramesContainer, ITargetContainer
//
//  Synopsis:   Provides access to our IOleContainer
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetFramesContainer(IOleContainer **ppContainer)
{
    RRETURN(QueryInterface(IID_IOleContainer, (void**)ppContainer));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFrameUrl, ITargetContainer
//
//  Synopsis:   Provides access to our URL
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetFrameUrl(LPWSTR *ppszFrameSrc)
{
    Assert(!!GetPrimaryUrl());

    RRETURN(TaskAllocString(GetPrimaryUrl(), ppszFrameSrc));
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetParentFrame, ITargetFrame
//
//  Synopsis:   Provides access to our IOleContainer
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetParentFrame(IUnknown **ppUnkParentFrame)
{
    HRESULT         hr;
    ITargetFrame  * pTargetFrame = NULL;

    hr = THR(QueryService(IID_ITargetFrame, IID_ITargetFrame, (void**)&pTargetFrame));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrame->QueryInterface(IID_IUnknown, (void**)ppUnkParentFrame));

Cleanup:
    ReleaseInterface(pTargetFrame);
    RRETURN(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::TerminateLookForBookmarkTask
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void
CMarkup::TerminateLookForBookmarkTask()
{
    if (!HasTransNavContext())
        return;

    CMarkupTransNavContext * ptnc = GetTransNavContext();

    if (ptnc && ptnc->_pTaskLookForBookmark)
    {
        ptnc->_pTaskLookForBookmark->Terminate();
        ptnc->_pTaskLookForBookmark->Release();
        ptnc->_pTaskLookForBookmark = NULL;

        EnsureDeleteTransNavContext(ptnc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTaskLookForBookmark::OnRun
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CTaskLookForBookmark::OnRun(DWORD dwTimeOut)
{
    if (!_pMarkup->_fPicsProcessPending )
    {
        if (_cstrJumpLocation)
        {
            CStr cstrTemp;

            // The problem is that Navigate and its descendants will want
            // to call CStr::Set on _cstrJumpLocation, and hence we cannot
            // pass that in to Navigate (CStr::Set frees memory and then
            // allocates and copies -- you figure yet?)
            cstrTemp.Set(_cstrJumpLocation);
            if (_pMarkup->Doc()->_pClientSite)
                _pMarkup->NavigateHere(_dwFlags, cstrTemp, 0, TRUE);
            else
                _pMarkup->Navigate(_dwFlags, cstrTemp);
        }
        else
        {
            // Then try to scroll or continue waiting
            _pMarkup->NavigateHere(_dwFlags, NULL, _dwScrollPos, TRUE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\inplace.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inplace.cxx
//
//  Contents:   CDoc implementation (partial)
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef UNIX
#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

EXTERN_C const GUID SID_SMenuBandHandler;

//TODO : (chandras 05/25/1999) As edit resources are not in common place, this needs to be done
//       when they are moved to a commonplace, this needs to be removed
#ifndef IDS_EDUNDODRAGDROP
#define IDS_EDUNDODRAGDROP 2009
#endif 

#define SCROLLPERCENT   125

ATOM GetWndClassAtom(UINT uIndex);

UINT   g_msgMouseWheel  = 0;

EXTERN_C const CLSID CLSID_HTMLDialog;

#ifndef NO_IME
extern HRESULT ActivateDIMM(); // imm32.cxx
extern HRESULT FilterClientWindowsDIMM(ATOM *aaWindowClasses, UINT uSize);
#endif // ndef NO_IME

CLayout * GetLayoutForDragDrop(CElement * pElement); // defined below

DeclareTagOther(tagFirstTimeTab, "Currency", "Enable IE FirstTime Tab")

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureInPlaceObject, CServer
//
//  Synopsis:   Creates the InPlace object when needed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureInPlaceObject()
{
    if (!_pInPlace)
    {
        _pInPlace = new CFormInPlace();
        if (!_pInPlace)
            RRETURN(E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormInPlace::~CFormInplace
//
//  Synopsis:   Cleanup before destruction.
//
//----------------------------------------------------------------------------

CFormInPlace::~CFormInPlace()
{
    // Make sure we have released all window resources.
    ClearInterface(&_pHostShowUI);
}


HRESULT
CDoc::OnSelectChange(void)
{
    if (_state != OS_UIACTIVE)
        return S_OK;

    HRESULT                         hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     FormOverlayWndProc
//
//  Synopsis:   Transparent window for use during drag-drop.
//
//-------------------------------------------------------------------------

static LRESULT CALLBACK
FormOverlayWndProc(HWND hWnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            BeginPaint(hWnd, &ps);
            EndPaint(hWnd, &ps);
        }
        return 0;

    case WM_ERASEBKGND:
        return TRUE;

    default:
        return DefWindowProc(hWnd, wm, wParam, lParam);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::CreateOverlayWindow
//
//  Synopsis:   Creates a transparent window for use during drag-drop.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HWND
CDoc::CreateOverlayWindow(HWND hwndCover)
{
    Assert(_pInPlace->_hwnd);
    HWND hwnd;
    TCHAR * pszBuf;

    if (!GetWndClassAtom(WNDCLASS_OVERLAY))
    {
        HRESULT     hr;

        hr = THR(RegisterWindowClass(
                WNDCLASS_OVERLAY,
                FormOverlayWndProc,
                CS_DBLCLKS,
                NULL, 
                NULL));
        if (hr)
            return NULL;
    }

#if defined(WIN16) || defined(_MAC)
    TCHAR szBuf[128];
    GlobalGetAtomName(GetWndClassAtom(WNDCLASS_OVERLAY), szBuf, ARRAY_SIZE(szBuf));
    pszBuf = szBuf;
#else
    pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_OVERLAY);
#endif


    // TODO (garybu) Overlay window should be same size as hwndCover and
    // just above it in the zorder.

    hwnd = CreateWindowEx(
            WS_EX_TRANSPARENT,
            pszBuf,
            NULL,
            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
            0, 0,
            SHRT_MAX / 2, SHRT_MAX / 2,
            _pInPlace->_hwnd,
            0,
            g_hInstCore,
            this);
    if (!hwnd)
        return NULL;

    SetWindowPos(
            hwnd,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Member:    CDoc::AttachWin
//
//  Synopsis:  Create our InPlace window
//
//  Arguments: [hwndParent] -- our container's hwnd
//
//  Returns:   hwnd of InPlace window, or NULL
//
//---------------------------------------------------------------

HRESULT
CDoc::AttachWin(HWND hwndParent, RECT * prc, HWND * phwnd)
{
    HRESULT     hr = S_OK;
    HWND        hwnd = NULL;
    const DWORD STYLE_ENABLED = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    //  Note: this code is duplicated in CServer::AttachWin.

    if (!GetWndClassAtom(WNDCLASS_SERVER))
    {
        hr = THR(RegisterWindowClass(
                WNDCLASS_SERVER,
                CServer::WndProc,
                CS_DBLCLKS,
                NULL, NULL));

        if (hr)
        {
            WHEN_DBG(GetLastError());
            AssertSz(0, "RegisterWindowClass for server failed");
            goto Cleanup;
        }

#ifndef NO_IME
        // if dimm is installed, we only want ime interaction with the server class
        ATOM atomWndClass = GetWndClassAtom(WNDCLASS_SERVER);
        FilterClientWindowsDIMM(&atomWndClass, 1);
#endif // ndef NO_IME
    }

    Assert(phwnd);

    if (_hwndCached)
    {
        hwnd = _hwndCached;
        _hwndCached = NULL; // this is necessary because if the window is destroyed later by WM_DESTROY,
                            // which we don't intercept, then _hwndCached should not be != NULL
        if (SetParent (hwnd, hwndParent))
        {
            UINT uiSWPFlags = (_fPopupDoc ? SWP_NOACTIVATE : 0) | SWP_SHOWWINDOW | SWP_NOREDRAW;
            _pInPlace->_hwnd = hwnd;
            PrivateAddRef();
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(CServer *) this); // connect this CDoc to the window
                                                                 // NOTE the cast to CServer for WIN16
            SetWindowPos (
                hwnd,
                HWND_TOP,
                prc->left, prc->top,
                prc->right - prc->left, prc->bottom - prc->top,
                uiSWPFlags);
        }
        else
        {
            DestroyWindow(hwnd);
            hwnd = NULL; // this will cause it to create new window
        }
    }

    if (!hwnd)
    {
        TCHAR * pszBuf;
        TCHAR achClassName[256];

        DWORD dwExStyle = 0;
        DWORD dwStyle = STYLE_ENABLED;

        if (_fPopupDoc)
        {
            dwExStyle   |=  WS_EX_TOPMOST
                          | WS_EX_TOOLWINDOW
                          | WS_EX_NOPARENTNOTIFY;

            dwStyle     |=  WS_POPUP
                          | WS_CLIPCHILDREN;
        }

#ifdef WIN16
        char szBuf[128];
        GlobalGetAtomName(GetWndClassAtom(WNDCLASS_SERVER), szBuf, ARRAY_SIZE(szBuf));
        pszBuf = szBuf;
#else
        pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_SERVER);
#endif

        hwnd = CreateWindowEx(
                dwExStyle,
                pszBuf,
                NULL,
                dwStyle,
                prc->left, prc->top,
                prc->right - prc->left, prc->bottom - prc->top,
                hwndParent,
                0,              // no child identifier - shouldn't send WM_COMMAND
                g_hInstCore,
                (CServer *)this);

        ::GetClassName(hwndParent, achClassName, ARRAY_SIZE(achClassName));
        _fVB = (StrCmpIW(achClassName, _T("HTMLPageDesignerWndClass")) == 0) ? TRUE : FALSE;
    }

    if (!hwnd)
        goto Win32Error;

    // Lazily register/revoke drag-drop
#ifndef NO_DRAGDROP
    IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CDoc, EnableDragDrop, enabledragdrop), 0, FALSE, "CDoc::EnableDragDrop"));
#endif // NO_DRAGDROP

#ifndef WIN16
#ifndef NO_IME
    // if DIMM is installed, activate it
    ActivateDIMM();
#endif // ndef NO_IME

    if (g_msgMouseWheel == 0 && GetVersion() >= 0x80000000)
    {
        // special for Windows 95, equivalent to WM_MOUSEWHEEL
        //
        g_msgMouseWheel = RegisterWindowMessage(_T("MSWHEEL_ROLLMSG"));
    }

    // Initialize our _wUIState from the window.
    // TODO: do we need to clear formats here? (jbeda)
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        _wUIState = SendMessage(hwnd, WM_QUERYUISTATE, 0, 0);
    }
#endif // ndef WIN16

    //
    // We need to give editor a chance to initialize DIMM 
    // if it has already been created. 
    //
    if (GetHTMLEditor(FALSE))
    {
        IGNORE_HR( NotifySelection(EDITOR_NOTIFY_ATTACH_WIN, this) );
    }
Cleanup:
    *phwnd = hwnd;

    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    DetachWin();
    goto Cleanup;
}

//+---------------------------------------------------------------
//
// Local Helper: IsInIEBrowser
//
// Synopsis: Determine if Trident is in IE browser
//
//----------------------------------------------------------------
BOOL
IsInIEBrowser(CDoc * pDoc)
{
    BOOL             fResult     = FALSE;
    IOleClientSite * pClientSite = pDoc->_pClientSite;
    IUnknown         * pUnk2 = NULL;
    
    if ((!(pDoc->DesignMode()))
            && ((pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG) == 0)
            && (pClientSite))
    {
        HRESULT hr;
        IServiceProvider * psp1, * psp2;
        IUnknown         * pUnk;


        hr = pClientSite->QueryInterface(IID_IServiceProvider, (void **) &psp1);
        if (!hr && psp1)
        {
            hr = psp1->QueryService(
                    SID_STopLevelBrowser,
                    IID_IServiceProvider,
                    (void **) &psp2);

                                   
            if (!hr && psp2)
            {                    
                hr = psp2->QueryInterface(SID_SShellDesktop, (void **) &pUnk);
                if (!hr && pUnk)
                    pUnk->Release();
                else
                {
                    hr = psp2->QueryService( SID_SMenuBandHandler, IID_IUnknown, (void**) & pUnk2 );
                    if ( SUCCEEDED( hr ))
                        fResult = TRUE;
#if DBG == 1                        
                    else if (IsTagEnabled(tagFirstTimeTab))
                    {
                        fResult = TRUE;
                    }
#endif                    
                    ReleaseInterface( pUnk2 );                        
                }    
                psp2->Release();
            }
            psp1->Release();
        }
    }
    
    return fResult;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RunningToInPlace
//
//  Synopsis:   Effects the running to inplace-active state transition
//
//  Returns:    SUCCESS if the object results in the in-place state
//
//  Notes:      This method in-place activates all inside-out embeddings
//              in addition to the normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::RunningToInPlace(LPMSG lpmsg)
{
    HRESULT         hr;
    CNotification   nf;

    TraceTag((tagCDoc, "%lx CDoc::RunningToInPlace", this));

    _fFirstTimeTab = IsInIEBrowser(this);
    
    _fInPlaceActivating = TRUE;
    _fEnableInteraction = TRUE;

    //  Do the normal transition, creating our main window

    hr = THR(CServer::RunningToInPlace(lpmsg));
    if (hr)
        goto Cleanup; // Do not goto error because CServer has already
                      // performed all necessary cleanup.

    // Make sure that we have a current element before we set focus to one.
    // If we are parse done, and just becoming inplace, then we don't have an
    // active element yet.
    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)	
        DeferSetCurrency(0);    

    //
    // Prepare the view
    //
    _view.Activate();
    {
        SIZE    sizeDst;
        sizeDst.cx = _pInPlace->_rcPos.right  - _pInPlace->_rcPos.left;
        sizeDst.cy = _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top;
        if (sizeDst.cx == 0) sizeDst.cx = 1;
        if (sizeDst.cy == 0) sizeDst.cy = 1;
        _view.SetViewSize(sizeDst);
    }
    _view.SetFocus(_pElemCurrent, _lSubCurrent);

    //
    // Look for IDocHostShowUI
    //

    Assert(!InPlace()->_pHostShowUI);

    // first look on the DocHostUIHandler
    // If the handler is imposed on us through ICustomDoc,
    //   it has already happened
    // If we use CSmartDocHostUIHandler, it will also
    //   pass IDocHostShowUI calls to the super site.
    if(_pHostUIHandler)
    {
        hr = THR_NOTRACE(_pHostUIHandler->QueryInterface(
                                                IID_IDocHostShowUI,
                                                (void **)&(InPlace()->_pHostShowUI)));
        if(hr != S_OK)
        {
            InPlace()->_pHostShowUI = NULL;
        }
    }

    // next look on the client site
    if(_pClientSite && !InPlace()->_pHostShowUI)
    {
        hr = THR_NOTRACE(_pClientSite->QueryInterface(
                                           IID_IDocHostShowUI,
                                           (void **)&(InPlace()->_pHostShowUI)));
        if(hr != S_OK)
        {
            InPlace()->_pHostShowUI = NULL;
        }
    }

    // not having a DocHostShowUI is not a failing condition for this function
    hr = S_OK;

    //
    // Make sure that everything is laid out correctly
    // *before* doing the BroadcastNotify because with olesites,
    // we want to baseline them upon the broadcast.  When doing this,
    // we better know the olesite's position.
    //

    _view.EnsureView(LAYOUT_SYNCHRONOUS);

    nf.DocStateChange1(PrimaryRoot(), (void *)OS_RUNNING);
    BroadcastNotify(&nf);

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        // Now is the time to ask the sites to load any history
        // that they could not earlier (e.g. scroll/caret positions
        // because they require the doc to be recalced, the site
        // arrays built, etc.)
        CMarkup * pMarkupPrimary = PrimaryMarkup();
        CMarkupTransNavContext * ptnc;
        if (    pMarkupPrimary 
            &&  pMarkupPrimary->HasTransNavContext() 
            &&  (ptnc = pMarkupPrimary->GetTransNavContext())->_fDoDelayLoadHistory)
        {
            CNotification   nf;
            
            // TODO: (jbeda) We need to do this for ALL markups 
            // -- not just the primary
            ptnc->_fDoDelayLoadHistory = FALSE;
            pMarkupPrimary->EnsureDeleteTransNavContext(ptnc);

            nf.DelayLoadHistory(pMarkupPrimary->Root());
            BroadcastNotify(&nf);
        }
    }

#if DBG == 1
    DisplayChildZOrder(_pInPlace->_hwnd);
#endif

    //
    // Show document window *after* all child windows have been
    // created, to reduce clipping region recomputations.  To avoid
    // WM_ERASEBKGND sent outside of a WM_PAINT, we show without
    // redraw and then invalidate.
    //

    SetWindowPos(_pInPlace->_hwnd, NULL, 0, 0, 0, 0,
            SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE |
            SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

    // Unblock any script execution/parsing that was waiting for inplace activation
    NotifyMarkupsInPlace();

    // If we have a task to look for a certain scroll position, make sure
    // we have recalc'd at least to that point before display.

    // Supress scrollbits because we're about to inval the entire window
    PrimaryMarkup()->NavigateNow(FALSE);

    // This inval does nothing if LoadStatus() < LOADSTATUS_INTERACTIVE
    Invalidate(NULL, NULL, NULL, INVAL_CHILDWINDOWS);

    // run scripts if not in  mode
    if (!DesignMode())
    {
        if (LoadStatus() >= LOADSTATUS_DONE)
        {
            CScriptCollection * pScriptCollection = PrimaryMarkup()->GetScriptCollection();

            if (pScriptCollection)
            {
                hr = THR(pScriptCollection->SetState(SCRIPTSTATE_CONNECTED));
                if (hr)
                    goto Error;
            }

            if (!_pWindowPrimary->_fFiredOnLoad)
            {
                _pWindowPrimary->_fFiredOnLoad = TRUE;

                {
                    CDoc::CLock Lock(this);

                    if (    CMarkup::HtmCtxHelper(PrimaryMarkup())
                        && !(CMarkup::HtmCtxHelper(PrimaryMarkup())->GetState() & (DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                    {
                        // these memberdata will only be here if a peer was present to put them
                        // there.  thus we don't need to check for _fPeersPossible
                        CMarkupBehaviorContext * pContext = NULL;

                        hr = THR(PrimaryMarkup()->EnsureBehaviorContext(&pContext));
                        if (hr)
                            goto Cleanup;

                        if ( pContext->_cstrHistoryUserData || _pShortcutUserData)
                            PrimaryMarkup()->FirePersistOnloads();

                        _pWindowPrimary->Fire_onload();
                    }

                    // Let the client site know we are loaded
                    // Only HTMLDialog pays attention to this
                    if (_pClientSite && _fInHTMLDlg)
                    {
                        CTExec(_pClientSite, &CLSID_HTMLDialog,
                               0, 0, NULL, NULL);
                    }
                }
            }
        }
    }

    RefreshStatusUI();
    DeferUpdateUI();

Cleanup:

    _fInPlaceActivating = FALSE;
    RRETURN(hr);

Error:

    IGNORE_HR(InPlaceToRunning());
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::InPlaceToRunning
//
//  Synopsis:   Effects the inplace-active to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method in-place deactivates all inside-out embeddings
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::InPlaceToRunning(void)
{
    HRESULT             hr = S_OK;
    CNotification       nf;
    CScriptCollection * pScriptCollection;

    TraceTag((tagCDoc, "%lx CDoc::InPlaceToRunning", this));
    {
        CElement *pElemFireTarget;
        pElemFireTarget = _pElemCurrent->GetFocusBlurFireTarget(_lSubCurrent);
        Assert(pElemFireTarget);

        CElement::CLock LockUpdate(pElemFireTarget, CElement::ELEMENTLOCK_UPDATE);
        _fInhibitFocusFiring = TRUE;

        if (pElemFireTarget->IsInMarkup())
        {
            IGNORE_HR(pElemFireTarget->RequestYieldCurrency(TRUE));
        }

        if (pElemFireTarget->IsInMarkup())
        {
            hr = THR(pElemFireTarget->YieldCurrency(_pElementDefault));
            if (hr)
                goto Cleanup;

            if (!TestLock(FORMLOCK_CURRENT))
            {
                Assert(pElemFireTarget == _pElemCurrent || pElemFireTarget->Tag() == ETAG_AREA);
                pElemFireTarget->Fire_onblur(0);
            }
        }
        _fInhibitFocusFiring = FALSE;
    }

    if (_pElemUIActive)
    {
        _pElemUIActive->YieldUI(PrimaryRoot());
    }
    _pElemCurrent = _pElemUIActive = PrimaryRoot();

    SetMouseCapture (NULL, NULL);

    // stop scripts if not in design mode
    
    _pWindowPrimary->Window()->CleanupScriptTimers();

    if (_pWindowPrimary->_fFiredOnLoad)
    {
        _pWindowPrimary->_fFiredOnLoad = FALSE;
        {
            CDoc::CLock Lock(this);
            _pWindowPrimary->Fire_onunload();
        }
    }

    //
    // Shutdown the view
    //

    hr = THR(CServer::InPlaceToRunning());

    //
    // if we are a popup restore the _pDT of our parent
    //
    if (_fPopupDoc && _pHostUIHandler)
    {
        IDropTarget *   pDTOut = NULL;
        if (!_pHostUIHandler->GetDropTarget(_pPopupParentWindow->Doc()->_pDT, &pDTOut))
        {
            ReleaseInterface(pDTOut);
        }
    }

    ClearInterface(&_pDT);


    //
    // Clear these variables so we don't stumble over stale
    // values should we be inplace activated again.
    //

    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
    _fMouseOverTimer = FALSE;
    if (_pNodeLastMouseOver)
    {
        CTreeNode * pNodeRelease = _pNodeLastMouseOver;
        _pNodeLastMouseOver = NULL;
        pNodeRelease->NodeRelease();
    }

    nf.DocStateChange1(PrimaryRoot(), (void *)OS_INPLACE);
    BroadcastNotify(&nf);

    _view.Deactivate();

    pScriptCollection = PrimaryMarkup()->GetScriptCollection();
    if (pScriptCollection)
    {
        pScriptCollection->SetState(SCRIPTSTATE_DISCONNECTED);
    }


Cleanup:

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InPlaceToUIActive, public
//
//  Synopsis:   Overridden helper method in CServer.  Called when we
//              transition from InPlace to UIActive.
//
//  Returns:    HRESULT
//
//  Notes:      If the form is in run mode, then the first control on the
//              tab-stop list is UI Activated in leu of the form.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InPlaceToUIActive(LPMSG lpmsg)
{
    HRESULT         hr  = S_OK;
    CNotification   nf;

    //
    // Try to get into the UI active state by UI activating
    // a contained site. If this works, CServer::InPlaceToUIActivate
    // will be called from CDoc::SetUIActiveSite.  Do this as long as
    // a child within us is not activating.
    //

    if (!_pInPlace->_fChildActivating)
    {
        if (_fDefView && !_fActiveDesktop && _pInPlace->_hwnd)
        {
            // Bring to top of z-order (fix for #77063)
            // Ideally, we would like to bring ourselves to the top
            // always, but this would break ActiveDesktop! They keep us behind the
            // transparent ListView which contains the desktop icons.
            SetWindowPos(
                    _pInPlace->_hwnd,
                    HWND_TOP,
                    0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }

        if (_pElemCurrent != PrimaryRoot())
        {
            hr = THR(_pElemCurrent->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        }
        else
        {
            ActivateFirstObject(lpmsg);
        }
    }


    // If we couldn't get a site to activate, then activate the document.

    if (_state != OS_UIACTIVE && !_fIsPrintWithNoUI)
    {
        hr = THR(CServer::InPlaceToUIActive(lpmsg));
    }

    _view.SetFocus(_pElemCurrent, _lSubCurrent);

    // Tell the caret to update
    if( _pCaret )
        _pCaret->DeferredUpdateCaret((DWORD_PTR) this);

    IGNORE_HR(OnSelectChange());
    
    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_INPLACE);
        Assert( nf.Element() );
        BroadcastNotify(&nf);
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::UIActiveToInPlace
//
//  Synopsis:   Effects the U.I. active to inplace-active state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method U.I. deactivates any U.I. active embedding
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::UIActiveToInPlace()
{
    HRESULT         hr;
    CNotification   nf;
    
    //
    //  Tell the editor to lose focus
    //

    hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS, NULL ));

    _state = OS_INPLACE;

    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_UIACTIVE);
        BroadcastNotify(&nf);
    }

    _view.SetFocus(NULL, 0);
    
    //  Clear ourselves as the active selection container

    hr = THR(CServer::UIActiveToInPlace());

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragEnter, IDropTarget
//
//  Synopsis:   Setup for possible drop
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragEnter(
        IDataObject * pDataObj,
        DWORD         grfKeyState,
        POINTL        ptlScreen,
        DWORD *       pdwEffect)
{
#ifdef UNIX
    if (_dwTID != GetCurrentThreadId())
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
#endif

    _fRightBtnDrag = (grfKeyState & MK_RBUTTON) ? 1 : 0;

    HRESULT hr = CServer::DragEnter(pDataObj, grfKeyState, ptlScreen, pdwEffect);
    if (hr)
    {
        RRETURN(hr);
    }

    TCHAR pUndoTitle[ 256 ];
    hr = THR( GetEditingString( IDS_EDUNDODRAGDROP, pUndoTitle ));
    if ( hr )
    {
        RRETURN( hr );
    }
    BeginUndoUnit(pUndoTitle);

    Assert(!_pDragDropTargetInfo);
    _pDragDropTargetInfo = new CDragDropTargetInfo( this );
    if (!_pDragDropTargetInfo)
        return E_OUTOFMEMORY;

    RRETURN(THR(DragOver(grfKeyState, ptlScreen, pdwEffect)));
}

CLayout *
GetLayoutForDragDrop(CElement * pElement)
{
    CLayout * pLayout = pElement->GetUpdatedLayout();

    // Handle slaves
    if (!pLayout && pElement->HasMasterPtr())
    {
        pLayout = pElement->GetMasterPtr()->GetUpdatedLayout();
    }
    return pLayout;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragOver, IDropTarget
//
//  Synopsis:   Handle scrolling and dispatch to site.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragOver(DWORD grfKeyState, POINTL ptScreen, DWORD *pdwEffect)
{

    HRESULT     hr              = S_OK;
    POINT       pt;
    CTreeNode * pNodeElement    = NULL;
    DWORD       dwLoopEffect;
    CMessage    msg;
    DWORD       dwScrollDir     = 0;
    BOOL        fRedrawFeedback;
    BOOL        fRet;
    BOOL        fDragEnter;

    Assert(_pInPlace->_pDataObj);

    if (!_pDragDropTargetInfo)
    {
        AssertSz(0, "DragDropTargetInfo is NULL. Possible cause - DragOver called without calling DragEnter");
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    // Cache for possible use in CDoc::Drop.  See comment there.
    _pDragDropTargetInfo->_dwLastKeyState = grfKeyState;
    
    pt = *(POINT *)&ptScreen;
    ScreenToClient(_pInPlace->_hwnd, &pt);

    msg.pt = pt;
    HitTestPoint(&msg, &pNodeElement, HT_IGNOREINDRAG);
    if ( !pNodeElement )
        goto Cleanup;
        
    // Point to the content
    if (pNodeElement->Element()->HasSlavePtr())
    {
        pNodeElement = pNodeElement->Element()->GetSlavePtr()->GetFirstBranch();
    }

    // We should not change pdwEffect unless DragEnter succeeded, and always call
    // DragEnter with the original effect
    dwLoopEffect = *pdwEffect;

    if (pNodeElement->Element() != _pDragDropTargetInfo->_pElementHit)
    {
        fDragEnter = TRUE;
        _pDragDropTargetInfo->_pElementHit = pNodeElement->Element();
    }
    else
        fDragEnter = FALSE;

    while (pNodeElement)
    {
        CLayout * pLayout = GetLayoutForDragDrop(pNodeElement->Element());

        hr = THR( pNodeElement->NodeAddRef() );
        if( hr )
            goto Cleanup;

        //  Bug 102481: If this is an atomic element, we do not want to allow drops onto it.
        //  We'll only do this check once when we cross between elements.

        if (fDragEnter && IsElementAtomic(pNodeElement->Element()))
        {
            *pdwEffect = DROPEFFECT_NONE;
            break;
        }

        if (pNodeElement->Element() == _pDragDropTargetInfo->_pElementTarget)
        {
            fRet = pNodeElement->Element()->Fire_ondragHelper(
                0,
                &s_propdescCElementondragover,
                pdwEffect);

            if (pNodeElement->IsDead())
            {
                pNodeElement->NodeRelease();
                goto Cleanup;
            }
            if (fRet)
            {
                if (pLayout)
                    hr = THR(pLayout->DragOver(grfKeyState, ptScreen, pdwEffect));
                else
                    *pdwEffect = DROPEFFECT_NONE;
            }
            break;
        }

        if (fDragEnter)
        {
            fRet = pNodeElement->Element()->Fire_ondragHelper(
                0,
                &s_propdescCElementondragenter,
                &dwLoopEffect);

            if (pNodeElement->IsDead())
            {
                pNodeElement->NodeRelease();
                goto Cleanup;
            }
            if (fRet)
            {
                if (pLayout)
                {
                    hr = THR(pLayout->DragEnter(_pInPlace->_pDataObj, grfKeyState, ptScreen, &dwLoopEffect));

                    if (dwLoopEffect == DROPEFFECT_NONE)
                    {
                        _fDragFeedbackVis = FALSE;
                        IGNORE_HR(_pCaret->Hide());
                    }

                    if (hr != S_FALSE)
                        break;
                }
            }
            else
                break;
        }

        // TODO: what if pNodeElement goes away on this first release?!?
        pNodeElement->NodeRelease();
        pNodeElement = pNodeElement->GetUpdatedParentLayoutNode();
        dwLoopEffect = *pdwEffect;
    }
    if ( pNodeElement && DifferentScope(pNodeElement, _pDragDropTargetInfo->_pElementTarget) )
    {
        if (_pDragDropTargetInfo->_pElementTarget && _pDragDropTargetInfo->_pElementTarget->GetFirstBranch())
        {
            CLayout * pLayout;

            _pDragDropTargetInfo->_pElementTarget->Fire_ondragleave();

            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
            if (pLayout)
                IGNORE_HR(pLayout->DragLeave());
        }

        _pDragDropTargetInfo->_pElementTarget = pNodeElement->Element();
        *pdwEffect = dwLoopEffect;
    }

    if (NULL == _pDragDropTargetInfo->_pElementTarget)
    {
        *pdwEffect = DROPEFFECT_NONE;
    }


    // Find the site to scroll and the direction, if any

    if (pNodeElement)
    {
        // TODO: what if pNodeElement goes away on this first release!?!?
        pNodeElement->NodeRelease();
        if (pNodeElement->IsDead())
            goto Cleanup;
    }

    {
        Assert(_view.IsActive());

        CDispScroller * pDispScroller = _view.HitScrollInset((CPoint *) &pt, &dwScrollDir);

        if (pDispScroller)
        {
            Assert(dwScrollDir);
            *pdwEffect |= DROPEFFECT_SCROLL;

            if (_pDragDropTargetInfo->_pDispScroller == pDispScroller)
            {
                if (IsTimePassed(_pDragDropTargetInfo->_uTimeScroll))
                {
                    CElement        *pElement = NULL;
                    CTreeNode       *pNodeElement = NULL;
                    styleOverflow   stO = styleOverflowNotSet;

                    //  Get the element that refers to the disp scroller
                    //  and get the overflow attribute.
                    pElement = GetDispNodeElement(pDispScroller);
                    if (pElement)
                    {
                        pNodeElement = pElement->GetFirstBranch();
                        Assert(pNodeElement);
                        if (pNodeElement)
                            stO = pNodeElement->GetCascadedoverflow();
                    }

                    //  We want to scroll only if the scroller does not have
                    //  overflow:hidden.
                    if (stO != styleOverflowHidden)
                    {
                        CSize sizeOffset;
                        CSize sizePercent(0, 0);
                        CSize sizeDelta;
                        CRect rc;

                        // Hide drag feedback while scrolling
                        fRedrawFeedback = _fDragFeedbackVis;
                        if (_fDragFeedbackVis)
                        {
                            CLayout * pLayout;

                            Assert(_pDragDropTargetInfo->_pElementTarget);

                            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
                            if (pLayout)
                                pLayout->DrawDragFeedback(FALSE);
                        }

                        // open display tree for scrolling
                        Verify(_view.OpenView());

                        pDispScroller->GetClientRect(&rc, CLIENTRECT_CONTENT);
                        pDispScroller->GetScrollOffset(&sizeOffset);

                        if (dwScrollDir & SCROLL_LEFT)
                            sizePercent.cx = -SCROLLPERCENT;
                        else if (dwScrollDir & SCROLL_RIGHT)
                            sizePercent.cx = SCROLLPERCENT;
                        if (dwScrollDir & SCROLL_UP)
                            sizePercent.cy = -SCROLLPERCENT;
                        else if (dwScrollDir & SCROLL_DOWN)
                            sizePercent.cy = SCROLLPERCENT;

                        sizeDelta.cx = (sizePercent.cx ? (rc.Width() * sizePercent.cx) / 1000L : 0);
                        sizeDelta.cy = (sizePercent.cy ? (rc.Height() * sizePercent.cy) / 1000L : 0);

                        sizeOffset += sizeDelta;
                        sizeOffset.Max(g_Zero.size);

                        if( _pCaret )
                        {
                            _pCaret->BeginPaint();
                        }
                    
                        pDispScroller->SetScrollOffset(sizeOffset, TRUE);
                    
                        if( _pCaret )
                        {
                            _pCaret->EndPaint();
                        }
                    
                        //  Ensure all deferred calls are executed
                        _view.EndDeferred();

                        // Show drag feedback after scrolling is finished
                        if (fRedrawFeedback)
                        {
                            CLayout * pLayout;

                            Assert(_pDragDropTargetInfo->_pElementTarget);

                            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
                            if (pLayout)
                                pLayout->DrawDragFeedback(TRUE);
                        }
                    }

                    // Wait a while before scrolling again
                    _pDragDropTargetInfo->_uTimeScroll = NextEventTime(g_iDragScrollInterval / 2);
                }
            }
            else
            {
                _pDragDropTargetInfo->_pDispScroller = pDispScroller;
                _pDragDropTargetInfo->_uTimeScroll = NextEventTime(g_iDragScrollDelay);
            }
        }
        else
        {
            _pDragDropTargetInfo->_pDispScroller = NULL;
        }
    }

Cleanup:
    // S_FALSE from DragOver() does not make sense for OLE. Also, since we
    // call DragOver() from within DragEnter(), we DO NOT want to return
    // S_FALSE because that would result in OLE passing on DragOver() to
    // the parent drop target.
    if (hr == S_FALSE)
        hr = S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragLeave, IDropTarget
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragLeave(BOOL fDrop)
{
    if (_pDragDropTargetInfo)
    {

        CLayout * pLayout = NULL;

        if (_pDragDropTargetInfo->_pElementTarget)
        {            
            //TODO (t-jeffg) This makes sure that when dragging out of the source window
            //the dragged item will be deleted.  Will be removed when _pdraginfo is dealt
            //with properly on leave.  (Anandra)
            _fSlowClick = FALSE;

            if (!fDrop)
                _pDragDropTargetInfo->_pElementTarget->Fire_ondragleave();

            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
            if (pLayout)
                IGNORE_HR(pLayout->DragLeave());
        }
        if ( ! fDrop && pLayout && _pDragDropTargetInfo->SavedSelection() )
        {
            _pDragDropTargetInfo->RestoreSelection();    
        }            
        delete _pDragDropTargetInfo;
        _pDragDropTargetInfo = NULL;
               
        if ( _pCaret )
        {
            _pCaret->LoseFocus();
        }        
    }

    EndUndoUnit();

    RRETURN(CServer::DragLeave(fDrop));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Drop, IDropTarget
//
//  Synopsis:   Handle the drop operation
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Drop(
    IDataObject *pDataObj,
    DWORD        grfKeyState,
    POINTL       ptScreen,
    DWORD *      pdwEffect)
{
    HRESULT   hr = S_OK;
    CLayout * pLayout;

    CCurs   curs(IDC_WAIT);
    DWORD   dwEffect = *pdwEffect;

    // Since the keystate now might be (probably is) different than the last DragOver, use
    // cached keystate from that call.  Otherwise, things like MK_BUTTON might not be set.
    hr = THR(DragOver(_pDragDropTargetInfo ? _pDragDropTargetInfo->_dwLastKeyState : grfKeyState,
                ptScreen, &dwEffect));
    
    // Continue only if drop can happen (i.e. at least one of DROPEFFECT_COPY,
    // DROPEFFECT_MOVE, etc. is set in dwEffect).
    if (hr || DROPEFFECT_NONE == dwEffect || DROPEFFECT_SCROLL == dwEffect)
        goto Cleanup;

    Assert(_pDragDropTargetInfo);
    if (!_pDragDropTargetInfo->_pElementTarget)
    {
        *pdwEffect = DROPEFFECT_NONE;
        goto Cleanup;
    }

    if (_pDragDropTargetInfo->_pElementTarget->Fire_ondragHelper(
                0,
                &s_propdescCElementondrop,
                pdwEffect))
    {
        if (!_pDragDropTargetInfo->_pElementTarget)
        {
            *pdwEffect = DROPEFFECT_NONE;
            goto Cleanup;
        }

        pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
        if (pLayout)
            hr = THR(pLayout->Drop(pDataObj, grfKeyState, ptScreen, pdwEffect));
        else
            *pdwEffect = DROPEFFECT_NONE;
    }

    // Drop can change the current site.  Set the UI active
    // site to correspond to the current site.

    if (_pElemUIActive != _pElemCurrent)
    {
        _pElemCurrent->BecomeUIActive();
    }

Cleanup:
    IGNORE_HR(DragLeave( hr == S_OK ));    

    RRETURN1(hr,S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReactivateAndUndo, public
//
//  Synopsis:   Transitions us to UI Active and performs an undo.  This is
//              called if we just deactivated and the user selected our
//              parent's Undo option.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ReactivateAndUndo(void)
{
    HRESULT      hr;
    CDoc::CLock Lock(this);

    TransitionTo(OS_UIACTIVE);

#ifdef NO_EDIT
    hr = S_OK;
#else
    hr = THR(EditUndo());
#endif // NO_EDIT

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     DoTranslateAccelerator, public
//
//  Synopsis:   Overridden method of IOleInPlaceActiveObject
//
//  Arguments:  [lpmsg] -- Message to translate
//
//  Returns:    S_OK if translated, S_FALSE if not.  Error otherwise
//
//  History:    07-Feb-94     LyleC    Created
//              08-Feb-95     AndrewL  Turned off noisy trace.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::DoTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT  hr = S_FALSE;
    HRESULT  hr2;
    CMessage Message(lpmsg);

    if (    _pDocPopup 
        &&  _pDocPopup->_pInPlace)
    {
        hr = _pDocPopup->DoTranslateAccelerator(lpmsg);
        if (hr != S_FALSE)
        {
            RRETURN(hr);
        }

        if (lpmsg->message == WM_KEYDOWN && (lpmsg->wParam == VK_ESCAPE || lpmsg->wParam == VK_TAB))
        {
            hr = THR(_pDocPopup->DoVerb(    OLEIVERB_HIDE,
                                            NULL,
                                            _pDocPopup->_pClientSite,
                                            0,
                                            NULL,
                                            NULL));

            if (lpmsg->wParam == VK_ESCAPE && hr != S_FALSE)
                RRETURN(hr);
        }
    }

    Assert(_pElemCurrent && _pElemCurrent->GetFirstBranch());

    CTreeNode::CLock Lock;

    hr2 = THR( Lock.Init(_pElemCurrent->GetFirstBranch()) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }


    switch (lpmsg->message)
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        goto Cleanup;
    }

    //
    // Do not handle any messages if our window or one of our children
    // does not have focus.
    //

    // TODO (sujalp): We should not be dispatching this message from here.
    // It should be dispatched only from CDoc::OnWindowMessage. When this
    // problem is fixed up, remove the following switch.
    switch (lpmsg->message)
    {
    case WM_KEYDOWN:
        _fGotKeyDown = TRUE;
        // if we are Tabbing into Trident the first time directly from address bar
        // do not tab into address bar again on next TAB. (sramani: see bug#28426)

        if (lpmsg->wParam == VK_TAB && ::GetFocus() != _pInPlace->_hwnd)
            _fFirstTimeTab = FALSE;

        break;

    case WM_KEYUP:
        if (!_fGotKeyDown)
            return S_FALSE;
        break;
    }

    // If there was no captured object, or if the capture object did not
    // handle the message, then lets pass it to the current site
    hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch(), TRUE));

Cleanup:
    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CallParentTA, public
//
//  Synopsis:   Calls the parent's TranslateAccelerator method and returns
//              TRUE if the parent handled the message.
//
//  Arguments:  pmsg    Message for parent to translate.  If NULL,
//                      then this function always returns FALSE.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CallParentTA(CMessage * pmsg)
{
    HRESULT             hr;
    IOleControlSite *   pCtrlSite;

    Assert(_pClientSite);

    //  If we didn't have a message to translate, no need to call
    //    to our parent.  It is OK for the parent to not
    //    support IOleControlSite. In that case we just indicate
    //    the event was not handled.

    if (pmsg &&
            _pClientSite &&
            !THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleControlSite,
                (void **) &pCtrlSite)))
    {
        hr = THR(pCtrlSite->TranslateAccelerator(
                                pmsg,
                                VBShiftState(pmsg->dwKeyState)));
        pCtrlSite->Release();
        if (FAILED(hr))
            hr = S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


    //+---------------------------------------------------------------------------
//
//  Member:     Form::ActivateFirstObject
//
//  Synopsis:   Activate the first object in the tab order.
//
//  Arguments:  lpmsg       Message which prompted this rotation, or
//                          NULL if no message is available
//              pSiteStart  Site to start the search at.  If null, start
//                          at beginning of tab order.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateFirstObject(LPMSG lpmsg)
{
    HRESULT     hr              = S_OK;
    CElement *  pElementClient  = CMarkup::GetElementTopHelper(PrimaryMarkup());
    BOOL        fDeferActivate  = FALSE;

    if( pElementClient == NULL )
        goto Cleanup;


    if ( pElementClient && ( pElementClient->IsEditable(/*fCheckContainerOnly*/FALSE) || pElementClient->Tag() == ETAG_FRAMESET ))
    {
        // In design mode or in frameset case, just activate the ped.
        //
        hr = THR(pElementClient->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        goto Cleanup;
    }

    if (_fInHTMLDlg || !_fMsoDocMode
                    || ((_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG) != 0))
    {
        // only if we are a dialog or no one is activating us as a doc obj

        if (LoadStatus() < LOADSTATUS_PARSE_DONE)
        {
            // We need to wait until the doc is fully parsed before we can
            // determine the first tabbable object (IE5 #73116).
            fDeferActivate = !_fCurrencySet;
        }
        else
        {
            CElement *      pElement    = NULL;
            long            lSubNext    = 0;
            FOCUS_DIRECTION dir         = DIRECTION_FORWARD;

            if (lpmsg && (lpmsg->message == WM_KEYDOWN ||
                          lpmsg->message == WM_SYSKEYDOWN))
            {
                if (GetKeyState(VK_SHIFT) & 0x8000)
                {
                    dir = DIRECTION_BACKWARD;
                }
            }

            FindNextTabOrder(dir, FALSE, NULL, NULL, 0, &pElement, &lSubNext);
            if (pElement)
            {
                Assert(pElement->IsTabbable(lSubNext));
                hr = THR(pElement->BecomeCurrentAndActive(lSubNext, NULL, NULL, TRUE));
                if (hr)
                    goto Cleanup;

                IGNORE_HR(THR(pElement->ScrollIntoView()));
                _fFirstTimeTab = FALSE;                
                goto Cleanup;
            }
        }
    }

    hr = THR(PrimaryMarkup()->GetElementTop()->BecomeCurrentAndActive(0, NULL, NULL, !g_fInMoney99));

    // Although we have set the currency, if we have not completed the 
    // parsing yet, we were only able to set it to the element client. Once
    // the parsing is completed, it will be set on the proper tab-stop element.
    // We ignore the _fCurrencySet value set by the BecomeCurrentAndActive call.
    if (fDeferActivate)
    {
        _fCurrencySet = FALSE;
    }

    // Fire window onfocus here the first time if not fired before in
    // onloadstatus when it goes to LOADSTATUS_DONE
    _pWindowPrimary->Post_onfocus();

Cleanup:
    RRETURN1(hr, S_FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\krnlundo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       undo.cxx
//
//  Contents:   Implementation of Undo classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  CUndoNewControl Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::CUndoDeleteControl, public
//
//  Synopsis:   CUndoDeleteControl ctor
//
//  Arguments:  [pDoc] -- Pointer to owner form
//
//----------------------------------------------------------------------------

CUndoDeleteControl::CUndoDeleteControl(CSite * pSite)
    : CUndoUnitBase(pSite, IDS_UNDODELETE)
{
    TraceTag((tagUndo, "CUndoDeleteControl ctor"));

    _pDOBag = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::CUndoDeleteControl, public
//
//  Synopsis:   CUndoDeleteControl dtor
//
//----------------------------------------------------------------------------

CUndoDeleteControl::~CUndoDeleteControl()
{
    ReleaseInterface(_pDOBag);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::Init, public
//
//  Synopsis:   Initializes the undo object.
//
//  Arguments:  [parySiteDelete] -- Array of sites that are going to be
//                                  deleted.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoDeleteControl::Init(int c, CSite ** ppSite)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::Do, public
//
//  Synopsis:   Performes an undo of a control deletion.
//
//  Arguments:  [pUM] -- Pointer to undo manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoDeleteControl::Do(IOleUndoManager * pUM)
{
    HRESULT    hr;
    IStorage * pStg      = NULL;
    DWORD      dwCookie;
    CDoc *    pDoc = Site()->_pDoc;

    if (!pUM)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            goto Cleanup;
    }

//    hr = THR(GetcfPrivateFmt(_pDOBag, &pStg));
 //   if (hr)
  //      goto Cleanup;

    //
    // This puts a Redo action on the stack.
    //
    hr = S_OK;

    pDoc->OnControlInfoChanged();

    if (!pUM)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

    pDoc->UndoManager()->DiscardFrom(NULL);

Cleanup:
    ReleaseInterface(pStg);
    ClearInterface(&_pDOBag);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoNewControl Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoNewControl::CUndoNewControl, public
//
//  Synopsis:   CUndoNewControl ctor
//
//----------------------------------------------------------------------------

CUndoNewControl::CUndoNewControl(CSite * pSite, CSite * pSiteNew)
    : CUndoUnitBase(pSite->_pDoc, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoNewControl ctor"));

    _arySites.Append(pSiteNew);
}

CUndoNewControl::CUndoNewControl(CSite * pSite, int c, CSite ** ppSite)
    : CUndoUnitBase(pSite->_pDoc, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoNewControl ctor"));

    _arySites.CopyIndirect(c, ppSite, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoNewControl::Do, public
//
//  Synopsis:   Performs an undo of adding a new control. Deletes the control
//              that was added.
//
//----------------------------------------------------------------------------

HRESULT
CUndoNewControl::Do(IOleUndoManager * pUndoMgr)
{
    TraceTag((tagUndo, "CUndoNewControl::Do"));

    HRESULT     hr = S_OK;
    DWORD       dwCookie;
    CDoc *      pDoc = Site()->_pDoc;
    CDoc::CLock Lock(pDoc);

    if (!pUndoMgr)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            goto Cleanup;
    }

    //
    // Puts a redo action on the stack.
    //
    Site()->ShowLastErrorInfo(hr);

    if (!pUndoMgr)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoMove Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoMove::CUndoMove, public
//
//  Synopsis:   CUndoMove ctor
//
//----------------------------------------------------------------------------

CUndoMove::CUndoMove(CSite * pSite, RECT *prc, DWORD dwFlags)
    : CUndoUnitBase(pSite, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoMove ctor"));

    Assert(prc);

    _rc      = *prc;
    _dwFlags = dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoMove::Do, public
//
//  Synopsis:   Performs an undo of moving a control.
//
//----------------------------------------------------------------------------

HRESULT
CUndoMove::Do(IOleUndoManager * pUndoMgr)
{
    HRESULT      hr;
    DWORD        dwCookie;
    CDoc *         pDoc = Site()->_pDoc;
    CDoc::CLock Lock(pDoc);

    TraceTag((tagUndo, "CUndoMove::Do"));

    if (!pUndoMgr)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            RRETURN(hr);
    }

    //
    // This move should put a corresponding move action on the redo stack
    // unless we're blocking new actions.
    //
    hr = Site()->Move(&_rc, _dwFlags);
    Site()->ShowLastErrorInfo(hr);

    if (!pUndoMgr)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\krnldisp.cxx ===
//+---------------------------------------------------------------------
//
//  File:       krnldisp.cxx
//
//  Contents:   dispatch implemtation for form object
//
//  Classes:    CDoc (partial)
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

MtDefine(CDocBuildObjectTypeInfo_aryEntry_pv, Locals, "CDoc::BuildObjectTypeInfo aryEntry::_pv")

//---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureObjectTypeInfo
//
//
//---------------------------------------------------------------------------

HRESULT
CDoc::EnsureObjectTypeInfo()
{
    HRESULT     hr = S_OK;
    CCollectionCache *pCollectionCache;

    if (!_pTypInfo || !_pTypInfoCoClass)
    {
        hr = THR(PrimaryMarkup()->InitCollections());
        if (hr)
            goto Cleanup;

        pCollectionCache = PrimaryMarkup()->CollectionCache();

        hr = THR(BuildObjectTypeInfo(
            pCollectionCache,
            CMarkup::ELEMENT_COLLECTION,                                     // index of array in coll cache
            DISPID_COLLECTION_MIN,                                  // Min DISPID
            pCollectionCache->GetMinDISPID(CMarkup::WINDOW_COLLECTION) - 1, // Max DISPID
            &_pTypInfo,
            &_pTypInfoCoClass,
            TRUE));
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CDoc::BuildObjectTypeInfo
//
//  Synopsis:   Build a typeinfo from the objects that are
//              to be added to some namespace.
//
//  Arguments:  guidTLib        ???
//              guidTInfo       ???
//              pCollCache      The collection cache to use
//              lIndex          Index in the collection cache to use
//              dispidMin       Minimum dispid to put in the typeinfo
//              ppTI            Outgoing generated typeinfo
//              ppTICoClass     Outgoing generated coclass
//              pvObject        Object implementing validate function.
//              pfnValidate     Function to call for validation of element
//
//---------------------------------------------------------------------------

HRESULT
CDoc::BuildObjectTypeInfo(
    CCollectionCache *  pCollCache,
    long                lIndex,
    DISPID              dispidMin,
    DISPID              dispidMax,
    ITypeInfo **        ppTI,
    ITypeInfo **        ppTICoClass,
    BOOL                fDocument/* = FALSE*/)
{
    HRESULT             hr          = S_OK;
    FUNCDESC            funcdesc    = {0};
    TYPEDESC            tdescUser   = {0};
    long                index       = 0;
    long                i;
    BOOL                fAtomAssigned;
    CElement *          pElement;
    TCHAR *             pchName;
    CStr                cstrUniqueName;
    ITypeInfo *         pTypInfoElement = NULL;
    CDataAry<DISPID>    aryEntry(Mt(CDocBuildObjectTypeInfo_aryEntry_pv));
    BOOL                fDidCreate;

    CCreateTypeInfoHelper Helper;

    Assert ( dispidMin < dispidMax );

    //
    // start creating the typeinfo
    //

    hr = THR(Helper.Start(g_Zero.guid));
    if (hr)
        goto Cleanup;

    //
    // Set up the function descriptor we'll be using.
    //

    funcdesc.funckind = FUNC_DISPATCH;
    funcdesc.invkind = INVOKE_PROPERTYGET;
    funcdesc.callconv = CC_STDCALL;
    funcdesc.cScodes = -1;
    funcdesc.elemdescFunc.tdesc.vt = VT_PTR;
    funcdesc.elemdescFunc.tdesc.lptdesc = &tdescUser;
    tdescUser.vt = VT_USERDEFINED;
    funcdesc.wFuncFlags = FUNCFLAG_FSOURCE;

    //
    // ensure the array
    //

    if (!pCollCache)
    {
        hr = THR(PrimaryMarkup()->EnsureCollectionCache(lIndex));
        if (hr)
            goto Cleanup;
        pCollCache = PrimaryMarkup()->CollectionCache();
    }

    hr = THR(pCollCache->EnsureAry(lIndex));
    if (hr)
        goto Cleanup;

    //
    // Finally loop through all elements in specified collection,
    // creating typeinfos for those elements which pass the
    // validation criteria defined in the validate function.
    //

    // TODO: (anandra) This will forestall addition of controls whose ID
    // changes after this occurs.

    for (i = 0; i < pCollCache->SizeAry(lIndex); i++)
    {

        hr = THR(pCollCache->GetIntoAry(lIndex, i, &pElement));
        if (hr)
            goto Cleanup;
        Assert(pElement);

        // if we are being called on the DOCUMENT's collectionCachethen
        // we are using the ALL collecion and not the window_collection.
        //are we w/n the scope of a form just continue the loop
        if (fDocument &&  
            PrimaryMarkup()->InFormCollection(pElement->GetFirstBranch()))
        {
            continue;
        }

        //
        // Validate this element: calculate name for type info
        //

        if (ETAG_INPUT == pElement->Tag()
            && DYNCAST(CInput, pElement)->GetType() == htmlInputRadio)
        {
            // radio buttons case - get id (can not be be accessed by name) 
            pchName = (TCHAR *) pElement->GetAAid();
        }
        else
        {
            // The forms have been moved to the window collection as a result
            // we don't want the form names to be sinked up twice once for the
            // AddNamedItem done in Init2 of CFormElement and then again when
            // drilling through the dynamic typelib.  If not form for window
            // then the main case -- get id or name.
            pchName = (fDocument && lIndex == CMarkup::ELEMENT_COLLECTION && pElement->Tag() == ETAG_FORM) ?
                        NULL : (TCHAR *) pElement->GetIdentifier();
        }

        fAtomAssigned = FALSE;


        if (pchName)
        {
            // if name is already present in atom table, this call will return index
            // of the name in table
            hr = THR_NOTRACE(_AtomTable.AddNameToAtomTable(pchName, &funcdesc.memid));
            if (hr)
                goto Cleanup;

            if (-1 == aryEntry.FindIndirect(&funcdesc.memid))
            {
                //
                // the id/name does not conflict with any other name
                //
                fAtomAssigned = TRUE;
            }
            else
            {
                //
                // name conflict; have to use unique name
                //
                hr = THR(pElement->GetUniqueIdentifier(&cstrUniqueName, TRUE, &fDidCreate ));
                if (hr)
                    goto Cleanup;

                pchName = (TCHAR*) cstrUniqueName;

                // Need to rebuild the WINDOW_COLLECTION, when added a unique name.
                // Do not use the passed in Collection Cache, it may not be the right one
                if ( fDidCreate )
                {
                    Assert(PrimaryMarkup());
                    Assert(PrimaryMarkup()->CollectionCache());
                    PrimaryMarkup()->CollectionCache()->InvalidateItem (CMarkup::WINDOW_COLLECTION );
                }
            }
        }

        // add VBScript scriptlets, if there are any.
        // if (NULL == pchName && (there is a scriptlet to add)) this call will
        // create a unique identifier
        hr = THR(pElement->AddAllScriptlets (pchName));
        if (hr)
            goto Cleanup;

        if (!pchName)
        {
            pchName = (TCHAR*) pElement->GetAAuniqueName();
        }

        if (!pchName || !*pchName)
            continue;

        // Add this element to the atom table of the doc

        if (!fAtomAssigned) 
        {
            hr = THR(_AtomTable.AddNameToAtomTable(pchName, &funcdesc.memid));
            if (hr)
                goto Cleanup;
        }

        // at this point it should not be possible to have id conflicts
        Assert (-1 == aryEntry.FindIndirect(&funcdesc.memid));

        hr = THR(aryEntry.AppendIndirect(&funcdesc.memid));
        if (hr)
            goto Cleanup;

        // The ID'd items here are resolved alongside the regular window collection items
        // The difference here is that the collection needs to return just the first
        // item whose name matches.
        funcdesc.memid += dispidMin;


        // Detect too many items - this is a seriously unlikely event !!
        if ( dispidMax <= funcdesc.memid)
            break;

        //
        // If we're here then it's ok for this element to create an
        // entry in the typelibrary for this element.
        //

        hr = THR(pElement->GetClassInfo(&pTypInfoElement));
        if (hr)
            goto Cleanup;

        hr = THR(Helper.pTypInfoCreate->AddRefTypeInfo(
            pTypInfoElement,
            &tdescUser.hreftype));
        if (hr)
            goto Cleanup;

        hr = THR(Helper.pTypInfoCreate->AddFuncDesc(index, &funcdesc));
        if (hr)
            goto Cleanup;

        LPTSTR ncpch = const_cast <LPTSTR> (pchName);
        hr = THR(Helper.pTypInfoCreate->SetFuncAndParamNames(
            index,
            &ncpch,
            1));
        if (hr)
            goto Cleanup;

        ClearInterface(&pTypInfoElement);
        index++;
    } // eo for (i = 0; i < pCollCache->SizeAry(lIndex); i++)

    //
    // finalize creating the typeinfo
    //

    hr = THR(Helper.Finalize(IMPLTYPEFLAG_FDEFAULT));
    if (hr)
        goto Cleanup;

    ReplaceInterface (ppTI, Helper.pTIOut);
    ReplaceInterface (ppTICoClass, Helper.pTICoClassOut);

Cleanup:
    aryEntry.DeleteAll();
    ReleaseInterface(pTypInfoElement);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\htc.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       htc.cxx
//
//  Classes:    CHtmlComponent, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#define _cxx_
#include "htc.hdl"

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

DeclareTag(tagHtcConstructorRequestMarkup,  "HTC", "trace requesting markup in HTC constructor")

DeclareTag(tagHtcTags,                      "HTC", "trace HTC tags (CHtmlComponentBase::Notify, documentReady)")
DeclareTag(tagHtcOnLoadStatus,              "HTC", "trace CHtmlComponent::OnLoadStatus")
DeclareTag(tagHtcInitPassivate,             "HTC", "trace CHtmlComponent::[Init|Passivate]")
DeclareTag(tagHtcDelete,                    "HTC", "trace CHtmlComponent::~CHtmlComponent")
DeclareTag(tagHtcPropertyEnsureHtmlLoad,    "HTC", "trace CHtmlComponentProperty::EnsureHtmlLoad")
DeclareTag(tagHtcAttachFireEvent,           "HTC", "trace CHtmlComponentAttach::fireEvent")

DeclareTag(tagHtcNeverSynchronous,          "HTC", "never create synchronously")
DeclareTag(tagHtcNeverShareMarkup,          "HTC", "never share markups")

extern const CLSID CLSID_CHtmlComponent;

const CLSID CLSID_CHtmlComponentConstructorFactory = {0x3050f4f8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};
const CLSID CLSID_CHtmlComponent                   = {0x3050f4fa, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};
const CLSID CLSID_CHtmlComponentBase               = {0x3050f5f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};

MtDefine(CHtmlComponentConstructor,                     Behaviors,                  "CHtmlComponentConstructor")
MtDefine(CHtmlComponentBase,                            Behaviors,                  "CHtmlComponentBase")
MtDefine(CHtmlComponent,                                Behaviors,                  "CHtmlComponent")
MtDefine(CHtmlComponentDD,                              Behaviors,                  "CHtmlComponentDD")
MtDefine(CHtmlComponentProperty,                        Behaviors,                  "CHtmlComponentProperty")
MtDefine(CHtmlComponentMethod,                          Behaviors,                  "CHtmlComponentMethod")
MtDefine(CHtmlComponentEvent,                           Behaviors,                  "CHtmlComponentEvent")
MtDefine(CHtmlComponentAttach,                          Behaviors,                  "CHtmlComponentAttach")
MtDefine(CHtmlComponentDesc,                            Behaviors,                  "CHtmlComponentDesc")
MtDefine(CHtmlComponentDefaults,                        Behaviors,                  "CHtmlComponentDefaults")

MtDefine(CHtmlComponentPropertyAgent,                   CHtmlComponentProperty,     "CHtmlComponentPropertyAgent")
MtDefine(CHtmlComponentEventAgent,                      CHtmlComponentEvent,        "CHtmlComponentEventAgent")
MtDefine(CHtmlComponentAttachAgent,                     CHtmlComponentAttach,       "CHtmlComponentAttachAgent")

MtDefine(CHtmlComponent_aryAgents,                      CHtmlComponent,             "CHtmlComponent::_aryAgents")

MtDefine(CHtmlComponentConstructor_aryRequestMarkup,    CHtmlComponentConstructor,  "CHtmlComponentConstructor::_aryRequestMarkup")

MtDefine(CProfferService_CItemsArray,                   Behaviors,                  "CProfferService::CItemsArray")

BEGIN_TEAROFF_TABLE(CHtmlComponent, IServiceProvider)
    TEAROFF_METHOD(CHtmlComponent, QueryService, queryservice, (REFGUID rguidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CHtmlComponent, IPersistPropertyBag2)
    TEAROFF_METHOD(CHtmlComponent, GetClassID,   getclassid, (CLSID *pClassID))
    TEAROFF_METHOD(CHtmlComponent, InitNew,      initnew,    ())
    TEAROFF_METHOD(CHtmlComponent, Load,         load,       (IPropertyBag2 * pPropBag, IErrorLog * pErrLog))
    TEAROFF_METHOD(CHtmlComponent, Save,         save,       (IPropertyBag2 * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties))
    TEAROFF_METHOD(CHtmlComponent, IsDirty,      isdirty,    ())
END_TEAROFF_TABLE()

const CBase::CLASSDESC CHtmlComponentConstructor::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentBase::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponent::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    CHtmlComponent::s_acpi,         // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CONNECTION_POINT_INFO CHtmlComponent::s_acpi[] = {
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CHtmlComponentDD::s_classdesc =
{
    &CLSID_HTCDefaultDispatch,      // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCDefaultDispatch,       // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentProperty::s_classdesc =
{
    &CLSID_HTCPropertyBehavior,     // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCPropertyBehavior,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentMethod::s_classdesc =
{
    &CLSID_HTCMethodBehavior,       // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCMethodBehavior,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentEvent::s_classdesc =
{
    &CLSID_HTCEventBehavior,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCEventBehavior,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentAttach::s_classdesc =
{
    &CLSID_HTCAttachBehavior,       // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCAttachBehavior,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentDesc::s_classdesc =
{
    &CLSID_HTCDescBehavior,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCDescBehavior,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentDefaults::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

///////////////////////////////////////////////////////////////////////////
//
// misc helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Function:   HasExpando
//
//-------------------------------------------------------------------------

BOOL
HasExpando (CElement * pElement, LPTSTR pchName)
{
    HRESULT hr;
    DISPID  dispid;
    hr = THR_NOTRACE(pElement->GetExpandoDispID(pchName, &dispid, 0));
    return S_OK == hr ? TRUE : FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   HasExpandos
//
//-------------------------------------------------------------------------

BOOL
HasExpandos (CElement * pElement)
{
    CAttrValue *  pav = NULL;
    CAttrArray ** ppaa = NULL;

    ppaa = pElement->GetAttrArray();
    pav = (*ppaa)->Find(DISPID_UNKNOWN, CAttrValue::AA_Expando);

    return !!pav;
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoStringHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//                  *ppch will be set to NULL
//              S_OK if it does
//                  *ppch will be set to value (can be NULL)
//
//-------------------------------------------------------------------------

HRESULT GetExpandoStringHr( CElement * pElement, LPTSTR pchName, LPTSTR * ppch )
{
    HRESULT         hr          = S_OK;
    DISPID          dispid;
    CAttrArray *    pAA;

    Assert( pElement && pchName && ppch );
    *ppch = NULL;

    hr = THR_NOTRACE( pElement->GetExpandoDispID( pchName, &dispid, 0 ) );
    if( hr )
        goto Cleanup;

    pAA = *(pElement->GetAttrArray());
    Assert( pAA );

    pAA->FindString(dispid, (LPCTSTR *)ppch, CAttrValue::AA_Expando);

Cleanup:
    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoBoolHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//
//-------------------------------------------------------------------------

HRESULT
GetExpandoBoolHr (CElement * pElement, LPTSTR pchName, BOOL * pf)
{
    HRESULT      hr = S_FALSE;
    LPTSTR       pchValue;

    Assert (pf);

    *pf = FALSE;
    hr = THR_NOTRACE( GetExpandoStringHr( pElement, pchName, &pchValue ) );
    if( hr )
        goto Cleanup;

    *pf = StringToBool( pchValue );

Cleanup:

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoBool
//
//-------------------------------------------------------------------------

BOOL
GetExpandoBool(CElement * pElement, LPTSTR pchName)
{
    HRESULT hr2;
    BOOL    fResult;

    hr2 = THR_NOTRACE(GetExpandoBoolHr(pElement, pchName, &fResult));
    if (S_OK == hr2)
    {
        return fResult;
    }
    else
    {
        return FALSE;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoLongHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//
//-------------------------------------------------------------------------

HRESULT
GetExpandoLongHr (CElement * pElement, LPTSTR pchName, long * pl)
{
    HRESULT      hr = S_FALSE;
    long         lReturn = 0;
    LPTSTR       pchValue = NULL;

    hr = THR_NOTRACE(GetExpandoStringHr( pElement, pchName, &pchValue ));
    if( hr )
        goto Cleanup;

    lReturn = _ttol(pchValue);

Cleanup:
    *pl = lReturn;

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   HTCPreloadTokenizerFilter
//
//-------------------------------------------------------------------------

BOOL
HTCPreloadTokenizerFilter(LPTSTR pchNamespace, LPTSTR pchTagName, CHtmTag * pht)
{
    switch (pht->GetTag())
    {
    case ETAG_SCRIPT:
        return TRUE;

    case ETAG_GENERIC_BUILTIN:

        // NOTE (alexz) this is a fragile but perf-reasonable way to do it: currently, all tags with etag
        // ETAG_GENERIC_BUILTIN are allowed in preloaded instances of HTCs. When this becomes not the case,
        // we will have to use pchTagName to figure how to filter the tag.
        // (this is when the following assert will fire)

        // aware only of these tags to have ETAG_GENERIC_BUILTIN
        Assert (0 == StrCmpIC(_T("HTC"),        pchTagName) ||
                0 == StrCmpIC(_T("COMPONENT"),  pchTagName) ||
                0 == StrCmpIC(_T("PROPERTY"),   pchTagName) ||
                0 == StrCmpIC(_T("METHOD"),     pchTagName) ||
                0 == StrCmpIC(_T("EVENT"),      pchTagName) ||
                0 == StrCmpIC(_T("ATTACH"),     pchTagName) ||
                0 == StrCmpIC(_T("DEFAULTS"),   pchTagName) ||
                0 == StrCmpIC(_T("PUT"),        pchTagName) ||
                0 == StrCmpIC(_T("GET"),        pchTagName));

        return TRUE;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Functions:   notification mappings
//
// CONSIDER     (alexz) using hash tables for this
//
//-------------------------------------------------------------------------

class CNotifications
{
public:

    //
    // data definitions
    //

    class CItem
    {
    public:
        LPTSTR          _pchName;
        LONG            _lEvent;
        DISPID          _dispidInternal;

    };

    static const CItem s_ary[];

    //
    // methods
    //

    static CItem const * Find(LPTSTR pch)
    {
        CItem const * pItem;
        for (pItem = s_ary; pItem->_pchName; pItem++)
        {
            if (0 == StrCmpIC(pItem->_pchName, pch))
                return pItem;
        }
        return NULL;
    };
};

const CNotifications::CItem CNotifications::s_ary[] =
{
    {   _T("onContentReady"),       BEHAVIOREVENT_CONTENTREADY,     DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY     },
    {   _T("onDocumentReady"),      BEHAVIOREVENT_DOCUMENTREADY,    DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY    },
    {   _T("onDetach"),             -1,                             -1                                          },
    {   _T("onApplyStyle"),         BEHAVIOREVENT_APPLYSTYLE,       DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       },
    {   _T("onContentSave"),        BEHAVIOREVENT_CONTENTSAVE,      DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE      },
    {   NULL,                       -1,                             -1                                          }
};

//+------------------------------------------------------------------------
//
//  Function:   TagNameToHtcBehaviorType
//
//-------------------------------------------------------------------------

HTC_BEHAVIOR_TYPE
TagNameToHtcBehaviorType(LPCTSTR pchTagName)
{
    // NOTE(sramani): We can make use of the fact that each builtin type starts with
    // a diffent letter to our advantage, by comparing only the first letters of the 
    // generic element's tagName, as the parser enforces the correct tagname only for 
    // these ETAG_GENERIC_BUILTINs. We do the entire string compare in debug for sanity check.

    switch (*pchTagName)
    {
    case _T('P') :
    case _T('p') : 
        if (0 == StrCmpIC(pchTagName, _T("put")))
            return HTC_BEHAVIOR_NONE;
        else
        {
            Assert(0 == StrCmpIC(pchTagName, _T("property")));
            return HTC_BEHAVIOR_PROPERTY;    // property
        }

    case _T('M') :
    case _T('m') :
        Assert(0 == StrCmpIC(pchTagName, _T("method")));
        return HTC_BEHAVIOR_METHOD;      // method
    
    case _T('E') :
    case _T('e') : 
        Assert(0 == StrCmpIC(pchTagName, _T("event")));
        return HTC_BEHAVIOR_EVENT;       // event
    
    case _T('A') :
    case _T('a') :
        Assert(0 == StrCmpIC(pchTagName, _T("attach")));
        return HTC_BEHAVIOR_ATTACH;      // attach
    
    case _T('H') :
    case _T('h') :
        Assert(0 == StrCmpIC(pchTagName, _T("htc")));
        return HTC_BEHAVIOR_DESC;        // htc
    
    case _T('C') :
    case _T('c') :
        Assert(0 == StrCmpIC(pchTagName, _T("component")));
        return HTC_BEHAVIOR_DESC;        // component

    case _T('D') :
    case _T('d') :
        Assert(0 == StrCmpIC(pchTagName, _T("defaults")));
        return HTC_BEHAVIOR_DEFAULTS;    // defaults

    default  :
        return HTC_BEHAVIOR_NONE;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetHtcFromElement
//
//  Note:   Theoretically, the cleanest way to do this is to QI element for
//          CLSID_CHtmlComponentBase. However, this will be doing thunking so
//          returned pointer is required to be strong ref. But we want the 
//          pointer to be weak ref to keep the code cleaner in HTCs.
//
//-------------------------------------------------------------------------

CHtmlComponentBase *
GetHtcFromElement(CElement * pElement)
{
    HRESULT                 hr2;
    CHtmlComponentBase *    pBehavior;

    //
    // ideal way; pBehavior has to be strong ref.
    // pElement->QueryInterface(CLSID_CHtmlComponentBase, (void**)&pBehavior);
    //

    //
    // practical way; pBehavior is weak ref
    //

    CPeerHolder * pPeerHolder = pElement->GetIdentityPeerHolder();

    if (pPeerHolder)
    {
        hr2 = THR_NOTRACE(pPeerHolder->QueryPeerInterface(CLSID_CHtmlComponentBase, (void**)&pBehavior));
        if (hr2)
        {
            pBehavior = NULL;
        }
        else
        {
            Assert (pBehavior);
        }
    }
    else
    {
        pBehavior = NULL;
    }

    return pBehavior;
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDummy and g_HtmlComponentDummy
//
//  Synopsis:   class, instance of which is created one per mshtml process.
//              It serves as totally empty behavior. It allows us to avoid any 
//              special-casing for HTC behaviors that don't do anything,
//              such as property <PUT> or <GET>.
//
///////////////////////////////////////////////////////////////////////////

class CHtmlComponentDummy : public IElementBehavior
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)
    {
        if (IsEqualGUID(IID_IUnknown,         riid) ||
            IsEqualGUID(IID_IElementBehavior, riid))
        {
            *ppv = this;
            return S_OK;
        }
        else
        {
            RRETURN (E_NOINTERFACE);
        }
    }
    STDMETHOD_(ULONG, AddRef)()  { return 0; }
    STDMETHOD_(ULONG, Release)() { return 0; };

    STDMETHOD(Init)(IElementBehaviorSite * pSite)  { return S_OK; };
    STDMETHOD(Notify)(LONG lEvent, VARIANT * pVar) { return S_OK; };
    STDMETHOD(Detach)()                            { return S_OK; };

};

static CHtmlComponentDummy g_HtmlComponentDummy;

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentConstructor wiring
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Aux Class:   CHtmlComponentConstructorFactory
//
//-------------------------------------------------------------------------

class CHtmlComponentConstructorFactory : public CStaticCF
{
public:
    DECLARE_CLASS_TYPES(CHtmlComponentConstructorFactory, CStaticCF)

    CHtmlComponentConstructorFactory (FNCREATE * pfnCreate) : CStaticCF(pfnCreate) {};

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID * ppv)
    {
        if (IsEqualGUID(CLSID_CHtmlComponentConstructorFactory, iid))
        {
            *ppv = this; // weak ref
            RRETURN (S_OK);
        }
        else
        {
            RRETURN (super::QueryInterface(iid, ppv));
        }
    }
};

//+------------------------------------------------------------------------
//
//  Function:   CreateHtmlComponentConstructor
//
//-------------------------------------------------------------------------

HRESULT
CreateHtmlComponentConstructor(IUnknown * pUnkOuter, IUnknown ** ppUnk)
{
    HRESULT                     hr = S_OK;
    CHtmlComponentConstructor * pConstructor;

    if (!ppUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppUnk = NULL;

    if (pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto Cleanup;
    }

    pConstructor = new CHtmlComponentConstructor();
    if (!pConstructor)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppUnk = (IUnknown*)(IClassFactory*)pConstructor;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Global:   g_cfHtmlComponentConstructorFactory
//
//-------------------------------------------------------------------------

CHtmlComponentConstructorFactory g_cfHtmlComponentConstructorFactory (CreateHtmlComponentConstructor);

//+------------------------------------------------------------------------
//
//  Function:   HtcPrivateExec
//
//  Synopsis:   internal wiring to allow HTC do a couple of private things:
//              -   let constructor figure out if it needs to attempt to load
//                  HTC synchronously;
//              -   request parser to hold parsing while HTC is loading
//
//-------------------------------------------------------------------------

HRESULT
HtcPrivateExec(CHtmlComponent * pComponent, BOOL * pfSync)
{
    HRESULT             hr = S_OK;
    VARIANT             varSync;
    IServiceProvider *  pServiceProvider = NULL;
    IOleCommandTarget * pCommandTarget = NULL;

    Assert (pfSync);
    Assert (pComponent->_pSite);

    hr = pComponent->_pSite->QueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
    if (hr)
        goto Cleanup;

    hr = pServiceProvider->QueryService(SID_SElementBehaviorMisc, IID_IOleCommandTarget, (void**)&pCommandTarget);
    if (hr)
        goto Cleanup;

    hr = pCommandTarget->Exec(
            &CGID_ElementBehaviorMisc, CMDID_ELEMENTBEHAVIORMISC_ISSYNCHRONOUSBEHAVIOR, 0, NULL, &varSync);
    if (hr)
        goto Cleanup;

    Assert (VT_I4 == V_VT(&varSync));

    *pfSync = (0 != V_I4(&varSync));

    hr = pCommandTarget->Exec(
            &CGID_ElementBehaviorMisc, CMDID_ELEMENTBEHAVIORMISC_REQUESTBLOCKPARSERWHILEINCOMPLETE, 0, NULL, NULL);

Cleanup:
    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pCommandTarget);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentConstructor
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor constructor
//
//-------------------------------------------------------------------------

CHtmlComponentConstructor::CHtmlComponentConstructor()
{
    _idxRequestMarkup = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponentConstructor::Passivate()
{
    int                 c;
    CHtmlComponent **   ppComponent;

    AssertSz(0 == _cComponents, "Attempt to passivate HTC factory before all HTC instances have been passivated; this will cause serious bugs");

    FormsFreeString(_bstrTagName);
#if 0
    FormsFreeString(_bstrBaseTagName);
#endif

    for (ppComponent = &(_aryRequestMarkup[_idxRequestMarkup + 1]), c = _aryRequestMarkup.Size() - ( _idxRequestMarkup + 1 ); c; ppComponent++, c--)
    {
        (*ppComponent)->SubRelease();
    }
    _aryRequestMarkup.DeleteAll();
    _idxRequestMarkup = -1;
    _fRequestMarkupNext = FALSE;

    if (_pFactoryComponent)
    {
        _pFactoryComponent->PrivateRelease();
        _pFactoryComponent = NULL;
    }

    ClearInterface(&_pMoniker);

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IClassFactory*)this, IUnknown)
    QI_INHERITS(this, IPersistMoniker)
    QI_INHERITS(this, IClassFactory)
    QI_INHERITS(this, IElementBehaviorFactory)
    QI_INHERITS(this, IElementNamespaceFactory)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        // this violates object identity rules, but:
        // (1) this will only happen if _pFactoryComponent is set, and this can only happen when interacting with mshtml;
        // (2) with IConnectionPointContainer this is kinda typical anyway;
        if (_pFactoryComponent &&
            (IsEqualGUID(IID_IConnectionPointContainer, iid) ||
             IsEqualGUID(IID_IDispatchEx, iid)))
        {
            RRETURN(_pFactoryComponent->PrivateQueryInterface(iid, ppv));
        }

        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+---------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LockServer, per IClassFactory
//
//----------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LockServer (BOOL fLock)
{
    if (fLock)
        IncrementSecondaryObjectCount(4);
    else
        DecrementSecondaryObjectCount(4);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, per IPersistMoniker
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::Load(
    BOOL        fFullyAvailable,
    IMoniker *  pMoniker,
    IBindCtx *  pBindCtx,
    DWORD       grfMode)
{
    HRESULT     hr = S_OK;

    _pMoniker = pMoniker;
    _pMoniker->AddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::FindBehavior, per IElementBehaviorFactory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::FindBehavior(
    BSTR                    bstrName,
    BSTR                    bstrUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT             hr = S_OK;
    CHtmlComponent *    pComponent = NULL;

    hr = THR(EnsureFactoryComponent(pSite));
    if (hr)
        goto Cleanup;

    Assert (_pFactoryComponent);

    //
    // allowed to create the HTC?
    //

    if (!_fSupportsEditMode && _pFactoryComponent->_pDoc->DesignMode())
    {
        // the HTC does not support edit mode, and the doc is in design mode - fail the instantiation
        hr = E_FAIL;
        goto Cleanup;
    }


    //
    // create and init CHtmlComponent
    //

    pComponent = new CHtmlComponent(this);
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pComponent->InitHelper(pSite));
    if (hr)
        goto Cleanup;

    if (pComponent->IsRecursiveUrl(bstrUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // get IElementBehavior interface
    //

    hr = THR(pComponent->PrivateQueryInterface(IID_IElementBehavior, (void**)ppBehavior));

Cleanup:
    if (pComponent)
        pComponent->PrivateRelease();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::EnsureFactoryComponent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::EnsureFactoryComponent(IUnknown * punkContext)
{
    if (_pFactoryComponent)
        return S_OK;

    HRESULT             hr = S_OK;
    IServiceProvider *  pServiceProvider = NULL;
    CDoc *              pDoc;

    //
    // get moniker and doc
    //

    hr = THR(punkContext->QueryInterface(IID_IServiceProvider, (void**)&pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(CLSID_HTMLDocument, CLSID_HTMLDocument, (void**) &pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(CLSID_CMarkup, CLSID_CMarkup, (void **) &_pMarkup ));
    if( hr )
        goto Cleanup;

    //
    // create and init reference CHtmlComponent
    //

    _pFactoryComponent = new CHtmlComponent(this, /* fFactoryComponent =*/TRUE);
    if (!_pFactoryComponent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_pFactoryComponent->Init(pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(RequestMarkup(_pFactoryComponent));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pServiceProvider);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::Create, per IElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::Create(IElementNamespace * pNamespace)
{
    HRESULT      hr = S_OK;
    DWORD        dwFlags = 0;

    if (!pNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureFactoryComponent(/*punkContext =*/pNamespace));
    if (hr)
        goto Cleanup;

    Assert (_pFactoryComponent);

    if (_pFactoryComponent->GetReadyState() < READYSTATE_COMPLETE)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    if (_bstrTagName)
    {
#if 0
        if( _bstrBaseTagName )
        {
            HRESULT hr2;
            IElementNamespacePrivate * pNSPrivate = NULL;

            hr2 = THR( pNamespace->QueryInterface( IID_IElementNamespacePrivate, (void **)&pNSPrivate ) );
            if( hr2 )
                goto TestCleanup;

            hr2 = THR( pNSPrivate->AddTagPrivate( _bstrTagName, _bstrBaseTagName, _fLiteral ) );
            if( hr2 )
                goto TestCleanup;
            
TestCleanup:
            ClearInterface( &pNSPrivate );
            goto Cleanup;
        }
        else
#endif // Test code for derived element behaviors
        {
            Assert( !_fLiteral || !_fNested );
            if( _fLiteral )
            {
                dwFlags = ELEMENTDESCRIPTORFLAGS_LITERAL;
            }
            else if( _fNested )
            {
                dwFlags = ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL;
            }
            hr = THR(pNamespace->AddTag(_bstrTagName, dwFlags));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::IsFactoryMarkupReady, helper
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponentConstructor::IsFactoryMarkupReady()
{
    return _pFactoryComponent &&
           _pFactoryComponent->_pMarkup &&
           _pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkupAsynchronously, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkupAsynchronously(CHtmlComponent * pComponent)
{
    HRESULT hr;

    hr = THR(pComponent->Load(_pMoniker));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkupSynchronously, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkupSynchronously(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    IStream *   pStream = NULL;
    TCHAR *     pchUrl = NULL;

    Assert (    _fDownloadStream          // Either we have to do a synchronous download, or
            ||  (   IsFactoryMarkupReady()                  // We have a valid factory markup to use
                 && _pFactoryComponent->_pMarkup->HtmCtx() ) );

    if( !_fDownloadStream && _pFactoryComponent->_pMarkup->HtmCtx()->HasCachedFile())
    {
        Assert( _pFactoryComponent->_pMarkup->HtmCtx() );

        hr = THR(_pFactoryComponent->_pMarkup->HtmCtx()->GetStream(&pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( _pMoniker->GetDisplayName( NULL, NULL, &pchUrl ) );
        if( hr )
            goto Cleanup;

        hr = THR( URLOpenBlockingStreamW( NULL, pchUrl, &pStream, 0, NULL ) );
        if( hr )
            goto Cleanup;
    }

    hr = THR(pComponent->Load(pStream));
    if( hr )
        goto Cleanup;

Cleanup:
    CoTaskMemFree( pchUrl );
    ReleaseInterface( pStream );
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkup(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    BOOL        fSync = FALSE;
 
    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::LoadMarkup     [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    Assert (-1 == _idxRequestMarkup ||
            0 == _aryRequestMarkup.Size() ||
            pComponent == _aryRequestMarkup[_idxRequestMarkup]);

    _fRequestMarkupLock = TRUE;

    if (_fSharedMarkup)
    {
        Assert (IsFactoryMarkupReady());

        hr = THR(pComponent->ToSharedMarkupMode( _pMarkup->Doc()->_fSyncParsing));
        goto Cleanup; // done
    }

    // There can be times where we require that the factory component be
    // created synchronously, for example innerHTML-ing in an ?IMPORT PI.
    // In this case, we have to do a synchronous download of the URL to
    // a stream.  The other, more normal case for doing a synchronous load,
    // though, is just that we need to create an element behavior synchronously
    // and load from the existing stream.  Note that if the factory component
    // is downloaded synchronously, we have to use that for all subsequent
    // components because we can't get a stream from the markup.
    if (IsFactoryMarkupReady() )
    {
        hr = THR(HtcPrivateExec(pComponent, &fSync));
        if (hr)
            goto Cleanup;

#if DBG == 1
        // reset fSync if the NeverSynchronous tag is enabled
        if (IsTagEnabled(tagHtcNeverSynchronous))
            fSync = FALSE;
#endif
    }
    else if( pComponent->_fFactoryComponent )
    {
        _fDownloadStream = fSync = _pMarkup->HtmCtx() && _pMarkup->HtmCtx()->IsSyncParsing();
    }

    if (fSync)
    {
        hr = THR(LoadMarkupSynchronously(pComponent));
    }
    else
    {
        hr = THR(LoadMarkupAsynchronously(pComponent));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::RequestMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::RequestMarkup(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;

    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::RequestMarkup  [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    if (!_fRequestMarkupLock)
    {
        hr = THR(LoadMarkup(pComponent));
    }
    else
    {
        pComponent->SubAddRef();

        hr = THR(_aryRequestMarkup.Append (pComponent));

        _fRequestMarkupNext = TRUE;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::OnMarkupLoaded, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::OnMarkupLoaded(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;

    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::OnMarkupLoaded [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    Assert (pComponent);

    Assert (-1 == _idxRequestMarkup ||
            0 == _aryRequestMarkup.Size() ||
            pComponent == _aryRequestMarkup[_idxRequestMarkup]);

    Assert (_fRequestMarkupLock);

    _fRequestMarkupLock = FALSE;

    if (_fLoadMarkupLock)
    {
        // Assert (CHtmlComponentConstructor::OnMarkupLoaded is somewhere above on the call stack)
        _fRequestMarkupNext = TRUE;
        goto Cleanup; // out
    }

    _fLoadMarkupLock = TRUE;

    if (pComponent->_fFactoryComponent &&
        !pComponent->IsPassivating() &&
        !pComponent->IsPassivated())
    {
        hr = THR(OnFactoryMarkupLoaded());
        if (hr)
            goto Cleanup;
    }

    do
    {
        _fRequestMarkupNext = FALSE;
 
        if (_aryRequestMarkup.Size() - 1 <= _idxRequestMarkup)
        {
            _aryRequestMarkup.DeleteAll();
            _idxRequestMarkup = -1;
        }
        else
        {
            _idxRequestMarkup++;
            pComponent = _aryRequestMarkup[_idxRequestMarkup];

            if (!pComponent->IsPassivated())
            {
                // Failure is legit here
                IGNORE_HR(LoadMarkup(pComponent));
            }
            else
            {
                _fRequestMarkupNext = TRUE;
            }

            pComponent->SubRelease();
        }
    } while (_fRequestMarkupNext);

    Assert (_fLoadMarkupLock);
    _fLoadMarkupLock = FALSE;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::OnFactoryMarkupLoaded, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::OnFactoryMarkupLoaded()
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    CElement *  pElement;
    LPTSTR     pch;

    Assert (_pFactoryComponent &&
            _pFactoryComponent->_pMarkup &&
            _pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE);

    hr = _pFactoryComponent->GetElement((LONG*)NULL, &pElement, HTC_BEHAVIOR_DESC);
    if (hr || !pElement)
        goto Cleanup;

    //
    // get the tag name
    //

    pch = GetExpandoString(pElement, _T("tagName"));
    if (!pch)
    {
        pch = GetExpandoString(pElement, _T("name"));
    }
    if (pch)
    {
        hr = THR(FormsAllocString(pch, &_bstrTagName));
        if (hr)
            goto Cleanup;
    }

    //
    // get the base tag name
    //
#if 0
    pch = GetExpandoString(pElement, _T("__MS__baseTagName"));
    if (pch)
    {
        hr = THR(FormsAllocString(pch, &_bstrBaseTagName));
        if (hr)
            goto Cleanup;
    }
#endif 

    //
    // lightweight HTC? literal? supportsEditMode?
    //

    _fSharedMarkup      = _pFactoryComponent->_fLightWeight;
    _fSupportsEditMode  = GetExpandoBool(pElement, _T("supportsEditMode"));
    hr2 = THR_NOTRACE( GetExpandoStringHr( pElement, _T("literalContent"), &pch ) );
    if( S_OK == hr2 )
    {
        _fLiteral = StringToBool( pch );    // Normal literal?
        if( !_fLiteral )
            _fNested = !StrCmpIC( pch, _T("nested") ); // No - see if it's nested
    }

#if DBG == 1
    if (IsTagEnabled(tagHtcNeverShareMarkup))
    {
        _fSharedMarkup = FALSE;
    }
#endif

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAgentBase
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::CHtmlComponentAgentBase
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase::CHtmlComponentAgentBase(CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
{
    _ulRefs = 1;

    Assert (pClient && pClient->_pElement);

    _pComponent = pComponent;
    if (_pComponent)
    {
        _pComponent->SubAddRef();
    }

    _pClient = pClient;
    _pClient->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::~CHtmlComponentAgentBase
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase::~CHtmlComponentAgentBase()
{
    if (_pComponent)
    {
        _pComponent->SubRelease();
    }
    _pClient->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::QueryInterface(REFIID iid, void ** ppv)
{

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDispatch)
    QI_INHERITS(this, IDispatchEx)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    if (_pClient->_pElement)
    {
        hr = THR_NOTRACE(_pClient->_pElement->GetDispID(bstrName, grfdex, pdispid));
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT     hr;

    if (_pClient->_pElement)
    {
        hr = THR_NOTRACE(_pClient->_pElement->InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::GetNameSpaceParent, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::GetNameSpaceParent(IUnknown ** ppunk)
{
    HRESULT     hr;

    hr = THR(_pComponent->_DD.PrivateQueryInterface(IID_IDispatchEx, (void**)ppunk));

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentBase
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::CHtmlComponentBase
//
//-------------------------------------------------------------------------

CHtmlComponentBase::CHtmlComponentBase()
{
    _idxAgent = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentBase::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_INHERITS(this, IElementBehavior)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    if (IsEqualGUID(iid, CLSID_CHtmlComponentBase))
    {
        *ppv = this;    // weak ref
        return S_OK;
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponentBase::Passivate()
{
    // do not do ClearInterface (&_pComponent)

    _pElement = NULL;   // Weak ref

    ClearInterface (&_pSite);

    if (_pAgentWhenStandalone)
    {
        _pAgentWhenStandalone->Release();
        _pAgentWhenStandalone = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Init(IElementBehaviorSite * pSite)
{
    HRESULT             hr;
    IHTMLElement *      pHtmlElement = NULL;
    IServiceProvider *  pSP = NULL;

    //
    // get _pSite
    //

    _pSite = pSite;
    _pSite->AddRef();

    //
    // get _pElement
    //

    hr = THR(_pSite->GetElement(&pHtmlElement));
    if (hr)
        goto Cleanup;

    hr = THR(pHtmlElement->QueryInterface(CLSID_CElement, (void**)&_pElement));
    if (hr)
        goto Cleanup;

    Assert (_pElement);

    //
    // get _pComponent
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    IGNORE_HR(pSP->QueryService(CLSID_CHtmlComponent, CLSID_CHtmlComponent, (void**)&_pComponent));

Cleanup:
    ReleaseInterface(pHtmlElement);
    ReleaseInterface(pSP);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Notify(LONG lEvent, VARIANT * pVar)
{
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Detach
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Detach()
{
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase *
CHtmlComponentBase::GetAgent(CHtmlComponent * pComponent)
{
    CHtmlComponentAgentBase * pAgent;

    if (pComponent)
    {
        Assert (!_pAgentWhenStandalone);

        pAgent = pComponent->GetAgent(this);
    }
    else
    {
        if (!_pAgentWhenStandalone)
        {
            _pAgentWhenStandalone = CreateAgent(pComponent);
        }

        pAgent = _pAgentWhenStandalone;
    }

    return pAgent;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetExternalName, helper
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetExternalName()
{
    return GetExpandoString(_pElement, _T("name"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::InvokeEngines, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::InvokeEngines(
    CHtmlComponent *    pComponent,
    CScriptContext *    pScriptContext,
    LPTSTR              pchName,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CScriptCollection * pScriptCollection = NULL;

    if (!_pElement)
        goto Cleanup;
        
    if (pComponent)
    {
        pScriptCollection = pComponent->GetScriptCollection();
    }
    else
    {
        Assert (_pElement);
        pScriptCollection = _pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();
    }

    if (!pScriptCollection)
        goto Cleanup;
        
    hr = THR_NOTRACE(pScriptCollection->InvokeName(
        pScriptContext, pchName,
        g_lcidUserDefault, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetChildInternalName, helper
//
//  CONSIDER:   optimizing this so to avoid children scan
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetChildInternalName(LPTSTR pchChild)
{
    CChildIterator  ci (_pElement);
    CTreeNode *     pNode;
    CElement *      pElement;

    while (NULL != (pNode = ci.NextChild()))
    {
        pElement = pNode->Element();
        if (0 == StrCmpIC (pElement->TagName(), pchChild))
        {
            return GetExpandoString (pElement, _T("internalName"));
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetInternalName, helper
//
//  Parameters: pfDifferent     indicates if external and internal names are different
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetInternalName(BOOL * pfScriptsOnly, WORD * pwFlags, DISPPARAMS * pDispParams)
{
    LPTSTR  pchName;
    BOOL    fScriptsOnly;

    if (!_pElement)
        return NULL;

    if (!pfScriptsOnly)
        pfScriptsOnly = &fScriptsOnly;

    //
    // putters / getters
    //

    if (pwFlags)
    {
        if ((*pwFlags) & DISPATCH_PROPERTYGET)
        {
            pchName = GetExpandoString(_pElement, _T("GET"));
            if (!pchName)
            {
                pchName = GetChildInternalName(_T("GET"));
            }
        }
        else if ((*pwFlags) & DISPATCH_PROPERTYPUT)
        {
            pchName = GetExpandoString(_pElement, _T("PUT"));
            if (!pchName)
            {
                pchName = GetChildInternalName(_T("PUT"));
            }
        }
        else
        {
            pchName = NULL;
        }

        if (pchName)                            // if there is a putter or getter method for the property
        {
            *pwFlags = DISPATCH_METHOD;         // switch to METHOD call type
            if (pDispParams)
            {
                pDispParams->cNamedArgs = 0;    // remove any named args
            }
            *pfScriptsOnly = TRUE;
            return pchName;                     // and use the putter/getter
        }
    }

    //
    // internal name
    //

    pchName = GetExpandoString(_pElement, _T("internalName"));
    if (pchName)
    {
        *pfScriptsOnly = TRUE;
        return pchName;
    }

    //
    // name
    //

    *pfScriptsOnly = FALSE;

    return GetExternalName();
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDD
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateAddRef, per IPrivateUnknown
//
//-------------------------------------------------------------------------

ULONG
CHtmlComponentDD::PrivateAddRef()
{
    return Component()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateRelease, per IPrivateUnknown
//
//-------------------------------------------------------------------------

ULONG
CHtmlComponentDD::PrivateRelease()
{
    return Component()->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCDefaultDispatch, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

#if DBG == 1
//+------------------------------------------------------------------------
//
//  Helper:     DDAssertDispidRanges
//
//              DEBUG ONLY
//
//-------------------------------------------------------------------------

void
DDAssertDispidRanges(DISPID dispid)
{
    struct
    {
        DISPID  dispidMin;
        DISPID  dispidMax;
    }   aryRanges[] =
    {
        // (0)  script collection - cross languages glue
        {   DISPID_OMWINDOWMETHODS,       1000000 - 1                             }, //     10,000 ..    999,999

        // (1)  markup window all collection (elements within htc accessed by id)
        {   DISPID_COLLECTION_MIN,        DISPID_COLLECTION_MAX                   }, //  1,000,000 ..  2,999,999

        // ()   doc fragment DD
        // DISPID_A_DOCFRAGMENT                 document
        // (in range 3)

        // ()   HTC DD
        // DISPID_A_HTCDD_ELEMENT               element
        // DISPID_A_HTCDD_CREATEEVENTOBJECT     createEventObject
        // (in range 3)

        // (2)  element's namespace - standard properties
        {   -1,                           -30000                                  }, // 0xFFFFFFFF .. 0xFFFF0000 (~)

        // (3)  element's namespace - properties
        {   DISPID_XOBJ_MIN,              DISPID_XOBJ_MAX                         }, // 0x80010000 .. 0x8001FFFF

        // (4)  element's namespace - expandos
        {   DISPID_EXPANDO_BASE,          DISPID_EXPANDO_MAX                      }, //  3,000,000 .. 3,999,999

        // (5)  element's namespace - properties of other behaviors attached to the element
        { DISPID_PEER_HOLDER_BASE,      DISPID_PEER_HOLDER_BASE + INT_MAX / 2     }, //  5,000,000 .. + infinity

        // (6)  element's namespace - properties CElement-derived elements
        { DISPID_NORMAL_FIRST,          DISPID_NORMAL_FIRST + 1000 * 9            },  //      1000 .. 9000
    };

    int     i, j;
    BOOL    fRangeHit;

    // check that the dispid falls into an expected range

    fRangeHit = FALSE;
    for (i = 0; i < ARRAY_SIZE(aryRanges); i++)
    {
        if (aryRanges[i].dispidMin <= dispid && dispid <= aryRanges[i].dispidMax)
        {
            fRangeHit = TRUE;
        }
    }

    Assert (fRangeHit);

    // check that the ranges do not overlap

    for (i = 0; i < ARRAY_SIZE(aryRanges) - 1; i++)
    {
        if (4 == i)
            continue;

        for (j = i + 1; j < ARRAY_SIZE(aryRanges); j++)
        {
            Assert (aryRanges[j].dispidMin < aryRanges[i].dispidMin || aryRanges[i].dispidMax < aryRanges[j].dispidMin);
            Assert (aryRanges[j].dispidMax < aryRanges[i].dispidMin || aryRanges[i].dispidMax < aryRanges[j].dispidMax);
        }
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT             hr;
    CMarkup *           pMarkup = Component()->GetMarkup();
    CCollectionCache *  pWindowCollection;
    CScriptCollection * pScriptCollection;
    CScriptContext *    pScriptContext;

    //
    // standard handling
    //

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK == hr || (hr other then DISP_E_UNKNOWNNAME))
        goto Cleanup;               // get out

    //
    // gluing different script engines togather 
    //

    if (pMarkup)
    {
        pScriptCollection = Component()->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = Component()->GetScriptContext(&pScriptContext);
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->GetDispID(pScriptContext, bstrName, grfdex, pdispid));
            if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK or error other then DISP_E_UNKNOWNNAME)
                goto Cleanup;
        }
    }

    //
    // access to id'd elements 
    //

    if (pMarkup)
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pWindowCollection = pMarkup->CollectionCache();

        hr = THR_NOTRACE(pWindowCollection->GetDispID(
                CMarkup::WINDOW_COLLECTION,
                bstrName,
                grfdex,
                pdispid));
        if (S_OK == hr && DISPID_UNKNOWN == *pdispid)
        {
            // the collection cache GetDispID may return S_OK with DISPID_UNKNOWN if the name isn't found.
            hr = DISP_E_UNKNOWNNAME;
        }
        else if (DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;
    }
    
    //
    // access to element's namespace
    //

    if (Component()->_pElement)
    {
        hr = THR_NOTRACE(Component()->_pElement->GetDispID(bstrName, grfdex, pdispid));
        if (DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;
    }
    
    //
    // internal object model
    //

    if (0 == StrCmpIC(_T("__MS__isMarkupShared"), bstrName))
    {
        hr = S_OK;
        *pdispid = DISPID_A_HTCDD_ISMARKUPSHARED;
        goto Cleanup; // done
    }

Cleanup:

#if DBG == 1
    if (S_OK == hr)
    {
        DDAssertDispidRanges(*pdispid);
    }
#endif

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::InvokeEx(
    DISPID          dispid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarRes,
    EXCEPINFO *     pExcepInfo,
    IServiceProvider * pSrvProvider)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *       pdispexElement = NULL;
    CMarkup *           pMarkup = Component()->GetMarkup();
    CCollectionCache *  pWindowCollection;
    CScriptCollection * pScriptCollection;
    CScriptContext *    pScriptContext;
    
#if DBG == 1
    DDAssertDispidRanges(dispid);
#endif

    //
    // gluing different script engines together 
    //

    if (pMarkup)
    {
        pScriptCollection = Component()->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = Component()->GetScriptContext(&pScriptContext);
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->InvokeEx(
                pScriptContext, dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));
            
            if (DISP_E_MEMBERNOTFOUND != hr)   // if (S_OK or error other then DISP_E_UNKNOWNNAME)
                goto Cleanup;
        }
    }

    //
    // access to id'd elements on the markup.
    //

    if (pMarkup)
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pWindowCollection = pMarkup->CollectionCache();

        if (pWindowCollection->IsDISPIDInCollection(CMarkup::WINDOW_COLLECTION, dispid))
        {
            hr = THR_NOTRACE(pWindowCollection->Invoke(
                CMarkup::WINDOW_COLLECTION, dispid, IID_NULL, lcid, wFlags,
                pDispParams, pvarRes, pExcepInfo, NULL));
            if (hr)
                goto Cleanup;

            if (Component()->_fSharedMarkup)
            {
                hr = THR_NOTRACE(Component()->WrapSharedElement(pvarRes));
            }
        
            goto Cleanup; // done
        }
    }
    
    if (IsStandardDispid(dispid))
    {
        //
        // standard handling
        //

        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));
        if (DISP_E_MEMBERNOTFOUND != hr)    // if (S_OK == hr || (hr other then DISP_E_MEMBERNOTFOUND))
            goto Cleanup;                   // get out
    }
    
    //
    // access to element's namespace
    //

    if (Component()->_pElement)
    {
        hr = THR(Component()->_pElement->QueryInterface(
            IID_IDispatchEx, (void **)&pdispexElement));
        if (hr)
            goto Cleanup;
            
        hr = THR_NOTRACE(pdispexElement->InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));

        if (DISP_E_MEMBERNOTFOUND != hr)    // if (S_OK == hr || (hr other then DISP_E_MEMBERNOTFOUND))
            goto Cleanup;                   // get out
    }
    
    //
    // internal object model
    //

    if (DISPID_A_HTCDD_ISMARKUPSHARED == dispid &&
        (wFlags & DISPATCH_PROPERTYGET))
    {
        Assert (pvarRes);
        hr = S_OK;
        V_VT(pvarRes) = VT_BOOL;
        V_BOOL(pvarRes) = Component()->_fSharedMarkup;
        goto Cleanup; // done
    }

Cleanup:

    ReleaseInterface(pdispexElement);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::GetNameSpaceParent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;
    CMarkup *   pMarkup = Component()->_pMarkup;
    CDocument * pDocument;

    if (!pMarkup)
        RRETURN (E_FAIL);

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    hr = THR(pDocument->PrivateQueryInterface(IID_IDispatchEx, (void**)ppunk));

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_element
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_element(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr;
    
    if (Component()->_pElement)
    {
        hr = THR(Component()->_pElement->QueryInterface(IID_IHTMLElement, (void**) ppHTMLElement));
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_defaults
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_defaults(IDispatch ** ppDefaults)
{
    HRESULT hr;

    if (Component()->_pElement)
    {
        hr = THR(Component()->_pSiteOM->GetDefaults((IHTMLElementDefaults**)ppDefaults));
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::createEventObject
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::createEventObject(IHTMLEventObj ** ppEventObj)
{
    HRESULT hr;

    hr = THR(Component()->_pSiteOM->CreateEventObject(ppEventObj));

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_document
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_document(IDispatch ** ppDocument)
{
    HRESULT hr;

    if (Component()->_fSharedMarkup)
    {
        hr = E_ACCESSDENIED;
    }
    else if (Component()->_pMarkup)
    {
        CDocument * pDocument;

        hr = THR(Component()->_pMarkup->EnsureDocument(&pDocument));
        if (hr)
            goto Cleanup;

        hr = pDocument->QueryInterface(IID_IDispatch, (void **)ppDocument);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent constructor
//
//-------------------------------------------------------------------------

CHtmlComponent::CHtmlComponent(CHtmlComponentConstructor *pConstructor, BOOL fFactoryComponent)
{
    Assert (pConstructor);

    _pConstructor = pConstructor;

    _fFactoryComponent = fFactoryComponent;

    if (_fFactoryComponent)
    {
        _pConstructor->SubAddRef();
    }
    else
    {
        _pConstructor->AddRef();
        if (!_pConstructor->_pFactoryComponent->_fFirstInstance)
        {
            _pConstructor->_pFactoryComponent->_fFirstInstance = TRUE;
            _fFirstInstance = TRUE;
            Assert(_pConstructor->_cComponents == 0);
        }
    }

#if DBG == 1
    if (!_fFactoryComponent)
        _pConstructor->_cComponents++;
#endif

#if DBG == 1
    _DD._pComponentDbg = this;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent destructor
//
//-------------------------------------------------------------------------

CHtmlComponent::~CHtmlComponent()
{
    TraceTag((tagHtcDelete, "CHtmlComponent::~CHtmlComponent, [%lx] deleted", this));

    // force passivation of omdoc
    _DD.Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponent::Passivate()
{
#if DBG == 1
//    if (_pElement)
//    {
//        TraceTag((
//            tagHtcInitPassivate,
//            "CHtmlComponent::Passivate, [%lx] detached from <%ls id = %ls SN = %ld>",
//            this, _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->_nSerialNumber));
//    }
#endif

    Assert (_pConstructor);

    ClearInterface (&_pSiteOM);

    GWKillMethodCall( this, ONCALL_METHOD(CHtmlComponent, FireAsyncReadyState, fireasyncreadystate), 0 );
    GWKillMethodCall( this, ONCALL_METHOD(CHtmlComponent, SetReadystateCompleteAsync, setreadystatecompleteasync), 0 );

    if (_pMarkup)
    {
        CMarkupBehaviorContext *    pMarkupBehaviorContext = _pMarkup->BehaviorContext();

        if (pMarkupBehaviorContext)
        {
            // remove back pointer - important if someone else keeps reference on the tree
            pMarkupBehaviorContext->_pHtmlComponent = NULL;

            // ensure the booster map does not grow indefinitely
            if (pMarkupBehaviorContext->_pExtendedTagTableBooster)
                pMarkupBehaviorContext->_pExtendedTagTableBooster->ResetMap();
        }

        if (!_fGotQuickDone)
        {
            _pConstructor->OnMarkupLoaded(this);
        }
        WHEN_DBG( else Assert( _pMarkup->_LoadStatus >= LOADSTATUS_QUICK_DONE ); )

        // stop further loading of the HTC markup
        _pMarkup->_LoadStatus = LOADSTATUS_DONE;

        IGNORE_HR(_pMarkup->ExecStop(FALSE, FALSE, FALSE));

        if (_pMarkup->HasScriptContext() &&
            !_fFactoryComponent &&
            _pConstructor->_pFactoryComponent->_fClonedScript)
        {
            if (_pDoc && _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fCleanupHTCs)
            {
                CScriptContext *pScriptContext = _pMarkup->ScriptContext();
                Assert(!_pConstructor->_pFactoryComponent->_fLightWeight);
                Assert(pScriptContext);
                Assert(pScriptContext->_fClonedScript);
                Assert(pScriptContext->GetNamespace());

                pScriptContext->SetNamespace(NULL);

                CScriptCollection * pScriptCollection = GetScriptCollection();
                if (pScriptCollection && (pScriptContext->_idxDefaultScriptHolder != -1) && (pScriptCollection->_aryCloneHolder.Size() > pScriptContext->_idxDefaultScriptHolder))
                {
                    CScriptHolder * pHolder = pScriptCollection->_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
                    if (pHolder && pHolder->_fClone)
                    {
                        Assert(!_fFirstInstance);
                        pHolder->Close();
                        pHolder->Release();
                        pScriptCollection->_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder] = NULL;
                    }
                }
            }
            else
            {
                Assert(!_pConstructor->_pFactoryComponent->_fLightWeight);
                Assert(_pMarkup->ScriptContext()->_fClonedScript);
                Assert(_pMarkup->ScriptContext()->GetNamespace());
                _pMarkup->ScriptContext()->SetNamespace(NULL);
            }
        }

        if( _pMarkup->GetObjectRefs() > 1 )
        {
            IGNORE_HR( _pMarkup->SetOrphanedMarkup( TRUE ) );
        }

        _pMarkup->Release();
        _pMarkup = NULL;
    }
    
#if DBG == 1
    if (!_fFactoryComponent)
        _pConstructor->_cComponents--;
#endif

    if (_fFactoryComponent)
    {
        _pConstructor->SubRelease();
        if (_pCustomNames)
        {
            delete _pCustomNames;
            _pCustomNames = NULL;
        }
    }
    else
    {
        if (_pScriptContext && _pConstructor->_pFactoryComponent->_fClonedScript)
        {
            Assert(_pConstructor->_pFactoryComponent->_fLightWeight && _pScriptContext->_fClonedScript);
            _pScriptContext->SetNamespace(NULL);

            if (_pDoc && _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fCleanupHTCs)
            {
                Assert(_pScriptContext->_fClonedScript);

                CScriptCollection * pScriptCollection = GetScriptCollection();
                if (pScriptCollection && (_pScriptContext->_idxDefaultScriptHolder != -1) && (pScriptCollection->_aryCloneHolder.Size() > _pScriptContext->_idxDefaultScriptHolder))
                {
                    CScriptHolder * pHolder = pScriptCollection->_aryCloneHolder[_pScriptContext->_idxDefaultScriptHolder];
                    if (pHolder && pHolder->_fClone)
                    {
                        Assert(!_fFirstInstance);
                        pHolder->Close();
                        pHolder->Release();
                        pScriptCollection->_aryCloneHolder[_pScriptContext->_idxDefaultScriptHolder] = NULL;
                    }
                }
            }
        }

        // If this is the first instance, but the SE has not been hooked up for it yet when it goes away,
        // reset the firstinstance flag on both this and the factory, so that if another comes in it can
        // become the first instance.
        if (!_pConstructor->_pFactoryComponent->_fOriginalSECreated &&
            _pConstructor->_pFactoryComponent->_fClonedScript && 
            _fFirstInstance)
        {
            _fFirstInstance = FALSE;
            _pConstructor->_pFactoryComponent->_fFirstInstance = FALSE;
        }

        _pConstructor->Release();
        Assert(!_pCustomNames);
    }
    _pConstructor = NULL;

    _pDoc->SubRelease();

    delete _pScriptContext;
    _pScriptContext = NULL;

    // clear _aryPropertyAgents
    {
        CHtmlComponentAgentBase **  ppAgent;
        int                             c;

        for (ppAgent = _aryAgents, c = _aryAgents.Size(); c; ppAgent++, c--)
        {
            (*ppAgent)->Release();
        }
        _aryAgents.DeleteAll();
    }

    if (_pProfferService)
    {
        _pProfferService->Release();
        _pProfferService = NULL;
    }

    // super
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponent::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IPersistPropertyBag2, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(this, NULL);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    if (IsEqualGUID(iid, CLSID_CHtmlComponent))
    {
        *ppv = this; // weak ref
        return S_OK;
    }

    if (_pProfferService)
    {
        HRESULT     hr;
        IUnknown *  pUnk;

        hr = THR_NOTRACE(_pProfferService->QueryService(iid, iid, (void**) &pUnk));
        if (S_OK == hr)
        {
            hr = THR(CreateTearOffThunk(
                    pUnk,
                    *(void **)pUnk,
                    NULL,
                    ppv,
                    this,
                    *(void **)(IUnknown*)(IPrivateUnknown*)this,
                    QI_MASK | ADDREF_MASK | RELEASE_MASK,
                    NULL));

            pUnk->Release();

            if (S_OK == hr)
            {
                ((IUnknown*)*ppv)->AddRef();
            }

            RRETURN (hr);
        }
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    if (IsEqualGUID(rguidService, CLSID_CHtmlComponent))
    {
        RRETURN (PrivateQueryInterface(riid, ppvObject));
    }
    else if (IsEqualGUID(rguidService, SID_SProfferService))
    {
        if (!_pProfferService)
        {
            _pProfferService = new CProfferService();
            if (!_pProfferService)
            {
                RRETURN (E_OUTOFMEMORY);
            }
        }

        RRETURN (_pProfferService->QueryInterface(riid, ppvObject));
    }

    RRETURN(_pDoc->QueryService(rguidService, riid, ppvObject));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetScriptCollection, helper
//
//-------------------------------------------------------------------------

CScriptCollection *
CHtmlComponent::GetScriptCollection()
{
    CMarkup *   pMarkup;

    if (!_pElement)
        return NULL;

    pMarkup = _pElement->GetNearestMarkupForScriptCollection();

    return pMarkup->HasWindowPending() ? pMarkup->GetScriptCollection() : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CanCommitScripts
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponent::CanCommitScripts(CScriptElement *pelScript)
{
    if (_fFactoryComponent)
    {
        Assert(pelScript);

        if (!pelScript->GetAAevent())
        {
            if (_fClonedScriptClamp)
            {
                _fClonedScript = FALSE;
                _pConstructor->_pelFactoryScript = NULL;
            }
            else 
            {
                BOOL fOtherScript = FALSE;
                LPCTSTR pchLanguage = pelScript->GetAAlanguage();
                if (pchLanguage)
                {
                    pelScript->_fJScript = ((*pchLanguage == _T('j') || *pchLanguage == _T('J'))    &&
                                            (0 == StrCmpIC(pchLanguage, _T("jscript"))          ||
                                            0 == StrCmpIC(pchLanguage, _T("javascript"))));

                    if (!pelScript->_fJScript)
                    {
                        fOtherScript = !((*pchLanguage == _T('v') || *pchLanguage == _T('V'))    &&
                                         (0 == StrCmpIC(pchLanguage, _T("vbs"))         ||
                                         0 == StrCmpIC(pchLanguage, _T("vbscript"))));
                    }
                }

                Assert(!_pConstructor->_pelFactoryScript);
                if (!fOtherScript && (pelScript->_pchSrcCode || pelScript->_cstrText.Length() > 512))
                {
                    _fClonedScript = TRUE;
                    _pConstructor->_pelFactoryScript = pelScript;
                }
                else
                    Assert(!_fClonedScript);

                _fClonedScriptClamp = TRUE;
            }
        }

        return FALSE;
    }

    Assert (_pConstructor);
    Assert (_pConstructor->_fSupportsEditMode || !_pDoc->DesignMode());

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CreateMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::CreateMarkup()
{
    HRESULT     hr;
    CMarkup *   pWindowedMarkupContext = NULL;

    Assert (!_pMarkup);

    if( _fFactoryComponent )
    {
        if ( _pConstructor->_pMarkup )
            pWindowedMarkupContext = _pConstructor->_pMarkup->GetWindowedMarkupContext();
    }
    else
    {
        Assert( _pElement );
        pWindowedMarkupContext = _pElement->GetWindowedMarkupContext();
    }


    hr = _pDoc->CreateMarkup(&_pMarkup, pWindowedMarkupContext );
    if (hr)
        goto Cleanup;

    hr = _pMarkup->EnsureBehaviorContext();
    if (hr)
        goto Cleanup;

    _pMarkup->BehaviorContext()->_pHtmlComponent = this; // this should happen before load

    // If we have an element, try to inherit its media
    if ( _pElement )
    {
        CMarkup  *pParentMarkup = _pElement->GetMarkup();
        mediaType mtParentMarkup;
        if ( pParentMarkup )
        {
            mtParentMarkup = pParentMarkup->GetMedia();
            // Only inherit if the parent has a media set.
            if ( mtParentMarkup != mediaTypeNotSet )
                _pMarkup->SetMedia( mtParentMarkup );

            if (    !_pMarkup->IsPrintTemplateExplicit()
                &&  pParentMarkup->IsPrintTemplate()    )
            {
                // Why the Check? Because we are being viewlinked from a print template, and print media markups cannot be print templates.
                Check(!_pMarkup->IsPrintMedia());

                _pMarkup->SetPrintTemplate(TRUE);
            }
        }
    }


Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Load(IStream * pStream)
{
    HRESULT     hr;

    hr = THR(CreateMarkup());
    if (hr)
        goto Cleanup;

    {
        CLock       (this); // Load can make this HtmlComponent passivate;
                            // but Load will not handle it gracefully if aborted while downloading from stream

        hr = THR(_pMarkup->Load(pStream, /* pContextMarkup = */NULL, /* fAdvanceLoadStatus = */TRUE));
        if (hr)
            goto Cleanup;
    }

    Assert (LOADSTATUS_PARSE_DONE <= _pMarkup->_LoadStatus);

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Load(IMoniker * pMoniker)
{
    HRESULT                 hr;
    CDwnBindInfo *          pBSC = NULL;
    IBindCtx *              pBindCtx = NULL;

    Assert (pMoniker);

    if (_pMarkup)
    {
        hr = S_OK;
        goto Cleanup;   // done - nothing to do
    }

    //
    // create tree and connect to it
    //

    hr = THR(CreateMarkup());
    if (hr)
        goto Cleanup;

    //
    // launch download
    //

    pBSC = new CDwnBindInfo();
    if (!pBSC)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(CreateAsyncBindCtx(0, pBSC, NULL, &pBindCtx));
    if (hr)
        goto Cleanup;

    hr = THR(_pMarkup->Load(
        pMoniker,
        pBindCtx,
        /* fNoProgressUI = */TRUE,
        /* fOffline = */!_fFactoryComponent,
        /* pfnTokenizerFilterOutputToken = */ _fFactoryComponent ? HTCPreloadTokenizerFilter : NULL,
        TRUE ));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));

Cleanup:

    ReleaseInterface (pBindCtx);
    if (pBSC)
        pBSC->Release();

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetAgent, helper
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase *
CHtmlComponent::GetAgent(CHtmlComponentBase * pClient)
{
    HRESULT                         hr2;
    CHtmlComponentAgentBase *       pAgent = NULL;
    
    Assert (pClient && pClient->_pElement);

    if (-1 == pClient->_idxAgent)
    {
        //
        // create a new agent for this client
        //

        pAgent = pClient->CreateAgent(this);
        if (!pAgent)
            goto Cleanup;

        hr2 = _aryAgents.Append(pAgent);
        if (hr2)
        {
            pAgent->Release();
            pAgent = NULL;
            goto Cleanup;
        }

        pClient->_idxAgent = _aryAgents.Size() - 1;
    }
    else
    {
        Assert (0 <= pClient->_idxAgent);
        
        if (pClient->_idxAgent < _aryAgents.Size())
        {
            //
            // get the existing agent
            //

            pAgent = _aryAgents[pClient->_idxAgent];
        }
        else
        {
            //
            // adjust size of the array and create a new agent at the given idx
            //

            pAgent = pClient->CreateAgent(this);
            if (!pAgent)
                goto Cleanup;

            Assert (_aryAgents.Size() == pClient->_idxAgent);

            hr2 = _aryAgents.Append(pAgent);
            if (hr2)
            {
                pAgent->Release();
                pAgent = NULL;
                goto Cleanup;
            }
        }
    }

Cleanup:

    return pAgent;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CHtmlComponent::SetReadystateCompleteAsync
//  
//  Synopsis:   Async callback to set the component to readystate complete.
//              This prevents lightweight behaviors from skipping the loading
//              state.
//              This is done in 2 stages, so that we allow asynch operations
//              from Trident proper that were queued up
//              
//  Returns:    void
//  
//  Arguments:
//          DWORD_PTR dwContext - N/A
//  
//+----------------------------------------------------------------------------
void
CHtmlComponent::SetReadystateCompleteAsync(DWORD_PTR dwContext)
{
    Assert( _fSharedMarkup && _fEmulateLoadingState );
    _fEmulateLoadingState = FALSE;
    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::ToSharedMarkupMode, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::ToSharedMarkupMode( BOOL fSync )
{
    HRESULT     hr = S_OK;
    CScriptCollection * pScriptCollection = GetScriptCollection();

    Assert (!_fSharedMarkup);
    _fSharedMarkup = TRUE;

    if( !fSync )
    {
        _fEmulateLoadingState = TRUE;

        GWPostMethodCall(this, ONCALL_METHOD(CHtmlComponent, SetReadystateCompleteAsync, setreadystatecompleteasync), 0, TRUE, "CHtmlComponent::SetReadystateCompleteAsync");
    }

    _pScriptContext = new CScriptContext();
    if (!_pScriptContext)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!_pConstructor->_pFactoryComponent->_fClonedScript)
    {
        if (pScriptCollection)
        {
            IGNORE_HR(pScriptCollection->AddNamedItem(
                /* pchNamespace = */ NULL, _pScriptContext, (IUnknown*)(IPrivateUnknown*)&_DD));
        }
    }
    else
    {
        _pScriptContext->_fClonedScript = TRUE;
        CMarkupScriptContext *pScriptContext = _pConstructor->_pFactoryComponent->_pMarkup->ScriptContext();

        Assert(pScriptContext && pScriptContext->GetNamespace());
        Assert(!_pConstructor->_pFactoryComponent->_pScriptContext);
        _pScriptContext->_cstrNamespace.SetPch(pScriptContext->GetNamespace());
    }

    hr = THR(CommitSharedItems());
    if (hr)
        goto Cleanup;

    hr = THR(OnMarkupLoaded( /*fAsync=*/ TRUE ));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::WrapSharedElement, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::WrapSharedElement(VARIANT * pvarElement)
{
    HRESULT                     hr = E_ACCESSDENIED;
    HRESULT                     hr2;
    CElement *                  pElement;
    CHtmlComponentBase *        pHtmlComponentBase;
    CHtmlComponentAgentBase *   pAgent;

    Assert (_fSharedMarkup);
    Assert (pvarElement);

    if (VT_UNKNOWN != V_VT(pvarElement) &&
        VT_DISPATCH != V_VT(pvarElement))
        goto Cleanup;

    hr2 = THR_NOTRACE(V_UNKNOWN(pvarElement)->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr2)
        goto Cleanup;

    pHtmlComponentBase = GetHtcFromElement(pElement);
    if (!pHtmlComponentBase)
        goto Cleanup;

    switch (pHtmlComponentBase->GetType())
    {
    case HTC_BEHAVIOR_PROPERTY:
    case HTC_BEHAVIOR_EVENT:
    case HTC_BEHAVIOR_ATTACH:
        pAgent = GetAgent(pHtmlComponentBase);
        if (!pAgent)
            goto Cleanup;
        break;

    default:
        goto Cleanup;
    }

    V_UNKNOWN(pvarElement)->Release();

    V_VT(pvarElement) = VT_UNKNOWN;
    V_UNKNOWN(pvarElement) = pAgent;
    V_UNKNOWN(pvarElement)->AddRef();
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Init(IElementBehaviorSite * pSite)
{
    HRESULT hr;

    hr = THR(InitHelper(pSite));
    if (hr)
        goto Cleanup;

    Assert (_pElement);

    TraceTag((
        tagHtcInitPassivate,
        "CHtmlComponent::Init, [%lx] attached to <%ls id = %ls SN = %ld>",
        this, _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->_nSerialNumber));

    Assert (_pConstructor);

    hr = THR(_pConstructor->RequestMarkup(this));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::InitHelper(IElementBehaviorSite * pSite)
{
    if (_pSite)         // if already initialized
        return S_OK;

    HRESULT                 hr;
    IServiceProvider *      pSP = NULL;
    IHTMLElementDefaults *  pDefaults = NULL;

    //
    // get site interface pointers
    //
    
    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    hr = THR(_pSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&_pSiteOM));
    if (hr)
        goto Cleanup;

    //
    // get the doc
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR(pSP->QueryService(CLSID_HTMLDocument, CLSID_HTMLDocument, (void**)&_pDoc));
    if (hr)
        goto Cleanup;

    Assert (_pDoc);
    _pDoc->SubAddRef();

    //
    // Decide if we're an element behavior
    // There's no direct way of asking this; however, attached behaviors don't
    // have access to a "defaults" object, so we can try and get that.
    if( SUCCEEDED( _pSiteOM->GetDefaults( &pDefaults ) ) )
    {
        _fElementBehavior = TRUE;
        ReleaseInterface( pDefaults );
    }

Cleanup:
    ReleaseInterface (pSP);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Init(CDoc * pDoc)
{
    HRESULT     hr = S_OK;

    Assert (!_pSite && !_pElement && _fFactoryComponent);

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::IsRecursiveUrl, helper
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponent::IsRecursiveUrl(LPTSTR pchUrl)
{
    HRESULT                     hr;
    TCHAR                       achUrlExpanded1[pdlUrlLen];
    TCHAR                       achUrlExpanded2[pdlUrlLen];
    CMarkup *                   pMarkup;
    CMarkupBehaviorContext *    pMarkupBehaviorContext;

    Assert (_pElement && pchUrl && pchUrl[0]);

    hr = THR(CMarkup::ExpandUrl(NULL, 
        pchUrl, ARRAY_SIZE(achUrlExpanded1), achUrlExpanded1, _pElement));
    if (hr)
        goto Cleanup;

    pMarkup = _pElement->GetMarkup();

    // walk up parent markup chain
    while (pMarkup)
    {
        hr = THR(CMarkup::ExpandUrl(pMarkup, 
            CMarkup::GetUrl(pMarkup), ARRAY_SIZE(achUrlExpanded2), achUrlExpanded2, _pElement));

        if (hr)
            goto Cleanup;

        if (0 == StrCmpIC(achUrlExpanded1, achUrlExpanded2))
        {
            TraceTag((tagError, "Detected recursion in HTC!"));
            return TRUE;
        }

        pMarkupBehaviorContext = pMarkup->BehaviorContext();
        if (!pMarkupBehaviorContext ||
            !pMarkupBehaviorContext->_pHtmlComponent ||
            !pMarkupBehaviorContext->_pHtmlComponent->_pElement)
            break;

        pMarkup = pMarkupBehaviorContext->_pHtmlComponent->_pElement->GetMarkup();
    }

Cleanup:
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    hr = THR(FireNotification(lEvent, pVar));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Detach, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Detach(void)
{
    HRESULT                 hr = S_OK;
    LONG                    idx;
    CElement *              pElement;
    CHtmlComponentAttach *  pAttach;
    CMarkup *               pMarkup = GetMarkup();

    Assert (!IsPassivated());

    //
    // call detachEvent on all attach tags
    //

    if (pMarkup)
    {
        for (idx = 0;; idx++)
        {
            hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_ATTACH));
            if (hr)
                goto Cleanup;
            if (!pElement)
                break;

            pAttach = DYNCAST(CHtmlComponentAttach, GetHtcFromElement(pElement));
            Assert (pAttach);

            hr = THR(pAttach->DetachEvent(this));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::OnMarkupLoaded
//
//----------------------------------------------------------------------------

HRESULT
CHtmlComponent::OnMarkupLoaded( BOOL fAsync /*=FALSE*/ )
{
    HRESULT     hr = S_OK;
    CLock       lockComponent(this);

    if (_pConstructor)
    {
        IGNORE_HR(_pConstructor->OnMarkupLoaded(this));
    }

    if (_fContentReadyPending)
    {
        IGNORE_HR(FireNotification (BEHAVIOREVENT_CONTENTREADY, NULL));
    }

    if (_fDocumentReadyPending)
    {
        IGNORE_HR(FireNotification (BEHAVIOREVENT_DOCUMENTREADY, NULL));
    }

    if( fAsync )
    {
        GWPostMethodCall(this, ONCALL_METHOD(CHtmlComponent, FireAsyncReadyState, fireasyncreadystate), 0, TRUE, "CHtmlComponent::FireAsyncReadyState");
    }
    else
    {
        IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
    }

    RRETURN (hr);
}


//+----------------------------------------------------------------------------
//  
//  Method:     CHtmlComponent::FireAsyncReadyState
//  
//  Synopsis:   Async callback to handle firing the ready state change
//  
//  Returns:    void
//  
//  Arguments:
//          DWORD dwContext - Not used
//  
//+----------------------------------------------------------------------------

void
CHtmlComponent::FireAsyncReadyState(DWORD_PTR dwContext)
{
    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load
//
//----------------------------------------------------------------------------

HRESULT
CHtmlComponent::OnLoadStatus(LOADSTATUS LoadStatus)
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagHtcOnLoadStatus,
        "CHtmlComponent::OnLoadStatus, [%lx] load status: %ld",
        this, LoadStatus));

    switch (LoadStatus)
    {
    case LOADSTATUS_QUICK_DONE:

        _fGotQuickDone = TRUE;
        IGNORE_HR(OnMarkupLoaded());

        break;

#if DBG == 1
    case LOADSTATUS_DONE:

        // assert that markup (other then factory or shared) does not have HtmCtx - 
        // that would be a very significant perf hit
        if (!_fFactoryComponent && 
            !_fSharedMarkup && 
            !(_pMarkup->HasScriptContext() && _pMarkup->ScriptContext()->_pScriptDebugDocument))
        {
            Assert (!_pMarkup->HtmCtx());
        }

        break;
#endif
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetScriptContext
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetScriptContext(CScriptContext ** ppScriptContext)
{
    HRESULT     hr = S_OK;

    Assert (ppScriptContext);

    if (_pScriptContext)
    {
        Assert (_fSharedMarkup);
        *ppScriptContext = _pScriptContext;
    }
    else
    {
        hr = THR(GetMarkup()->EnsureScriptContext((CMarkupScriptContext**)ppScriptContext));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetMarkup
//
//-------------------------------------------------------------------------
CMarkup *
CHtmlComponent::GetMarkup()
{
    if (_fSharedMarkup &&
        _pConstructor &&
        _pConstructor->_pFactoryComponent &&
        _pConstructor->_pFactoryComponent->_pMarkup)        
    {
        Assert(_pConstructor->_pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE);
        return _pConstructor->_pFactoryComponent->_pMarkup;
    }
    else
    {
        return _pMarkup;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CommitSharedItems
//
//  CONSIDER:   (alexz) optimize the passes by storing an array of elements
//              either locally or on the factory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::CommitSharedItems()
{
    HRESULT                     hr = S_OK;
    LONG                        idx;
    CElement *                  pElement;
    CHtmlComponentBase *        pHtmlComponentBase;

    Assert (_pConstructor && _pConstructor->_pFactoryComponent);
    Assert (_pScriptContext && GetNamespace());

    Assert (!_fCommitting);
    _fCommitting = TRUE;

    //
    // pass 1
    //

    for (idx = 0;; idx++)
    {
        hr = THR(_pConstructor->_pFactoryComponent->GetElement(&idx, &pElement));
        if (hr)
            goto Cleanup;

        if (!pElement)
            break;

        switch (pElement->Tag())
        {
        case ETAG_SCRIPT:

            hr = THR(DYNCAST(CScriptElement, pElement)->CommitCode(
                TRUE,               // fCommitOutOfMarkup
                this,               // pchNamespace
                _pElement));        // pElementContext
            if (hr)
                goto Cleanup;

            break;

        case ETAG_GENERIC_BUILTIN:

            pHtmlComponentBase = GetHtcFromElement (pElement);
            if(pHtmlComponentBase)
            {
                switch (pHtmlComponentBase->GetType())
                {
                case HTC_BEHAVIOR_PROPERTY:
                    IGNORE_HR(DYNCAST(CHtmlComponentProperty,pHtmlComponentBase)->EnsureHtmlLoad(
                        this, /* fScriptsOnly = */TRUE));
                    break;

                case HTC_BEHAVIOR_DEFAULTS:
                    hr = THR(DYNCAST(CHtmlComponentDefaults, pHtmlComponentBase)->Commit1(this));
                    break;
                }
            }
            break;
        }
    }

    //
    // pass 2
    //

    for (idx = 0;; idx++)
    {
        hr = THR(_pConstructor->_pFactoryComponent->GetElement(&idx, &pElement));
        if (hr)
            goto Cleanup;

        if (!pElement)
            break;

        switch (pElement->Tag())
        {
        case ETAG_GENERIC_BUILTIN:

            pHtmlComponentBase = GetHtcFromElement (pElement);
            if(pHtmlComponentBase)
            {
                switch (pHtmlComponentBase->GetType())
                {
                case HTC_BEHAVIOR_PROPERTY:
                    IGNORE_HR(DYNCAST(CHtmlComponentProperty, pHtmlComponentBase)->EnsureHtmlLoad(
                        this, /* fScriptsOnly = */FALSE));
                    break;

                case HTC_BEHAVIOR_EVENT:
                    hr = THR(DYNCAST(CHtmlComponentEvent, pHtmlComponentBase)->Commit(this));
                    break;

                case HTC_BEHAVIOR_DESC:
                    hr = THR(DYNCAST(CHtmlComponentDesc, pHtmlComponentBase)->Commit(this));
                    break;

                case HTC_BEHAVIOR_ATTACH:
                    hr = THR(DYNCAST(CHtmlComponentAttach, pHtmlComponentBase)->Attach(this, /* fInit = */TRUE));
                    break;

                case HTC_BEHAVIOR_DEFAULTS:
                    hr = THR(DYNCAST(CHtmlComponentDefaults, pHtmlComponentBase)->Commit2(this));
                    break;
                }
            }
            break;
        }
    }

    _fCommitting = FALSE;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetElement, helper
//
//  Returns:    hr == S_OK, pElement != NULL:       found the element
//              hr == S_OK, pElement == NULL:       reached the end of collection
//              hr != S_OK:                         fatal error
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetElement(LONG * pIdx, CElement ** ppElement, HTC_BEHAVIOR_TYPE typeRequested)
{
    HRESULT             hr;
    CCollectionCache *  pCollection;
    LONG                idx = 0;
    HTC_BEHAVIOR_TYPE   typeElement;
    CMarkup *           pMarkup = GetMarkup();

    if (!pMarkup)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (!pIdx)
        pIdx = &idx;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollection = pMarkup->CollectionCache();

    for (;; (*pIdx)++)
    {
        hr = THR_NOTRACE(pCollection->GetIntoAry(
            CMarkup::ELEMENT_COLLECTION, *pIdx, ppElement));
        Assert (S_FALSE != hr);
        if (DISP_E_MEMBERNOTFOUND == hr)        // if reached end of collection
        {
            hr = S_OK;
            *ppElement = NULL;
            goto Cleanup;
        }
        if (hr)                                 // if fatal error
            goto Cleanup;

        if (HTC_BEHAVIOR_NONE == typeRequested)
            break;

        if (ETAG_GENERIC_BUILTIN != (*ppElement)->Tag())
            continue;

        typeElement = TagNameToHtcBehaviorType((*ppElement)->TagName());

        if (typeElement & typeRequested)
            break;
    }

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::AttachNotification, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::AttachNotification(DISPID dispid, IDispatch * pdispHandler)
{
    HRESULT hr;
    hr = THR(AddDispatchObjectMultiple(dispid, pdispHandler, CAttrValue::AA_AttachEvent, CAttrValue::AA_Extra_OldEventStyle));
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::FireNotification, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::FireNotification(LONG lEvent, VARIANT *pVar)
{
    HRESULT     hr = S_OK;
    DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
    DISPID      dispidEvent = 0;

    switch (lEvent)
    {
    case BEHAVIOREVENT_CONTENTREADY:

        // If we're only pretending to be loading, then we should still 
        // go ahead and fire off the notification
        if ( !_fEmulateLoadingState && GetReadyState() < READYSTATE_COMPLETE )
        {
            _fContentReadyPending = TRUE;
            goto Cleanup;   // get out
        }

        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY;

        break;

    case BEHAVIOREVENT_DOCUMENTREADY:

        if ( !_fEmulateLoadingState && GetReadyState() < READYSTATE_COMPLETE )
        {
            _fDocumentReadyPending = TRUE;
            goto Cleanup;   // get out
        }

        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY;
        break;

    case BEHAVIOREVENT_APPLYSTYLE:
        if (pVar)
        {
            dispParams.rgvarg = pVar;
            dispParams.cArgs = 1;
        }
        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE;
        break;

    case BEHAVIOREVENT_CONTENTSAVE:
        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE;
        Assert(pVar);
        dispParams.rgvarg = pVar;
        dispParams.cArgs = 1;
        break;
        
    default:
        Assert (0 && "a notification not implemented in HTC");
        goto Cleanup;
    }

    IGNORE_HR(InvokeAttachEvents(dispidEvent, &dispParams, NULL, _pDoc));

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CMarkup *           pMarkup = GetMarkup();
    STRINGCOMPAREFN     pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;
    CElement *          pElement;
    LPCTSTR             pchName;
    long                idx;

    //
    // search markup for all property and method tags
    //

    if (pMarkup)
    {
        if (!Dirty() && _pConstructor && _pConstructor->_pFactoryComponent)
        {
            idx = FindIndexFromName(bstrName, (grfdex & fdexNameCaseSensitive));
            if (idx != -1)
            {
                WHEN_DBG(CElement *pelActual=NULL;)
                // if an inline script tries to access a prop\method when it is not yet parsed in, return error
                if (idx < (pMarkup->NumElems() - 1))
                {
                    *pdispid = DISPID_COMPONENTBASE + idx;
#if DBG == 1
                    hr = THR(GetElement(idx, &pelActual, HTC_BEHAVIOR_PROPERTYORMETHOD));
                    Assert(hr == S_OK && pelActual);
                    pchName = GetExpandoString(pelActual, _T("name"));
                    Assert(pchName);
                    Assert(0 == pfnStrCmp(pchName, bstrName));
#endif
                    hr = S_OK;
                }
            }

            goto Cleanup;
        }

        for (idx = 0;; idx++)
        {
            hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_PROPERTYORMETHOD));
            if (hr)
                goto Cleanup;
            if (!pElement)
            {
                hr = DISP_E_UNKNOWNNAME;
                break;
            }

            pchName = GetExpandoString(pElement, _T("name"));
            if (!pchName)
                continue;
            
            if (0 == pfnStrCmp(pchName, bstrName))
            {
                *pdispid = DISPID_COMPONENTBASE + idx;
                break;
            }
        }
    }
    
Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::InvokeEx(
    DISPID          dispid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarRes,
    EXCEPINFO *     pExcepInfo,
    IServiceProvider * pServiceProvider)
{
    CElement *                  pElement;
    HRESULT                     hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *               pdexElement = NULL;
    CHtmlComponentBase *        pHtc;
    CHtmlComponentProperty *    pProperty;
    CHtmlComponentMethod *      pMethod;

    switch (dispid)
    {
    case DISPID_READYSTATE:
        V_VT(pvarRes) = VT_I4;
        hr = THR(GetReadyState((READYSTATE*)&V_I4(pvarRes)));
        goto Cleanup; // done
    }

    if (GetMarkup())
    {
        //
        // find the item
        //

        hr = THR_NOTRACE(GetElement(dispid - DISPID_COMPONENTBASE, &pElement, HTC_BEHAVIOR_PROPERTYORMETHOD));
        if (hr)
            goto Cleanup;
        if (!pElement)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        //
        // invoke the item
        //

        pHtc = GetHtcFromElement(pElement);
        Assert (pHtc);

        switch (pHtc->GetType())
        {
        case HTC_BEHAVIOR_METHOD:

            if (wFlags & DISPATCH_METHOD)
            {
                pMethod = DYNCAST(CHtmlComponentMethod, pHtc);

                hr = THR_NOTRACE(pMethod->InvokeItem(this, lcid, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
                if (hr)
                    goto Cleanup;
            }
            else
                hr = DISP_E_MEMBERNOTFOUND;

            break;

        case HTC_BEHAVIOR_PROPERTY:

            pProperty = DYNCAST(CHtmlComponentProperty, pHtc);

            if (wFlags & DISPATCH_PROPERTYGET)
            {
                pProperty->EnsureHtmlLoad(this, /* fScriptsOnly = */FALSE);
            }

            hr = THR_NOTRACE(pProperty->InvokeItem(
                this, /* fScriptsOnly = */ FALSE,
                lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
            if (hr)
                goto Cleanup;

            break;

        default:
            Assert (FALSE);
            break;
        }
    }

Cleanup:
    if (hr)
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    ReleaseInterface(pdexElement);
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetNextDispID, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetNextDispID(
    DWORD       grfdex,
    DISPID      dispid,
    DISPID *    pdispid)
{
    CElement *      pElement;
    HRESULT         hr;

    if (!_pMarkup)
    {
        hr = S_FALSE;
        *pdispid = DISPID_UNKNOWN;
        goto Cleanup;
    }
    
    // offset from dispid range to array idx range

    if (-1 != dispid)
    {
        dispid -= DISPID_COMPONENTBASE;
    }

    dispid++;

    // get the next index

    hr = THR(GetElement(&dispid, &pElement, HTC_BEHAVIOR_PROPERTYOREVENT));
    if (hr)
        goto Cleanup;
    if (!pElement)
    {
        hr = S_FALSE;
        *pdispid = DISPID_UNKNOWN;
        goto Cleanup;
    }

    *pdispid = DISPID_COMPONENTBASE + dispid;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetMemberName, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetMemberName(DISPID dispid, BSTR * pbstrName)
{
    HRESULT     hr;
    CElement *  pElement;

    hr = THR(GetElement(dispid - DISPID_COMPONENTBASE, &pElement, HTC_BEHAVIOR_PROPERTYORMETHODOREVENT));
    if (hr)
        goto Cleanup;
    if (!pElement)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(FormsAllocString(GetExpandoString(pElement, _T("name")), pbstrName));
    if (hr)
        goto Cleanup;

Cleanup:        
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetReadyState
//
//-------------------------------------------------------------------------

READYSTATE
CHtmlComponent::GetReadyState()
{
    if (_fSharedMarkup)
    {
        return _fEmulateLoadingState ? READYSTATE_LOADING : READYSTATE_COMPLETE;
    }
    else if (_pMarkup)
    {
        if (_pMarkup->LoadStatus() < LOADSTATUS_QUICK_DONE )
        {
            return READYSTATE_LOADING;
        }
        else
        {
            return READYSTATE_COMPLETE;
        }
    }
    else
    {
        return READYSTATE_LOADING;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetReadyState
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetReadyState(READYSTATE * pReadyState)
{
    HRESULT     hr = S_OK;

    Assert (pReadyState);

    *pReadyState = GetReadyState();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Save
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Save(IPropertyBag2 * pPropBag2, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2;
    LONG                        idx;
    LPCTSTR                     pchName;
    IPropertyBag *              pPropBag = NULL;
    CElement *                  pElement;
    CHtmlComponentProperty *    pProperty;

    if (!GetMarkup())
        goto Cleanup;
    
    hr = THR(pPropBag2->QueryInterface(IID_IPropertyBag, (void**)&pPropBag));
    if (hr)
        goto Cleanup;

    //
    // for every property tag in the markup...
    //

    for (idx = 0;; idx++)
    {
        hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_PROPERTY));
        if (hr)
            goto Cleanup;
        if (!pElement)
            break;

        pchName = GetExpandoString(pElement, _T("name"));
        if (!pchName || !HasExpando(pElement, _T("persist")))
            continue;

        pProperty = DYNCAST(CHtmlComponentProperty, GetHtcFromElement(pElement));
        Assert (pProperty);

        {
            CInvoke invoke;
        
            hr2 = THR_NOTRACE(pProperty->InvokeItem(
                this, /* fScriptsOnly = */ FALSE,
                LCID_SCRIPTING, DISPATCH_PROPERTYGET,
                &invoke._dispParams, invoke.Res(), &invoke._excepInfo, NULL));

            if (S_OK == hr2 &&
                VT_NULL  != V_VT(invoke.Res()) &&
                VT_EMPTY != V_VT(invoke.Res()))
            {
                hr = THR(pPropBag->Write(pchName, invoke.Res()));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
Cleanup:
    ReleaseInterface (pPropBag);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::FindBehavior, static helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::FindBehavior(HTC_BEHAVIOR_TYPE type, IElementBehaviorSite * pSite, IElementBehavior ** ppBehavior)
{
    HRESULT                 hr = E_FAIL;
    CHtmlComponentBase *    pBehaviorItem = NULL;

    switch (type)
    {
    case HTC_BEHAVIOR_DESC:
        pBehaviorItem = new CHtmlComponentDesc();
        break;

    case HTC_BEHAVIOR_PROPERTY:
        pBehaviorItem = new CHtmlComponentProperty();
        break;

    case HTC_BEHAVIOR_METHOD:
        pBehaviorItem = new CHtmlComponentMethod();
        break;

    case HTC_BEHAVIOR_EVENT:
        pBehaviorItem = new CHtmlComponentEvent();
        break;

    case HTC_BEHAVIOR_ATTACH:
        pBehaviorItem = new CHtmlComponentAttach();
        break;

    case HTC_BEHAVIOR_DEFAULTS:
        pBehaviorItem = new CHtmlComponentDefaults();
        break;

    default:
        *ppBehavior = &g_HtmlComponentDummy;
        hr = S_OK;
        goto Cleanup; // done
    }

    if (!pBehaviorItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pBehaviorItem->PrivateQueryInterface(IID_IElementBehavior, (void**)ppBehavior));

Cleanup:
    if (pBehaviorItem)
        pBehaviorItem->PrivateRelease();

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentPropertyAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::CHtmlComponentPropertyAgent
//
//-------------------------------------------------------------------------

CHtmlComponentPropertyAgent::CHtmlComponentPropertyAgent(
    CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
    : CHtmlComponentAgentBase(pComponent, pClient)
{
};

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::~CHtmlComponentPropertyAgent
//
//-------------------------------------------------------------------------

CHtmlComponentPropertyAgent::~CHtmlComponentPropertyAgent()
{
    VariantClear(&_varValue);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentPropertyAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentProperty_fireChange:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentPropertyAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;

    switch (dispid)
    {
    case DISPID_CHtmlComponentProperty_fireChange:

        hr = THR(((CHtmlComponentProperty*)_pClient)->FireChange(_pComponent));

        break;

    default:

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));

        break;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentProperty
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentProperty::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCPropertyBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::Notify
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_CONTENTREADY:
            EnsureHtmlLoad(_pComponent, /* fScriptsOnly =*/TRUE);
            break;

        case BEHAVIOREVENT_DOCUMENTREADY:
            EnsureHtmlLoad(_pComponent, /* fScriptsOnly =*/FALSE);
            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::EnsureHtmlLoad
//
//  NOTES:      Points when EnsureHtmlLoad is called:
//                  1.  as soon as <property> tag parsed (contentReady notification on the property behavior).
//                      fScriptsOnly = TRUE in this case. This call makes sure that any 
//                      script below will see corresponding script var set to the value from html.
//                  2.  as soon as any script attempts to access the property on element.
//                      fScriptsOnly = FALSE in this case. This makes sure the property
//                      is not returned NULL in this case.
//                  3.  in the end of parsing the document.
//                      fScriptsOnly = FALSE in this case. This makes sure the property is loaded
//                      completely.
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::EnsureHtmlLoad(CHtmlComponent * pComponent, BOOL fScriptsOnly)
{
    HRESULT                         hr = S_OK;
    CHtmlComponentPropertyAgent *   pAgent;

    pAgent = GetAgent(pComponent);

    if (!pAgent || pAgent->_fHtmlLoadEnsured)
        goto Cleanup;

    hr = THR_NOTRACE(HtmlLoad(pComponent, fScriptsOnly));
    if (S_OK == hr || (pComponent && !pComponent->IsConstructingMarkup()))
    {
        pAgent->_fHtmlLoadEnsured = TRUE;
    }

    TraceTag((
        tagHtcPropertyEnsureHtmlLoad,
        "CHtmlComponentProperty::EnsureHtmlLoad, element SN: %ld, name: %ls, internal name: %ls, ensured: %ls",
        _pElement ? _pElement->SN() : 0,
        GetExternalName(), GetInternalName(), pAgent->_fHtmlLoadEnsured ? _T("TRUE") : _T("FALSE")));

Cleanup:
    RRETURN (hr);
}
        
//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::HtmlLoad
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::HtmlLoad(CHtmlComponent * pComponent, BOOL fScriptsOnly)
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    DISPID      dispid;

    //
    // load attribute from element
    //

    if (pComponent)
    {
        hr2 = THR_NOTRACE(pComponent->_pElement->GetExpandoDispID(GetExternalName(), &dispid, 0));
        if (S_OK == hr2)
        {
            CInvoke     invoke(GetUnknown());
            DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
            EXCEPINFO   excepInfo;

            invoke.AddArg();

            hr = THR(pComponent->_pElement->InvokeAA(
                dispid, CAttrValue::AA_Expando, LCID_SCRIPTING,
                DISPATCH_PROPERTYGET, &dispParams, invoke.Arg(0), &excepInfo, NULL));
            if (hr)
                goto Cleanup;

            invoke.AddNamedArg(DISPID_PROPERTYPUT);

            hr = THR(InvokeItem(
                pComponent, fScriptsOnly,
                LCID_SCRIPTING, DISPATCH_PROPERTYPUT,
                &invoke._dispParams, &invoke._varRes, &invoke._excepInfo, NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr;

    switch (dispid)
    {
    case DISPID_A_HTCDISPATCHITEM_VALUE:

        hr = THR_NOTRACE(InvokeItem(
            _pComponent, /* fScriptsOnly = */ FALSE,
            lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        break;

    default:
        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        break;
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::InvokeItem, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::InvokeItem(
    CHtmlComponent *    pComponent,
    BOOL                fScriptsOnly,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT                         hr = S_OK;
    DISPID                          dispid;
    BOOL                            fNameImpliesScriptsOnly;
    LPTSTR                          pchInternalName = GetInternalName(&fNameImpliesScriptsOnly, &wFlags, pDispParams);
    CScriptContext *                pScriptContext = NULL;
    CHtmlComponentPropertyAgent *   pAgent;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // first, invoke script engines
    //

    if (pComponent)
    {
        hr = pComponent->GetScriptContext(&pScriptContext);
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (_pElement->IsInMarkup())
        {
            pScriptContext = _pElement->GetMarkup()->ScriptContext();
        }
    }

    if (pScriptContext)
    {
        hr = THR_NOTRACE(InvokeEngines(
                pComponent, pScriptContext, pchInternalName,
                wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK == hr || DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;               // done
    }

    //
    // now do our own stuff
    //

    if (!fNameImpliesScriptsOnly &&
        !fScriptsOnly)
    {
        pAgent = GetAgent(pComponent);

        if (pAgent)
        {
            if (DISPATCH_PROPERTYGET & wFlags)
            {
                // see if we have a value in agent storage
                if (VT_EMPTY != V_VT(&pAgent->_varValue))
                {
                    if (!pvarRes)
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    hr = THR(VariantCopy(pvarRes, &pAgent->_varValue));

                    goto Cleanup; // done
                }

                // see if there is expando "value"
                hr = THR_NOTRACE(_pElement->GetExpandoDispID(_T("value"), &dispid, 0));
                if (hr)
                {
                    // not found, return null
                    hr = S_OK;
                    V_VT(pvarRes) = VT_NULL;
                    goto Cleanup;       // done
                }

                hr = THR(_pElement->InvokeAA(
                    dispid, CAttrValue::AA_Expando, lcid,
                    wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

                goto Cleanup; // done

            }
            else if (DISPATCH_PROPERTYPUT & wFlags)
            {
                // put an expando in agent storage

                if (!pDispParams || 
                     pDispParams->cArgs != 1 ||
                    !pDispParams->rgvarg)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

                hr = THR(VariantCopy(&pAgent->_varValue, &pDispParams->rgvarg[0]));

                goto Cleanup; // done
            }
        }
    }

Cleanup:
    if (S_OK == hr && (DISPATCH_PROPERTYPUT & wFlags))
    {
        IGNORE_HR(FireChange(pComponent));
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::fireChange, OM
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::fireChange()
{
    HRESULT     hr;

    hr = THR(FireChange(_pComponent));

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::FireChange, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::FireChange(CHtmlComponent * pComponent)
{
    HRESULT                         hr = S_OK;
    CHtmlComponentPropertyAgent *   pAgent;

    if (!pComponent)
        goto Cleanup;   // (it is legal for a prop to not have pComponent: this happens when it is used outside of HTC)

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pAgent = GetAgent(pComponent);
    if (!pAgent || !pAgent->_fHtmlLoadEnsured)
        goto Cleanup;

    hr = THR(pComponent->FirePropertyNotify(_pElement->GetSourceIndex() + DISPID_COMPONENTBASE, TRUE));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::put_value, 
//              CHtmlComponentProperty::get_value
//
//-------------------------------------------------------------------------

HRESULT CHtmlComponentProperty::put_value(VARIANT ) { Assert (0 && "not implemented"); RRETURN (E_NOTIMPL); }
HRESULT CHtmlComponentProperty::get_value(VARIANT*) { Assert (0 && "not implemented"); RRETURN (E_NOTIMPL); }

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentMethod
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentMethod::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    //QI_TEAROFF(this, IHTCMethodBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::InvokeItem, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentMethod::InvokeItem(
    CHtmlComponent *    pComponent,
    LCID                lcid,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr;
    CScriptContext *    pScriptContext;

    Assert (pComponent);

    hr = THR(pComponent->GetScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(InvokeEngines(
        pComponent, pScriptContext, GetInternalName(),
        DISPATCH_METHOD, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentMethod::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT     hr;

    if (DISPID_A_HTCDISPATCHITEM_VALUE == dispid &&
        (DISPATCH_METHOD & wFlags))
    {
        hr = THR_NOTRACE(InvokeItem(_pComponent, lcid, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
    }
    else
    {
        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
    }

    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentEventAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEventAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEventAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentEvent_fire:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEventAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEventAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;
    HRESULT             hr2;
    VARIANT *           pvarParam;
    IHTMLEventObj *     pEventObject = NULL;

    switch (dispid)
    {
    case DISPID_CHtmlComponentEvent_fire:

        //
        // extract the argument: eventObject
        //

        if (pDispParams && pDispParams->cArgs)
        {
            if ( pDispParams->cArgs != 1 ||
                !pDispParams->rgvarg)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            pvarParam = &pDispParams->rgvarg[0];

            switch (V_VT(pvarParam))
            {
            case VT_NULL:
            case VT_EMPTY:
                break;

            case VT_UNKNOWN:
            case VT_DISPATCH:
                hr2 = THR_NOTRACE(V_UNKNOWN(pvarParam)->QueryInterface(
                    IID_IHTMLEventObj, (void**)&pEventObject));
                if (hr2)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

                break;

            default:
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        //
        // fire now
        //

        hr = THR(((CHtmlComponentEvent*)_pClient)->Fire(_pComponent, pEventObject));
        if (hr)
            goto Cleanup;

        break;

    default:

        //
        // default
        //

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
        if (hr)
            goto Cleanup;

        break;

    }

Cleanup:
    ReleaseInterface(pEventObject);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAttachAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::CHtmlComponentAttachAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAttachAgent::CHtmlComponentAttachAgent(
    CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
    : CHtmlComponentAgentBase(pComponent, pClient)
{
};

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::~CHtmlComponentAttachAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAttachAgent::~CHtmlComponentAttachAgent()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttachAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentAttach_fireEvent:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttachAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;
    VARIANT *           pvarParam = NULL;

    switch (dispid)
    {
    case DISPID_CHtmlComponentAttach_fireEvent:

        //
        // extract the argument: eventObject
        //

        if (pDispParams && pDispParams->cArgs)
        {
            if (!pDispParams->rgvarg)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            pvarParam = &pDispParams->rgvarg[pDispParams->cArgs - 1];
        }

        //
        // fire now
        //

        hr = THR(((CHtmlComponentAttach*)_pClient)->FireEvent(_pComponent, pvarParam ? *pvarParam : CVariant(VT_NULL)));

        break;

    default:

        //
        // default
        //

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
        if (hr)
            goto Cleanup;

        break;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentEvent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentEvent::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCEventBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Init(IElementBehaviorSite * pSite)
{
    HRESULT     hr = S_OK;
    
    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        hr = THR(Commit(_pComponent));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Commit
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Commit(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    LPTSTR      pchName;
    LONG        lFlags;

    if (!_pElement)
        goto Cleanup;
        
    pchName = GetExternalName();

    if (pchName)
    {
        lFlags = HasExpando(_pElement, _T("bubble")) ? BEHAVIOREVENTFLAGS_BUBBLE : 0;
        
        IGNORE_HR(pComponent->_pSiteOM->RegisterEvent(pchName, lFlags, &_lCookie));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::fire, OM
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::fire(IHTMLEventObj * pEventObject)
{
    HRESULT     hr;

    hr = THR(Fire(_pComponent, pEventObject));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Fire, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Fire(CHtmlComponent * pComponent, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;

    if (!pComponent)
        goto Cleanup;

    Assert (!pComponent->_fFactoryComponent && pComponent->_pSiteOM);

    hr = THR(pComponent->_pSiteOM->FireEvent(_lCookie, pEventObject));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAttach
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentAttach::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCAttachBehavior, NULL)
    QI_TEAROFF(this, IHTCAttachBehavior2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Init(IElementBehaviorSite * pSite)
{
    HRESULT     hr;

    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    hr = THR(_pSite->QueryInterface(CLSID_CPeerHolderSite, (void**)&_pSiteOM));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Passivate, virtual
//
//-------------------------------------------------------------------------

void
CHtmlComponentAttach::Passivate()
{
    _pSiteOM = NULL; // _pSiteOM is a private weak ref

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetExternalName, virtual helper
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentAttach::GetExternalName()
{
    return GetExpandoString(_pElement, _T("EVENT"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetEventSource
//
//-------------------------------------------------------------------------

CBase *
CHtmlComponentAttach::GetEventSource(CHtmlComponent * pComponent, BOOL fInit)
{
    HRESULT     hr;
    CBase *     pSource = NULL;
    LPTSTR      pchFor;
    LPTSTR      pchEvent;

    pchFor = GetExpandoString(_pElement, _T("for"));
    if (pchFor)
    {
        if (0 == StrCmpIC(_T("window"), pchFor))                    // window
        {
            if (fInit && pComponent->_pElement->IsInMarkup())
            {
                pSource = pComponent->_pElement->GetFrameOrPrimaryMarkup()->Window();
            }
        }
        else if (0 == StrCmpIC(_T("document"), pchFor))             // document
        {
            if (fInit && pComponent->_pElement->IsInMarkup())
            {
                CMarkup *   pMarkup = pComponent->_pElement->GetMarkup();

                if (pMarkup)
                {
                    hr = THR(pMarkup->EnsureDocument((CDocument**)&pSource));
                    if (hr)
                        goto Cleanup;
                }
            }
        }
        else if (0 == StrCmpIC(_T("element"), pchFor))              // element
        {
            pSource = pComponent->_pElement;
        }
    }
    else
    {
        pSource = pComponent->_pElement;
    }

    /// reset pSource for any peer notifications if the source is specified to be the element
    if (pSource && pSource == pComponent->_pElement)
    {
        pchEvent = GetExternalName();

        if (pchEvent && CNotifications::Find(pchEvent))
        {
            pSource = NULL;
        }
    }

Cleanup:

    return pSource;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetEventHandler
//
//-------------------------------------------------------------------------

IDispatch *
CHtmlComponentAttach::GetEventHandler(CHtmlComponent * pComponent)
{
    HRESULT             hr;
    IDispatch *         pdispHandler = NULL;
    LPTSTR              pchHandler;
    CScriptContext *    pScriptContext;

    pchHandler = GetExpandoString(_pElement, _T("handler"));
    if (!pchHandler)
        goto Cleanup;

    //
    // get IDispatch from script engines
    //

    {
        VARIANT     varRes;
        DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
        EXCEPINFO   excepInfo;

        hr = THR(pComponent->GetScriptContext(&pScriptContext));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(InvokeEngines(
            pComponent, pScriptContext, pchHandler,
            DISPATCH_PROPERTYGET, &dispParams, &varRes, &excepInfo, NULL));
        if (hr)
            goto Cleanup;

        if (VT_DISPATCH != V_VT(&varRes))
            goto Cleanup;

        pdispHandler = V_DISPATCH(&varRes);
    }

Cleanup:

    return pdispHandler;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::CreateEventObject
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::CreateEventObject(VARIANT varArg, IHTMLEventObj ** ppEventObject)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    IHTMLEventObj2 *    pEventObject2 = NULL;
    IHTMLStyle2 *       pStyle = NULL;
    TCHAR *             pchEventName = GetExternalName();

    Assert (ppEventObject);

    hr = THR(_pSiteOM->CreateEventObject(ppEventObject));
    if (hr)
        goto Cleanup;

    hr = THR((*ppEventObject)->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObject2));
    if (hr)
        goto Cleanup;

    // Make sure we only set properties that correspond to the appropriate event
    if( pchEventName )
    {
        CNotifications::CItem const *     pNotification;

        pNotification = CNotifications::Find( pchEventName );
        if( pNotification )
        {
            if( pNotification->_lEvent == BEHAVIOREVENT_APPLYSTYLE &&
                ( ( V_VT(&varArg) == VT_DISPATCH && V_DISPATCH(&varArg) ) ||
                  ( V_VT(&varArg) == VT_UNKNOWN  && V_UNKNOWN(&varArg) ) ) )
            {
                // if the argument is a style object
                hr2 = THR_NOTRACE(V_UNKNOWN(&varArg)->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle));
                if (S_OK == hr2)
                {
                    hr = THR(pEventObject2->setAttribute(_T("style"), varArg, 0));
                    if (hr)
                        goto Cleanup;
                }
            }
            else if( pNotification->_lEvent == BEHAVIOREVENT_CONTENTSAVE &&
                     V_VT(&varArg) == VT_BSTR &&
                     V_BSTR(&varArg) )
            {
                hr = THR(pEventObject2->setAttribute(_T("saveType"), varArg, 0));
                if( hr )
                    goto Cleanup;
            }
        }
    }

Cleanup:
    ReleaseInterface (pEventObject2);
    ReleaseInterface (pStyle);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireHandler
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireHandler(
    CHtmlComponent *    pComponent,
    IHTMLEventObj *     pEventObject,
    BOOL                fReuseCurrentEventObject)
{
    HRESULT hr;

	// NOTE any change here might have to be mirrored in CPeerHolder::CPeerSite::FireEvent

    if (fReuseCurrentEventObject)
    {
        hr = THR(FireHandler2(pComponent, NULL));
    }
    else if (pEventObject)
    {
        CEventObj::COnStackLock onStackLock(pEventObject);

        hr = THR(FireHandler2(pComponent, pEventObject));
    }
    else
    {
        AssertSz(_pElement && _pElement->Doc(),"Possible Async Problem Causing Watson Crashes");
        EVENTPARAM param(_pElement->Doc(), _pElement, NULL, TRUE);

        hr = THR(FireHandler2(pComponent, pEventObject));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireHandler2
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireHandler2(CHtmlComponent * pComponent, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;
    IDispatch * pdispHandler = GetEventHandler(pComponent);

    if (pdispHandler)
    {
        CInvoke     invoke(pdispHandler);
        VARIANT *   pvar;

        if (pEventObject)
        {
            hr = THR(invoke.AddArg());
            if (hr)
                goto Cleanup;

            pvar = invoke.Arg(0);
            V_VT(pvar) = VT_DISPATCH;
            V_DISPATCH(pvar) = pEventObject;
            V_DISPATCH(pvar)->AddRef();
        }
        
        hr = THR(invoke.Invoke(DISPID_VALUE, DISPATCH_METHOD));
    }

Cleanup:
    ReleaseInterface(pdispHandler);
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::fireEvent, OM
//
//  Note (JHarding): There's some slightly sneaky stuff going on here:
//  In IE5, we shipped the IHTCAttachBehavior, which contained fireEvent
//  taking an IDispatch pointer.  We have to maintain this for early-bound
//  clients, but for scripting clients, we want them to get a new version
//  that takes a VARIANT (this argument may be added as an expando to
//  the event object in certain cases).
//  The solution is to maintain the IHTCAttachBehavior interface as it
//  was, and add an IHTCAttachBehavior2, which contains a new version
//  of fireEvent taking a VARIANT.
//  Then, we tweak the mondo dispatch such that the old fireEvent is
//  replaced with the new one.
//  Executive summary:  Dispatch clients will get the new fireEvent, 
//  where the IDispatch* they were passing before gets happily converted
//  to a VARIANT.  Additionally, they can now pass strings, etc. as
//  required by new events.  Early bound clients will access the new
//  functionality by using the version on IHTCAttachBehavior2.
//  Internally, these are fireEventOld and fireEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::fireEventOld(IDispatch * pdispArg)
{
    HRESULT     hr;
    CVariant    vt(VT_DISPATCH);

    V_DISPATCH(&vt) = pdispArg;
    if( pdispArg )
    {
        pdispArg->AddRef();
    }
    hr = THR(FireEvent(_pComponent, vt));

    RRETURN(hr);
}

HRESULT
CHtmlComponentAttach::fireEvent(VARIANT varArg)
{
    HRESULT hr;

    hr = THR(FireEvent(_pComponent, varArg));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireEvent(
    CHtmlComponent *            pComponent,
    VARIANT                     varArg)
{
    HRESULT                     hr = S_OK;
    LONG                        lCookie;
    IDispatch *                 pdispContext = NULL;
    BOOL                        fReuseCurrentEventObject = FALSE;
    IHTMLEventObj *             pEventObject = NULL;

    TraceTag((tagHtcAttachFireEvent, "CHtmlComponentAttach::FireEvent, event: %ls, %lx", GetExternalName(), this));
    
    if ( pComponent && 
         pComponent->_pElement && 
         !pComponent->_pElement->IsPassivating() && 
         pComponent->_pElement->GetWindowedMarkupContext()->HasWindowPending() )
    {
        CLock lockComponent(pComponent);
    
        //
        // setup parameters
        //

        // event object
        if (_fEvent)
        {
            fReuseCurrentEventObject = TRUE;
        }
        else
        {
            hr = THR(CreateEventObject(varArg, &pEventObject));
            if (hr)
                goto Cleanup;
        }

        // pdispContext
        if (!pComponent->_fSharedMarkup)
        {
            if (!_pElement)
                goto Cleanup;

            hr = THR(_pElement->PrivateQueryInterface(IID_IDispatch, (void**)&pdispContext));
            if (hr)
                goto Cleanup;
        }
        else
        {
            pdispContext = GetAgent(pComponent);
            if (!pdispContext)
                goto Cleanup;

            pdispContext->AddRef();
        }
        Assert (pdispContext);

        //
        // fire
        //

        hr = THR(_pSiteOM->GetEventCookie(_T("onevent"), &lCookie));
        if (hr)
            goto Cleanup;

        hr = THR(_pSiteOM->FireEvent(lCookie, pEventObject, fReuseCurrentEventObject, pdispContext));
        if (hr)
            goto Cleanup;

        IGNORE_HR(FireHandler(pComponent, pEventObject, fReuseCurrentEventObject));
    }

Cleanup:
    ReleaseInterface(pdispContext);
    ReleaseInterface(pEventObject);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Attach
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Attach(CHtmlComponent * pComponent, BOOL fInit)
{
    HRESULT                     hr = S_OK;
    CBase *                     pEventSource;
    LPTSTR                      pchEventName;
    BSTR                        bstrEventName = NULL;
    CNotifications::CItem const * pNotification;
    IDispatch *                 pdispSink = NULL;

    if (!pComponent)
        goto Cleanup;

    if (!pComponent->_fSharedMarkup)
    {
        hr = THR(PrivateQueryInterface(IID_IDispatch, (void**)&pdispSink));
        if (hr)
            goto Cleanup;
    }
    else
    {
        pdispSink = GetAgent(pComponent);
        if (!pdispSink)
            goto Cleanup;

        pdispSink->AddRef();
    }

    Assert (pdispSink);

    pchEventName = GetExternalName();
    if (!pchEventName)
        goto Cleanup;

    pEventSource = GetEventSource(pComponent, fInit);

    if (fInit)
    {
        CPeerHolder::CPeerSite *pSite;

        if (pComponent->_fSharedMarkup)
        {
            Assert(pComponent->_pConstructor->_pFactoryComponent->_fLightWeight);
            hr = THR(_pSiteOM->QueryInterface(CLSID_CPeerHolderSite, (void**)&pSite));
            if (hr)
                goto Cleanup;

            hr = THR(pSite->RegisterEventHelper(_T("onevent"), 0, NULL, pComponent));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(_pSiteOM->RegisterEvent(_T("onevent"), 0, NULL));
            if (hr)
                goto Cleanup;
        }
    }

    _fEvent = (NULL != pEventSource);

    if (pEventSource)
    {
        //
        // attach to element / document / window events
        //

        hr = THR(FormsAllocString(pchEventName, &bstrEventName));
        if (hr)
            goto Cleanup;

        if (fInit)
        {
            IGNORE_HR(pEventSource->attachEvent(bstrEventName, (IDispatch*)pdispSink, NULL));
        }
        else
        {
            IGNORE_HR(pEventSource->detachEvent(bstrEventName, (IDispatch*)pdispSink));
        }
    }
    else // if (!pEventSource)
    {
        //
        // attach to behavior-specific notifications
        //

        if (fInit)
        {
            pNotification = CNotifications::Find(pchEventName);
            if (pNotification)
            {
                if (-1 != pNotification->_dispidInternal)
                {
                    hr = THR(pComponent->AttachNotification(pNotification->_dispidInternal, pdispSink));
                    if (hr)
                        goto Cleanup;
                }

                if (-1 != pNotification->_lEvent)
                {
                    hr = THR(pComponent->_pSite->RegisterNotification(pNotification->_lEvent));
                }
            }
        }
    }
    
Cleanup:
    FormsFreeString(bstrEventName);
    ReleaseInterface(pdispSink);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Notify
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_DOCUMENTREADY:

            Assert (S_OK == TestProfferService());

            IGNORE_HR(Attach(_pComponent, /* fInit = */ TRUE));

            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::detachEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::detachEvent()
{
    HRESULT     hr;

    hr = THR(DetachEvent(_pComponent));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::DetachEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::DetachEvent(CHtmlComponent * pComponent)
{
    HRESULT                     hr = S_OK;
    LPTSTR                      pchName;

    if (!pComponent)
        goto Cleanup;

    pchName = GetExternalName();
    if (!pchName)
        goto Cleanup;

    if (0 == StrCmpIC(_T("onDetach"), pchName))
    {
        IGNORE_HR(FireEvent(pComponent, CVariant(VT_NULL)));
    }

    hr = THR(Attach(pComponent, /* fInit = */ FALSE));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDesc
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDesc::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDesc::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    switch (lEvent)
    {
    case BEHAVIOREVENT_DOCUMENTREADY:

        if (_pComponent && !_pComponent->IsSkeletonMode())
        {
            hr = THR(Commit(_pComponent));
        }

        break;
    }
    
Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDesc::Commit, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDesc::Commit(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    LPTSTR      pch;

    if (!pComponent || pComponent->IsSkeletonMode())
        goto Cleanup;

    pch = GetExpandoString(_pElement, _T("urn"));
    if (pch)
    {
        hr = THR(pComponent->_pSiteOM->RegisterUrn(pch));
        if (hr)
            goto Cleanup;
    }

    pch = GetExpandoString(_pElement, _T("name"));
    if (pch)
    {
        hr = THR(pComponent->_pSiteOM->RegisterName(pch));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDefaults
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_CONTENTREADY:

            hr = THR(Commit1(_pComponent));

            break;

        case BEHAVIOREVENT_DOCUMENTREADY:

            hr = THR(Commit2(_pComponent));

            break;
        }
    }
    
Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Commit1, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Commit1(CHtmlComponent * pComponent)
{
    HRESULT                 hr = S_OK;
    IDispatch *             pdispDefaults = NULL;
    CDefaults *             pDefaults = NULL;
    BOOL                    fDefStyle;
    BOOL                    fDefProps;

    Assert (_pElement);

    //
    // access to Defaults object 
    // TODO(alexz) don't ensure it if we have no properties
    //

    hr = THR(pComponent->_DD.get_defaults(&pdispDefaults));
    if (hr)
        goto Cleanup;

    hr = THR(pdispDefaults->QueryInterface(CLSID_HTMLDefaults, (void**)&pDefaults));
    if (hr)
        goto Cleanup;

    //
    // copy the defaults
    //

    hr = THR(CommitStyle(pComponent, pDefaults, &fDefStyle));
    if (hr)
        goto Cleanup;

    hr = THR(CommitHelper(pDefaults, &fDefProps));
    if (hr)
        goto Cleanup;

    if (fDefProps || fDefStyle)
    {
        // (JHarding): We were doing an OnCSSChange, which was basically invalidating
        // the entire markup here.  Bad.  We should just have to clear the caches and
        // force a relayout of the element.
        hr = THR(pComponent->_pElement->ClearRunCaches(ELEMCHNG_CLEARCACHES));
        if( hr )
            goto Cleanup;
        pComponent->_pElement->ResizeElement();
    }

Cleanup:

    ReleaseInterface(pdispDefaults);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Commit2, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Commit2(CHtmlComponent * pComponent)
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2;
    BOOL                        f;
    CMarkup *                   pMarkup;
    CDocument *                 pDocument;
    IHTMLDocument *             pDocFragment = NULL;
    IHTMLElementDefaults *      pElementDefaults = NULL;

    Assert (pComponent);
    Assert (_pElement);

    // ( viewLinkContent is only allowed for HTCs that don't share markup )
    if (!pComponent->_fSharedMarkup)
    {
        // While printing, we persist & reviewlink HTC content.
        // HTCs can currently viewlink two ways:
        //  1. PUBLIC component     blocked here.
        //  2. Script               blocked by CMarkup::DontRunScripts
        pMarkup = pComponent->GetMarkup();
        if (!pMarkup->IsPrintMedia())
        {
        
            hr2 = GetExpandoBoolHr(_pElement, _T("viewLinkContent"), &f);
            if (S_OK == hr2 && f)
            {
                Assert (READYSTATE_COMPLETE == pComponent->GetReadyState());

                hr = THR(pComponent->_pSiteOM->GetDefaults(&pElementDefaults));
                if (hr)
                    goto Cleanup;

                hr = THR(pMarkup->EnsureDocument(&pDocument));
                if (hr)
                    goto Cleanup;

                hr = THR(pDocument->QueryInterface(IID_IHTMLDocument, (void **)&pDocFragment));
                if (hr)
                    goto Cleanup;

                hr = THR(pElementDefaults->put_viewLink(pDocFragment));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:

    ReleaseInterface (pElementDefaults);
    ReleaseInterface (pDocFragment);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::CommitStyle, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::CommitStyle(CHtmlComponent * pComponent, CDefaults * pDefaultsTarget, BOOL *pfDefStyle)
{
    HRESULT         hr = S_OK;
    CAttrArray *    pAASource;
    CAttrArray **   ppAATarget;
    CStyle *        pStyleTarget;

    Assert (pComponent && pComponent->_pElement);
    Assert (_pElement);
    Assert (pDefaultsTarget);
    Assert (pfDefStyle);

    *pfDefStyle = FALSE;

    //
    // get source AA
    //

    pAASource = _pElement->GetInLineStyleAttrArray();
    if (!pAASource)
        goto Cleanup;

    //
    // get target AA
    //

    hr = THR(pDefaultsTarget->EnsureStyle(&pStyleTarget));
    if (hr)
        goto Cleanup;

    ppAATarget = pStyleTarget->GetAttrArray();
    if (!ppAATarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // merge now and make sure the style is invalidated
    //

    hr = THR(pAASource->Merge(ppAATarget, NULL, NULL));
    if (hr)
        goto Cleanup;

    *pfDefStyle = TRUE;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::CommitHelper, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::CommitHelper(CDefaults * pDefaults, BOOL *pfDefProps)
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    BOOL            f;
    LONG            l;
    htmlEditable    editable;

    Assert (_pElement);
    Assert (pfDefProps);

    //
    // TODO (alexz) do this in a generic way
    //

    *pfDefProps = FALSE;
    editable = _pElement->GetAAcontentEditable();

    if (htmlEditableInherit != editable)
    {
        hr = THR(pDefaults->SetAAcontentEditable(editable));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("tabStop"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAtabStop((short) f));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("isMultiLine"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAisMultiLine((short) f));
        if (hr)
            goto Cleanup;

        if (!f)
        {
            CStyle *pDefaultStyle;
            CAttrArray *pDefaultStyleAA;
            CAttrArray **ppDefaultStyleAA;

            hr = THR(pDefaults->EnsureStyle(&pDefaultStyle));
            if (hr)
                goto Cleanup;

            Assert(pDefaultStyle);
            ppDefaultStyleAA = pDefaultStyle->GetAttrArray();
            if (!ppDefaultStyleAA)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pDefaultStyleAA = *ppDefaultStyleAA;
            hr = THR(CAttrArray::SetSimple(&pDefaultStyleAA, (const PROPERTYDESC *)&s_propdescCStylewhiteSpace,
                                           styleWhiteSpaceNowrap, 0));
            if (hr)
                goto Cleanup;
        }
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("canHaveHtml"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAcanHaveHTML((short) f));
        if (hr)
            goto Cleanup;
    }
    
    hr2 = GetExpandoLongHr(_pElement, _T("scrollSegmentX"), &l);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAscrollSegmentX(l));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoLongHr(_pElement, _T("scrollSegmentY"), &l);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAscrollSegmentY(l));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("viewMasterTab"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAviewMasterTab((short) f));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("viewInheritStyle"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAviewInheritStyle((short) f));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("frozen"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAfrozen((short) f));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Proffer service testing, DEBUG ONLY code
//
///////////////////////////////////////////////////////////////////////////

#if DBG == 1

const IID IID_IProfferTest = {0x3050f5d7, 0x98b5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B};

class CProfferTestObj : public IServiceProvider
{
public:
    CProfferTestObj() { _ulRefs = 1; }
    DECLARE_FORMS_STANDARD_IUNKNOWN(CProfferTestObj);
    STDMETHOD(QueryService)(REFGUID rguidService, REFIID riid, void ** ppv);
};

HRESULT
CProfferTestObj::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IProfferTest))
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }

    Assert (0 && "CProfferTestObj should never be QI-ed with anything but IID_IProfferTest");

    return E_NOTIMPL;
}

HRESULT
CProfferTestObj::QueryService(REFGUID rguidService, REFIID riid, void ** ppv)
{
    Assert (IsEqualGUID(rguidService, riid));
    RRETURN (QueryInterface(riid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::TestProfferService, DEBUG ONLY code
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::TestProfferService()
{
    HRESULT             hr = S_OK;
    IServiceProvider *  pSP = NULL;
    IProfferService *   pProfferService = NULL;
    DWORD               dwServiceCookie;
    IUnknown *          pTestInterface = NULL;
    IUnknown *          pTestInterface2 = NULL;
    CProfferTestObj *   pProfferTest = NULL;

    if (!_pComponent || !_pComponent->_pElement)
        goto Cleanup;

    pProfferTest = new CProfferTestObj();
    if (!pProfferTest)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // register the interface with HTC
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR(pSP->QueryService(SID_SProfferService, IID_IProfferService, (void**)&pProfferService));
    if (hr)
        goto Cleanup;

    hr = THR(pProfferService->ProfferService(IID_IProfferTest, pProfferTest, &dwServiceCookie));
    if (hr)
        goto Cleanup;

    //
    // verify the interface is QI-able from HTC behavior and properly thunked
    //

    hr = THR(_pComponent->_pElement->GetPeerHolder()->QueryPeerInterfaceMulti(
        IID_IProfferTest, (void**)&pTestInterface, /* fIdentityOnly = */FALSE));
    if (hr)
        goto Cleanup;

    pTestInterface->AddRef();
    pTestInterface->Release();

    hr = THR(pTestInterface->QueryInterface(IID_IProfferTest, (void**)&pTestInterface2));
    if (hr)
        goto Cleanup;

    pTestInterface2->AddRef();
    pTestInterface2->Release();

Cleanup:
    ReleaseInterface (pSP);
    ReleaseInterface (pProfferService);
    ReleaseInterface (pTestInterface);
    ReleaseInterface (pTestInterface2);
    if (pProfferTest)
        pProfferTest->Release();

    RRETURN(hr);
}

#endif

///////////////////////////////////////////////////////////////////////////
//
// CProfferService
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CProfferService constructor
//
//-------------------------------------------------------------------------

CProfferService::CProfferService()
{
    _ulRefs = 1;
};

//+------------------------------------------------------------------------
//
//  Member:     CProfferService destructor
//
//-------------------------------------------------------------------------

CProfferService::~CProfferService()
{
    int i, c;

    for (i = 0, c = _aryItems.Size(); i < c; i++)
    {
        delete _aryItems[i];
    }

    _aryItems.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CProfferService::QueryInterface(REFIID iid, void **ppv)
{

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IProfferService)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::ProfferService, per IProfferService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::ProfferService(REFGUID rguidService, IServiceProvider * pSP, DWORD * pdwCookie)
{
    HRESULT                 hr;
    CProfferServiceItem *   pItem;

    pItem = new CProfferServiceItem(rguidService, pSP);
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_aryItems.Append(pItem));
    if (hr)
        goto Cleanup;

    if (!pdwCookie)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pdwCookie = _aryItems.Size() - 1;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::RevokeService, per IProfferService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::RevokeService(DWORD dwCookie)
{
    if ((DWORD)_aryItems.Size() <= dwCookie)
    {
        RRETURN (E_INVALIDARG);
    }

    delete _aryItems[dwCookie];
    _aryItems[dwCookie] = NULL;

    RRETURN (S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::QueryService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::QueryService(REFGUID rguidService, REFIID riid, void ** ppv)
{
    CProfferServiceItem *   pItem;
    int                     i, c;

    for (i = 0, c = _aryItems.Size(); i < c; i++)
    {
        pItem = _aryItems[i];
        if (pItem && IsEqualGUID(pItem->_guidService, rguidService))
        {
            RRETURN (pItem->_pSP->QueryService(rguidService, riid, ppv));
        }
    }

    RRETURN (E_NOTIMPL);
}

HRESULT
CHtmlComponent::EnsureCustomNames()
{
    HRESULT hr = S_OK;

    if (!_pCustomNames)
    {
        _pCustomNames = new CStringTable(CStringTable::CASEINSENSITIVE);
        if (!_pCustomNames)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    RRETURN (hr);
}

void CHtmlComponent::AddAtom(LPTSTR pchName, LPVOID pv)
{
    HRESULT hr;
    Assert(pchName);
    Assert(_fFactoryComponent);

    hr = THR(EnsureCustomNames());
    if (hr)
        return;

    IGNORE_HR(_pCustomNames->Add(pchName, pv, NULL, FALSE));
}

long CHtmlComponent::FindIndexFromName(LPTSTR pchName, BOOL fCaseSensitive)
{
    CHtmlComponent *pFactory = _pConstructor->_pFactoryComponent;
    CElement *pel = NULL;
    LONG_PTR idx = -1;

    if (pFactory->_pCustomNames)
    {
        HRESULT hr;
        LPCTSTR pActualName = NULL;
        Assert(pchName);

        hr = THR(pFactory->_pCustomNames->Find(pchName, pFactory->_fLightWeight ? (LPVOID*)&pel : (LPVOID*)&idx, NULL, fCaseSensitive ? &pActualName : NULL));
        if (hr || (pActualName && StrCmpC(pActualName, pchName)))
        {
            // No such name exists, or name is not a case sensitive match, bail out
            idx = -1;
            goto Cleanup;
        }

        if (pFactory->_fLightWeight)
        {
            if ((LONG_PTR)pel < HTC_PROPMETHODNAMEINDEX_BASE)
            {
                // Custom Event dispid, bail out
                Assert(idx == -1);
                goto Cleanup;
            }

            if (pel && (HTC_BEHAVIOR_PROPERTYORMETHOD & TagNameToHtcBehaviorType(pel->TagName())))
            {
                Assert(pel->GetMarkup() == pFactory->_pMarkup);
                idx = pel->GetSourceIndex();
            }
            else
            {
                // Not a htc property or method, bail out
                Assert(idx == -1);
                goto Cleanup;
            }
        }
        else
        {
            Assert(idx != -1);
            Assert(!_fFactoryComponent);
            if (idx < HTC_PROPMETHODNAMEINDEX_BASE)
            {
                // Custom Event dispid, bail out
                idx = -1;
                goto Cleanup;
            }

            idx -= HTC_PROPMETHODNAMEINDEX_BASE;
        }

        Assert(idx != -1);
    }

Cleanup:
    return idx;
}

long CHtmlComponent::FindEventCookie(LPTSTR pchEvent)
{
    long idx = -1;

    Assert(_fFactoryComponent);
    if (_pCustomNames)
    {
        HRESULT hr;
        Assert(pchEvent);

        hr = THR(_pCustomNames->Find(pchEvent, (LPVOID*)&idx));
        if (hr)
            idx = -1;
    }

    return idx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\logmgr.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_MARKUP_HXX
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif 

#ifndef X_STYLE_HXX
#define X_STYLE_HXX
#include "style.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif // X_GENERIC_HXX_



MtDefine(CLogManager_ChangeRecord_pv, Tree, "CLogManager::ChangeRecord_pv");
MtDefine(CLogManager_aryLogs_pv, Tree, "CLogManager::_aryLogs_pv");
MtDefine(CLogManager_aryfElemInTree, Locals, "CLogManager::ConvertChunksToRecords data array");

DeclareTag(tagTraceTreeSync, "TreeSync", "Trace TreeSync actions");

CLogManager::CLogManager( CMarkup * pMarkup ) 
    : _aryLogs(Mt(CLogManager_aryLogs_pv))
{
    TraceTag((tagTraceTreeSync, "TreeSync: Creating Log Manager"));

    _pMarkup = pMarkup;
    _dwFlags = 0;
    pMarkup->QueryService( IID_ISequenceNumber, IID_ISequenceNumber, (void **)&_pISequencer );
    _nSequenceNumber = _pISequencer ? -1 : 0;

    // Set up the queue
    _pchrecHead = _pchrecTail = NULL;
}

CLogManager::~CLogManager()
{
    TraceTag((tagTraceTreeSync, "TreeSync: Destroying Log Manager"));

    // Kill any outstanding callback we may have posted
    if( TestCallbackPosted() )
    {
        ClearCallbackPosted();
        GWKillMethodCall( this, ONCALL_METHOD(CLogManager, NotifySinksCallback, notifysinkscallback), 0 );
    }

    DisconnectFromMarkup();
    Assert( _aryLogs.Size() == 0 && _pchrecHead == NULL && _pchrecTail == NULL );

    ReleaseInterface( _pISequencer );
}


/*******************************************************************/
/*                  Record creation functions                      */
/*******************************************************************/

//+----------------------------------------------------------------+
//
//  Method: InsertText
//
//  Synopsis: Creates and appends a Change Record for an Insert
//      Text operation.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertText( long cp, long cch, const TCHAR * pchText )
{
    HRESULT                     hr = S_OK;
    CChangeRecord_TextChange *  pchrec;
    long                        cchRec = TestForward() ? cch : 0;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: InsertText - cp=%d; cch=%d;", cp, cch));

    // Allocate our record
    pchrec = (CChangeRecord_TextChange *)MemAlloc(Mt(CLogManager_ChangeRecord_pv), 
                                                  sizeof(CChangeRecord_TextChange) +  // A Text Change Record
                                                  ( ( cchRec ) * sizeof( TCHAR ) ) ); // And a buffer of text
    if( !pchrec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchrec->_opcode  = CHANGE_RECORD_OPCODE( CHANGE_RECORD_INSERTTEXT | DirFlags() );
    pchrec->_cp      = cp;
    pchrec->_cch     = cch;

    if( TestForward() )
    {
        // copy in the text buffer
        memcpy( (BYTE *)pchrec + sizeof( CChangeRecord_TextChange ), pchText, ( cch ) * sizeof( TCHAR ) );
    }
    
    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: InsertOrRemoveElement
//
//  Synopsis: Creates and appends a Change Record for an Insert 
//      Element or Remove Element operation.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertOrRemoveElement( BOOL fInsert, long cpBegin, long cpEnd, CElement *pElement )
{
    HRESULT                         hr      = S_OK;
    CChangeRecord_ElemChange    *   pchrec  = NULL;
    BSTR                            bstr    = NULL;
    long                            cchElem = 0;
    CGenericElement             *   pGenericElement = NULL;
    long                            cchLiteralContent = 0;
    BOOL                            fRecordElem = fInsert ? TestForward() : TestBackward();
    BYTE *                          pBuff;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: Ins/Rem Element - fIns=%d; cpBegin=%d; cpEnd=%d; pElement=%lx", fInsert, cpBegin, cpEnd, pElement));

    if( fRecordElem )
    {
        // First we have to save the element to know how much memory to allocate
        hr = THR( SaveElementToBstr( pElement, &bstr ) );
        if( hr )
            goto Cleanup;

        cchElem = SysStringLen( bstr );

        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
       if( pElement->Tag() == ETAG_GENERIC_LITERAL )
        {
            pGenericElement = DYNCAST(CGenericElement, pElement);

            cchLiteralContent = pGenericElement->_cstrContents.Length();
        }
    }

    // Allocate our record
    pchrec = (CChangeRecord_ElemChange *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                      sizeof( CChangeRecord_ElemChange ) +
                                                      cchElem * sizeof( TCHAR ) +
                                                      ( cchLiteralContent ? ( cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) ) : 0 ) );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set its fields
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( ( fInsert ? CHANGE_RECORD_INSERTELEM : CHANGE_RECORD_REMOVEELEM ) | 
                                               DirFlags() | 
                                               ( cchLiteralContent ? CHANGE_RECORD_EXTENDED : 0 ) );
    pchrec->_cpBegin   = cpBegin;
    pchrec->_cpEnd     = cpEnd;
    pchrec->_cchElem   = cchElem;

    if( fRecordElem )
    {
        // Copy the string in
        memcpy( (BYTE *)pchrec + sizeof( CChangeRecord_ElemChange ), bstr, pchrec->_cchElem * sizeof( TCHAR ) );

        // If necessary, copy literal content
        if( cchLiteralContent )
        {
            Assert( pGenericElement );

            pBuff = (BYTE *)pchrec + sizeof( CChangeRecord_ElemChange ) + pchrec->_cchElem * sizeof( TCHAR );
            *(long *)pBuff = cchLiteralContent;
            pBuff += sizeof(long);

            memcpy( pBuff, pGenericElement->_cstrContents, cchLiteralContent * sizeof( TCHAR ) );
        }

        if( pElement->_fBreakOnEmpty )
        {
            pchrec->_opcode = CHANGE_RECORD_OPCODE( pchrec->_opcode | CHANGE_RECORD_BREAKONEMPTY );
        }
    }

    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    SysFreeString( bstr );
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: RemoveSplice
//
//  Synopsis: Creates and appends a Change Record for a Remove
//      Splice operation
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::RemoveSplice( long                     cpBegin, 
                           long                     cpEnd, 
                           CSpliceRecordList    *   paryRegion, 
                           TCHAR                *   pchRemoved,
                           long                     cchRemoved )
{
    HRESULT                         hr = S_OK;
    long                            nRecSize;
    long                            crec = 0;
    CChangeRecord_Splice        *   pchrec;
    
    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    Assert( !TestBackward() || ( paryRegion && pchRemoved ) );
    TraceTag((tagTraceTreeSync, "TreeSync: RemoveSplice - cpBegin=%d; cpEnd=%d", cpBegin, cpEnd));

    // Allocate our buffer
    nRecSize = sizeof( CChangeRecord_Splice );
    pchrec = (CChangeRecord_Splice *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nRecSize );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set up the record
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( CHANGE_RECORD_REMOVESPLICE | DirFlags() );
    pchrec->_cpBegin   = cpBegin;
    pchrec->_cpEnd     = cpEnd;

    if( TestBackward() )
    {
        hr = THR( ConvertRecordsToChunks( NULL, paryRegion, pchRemoved, &pchrec, &nRecSize, &crec ) );
        if( hr )
            goto Cleanup;
    }

    // Note the size, so we don't have to walk this whole structure to count it.
    pchrec->_cb = nRecSize - sizeof(CChangeRecordBase *);
    pchrec->_crec = crec;

    AppendRecord( pchrec );

    PostCallback();

Cleanup:

    if( hr )
    {
        MemFree( pchrec );
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: InsertSplice
//
//  Synopsis: Creates and appends a Change Record for a Insert
//      Splice operation
//
//  TODO (JHarding):
//  If it turns out that calling MemRealloc is causing a
//  bottleneck, we can use a more efficient allocation pattern
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertSplice( long cp, long cch, TCHAR * pch, CSpliceRecordList * paryLeft, CSpliceRecordList * paryInside )
{
    HRESULT                         hr = S_OK;
    CChangeRecord_Splice        *   pchrec;
    long                            nRecSize;
    long                            crec = 0;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: InsertSplice - cpBegin=%d; cch=%d", cp, cch));

    // We'll start our record out at the size of an InsertSplice record
    nRecSize = sizeof( CChangeRecord_Splice );
    pchrec = (CChangeRecord_Splice *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nRecSize );

    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set up the fixed Change Record
    pchrec->_opcode    = CHANGE_RECORD_OPCODE( CHANGE_RECORD_INSERTSPLICE | DirFlags() );
    pchrec->_cpBegin   = cp;
    pchrec->_cpEnd     = cp + cch;
    // We'll set up _cb later when we know the real size

    if( TestForward() )
    {
        hr = THR( ConvertRecordsToChunks( paryLeft, paryInside, pch, &pchrec, &nRecSize, &crec ) );
        if( hr )
            goto Cleanup;
    }

    // Note the size, so we don't have to walk this whole structure to count it.
    pchrec->_cb = nRecSize - sizeof(CChangeRecordBase *);
    pchrec->_crec = crec;

    AppendRecord( pchrec );

    PostCallback();

Cleanup:

    if( hr )
    {
        MemFree( pchrec );
    }
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: AttrChangeProp
//
//  Synopsis: Creates a change record for a property change on an
//      element
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::AttrChangeProp( CElement * pElement, CBase * pBase, ATTR_CHANGE_FLAGS lFlags, DISPID dispid, VARIANT * pVarOld, VARIANT * pVarNew )
{
    HRESULT                         hr;
    IDispatchEx                 *   pDisp   = NULL;
    BSTR                            bstr    = NULL;
    CChangeRecord_AttrChange    *   pchrec  = NULL;
    long                            cp;
    CTreePos                    *   ptpBegin;
    BYTE                        *   pb;
    VARIANT                         varTemp;
    BSTR                            bstrOld = NULL;
    BSTR                            bstrNew = NULL;

    WHEN_DBG( ValidateQueue() );
    Assert( IsAnyoneListening() );
    TraceTag((tagTraceTreeSync, "TreeSync: AttrChange - pElement=%lx; pBase=%lx; lFlags=%lx; dispid=%lx", pElement, pBase, lFlags, dispid));

    hr = THR( pBase->PunkOuter()->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
    if( hr )
        goto Cleanup;

    hr = THR( pDisp->GetMemberName( dispid, &bstr ) );
    if( hr )
        goto Cleanup;

    if( !pVarOld || V_VT( pVarOld ) == VT_NULL || V_VT( pVarOld ) == VT_EMPTY )
    {
        // No value currently set
        lFlags = ATTR_CHANGE_FLAGS( (long)lFlags | ATTR_CHANGE_OLDNOTSET );
    }
    else
    {
        if( pVarOld->vt == VT_LPWSTR || pVarOld->vt == VT_BSTR )
        {
            hr = THR( FormsAllocString( (TCHAR *)pVarOld->byref, &bstrOld ) );
        }
        else
        {
            VariantInit( &varTemp );
            hr = THR( VariantChangeType( &varTemp, pVarOld, 0, VT_BSTR ) );
            if( hr )
                goto Cleanup;

            bstrOld = V_BSTR( &varTemp );
        }
    }

    if( !pVarNew || V_VT( pVarNew ) == VT_NULL || V_VT( pVarNew ) == VT_EMPTY )
    {
        // Clearing the value
        lFlags = ATTR_CHANGE_FLAGS( (long)lFlags | ATTR_CHANGE_NEWNOTSET );
    }
    else
    {
        if( pVarNew->vt == VT_LPWSTR || pVarNew->vt == VT_BSTR )
        {
            hr = THR( FormsAllocString( (TCHAR *)pVarNew->byref, &bstrNew ) );
        }
        else
        {
            VariantInit( &varTemp );
            hr = THR( VariantChangeType( &varTemp, pVarNew, 0, VT_BSTR ) );
            if( hr )
                goto Cleanup;

            bstrNew = V_BSTR( &varTemp );
        }
    }


    pElement->GetTreeExtent( &ptpBegin, NULL );
    Assert(ptpBegin);
    cp = ptpBegin->GetCp();

    pchrec = (CChangeRecord_AttrChange *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                   sizeof( CChangeRecord_AttrChange ) +         // The record
                                                   SysStringLen( bstr ) * sizeof( TCHAR ) +     // Plus the prop name
                                                   SysStringLen( bstrOld ) * sizeof( TCHAR ) +  // Plus the old value
                                                   SysStringLen( bstrNew ) * sizeof( TCHAR ) ); // Plus the new value
    
    if( !pchrec )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchrec->_opcode      = CHANGE_RECORD_OPCODE( CHANGE_RECORD_ATTRCHANGE | DirFlags() );
    pchrec->_lFlags      = lFlags;
    pchrec->_cpElement   = cp;
    pchrec->_cchName     = SysStringLen( bstr );
    pchrec->_cchOldValue = SysStringLen( bstrOld );
    pchrec->_cchNewValue = SysStringLen( bstrNew );

    pb = (BYTE *)pchrec + sizeof( CChangeRecord_AttrChange );
    memcpy( pb, bstr, SysStringLen( bstr ) * sizeof( TCHAR ) );

    pb += SysStringLen( bstr ) * sizeof( TCHAR );
    memcpy( pb, bstrOld, SysStringLen( bstrOld ) * sizeof( TCHAR ) );

    pb += SysStringLen( bstrOld ) * sizeof( TCHAR );
    memcpy( pb, bstrNew, SysStringLen( bstrNew ) * sizeof( TCHAR ) );

    AppendRecord( pchrec );

    PostCallback();

Cleanup:
    ReleaseInterface( pDisp );
    SysFreeString( bstr );
    SysFreeString( bstrOld );
    SysFreeString( bstrNew );

    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: PostCallback
//
//  Synopsis: Posts a method call for us to notify any Sinks
//      of pending changes
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::PostCallback()
{
    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Posting callback"));

    // We better have someone listening
    Assert( _aryLogs.Size() > 0 );

    if( !TestCallbackPosted() )
    {
        GWPostMethodCall(this, ONCALL_METHOD(CLogManager, NotifySinksCallback, notifysinkscallback), 0, TRUE, "CLogManager::NotifySinksCallback");
        SetCallbackPosted();
    }

    RRETURN( S_OK );
}

//+----------------------------------------------------------------+
//
//  Method: NotifySinksCallback
//
//  Synopsis: Notifies listeners that there are new changes pending
//      for them to grab.
//
//+----------------------------------------------------------------+

void
CLogManager::NotifySinksCallback( DWORD_PTR dwParam )
{
    long            c;
    CChangeLog **   ppLog;
    BOOL            fWasNotified;
    CDeletionLock   Lock(this);     // May delete this in destructor

    WHEN_DBG( ValidateQueue() );
    Assert( TestCallbackPosted() );
    TraceTag((tagTraceTreeSync, "TreeSync: Notifying sinks"));

    ClearCallbackPosted();

    // Clear flags
    ClearReentrant();
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog) && (*ppLog)->_pPlaceholder );

        (*ppLog)->_fNotified = FALSE;
    }

NotifyLoop:
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog) && (*ppLog)->_pPlaceholder );

        // The notified flag is to prevent us from notifying someone repeatedly.
        // Thus, if we skip someone becasue they have no changes pending, we
        // can set the flag, because we don't want to come back and notify them
        // if we have to re-iterate through the clients.
        fWasNotified = (*ppLog)->_fNotified;
        (*ppLog)->_fNotified = TRUE;

        // Someone may have registered or read changes after we posted
        // our callback, so make sure there really is a change pending
        if( !fWasNotified && (*ppLog)->_pPlaceholder->GetNextRecord() )
        {
            (*ppLog)->NotifySink();
        }

        if( TestReentrant() )
        {
            TraceTag((tagTraceTreeSync, "TreeSync: Reentrancy detected in notification loop - resetting"));
            ClearReentrant();
            goto NotifyLoop;
        }
    }

    Assert( !TestReentrant() );
#if DBG==1
    for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ++ppLog )
    {
        Assert( (*ppLog)->_fNotified );
    }
#endif // DBG

    WHEN_DBG( ValidateQueue() );
}


//+----------------------------------------------------------------+
//
//  Method: RegisterSink
//
//  Synopsis: Registers an IHTMLChangeSink.  Creates a CChangeLog
//      object to communicate with the Sink and adds it to our
//      data structures
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::RegisterSink( IHTMLChangeSink * pChangeSink, IHTMLChangeLog ** ppChangeLog, BOOL fForward, BOOL fBackward )
{
    HRESULT                     hr;
    CChangeLog                * pChangeLog = NULL;
    CChangeRecord_Placeholder * pPlaceholder;
    CDeletionLock               Lock(this); // May delete this in destructor


    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Registering new sink:%lx; fForward=%d; fBackward=%d", pChangeSink, fForward, fBackward));

    Assert( pChangeSink && ppChangeLog );

    // Create a placeholder first
    pPlaceholder = (CChangeRecord_Placeholder *)MemAlloc( Mt(CLogManager_ChangeRecord_pv),
                                                          sizeof(CChangeRecord_Placeholder) );
    if( !pPlaceholder )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now create the log object
    pChangeLog = new CChangeLog( this, pChangeSink, pPlaceholder );
    if( !pChangeLog )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pPlaceholder->_opcode = CHANGE_RECORD_PLACEHOLDER;

    // Add the log
    hr = THR( _aryLogs.Append( pChangeLog ) );
    if( hr )
        goto Cleanup;

    // Add the placeholder
    pPlaceholder->_pPrev = _pchrecTail;
    AppendRecord( pPlaceholder );

    *ppChangeLog = pChangeLog;
    
    SetReentrant();

    // This will propagate back into us to do the right thing.
    pChangeLog->SetDirection( fForward, fBackward );

Cleanup:
    WHEN_DBG( ValidateQueue() );

    if( hr )
    {
        delete pChangeLog;
        delete pPlaceholder;
    }

    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: Unregister
//
//  Synopsis: Unregisters a Change Log and removes it from our
//      data structures
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::Unregister( CChangeLog *pChangeLog )
{
    HRESULT                     hr = S_OK;
    CDeletionLock               Lock(this); // May delete this in destructor

    WHEN_DBG( ValidateQueue() );
    TraceTag((tagTraceTreeSync, "TreeSync: Unregistering Log:%lx", pChangeLog));

    Assert( pChangeLog && pChangeLog->_pPlaceholder );

    // Remove the log from our list
    if( !_aryLogs.DeleteByValue( pChangeLog ) )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    RemovePlaceholder( pChangeLog->_pPlaceholder );

    MemFree( pChangeLog->_pPlaceholder );

    TrimQueue();

    // Make us re-evaluate what information we're storing.
    SetDirection( FALSE, FALSE );

    SetReentrant();

    WHEN_DBG( ValidateQueue() );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: DisconnectFromMarkup
//
//  Synopsis: Disconnects the log manager from its markup
//
//+----------------------------------------------------------------+
void
CLogManager::DisconnectFromMarkup()
{
    if( _pMarkup )
    {
        Assert( _pMarkup->HasLogManager() && _pMarkup->GetLogManager() == this );
        _pMarkup->GetChangeNotificationContext()->_pLogManager = NULL;
        _pMarkup = NULL;
    }
}

//+----------------------------------------------------------------+
//
//  Method: SetDirection
//
//  Synopsis: Sets which directions of information we're interested
//      in recording.  If someone turns on a direction, we just
//      set a flag.  If someone turns off, we scan to see if any
//      other clients are interested.
//
//      NOTE (JHarding): We could maintain counts for these instead,
//      but since we don't expect many clients, running the list
//      isn't a big deal.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::SetDirection( BOOL fForward, BOOL fBackward )
{
    long            c;
    CChangeLog  **  ppLog;

    if( fForward )
    {
        SetForward();
    }
    else
    {
        // Re-scan now to see if anyone wants forward info
        ClearForward();
        for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ppLog++ )
        {
            if( (*ppLog)->_pPlaceholder->_opcode & LOGMGR_FORWARDINFO )
            {
                SetForward();
                break;
            }
        }
    }

    if( fBackward )
    {
        SetBackward();
    }
    else
    {
        // Re-scan now to see if anyone wants forward info
        ClearBackward();
        for( c = _aryLogs.Size(), ppLog = _aryLogs; c; c--, ppLog++ )
        {
            if( (*ppLog)->_pPlaceholder->_opcode & LOGMGR_BACKWARDINFO )
            {
                SetBackward();
                break;
            }
        }
    }

    RRETURN( S_OK );
}


//+----------------------------------------------------------------+
//
//  Method: AppendRecord
//
//  Synopsis: Just appends the ChangeRecord to our stream of
//      changes
//+----------------------------------------------------------------+
#if DBG==1      // Don't inline in debug
void
#else
inline void
#endif // DBG==1
CLogManager::AppendRecord( CChangeRecordBase * pchrec )
{
    AssertSz( _aryLogs.Size() > 0, "AppendRecord should only be called when someone is listening." );
    TraceTag((tagTraceTreeSync, "TreeSync: Appending record - %lx", pchrec->_opcode));

    pchrec->_pNext = NULL;

    // If for some reason the QS failed, we'll keep using 0
    if( _pISequencer )
    {
        _pISequencer->GetSequenceNumber( _nSequenceNumber, &_nSequenceNumber );
    }
    pchrec->_nSequenceNumber = _nSequenceNumber;

    if( !_pchrecHead )
    {
        Assert( !_pchrecTail );

        _pchrecHead = _pchrecTail = pchrec;
    }
    else
    {
        // Add him after the tail
        _pchrecTail->_pNext = pchrec;
        _pchrecTail = pchrec;
    }
}


//+----------------------------------------------------------------+
//
//  Method: RemovePlaceholder
//
//  Synopsis: Removes a placeholder from the stream and cleans up the
//      queue
//
//+----------------------------------------------------------------+

void
CLogManager::RemovePlaceholder( CChangeRecord_Placeholder * pPlaceholder )
{
    // If there was something before the placeholder
    if( pPlaceholder->_pPrev )
    {
        // Set its next pointer past the placeholder
        pPlaceholder->_pPrev->_pNext = pPlaceholder->_pNext;
    }
    else
    {
        // Otherwise, the placeholder should have been the head
        Assert( _pchrecHead == pPlaceholder );

        // Set the head pointer
        _pchrecHead = pPlaceholder->_pNext;
    }

    // If the placeholder was the tail, we need to update the tail ptr
    if( _pchrecTail == pPlaceholder )
    {
        Assert( pPlaceholder->_pNext == NULL );

        _pchrecTail = pPlaceholder->_pPrev;
    }

    // Now, if there was another placeholder after this placeholder, fix its prev ptr
    if( pPlaceholder->_pNext && 
        ( pPlaceholder->_pNext->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
    {
        ((CChangeRecord_Placeholder *)pPlaceholder->_pNext)->_pPrev = pPlaceholder->_pPrev;
    }
}


//+----------------------------------------------------------------+
//
//  Method: InsertPlaceholderAfterRecord
//
//  Synopsis: Moves the given placeholder to a position in the stream
//      just after the given record.  Placeholder are the only records
//      allowed to move around in the stream, and so they are
//      handled explicitly.
//
//+----------------------------------------------------------------+

void
CLogManager::InsertPlaceholderAfterRecord( CChangeRecord_Placeholder * pPlaceholder,
                                           CChangeRecordBase         * pchrec )
{
    Assert( pPlaceholder && pchrec );

    // Set the placeholder's prev ptr
    pPlaceholder->_pPrev = pchrec;

    if( pchrec == _pchrecTail )
    {
        AppendRecord( pPlaceholder );
    }
    else
    {
        // And insert it into its new home
        pPlaceholder->_pNext = pchrec->_pNext;
        pchrec->_pNext  = pPlaceholder;

        // If the guy after the placeholder now has a prev pointer, we have to fix it
        if( ( pPlaceholder->_pNext->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
        {
            ((CChangeRecord_Placeholder *)pPlaceholder->_pNext)->_pPrev = pPlaceholder;
        }
    }

    TrimQueue();
}


//+----------------------------------------------------------------+
//
//  Method: TrimQueue
//
//  Synopsis: Trims useless records off the head of the queue. 
//      The first record in the stream should always be a placeholder,
//      because any records before a placeholder do not have anyone
//      waiting to receive them.
//
//+----------------------------------------------------------------+

void
CLogManager::TrimQueue()
{
    CChangeRecordBase * pchrec;

    while( _pchrecHead && ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) != CHANGE_RECORD_PLACEHOLDER )
    {
        pchrec = _pchrecHead->_pNext;
        MemFree( _pchrecHead );
        _pchrecHead = pchrec;
    }

    if( _pchrecHead )
    {
        Assert( ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER && _aryLogs.Size() > 0 );
        ((CChangeRecord_Placeholder *)_pchrecHead)->_pPrev = NULL;
    }
    else
    {
        // We drained the whole queue
        Assert( _aryLogs.Size() == 0 );
        _pchrecTail = NULL;
    }

    WHEN_DBG( ValidateQueue() );
}

//+----------------------------------------------------------------+
//
//  Method: ClearQueue
//
//  Synopsis: Clears and frees all records from the queue
//
//+----------------------------------------------------------------+

void
CLogManager::ClearQueue()
{
    CChangeRecordBase * pchrec;

    while( _pchrecHead )
    {
        pchrec = _pchrecHead->_pNext;
        MemFree( _pchrecHead );
        _pchrecHead = pchrec;
    }

    _pchrecTail = NULL;
}


//+----------------------------------------------------------------+
//
//  Method: SaveElementToBstr
//
//  Synopsis: Saves the given element into a newly created BSTR
//  TODO (JHarding): This is not particularly efficient, as it
//  has to allocate a Global, a stream, and a BSTR.
//
//+----------------------------------------------------------------+
HRESULT
CLogManager::SaveElementToBstr( CElement * pElement, BSTR * pbstr )
{
    HRESULT   hr;
    IStream * pstm = NULL;

    Assert( pbstr );

    *pbstr = NULL;

    hr = THR( CreateStreamOnHGlobal( NULL, TRUE, &pstm ) );
    if( hr )
        goto Cleanup;

    {
        CStreamWriteBuff swb( pstm, CP_UCS_2 );

        hr = THR( swb.Init() );
        if( hr )
            goto Cleanup;

        swb.SetFlags( WBF_NO_WRAP | WBF_NO_PRETTY_CRLF | WBF_FOR_TREESYNC );
        swb.SetElementContext( pElement );
        WHEN_DBG( swb._fValidateDbg = FALSE );

        hr = THR( pElement->Save( &swb, FALSE ) );
        if( hr )
            goto Cleanup;

        hr = swb.Terminate();
        if( hr )
            goto Cleanup;
    }

    hr = THR( GetBStrFromStream( pstm, pbstr, TRUE ) );
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pstm );
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: ConvertChunksToRecords
//
//  Synopsis: Helper function to convert a buffer of SpliceChunks
//      into a SpliceRecordList + Text Stream combo.  Does some
//      work to Do The Right Thing with Text chunks, splitting 
//      them up into text TreePos' by SID.
//
//      Output buffer and SpliceRecordList are allocated by us.
//      If we succeed, they're set, otherwise they're not.
//      If we succeed, caller is responsible for freeing them.
//
//      Note on verification of SpliceChunks.  In order to preserve
//  the symmetry of insert/remove operations, we validate the
//  splice chunks as we convert them.  It is illegal to insert
//  content completely enclosing an existing element.  For example,
//  if the tree contained: foo<B></B>bar, the following would be
//  LEGAL to insert between "o" and <B>:
//  *) moo<Skip Begin>cow
//  *) moo<I>cow<Skip Begin>blah<End 1>
//  However, the following would be ILLEGAL:
//  *) moo<Skip Begin>cow<End 0>more
//  Because it completely encloses the existing <B> tag.
//
//  Also, we walk the tree as we go to make sure that things
//  like skipped begin/end nodes are already there.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::ConvertChunksToRecords( CMarkup            *   pMarkup, 
                                     long                   cpInsert, 
                                     BYTE               *   pbFirstChunk, 
                                     long                   nBufferLength,
                                     long                   crec, 
                                     TCHAR             **   ppch, 
                                     long               *   pcch, 
                                     CSpliceRecordList **   pparyRecords )
{
    HRESULT                     hr              = S_OK;
    CSpliceChunkBase        *   pscBase         = (CSpliceChunkBase *)pbFirstChunk;
    CSpliceRecord           *   prec;
    CTreePos                *   ptpIns;
    CStackDataAry<BOOL, 10>     aryfElemInTree(Mt(CLogManager_aryfElemInTree)); // Stack of BOOLs noting if elem was in tree
    TCHAR                   *   pchText         = NULL;
    TCHAR                   *   pchTextStart    = NULL;
    long                        cch             = 0;
    CSpliceRecordList       *   paryRecords     = NULL;
    IHTMLElement            *   pIHTMLElement   = NULL;


    Assert( pbFirstChunk && pparyRecords && pcch && ppch );

    // Zero out our output params
    *ppch = NULL;
    *pcch = 0;
    *pparyRecords = NULL;

    // Estimate (generously) the space needed to store the text stream
    pchTextStart = pchText = (TCHAR *)MemAlloc( Mt(CLogManager_ChangeRecord_pv), nBufferLength - crec * sizeof(long) );
    if( !pchText )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    // And create our record list
    paryRecords = new CSpliceRecordList();
    if( !paryRecords )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptpIns = pMarkup->TreePosAtCp( cpInsert, NULL, TRUE );
    Assert( !ptpIns->IsPointer() );

    while( crec-- )
    {
        switch( pscBase->_opcodeAndFlags & CSpliceChunkBase::TypeMask )
        {
        case CTreePos::NodeBeg:
            {
                CSpliceChunk_NodeBegin * pscNodeBeg = (CSpliceChunk_NodeBegin *)pscBase;
                CElement               * pElement = NULL;
                long                     cchLiteralContent = 0;

                if( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::SkipChunk ) )
                {
                    // Should not be an element string for something we're skipping
                    // Nor should they have set both these flags
                    if( pscNodeBeg->_cchElem || ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr )  )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    // Skip the existing begin
                    if( !ptpIns->IsBeginElementScope() )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Attempting to skip into non-existing element" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    pElement = ptpIns->Branch()->Element();
                    pElement->AddRef(); // Splice Records hold AddRef'd pointers

                    // Adjust to the next Edge NodePos or Text
                    do
                    {
                        ptpIns = ptpIns->NextTreePos();
                    } while( ptpIns->IsPointer() ||
                             ( ptpIns->IsNode() && !ptpIns->IsEdgeScope() ) );
                }
                else if( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr ) )
                {
                    // They've given us an element ptr - QI for IHTMLElement to make sure it really is one
                    hr = THR( pscNodeBeg->_pElement->QueryInterface( IID_IHTMLElement, (void **)&pIHTMLElement ) );
                    if( hr )
                        goto Cleanup;

                    // Make sure it's not already in the tree
                    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **)&pElement ) );
                    if( hr )
                    {
                        goto Cleanup;
                    }
                    if( pElement->GetFirstBranch() || pElement->Tag() == ETAG_ROOT )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    pElement->AddRef();     // Hold an AddRef'd pointer for the Splice Record
                    ClearInterface( &pIHTMLElement );
                }
                else
                {
                    // Create the element from the string
                    hr = THR( pMarkup->CreateElement( ETAG_NULL, 
                                                       &pElement, 
                                                       (TCHAR *)((BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin)), 
                                                       pscNodeBeg->_cchElem ) );
                    if( hr )
                        goto Cleanup;

                    if( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::Extended )
                    {
                        cchLiteralContent = *(long *)( (BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin) + pscNodeBeg->_cchElem * sizeof( TCHAR ) );

                        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
                        if( pElement->Tag() == ETAG_GENERIC_LITERAL )
                        {
                            CGenericElement * pGenericElement = DYNCAST( CGenericElement, pElement );

                            pGenericElement->_cstrContents.Set( (TCHAR *)( (BYTE *)pscNodeBeg + sizeof(CSpliceChunk_NodeBegin) + pscNodeBeg->_cchElem * sizeof( TCHAR ) + sizeof( long ) ),
                                                                 cchLiteralContent );
                        }
                    }

                    if( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::BreakOnEmpty )
                    {
                        pElement->_fBreakOnEmpty = TRUE;
                    }
                }

                // Append a splice record
                hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                if( hr )
                    goto Cleanup;

                // And set the fields
                prec->_type  = CTreePos::NodeBeg;
                prec->_pel   = pElement;    // Transferring the ref to the SpliceRecord
                prec->_fSkip = !!( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::SkipChunk );

                aryfElemInTree.AppendIndirect( &(prec->_fSkip), NULL );

                // Add a WCH_NODE char to the stream
                *pchText++ = WCH_NODE;
                cch += 1;

                // Skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_NodeBegin) + 
                          ( ( pscNodeBeg->_opcodeAndFlags & CSpliceChunkBase::ElemPtr ) ? 0 : pscNodeBeg->_cchElem * sizeof( TCHAR ) ) +
                          ( cchLiteralContent ? cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) : 0 ) );
            }
            break;

        case CTreePos::NodeEnd:
            {
                CSpliceChunk_NodeEnd * pscNodeEnd = (CSpliceChunk_NodeEnd *)pscBase;

                //
                // Verify this Node End:
                //
                // 1) If it's not in our stack, then it should be in the tree
                if( pscNodeEnd->_cIncl >= aryfElemInTree.Size() )
                {
                    if( !ptpIns->IsEndElementScope() )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Trying to end an existing element in the wrong place" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    // Adjust to the next Edge NodePos or Text
                    do
                    {
                        ptpIns = ptpIns->NextTreePos();
                    } while( ptpIns->IsPointer() ||
                             ( ptpIns->IsNode() && !ptpIns->IsEdgeScope() ) );
                }
                else
                {
                    // 2) If this was skipped in the tree, we can't end it
                    if( aryfElemInTree[ aryfElemInTree.Size() - pscNodeEnd->_cIncl - 1 ] )
                    {
                        AssertSz( FALSE, "Bogus Insert Splice Change Record given - Trying to end an element whose begin we skipped" );
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    // 3) Otherwise we created it, so we can end it
                    aryfElemInTree.Delete( aryfElemInTree.Size() - pscNodeEnd->_cIncl - 1 );
                }

                // Append a splice record
                hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                if( hr )
                    goto Cleanup;

                // set the fields
                prec->_type  = CTreePos::NodeEnd;
                prec->_cIncl = pscNodeEnd->_cIncl;
                prec->_pel   = NULL;

                // Add a WCH_NODE char to the stream
                *pchText++ = WCH_NODE;
                cch += 1;

                // and skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_NodeEnd));
            }
            break;

        case CTreePos::Text:
            // For text, we have to split the text up into text pos's by Script ID
            // (which we have to calculate)
            {
                CSpliceChunk_Text * pscText = (CSpliceChunk_Text *)pscBase;
                SCRIPT_ID           sidCurr, sidChunk;
                long                cchLeft;
                TCHAR               chCurr;
                TCHAR *             pchIn;
                TCHAR *             pchStart;


                pchIn       = (TCHAR *)((BYTE *)pscText + sizeof(CSpliceChunk_Text));
                cchLeft     = pscText->_cch;

                while( cchLeft )    // Iterate over all the characters here
                {
                    // Append a splice record for this text-pos-to-be
                    hr = THR( paryRecords->AppendIndirect( NULL, &prec ) );
                    if( hr )
                        goto Cleanup;


                    // The first char determines the starting sid
                    sidChunk = ScriptIDFromCh( *pchIn );

                    // Remember the start of this chunk
                    pchStart = pchIn;

                    while( cchLeft )    // pull up chars that merge with the first
                    {
                        chCurr = *pchIn;

                        // If we got a bogus character, try to do something intelligent with it.
                        if( chCurr == 0 || !IsValidWideChar( chCurr ) )
                        {
                            AssertSz( FALSE, "Bogus character came in through an Insert Splice record in ExecChange" );

                            chCurr = _T('?');
                        }

                        // Find the sid for the new char
                        sidCurr = ScriptIDFromCh( chCurr );

                        if( AreDifferentScriptIDs( &sidChunk, sidCurr ) )
                            break;  // Done with this chunk

                        pchIn++;
                        cchLeft--;
                    }   // Done pulling up chars that merge with the first

                    Assert( pchIn > pchStart );

                    if( sidChunk == sidMerge )
                        sidChunk = sidDefault;

                    // set the fields
                    prec->_type     = CTreePos::Text;
                    prec->_cch      = pchIn - pchStart;
                    prec->_sid      = sidChunk;
                    prec->_lTextID  = 0;

                    cch += prec->_cch;

                    // Copy this chunk into the text stream
                    memcpy( pchText, pchStart, prec->_cch * sizeof( TCHAR ) );
                    pchText += prec->_cch;
                }

                // and skip to the next record
                pscBase = (CSpliceChunkBase *)((BYTE *)pscBase + sizeof(CSpliceChunk_Text) + pscText->_cch * sizeof( TCHAR ));
            }
            break;

        default:
            AssertSz( FALSE, "Unknown Splice Chunk in Insert Splice operation" );
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

Cleanup:
    if( hr )
    {
        MemFree( pchTextStart );
        delete paryRecords;
    }
    else
    {
        *pcch = cch;
        *pparyRecords = paryRecords;
        *ppch = pchTextStart;
    }

    ReleaseInterface( pIHTMLElement );
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: ConvertRecordsToChunks
//
//  Synopsis: Helper function to convert one or two 
//      SpliceRecordLists to a buffer of Splice Chunks.  The
//      pointer given must point to a valid pointer, because we're
//      going to MemRealloc it.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::ConvertRecordsToChunks( CSpliceRecordList           * paryLeft, 
                                     CSpliceRecordList           * paryInside, 
                                     TCHAR                       * pch, 
                                     CChangeRecord_Splice       ** ppchrecIns,
                                     long                        * pnBufferSize,
                                     long                        * pcRec )
{
    HRESULT                 hr          = S_OK;
    long                    crec;
    TCHAR               *   pchText;
    CSpliceRecord       *   prec;
    long                    nRecSize;
    long                    nChunkSize;
    BSTR                    bstr        = NULL;
    long                    nOffsetOfLastText = 0;

    Assert( ppchrecIns && paryInside && pnBufferSize && pcRec );

    // Count the number of records
    crec = paryLeft ? paryLeft->Size() : 0;
    crec += paryInside->Size();

    nRecSize = *pnBufferSize;

    prec = paryLeft ? *paryLeft : *paryInside;
    pchText = pch;
    *pcRec = crec;

    for( ; crec; crec--, prec++ )
    {
        // If we finished paryLeft, jump to paryInside
        if( paryLeft && crec == paryInside->Size() )
            prec = *paryInside;

        switch( prec->_type )
        {
        // For a NodeBegin SpliceRecord, we need to save:
        // 1) Note the opcode for a NodeBegin (we never skip begin nodes)
        // 2) Record the length of the persisted element string
        // 3) Append the element string after the record
        case CTreePos::NodeBeg:
        {

            CSpliceChunk_NodeBegin * pscNodeBegin;
            CGenericElement        * pGenericElement = NULL;
            long                     cchElem = 0;
            long                     cchLiteralContent = 0;

            if( !prec->_fSkip )
            {
                // Save the element to a BSTR
                hr = THR( SaveElementToBstr( prec->_pel, &bstr ) );
                if( hr )
                    goto Cleanup;

                cchElem = SysStringLen( bstr );

                Assert( prec->_pel->Tag() != ETAG_GENERIC_NESTED_LITERAL );
                if( prec->_pel->Tag() == ETAG_GENERIC_LITERAL )
                {
                    pGenericElement = DYNCAST( CGenericElement, prec->_pel );

                    cchLiteralContent = pGenericElement->_cstrContents.Length();
                }
            }

            // Calcuate the size of this new chunk
            nChunkSize = sizeof( CSpliceChunk_NodeBegin ) +         // NodeBegin chunk
                         cchElem * sizeof( TCHAR ) +                // element string
                         ( cchLiteralContent ? cchLiteralContent * sizeof( TCHAR ) + sizeof( long ) : 0 ); // Possibly literal content
                        
            // Grow our allocation by the new chunk size
            hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
            if( hr )
                goto Cleanup;

            // Set up a pointer to the newly allocated memory for this chunk
            pscNodeBegin = (CSpliceChunk_NodeBegin *)((BYTE *)*ppchrecIns + nRecSize);
            nRecSize += nChunkSize;

            //
            // Copy the data into the buffer
            //
            pscNodeBegin->_opcodeAndFlags = CTreePos::NodeBeg;                  // Opcode
            pscNodeBegin->_cchElem = cchElem;                                   // String len
            if( prec->_fSkip )
            {
                // No string and no string length
                Assert( !bstr && cchElem == 0 );

                // If this is a skip, set the flag, and don't copy the elem string
                pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::SkipChunk;
            }
            else
            {
                // Otherwise, set length and copy string
                memcpy( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ), 
                        bstr, 
                        pscNodeBegin->_cchElem * sizeof( TCHAR ) );             // Element string

                SysFreeString( bstr );
                bstr = NULL;

                if( cchLiteralContent )
                {
                    Assert( pGenericElement );

                    *(long *)( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR ) ) = cchLiteralContent;

                    memcpy( (BYTE *)pscNodeBegin + sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR ) + sizeof( long ),
                            pGenericElement->_cstrContents,
                            cchLiteralContent * sizeof( TCHAR ) );

                    pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::Extended;
                }
            }
            if( prec->_pel->_fBreakOnEmpty )
            {
                pscNodeBegin->_opcodeAndFlags |= CSpliceChunkBase::BreakOnEmpty;
            }

            nOffsetOfLastText = 0;

            Assert( *pchText == WCH_NODE );
            ++pchText;

            break;
        }

        // For a NodeEnd SpliceRecord, we need to save:
        // 1) Note the opcode for a NodeEnd, as well as the fSkip flag
        // 2) Record the length of the inclusion around this node's ending
        case CTreePos::NodeEnd:

            CSpliceChunk_NodeEnd * pscNodeEnd;

            // Calcuate the size of this new chunk
            nChunkSize = sizeof( CSpliceChunk_NodeEnd );

            // Grow our allocation by the new chunk size
            hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
            if( hr )
                goto Cleanup;

            // Set up a pointer to the newly allocated memory for this chunk
            pscNodeEnd = (CSpliceChunk_NodeEnd *)((BYTE *)*ppchrecIns + nRecSize);
            nRecSize += nChunkSize;

            // Copy the data into the buffer
            pscNodeEnd->_opcodeAndFlags = CTreePos::NodeEnd;
            pscNodeEnd->_cIncl = prec->_cIncl; 

            nOffsetOfLastText = 0;

            Assert( *pchText == WCH_NODE );
            ++pchText;

            break;

        // For a Text SpliceRecord, we need to save:
        // 1) Note the opcode for a Text pos
        // 2) Record the cch
        case CTreePos::Text:
            CSpliceChunk_Text * pscText;

            // If the last record was text, just work with it.
            if( nOffsetOfLastText )
            {
                // Reallocate for more text
                hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + prec->_cch * sizeof( TCHAR ) ) );
                if( hr )
                    goto Cleanup;

                // Set up a pointer to the last text splice chunk
                pscText = (CSpliceChunk_Text *)((BYTE *)*ppchrecIns + nOffsetOfLastText);
                Assert( ( pscText->_opcodeAndFlags & CSpliceChunkBase::TypeMask ) == CTreePos::Text );

                // Update the character count for that splice chunk
                pscText->_cch += prec->_cch;

                // And copy it in.
                memcpy( (BYTE *)*ppchrecIns + nRecSize, pchText, prec->_cch * sizeof( TCHAR ) );
                pchText += prec->_cch;

                nRecSize += prec->_cch * sizeof( TCHAR );

                // One less record, too.
                (*pcRec) -= 1;
            }
            else
            {
                // Calcuate the size of this new chunk
                nChunkSize = sizeof( CSpliceChunk_Text ) + prec->_cch * sizeof( TCHAR );

                // Grow our allocation by the new chunk size
                hr = THR( MemRealloc( Mt(CLogManager_ChangeRecord_pv), (void **)ppchrecIns, nRecSize + nChunkSize ) );
                if( hr )
                    goto Cleanup;

                // Set up a pointer to the newly allocated memory for this chunk
                pscText = (CSpliceChunk_Text *)((BYTE *)*ppchrecIns + nRecSize);

                // Copy the data into the buffer
                pscText->_opcodeAndFlags = CTreePos::Text;
                pscText->_cch = prec->_cch;

                memcpy( (TCHAR *)((BYTE *)pscText + sizeof( CSpliceChunk_Text )), pchText, prec->_cch * sizeof( TCHAR ) );
                pchText += prec->_cch;

                nRecSize += nChunkSize;

                nOffsetOfLastText = (BYTE *)pscText - (BYTE *)*ppchrecIns;
            }

            break;

        case CTreePos::Pointer:
            *pcRec -= 1;
            break;


#if DBG==1
        default:
            AssertSz( FALSE, "Unintialized splice record" );
            break;
#endif // DBG
        }
    }

Cleanup:

    SysFreeString( bstr );
    if( hr )
    {
        MemFree( *ppchrecIns );
        nRecSize = 0;
    }

    *pnBufferSize = nRecSize;

    RRETURN( hr );
}


///////////////////////////////
// CChangeRecordBase Methods

//+----------------------------------------------------------------+
//
//  Method: RecordLength
//
//  Synopsis: Returns the length of the record, in bytes - 
//      The flags passed in specify what information you're
//      interested in.  It is not valid to ask for more information
//      than was recorded.
//
//+----------------------------------------------------------------+

long
CChangeRecordBase::RecordLength( DWORD dwFlags )
{
    long nLen = 0;
    BOOL fForward = !!( dwFlags & CHANGE_RECORD_FORWARD );
    BOOL fBackward = !!( dwFlags & CHANGE_RECORD_BACKWARD );

    // Assert the type of info they want is stored.
    Assert( ( !fForward || _opcode & CHANGE_RECORD_FORWARD ) &&
            ( !fBackward || _opcode & CHANGE_RECORD_BACKWARD ) );

    switch( _opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
            CChangeRecord_TextChange * pchrec = (CChangeRecord_TextChange *)this;
            
            nLen = sizeof( CChangeRecord_TextChange );

            if( fForward )
            {
                nLen += pchrec->_cch * sizeof( TCHAR );
            }
        }
        break;

    case CHANGE_RECORD_INSERTELEM:
    case CHANGE_RECORD_REMOVEELEM:
        {
            CChangeRecord_ElemChange * pchrec = (CChangeRecord_ElemChange *)this;

            if( ( fForward  && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM ) ||
                ( fBackward && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM ) )
            {
                nLen = sizeof( CChangeRecord_ElemChange ) +
                       pchrec->_cchElem * sizeof( TCHAR );
                if( _opcode & CHANGE_RECORD_EXTENDED )
                {
                    // Add literal content data
                    nLen += *(long *)( (BYTE *)pchrec + nLen ) * sizeof( TCHAR ) + sizeof( long );
                }
            }
            else
            {
                nLen = offsetof( CChangeRecord_ElemChange, _cchElem );
            }
        }
        break;

    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
            CChangeRecord_Splice * pchrec = (CChangeRecord_Splice *)this;
            if( ( fForward  && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTSPLICE ) ||
                ( fBackward && ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVESPLICE ) )
            {
                nLen = pchrec->_cb + sizeof(CChangeRecordBase *);
            }
            else
            {
                nLen = offsetof( CChangeRecord_Splice, _crec );
            }
        }
        break;
    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrec = (CChangeRecord_AttrChange *)this;

            nLen = sizeof( CChangeRecord_AttrChange ) + 
                   ( pchrec->_cchName + pchrec->_cchOldValue + pchrec->_cchNewValue ) * sizeof( TCHAR );
        }
        break;

    case CHANGE_RECORD_PLACEHOLDER:
        nLen = sizeof( CChangeRecord_Placeholder );
        break;
#if DBG==1
    default:
        nLen = sizeof( CChangeRecordBase );
        AssertSz( FALSE, "Unknown record - Log Manager is probably corrupted." );
        break;
#endif // DBG==1
    }

    // The length should not include _pNext ptr.
    return nLen - sizeof(CChangeRecordBase *);
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecordBase::PlayIntoMarkup
//
//  Synopsis: Determines the type of the record, casts, and 
//      calls the appropriate version
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecordBase::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;

    // We have to have info for the direction they want to play
    if(  fForward && !( _opcode & CHANGE_RECORD_FORWARD ) ||
        !fForward && !( _opcode & CHANGE_RECORD_BACKWARD ) )
    {
        AssertSz( FALSE, "TreeSync record being played backwards!" );
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch( _opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
            CChangeRecord_TextChange * pchrecText = (CChangeRecord_TextChange *)this;

            hr = THR( pchrecText->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_REMOVEELEM:
    case CHANGE_RECORD_INSERTELEM:
        {
            CChangeRecord_ElemChange * pchrecElem = (CChangeRecord_ElemChange *)this;

            hr = THR( pchrecElem->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
            CChangeRecord_Splice       * pchrecSplice = (CChangeRecord_Splice *)this;

            hr = THR( pchrecSplice->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrecAttr = (CChangeRecord_AttrChange *)this;

            hr = THR( pchrecAttr->PlayIntoMarkup( pMarkup, fForward ) );
            if( hr )
                goto Cleanup;
        }

        break;

    default:
        AssertSz( FALSE, "Invalid TreeSync Change Record!" );
        hr = E_INVALIDARG;
        break;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_TextChange::PlayIntoMarkup
//
//  Synopsis: Replays the TextChange record into the given
//      markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_TextChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT         hr;
    CMarkupPointer  mp( pMarkup->Doc() );

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying TextChange fForward=%d", fForward));

    hr = THR( mp.MoveToCp( _cp, pMarkup ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if( fForward )
    {
        // Forward means Insert the Text
        hr = THR( pMarkup->Doc()->InsertText( &mp, (TCHAR *)((BYTE *)this + sizeof(CChangeRecord_TextChange)), _cch ) );
        if( hr )
            goto Cleanup;
    }
    else
    {
        CMarkupPointer mpEnd( pMarkup->Doc() );

        hr = THR( mpEnd.MoveToCp( _cp + _cch, pMarkup ) );
        if( hr )
            goto Cleanup;

        // Backwards means cut it out
        hr = THR( pMarkup->Doc()->CutCopyMove( &mp, &mpEnd, NULL, TRUE ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_ElemChange::PlayIntoMarkup
//
//  Synopsis: Replays the Element Change record into the given
//      markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_ElemChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;
    CElement          * pElement = NULL;
    CMarkupPointer      mp( pMarkup->Doc() );
    CTreePos          * ptp;

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying ElemChange fForward=%d", fForward));

    if( ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM &&  fForward ) ||
        ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM && !fForward ) )
    {
        CMarkupPointer             mpEnd( pMarkup->Doc() );

        hr = THR( mp.MoveToCp( _cpBegin, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto InsCleanup;
        }
        // Replaying a remove backwards, the end cp is off by one, because it's where
        // we removed.
        hr = THR( mpEnd.MoveToCp( fForward ? _cpEnd : _cpEnd - 1, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto InsCleanup;
        }

        hr = THR( pMarkup->CreateElement( ETAG_NULL, &pElement, (TCHAR *)((BYTE *)this + sizeof(CChangeRecord_ElemChange)), _cchElem ) );
        if( hr )
            goto InsCleanup;

        Assert( pElement->Tag() != ETAG_GENERIC_NESTED_LITERAL );
        if( _opcode & CHANGE_RECORD_EXTENDED && pElement->Tag() == ETAG_GENERIC_LITERAL )
        {
            CGenericElement * pGenericElement = DYNCAST( CGenericElement, pElement );

            pGenericElement->_cstrContents.Set( (TCHAR *)((BYTE *)this + sizeof( CChangeRecord_ElemChange ) + _cchElem * sizeof( TCHAR ) ) + sizeof( long ),
                                                *(long *)((BYTE *)this + sizeof( CChangeRecord_ElemChange ) + _cchElem * sizeof( TCHAR ) ) );
        }
        if( _opcode & CHANGE_RECORD_BREAKONEMPTY )
        {
            pElement->_fBreakOnEmpty = TRUE;
        }

        hr = THR( pMarkup->Doc()->InsertElement( pElement, &mp, &mpEnd ) );

InsCleanup:
        if( pElement )
            pElement->Release();

        if( hr )
            goto Cleanup;
    }
    else
    {
        ptp = pMarkup->TreePosAtCp( _cpBegin, NULL, TRUE );
        if( !ptp || !ptp->IsBeginElementScope() )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        pElement = ptp->Branch()->Element();

        hr = THR( pMarkup->RemoveElementInternal( pElement ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_Splice::PlayIntoMarkup
//
//  Synopsis: Converts the splice chunks into a splice record
//      list and plays into the given markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_Splice::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT             hr = S_OK;
    CMarkupPointer      mp( pMarkup->Doc() );

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying Splice fForward=%d", fForward));
    
    // Both directions are going to need this pointer
    hr = THR( mp.MoveToCp( _cpBegin, pMarkup ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTSPLICE &&  fForward ) ||
        ( ( _opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVESPLICE && !fForward ) )
    {
        CSpliceRecordList          * paryRecords = NULL;
        TCHAR                      * pch = NULL;
        long                         cch;

        hr = THR( CLogManager::ConvertChunksToRecords( pMarkup,
                                                       _cpBegin,
                                                       (BYTE *)this + sizeof(CChangeRecord_Splice),
                                                       _cb - sizeof( CChangeRecord_Splice ) + sizeof( CChangeRecordBase *),
                                                       _crec, 
                                                       &pch, 
                                                       &cch, 
                                                       &paryRecords ) );
        if( hr )
            goto InsCleanup;

        hr = THR( pMarkup->UndoRemoveSplice( &mp, 
                                             paryRecords, 
                                             cch, 
                                             pch,
                                             0 ) );

InsCleanup:
        if( pch )
            MemFree( pch );
        if( paryRecords )
            delete paryRecords;

        if( hr )
            goto Cleanup;
    }
    else
    {
        CMarkupPointer               mpEnd( pMarkup->Doc() );

        hr = THR( mpEnd.MoveToCp( _cpEnd, pMarkup ) );
        if( hr )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR( pMarkup->Doc()->CutCopyMove( &mp, &mpEnd, NULL, TRUE ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------+
//
//  Method: CChangeRecord_AttrChange::PlayIntoMarkup
//
//  Synopsis: Replays the attribute change into the given markup
//
//+----------------------------------------------------------------+

HRESULT
CChangeRecord_AttrChange::PlayIntoMarkup( CMarkup * pMarkup, BOOL fForward )
{
    HRESULT         hr              = S_OK;
    VARIANT         varNewValue;
    BSTR            bstrValue       = NULL;
    BSTR            bstrName        = NULL;
    CTreePos    *   ptp;
    CElement    *   pElement;
    IDispatchEx *   pDisp           = NULL;
    DISPID          dispid;
    TCHAR       *   pch             = NULL;
    CBase       *   pBase           = NULL;

    TraceTag((tagTraceTreeSync, "TreeSync: Replaying AttrChange fForward=%d", fForward));

    VariantInit(&varNewValue);              // keep compiler happy
    
    // Find the element
    ptp = pMarkup->TreePosAtCp( _cpElement, NULL, TRUE );
    if( !ptp || !ptp->IsBeginElementScope() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pElement = ptp->Branch()->Element();

    if( fForward )
    {
        if( _lFlags & ATTR_CHANGE_NEWNOTSET )
        {
            V_VT( &varNewValue ) = VT_NULL;
        }
        else
        {
            pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchNewValue + 1 ) * sizeof( TCHAR ) );
            if( !pch )
                goto Cleanup;

            memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ) + ( _cchName + _cchOldValue ) * sizeof( TCHAR ), _cchNewValue * sizeof( TCHAR ) );
            pch[ _cchNewValue ] = _T('\0');

        }
    }
    else
    {
        if( _lFlags & ATTR_CHANGE_OLDNOTSET )
        {
            V_VT( &varNewValue ) = VT_NULL;
        }
        else
        {
            pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchOldValue + 1 ) * sizeof( TCHAR ) );
            if( !pch )
                goto Cleanup;

            memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ) + _cchName * sizeof( TCHAR ), _cchOldValue * sizeof( TCHAR ) );
            pch[ _cchOldValue ] = _T('\0');
        }
    }

    if( pch )
    {
        hr = THR( FormsAllocString( pch, &bstrValue ) );
        if( hr )
            goto Cleanup;

        V_VT( &varNewValue )    = VT_BSTR;
        V_BSTR( &varNewValue )  = bstrValue;
        MemFree( pch );
        pch = NULL;
    }

    if( _lFlags & ATTR_CHANGE_INLINESTYLE )
    {
        // Get style object
        CStyle * pStyle;

        hr = THR( pElement->GetStyleObject( &pStyle ) );
        if( hr )
            goto Cleanup;

        Assert( pStyle );
        hr = THR( pStyle->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;

        pBase = pStyle;
    }
    else if( _lFlags & ATTR_CHANGE_RUNTIMESTYLE )
    {
        CStyle * pStyle;

        hr = THR( pElement->EnsureRuntimeStyle( &pStyle ) );
        if( hr )
            goto Cleanup;

        Assert( pStyle );
        hr = THR( pStyle->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;
        pBase = pStyle;
    }
    else
    {
        hr = THR( pElement->QueryInterface( IID_IDispatchEx, (void **)&pDisp ) );
        if( hr )
            goto Cleanup;

        pBase = pElement;
    }

    Assert( pDisp );

    pch = (TCHAR *)MemAlloc( Mt(Mem), ( _cchName + 1 ) * sizeof( TCHAR ) );
    if( !pch )
        goto Cleanup;

    memcpy( pch, (BYTE *)this + sizeof( CChangeRecord_AttrChange ), _cchName * sizeof( TCHAR ) );
    pch[ _cchName ] = _T('\0');

    hr = THR( FormsAllocString( pch, &bstrName ) );
    if( hr )
        goto Cleanup;

    hr = THR( pDisp->GetDispID( bstrName, fdexNameCaseSensitive | fdexNameEnsure, &dispid ) );
    if( hr )
        goto Cleanup;

    if( V_VT(&varNewValue) == VT_NULL )
    {
        if(! pBase->removeAttributeDispid( dispid ) )
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        hr = THR( SetDispProp( pDisp,
                               dispid, 
                               g_lcidUserDefault,
                               &varNewValue,
                               NULL ) );
    }
        

Cleanup:
    SysFreeString( bstrValue );
    SysFreeString( bstrName );
    ReleaseInterface( pDisp );
    MemFree( pch );
    RRETURN( hr );
}

///////////////////////////////
// CChangeRecord_Placeholder Methods

//+----------------------------------------------------------------+
//
//  Method: GetNextRecord
//
//  Synopsis: Returns the next REAL Change Record in the queue,
//      skipping past all placeholders
//
//+----------------------------------------------------------------+

CChangeRecordBase *
CChangeRecord_Placeholder::GetNextRecord()
{
    CChangeRecordBase * pchrec = _pNext;

    while( pchrec && ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
    {
        pchrec = pchrec->_pNext;
    }

    return pchrec;
}



#if DBG==1
////////////////////////////////
// Debug methods


//+----------------------------------------------------------------+
//
//  Method: ValidateQueue (DEBUG)
//
//  Synopsis: Performs some basic validation on the queue
//
//+----------------------------------------------------------------+
void
CLogManager::ValidateQueue()
{
    CChangeRecordBase * pchrec;
    long                nLogs = 0;

    // If we're empty, we shouldn't have any logs.  If we're not empty,
    // then the first thing had better be a placeholder and we'd better
    // have some logs
    Assert( ( !_pchrecHead && !_pchrecTail && _aryLogs.Size() == 0 ) || 
            ( ( _pchrecHead->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER && 
                _aryLogs.Size() > 0 ) );

    pchrec = _pchrecHead;
    while( pchrec )
    {
        if( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_PLACEHOLDER )
            ++nLogs;
        pchrec = pchrec->_pNext;
    }
    Assert( nLogs == _aryLogs.Size() );
}

#define TEXTDUMPLENGTH 40

//+----------------------------------------------------------------+
//
//  Method: DumpRecord (DEBUG)
//
//  Synopsis: Dumps the record in the given buffer to the dump file
//
//+----------------------------------------------------------------+
void 
CLogManager::DumpRecord( BYTE * pbRecord )
{
    // TODO (JHarding): This is cheating.  We're never going to reference
    // the first 4 bytes of the structure, which would ordinarily be the _pNext
    // ptr, but to line up the pointer, we need to point there.
    CChangeRecordBase * pchrec = (CChangeRecordBase *)(pbRecord - sizeof(CChangeRecordBase *));

    WriteHelp( g_f, _T("<0d>) "), pchrec->_nSequenceNumber );

    switch( pchrec->_opcode & CHANGE_RECORD_TYPEMASK )
    {
    case CHANGE_RECORD_INSERTTEXT:
        {
        CChangeRecord_TextChange * pchrecText = (CChangeRecord_TextChange *)pchrec;
        WriteHelp( g_f, _T("[Insert Text]\tcp=<0d>\tcch=<1d>"), 
            pchrecText->_cp, 
            pchrecText->_cch );
        
        if( pchrec->_opcode & CHANGE_RECORD_FORWARD )
        {
            TCHAR achText[TEXTDUMPLENGTH + 1 ];
            long  nTextLen = pchrecText->_cch > TEXTDUMPLENGTH ? TEXTDUMPLENGTH : pchrecText->_cch;

            // Copy some text in
            memcpy( achText, (BYTE *)pchrecText + sizeof( CChangeRecord_TextChange ), nTextLen * sizeof( TCHAR ) );
            achText[ nTextLen ] = _T('\0');

            if( nTextLen == TEXTDUMPLENGTH )
            {
                _tcscpy( &achText[ nTextLen - 3 ], _T("...") );
            }

            WriteHelp( g_f, _T("\t<0s>"), achText);
        }

        WriteHelp( g_f, _T("\r\n") );

        break;
        }
    case CHANGE_RECORD_INSERTELEM:
    case CHANGE_RECORD_REMOVEELEM:
        {
        CChangeRecord_ElemChange * pchrecElem = (CChangeRecord_ElemChange *)pchrec;

        WriteHelp( g_f, _T("[<0s>]\tcpBegin=<1d>\tcpEnd=<2d>\t"), 
            pchrec->_opcode & CHANGE_RECORD_INSERTELEM ? _T("Insert Elem") : _T("Remove Elem"), 
            pchrecElem->_cpBegin, 
            pchrecElem->_cpEnd );

        if( ( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_INSERTELEM &&   // Insert and
                pchrec->_opcode & CHANGE_RECORD_FORWARD ) ||                                // Forward, OR
            ( ( pchrec->_opcode & CHANGE_RECORD_TYPEMASK ) == CHANGE_RECORD_REMOVEELEM &&   // Remove and
                pchrec->_opcode & CHANGE_RECORD_BACKWARD ) )                                // Backward
        {
            // Terminate the string for printing.  
            TCHAR ch = *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR )));
            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ))) = 0;

            WriteHelp( g_f, _T("<0s>\n"), (TCHAR *)((BYTE *)pchrecElem + sizeof( CChangeRecord_ElemChange )) );
            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ))) = ch;
        }
        if( pchrec->_opcode & CHANGE_RECORD_EXTENDED )
        {
            long cchLiteral = *(long *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + pchrecElem->_cchElem * sizeof( TCHAR ));

            *((TCHAR *)((BYTE *)pchrecElem + sizeof(CChangeRecord_ElemChange) + ( pchrecElem->_cchElem + cchLiteral ) * sizeof( TCHAR ) + sizeof( long ))) = 0;

            WriteHelp( g_f, _T("Literal Content: <0s>"), (TCHAR *)((BYTE *)pchrecElem + sizeof( CChangeRecord_ElemChange ) + pchrecElem->_cchElem * sizeof( TCHAR ) + sizeof( long )) );
        }

        WriteHelp( g_f, _T("\r\n") );
        break;
        }
    case CHANGE_RECORD_REMOVESPLICE:
    case CHANGE_RECORD_INSERTSPLICE:
        {
        CChangeRecord_Splice * pchrecSplice = (CChangeRecord_Splice *)pchrec;
        BYTE * pCurr;
        BOOL   fDumpChunks;
        long   crec;

        if( pchrec->_opcode & CHANGE_RECORD_REMOVESPLICE )
        {
            WriteHelp( g_f, _T("[Remove") );
            fDumpChunks = pchrec->_opcode & CHANGE_RECORD_BACKWARD;
        }
        else
        {
            WriteHelp( g_f, _T("[Insert") );
            fDumpChunks = pchrec->_opcode & CHANGE_RECORD_FORWARD;
        }
        WriteHelp( g_f, _T(" Splice]\tcpBegin=<0d>\tcpEnd=<1d>"), pchrecSplice->_cpBegin, pchrecSplice->_cpEnd );

        if( fDumpChunks )
        {
            WriteHelp( g_f, _T("\tcrec=<0d>:\r\n"), pchrecSplice->_crec );
            for( crec = pchrecSplice->_crec, pCurr = (BYTE *)pchrecSplice + sizeof( CChangeRecord_Splice ); crec; crec-- )
            {
                CSpliceChunkBase * pscBase = (CSpliceChunkBase *)pCurr;
            
                switch( pscBase->_opcodeAndFlags & CSpliceChunkBase::TypeMask )
                {
                case CTreePos::NodeBeg:
                    {
                        CSpliceChunk_NodeBegin * pscNodeBegin = (CSpliceChunk_NodeBegin *)pscBase;
                        TCHAR                  * pch          = (TCHAR *)MemAlloc(Mt(Mem), ( pscNodeBegin->_cchElem + 1 ) * sizeof( TCHAR ) );

                        WriteHelp( g_f, _T("\t(Node Begin<0s>)"), pscNodeBegin->_opcodeAndFlags & CSpliceChunkBase::SkipChunk ? _T(" Skip") : _T("") );
                        memcpy( pch, pCurr + sizeof( CSpliceChunk_NodeBegin ), pscNodeBegin->_cchElem * sizeof( TCHAR ));
                        pch[pscNodeBegin->_cchElem] = _T('\0');

                        WriteHelp( g_f, _T("\t<0s>\r\n"), pch );
                        MemFree( pch );
                        pCurr += sizeof( CSpliceChunk_NodeBegin ) + pscNodeBegin->_cchElem * sizeof( TCHAR );

                        if( pscNodeBegin->_opcodeAndFlags & CSpliceChunkBase::Extended )
                        {
                            pch = (TCHAR *)MemAlloc(Mt(Mem), ( *(long *)pCurr + 1 ) * sizeof( TCHAR ) );
                            memcpy( pch, pCurr + sizeof( long ), *(long *)pCurr * sizeof( TCHAR ) );
                            pch[*(long *)pCurr] = _T('\0');
                            WriteHelp( g_f, _T("Literal Content: <0s>\r\n"), pch );
                            MemFree( pch );
                            pCurr += *(long *)pCurr * sizeof( TCHAR )+ sizeof( long );
                        }
                    }
                    break;

                case CTreePos::NodeEnd:
                    {
                        CSpliceChunk_NodeEnd * pscNodeEnd = (CSpliceChunk_NodeEnd *)pscBase;

                        WriteHelp( g_f, _T("\t(Node End)") );
                        WriteHelp( g_f, _T("\tcIncl = <0d>\r\n"), pscNodeEnd->_cIncl );
                        pCurr += sizeof( CSpliceChunk_NodeEnd );
                    }
                    break;

                case CTreePos::Text:
                    {
                        CSpliceChunk_Text * pscText = (CSpliceChunk_Text *)pscBase;
                        TCHAR             * pch     = (TCHAR *)MemAlloc(Mt(Mem), ( pscText->_cch + 1 ) * sizeof( TCHAR ) );

                        memcpy( pch, pCurr + sizeof( CSpliceChunk_Text ), pscText->_cch * sizeof( TCHAR ) );
                        pch[ pscText->_cch ] = _T('\0');

                        WriteHelp( g_f, _T("\t(Text)\t<0s>\r\n"), pch );
                        MemFree( pch );
                        pCurr += sizeof( CSpliceChunk_Text ) + pscText->_cch * sizeof( TCHAR );
                    }
                    break;
                }
            }
        }
        else
        {
            WriteHelp( g_f, _T("\r\n") );
        }
    
        break;
        }

    case CHANGE_RECORD_PLACEHOLDER:
        {
        WriteHelp( g_f, _T("[Log Placeholder]\r\n") );
        break;
        }
    case CHANGE_RECORD_ATTRCHANGE:
        {
            CChangeRecord_AttrChange * pchrecAttr = (CChangeRecord_AttrChange *)pchrec;
            long                       cchAlloc   = max( max( pchrecAttr->_cchName, pchrecAttr->_cchOldValue ), pchrecAttr->_cchNewValue ) + 1;
            TCHAR                    * pch        = (TCHAR *)MemAlloc(Mt(Mem), cchAlloc * sizeof( TCHAR ) );
            TCHAR                    * pchSrc;

            WriteHelp( g_f, _T("[Attr Change]\tcpElement=<0d>"), pchrecAttr->_cpElement );
            if( pchrecAttr->_lFlags & ATTR_CHANGE_INLINESTYLE )
            {
                WriteHelp( g_f, _T("\tStyle:") );
            }
            else if( pchrecAttr->_lFlags & ATTR_CHANGE_RUNTIMESTYLE )
            {
                WriteHelp( g_f, _T("\tRuntimeStyle:") );
            }

            pchSrc = (TCHAR *)((BYTE *)pchrecAttr + sizeof( CChangeRecord_AttrChange ));
            memcpy( pch, pchSrc, pchrecAttr->_cchName * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchName ] = _T('\0');
            WriteHelp( g_f, _T("\tName=\"<0s>\""), pch );

            pchSrc += pchrecAttr->_cchName;
            memcpy( pch, pchSrc, pchrecAttr->_cchOldValue * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchOldValue ] = _T('\0');
            WriteHelp( g_f, _T("\tOld Value=\"<0s>\""), ( pchrecAttr->_lFlags & ATTR_CHANGE_OLDNOTSET ) ? _T("[Not Set]") : pch );

            pchSrc += pchrecAttr->_cchOldValue;
            memcpy( pch, pchSrc, pchrecAttr->_cchNewValue * sizeof( TCHAR ) );
            pch[ pchrecAttr->_cchNewValue ] = _T('\0');
            WriteHelp( g_f, _T("\tNew Value=\"<0s>\"\r\n"), ( pchrecAttr->_lFlags & ATTR_CHANGE_NEWNOTSET ) ? _T("[Not Set]") : pch );

            MemFree( pch );
        }
        break;

    default:
        WriteHelp( g_f, _T("[Unknown Entry]\r\n") );
        break;
    }
}

//+----------------------------------------------------------------+
//
//  Method: DumpQueue (DEBUG)
//
//  Synopsis: Dumps the entire queue to the dump file
//
//+----------------------------------------------------------------+
void
CLogManager::DumpQueue()
{
    CChangeRecordBase * pchrec = _pchrecHead;

    if( !InitDumpFile() )
        return;

    WriteString( g_f, _T("\r\n------------------ Log Manager Queue ----------------\r\n" ) );

    while( pchrec )
    {
        DumpRecord( (BYTE *)pchrec + sizeof(CChangeRecordBase *) );
        pchrec = pchrec->_pNext;
    }

    CloseDumpFile();
}
#endif // DBG



CLogManager::CDeletionLock::CDeletionLock( CLogManager * pLogMgr )
{ 
    Assert( _pLogMgr );
    _pLogMgr = pLogMgr; 

    // If we're the first lock, we're responsible for clearing 
    // the flag and ensuring deletion of the log manager
    _fFirstLock = !pLogMgr->TestFlag( LOGMGR_NOTIFYINGLOCK ); 
    pLogMgr->SetFlag( LOGMGR_NOTIFYINGLOCK );
}

CLogManager::CDeletionLock::~CDeletionLock()
{
    if( _fFirstLock )
    {
        _pLogMgr->ClearFlag( LOGMGR_NOTIFYINGLOCK );
        if( 0 == _pLogMgr->_aryLogs.Size() )
        {
            delete _pLogMgr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\ipwnd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       ipwnd.cxx
//
//  Contents:   forms kernel window proc
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif


#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef UNIX
#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#if !defined(NO_IME)
#ifndef WM_IME_REQUEST
#define WM_IME_REQUEST 0x0288
#endif
#ifndef IMR_RECONVERTSTRING
#define IMR_RECONVERTSTRING 0x0004
#endif
#endif

#ifdef UNIX

#include <mainwin.h>
extern "C" HANDLE MwGetPrimarySelectionData();
#include "quxcopy.hxx"

#endif //UNIX

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

EXTERN_C const GUID CGID_DocHostCommandHandler;

#ifndef X_OLEACC_H
#define X_OLEACC_H
#include <oleacc.h>
#endif

#ifndef WIN16
DYNLIB g_dynlibOLEACC = { NULL, NULL, "OLEACC.DLL" };
#endif // !WIN16

MtDefine(MsoCmdText, Locals, "MSOCMDTEXT structure (temp)")

// Holds the user defined windows message
UINT CDoc::_g_msgHtmlGetobject = 0;
#if !defined(NO_IME)
UINT CDoc::_g_msgImeReconvert = 0;
#endif // !NO_IME

ExternTag(tagRects);
DeclareTag(tagCapture, "DocCapture", "trace SetMouseCapture")
DeclareTag(tagPaintRedraw, "Doc", "trace WM_PAINT, WM_SETREDRAW");

extern HRESULT EnsureAccWindow( CWindow * pWindow );

extern void RestartImgAnimTimerProc();
extern void KillImgAnimTimerProc();

#define WM_CHECKMINIMIZED (WM_USER + 145)

//+---------------------------------------------------------------
//
// Local Helper: ShowTooltipHelper
//
//----------------------------------------------------------------
void
ShowTooltipHelper(CDoc * pDoc, CTreeNode * pNodeContext, CMessage * pMsg)
{
    CMarkup * pMarkup = pNodeContext ? pNodeContext->GetMarkup() : NULL;

    if (!(pMarkup && pMarkup->_fDesignMode))
    {
        BOOL    fDismissed;

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        //
        //  Give tooltips a chance to dismiss
        //
        fDismissed = FormsTooltipMessage(
                pMsg->message,
                pMsg->wParam,
                pMsg->lParam);

        // If we're not captured and the tooltip is being dismissed....
        //
        if (fDismissed == FALSE)
        {
            //  If hitted element has tooltip, put up its tooltip, otherwise,
            //  Walk through the element hierarchy.  If any element
            //  has tooltip text, put up the tooltip.
            //
            CTreeNode * pNode = pNodeContext;
            for (; pNode && pNode->Tag() != ETAG_ROOT ;
                       pNode = pNode->Parent())
            {
                if (pNode->Element()->ShowTooltip(pMsg, pMsg->pt) != S_FALSE)
                {
                    break;
                }
            }
        }
    }
}


//+====================================================================================
//
// Method: IsTridentHWND
//
// Synopsis: Helper to check to see if a given HWND belongs to a trident window
//
//------------------------------------------------------------------------------------


BOOL
IsTridentHwnd( HWND hwnd )
{
    TCHAR strClassName[100] ;

    ::GetClassName( hwnd, strClassName, 100 );

    if ( StrCmpIW( strClassName, _T("Internet Explorer_Server") ) == 0 )
    {
        return TRUE;
    }
    else
        return FALSE;
}

//+====================================================================================
//
// Method: OnChildBeginSelection
//
// Synopsis: Called by enumeration of all child windows 
//           If you are a TridentHwnd - post a WM_BEGINSELECTION message to yourself.
//           Otherwise do nothing
//
//------------------------------------------------------------------------------------

BOOL
CALLBACK
OnChildBeginSelection( HWND hwnd, LPARAM lParam )
{
    if ( IsTridentHwnd( hwnd ) )
    {
        ::SendMessage( hwnd,
                       WM_BEGINSELECTION,
                       lParam,  // Cascade the Selection Type.
                       0 );
    }
    return TRUE;
}

BOOL
CDoc::IsPopupChildHwnd( HWND hwnd )
{
    CDoc *pDocChild = _pDocPopup;

    while (pDocChild)
    {
        if (    pDocChild->_pInPlace->_hwnd == hwnd
            ||   ::IsChild(pDocChild->_pInPlace->_hwnd, hwnd))
            return TRUE;

        pDocChild = pDocChild->_pDocPopup;
    }

    return FALSE;
}


#ifdef UNIX
//+---------------------------------------------------------------------------
//
//  Member:     MwTransalteUnixKeyBinding
//
//  Synopsis:   This routine acts as a late stage TranslateAccelerator call with
//              the caveat that if translated only the wParam and Modifiers 
//              arguments will be changed.
//
//              This means that for the KEYDOWN/KEYUP messages the key code and 
//              modifier state could be translated to something else.  This 
//              implies GetKeyState for the modifiers will not be re-queried 
//              after a call to this function as it might not be the same as the
//              now translated modifier state.
//
//  Returns:    void
//
//----------------------------------------------------------------------------
extern "C" BOOL MwTranslateUnixKeyBinding( HWND hwnd, DWORD message, 
                                           WPARAM *pwParam, DWORD *pModifiers );
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::OnWindowMessage
//
//  Synopsis:   Handle window messages dispatched from the wndproc.
//
//  Returns:    S_FALSE if message should be passed on to the
//              default window procedure.
//
//---------------------------------------------------------------

HRESULT
CDoc::OnWindowMessage(
        UINT msg,
        WPARAM wParam,
        LPARAM lParam,
        LRESULT *plResult)
{
    HRESULT     hr;
    HWND        hwnd = _pInPlace->_hwnd;
    HWND        hwndControl = NULL;
    CLock       Lock(this);
#ifdef UNIX
    BOOL        bCutToEOL = FALSE;
    BOOL        bCutFullLine = FALSE;
#endif
    BOOL        fWeJustHidSelection = FALSE;
    HWND        hwndParent = NULL;
    HWND        hwndLoseFocus = NULL;
    HWND        hwndTemp = NULL;
    BOOL        fTridentHwnd = FALSE;
    BOOL        fLosingFocusToTridentChild;
    CMarkup*    pCurMarkup;

    Assert(_pElemCurrent);

    hr = S_OK;
    *plResult = 0;
    if (    _pDocPopup 
        &&  msg >= WM_KEYFIRST 
        &&  msg <= WM_KEYLAST
        &&  _pDocPopup->_pInPlace)
    {
        HRESULT hr2 = S_OK;
        hr2 = THR(_pDocPopup->OnWindowMessage(msg, wParam, lParam, plResult));
        if (S_OK == hr2)
            goto Cleanup;
    }

#if DBG == 1
    if (msg == WM_PAINT || msg == WM_SETREDRAW)
    {
        TraceTag((tagPaintRedraw, "%x +%d %x %x",
                        this, msg, wParam, lParam));
    }
#endif

    switch (msg)
    {
    case WM_APPCOMMAND:
    case WM_INPUTLANGCHANGE:
        {
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);
            PumpMessage(&Message, _pElemCurrent->GetFirstBranch());
        }
        break;

#ifndef NO_MENU
     case WM_MENUSELECT:
     case WM_INITMENUPOPUP:
        {
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);

            if (_pMenuObject)
            {
                PumpMessage(&Message, _pMenuObject->GetFirstBranch());
            }
            else
            {
                PumpMessage(&Message, _pElemCurrent->GetFirstBranch());
            }
        }
        break;
#endif // NO_MENU

     case WM_TIMER:

        if (wParam == TIMER_DEFERUPDATEUI)
        {
            OnUpdateUI();
        }
        break;
            

    //
    // Somewhere inside us a Selection is begin made. We clear any selection we have
    // and post the message on to all our child windows.
    //
    case WM_BEGINSELECTION:
    {
        IGNORE_HR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS_FRAME, NULL, wParam ));

        ::EnumChildWindows( _pInPlace->_hwnd,
                            (WNDENUMPROC) OnChildBeginSelection,
                            wParam );
    }
    break;
    case WM_KILLFOCUS:
    {
        _pInPlace->_fFocus = FALSE;
        // Release any mouse capture when we loose focus
        SetMouseCapture (NULL, NULL);

        _fGotKeyUp = TRUE;

        //
        //  Tell the editor to lose focus
        //
        //
        // marka - check to see if 
        // a) we're losing focus to another frameset (we kill our selection )
        // b) we're losing focus to another window ( we hide our selection )
        // c) just losing focus - we call Lose Focus ( to hide the caret ).
        //


        //
        // See if we're losing focus to another Window in the same window as us.
        //

        hwndTemp  = _pInPlace->_hwnd;
        while(hwndTemp)
        {
            hwndParent = hwndTemp;
            hwndTemp = GetParent(hwndTemp);
        }

        fLosingFocusToTridentChild = FALSE;
        hwndTemp = (HWND) wParam;
        while(hwndTemp)
        {      
            hwndLoseFocus = hwndTemp;

            if (hwndLoseFocus == _pInPlace->_hwnd)
            {
                fLosingFocusToTridentChild = TRUE;

                // shortcut the serach, because we already
                // know the top-level parent in this case
                hwndLoseFocus = hwndParent;
                break;
            }

            hwndTemp = GetParent(hwndTemp);
        }

        fTridentHwnd = wParam && IsTridentHwnd( (HWND) wParam ) ;
        
        if ( hwndLoseFocus != hwndParent && HasTextSelection() ) 
        {
            CMarkup *pMarkup = GetCurrentMarkup();

            if( pMarkup )
            {
                pMarkup->HideSelection();
                SET_EDIT_BIT( pMarkup, _fSelectionHidden , TRUE)
                fWeJustHidSelection = TRUE;
            }
        }
        else  if ( hwndLoseFocus == hwndParent && fTridentHwnd )
        {
#if 0        
           hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS_FRAME, NULL ));
#endif            
        }
        else
        {
            hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS, NULL ));
        }
        
        // If losing focus to a window that is not a Trident child, but is a
        // child of Trident's top-level parent (for example, the address box
        // of IE), clear the first-time-tab flag (37950)
        if (!fLosingFocusToTridentChild && hwndParent == hwndLoseFocus)
        {
            _fFirstTimeTab = FALSE;
        }

        if (    _pDocPopup
            &&  (   GetWindowThreadProcessId((HWND) wParam, NULL)
                        != GetWindowThreadProcessId(_pInPlace->_hwnd, NULL)
                ||  !IsPopupChildHwnd( (HWND) wParam ))
            )
        {
            IGNORE_HR(_pDocPopup->DoVerb(OLEIVERB_HIDE,
                                        NULL,
                                        _pDocPopup->_pClientSite,
                                        0,
                                        NULL,
                                        NULL));
        }

        // check if we go iconic
        ::PostMessage(hwnd, WM_CHECKMINIMIZED, NULL, NULL);

    }           // Fall through

    case WM_SETFOCUS:
    {
        // check if we go maximized / restored
        if ( _fIconic && (msg == WM_SETFOCUS))
        {
            while (hwnd)
            {
                hwndParent = hwnd;
                hwnd = GetParent(hwnd);
            }
        
            if ( !IsIconic( hwndParent ) )
            {
                _fIconic = FALSE;
                InternetSetOption(NULL, INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS , NULL, NULL); 
                RestartImgAnimTimerProc();
            }
        }

        CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);

        CElement *pElemFireTarget;

        pElemFireTarget = _pElemCurrent->GetFocusBlurFireTarget(_lSubCurrent);
        Assert(pElemFireTarget);

        // Whenever we get focus, we set the flag to false to indicate
        // that we have not received a key down, so donot fire the keyups
        if (WM_SETFOCUS == msg)
        {
            _fGotKeyDown = FALSE;
            // Do not fire window onfocus if we are here as a result of onblur\onfocus
            // bringing up a modal dialog. However, we do want to fire it if window onblur
            // brought up a modal dialog that was dismissed.
            if (!TestLock(FORMLOCK_CURRENT) ||
                (   !pElemFireTarget->TestLock(CElement::ELEMENTLOCK_FOCUS)
                 && !pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR)
                 && _fModalDialogInOnblur
                )
               )
            {
                GetCurrentWindow()->Post_onfocus();
            }
        }

        if (    _pInPlace
            &&  !_pInPlace->_fDeactivating
            &&  !TestLock(FORMLOCK_CURRENT))
        {
            // Do not fire site onfocus\onblur if we come here either
            // as a result of calling blur() or focus(), because it would
            // have been already fired in BecomeCurrent()
            if (!_fInhibitFocusFiring)
            {
                // SELECT, being a windowed control should receive WM_KILLFOCUS directly
                if (WM_SETFOCUS == msg || (WM_KILLFOCUS == msg && _pElemCurrent->Tag() != ETAG_SELECT))
                {
                    // if the doc is not locked, the elem can't be locked either
                    Assert(!pElemFireTarget->TestLock(CElement::ELEMENTLOCK_FOCUS));
                    Assert(!pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR));

                    // fire focus/blur events
                    _pElemCurrent->Fire_ActivationHelper(
                                                        _lSubCurrent,
                                                        NULL,
                                                        0,
                                                        FALSE,
                                                        (WM_KILLFOCUS == msg),
                                                        TRUE, 
                                                        NULL,
                                                        FALSE);
                }

                if (WM_SETFOCUS == msg)
                {
                    // Fire window onblur if onfocus previously fired and the
                    // current site is not the body
                    if (_pElemCurrent->IsInMarkup() && _pElemCurrent != _pElemCurrent->GetMarkup()->GetElementClient())
                    {
                        GetCurrentWindow()->Post_onblur();
                    }
                }
            }
        }
        // we get here if a modal dialog from current element's onblur is dismissed.
        // In this case we wan't to fire its onfocus again.
        else if (pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR) &&
                 WM_SETFOCUS == msg && _fModalDialogInOnblur)
        {
            GWPostMethodCall(pElemFireTarget, ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus), 0, TRUE, "CElement::Fire_onfocus");
        }

        if (_view.IsActive())
        {
            _view.InvalidateFocus();

            // Display the caret
            if (_pCaret &&  WM_SETFOCUS == msg)
            {
                _pCaret->UpdateCaret();
            }
        }

        pCurMarkup = GetCurrentMarkup();        
        if ( !fWeJustHidSelection && pCurMarkup ) 
        {     
            if ( CHECK_EDIT_BIT( pCurMarkup, _fSelectionHidden ))
            {
                pCurMarkup->ShowSelection();                 
                SET_EDIT_BIT( pCurMarkup, _fSelectionHidden , FALSE)            
            }
            else if ( HasTextSelection() )
            {
                // Always inval the selection here. Fixes problems with inval from Alerts fired OnSelectStart
                pCurMarkup->InvalidateSelection( ); 
            }                
        }

        IGNORE_HR(InvalidateDefaultSite());

        IGNORE_HR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));

        // Forward the WM_KILLFOCUS, WM_SETFOCUS messages to CServer which
        // will notify the control site of the focus change.  Forward the
        // messages when no site has focus or when the site with focus is
        // a dataframe (non ole site).
        if (!_pElemCurrent->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));

        // Do not fire window onblur if we are here as a result of onblur\onfocus
        // bringing up a modal dialog.
        if (WM_KILLFOCUS == msg && !TestLock(FORMLOCK_CURRENT))
        {
            GetCurrentWindow()->Post_onblur(TRUE);
        }

        break;
    }

    case WM_CAPTURECHANGED:
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif
        SetMouseCapture(NULL, NULL);

#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif
        break;

    //
    // Messages sent to site under mouse.
    //

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            POINT pt;

            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);

            hr = THR(OnMouseMessage(
                    msg,
                    wParam,
                    lParam,
                    plResult,
                    pt.x, pt.y));

            //we couldn't find who is under us (BODY having "display:none" is example)
            //use default processing (it will eventually set arrow cursor)
            if(hr != S_OK)
                hr = CServer::OnWindowMessage(msg, wParam, lParam, plResult);
        }
        else
        {
            hr = CServer::OnWindowMessage(msg, wParam, lParam, plResult);
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;
            pt.x = MAKEPOINTS(lParam).x;
            pt.y = MAKEPOINTS(lParam).y;
            if ( (pt.x  == -1 && pt.y == -1) && _pElemCurrent )
            {
                // pt.x & pt.y are supposed to be in screen coordinates;
                // the only case when they are -1,-1 is if WM_CONTEXTMENU
                // originated from Shift-F10 or Windows keyboard
                // key 'Menu'; in this case we send the message to the
                // current site.

                CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);
                hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            }
            else
            {               
                ScreenToClient(_pInPlace->_hwnd, &pt);

                // CONSIDER: should this set the focus before
                // sending the OnMouseMessage.  Does anything actually
                // use this code path? (jbeda)

                hr = THR(OnMouseMessage(
                        msg,
                        wParam,
                        lParam,
                        plResult,
                        pt.x, pt.y));
            }
        }
        break;

#ifndef WIN16
    case WM_MOUSEWHEEL:
HandleMouseWheel:
        if (_pDocPopup)
        {
            SendMessage(_pDocPopup->_pInPlace->_hwnd, msg, wParam, lParam);
        }
        else
        {
            POINT ptCursor;
            RECT  rcCurrent;

            // Check where the wheel rotates.
            // If the wheel is rotated inside the current CDoc window, let
            // us handle it. Otherwise, let DefWindowProc and handle it and
            // bubble to the parent window.
            ptCursor.x = MAKEPOINTS(lParam).x;
            ptCursor.y = MAKEPOINTS(lParam).y;
            ::GetWindowRect(InPlace()->_hwnd, &rcCurrent);

            if (PtInRect(&rcCurrent, ptCursor))
            {
                ScreenToClient(hwnd, &ptCursor);
                Assert(msg == WM_MOUSEWHEEL || msg == g_msgMouseWheel);
                hr = THR(OnMouseMessage(
                        WM_MOUSEWHEEL,
                        wParam,
                        lParam,
                        plResult,
                        ptCursor.x,
                        ptCursor.y));
            }
            else
            {
                hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
            }
        }
        break;
#endif // ndef WIN16

    //
    // Messages sent to site under mouse
    //

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
        switch (msg)
        {
        case WM_LBUTTONDOWN:
            _fCanFireDblClick = TRUE;
            // fall through
        
        case WM_LBUTTONDBLCLK:
            _fGotLButtonDown = TRUE;
            break;
        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
            _fGotMButtonDown = TRUE;
            break;
        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            _fGotRButtonDown = TRUE;
            break;
        }
        _fGotKeyUp = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_LBUTTONUP:
        if (!_fGotLButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotLButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MBUTTONUP:
        if (!_fGotMButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotMButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_RBUTTONUP:
        if (!_fGotRButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotRButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MOUSEMOVE:
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MOUSELEAVE:
        // Default messages get forwarded to the base class's
        // window procedure.
        hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
        break;

    case WM_NCLBUTTONDOWN:
    {
        RECT    rcCurrent;

        if (OnNCLButtonDown(wParam, MAKEPOINTS(lParam), &rcCurrent))
        {
            SIZE size;

            TraceTag((tagRects,
                    "%08x OnNCLButtonDown > OnPosRectChange %d %d %d %d",
                    this, rcCurrent));

            HimetricFromDevice(size,
                    rcCurrent.right - rcCurrent.left,
                    rcCurrent.bottom - rcCurrent.top);
            SetExtent(DVASPECT_CONTENT, &size);

            IGNORE_HR(_pInPlace->_pInPlaceSite->OnPosRectChange(ENSUREOLERECT(&rcCurrent)));
        }
        break;
    }

    case WM_HELP:
        hr = THR(OnHelp((HELPINFO *)lParam));
        break;


    //
    // Keyboard messages: (Sent to _pElemCurrent)
    //

#ifdef UNIX
    //
    // Two new windows messages under Unix.  Kind of ironic huh?
    // These are generated from the TranslateUnixKeyBinding call
    // in the case where Ctrl-K (cut to the end of the line) or
    // Ctrl-U (cut full line) is pressed.
    //
    case WM_CUTTOEOL:
        bCutToEOL = TRUE;
        // fall thru
#endif
    case WM_KEYDOWN:
        /*
        if (_fPopupDoc && wParam == VK_ESCAPE)
        {
            // close Popup window if esc key pressed
            Assert(_pClientSite);

            hr = THR(DoVerb(    OLEIVERB_HIDE,
                                NULL,
                                _pClientSite,
                                0,
                                NULL,
                                NULL));
            if (hr)
                goto Cleanup;
            break;
        }
        */
        _fGotKeyDown = TRUE;
        // fall thru
    case WM_KEYUP:
        if (!_fGotKeyDown)
        {
            // NOTE (sujalp): Do not reset the _fGotKeyDown to
            // FALSE here. It is set to FALSE only when we get
            // the focus and that too to eat up the spurious key
            // up which we might get after we GOT_FOCUS.
            hr = S_OK;
            goto Cleanup;
        }
        // fall thru
    case WM_CHAR:
    case WM_DEADCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:

#ifndef NO_IME
    case WM_IME_SETCONTEXT:
    case WM_IME_NOTIFY:
    case WM_IME_CONTROL:
    case WM_IME_COMPOSITIONFULL:
    case WM_IME_SELECT:
    case WM_IME_CHAR:
    case WM_IME_KEYDOWN:
    case WM_IME_KEYUP:
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_REQUEST:
ReconvertIME:
#endif // !NO_IME
    {
        CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);

#if !defined(NO_IME)
        // Simulate IME Reconversion message
        if (msg == _g_msgImeReconvert)
        {
            Message.message = WM_IME_REQUEST;
            Message.wParam = IMR_RECONVERTSTRING;
        }
#endif // !(NO_IME)
        
#ifdef UNIX
        //
        // See MwTranslateUnixKeyBinding above for what it does.  
        // Basically we allow keys to be translated from emacs bindings
        // keys to windows keys.
        //


        if ((msg == WM_KEYDOWN) ||
            (msg == WM_KEYUP)) {
            BOOL bTranslated;

            bTranslated = MwTranslateUnixKeyBinding( Message.hwnd,
                                                     Message.message, 
                                                     &Message.wParam, 
                                                     &Message.dwKeyState );

            if ( bTranslated &&
                 msg == WM_KEYDOWN &&
                 Message.wParam == VK_DELETE ) {

                //
                // VK_DELETE is normally translated via resource
                // accelerators into an IDM_DELETE.  That code path
                // at this point has already passed though... so we
                // do it manually.
                //
                MSOCMD msocmd;

                msocmd.cmdID = IDM_DELETE;
                msocmd.cmdf = 0;

                QueryStatus((GUID *) &CGID_MSHTML,
                            1,
                            &msocmd,
                            NULL);
            
                if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
                    
                    Exec((GUID *)&CGID_MSHTML, IDM_DELETE, 0, NULL, NULL);
                }

                hr = S_OK;
                break;
            }
        }

        if ( bCutToEOL ) {
            //
            // Bit of a hack here.  When we're instructed to cut the 
            // current line or to the end of the current line we 
            // spoof the appropriate keystrokes into PumpMessage.
            //

            if ( Message.wParam == TRUE ) {
                bCutFullLine = TRUE;

                Message.message = WM_KEYDOWN;
                Message.wParam = VK_HOME;
                Message.lParam = 0L;
                Message.dwKeyState = 0;
            } else {
 CutToEOL:
                Message.message = WM_KEYDOWN;
                Message.wParam  = VK_END;
                Message.lParam  = 0L;
                Message.dwKeyState = FSHIFT;

                //
                // However, in order to not mess up the currently highlighted
                // item we first hide the selection.  This assures we don't
                // overwrite the current selection copy buffer.
                //
                // (Under Unix the currently selected item of which there are
                //  at most one can be pasted by pressing the middle mouse button)
                //

#if 0
                pTxtSite = _pSiteCurrent->GetTxtSite();
                if ( pTxtSite ) {
                    pTxtSite->GetSel(&pSel,FALSE);
                    if (pSel) {
                        pSel->ShowSelection(FALSE);
                    }
                }
#else

#endif
            }
        }
#endif // UNIX

        hr = S_FALSE;

        //
        // If the captured site didn't handle it, pass message to current
        // site.
        //

        if (S_FALSE == hr)
        {
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            *plResult = Message.lresult;
        }
        DeferUpdateUI();

#ifdef UNIX_NOTYET
        //
        // Tail portion of cut line hack
        //

        if ( bCutFullLine ) {
            bCutFullLine = FALSE;
            goto CutToEOL;
        }

        if ( bCutToEOL ) {
            LRESULT lResult;
            OnWindowMessage(WM_CUT, 0, 0L, &lResult);
            if ( pSel ) {
                pSel->ShowSelection(TRUE);
            }
        }
#endif
        break;
    }

    //
    //  Messages that are either handled or reflected.
    //

    case WM_COMMAND:
        if (!_pMenuObject &&
                lParam &&
                GetParent(GET_WM_COMMAND_HWND(wParam, lParam)) == _pInPlace->_hwnd)
        {
            // Command is bubbling up from a control. Reflect it back.

            hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            goto ReflectMessage;
        }
        else
        {
            // It's our command.
            OnCommand(GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam), GET_WM_COMMAND_CMD(wParam, lParam));
        }
        break;

    case WM_DEFERZORDER:
        {
            FixZOrder();
        }
        break;

    case WM_ACTIVEMOVIE:
        {
            CNotification   nf;

            nf.ActiveMovie(PrimaryRoot(), (void *)lParam);
            BroadcastNotify(&nf);
        }
        break;

    //
    //  OLE Control v1.0 reflected messages
    //

    case WM_DRAWITEM:
        hwndControl = ((DRAWITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_MEASUREITEM:
        //  TODO how did the control ID ever get set?
        hwndControl = GetDlgItem(hwnd, (UINT) wParam);
        goto ReflectMessage;

    case WM_DELETEITEM:
        hwndControl = ((DELETEITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_COMPAREITEM:
        hwndControl = ((COMPAREITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_NOTIFY:
#if DBG == 1 && !defined(WINCE) && defined(DBG_TOOLTIPS)
        if (DbgExIsFullDebug())
        {
            if ((TTN_NEEDTEXTA == ((LPNMHDR) lParam)->code) ||
                    (TTN_NEEDTEXTW == ((LPNMHDR) lParam)->code))
            {
                LPTOOLTIPTEXT   lpToolTipText;
                static TCHAR    szBuffer[256];

                // query tooltips for buttons on the in-place toolbar.

                lpToolTipText = (LPTOOLTIPTEXT) lParam;

                MSOCMD      msocmd;
                MSOCMDTEXT *pmsocmdtext;

                pmsocmdtext = (MSOCMDTEXT *) MemAlloc(Mt(MsoCmdText),
                    sizeof(MSOCMDTEXT) + (FORMS_BUFLEN * sizeof(TCHAR)));
                pmsocmdtext->cmdtextf = MSOCMDTEXTF_NAME;
                pmsocmdtext->cwBuf    = FORMS_BUFLEN;
                pmsocmdtext->cwActual = 0;

                msocmd.cmdID = lpToolTipText->hdr.idFrom;
                msocmd.cmdf  = 0;

                if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboTag)
                {
                    msocmd.cmdID = IDM_BLOCKFMT;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboFont)
                {
                    msocmd.cmdID = IDM_FONTNAME;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboSize)
                {
                    msocmd.cmdID = IDM_FONTSIZE;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboColor)
                {
                    msocmd.cmdID = IDM_FORECOLOR;
                }

                QueryStatus(
                        (GUID *) &CGID_MSHTML,
                        1,
                        &msocmd,
                        pmsocmdtext);

                if (pmsocmdtext->cwActual > 0)
                {
                    _tcscpy(szBuffer, pmsocmdtext->rgwz);
                }
                else
                {
                    LoadString(
                            g_hInstResource,
                            IDS_TOOLTIP(msocmd.cmdID),
                            szBuffer,
                            ARRAY_SIZE(szBuffer));
                }

                DWORD dwVersion = GetVersion();
                if (dwVersion >= 0x80000000) // Windows 95 or Win32s with Windows 3.1
                {
                    TCHAR szTemp[256];

                    _tcscpy(szTemp, szBuffer);
                    WideCharToMultiByte(
                            CP_ACP,
                            0,
                            szTemp,
                            -1,
                            (char *) szBuffer,
                            sizeof(szBuffer),
                            NULL,
                            NULL);
                }
                lpToolTipText->lpszText = szBuffer;
                MemFree(pmsocmdtext);
                break;
            }
            // else fall through & hit the goto ReflectMessage.
        }
#endif // DBG == 1 && !WINCE

        hwndControl = ((LPNMHDR) lParam)->hwndFrom;
        goto ReflectMessage;

    case WM_VSCROLL:
    case WM_HSCROLL:
        if (!lParam)
        {
            // If lParam is NULL, should try to scroll ourselves
            //
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            break;
        }
        // if lParam is defined, should fall through to ReflectMessage

#ifndef WIN16
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
#endif // !WIN16
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        hwndControl = (HWND) lParam;
        goto ReflectMessage;

#ifndef WINCE
    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_CREATE ||
            LOWORD(wParam) == WM_DESTROY)
        {
            hwndControl = (HWND) lParam;

            // Hack for PhotoSuite (#94834)
            if (_pElemOleSiteActivating && LOWORD(wParam) == WM_CREATE)
            {
                COleSite * pOleSite = DYNCAST(COleSite, _pElemOleSiteActivating);

                if (!pOleSite->_hwndPrivate)
                {
                    pOleSite->_hwndPrivate = hwndControl;
                }
            }
            goto ReflectMessage;
        }
        break;
#endif // WINCE

    case WM_GETDLGCODE:
        *plResult = DesignMode() ? DLGC_WANTALLKEYS : DLGC_WANTCHARS | DLGC_WANTARROWS;
        hr = S_OK;
        break;

    case WM_ERASEBKGND:
        if (wParam != 0)
        {
            *plResult = OnEraseBkgnd((HDC)wParam);
        }
        hr = S_OK;
        break;
        
#ifdef UNIX
    //
    // Under Unix handle the standard WM_CUT & PASTE messages.
    // Again, these are generated by the TranslateUnixKeyBinding
    // call on certain keystrokes... this happens too late to 
    // conver to the right IDM_ commands so I do it here.
    //

    case WM_CUT:
    {
        MSOCMD msocmd[2];

        msocmd[0].cmdID = IDM_CUT;
        msocmd[0].cmdf = 0;
        msocmd[1].cmdID = IDM_DELETE;
        msocmd[1].cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    2,
                    msocmd,
                    NULL);
            
        //
        // Here we either delete or cut depending on whether cut
        // is available or not.  It's usually not available because
        // it's on a password field
        //

        if ( msocmd[0].cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_CUT,0, NULL, NULL);
        } 
        else 
        if ( msocmd[1].cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_DELETE, 0, NULL, NULL);
        }

        hr = S_OK;
        break;
    }
    case WM_COPY:
    {
        MSOCMD msocmd;

        msocmd.cmdID = IDM_COPY;
        msocmd.cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);

        if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_COPY, 0, NULL, NULL);
        }

        hr = S_OK;
        break;
    }
    case WM_PASTE:
        MSOCMD msocmd;

        msocmd.cmdID = IDM_PASTE;
        msocmd.cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
            
        if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_PASTE, 0, NULL, NULL);
        }

        hr = S_OK;
        break;

    //
    // These two messages implement the Unix selection copy buffer
    // (clipboard) for Trident.
    //
    // Basically, if we get "GETTEXTPRIMARY" the system is doing 
    // the equivalent of a RenderFormat wanting the selected text.
    //
    // UNDOPRIMARYSELECTION tells us someone else has selected text
    // and we should undo our selection.
    //

    case WM_GETTEXTPRIMARY:
    case WM_UNDOPRIMARYSELECTION:
        {
            //
            // Send these messages down to the current Text Selection via
            // PumpMessage
            //
            CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            break;
        }
#endif // UNIX

    case WM_GETOBJECT :
            // ActiveX "accessibility", creation of in-context proxy
            OnAccGetObjectInContext(msg, wParam, lParam, plResult);
            hr = S_OK;  // no need to continue 
            break;

    case WM_UISTATEUPDATE:
        {
            WORD wUIStateOld = _wUIState;

            if (LOWORD(wParam) == UIS_SET)
                _wUIState |= HIWORD(wParam);
            else if (LOWORD(wParam) == UIS_CLEAR)
                _wUIState &= ~HIWORD(wParam);

            // Use XOR to see which bits changed.
            wUIStateOld ^= _wUIState;

            if (wUIStateOld & UISF_HIDEACCEL)
            {
                if (_fHaveAccelerators)
                {
                    CNotification   nf;

                    nf.ChangeAccelerator(PrimaryRoot());
                    nf.SetData((DWORD)0);
                    BroadcastNotify(&nf);
                    Assert(nf.IsDataValid());

                    // If there were any accelerators then they would
                    // have set the DWORD to non-zero
                    if (nf.DataAsDWORD() == 0)
                        _fHaveAccelerators = FALSE;
                    else
                        Invalidate();
                }
            }
            else if ((wUIStateOld & UISF_HIDEFOCUS) && _view.IsActive())
            {
                _view.InvalidateFocus();
            }
        }

        *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
        hr = S_OK;
        break;

    case WM_CHECKMINIMIZED:
        // check if we went iconic        
        if ( !_fIconic )
        {
            while (hwnd)
            {
                hwndParent = hwnd;
                hwnd = GetParent(hwnd);
            }

            if ( IsIconic( hwndParent ) )
            {
                _fIconic = TRUE;
                InternetSetOption(NULL, INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS, NULL, NULL); 
                KillImgAnimTimerProc();
                if (_pCaret)
                {
                    ::DestroyCaret();
                }
            }
        }
        break;
                        
    default:

        if (msg == WM_MOUSEACTIVATE && _fPopupDoc)
        {
            *plResult = (LRESULT)MA_NOACTIVATE;
            break;
        }

#ifndef WIN16
        // different WM_MOUSEWHEEL message between Windows 95 and NT 40
        //
        if (msg != 0 && msg == g_msgMouseWheel)
        {
            POINT ptCursor;

            ::GetCursorPos(&ptCursor);
            wParam = MAKEWPARAM(HIWORD(wParam), LOWORD(wParam));
            lParam = MAKELPARAM(ptCursor.x, ptCursor.y);
            goto HandleMouseWheel;
        }
#endif // ndef WIN16
        if(msg == _g_msgHtmlGetobject)
        {
            // ActiveX "accessibility"
            OnAccGetObject(msg, wParam, lParam, plResult);
            hr = S_OK;  // Stop bubbling.
            break;
        }

#if !defined(NO_IME)
        if( (msg == _g_msgImeReconvert) && (_g_msgImeReconvert) )
        {
            goto ReconvertIME;
        }
#endif // !NO_IME

        //  All other messages get forwarded to the base class's
        //    window procedure.

        hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
        break;
    }

Cleanup:

#if DBG == 1
    if (msg == WM_PAINT || msg == WM_SETREDRAW)
    {
        TraceTag((tagPaintRedraw, "%x -%d %x %x",
                        this, msg, wParam, lParam));
    }
#endif

    // TODO should we come here with S_FALSE, or does that mean
    // defProc was not called when should?
    RRETURN1(hr, S_FALSE);

ReflectMessage:

    Assert(hwndControl);
    *plResult= SendMessage(
            hwndControl,
            msg + OCM__BASE,
            wParam,
            lParam);

    hr = S_OK;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::EnableDragDrop
//
//  Synopsis:   Register or revoke drag-drop as appropriate.
//
//-------------------------------------------------------------------------
void
CDoc::EnableDragDrop(DWORD_PTR dwContext)
{
    IDropTarget *   pDT;

    if (State() >= OS_INPLACE)
    {
        if (!THR_NOTRACE(GetDropTarget(&pDT)))
        {
            BOOL    fRegHostDT = FALSE;
            if (_pHostUIHandler)
            {
                IDropTarget *   pDTOut = NULL;

                if (!_pHostUIHandler->GetDropTarget(pDT, &pDTOut))
                {
                    //cache our Drop target so it can be restored if it's overwriten by a popup
                    _pDT = pDT;
                    _pDT->AddRef();

                    // Register host's drop target
                    IGNORE_HR(RegisterDragDrop(_pInPlace->_hwnd, pDTOut));
                    fRegHostDT = TRUE;
                }
                ReleaseInterface(pDTOut);
            }

            if (!fRegHostDT)
                IGNORE_HR(RegisterDragDrop(_pInPlace->_hwnd, pDT));

            pDT->Release();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnMouseMessage
//
//  Synopsis:   Handle WM_MOUSEMOVE, WM_LBUTTONDOWN and so on.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::OnMouseMessage(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult,
    int x, int y)
{
    HRESULT         hr  = S_OK;
    CMessage        Message(_pInPlace->_hwnd, msg, wParam, lParam);
    CTreeNode *     pNodeHit = NULL;
    CTreeNode *     pNodeNewMouse = NULL;
    long            lNewSubDivision;
    BOOL            fCapture;
    DWORD           dwHitTestFlags;
    ULONG           cDie = _cDie;
    CTreeNode::CLock *pLockNodeNewMouse = 0;

    Message.pt.x = x;
    Message.pt.y = y;

    //--------------------------------------------------------------------
    //
    // NOTE(SujalP and GaryBu):
    //
    // Normally, a button down implies a BecomeCurrent() which implies
    // a transition to the UIActive state. The BecomeCurrent() happens
    // in PumpMessage(). However, we do not call BecomeCurrent() when
    // the mouse goes down on a scrollbar. This is needed to fix bugs
    // like bug48127, where clicking on the scrollbar changes the current
    // site.
    //
    // However, if we do not perform BecomeCurrent() on the button down
    // in PumpMessage(), then we have to atleast transition of UIActive
    // otherwise we will break the frame case. Consider a doc with 2 frames.
    // Lets say the focus is on the left frame. The user now clicks on
    // the right frame scrollbar. The right frame will not call BecomeCurrent
    // because the hit was on the scrollbar and hence not even transition to
    // UIActive state. Hence, we do the transition here. Note that the
    // transition has to be on a button down (not on a button up -- as it
    // was done originally) because if the object takes capture then we
    // may not get the button up message at all (scrollbar are guilty of
    // this).
    //
    // If non-client area like scrollbars are hit, then under certain hosts
    // we do not want to become UIActive either. Consider the case of Athena
    // (bug33562) where clicking on the scrollbar, takes focus away from
    // the "To:" input box of Athena. To prevent us from taking focus, we
    // ask hosts such as Athena to turn on the following doc host flag:
    // DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY. Note that we will still take
    // focus if the hit were on the body (done by PumpMessage() as explained
    // earlier).
    //
    //--------------------------------------------------------------------

    if (   State() < OS_UIACTIVE
        && !(_dwFlagsHostInfo & DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY)
        && (   msg == WM_LBUTTONDOWN
            || msg == WM_RBUTTONDOWN
            || msg == WM_MBUTTONDOWN
           )
       )
    {
        // Do not fire onfocus on the current element, because the
        // current element may change because of the button down.
        _fInhibitFocusFiring = TRUE;
        TransitionTo(OS_UIACTIVE);
        _fInhibitFocusFiring = FALSE;
    }
    // We need to check to see that we really have the capture
    // because WM_CAPTURECHANGED is not sent on all platforms.
    fCapture = FALSE;
    dwHitTestFlags = 0;

    if (HasCapture())
    {
        fCapture = TRUE;
        
        dwHitTestFlags = HT_IGNORESCROLL | HT_NOGRABTEST;
    }

    //
    // Locate the "hit" element
    //

    Message.htc = HitTestPoint(
                     &Message,
                     &pNodeHit,
                     dwHitTestFlags);

    if( !fCapture && Message.htc == HTC_NO )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert( !pNodeHit || pNodeHit->IsInMarkup() );

    // IE6 bug 29944 - this is a workaround trying to 
    // fix this stress failure. This should not happen
    // however it is a safe bet to bail out at this point.
    if (pNodeHit && !pNodeHit->IsInMarkup())
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    hr = THR( Message.SetNodeHit( pNodeHit ) );
    if( hr )
        goto Cleanup;

    if( Message.pNodeHit )
        pNodeHit->Element()->SubDivisionFromPt(Message.ptContent, &Message.lSubDivision);
    
    pNodeNewMouse = Message.pNodeHit;
    lNewSubDivision = Message.lSubDivision;

        // $$ktam: Revisit ref-counting _pLCLastMouseOver like _pNodeLastMouseOver.

    {
        // don't let the hit-tested element go away til we're ready
        if (pNodeNewMouse)
        {
            pLockNodeNewMouse = new CTreeNode::CLock;
            hr = THR( pLockNodeNewMouse->Init(pNodeNewMouse) );
            if( hr )
                goto Cleanup;
        }
        
        {
            CTreeNode * pNodeOldOver = _pNodeLastMouseOver;
            CLayoutContext *pLCOldOver = _pLCLastMouseOver;
    
            //
            // Hand the message to the site.  However, if the htc is >= HTC_GRPTOPBORDER
            // we can just hand it off to the parent.  htc >= HTC_GRPTOPBORDER implies
            // a hit on the grab handles or border.
            //
    
            if ((Message.htc >= HTC_GRPTOPBORDER) && Message.pNodeHit->Element()->IsEditable(TRUE))
            {
                pNodeNewMouse = Message.pNodeHit->GetUpdatedParentLayoutNode();
                pNodeNewMouse = (pNodeNewMouse && Message.pNodeHit->Element()->IsInMarkup())
                                    ? pNodeNewMouse
                                    : Message.pNodeHit;
            }
    
    
            // Do not send MouseOver/MouseLeave messages in response to a
            // WM_SETCURSOR! WM_SETCURSOR is not a true mouse message and Windows
            // can send us this message any time it thinks the cursor needs to be
            // redrawn. This can cause nasty situations if the script handler for
            // MouseOver/MouseOut generates another WM_SETCURSOR message! See bug
            // 13590. (MohanB)
    
            // deal with the last element under mouse
            if (    Message.message != WM_SETCURSOR
                &&  State() >= OS_INPLACE
                &&  cDie == _cDie
                &&  _pNodeLastMouseOver
                &&  pNodeNewMouse
                &&  (   _pNodeLastMouseOver != pNodeNewMouse
                     || _lSubDivisionLast != lNewSubDivision)

                // Ignore transitions from master to slave and vice versa (39135)
                && !(       _pNodeLastMouseOver->Element()->HasMasterPtr()
                        &&  _pNodeLastMouseOver->Element()->GetMasterPtr() == pNodeNewMouse->Element()
                     ||     pNodeNewMouse->Element()->HasMasterPtr()
                        &&  pNodeNewMouse->Element()->GetMasterPtr() == _pNodeLastMouseOver->Element()
                    )
               )
            {
                CTreeNode * pNodeTo = pNodeNewMouse->Ancestor(ETAG_A);
    
                CMessage MessageOut(_pInPlace->_hwnd, WM_MOUSELEAVE, NULL, lParam);
                hr = THR( MessageOut.SetNodeHit( pNodeOldOver ) );
                if( hr )
                    goto Cleanup;
                MessageOut.pt.x = x;
                MessageOut.pt.y = y;
                MessageOut.lSubDivision = _lSubDivisionLast;
                MessageOut.pLayoutContext = pLCOldOver;
    
                // set up for the 'from' & 'to' event object parameters. This part
                // is tricky. we are firing and WM_MOUSEEXIT, the this pointer is
                // the 'from' element, the 'to' element is accessed by TEMPORARILY
                // putting it into the _pNodeLastMouseOver pointer (since it is
                // redundant with the this pointer anyhow). after this call to HM
                // (which assumes the _pelemlast.. is the 'to' pointer (see CElement::
                // FireStdEventOnMessage)) the _pNodeLastMouseOver is restored for
                // the remainder of the HM calls.
                _pNodeLastMouseOver = pNodeNewMouse;
                hr = THR( _pNodeLastMouseOver->NodeAddRef() );
                if( hr )
                    goto Cleanup;
                _pLCLastMouseOver = Message.pLayoutContext;
                // if the timer is set, we want to turn it off. otherwise it is possible
                //  that the _pNodeLastMouseOver will be Nulled out from under use (root
                //  cause of bug 21062)
                if (_fMouseOverTimer)
                {
                    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
                    _fMouseOverTimer = FALSE;
                }

                hr = THR(PumpMessage(&MessageOut, pNodeOldOver));
                //restore to fire the message itself
                if (_pNodeLastMouseOver)
                    _pNodeLastMouseOver->NodeRelease();
    
                _pNodeLastMouseOver = pNodeOldOver;
                _pLCLastMouseOver = pLCOldOver;

                // Is this node no longer connected to the primary markup? (#30760)
                if (!_pNodeLastMouseOver->IsConnectedToPrimaryMarkup())
                {
                    _pNodeLastMouseOver->NodeRelease();
                    _pNodeLastMouseOver = NULL;
                }

                if (Message.pNodeHit && !Message.pNodeHit->IsConnectedToPrimaryMarkup())
                {
                    // The hit element got nuked! Get out now before we hurt ourselves!
                    goto Cleanup;
                }
    
                // if the element being hit is not an anchor or its child then show appropriate status text
                if (!pNodeTo)
                    (void)THR_NOTRACE(SetStatusText(NULL, STL_ROLLSTATUS));
            }
    
    
            // Watch for the mouse going off the window.
    
            if (!_fMouseOverTimer)
            {
                hr = THR(FormsSetTimer(this,
                       ONTICK_METHOD(CDoc, DetectMouseExit, detectmouseexit),
                       TIMER_ID_MOUSE_EXIT,
                       300));
                if (!hr)
                    _fMouseOverTimer = TRUE;
            }
    
            //
            //  Handle tooltips
            //
    
            if (Message.pNodeHit)
            {
                ShowTooltipHelper(this, Message.pNodeHit, &Message);
            }
    
            //TODO: This used to be working in IE4 (ie401)
            //          (Pri1 BUG: 7164)
            //  but crashing in IE5. seems related to some major changes
            //  We can no longer assume GetRootDoc()->_pInPlace to be valid
            //  any more. Therefore, we need to revisit this issue to make
            //  sure that all reference to _pInPlace are safe.
            if (!_pNodeLastMouseOver)
                IGNORE_HR(SetStatusText(NULL, STL_ROLLSTATUS));
    
            hr = THR(PumpMessage(&Message, pNodeNewMouse));

            // Fire the event unless the element got nuked in event handler!
            if (pNodeNewMouse && !pNodeNewMouse->IsDead() && pNodeNewMouse->IsInViewTree())
            {
                // Now fire MouseOver if applicable
                if (    Message.message != WM_SETCURSOR
                    &&  State() >= OS_INPLACE
                    &&  cDie == _cDie
                    &&  (   _pNodeLastMouseOver != pNodeNewMouse
                         || _lSubDivisionLast != lNewSubDivision)

                    // Ignore transitions from master to slave and vice versa (39135)
                    && !(   _pNodeLastMouseOver
                         && (
                                    _pNodeLastMouseOver->Element()->HasMasterPtr()
                                &&  _pNodeLastMouseOver->Element()->GetMasterPtr() == pNodeNewMouse->Element()
                             ||     pNodeNewMouse->Element()->HasMasterPtr()
                                &&  pNodeNewMouse->Element()->GetMasterPtr() == _pNodeLastMouseOver->Element()
                            )
                        )
                   )
                {
                    Assert(_pInPlace && _pInPlace->_hwnd);
                    CMessage MessageOut(_pInPlace->_hwnd, WM_MOUSEOVER, NULL, lParam);
                    hr = THR( MessageOut.SetNodeHit( pNodeNewMouse ) );
                    if( hr )
                        goto Cleanup;
                    MessageOut.pt.x = x;
                    MessageOut.pt.y = y;
                    MessageOut.lSubDivision = lNewSubDivision;
                    MessageOut.pLayoutContext = Message.pLayoutContext;
    
                    hr = THR(PumpMessage(&MessageOut, pNodeNewMouse));

                    if (pNodeNewMouse->IsDead() || !pNodeNewMouse->IsInViewTree())
                    {
                        Verify( !CTreeNode::ReplacePtr(&_pNodeLastMouseOver, NULL) );
                        _lSubDivisionLast = 0;
                        _pLCLastMouseOver = NULL;
                    }

                    // don't assign if this is the rootsite
                    else if (pNodeNewMouse->Element() != PrimaryRoot())
                    {
                        hr = THR( CTreeNode::ReplacePtr(&_pNodeLastMouseOver, pNodeNewMouse) );
                        if( hr )
                            goto Cleanup;
                        _lSubDivisionLast = MessageOut.lSubDivision;
                        _pLCLastMouseOver = MessageOut.pLayoutContext;
                    }
                }
            }
        }
    }

    //
    // Ensure that UI Active site matches the current site on mouse button up.
    //

    if ((msg == WM_LBUTTONUP || msg == WM_RBUTTONUP || msg == WM_MBUTTONUP) &&
        (_pElemUIActive != _pElemCurrent) &&
        (cDie == _cDie ) && 
        (State() >= OS_INPLACE ))
    {
        _pElemCurrent->BecomeUIActive();
    }

    if (msg != WM_MOUSEMOVE && msg != WM_SETCURSOR)
    {
        DeferUpdateUI();
    }

Cleanup:
    if  (pLockNodeNewMouse)
    {
        delete pLockNodeNewMouse;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member: FireMouseOverTest
//
// Sysnopsis:  Timer Callback. this function's job is to detect when a mouse move
//      has taken us outside the client rectl. when that is detected, we fire
//      an exit message.
//              in any case we clear the doc flag, and we kill the timer.
//
//-----------------------------------------------------------------------------

HRESULT BUGCALL
CDoc::DetectMouseExit( UINT uTimerID)
{
    HRESULT hr = S_OK;

    if (    !_fInhibitOnMouseOver
        &&  !HasCapture()
        &&  State() >= OS_INPLACE)
    {
        POINT     ptMouse;
        HWND      hwndMouse;

        GetCursorPos(&ptMouse);

        if ((hwndMouse = WindowFromPoint(ptMouse)) != NULL
            && hwndMouse != _pInPlace->_hwnd
            && !IsDuringDrag())
        {
            if (::IsChild(_pInPlace->_hwnd, hwndMouse))
            {
                LRESULT lResult;

                // We always send mousemove messages to the document so 
                // the onmouseover/out events will get fired correctly. 
                MapWindowPoints(NULL, _pInPlace->_hwnd, &ptMouse, 1);
                IGNORE_HR(OnWindowMessage(WM_MOUSEMOVE, 0, 
                    MAKELPARAM(ptMouse.x, ptMouse.y),  &lResult));
            }
            else if (_pNodeLastMouseOver)
            {
                CMessage  Message(_pInPlace->_hwnd, WM_MOUSELEAVE, NULL, NULL);
                CTreeNode * pNode = _pNodeLastMouseOver;

                hr = THR( Message.SetNodeHit( pNode ) );
                if( hr )
                    goto Cleanup;
                Message.pt.x = -1;      // we know we are outside client rect
                Message.pt.y = -1;
                Message.pLayoutContext = _pLCLastMouseOver;

                // Don't need timer any more.

                FormsKillTimer(this, uTimerID);
                _fMouseOverTimer = FALSE;

                // Set this first in order to properly fill the EVENTPARAM from,to

                _pNodeLastMouseOver = NULL;
                _pLCLastMouseOver = NULL;
                _lSubDivisionLast = 0;
            
                IGNORE_HR(PumpMessage(&Message, pNode));

                // Release our addref on the lastmouseoverelem.

                pNode->NodeRelease();
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnHelp
//
//  Synopsis:   Handle keboard messages
//
//----------------------------------------------------------------------------

//#ifndef WIN16
HRESULT
CDoc::OnHelp(HELPINFO *phi)
{
    HRESULT hr      = S_FALSE;
    LRESULT lResult = TRUE;

    // If the F1 key is down or the mouse is not down, then treat it
    // like a keyboard message. Otherwise, treat it like a mouse message.

    if ((GetKeyState(VK_F1) & 0x8000) || !(GetKeyState(VK_LBUTTON) & 0x8000))
    {
        // give a chance to ShowHelp which calls IDocHostShowUI; if that failed,
        // show help ourselves
        if (S_OK != ShowHelp(NULL, 0, 0, g_Zero.pt))
        {
            CMessage Message(_pInPlace->_hwnd, WM_HELP, 0, (LPARAM)phi);

            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
        }
    }
    else
    {
#ifndef WIN16
        POINT pt = phi->MousePos;
#else
        POINT pt;
        pt.x = (phi->MousePos).x;
        pt.y = (phi->MousePos).y;
#endif

        ScreenToClient(_pInPlace->_hwnd, &pt);
        hr = THR(OnMouseMessage(
                WM_HELP,
                0,
                (LPARAM)phi,
                &lResult,
                pt.x, pt.y));
    }

    RRETURN1(hr, S_FALSE);
}
//#endif // !WIN16

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::OnCommand
//
//  Synopsis:   Handle WM_COMMAND
//
//----------------------------------------------------------------------------

void
CDoc::OnCommand(int idm, HWND hwndCtl, UINT code)
{
    BOOL fRestoreFocus = FALSE;

#if DBG==1
    switch (idm)
    {
    case IDM_DEBUG_TRACETAGS:
        DbgExDoTracePointsDialog(FALSE);
        return;

    case IDM_DEBUG_RESFAIL:
        DbgExShowSimFailDlg();
        return;

    case IDM_DEBUG_DUMPOTRACK:
        DbgExTraceMemoryLeaks();
        return;

    case IDM_DEBUG_BREAK:
        DebugBreak();
        return;

    case IDM_DEBUG_VIEW:
        DbgExOpenViewObjectMonitor(_pInPlace->_hwnd, (IUnknown *)(IViewObject *) this, TRUE);
        return;
    }
#endif

        //
        // These are the cases which can be handled by Exec().
        //

        VARIANTARG *pvarIn  = NULL;
        if( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__ )
        {
            CODEPAGE cp = GetCodePageFromMenuID(idm);
            if (CP_UNDEFINED != cp && PrimaryMarkup()->GetCodePage() != cp)
            {
                PrimaryMarkup()->SwitchCodePage(cp);

                if (_pClientSite)
                {
                    // Let shdocvw know about it
                    VARIANT var;

                    V_VT(&var) = VT_I4;
                    V_I4(&var) = cp;

                    CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_ONCODEPAGECHANGE,
                           0, &var, NULL);
                }

                IGNORE_HR(_pWindowPrimary->ExecRefresh());
            }
            return;
        }
        Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL);

        // When the user selects a combo item, pop the focus pack into the document.

        if (fRestoreFocus)
        {
            ::SetFocus (_pInPlace->_hwnd);
        }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnAccGetObject
//
//  Synopsis:   Handles receipt of the WM_GET_HTML_OBJECT by the form
//
//  Input:      msg
//              wParam  Opaque, pass through.
//              lParam  idObject from NotifyWinEvent.
//
//  Returns:    LRESULT containing a IAccessible object.
//
//  Notes:      This must work in concert with the corresponding NotifyWinEvents,
//              which must pass the address of the object in idObject.
//
//-------------------------------------------------------------------------

void
CDoc::OnAccGetObject(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
#if !defined(_MAC) && !defined(WIN16)
    HRESULT hr;

    static DYNPROC s_dynprocLresultFromObject =
            { NULL, &g_dynlibOLEACC, "LresultFromObject" };

    if (!plResult)
        goto Cleanup;

    // Load up the LresultFromObject pointer.
    hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
    if (hr)
    {
        goto Cleanup;
    }

    // Convert the punk into an lresult, which is an OS means of
    // converting the punk into a handle that can be marshalled.

    // Note: Although this returns an interface pointer, we do not
    // addref it here.  copy semantics are inplace for the lresult 
    // so this function does the requisite stuff

    //  pass out the _OmDocument, this is necessary to handle QI's (et al)
    //  properly when we are in the webbrowser.ocx and other aggregating
    //  hosts.

    *plResult = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
            s_dynprocLresultFromObject.pfn)(IID_IHTMLDocument2, 
                                            wParam, 
                                            (IUnknown*)_pWindowPrimary->Document());

Cleanup:
#endif
    return;
}

//+--------------------------------------------------
//
//   member : OnAccGetObjectIncontenxt
//
//  Synopsis : WM_GETOBJECT processing
//          rather than passing the document pointer to oleacc
//        for them to cocreate the proxy, we can create the proxy
//        ourselves and thus save lots of work by not marshalling 
//
//
//------------------------------------------------------
// Note: lParam is intentionaly declared as a LONG since 
// Objids are 32bits everywhere (according to brendanm)
// and Win64 fills differently the upper 64bits of the
// LPARAM depending on the caller beign 32bits or 64bits
void
CDoc::OnAccGetObjectInContext (UINT msg, 
                              WPARAM wParam, 
                              LONG lParam, 
                              LRESULT *plResult)
{
#if !defined(_MAC) && !defined(WIN16)
    HRESULT         hr = S_OK;
    CAccBase *      pAccObj = NULL;
    ACCEVTRECORD    accEvtRec;

    static DYNPROC s_dynprocLresultFromObject =
            { NULL, &g_dynlibOLEACC, "LresultFromObject" };

    if (!plResult)
        goto Cleanup;

    // Load up the LresultFromObject pointer.
    hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
    if (hr)
    {
        goto Cleanup;
    }

    if ( (lParam == OBJID_WINDOW) || (lParam == OBJID_CLIENT))
    {
        CWindow * pWindow = _pWindowPrimary->Window();
        
        //check if this document has a Window Accessible object associated with it.
        //if not, create one, else AddRef and return the existing one.
        hr = EnsureAccWindow(pWindow);
        if (hr)
            goto Cleanup;

        pAccObj = pWindow->_pAccWindow;
    }
    else if (lParam > 0)
    {
        hr = _aryAccEvents.GetAccEvtSource(lParam, &accEvtRec);
        if (hr)
            goto Cleanup;

        Assert(accEvtRec.pObj);

        // The base object can be a window or an element
        // We will only release the additional reference we have on the element
        // once we have created the accessible object for it, since the reference
        // we have may be the only reference left.
        if (accEvtRec.fWindow)
        {
            hr = EnsureAccWindow(DYNCAST(CWindow, accEvtRec.pObj));
            if (hr)
                goto Cleanup;

            pAccObj = DYNCAST(CWindow, accEvtRec.pObj)->_pAccWindow;
        }
        else
        {
            CElement * pElement = DYNCAST(CElement, accEvtRec.pObj);

            // if an element is out of a markup, don't try to return a pointer to it at all.
            if (pElement->HasMarkupPtr())
            {
                // Ensure the accwindow object for this element.
                if (EnsureAccWindow(pElement->GetCWindowPtr()))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                pAccObj = GetAccObjOfElement(pElement);
                if (!pAccObj)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }
    // else is cases such as the title bar window, system menu window etc. 
    // all have negative handles used by OLEACC.

    // Convert the punk into an lresult, which is an OS means of
    // converting the punk into a handle that can be marshalled.

    // Note: Although this returns an interface pointer, we do not
    // addref it here.  There will be an addref performed when the
    // caller call ObjectFromLresult. (This isn't in the documentation,
    // but LauraBu swears it happens.)
    //
    // Of course, this is craziness, because if the object we return
    // is deallocated before the client calls ObjectFromLResult, someone
    // is in trouble. Laura replies that inproc clients always call
    // immediately, and out-of-proc clients somehow deal with it.

    if ( pAccObj )
    {
        *plResult = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
                s_dynprocLresultFromObject.pfn)(IID_IAccessible, 
                                                wParam, 
                                                (IAccessible *)pAccObj);
    }

Cleanup:

    // we want to bail not fail.  if ANY error happens we want to pretend nothing 
    //  was ever processed, and that the WM_GETOBJECT was never handled to begin 
    //  with. 
    if (hr || (plResult && FAILED(*plResult)))
        *plResult = S_OK;

#endif
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ActivateDefaultButton, protected
//
//  Synopsis:   Activate the default button on the form, if any
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateDefaultButton(LPMSG lpmsg)
{
    HRESULT         hr = S_FALSE;
    CElement *      pElem;   

    //  The container of this form is always given precedence,
    //    unless the currently active control is a "Push" button

    if (_pElemCurrent && _pElemCurrent->_fActsLikeButton)
    {
        pElem = _pElemCurrent;
        hr = S_OK;
    }
    else
    {
        pElem = _pElemCurrent->FindDefaultElem(TRUE);
    }

    if (pElem)
    {
        Assert(!pElem->IsEditable(/*fCheckContainerOnly*/TRUE));
        Assert(pElem->_fDefault);

        //  TODO error dialog?
        _fFirstTimeTab = FALSE;
        hr = THR(pElem->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        if (hr)
            goto Cleanup;

        hr = THR(pElem->DoClick());
    }
    else
    {
        hr = S_FALSE;
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ActivateCancelButton, protected
//
//  Synopsis:   Activate the cancel button on the form, if any
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateCancelButton(LPMSG lpmsg)
{
    HRESULT     hr = S_FALSE;
    CElement *  pElem = _pElemCurrent;
    
    if (!pElem)
        goto Cleanup;

    if (!pElem->TestClassFlag(CElement::ELEMENTDESC_CANCEL))
    {
        // find cancel site
        pElem = _pElemCurrent->FindDefaultElem(FALSE, TRUE);
    }
    if (!pElem)
        goto Cleanup;

    Assert(!pElem->IsEditable(/*fCheckContainerOnly*/TRUE));

    _fFirstTimeTab = FALSE;
    hr = THR(pElem->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
    if (!hr)
    {
        hr = THR(pElem->DoClick());
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InvalidateDefaultSite
//
//  Synopsis:   Invalidate the current site
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InvalidateDefaultSite()
{
    CElement * pElemDefault;
    if (!_pElemCurrent->IsEditable(/*fCheckContainerOnly*/TRUE) && !_pElemCurrent->_fDefault)
    {
        pElemDefault = _pElemCurrent->FindDefaultElem(TRUE);
        if (pElemDefault && pElemDefault != _pElemCurrent)
        {
            pElemDefault->Invalidate();
        }
    }

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::FixZOrder
//
//  Synopsis:   Inserts the given site's window at the proper place in
//              physical Z order, given the site's position in the logical
//              Z order as well as its current OLE state
//
//-------------------------------------------------------------------------
void
CDoc::FixZOrder()
{
    _view.SetFlag(CView::VF_DIRTYZORDER);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetZOrder
//
//  Synopsis:   Moves the current selection in the logical Z order.
//
//  Arguments:  [zorder]    action
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetZOrder(int zorder)
{
    CLayout *   pLayoutCurrent = _pElemCurrent->GetUpdatedLayout();


    if (!pLayoutCurrent)
        goto Cleanup;


    FixZOrder();
    Invalidate();

    //  TODO send OnDataChange?

Cleanup:
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowErrorDialog
//
//-------------------------------------------------------------------------
HRESULT
CWindow::ShowErrorDialog(VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    VARIANT varIn;
    CVariant varOut;
    CDoc * pDoc = Doc();
    CDoEnableModeless dem(pDoc, this);

    if (pDoc->_dwLoadf & DLCTL_SILENT)
        goto Cleanup;    

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *) Document();

    if (pDoc->_pHostUICommandHandler && !pDoc->_fOutlook98)
    {
        hr = pDoc->_pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWSCRIPTERROR,
                0,
                &varIn,
                &varOut);
        if (!hr)
            goto Cleanup;
    }

    pDoc->EnsureBackupUIHandler();
    if (pDoc->_pBackupHostUIHandler)
    {
        IOleCommandTarget * pBackupHostUICommandHandler;

        hr = pDoc->_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                (void **) &pBackupHostUICommandHandler);
        if (hr)
            goto Cleanup;

        hr = pBackupHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWSCRIPTERROR,
                0,
                &varIn,
                &varOut);

        ReleaseInterface(pBackupHostUICommandHandler);
    }

Cleanup:
    if (V_VT(&varOut) == VT_BOOL)
        *pfRet = V_BOOL(&varOut);   
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowContextMenu
//
//  Synopsis:   Returns the context menu based on the sub-menu id.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::ShowContextMenu(
        int x,
        int y,
        int id,
        CElement * pMenuObject)
{
    HRESULT                 hr = S_FALSE;   // Assume we keep bubbling.
#ifndef NO_MENU
    IOleCommandTarget *     pCommandTarget = NULL;
    IDispatch *             pDispatch = NULL;
    CElement::CLock         lock(pMenuObject);
    GDIPOINT                pt;
    BOOL                    fSkipHostUIHandler;

    _fDisableReaderMode = TRUE;
    _pMenuObject = pMenuObject;
   
    pt.x = x;
    pt.y = y;

    // DEBUG menu is only valid in debug builds. 
    if (GetAsyncKeyState(VK_CONTROL) < 0)
    {    
#if DBG==1 && !defined(WINCE)     
        id = CONTEXT_MENU_DEBUG;
#else
        if (id == CONTEXT_MENU_DEBUG)
            goto Cleanup;
#endif
    }


    // Query the host UIHandler to handle the context menu
    hr = THR(QueryInterface(
            IID_IOleCommandTarget,
            (void **) &pCommandTarget));
    if (hr)
        goto Cleanup;

    if (pMenuObject)
    {
        pMenuObject->QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch);
    }
    
    // if pMenuObject==NULL or doesn't support IDispatch
    // then default to the document's IDispatch
    if (!pDispatch)
    {
        hr = THR(QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch));
        if (hr)
            goto Cleanup;
    }

    
    // for active desktop items, trident is directly hosted by shell32, which also handles context menus
    // if we are in an active desktop item, we want trident context menus not shell context menus, 
    // so we need to bypass the shell32 UI handler
    fSkipHostUIHandler = DocIsDeskTopItem(this) && pMenuObject && !pMenuObject->IsInPrimaryMarkup();


    if (    !fSkipHostUIHandler
#if DBG==1
        &&  id != CONTEXT_MENU_DEBUG           // Don't let hosts override debug menu                 
#endif        
       )
    {
        if (_pHostUIHandler)
        {
            _fInhibitOnMouseOver = TRUE;
            hr = _pHostUIHandler->ShowContextMenu(
                id,
                (POINT *)&pt,           //cast is for win16, doesn't affect 32bit.
                pCommandTarget,
                pDispatch);
            
            _fInhibitOnMouseOver = FALSE;

            // Host has displayed context menu, forms3 will not display it.
            if (!hr)
                goto Cleanup;
        }
    }

    // If we don't allow a selection, don't allow a contex menu either
    // More detail: We want to disallow context menus on everything that
    // matched the following conditions:
    //      1. we're in a dialog.
    //      2. we're not an text input control (textbox, textarea, etc).
    // DisallowSelection checks if we're in a dialog and if the layout
    // has the _fAllowSelectionInDialog bit set. That bit is currently only
    // set on textareas, htmlareas, and text inputs.
    if (pMenuObject->DisallowSelection())
    {
        hr = S_OK;
        goto Cleanup;
    }

    
    // Either we don't have a _pHostUIHandler, or it didn't return S_OK.  Go to our backup.
    EnsureBackupUIHandler();     
    if (_pBackupHostUIHandler)    
    {
        _fInhibitOnMouseOver = TRUE;
        hr = THR(_pBackupHostUIHandler->ShowContextMenu(        
            id,            
            (POINT *)&pt,           //cast is for win16, doesn't affect 32bit.           
            pCommandTarget,            
            pDispatch));

        _fInhibitOnMouseOver = FALSE;
        
        // Backup has displayed context menu        
        hr = S_OK;
        goto Cleanup;
    }     
    

Cleanup:
    _pMenuObject = NULL;
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pDispatch);

    _fDisableReaderMode = FALSE;

#endif // NO_MENU
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::InsertMenuExt
//
//  Arguments:  hMenu       The menu to insert in
//
//  Synopsis:   Takes the hMenu passed in and then adds a separator
//              followed by all of the menu extensions.  These are
//              insterted if and where IDM_MENUEXT_PLACEHOLDER is.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

DeclareTag(tagMenuExt, "MenuExt", "Menu Extensions");

HRESULT
CDoc::InsertMenuExt(HMENU hMenu, int id)
{
    HRESULT     hr = S_OK;
    int         nExts;

    Assert(IsMenu(hMenu));

    // If our placeholder is gone or was never there, then just exit
    if(GetMenuState(hMenu, IDM_MENUEXT_PLACEHOLDER, MF_BYCOMMAND) == (UINT) -1)
    {
        goto Cleanup;
    }

    //
    // Add the context menu extensions
    //
    nExts = _pOptionSettings->aryContextMenuExts.Size();
    if(nExts != 0)
    {
        CONTEXTMENUEXT **   ppCME;
        int                 nExtCur = 0;
        int                 nExtFirst = 0;

        // Limit the number of extensions
        if(nExts > IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__)
        {
            nExts = IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__;
        }

        TraceTag((tagMenuExt, "%d menu exts", nExts));

        //
        // Add each of the extensions
        //

        for(ppCME = _pOptionSettings->aryContextMenuExts;
            nExtCur < nExts;
            nExtCur++, ppCME++)
        {
            if((*ppCME)->dwContexts & (0x1 << id))
            {
                Assert(IDM_MENUEXT_FIRST__ + nExtCur <= IDM_MENUEXT_LAST__);

                TraceTag((tagMenuExt, "Inserting %d: %ls",
                          IDM_MENUEXT_FIRST__ + nExtCur,
                          (LPTSTR)(*ppCME)->cstrMenuValue));

                if(!InsertMenu(hMenu,                           // The Context Menu
                               IDM_MENUEXT_PLACEHOLDER,         // The item to insert before
                               MF_BYCOMMAND|MF_STRING,          // by item ident and str value
                               IDM_MENUEXT_FIRST__ + nExtCur,   // the command id
                               (LPTSTR)(*ppCME)->cstrMenuValue))// The menu name
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }

                if(!nExtFirst)
                {
                    nExtFirst = IDM_MENUEXT_FIRST__ + nExtCur;
                }
            }
        }

        //
        // Add a separator if necessary
        //

        if(nExtFirst)
        {
            if(!InsertMenu(hMenu,                       // The context menu
                           nExtFirst,                   // The item to insert before
                           MF_BYCOMMAND|MF_SEPARATOR,   // by item ident
                           0,                           // the command id
                           NULL))                       // type value
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }
        }
    }

    //
    // Remove our placeholder
    //

    if(!DeleteMenu(hMenu,                   // The context menu
                   IDM_MENUEXT_PLACEHOLDER, // The item to delete
                   MF_BYCOMMAND))           // by item ident
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowDragContextMenu
//
//  Synopsis:   Shows the drag context menu upon a right button drop.
//
//  Arguments:  ptl           Where to pop the menu up
//              dwAllowed     Allowed actions for drag
//              piSelection   The choice selected by the menu.
//
//  Returns:    If the user selected a choice on the menu, S_OK.
//              If the menu was brought down, S_FALSE, errors otherwise.
//
//-------------------------------------------------------------------------
HRESULT
CDoc::ShowDragContextMenu(POINTL ptl, DWORD dwAllowed, int *piSelection, LPTSTR lptszFileType)
{
#ifdef NO_DRAGDROP
    return S_OK;
#else
    HRESULT                     hr;

    HMENU   hMenu;
    HMENU   hCtxMenu;
    HCURSOR hOldCursor;
    HCURSOR hArrow = LoadCursor(NULL, IDC_ARROW);

    if(hArrow == NULL)
        RRETURN(GetLastError());

    hMenu = TW32(0, LoadMenu(GetResourceHInst(), MAKEINTRESOURCE(IDR_DRAG_CONTEXT_MENU)));
    if (!hMenu)
        RRETURN(GetLastWin32Error());

    hCtxMenu = GetSubMenu(hMenu, 0);

    // Modify the sub menu based on whether particular choices are
    // available.
    if (!(dwAllowed & DROPEFFECT_MOVE) || (_fFromCtrlPalette))
    {
        EnableMenuItem(hCtxMenu,
            DROPEFFECT_MOVE,
            MF_BYCOMMAND | MF_GRAYED);
    }
    if (!(dwAllowed & DROPEFFECT_COPY))
    {
        EnableMenuItem(hCtxMenu,
            DROPEFFECT_COPY,
            MF_BYCOMMAND | MF_GRAYED);
    }

    //
    // Get the old cursor, and make new cursor into arrow
    //
    hOldCursor = ::SetCursor(hArrow);

    hr = THR(FormsTrackPopupMenu(
            hCtxMenu,
            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
            ptl.x + CX_CONTEXTMENUOFFSET,
            ptl.y + CY_CONTEXTMENUOFFSET,
            NULL,
            piSelection));

    // Now set back the old cursor
    ::SetCursor(hOldCursor);

    RRETURN1(hr, S_FALSE);
#endif // NO_DRAGDROP
}

#if DBG == 1
#ifndef UNIX

DeclareTag(tagZOrder, "ZOrder", "Form ZOrder information");

#define GetWinText(hwnd, sz, cch) if (!GetWindowText(hwnd, sz, cch)) _tcscpy(sz, _T("(null)"));

void
DisplayChildZOrder(HWND hwnd)
{
    TCHAR szClass[255], szTitle[255];
    LONG  lStyle;

    if (!hwnd)
        return;

    GetClassName(hwnd, szClass, 255);
    GetWinText(hwnd, szTitle, 255);

    TraceTag((tagZOrder, "Parent Window: %p, %ls, %ls", hwnd, szClass, szTitle));

    HWND hwndChild = GetWindow(hwnd, GW_CHILD);

    if (!hwndChild)
    {
        TraceTag((tagZOrder, "No Child Windows!"));
        return;
    }

    GetClassName(hwndChild, szClass, 255);
    GetWinText(hwndChild, szTitle, 255);
    lStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);

    TraceTag((tagZOrder, "Highest Child Window: %p, %ls, %ls%ls",
                   hwndChild, szClass, szTitle,
                   (lStyle & WS_EX_TOPMOST) ? _T(" (Topmost)") : _T("")
                   ));

    while ((hwndChild = GetWindow(hwndChild, GW_HWNDNEXT)) != NULL)
    {
        GetClassName(hwndChild, szClass, 255);
        GetWinText(hwndChild, szTitle, 255);
        lStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);

        TraceTag((tagZOrder, "   Next Child Window: %p, %ls, %ls%ls",
                       hwndChild, szClass, szTitle,
                       (lStyle & WS_EX_TOPMOST) ? _T(" (Topmost)") : _T("")
                       ));
    }

    return;
}
#else
void
DisplayChildZOrder(HWND hwnd)
{}
#endif // !UNIX
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HasCapture
//
//  Synopsis:   
//
//----------------------------------------------------------------------------

BOOL CDoc::HasCapture(CElement *pElement)
{
    if (!_pInPlace)
        return FALSE;

    if (!pElement)
    {
        if (_aryStackCapture.Size())
        {
            Assert(GetCapture());
            return TRUE;
        }
    }
    else
    {
        int i, lSizeStack = _aryStackCapture.Size();

        for ( i = 0; i < lSizeStack; i ++ )
        {
            if (_aryStackCapture[i]->_pElement == pElement)
            {
                Assert(GetCapture());
                return TRUE;
            }
        }
    }
    return GetCapture();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetMouseCapture
//
//  Synopsis:   Mouse capture utilities.
//
//----------------------------------------------------------------------------

void CDoc::SetMouseCapture(
    PFN_ELEMENT_MOUSECAPTURE   pfnTo,
    CElement                *pElement,
    BOOL                    fContainer,
    BOOL                    fFireOnNodeHit)
{
    int i;
    int lSizeStack = _aryStackCapture.Size();
    CElementCapture *pCapture;

    TraceTag((tagCapture, "SetCapture %x %x %ls-%d  fCont: %d  _fOnLose: %d",
            this, pElement, (pElement ? pElement->TagName() : L"null"),
            (pElement ? pElement->SN() : 0), fContainer, _fOnLoseCapture));

    if (_fOnLoseCapture)
    {
        //
        // make sure we empty the whole capture array
        //
        pElement = NULL;
    }

    if (!pElement)
    {
        //
        // request for a full capture release
        //

        if (lSizeStack)
        {
            for (i = lSizeStack - 1; i >= 0; i --)
            {
                if (    !_aryStackCapture[i]->_fFiredEvent
                    &&  !_aryStackCapture[i]->_pElement->_fExittreePending)
                {
                    _aryStackCapture[i]->_fFiredEvent = TRUE;
                    _fOnLoseCapture = TRUE;
                    
                    _aryStackCapture[i]->_pElement->Fire_onlosecapture();
                   
                    _fOnLoseCapture = FALSE;
                }
                //
                // during the event firing, the stack might be insane
                //
                lSizeStack = _aryStackCapture.Size();

                //
                // if insane
                // go out of the loop
                //

                if (!lSizeStack)
                    break;
                
                delete _aryStackCapture[i];
            }
            _aryStackCapture.DeleteAll();
        }

        if (    State() < OS_INPLACE
            &&  ::GetCapture() == _hwndCached)
        {
            // NOTE(sujalp): When we are no longer inplace, but we
            // may still have our window around in CDoc::hwndCached.
            // Check if this window has the capture and if it does
            // then release the capture. If not then, probably some
            // other window has captured the mouse so do not release it.
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif
            ::ReleaseCapture();
        }
        else
        {
            SetCapture(FALSE);
        }
        return;
    }

    //
    // verify if pElement has the capture, if so, do nothing
    //

    for (i = lSizeStack-1; i >= 0 && _aryStackCapture[i]->_pElement != pElement; i--);

    if (i >= 0)
        return;

    //
    // Add the new capture object
    //

    CElementCapture *pCaptureNew = new CElementCapture(pfnTo, pElement, fContainer, fFireOnNodeHit);

    if (!pCaptureNew)
        return;

    pCapture = GetLastCapture();

    //
    // Container capture means that the element takes
    // the capture and all mouse messages/events should
    // be targeting to it.
    // When the capture is not a container capture, events
    // will be targeting to the elements scoped inside it
    //

    if (!pCapture || !HasContainerCapture(pElement->GetFirstBranch()))
    {
        //
        // the Doc doesn't have container capture
        // push the capture in the stack
        //
        IGNORE_HR(_aryStackCapture.Append(pCaptureNew));
        if (!pCapture)
        {
            SetCapture(TRUE);
        }
        return;
    }
    //
    //
    // If we've got a capture object which is different from the argument
    // object, tell it that we're losing capture
    // 
    CMessage Message((MSG *)NULL);

    Message.message = WM_CAPTURECHANGED;

    // Tell the captured object that it's losing the capture
    IGNORE_HR( PumpMessage(&Message, NULL) );

    //
    // delete the previous capture if it is not Container Capture
    // has to do the container part
    //

    if (!pCapture->_fFiredEvent && !pCapture->_pElement->_fExittreePending)
    {
        pCapture->_fFiredEvent = TRUE;
        _fOnLoseCapture = TRUE;

        pCapture->_pElement->Fire_onlosecapture( );

        _fOnLoseCapture = FALSE;
    }

    //
    // during the event firing, the stack might be insane
    // if insane
    // don't do any capture work
    //

    if (!_aryStackCapture.Size())
    {
        delete pCaptureNew;
        return;
    }

    delete pCapture;
    _aryStackCapture.Delete(lSizeStack - 1);

    IGNORE_HR(_aryStackCapture.Append(pCaptureNew));
}

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::ClearMouseCapture
//
//  Synopsis:   Releases the capture object without notification. Used by
//              objects to revoke their own capture.
//              if pvObject is NULL, we will release all captures
//
//---------------------------------------------------------------------------

void
CDoc::ClearMouseCapture(CElement *pElement)
{
    int lSizeStack2, lSizeStack = _aryStackCapture.Size();
    int i, j;

    if (!lSizeStack)
        return;

    if (!pElement || _aryStackCapture[0]->_pElement == pElement)
    {
        SetMouseCapture(NULL, NULL);
        return;
    }

    //
    // Search for the capture element
    //
    
    for (i = lSizeStack-1; i > 0 && _aryStackCapture[i]->_pElement != pElement; i--);

    if (i == 0)
        return;

    Assert(lSizeStack > 1);
    j = i;

    for (i = lSizeStack - 1; i >= j; i --)
    {
        if (    !_aryStackCapture[i]->_fFiredEvent
            &&  !_aryStackCapture[i]->_pElement->_fExittreePending)
        {
            _aryStackCapture[i]->_fFiredEvent = TRUE;
            _fOnLoseCapture = TRUE;

            _aryStackCapture[i]->_pElement->Fire_onlosecapture( );
            
            _fOnLoseCapture = FALSE;
        }
        //
        // during the event firing, the stack might be insane
        //
        lSizeStack2 = _aryStackCapture.Size();

        //
        // if insane
        // go out of the loop
        //

        if (!lSizeStack2)
            return;
        delete _aryStackCapture[i];
    }
    _aryStackCapture.DeleteMultiple(j, lSizeStack - 1);

    //
    // Since there is still at least one capture object in the stack
    // we don't release window capture
    //
}

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseDetachedCaptures
//
//  Synopsis:   Releases the capture object which is no longer in the tree
//
//---------------------------------------------------------------------------

void
CDoc::ReleaseDetachedCaptures()
{
    int lSizeStack = _aryStackCapture.Size();
    int i, j;

    if (!lSizeStack)
        return;

    if (!_aryStackCapture[0]->_pElement->GetFirstBranch())
    {
        SetMouseCapture(0, 0);
        return;
    }

    for ( i = 1; i < lSizeStack && _aryStackCapture[i]->_pElement->GetFirstBranch(); i ++ );

    if (i == lSizeStack)
        return;

    j = i;

    for (; i < lSizeStack; i ++ )
    {
        delete _aryStackCapture[i];
    }
    _aryStackCapture.DeleteMultiple(j, lSizeStack - 1);
}

CElementCapture * CDoc::GetLastCapture()
{
    int iSize = _aryStackCapture.Size();

    if (!iSize)
        return NULL;

    return _aryStackCapture[iSize - 1];
}
 
CElementCapture::CElementCapture(PFN_ELEMENT_MOUSECAPTURE pfn, CElement *pElem, BOOL fContainer, BOOL fFireOnNodeHit)
{
    //
    // Args must be either both NULL == Release capture
    // Or both non-null == Set capture
    //
    // AssertSz(pfn && pElem || !pfn && !pElem, "Bad Arguments");

    _pfn        = pfn;
    _pElement   = pElem;

    Assert (_pElement);
    _pElement->AddRef();
    _fContainer = fContainer;
    _fFiredEvent = FALSE;
    _fFireOnNodeHit = fFireOnNodeHit;
}

CElementCapture::~CElementCapture()
{
    if (_pElement)
    {
        _pElement->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HasContainerCapture(CTreeNode *pNode)
//
//  Synopsis:   .
//
//----------------------------------------------------------------------------

BOOL    CDoc::HasContainerCapture(CTreeNode *pNode)
{
    CElementCapture *pCapture = GetLastCapture();
    BOOL            fHasContainerCapture = FALSE;

    if( pCapture )
    {
        //
        // if we have container capture, or the node passed in is the capture element,
        // then we have capture
        //
        fHasContainerCapture = pCapture->_fContainer || 
                                ( pNode && (pNode == pCapture->_pElement->GetFirstBranch() ) );

        if( !fHasContainerCapture )
        {
            //
            // We know that container capture is NOT set, so all children of the current capture
            // element should continue to get mouse events as normal.  So 
            // we need to check to see if the node passed in is a child of the element which
            // currently has capture.  If it is a child, then we DO NOT have container capture, 
            // route the message as normal.  If the node in question IS NOT a child of the
            // element which has setup capture, we need to hand all mouse messages to the 
            // element with capture, and we need to return TRUE.
            //
            CTreeNode *pMaster = pNode->GetNodeInMarkup( pCapture->_pElement->GetMarkupPtr() );

            fHasContainerCapture = !pMaster || !pMaster->SearchBranchToRootForScope( pCapture->_pElement );
        }
    }
    
    return fHasContainerCapture;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PumpMessage
//
//  Synopsis:   Fires the event and then hands over the message to pTarget. If
//              ptarget is NULL, the message is handed over to the capture
//              object.
//
//----------------------------------------------------------------------------
HRESULT
CDoc::PumpMessage(CMessage * pMessage, CTreeNode * pNodeTarget, BOOL fPerformTA)
{
    HRESULT     hr              = S_OK;
    BOOL        fInRecursion    = _fInPumpMessage;
    BOOL        fSaveModalState = _fModalDialogInScript; // to handle recursion
    BOOL        fEventCancelled = FALSE;
    CTreeNode * pNodeHit        = pMessage->pNodeHit;
    CTreeNode * pCurNode        = NULL;
    CTreeNode * pNodeFireEvent  = NULL;
    CTreeNode * pNodeFireEventSrcElement = NULL;
    CElement  * pElemCurrentOld = _pElemCurrent;
    ULONG       cDie            = _cDie;
    BOOL        fMouseMessage   =   (   (pMessage->message >= WM_MOUSEFIRST)
                                     && (pMessage->message <= WM_MOUSELAST))
                                  ||    (pMessage->message == WM_SETCURSOR)
                                  ||    (pMessage->message == WM_CAPTURECHANGED)
                                  ||    (pMessage->message == WM_MOUSELEAVE)
                                  ||    (pMessage->message == WM_MOUSEOVER);
    BOOL        fSiteSelected   = FALSE;
    EVENTINFO evtInfo;
    BOOL fHadCapture = FALSE;
    CTreeNode * pNodePrimaryRoot   = PrimaryRoot()->GetFirstBranch();
    IHTMLEditor* ped = _pIHTMLEditor;
    BOOL        fPopupKeyMsg    =   _fPopupDoc 
                                &&  pMessage->message >= WM_KEYFIRST
                                &&  pMessage->message <= WM_KEYLAST;
     
    if ( ped )
    {
        ped->AddRef();
    }
    
    Assert(pNodePrimaryRoot);
    
    //  TODO(laszlog): This should be changed into a real fix!
    if ( ! _pElemCurrent || _pElemCurrent->Tag() == ETAG_DEFAULT )
    {
        return S_OK;
    }

    Assert(pMessage);

    AssertSz((  pNodeTarget
                && !pNodeTarget->IsDead()
                && pNodeTarget->Element()
                && pNodeTarget->IsInMarkup())
            || HasCapture() // TODO: investigate this (marka)
            || !GetLastCapture()
            || GetLastCapture()->_pElement->IsInMarkup()
            || pMessage->message == WM_MOUSEOVER
            || pMessage->message == WM_MOUSELEAVE,
             "Trying to send a windows message to an element not in the tree");

    _fInPumpMessage = TRUE;

    // In browse mode, if the mouse is clicked on a child of BUTTON,
    // we want to send that click to the BUTTON instead. IE5 #34796, #26572
    switch (pMessage->message)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        if (pNodeHit && !pNodeHit->Element()->IsEditable(TRUE))
        {
            CTreeNode * pNodeLoop = pNodeHit;

            while (pNodeLoop && pNodeLoop->Tag() != ETAG_BUTTON)
            {
                pNodeLoop = pNodeLoop->Parent();
            }
            if (pNodeLoop)
            {
                if (pNodeLoop != pNodeHit)
                {
                    if (pNodeTarget == pNodeHit)
                    {
                        pNodeTarget = pNodeLoop;
                    }

                    // pNodeHit is parented by a BUTTON.
                    pNodeHit = pNodeLoop;
                    hr = THR( pMessage->SetNodeHit(pNodeHit) );
                    if( hr )
                        goto Cleanup;
                    pMessage->lSubDivision = 0;
                }
            }
        }
    }

    switch (pMessage->message)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
        Assert(pNodeHit || !pNodeTarget);
        hr = THR( CTreeNode::ReplacePtr(&_pNodeGotButtonDown, pNodeHit) );
        if( hr )
            goto Cleanup;
        _fFirstTimeTab = FALSE;
        // fall-through
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (fPerformTA)
        {
            if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
            {
                extern BOOL IsNumpadKey(CMessage *);
                if (!(pMessage->message == WM_SYSKEYDOWN && IsNumpadKey(pMessage)))
                {
                    switch (pMessage->wParam)
                    {
                    case VK_MENU:
                        if (_wUIState & UISF_HIDEACCEL)
                            SendMessage(_pInPlace->_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);
                        break;
                    case VK_RIGHT:
                    case VK_LEFT:
                    case VK_UP:
                    case VK_DOWN:
                    case VK_TAB:
                        if (_wUIState & UISF_HIDEFOCUS)
                            SendMessage(_pInPlace->_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
                        break;                
                    }
                }
            }
        }

        // Kill any task that's waiting to scroll or jump to a bookmark
        // TODO (jbeda) we have to figure out he right markup to send these to

        // Set a flag to indicate that the user has started interacting.
        // We use this flag to cancel restoring history like scroll/caret
        // positions.    
        {
            CMarkup * pMarkupCurrent = _pElemCurrent->GetMarkup();

            pMarkupCurrent->_fUserInteracted = TRUE;
            pMarkupCurrent->TerminateLookForBookmarkTask();
        }
        break;

    case WM_CONTEXTMENU:
        // if generated by the mouse, this WM_CONTEXTMENU should be treated as
        // a mouse message.  This will cause proper mouse capture behavior.
            if ((GET_X_LPARAM(pMessage->lParam) != -1) || 
                (GET_Y_LPARAM(pMessage->lParam) != -1))
            {
                fMouseMessage = TRUE;
            }
        break;
    }

#ifndef WIN16
    // NB (cthrash) If we get a TranslateAccelerator message directly from
    // our host, we need to be sensitive to whether the host's message loop
    // gets Unicode our Multibyte window messages.  For our internal purposes,
    // we need the WM_CHAR message to be in Unicode, so we need to convert
    // when appropriate.
    if (pMessage->message == WM_CHAR &&
        ( VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID ||
          !IsWindowUnicode( pMessage->hwnd ) ))
    {
        UINT uKeyboardCodePage = GetKeyboardCodePage();
        
        if (!_bLeadByte && IsDBCSLeadByteEx(uKeyboardCodePage, (BYTE)pMessage->wParam))
        {
            _bLeadByte = BYTE(pMessage->wParam);
            goto Cleanup;
        }
        else
        {
            // Translate the character to unicode
            CHAR ach[2];
            wchar_t wch;

            if (_bLeadByte)
            {
                ach[0] = _bLeadByte;
                ach[1] = (BYTE)pMessage->wParam;
            }
            else
            {
                ach[0] = (BYTE)pMessage->wParam;
                ach[1] = 0;
            }

            WHEN_DBG(int cchDbg =)
            MultiByteToWideChar(uKeyboardCodePage, 0,
                                ach, ach[1] ? 2 : 1, &wch, 1);

            //
            // HACK (cthrash) For codepages which don't support the Euro symbol,
            // convert multibyte value of 128 simply results in U+0080.  Since
            // this is never what the user wanted (it's a control character), we
            // hack this to convert to the Euro.
            //  

            if (   wch == 128
                && ach[1] == 0
                && BYTE(ach[0]) == 128)
            {
                wch = WCH_EURO;
            }
                
            AssertSz(1== cchDbg, "Char convert failed");
            pMessage->wParam = wch;
            _bLeadByte = 0;
        }
    }
#endif // WIN16

    // Determine who should fire the event for this message

    if (!pNodeHit)
    {
        pNodeFireEvent = _pElemCurrent ? _pElemCurrent->GetFirstBranch() : NULL;
    }
    else
    {
        if (pMessage->pElementEventTarget)
        {
            pNodeFireEvent = pMessage->pElementEventTarget->GetFirstBranch();
            pNodeFireEventSrcElement = pNodeHit;
        }
        else
        {
            pNodeFireEvent = pNodeHit;
        }
    }

    if (!pNodeFireEvent)
        goto Cleanup;

    Assert(pNodeFireEvent);

    _fModalDialogInScript = FALSE;


    //
    // release all detached captures
    //

    ReleaseDetachedCaptures();

    if (    fMouseMessage
        &&  HasContainerCapture(pNodeFireEvent))
    {
        CElementCapture *pCapture = GetLastCapture();
        pNodeFireEventSrcElement = pNodeFireEvent;
        if (!pCapture->_fFireOnNodeHit)
            pNodeFireEvent = pCapture->_pElement->GetFirstBranch();

        Assert(pNodeFireEventSrcElement);
        Assert(pNodeFireEvent);
        if (pNodeFireEventSrcElement->GetMarkup() != pNodeFireEvent->GetMarkup())
        {
            // Fix for #86892
            // If a master has capture and its slave is the src element, then change
            // the src element to be the master, to ensure encapsulation.
            if (    pNodeFireEventSrcElement->Element()->HasMasterPtr()
                &&  pNodeFireEventSrcElement->Element()->GetMasterPtr() == pNodeFireEvent->Element())
            {
                pNodeFireEventSrcElement = NULL;
            }
            else
            {
                pNodeFireEventSrcElement = NULL;
            }
        }
        fHadCapture = TRUE;
    }

    if (!fPerformTA)
    {
        // We have already fired the event for certain messages in the TA pass
        switch (pMessage->message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
            pMessage->fEventsFired = TRUE;
            break;
        }
    }

    if (    !pMessage->fEventsFired
         && pNodeFireEvent != pNodePrimaryRoot)
    {
    
        CTreeNode::CLock lock;
        hr = THR( lock.Init( pNodeFireEvent ) );
        if( hr )
            goto Cleanup;


        fEventCancelled = (S_FALSE != THR(pNodeFireEvent->Element()->
                                            FireStdEventOnMessage(pNodeFireEvent, pMessage, NULL, pNodeFireEventSrcElement, & evtInfo )));

        Assert( ! evtInfo._fDontFireEvent ||
                ( evtInfo._fDontFireEvent && !fEventCancelled ));
                
        if ( evtInfo._pParam == NULL &&
             ( pMessage->message == WM_IME_STARTCOMPOSITION ||
               pMessage->message == WM_IME_ENDCOMPOSITION || 
               pMessage->message == WM_IME_COMPOSITIONFULL ||
               pMessage->message == WM_IME_CHAR ||
               pMessage->message == WM_IME_COMPOSITION ||
               pMessage->message == WM_IME_NOTIFY ||
               pMessage->message == WM_INPUTLANGCHANGE ||
               pMessage->message == WM_IME_REQUEST ))
        {
            hr = THR(CreateIMEEventInfo(pMessage, &evtInfo, pNodeFireEvent->Element()));
            if (FAILED(hr))
                goto Cleanup;
        }

        //
        // This is a slight hack.  Well more than a slight hack.  IN IE 5.0, the editor
        // listened directly to windows messages.  Windows fires the WM_LBUTTONDBLCLK message
        // in the following order.  LBUTTONDOWN, LBUTTONUP, LBUTTONDBLCLK, LBUTTONUP.  In 
        // IE 5.0, the editor would intercept the LBUTTONDBLCLK message and fire the
        // OnSelectStart event, notifying our clients that a selection was beginning.
        //
        // In IE 5.5, the editor is only using trident events in order to do all its work.
        // Trident, however, sends the DBLCLICK message in the following order.
        //  LBUTTONDOWN, LBUTTONUP, CLICK, LBUTTONUP, LBUTTONDBLCLK.
        //
        // Therefore the editor is unable to send the OnSelectStart event at the same
        // time as it used to, breaking other applications because of compat.  See bug
        // 86923 for more information.
        // 
        if( evtInfo._pParam == NULL && pMessage->message == WM_LBUTTONDBLCLK )
        {
            hr = THR( CreateDblClickInfo( pMessage, &evtInfo, pNodeFireEvent, pNodeFireEventSrcElement ) );
            if( FAILED(hr) )
                goto Cleanup;
        }
                                                
        if (!AreWeSaneAfterEventFiring(pMessage, cDie))
            goto Cleanup;

        // script may have removed pNodeFireEvent from the tree
        if(pNodeFireEvent->IsDead())
            pNodeFireEvent = pNodeFireEvent->Element()->GetFirstBranch();

        if(!pNodeFireEvent || !pNodeFireEvent->Element()->IsInMarkup())
            goto Cleanup;
    }

    //
    // TODO-NEW_EDIT_EVENTS : Why not always do the currency change irregardless of who has capture ?
    //                        This code is being reworked to put SetEditContext inside of mshtmled. Shouldn't be an issue
    // 

    // Do special stuff for MouseDown/Up messages

    //
    // TODO - designmode check is just for setting currency issue. 
    // Remove this after my set edit context work goes in.
    // 
    if (!HasContainerCapture(pNodeFireEvent) || pNodeTarget && pNodeTarget->GetMarkup()->_fDesignMode )
    {
        switch (pMessage->message)
        {
            case WM_LBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONDOWN:

            if ( !HasContainerCapture(pNodeFireEvent) )
            {
                // Give currency to the site under the mouse, unless the event
                // handler changed currency or the mouse is on a selection.
                // Leave OLEsites alone; let them set their own currency in HandleMessage (#60183)
                Assert(pNodeHit);

                if (_fFirstTimeTab)
                {
                    CLayout * pLayoutClient = pNodeHit->GetMarkup()->GetElementClient()->GetUpdatedLayout();
                    RECT      rc;

                    pLayoutClient->GetRect(&rc);
                    if (PtInRect(&rc, pMessage->pt))
                    {
                        _fFirstTimeTab = FALSE;
                    }
                }
            }

            pCurNode = pMessage->pNodeHit;
            
            if (    pCurNode
                && ! fSiteSelected
                &&  _pElemCurrent == pElemCurrentOld
                &&  (   DifferentScope(_pElemCurrent, pCurNode )
                    ||  _lSubCurrent != pMessage->lSubDivision || !_pInPlace->_fFocus)
                &&  !pCurNode->Element()->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            {
                Assert( pCurNode->GetMarkup() );
                
                //
                // Look for the topmost element client - for frameset pages. 
                //
                CElement* pElemFrame = NULL;
                CWindow * pWindowTop = pCurNode->GetMarkup()->Window() ? pCurNode->GetMarkup()->Window()->Window() : NULL;                
                CMarkup* pMarkupFrame = pWindowTop && pWindowTop->_pWindowParent ? pWindowTop->_pWindowParent->_pMarkup : NULL;                

                pElemFrame = pMarkupFrame ? pMarkupFrame->GetElementClient() : NULL ;            
                
                if (    pMessage->htc <  HTC_GRPTOPBORDER
                    &&  (   pCurNode->Element()->Tag() != ETAG_BODY
                        ||  (   pMessage->htc != HTC_HSCROLLBAR
                            &&  pMessage->htc != HTC_VSCROLLBAR)) 

                        //
                        // Currently our editing in framesets in desing mode doesn't work
                        // properly. A click UI-activates, not site-selects
                        // the code below makes this behavior consistent
                        //
                        
                        ||  ( pElemFrame && 
                              pElemFrame->Tag() == ETAG_FRAMESET &&
                              pElemFrame->IsEditable( FALSE ) &&
                              pCurNode->GetMarkup()->IsScrollingElementClient( pCurNode->Element()) ))                            
                {
                    BOOL        fYieldFailed    = FALSE;
                    CElement *  pElemCurrentNew = pCurNode->Element();

#ifdef UNIX
                    if ((pMessage->message == WM_MBUTTONDOWN) &&  
                        pMessage->pNodeHit->Element()->IsEditable())
                    {
                        // Get selected text before it's gone.
                        HANDLE hszText = MwGetPrimarySelectionData();
                        if(hszText)
                        {
                            g_uxQuickCopyBuffer.GetTextSelection(hszText, FALSE, NULL);
                            GlobalFree(hszText);
                        }
                    }
#endif
                    LONG lButton = 0;

                    switch( pMessage->message )
                    {
                        case WM_LBUTTONDOWN:
                        lButton = 1;
                        break;

                        case WM_RBUTTONDOWN:
                        lButton = 2;
                        break;

                        case WM_MBUTTONDOWN:
                        lButton = 4;
                        break;
                    }

                        
                    if (S_FALSE == NotifySelectionHelper(  EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE, pElemCurrentNew)
                        || S_OK != pElemCurrentNew->BubbleBecomeCurrent(
                            pMessage->lSubDivision, &fYieldFailed, pMessage, TRUE, lButton ))
                    {
                        if (fYieldFailed)
                        {
                            fEventCancelled = TRUE;
                        }
                    }

                    if (!AreWeSaneAfterEventFiring(pMessage, cDie))
                        goto Cleanup;

                    // script may have removed pNodeFireEvent from the tree
                    if(pNodeFireEvent->IsDead())
                        pNodeFireEvent = pNodeFireEvent->Element()->GetFirstBranch();

                    if(!pNodeFireEvent || !pNodeFireEvent->Element()->IsInMarkup())
                        goto Cleanup;
                }
            }

            // if a modal dialog was brought by the event handler, treat it
            // as a cancel
            fEventCancelled = (fEventCancelled || _fModalDialogInScript);
            
            break;

            case WM_LBUTTONUP:
            case WM_MBUTTONUP:
            case WM_RBUTTONUP:
            // If a MouseUp is cancelled, release capture. Any further cleanup
            // required should be performed by the site/element by handling
            // WM_CAPTURECHANGED
            if (fEventCancelled)
            {
                SetMouseCapture (NULL, NULL);
            }
            break;
        }
    }

    //
    // release all detached captures
    //

    ReleaseDetachedCaptures();

    if (!fEventCancelled)
    {
        hr = S_FALSE;
    }

    if (!fEventCancelled && !fPopupKeyMsg)
    {
        if (fPerformTA)
        {
            // don't bubbel through element handlemessage
            hr = THR(PerformTA(pMessage, & evtInfo ));
        }
        else
        {
            if (    fMouseMessage
                &&  HasContainerCapture(pNodeFireEvent))
            {
                hr = THR(GetLastCapture()->CallCaptureFunction(pMessage));                
            }
            else
            {
                // if we lost capture in the event handler or while setting focus,
                // send the message to the element that fired the event
                pNodeTarget = pNodeFireEvent;
                Assert(pNodeTarget->IsInMarkup());
                //
                // Since the htmlInputFile version of CInput has an input
                // and a button that we're simulating, we have to 
                // do this hack.
                //
                BOOL fGiveMsgToEditor = TRUE;

                // Verify that we have a CInput and the message is a WM_CHAR
                if ((pMessage->message  == WM_CHAR) && 
                    (_pElemCurrent->Tag() == ETAG_INPUT))
                {
                    CInput * pInput = DYNCAST(CInput, _pElemCurrent);

                    // We only want the htmlInputFile version of CInput
                    if (pInput->GetType() == htmlInputFile)
                    {
                        // Give the message only if the button doesn't have focus.
                        fGiveMsgToEditor = !pInput->_fButtonHasFocus;
                    }
                }

                // give first chance to the Editor in certain cases

                //
                // TODO-NEW_EDIT_EVENTS : Completely remove all the above fGiveMsgToEditor junk
                //
                                
                if (  fGiveMsgToEditor )
                {
                    if ( ! fHadCapture )
                    {
                        if ( evtInfo._pParam != NULL  ||
                             pMessage->message == WM_KEYDOWN )
                        {

                            if ( evtInfo._pParam == NULL )
                            {
                                evtInfo._pParam = new EVENTPARAM(this, pNodeFireEvent->Element(), NULL, TRUE /*fInitState*/, FALSE /*fPush*/ );
                                
                                const PROPERTYDESC_BASIC* pDesc;
                                
                                InitEventParamForKeyEvent(
                                    evtInfo._pParam , 
                                    pNodeFireEvent, 
                                    pMessage, 
                                    (int*)&pMessage->wParam, 
                                    & pDesc );

                                evtInfo._dispId = (DISPID)(pDesc->c);                               
                            }
                            Assert( evtInfo._pParam != NULL );
                        
                            hr = THR(HandleSelectionMessage(pMessage, FALSE, & evtInfo, HM_Pre ));
                        }                            
                    }
                }

                if (   hr == S_FALSE && 
                       pMessage->pNodeHit &&
                       pMessage->message == WM_LBUTTONUP &&
                       ! pMessage->pNodeClk )
                {
                    SetClick( pMessage );
                }             

                if (hr == S_FALSE)
                {
                    while (pNodeTarget && pNodeTarget->IsInMarkup() && pNodeTarget != pNodePrimaryRoot)
                    {
                        Assert( pNodeTarget && pNodeTarget->IsInMarkup() );
                        // TODO (jbeda) I don't feel confident enough in this
                        // code to let the assert above handle this problem.  Break
                        // out here if we aren't in the markup because otherwise
                        // we *will* crash
                        if (!pNodeTarget || !pNodeTarget->IsInMarkup())
                            break;

                        hr = THR(pNodeTarget->Element()->HandleMessage(pMessage));

                        if (hr != S_FALSE)
                            break;


                        if (pNodeTarget->Element()->HasMasterPtr())
                        {
                            pNodeTarget = pNodeTarget->Element()->GetMasterPtr()->GetFirstBranch();
                        }
                        else
                        {
                            pNodeTarget = pNodeTarget->Parent();
                        }
                        
                        // Don't bubble up WM_MOUSEHWEEL into frameset. Frameset sent the message
                        // down
                        if (    pMessage->message == WM_MOUSEWHEEL
                            &&  pNodeTarget
                            &&  pNodeTarget->Tag() == ETAG_FRAMESET)
                        {
                            break;
                        }
                    }
                }
                // give a second and final chance to the Editor
                if ((hr == S_FALSE) && fGiveMsgToEditor)
                {
                    if ( ! fHadCapture 
                        //
                        // We only call HandleSelectionMessage if there was an OM message
                        // like the windows message.
                        //
                        && ( evtInfo._pParam != NULL  ||
                             ( pMessage->message == WM_KEYDOWN && !fPerformTA ))
                    )
                    {
                        //
                        // TODO-NEW_EDIT_EVENTS : Talk to mohan abt. a better way of acheiving this.
                        //

                        if (evtInfo._pParam == NULL)
                        {
                            evtInfo._pParam = new EVENTPARAM(this, pNodeFireEvent->Element(), NULL, TRUE /*fInitState*/, FALSE /*fPush*/ );
                            
                            const PROPERTYDESC_BASIC* pDesc;
                            
                            InitEventParamForKeyEvent(
                                evtInfo._pParam , 
                                pNodeFireEvent, 
                                pMessage, 
                                (int*)&pMessage->wParam, 
                                & pDesc );

                            evtInfo._dispId = (DISPID)(pDesc->c);                               
                        }
                        Assert( evtInfo._pParam != NULL );
                        
                        hr = THR(HandleSelectionMessage(pMessage, FALSE, & evtInfo , HM_Post ));

                    }                        

                }
            }

            if (hr == S_FALSE)
            {
                LRESULT lr;

                hr = THR(OnDefWindowMessage(pMessage->message, pMessage->wParam, pMessage->lParam, &lr));
            }

        }

        if (!SUCCEEDED(hr))
            goto Cleanup;

        if (S_OK == hr && !fPerformTA)
        {
            CElementCapture * pCapture = GetLastCapture();
            CElement *pelFireTarget = NULL;
            CTreeNode *pNode = NULL;
            BOOL    fFireDblClick = FALSE;

            // Do click or dblclick as appropriate
            if (_fGotDblClk && pMessage->message == WM_LBUTTONUP)
            {
                fFireDblClick = TRUE;
                if (HasContainerCapture(pNodeHit))
                {
                    pelFireTarget = pCapture->_pElement;
                }
                else if (pNodeHit)
                {
                    pelFireTarget = pNodeHit->Element();
                    pNode = pNodeHit;
                }
            }
            else if (pMessage->pNodeClk)
            {
                if (HasContainerCapture(pMessage->pNodeClk) )
                {
                    pelFireTarget = pCapture->_pElement;
                }
                else
                {
                    pelFireTarget = pMessage->pNodeClk->Element();
                    pNode = pMessage->pNodeClk;
                }                
            }
            else if (pMessage->message == WM_LBUTTONUP && HasCapture())
            {
                if (!HasContainerCapture(pNodeHit))
                    pelFireTarget = pNodeHit->Element();
                else
                    pelFireTarget = pCapture->_pElement;
            }

            BOOL fDoOleSite;
            EVENTINFO clkEvtInfo;
            
            if (!pelFireTarget || pelFireTarget->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            {
                fDoOleSite = TRUE;
                clkEvtInfo._fDontFireEvent = TRUE;                
            }
            else
            {
                fDoOleSite = FALSE;
            }                
                
            if (!fDoOleSite || fFireDblClick)
            {
                if (pelFireTarget)
                {
                    if (fFireDblClick)
                    {
                        hr = THR(pelFireTarget->Fire_ondblclick(pNode, pMessage ? pMessage->lSubDivision : 0, & clkEvtInfo ));
                        _fGotDblClk = FALSE;                    
                    }
                    else
                    {
                        hr = THR(pelFireTarget->DoClick(pMessage, pNode, FALSE, & clkEvtInfo ));
                    }
                }

                pMessage->fSelectionHMCalled = FALSE;
                if ( clkEvtInfo._pParam )
                {
                    hr = THR(HandleSelectionMessage(pMessage, FALSE, & clkEvtInfo, HM_Post ));                    
                }
            }
                
        }
    }

    if (!AreWeSaneAfterEventFiring(pMessage, cDie))
        goto Cleanup;

    if (_fInvalInScript && !fInRecursion)
    {
        Assert(_pInPlace);
        Assert(_pInPlace->_hwnd);
        UpdateWindow(_pInPlace->_hwnd);
    }
Cleanup:
    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
    case WM_KILLFOCUS:
        Verify( !CTreeNode::ReplacePtr(&_pNodeGotButtonDown, NULL) );
        break;
    }

    if ( ped )
    {
        ped->Release();
    }

    _fModalDialogInScript = fSaveModalState;
    _fInPumpMessage = fInRecursion;


    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AreWeSaneAfterEventFiring
//
//  Synopsis:   Determines if anything during the event firing has changed
//              things adversly.
//
//----------------------------------------------------------------------------
BOOL
CDoc::AreWeSaneAfterEventFiring(CMessage *pMessage, ULONG cDie)
{
    BOOL fAreWeSane = FALSE;

    if (State() < OS_INPLACE || cDie != _cDie)
        goto Cleanup;

    if ((   pMessage->message >= WM_MOUSEFIRST
         && pMessage->message <= WM_MOUSELAST
        )
        || pMessage->message == WM_SETCURSOR
       )
    {
        if (   pMessage->pNodeHit
            && !pMessage->pNodeHit->Element()->IsInMarkup()
           )
            goto Cleanup;
    }

    fAreWeSane = TRUE;

Cleanup:
    return fAreWeSane;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\markup.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTCTX_HXX
#define X_ROOTCTX_HXX
#include "rootctx.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ESCRIPT_HXX
#define X_ESCRIPT_HXX
#include "escript.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_DLL_HXX_
#define X_DLL_HXX_
#include "dll.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"

#ifndef X_OPTARY_H_
#define X_OPTARY_H_
#include <optary.h>
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_WEBOC_HXX_
#define X_WEBOC_HXX_
#include "weboc.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_MIMEOLE_H_
#define X_MIMEOLE_H_
#define _MIMEOLE_  // To avoid having DECLSPEC_IMPORT
#include "mimeole.h"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif


#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

// TODO: move to global place in trident [ashrafm]
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

#define EXPANDOS_DEFAULT TRUE

MtDefine(CMarkup, Tree, "CMarkup")
MtDefine(CMarkupChangeNotificationContext, CMarkup, "CMarkupChangeNotificationContext")
MtDefine(CMarkupChangeNotificationContext_aryMarkupDirtyRange_pv, CMarkupChangeNotificationContext, "CMarkupChangeNotificationContext::aryMarkupDirtyRange::pv")
MtDefine(CMarkupTextFragContext, CMarkup, "CMarkupTextFragContext")
MtDefine(CMarkupTextFragContext_aryMarkupTextFrag_pv, CMarkupTextFragContext,  "CMarkupTextFragContext::aryMarkupTextFrag::pv")
MtDefine(MarkupTextFrag_pchTextFrag, CMarkupTextFragContext,  "MarkupTextFrag::_pchTextFrag")
MtDefine(CDocFrag, CMarkup, "CDocFrag")
MtDefine(CMarkupScriptContext, Tree, "CMarkupScriptContext")
MtDefine(CMarkup_aryScriptEnqueued_pv, CMarkupScriptContext, "CMarkupScriptContext::_aryScriptEnqueued::_pv")
MtDefine(CMarkup_aryScriptUnblock_pv, CMarkupScriptContext, "CMarkupScriptContext::_aryScriptUnblock::_pv")
MtDefine(CMarkupPeerTaskContext, CMarkup, "CMarkupPeerTaskContext")
MtDefine(LoadInfo, Dwn, "LoadInfo")
MtDefine(CMarkupTransNavContext, CMarkup, "CMarkupTransNavContext");
MtDefine(CMarkupLocationContext, CMarkup, "CMarkupLocationContext");
MtDefine(CMarkupTextContext, CMarkup, "CMarkupTextContext")
MtDefine(CMarkupEditContext, CMarkup, "CMarkupEditContext")
MtDefine(CMarkup_pchDomain, CMarkup, "CMarkup::_pchDomain")
MtDefine(CMarkup_aryFocusItems_pv, CMarkup, "CMarkup::aryFocusItems")
MtDefine(CDoc_aryMarkups_pv, CDoc, "CDoc::_aryMarkups::_pv")
MtDefine(CDocDelegateNavigation_pBuffer, CDoc, "CDoc::DelegateNavigation pBuffer")
MtDefine(CPrivacyInfo, CMarkup, "CPrivacyInfo")

DeclareTag(tagMarkupCSS1Compat, "Markup", "Enforce Strict CSS1 Compatibility")
DeclareTag(tagMarkupOnLoadStatus, "Markup", "trace CMarkup::OnLoadStatus")
DeclareTag(tagNoMetaToTrident, "Markup", "Don't set generator to trident")
DeclareTag(tagCMarkup, "CMarkup", "CMarkup Methods")
DeclareTag(tagCSSWhitespacePre, "CSS", "Enable white-space:pre");

ExternTag(tagSecurityContext);
DeclareTag(tagOrphanedMarkup, "Markup", "Trace orphaned CMarkups")

PerfDbgExtern(tagPerfWatch)
PerfDbgTag(tagDocBytesRead, "Doc", "Show bytes read on done")

DeclareTag(tagPendingAssert, "Markup", "Markup pending in OnLoadStatusDone, was an assert")

extern BOOL IsScriptUrl(LPCTSTR pszURL);

#define _cxx_
#include "markup.hdl"

BEGIN_TEAROFF_TABLE(CMarkup, IMarkupContainer2)
    TEAROFF_METHOD(CMarkup, OwningDoc, owningdoc, ( IHTMLDocument2 ** ppDoc ))
    // End of IMarkupContainer methods, Begin of IMarkupContainer2 methods
    TEAROFF_METHOD(CMarkup, CreateChangeLog, createchangelog, ( IHTMLChangeSink * pChangeSink, IHTMLChangeLog ** pChangeLog, BOOL fForward, BOOL fBackward ) )
#if 0
    TEAROFF_METHOD(CMarkup, GetRootElement, getrootelement, ( IHTMLElement ** ppElement ) )
#endif // 0
    TEAROFF_METHOD(CMarkup, RegisterForDirtyRange, registerfordirtyrange, ( IHTMLChangeSink * pChangeSink, DWORD * pdwCookie ) )
    TEAROFF_METHOD(CMarkup, UnRegisterForDirtyRange, unregisterfordirtyrange, ( DWORD dwCookie ) )
    TEAROFF_METHOD(CMarkup, GetAndClearDirtyRange, getandcleardirtyrange, ( DWORD dwCookie, IMarkupPointer * pIPointerBegin, IMarkupPointer * pIPointerEnd ) )
   TEAROFF_METHOD_(CMarkup, GetVersionNumber, getversionnumber, long, () )
    TEAROFF_METHOD(CMarkup, GetMasterElement, getmasterelement, ( IHTMLElement ** ppElementMaster ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IMarkupTextFrags)
    TEAROFF_METHOD(CMarkup, GetTextFragCount, gettextfragcount, (long *pcFrags) )
    TEAROFF_METHOD(CMarkup, GetTextFrag, gettextfrag, (long iFrag, BSTR* pbstrFrag, IMarkupPointer* pPointerFrag ) )
    TEAROFF_METHOD(CMarkup, RemoveTextFrag, removetextfrag, (long iFrag) )
    TEAROFF_METHOD(CMarkup, InsertTextFrag, inserttextfrag, (long iFrag, BSTR bstrInsert, IMarkupPointer* pPointerInsert ) )
    TEAROFF_METHOD(CMarkup, FindTextFragFromMarkupPointer, findtextfragfrommarkuppointer, (IMarkupPointer* pPointerFind, long* piFrag, BOOL* pfFragFound ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IHTMLChangePlayback)
    TEAROFF_METHOD(CMarkup, ExecChange, execchange, ( BYTE * pbRecord, BOOL fForward ) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CMarkup, IPersistStream)
    // IPersist methods
    TEAROFF_METHOD( CMarkup, GetClassID, getclassid, ( CLSID * pclsid ) )
    // IPersistFile methods
    TEAROFF_METHOD( CMarkup, IsDirty, isdirty, () )
    TEAROFF_METHOD( CMarkup, Load, load, ( LPSTREAM pStream ) )
    TEAROFF_METHOD( CMarkup, Save, save, ( LPSTREAM pStream, BOOL fClearDirty ) )
    TEAROFF_METHOD( CMarkup, GetSizeMax, getsizemax, ( ULARGE_INTEGER FAR * pcbSize ) )
END_TEAROFF_TABLE()





const CBase::CLASSDESC CMarkup::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &CDoc::s_apHdlDescs,            // _apHdlDesc
};

extern "C" const GUID   SID_SXmlNamespaceMapping;
extern "C" const CLSID  CLSID_HTMLDialog;

#if DBG==1
    CMarkup *    g_pDebugMarkup = NULL;        // Used in tree dump overwrite cases to see real-time tree changes
#endif

    extern BOOL  g_fThemedPlatform;

DWORD CMarkup::s_dwDirtyRangeServiceCookiePool = 0x0;

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext constructor
//
//----------------------------------------------------------------------------

CMarkupScriptContext::CMarkupScriptContext()
{
    _dwScriptCookie             = NO_SOURCE_CONTEXT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext destructor
//
//----------------------------------------------------------------------------

CMarkupScriptContext::~CMarkupScriptContext()
{
    if (_pScriptDebugDocument)
    {
        _pScriptDebugDocument->Release();
    }

    CMarkup **  ppMarkup;
    int         i;

    for (i = _aryScriptUnblock.Size(), ppMarkup = _aryScriptUnblock;
         i > 0;
         i--, ppMarkup++)
    {
        (*ppMarkup)->SubRelease();
    }

    for (i = _aryScriptEnqueued.Size(); i > 0; i--)
    {
        _aryScriptEnqueued[i-1]->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::RegisterMarkupForScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::RegisterMarkupForScriptUnblock(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryScriptUnblock.Find(pMarkup));

    hr = _aryScriptUnblock.Append(pMarkup);

    pMarkup->SubAddRef();

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::UnregisterMarkupForScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::UnregisterMarkupForScriptUnblock(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    Verify( _aryScriptUnblock.DeleteByValue(pMarkup) );

    pMarkup->SubRelease();

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkupScriptContext::NotifyMarkupsScriptUnblock
//
//--------------------------------------------------------------------

HRESULT
CMarkupScriptContext::NotifyMarkupsScriptUnblock()
{
    HRESULT     hr = S_OK;
    int         c;
    CMarkup *   pMarkup;

    while (0 != (c = _aryScriptUnblock.Size()) && !_fScriptExecutionBlocked)
    {
        pMarkup = _aryScriptUnblock[c - 1];

        _aryScriptUnblock.Delete(c - 1);

        // Let that guy know that we are now unblocked
        if(!pMarkup->IsShuttingDown())
        {
            hr = THR(pMarkup->UnblockScriptExecutionHelper());
            if (hr)
                break;
        }

        // We are deleted out of the array so release the markup
        pMarkup->SubRelease();
    }

    Assert (0 == _aryScriptUnblock.Size() || _fScriptExecutionBlocked);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupTopElemCache constructor
//
//----------------------------------------------------------------------------

CMarkupTopElemCache::CMarkupTopElemCache()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupTopElemCache destructor
//
//----------------------------------------------------------------------------

CMarkupTopElemCache::~CMarkupTopElemCache()
{
}

CMarkupPeerTaskContext::CMarkupPeerTaskContext()
{
}

CMarkupPeerTaskContext::~CMarkupPeerTaskContext()
{
    Assert( _aryPeerQueue.Size() == 0 );
    Assert( !_dwPeerQueueProgressCookie );
    Assert( !_pElementIdentityPeerTask );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup constructor
//
//----------------------------------------------------------------------------

CMarkup::CMarkup ( CDoc *pDoc, BOOL fIncrementalAlloc )
#if DBG == 1 || defined(DUMPTREE)
    : _nSerialNumber( CTreeNode::s_NextSerialNumber++ )
#endif
{
    __lMarkupTreeVersion = 1;
    __lMarkupContentsVersion = 1 | MARKUP_DIRTY_FLAG;

    pDoc->SubAddRef();

    _pDoc = pDoc;

    Assert( _pDoc && _pDoc->AreLookasidesClear( this, LOOKASIDE_MARKUP_NUMBER ) );

    _LoadStatus = LOADSTATUS_UNINITIALIZED;
    _fIncrementalAlloc = fIncrementalAlloc;
    // TODO (KTam): Figure out the right check here; recall that this may be called
    // for the primary markup, so we might not have a _pWindowPrimary!

    // if (pDoc->PrimaryMarkup() && pDoc->PrimaryMarkup()->IsPrintMedia())

    _fInheritDesignMode = TRUE;  
    _fExpando           = EXPANDOS_DEFAULT;
    // _fShowWaitCursor    = FALSE;

    WHEN_DBG( ZeroMemory(_apLookAside, sizeof(_apLookAside)); )      
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup destructor
//
//----------------------------------------------------------------------------

CMarkup::~CMarkup()
{   
    ClearLookasidePtrs();

    //
    // Destroy stylesheets collection subobject (if anyone held refs on it, we
    // should never have gotten here since the doc should then have subrefs
    // keeping it alive).  This is the only place where we directly access the
    // CBase impl. of IUnk. for the CStyleSheetArray -- we do this instead of
    // just calling delete in order to assure that the CBase part of the CSSA
    // is properly destroyed (CBase::Passivate gets called etc.)
    //

    if (HasStyleSheetArray())
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();

        pStyleSheets->CBase::PrivateRelease();
        DelLookasidePtr(LOOKASIDE_STYLESHEETS);
    }

    _pDoc->SubRelease();

}

//+---------------------------------------------------------------------------
//
//  Members:    Debug only version number incrementors
//
//----------------------------------------------------------------------------

#if DBG == 1

void
CMarkup::UpdateMarkupTreeVersion ( )
{
    AssertSz(!__fDbgLockTree, "Tree was modified when it should not have been (e.g., inside ENTERTREE notification)");
    __lMarkupTreeVersion++;
    UpdateMarkupContentsVersion();
    _fFocusCacheDirty = TRUE;
}

void
CMarkup::UpdateMarkupContentsVersion ( )
{
     AssertSz(!__fDbgLockTree, "Tree was modified when it should not have been (e.g., inside ENTERTREE notification)");
    __lMarkupContentsVersion++;
    SetDirtyFlag();
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     ClearLookasidePtrs
//
//----------------------------------------------------------------------------

void
CMarkup::ClearLookasidePtrs ( )
{
    delete DelCollectionCache();
   
    Assert(_pDoc->GetLookasidePtr((DWORD *) this + LOOKASIDE_COLLECTIONCACHE) == NULL);

    Assert( !HasChangeNotificationContext() );

    Assert( !HasTransNavContext() );
    Assert(!HasWindow());

    Assert (!HasBehaviorContext());
    Assert (!HasScriptContext());
    Assert (!HasTextRangeListPtr());
    Assert (!HasCFState());
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Init
//
//----------------------------------------------------------------------------

HRESULT 
CMarkup::Init( CRootElement * pElementRoot )
{
    HRESULT     hr;

    Assert( pElementRoot );

    _tpRoot.MarkLast();
    _tpRoot.MarkRight();

    WHEN_DBG( _cchTotalDbg = 0 );
    WHEN_DBG( _cElementsTotalDbg = 0 );            

    hr = CreateInitialMarkup( pElementRoot );
    if (hr)
        goto Cleanup;    
   
    hr = THR(super::Init());
    if (hr)
        goto Cleanup;

    /* The following code is commented out because it produces some problems
     * with Outlook Express. See bug #23961. 
     */

    //if registry key says always use Strict - then do it.
    // {
    //     Doc()->UpdateFromRegistry();
    //     OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
    //     if(pos && pos->nStrictCSSInterpretation == STRICT_CSS_ALWAYS)
    //         SetStrictCSS1Document(TRUE);
    // }

        
#if DBG == 1
    if(IsTagEnabled(tagMarkupCSS1Compat))   //enforce strict CSS1 compat regardless
        SetStrictCSS1Document(TRUE);        //of DOCTYPE tag for debugging
#endif



Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::UpdateReleaseHtmCtx
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::UpdateReleaseHtmCtx(BOOL fShutdown)
{
    HRESULT     hr = S_OK;

    if (_pHtmCtx)
    {   
        if (!fShutdown)
        {
            if (NeedsHtmCtx())
                goto Cleanup; // still need HtmCtx, don't do anything
        }
        else
        {
            _pHtmCtx->SetLoad(FALSE, NULL, FALSE);
        }

        _pHtmCtx->Release();
        _pHtmCtx = NULL;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::UnloadContents
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::UnloadContents( BOOL fForPassivate /*= FALSE*/)
{
    HRESULT          hr = S_OK;
    CElement::CLock  lockElem( Root() );
    const TCHAR *    pchDwnHeader = GetDwnHeader();
    CTreeNode::CLock lockNode;
    CDoc * pDoc = Doc();
    CMarkup::CLock markupLock(this);

    hr = THR( lockNode.Init( RootNode() ) );
    if( hr )
        goto Cleanup;

    //
    // Remove any pending FirePostedOnPropertyChange
    //
    GWKillMethodCall( Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);
    
    if (pchDwnHeader)
    {
        CoTaskMemFree((TCHAR *) pchDwnHeader);

        IGNORE_HR(SetDwnHeader(NULL));
    }

    //
    // With native frames, it is possible that we get a mouse down on one markup
    // which can navigate and result in the mouse up triggering on the next
    // markup.  So, we can fire the dblclick event without firing the single 
    // click event.  This scenario will break home publisher (bug 89715).
    //
    // So, don't fire dbl click if we didn't see the single click on this
    // markup.
    //

    if (pDoc->_pNodeLastMouseOver == NULL
        || pDoc->_pNodeLastMouseOver->GetNodeInMarkup(this) != NULL)
    {
        pDoc->_fCanFireDblClick = FALSE;
    }

    ExecStop(FALSE, FALSE, FALSE);

    if (Root() && 
        (pDoc->_fHasViewSlave ||
         pDoc->_fBroadcastStop || 
         (GetProgSinkC() && 
            GetProgSinkC()->GetClassCounter((DWORD)-1))))
    {
        CNotification   nf;

        nf.MarkupUnload1(Root());
        Notify(&nf);
    }


    //
    // [Removed some conflicting comments by sramani & ferhane regarding IE5 Bug #103673]
    // ReleaseNotify will talk to external code which may push a message loop.  As such,
    // it should be done AFTER ExecStop/UpdateReleaseHtmCtx (so as to shut down the parser),
    // and AFTER we clear the ProgSink (so he can kill his posted method call).
    // If we see other bugs where someone's getting a posted method call where it's not
    // expected, we may want to move the ReleaseNotify further down. 
    // The UpdateReleaseHtmCtx should be done BEFORE the ProgSink gets nuked, because
    // if we're still loading, we need the progsink stuff to happen so that we stop 
    // the globe from spinning, etc.
    // (JHarding, FerhanE, SRamani)
    //

    UpdateReleaseHtmCtx(/* fShutdown = */TRUE);

    if (_pProgSink)
    {
        CProgSink * pProgSink = _pProgSink;

        _pProgSink = NULL;
        pProgSink->Detach();
        pProgSink->Release();
    }

    IGNORE_HR(ReleaseNotify());

    if (Doc()->_pElemUIActive && Doc()->_pElemUIActive->GetMarkup() == this)
        Doc()->_pElemUIActive = NULL;

    hr = SetAAreadystate(READYSTATE_UNINITIALIZED);
    if (hr)
        goto Cleanup;

    ClearDefaultCharFormat();
    ClearDwnPost();

    {
        CDwnDoc * pDwnDoc = GetDwnDoc();

        if (pDwnDoc)
        {
            pDwnDoc->Disconnect();
            pDwnDoc->Release();

            hr = SetDwnDoc(NULL);
            if (hr)
                goto Cleanup;
        }
    }

    ReleaseDataBinding();

    if (_fPicsProcessPending && _pDoc->_pClientSite)
    {
        Assert( HasWindowPending() && !HasWindow() );
        IUnknown * pUnk = DYNCAST(IHTMLWindow2, GetWindowPending());

        CVariant cvarUnk(VT_UNKNOWN);
        V_UNKNOWN(&cvarUnk) = pUnk;
        pUnk->AddRef();

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_CANCELPICSFORWINDOW, 
                         0, &cvarUnk, NULL));

        Assert( !GetPicsTarget() );

        _fPicsProcessPending = FALSE;
    }

    if (HasTransNavContext())
    {
        TerminateLookForBookmarkTask();

        CMarkupTransNavContext * ptnc = GetTransNavContext();

        if (ptnc)
        {
            ptnc->_historyCurElem.lIndex = -1L;
            ptnc->_historyCurElem.dwCode = 0;
            ptnc->_historyCurElem.lSubDivision = 0;

            ptnc->_dwHistoryIndex = 0;
 
            ptnc->_dwFlags = 0;

            ptnc->_HistoryLoadCtx.Clear();

            ClearInterface( &(ptnc->_pctPics) );

            EnsureDeleteTransNavContext(ptnc);
        }
    }

    ReleaseLayoutRectRegistry();

    //
    // text and tree
    // 
    _fHaveDifferingLayoutFlows = FALSE;

    delete _pHighlightRenSvcProvider;
    _pHighlightRenSvcProvider = NULL;

    _TxtArray.RemoveAll();


//
//  Clear defunked AccEvents -- mwatt 
//
    _pDoc->_aryAccEvents.Flush();


    hr = DestroySplayTree(!fForPassivate);
    if (hr)
        goto Cleanup;

    //
    // behaviors UnloadContents
    //

    ProcessPeerTasks(0);
    
    Assert( !HasMarkupPeerTaskContext() ||
            ( GetMarkupPeerTaskContext()->_aryPeerQueue.Size() == 0 &&
              !GetMarkupPeerTaskContext()->_pElementIdentityPeerTask ) ||
            IsProcessingPeerTasksNow() );

    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks), 0);

    delete DelMarkupPeerTaskContext();

    if (HasBehaviorContext())
    {
        CMarkupBehaviorContext *pContext = BehaviorContext();

        delete pContext->_pPeerFactoryUrlMap;
        pContext->_pPeerFactoryUrlMap = NULL;

        delete pContext->_pExtendedTagTableBooster;
        pContext->_pExtendedTagTableBooster = NULL;

    }

    // 
    // Clear off the editing context stuff
    //

    // Free cached radio groups

    if ( HasRadioGroupName())
    {   
        DelRadioGroupName();
    }

    if( HasEditRouter() )
    {
        CEditRouter *pRouter = GetEditRouter();
        pRouter->Passivate();
    }

    if( HasGlyphTable() )
    {
        delete DelGlyphTable();
    }
       
    //
    // misc
    //

    if (    pDoc->_pWindowPrimary
        &&  !pDoc->_pWindowPrimary->IsPassivating()
        &&  IsPrimaryMarkup())
    {
        pDoc->_cStylesheetDownloading         = 0;
        pDoc->_dwStylesheetDownloadingCookie += 1;
    }

    
    //
    // Restore initial state
    //

    _fIncrementalAlloc = FALSE;
    _fEnsuredFormats = FALSE;

    _fNoUndoInfo = FALSE;
    _fLoaded = FALSE;
    //_fEnableDownload = TRUE;

    _fSslSuppressedLoad = FALSE;
    _fUserInteracted = FALSE;

    _fExpando = EXPANDOS_DEFAULT;
    _fHasScriptForEvent = FALSE;

    if (HasWindow())
    {
        pDoc->_fEngineSuspended = FALSE;
        Window()->Window()->_fEngineSuspended = FALSE;
    }
    // 
    // CompatibleLayoutContext
    // 

    if (HasCompatibleLayoutContext())
    {
        DelCompatibleLayoutContext();
    }

    //
    // behaviors
    //

    delete DelBehaviorContext();

    //
    // script
    //

    if (HasScriptContext())
    {
        CMarkupScriptContext *  pScriptContext = ScriptContext();

        if (pScriptContext->_fScriptExecutionBlocked)
        {
            _pDoc->UnregisterMarkupForInPlace(this);
        }

        if (_pDoc->_pScriptCookieTable && NO_SOURCE_CONTEXT != pScriptContext->_dwScriptCookie)
        {
            IGNORE_HR(_pDoc->_pScriptCookieTable->RevokeSourceObject(pScriptContext->_dwScriptCookie, this));
        }
    }

    SetUrl(this, NULL);
    SetUrlOriginal(this, NULL);
    SetDomain(NULL);
    SetUrlSearch(this, NULL);
    
    IGNORE_HR( ReplaceMonikerPtr( NULL ) );

    delete DelLocationContext();

    delete DelPrivacyInfo();

    delete DelScriptContext();
   
    _codepage = NULL;
    _codepageFamily = NULL;
    if(!GetAAcodepageurl())
        SetURLCodePage(NULL);
    _fVisualOrder = 0;

    //
    // Dirty range service
    //

    if( HasChangeNotificationContext() )
    {
        CMarkupChangeNotificationContext * pcnc;
        MarkupDirtyRange            *   pdr;
        long                            cdr;

        pcnc = GetChangeNotificationContext();
        Assert( pcnc );

        // Clear all our flags
        pcnc->_fReentrantModification = FALSE;
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            pdr->_fNotified = FALSE;
        }

        // Release all the dirty range clients
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            if( !pdr->_fNotified )
            {
                pdr->_fNotified = TRUE;
                pdr->_pChangeSink->Release();
            }

            // If someone messed with anything, we have to reset our state
            if( pcnc->_fReentrantModification )
            {
                pcnc->_fReentrantModification = FALSE;
                cdr = pcnc->_aryMarkupDirtyRange.Size();
                pdr = pcnc->_aryMarkupDirtyRange;
            }
        }

        // Verify
        Assert( !pcnc->_fReentrantModification );
#if DBG==1
        for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
        {
            Assert( pdr->_fNotified );
        }
#endif // DBG

        if (pcnc->_fOnDirtyRangeChangePosted)
        {
            GWKillMethodCall(this, ONCALL_METHOD(CMarkup, OnDirtyRangeChange, ondirtyrangechange), 0);
            pcnc->_fOnDirtyRangeChangePosted = FALSE;
        }

        if( pcnc->_pLogManager )
        {
            // Disonnect the log manager.
            Assert( pcnc->_pLogManager->_pMarkup == this );
            pcnc->_pLogManager->DisconnectFromMarkup();
        }

        delete DelChangeNotificationContext();
    }

    //
    // loading
    //

    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }

    _LoadStatus = LOADSTATUS_UNINITIALIZED;

    if (HasStyleSheetArray())
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();
        pStyleSheets->Free( );  // Force our stylesheets collection to release its
                                    // refs on stylesheets/rules.  We will rel in passivate,
                                    // delete in destructor.
    }

    {
        IStream * pStmDirty = GetStmDirty();

        if (pStmDirty)
        {
            ReleaseInterface(pStmDirty);
            hr = SetStmDirty(NULL);
            if (hr)
                goto Cleanup;
        }
    }   

     // free the focus items array
    CAryFocusItem * paryFocusItem;    
   
    if ((paryFocusItem = GetFocusItems(FALSE)) != NULL)
    {
        AssertSz (!paryFocusItem->Size(), "Focus item array not empty in CMarkup destructor");
        paryFocusItem->DeleteAll();
        delete paryFocusItem;

        FindAAIndexAndDelete ( DISPID_INTERNAL_FOCUSITEMS, CAttrValue::AA_Internal );    
    }

    DelScriptCollection();    

    if( IsPrimaryMarkup() )
    {
        Assert( !Doc()->_fClearingOrphanedMarkups );
        Doc()->_fClearingOrphanedMarkups = TRUE;

        while( Doc()->_aryMarkups.Size() )
        {
            int c;
            CMarkup ** ppMarkup;
            CDoc::CAryMarkups aryMarkupsCopy;

            aryMarkupsCopy.Copy( Doc()->_aryMarkups, FALSE );
            Doc()->_aryMarkups.DeleteAll();

            for( c = aryMarkupsCopy.Size(), ppMarkup = aryMarkupsCopy; c; ppMarkup++, c-- )
            {
                TraceTag(( tagOrphanedMarkup, "Orphaned markup in array: %d(%x)", (*ppMarkup)->_nSerialNumber, (*ppMarkup) ));
                Assert( (*ppMarkup)->IsOrphanedMarkup() );
                (*ppMarkup)->SubAddRef();
            }

            for( c = aryMarkupsCopy.Size(), ppMarkup = aryMarkupsCopy; c; ppMarkup++, c-- )
            {
                if( !(*ppMarkup)->IsPassivated() && !(*ppMarkup)->IsPassivating() )
                {
                    TraceTag(( tagOrphanedMarkup, "Orphaned markup tearing down: %d(%x)", (*ppMarkup)->_nSerialNumber, (*ppMarkup) ));
                    Assert( (*ppMarkup)->HasTextContext() );

                    (*ppMarkup)->GetTextContext()->_fOrphanedMarkup = FALSE;
                    (*ppMarkup)->TearDownMarkup( /* fStop= */ TRUE, /* fSwitch= */ FALSE);
                }
                (*ppMarkup)->SubRelease();
            }
        }

        Doc()->_fClearingOrphanedMarkups = FALSE;
    }


    //if registry key says always use Strict - then do it.
    {
        OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
        if (pos)
        {
            if(pos->nStrictCSSInterpretation == STRICT_CSS_ALWAYS)
                SetStrictCSS1Document(TRUE);
            else // Reset Strict CSS1 mode to default (not Strict CSS1) in case markup is reused
                SetStrictCSS1Document(FALSE);
        }
    }

Cleanup:

    // TODO: we should be able to assert this but we keep seeing it
    // in a really strange stress case.  Revisit later.
    // Assert(!_aryANotification.Size());
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Passivate
//
//----------------------------------------------------------------------------

void
CMarkup::Passivate()
{
    //
    // Release everything
    //

    Assert(!_fWindowPending);

    if( IsOrphanedMarkup() )
    {
        Verify( !SetOrphanedMarkup( FALSE ) );
    }

    if(Document() && Document()->HasPageTransitionInfo() && 
        Document()->GetPageTransitionInfo()->GetTransitionToMarkup() == this)
    {
        // Current markup is participating in a page transition, abort the transition
        Document()->CleanupPageTransitions(0);
    }

    IGNORE_HR( UnloadContents( TRUE ) );

    if( HasEditRouter() )
    {
        CEditRouter *pRouter = GetEditRouter();
        pRouter->Passivate();

        delete DelEditRouter();
    }

    if( HasEditContext() )
    {
        delete DelEditContext();
    }

    if( HasTextContext() )
    {
        delete DelTextContext();
    }

    // Release stylesheets subobj, which will subrel us
    if ( HasStyleSheetArray() )
    {
        CStyleSheetArray * pStyleSheets = GetStyleSheetArray();
        pStyleSheets->Release();
        // we will delete in destructor
    }

    ClearWindow();
    ReleaseAryElementReleaseNotify();

    if (HasDocumentPtr())
    {
        DelDocumentPtr()->PrivateRelease();
    }

    if( HasWindowedMarkupContextPtr() )
    {
        DelWindowedMarkupContextPtr()->SubRelease();
    }

    //
    // super
    //

    super::Passivate();
}

void
CMarkup::ClearWindow(BOOL fFromRestart /*= FALSE*/)
{
    COmWindowProxy *pWindow = DelWindow();

    TraceTag((tagCMarkup, "CMarkup::ClearWindow() - this:[0x%x] Proxy Window:[0x%x] CWindow:[0x%x]",
              this, pWindow, pWindow ? pWindow->_pCWindow : NULL));

    _fWindow = FALSE;
    Assert( !_fWindowPending );

    if (pWindow)
    {
        COmWindowProxy * pProxySecure = pWindow->GetSecureWindowProxy(TRUE);

        Assert(pProxySecure);

        delete *pProxySecure->GetAttrArray();
        pProxySecure->SetAttrArray(NULL);

        pProxySecure->Release();

        pWindow->OnClearWindow(this, fFromRestart);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::DoEmbedPointers
//
//  Synopsis:   Puts unembedded pointers into the splay tree.
//
//----------------------------------------------------------------------------

#if DBG!=1
#pragma optimize(SPEED_OPTIMIZE_FLAGS, on)
#endif

HRESULT
CMarkup::DoEmbedPointers ( )
{
    HRESULT hr = S_OK;
    
    //
    // This should only be called from EmbedPointers when there are any
    // outstanding
    //
    
#if DBG == 1
    
    //
    // Make sure all unembedded pointers are correct
    //
    
    {
        for ( CMarkupPointer * pmp = _pmpFirst ; pmp ; pmp = pmp->_pmpNext )
        {
            Assert( pmp->Markup() == this );
            Assert( ! pmp->_fEmbedded );
            Assert( pmp->_ptpRef );
            Assert( pmp->_ptpRef->GetMarkup() == this );
            Assert( ! pmp->_ptpRef->IsPointer() );

            if (pmp->_ptpRef->IsText())
                Assert( pmp->_ichRef <= pmp->_ptpRef->Cch() );
            else
                Assert( pmp->_ichRef == 0 );
        }
    }
#endif

    while ( _pmpFirst )
    {
        CMarkupPointer * pmp;
        CTreePos *       ptpNew;

        //
        // Remove the first pointer from the list
        //
        
        pmp = _pmpFirst;
        
        _pmpFirst = pmp->_pmpNext;
        
        if (_pmpFirst)
            _pmpFirst->_pmpPrev = NULL;
        
        pmp->_pmpNext = pmp->_pmpPrev = NULL;

        Assert( pmp->_ichRef == 0 || pmp->_ptpRef->IsText() );

        //
        // Consider the case where two markup pointers point in to the the
        // middle of the same text pos, where the one with the larger ich
        // occurs later in the list of unembedded pointers.  When the first
        // is encountered, it will split the text pos, leaving the second
        // with an invalid ich.
        //
        // Here we check to see if the ich is within the text pos.  If it is
        // not, then the embedding of a previous pointer must have split the
        // text pos.  In this case, we scan forward to locate the right hand
        // side of that split, and re-adjust this pointer!
        //

        if (pmp->_ptpRef->IsText() && pmp->_ichRef > pmp->_ptpRef->Cch())
        {
            //
            // If we are out of range, then there better very well be a pointer
            // next which did it.
            //
            
            Assert( pmp->_ptpRef->NextTreePos()->IsPointer() );

            while ( pmp->_ichRef > pmp->_ptpRef->Cch() )
            {
                Assert( pmp->_ptpRef->IsText() && pmp->_ptpRef->Cch() > 0 );
            
                pmp->_ichRef -= pmp->_ptpRef->Cch();

                do
                    { pmp->_ptpRef = pmp->_ptpRef->NextTreePos(); }
                while ( ! pmp->_ptpRef->IsText() );
            }
        }
        
        //
        // See if we have to split a text pos
        //

        if (pmp->_ptpRef->IsText() && pmp->_ichRef < pmp->_ptpRef->Cch())
        {
            Assert( pmp->_ichRef != 0 );
            
            hr = THR( Split( pmp->_ptpRef, pmp->_ichRef ) );

            if (hr)
                goto Cleanup;
        }
        
        ptpNew = NewPointerPos( pmp, pmp->Gravity(), pmp->Cling() );

        if (!ptpNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        //
        // We should always be at the end of a text pos.
        //

        Assert( ! pmp->_ptpRef->IsText() || pmp->_ichRef == pmp->_ptpRef->Cch() );

        hr = THR( Insert( ptpNew, pmp->_ptpRef, FALSE ) );

        if (hr)
            goto Cleanup;

        pmp->_fEmbedded = TRUE;
        pmp->_ptpEmbeddedPointer = ptpNew;
        pmp->_ichRef = 0;
    }

Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::IsSkeletonMode
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::IsSkeletonMode()
{
    CMarkupBehaviorContext * pBehaviorContext = BehaviorContext();
    if (!pBehaviorContext || !pBehaviorContext->_pHtmlComponent)
    {
        return FALSE;
    }
    else
    {
        return pBehaviorContext->_pHtmlComponent->IsSkeletonMode();
    }
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::CanCommitScripts
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::CanCommitScripts(CMarkup * pMarkup, CScriptElement *pelScript)
{
    HRESULT                     hr;
    BOOL                        fCanCommitScripts = FALSE;
    PUA_Flags                   pua = PUA_None;
    CMarkupBehaviorContext *    pBehaviorContext;

    if (pMarkup)
    {
        pBehaviorContext = pMarkup->BehaviorContext();

        // if a behavior-owned markup
        if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        {
            // Does the behavior support edit mode?
            if( !pBehaviorContext->_pHtmlComponent->CanCommitScripts(pelScript) )
                return FALSE;

            // Since element behaviors are basically first-class elements, 
            // they don't have to respect the no script loadf.
            if( pBehaviorContext->_pHtmlComponent->IsElementBehavior() )
            {
                pua = PUA_NoLoadfCheckForScripts;
            }
        }

        fCanCommitScripts = TRUE;

        if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)))
        {
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                &fCanCommitScripts,
                                                0, 
                                                NULL, 
                                                pMarkup->GetAAcreatorUrl(),
                                                NULL,
                                                0, 
                                                pua));
        }
        else
        {
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                &fCanCommitScripts,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0,
                                                pua));
        }

        if (hr)
            fCanCommitScripts = FALSE;

        return fCanCommitScripts;
    }
    else
    {
        // TODO (JHarding): Somehow, I don't trust the caller.  This is the lightweight htc case.
        // the question "can commit scripts?" is asked outside of a markup;
        // the caller is reponsible for making the security decision
        return TRUE;
    }
}

#if DBG!=1
#pragma optimize("", on)
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetDD
//
//  Synopsis:   returns Default Dispatch object for this markup
//
//  [ htc dependency ]
//
//----------------------------------------------------------------------------

CBase *
CMarkup::GetDefaultDocument()
{
    CMarkupBehaviorContext *pBehaviorContext = BehaviorContext();

    if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        return (CBase*) &pBehaviorContext->_pHtmlComponent->_DD;
    else
    {        
        CDocument *pDocument = NULL;
        EnsureDocument(&pDocument);
        return pDocument;
    }
}

CScriptCollection *
CMarkup::GetScriptCollection(BOOL fCreate /* TRUE */)
{
    CScriptCollection * pScriptCollection = NULL;
    CMarkup * pScriptCollectionMarkup;       
   
    // NOTE do not check for _fInDestroySplayTree here: script collection should be available
    // during destroy splay tree to allow HTCs run onDetach code (or else bug 95913)
    if (IsPassivating() ||  Doc()->IsPassivating() ||  Doc()->IsPassivated())
        goto Cleanup;

    pScriptCollectionMarkup = GetNearestMarkupForScriptCollection();
    
    Assert(pScriptCollectionMarkup);

    if (!pScriptCollectionMarkup->HasScriptCollection() && fCreate)
    {         
        if (pScriptCollectionMarkup->SetScriptCollection())
           goto Cleanup;                             
    }
    pScriptCollection = (CScriptCollection *) pScriptCollectionMarkup->GetLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION);            

 
    Assert (pScriptCollection || !fCreate);                             

Cleanup:       
    return pScriptCollection;
}


HRESULT
CMarkup::SetScriptCollection()
{
    HRESULT             hr = E_FAIL;
    CScriptCollection * pScriptCollection = NULL;          
 
    Assert(this == GetNearestMarkupForScriptCollection());

    if (!HasWindowPending())
        goto Cleanup;
   
    pScriptCollection = new CScriptCollection();
    if (!pScriptCollection)                  
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;        
    }

    hr = THR(pScriptCollection->Init(Doc(), GetWindowPending()));
    if (hr)
        goto Cleanup;

    hr = SetLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION, pScriptCollection);    
    pScriptCollection = NULL;

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();
    return hr;
}

void
CMarkup::TearDownMarkup(BOOL fStop /* = TRUE */, BOOL fSwitch /* = FALSE */)
{
    CDoc *  pDoc = Doc();    
    CWindow * pWindow = HasWindow() ? Window()->Window() : NULL;

    CMarkup::CLock MarkupLock(this);  // UnloadContents can make us passivate, which would be bad
    CDoc::CLock Lock(pDoc, SERVERLOCK_BLOCKPAINT | FORMLOCK_UNLOADING); // TODO (lmollico): move the lock to CMarkup

    if (fStop)
    {
        if (!fSwitch && pWindow)
            pWindow->DetachOnloadEvent();

        IGNORE_HR(UnloadContents());
        
        if (!fSwitch && pWindow && pWindow->_pMarkupPending)
            pWindow->ReleaseMarkupPending(pWindow->_pMarkupPending);
    }
    else if (HasScriptContext())
    {
        delete DelScriptContext();
    }

    DelScriptCollection();
}

void
CMarkup::DelScriptCollection()
{
    if (HasScriptCollection())
    {
        ((CScriptCollection *) DelLookasidePtr(LOOKASIDE_SCRIPTCOLLECTION))->Release();          
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureDocument
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureDocument(CDocument ** ppDocument)
{
    HRESULT     hr = S_OK;
    CDocument * pDocument = Document();

    // We shouldn't have a document if we are pending 
    // -- we should switch first
    Assert( !_fWindowPending );

    if (!pDocument)
    {
        // The ref from creation will be owned by the
        // CMarkup
        pDocument = new CDocument( this );
        if (!pDocument)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        Assert (pDocument->_pWindow == NULL);

        hr = THR(SetDocumentPtr(pDocument));
        if (hr)
        {
            // oops, we couldn't set the document pointer --
            // we are pretty much stuck here -- at least
            // let go of the document we just created.
            pDocument->PrivateRelease();

            goto Cleanup;
        }
    }

    if (ppDocument)
    {
        *ppDocument = pDocument;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Document
//
//----------------------------------------------------------------------------

CDocument *
CMarkup::Document()
{
    // We shouldn't have a document if we are pending 
    // -- we should switch first
    Assert( !(_fWindowPending && HasDocument())); 

    if (HasWindow())
    {
        Assert (Window()->Window()->HasDocument());
        return Window()->Window()->Document();
    }
    else
    {
        return GetDocumentPtr();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureScriptContext
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureScriptContext (CMarkupScriptContext ** ppScriptContext)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
    CScriptCollection *     pScriptCollection;
    
    // Don't create script context for paste markup
    if (!pScriptContext)
    {
        //
        // create the context
        //

        pScriptContext = new CMarkupScriptContext();
        if (!pScriptContext)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetScriptContext(pScriptContext));
        if (hr)
            goto Cleanup;
       
        //
        // init namespace
        //

        // TODO (sramani): The scriptcontext shud really not be created at all for paste markups,
        // but to do this the parser code has to be modified. Something todo for v4
        if (!_fMarkupServicesParsing)
        {
            if (HasWindowPending()) 
            {
                Assert(!IsHtcMarkup());
                hr = THR(pScriptContext->_cstrNamespace.Set(DEFAULT_OM_SCOPE));

                // don't do AddNamedItem for PrimaryMarkup: this is done once when we create script engines.
                // we don't want to be re-registering DEFAULT_OM_SCOPE namespace each time in refresh
            }
            else
            {
                CHtmlComponent *pFactory = NULL;
                CHtmlComponent *pComponent = HasBehaviorContext() ? BehaviorContext()->_pHtmlComponent : NULL;
                if (pComponent)
                {
                    pFactory = pComponent->_pConstructor->_pFactoryComponent;
                    Assert(pFactory);
                }

                if (pComponent && pComponent->_fFactoryComponent)
                {
                    hr = THR(_pDoc->GetUniqueIdentifier(&pScriptContext->_cstrNamespace));
                    if (hr)
                        goto Cleanup;
                }
                else if (!pFactory || !pFactory->_fClonedScript)
                {
                    pScriptCollection = GetScriptCollection();
                    if (pScriptCollection)
                    {                     
                        CBase *pBase = GetDefaultDocument();
                        if (!pBase)
                        {
                            hr = E_FAIL;
                            goto Cleanup;
                        }

                        IGNORE_HR(pScriptCollection->AddNamedItem(
                              /* pchNamespace = */NULL, pScriptContext,
                              (IUnknown*)(IPrivateUnknown*)pBase));
                    }
                }
                else
                {
                    Assert(!pFactory->_fLightWeight);
                    Assert(!pFactory->_pScriptContext);
                    Assert(pFactory->GetMarkup()->HasScriptContext());
                    Assert(pFactory->GetMarkup()->ScriptContext()->GetNamespace());
                    pScriptContext->_cstrNamespace.SetPch(pFactory->GetMarkup()->ScriptContext()->GetNamespace());
                    pScriptContext->_fClonedScript = TRUE;
                }
            }

            //
            // script debugger initialization wiring
            //

            {
                CScriptDebugDocument::CCreateInfo   createInfo(this, HtmCtx());
            
                hr = THR(CScriptDebugDocument::Create(&createInfo, &pScriptContext->_pScriptDebugDocument));
                if (hr)
                    goto Cleanup;
            }
        }
    }


    if (ppScriptContext)
    {
        *ppScriptContext = pScriptContext;
    }

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureMarkupPeerTaskContext
//  
//  Synopsis:   Ensures a CMarkupPeerTaskContext for this markup
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMarkupPeerTaskContext ** ppPTC - for returning the PTC
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureMarkupPeerTaskContext( CMarkupPeerTaskContext ** ppPTC /*=NULL*/ )
{
    HRESULT hr = S_OK;
    CMarkupPeerTaskContext * pPTC = HasMarkupPeerTaskContext() ? GetMarkupPeerTaskContext() : NULL;

    // Only a frame should have one of these.
    Assert( GetFrameOrPrimaryMarkup() == this );

    // Try to make and set one if needed
    if( !pPTC )
    {
        pPTC = new CMarkupPeerTaskContext();
        if( !pPTC )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( SetMarkupPeerTaskContext( pPTC ) );
        if( hr )
        {
            delete pPTC;
            pPTC = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if( ppPTC )
    {
        *ppPTC = pPTC;
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::NeedsHtmCtx
//
//  [ htc dependency ]
//
//---------------------------------------------------------------

BOOL
CMarkup::NeedsHtmCtx()
{
    // frame or primary markups always need HtmCtx (for view source)
    if (this == GetFrameOrPrimaryMarkup())
        return TRUE;

    // script debug documents always need it (for view source analogue)
    if (HasScriptContext() && ScriptContext()->_pScriptDebugDocument)
        return TRUE;

    // factory behavior component always need it
    if (HasBehaviorContext())
    {
        CMarkupBehaviorContext * pBehaviorContext = BehaviorContext();
        if (pBehaviorContext &&
            pBehaviorContext->_pHtmlComponent &&
            pBehaviorContext->_pHtmlComponent->_fFactoryComponent)
            return TRUE;
    }

    return  FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PrivateQueryInterface
//
//  TODO (anandra): This should go away completely.
//  
//----------------------------------------------------------------------------

HRESULT
CMarkup::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;
    void *       appropdescsInVtblOrder = NULL;
    const IID * const * apIID = NULL;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IMarkupContainer2, NULL)
        QI_TEAROFF2(this, IMarkupContainer, IMarkupContainer2, NULL)
        QI_TEAROFF(this, IMarkupTextFrags, NULL)
        QI_TEAROFF(this, IHTMLChangePlayback, NULL)
        QI_TEAROFF(this, IPersistStream, NULL)
        
    default:
        if (IsEqualIID(iid, CLSID_CMarkup))
        {
            *ppv = this;
            return S_OK;
        }
        else if (iid == IID_IDispatchEx || iid == IID_IDispatch)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apIID = g_apIID_IDispatchEx;
            apfn = (const void *) CDocument::s_apfnIDispatchEx;
        }
        else if (iid == IID_IHTMLDocument || iid == IID_IHTMLDocument2)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument2;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument2; 
        }
        else if (iid == IID_IHTMLDocument3)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument3;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument3; 
        }
        else if (iid == IID_IHTMLDocument4)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument4;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument4; 
        }
        else if (iid == IID_IHTMLDocument5)
        {
            hr = THR(EnsureDocument());
            if (hr)
                RRETURN (hr);
         
            pv = (void *) Document();
            apfn = (const void *) CDocument::s_apfnpdIHTMLDocument5;
            appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument5;
        }
        else if (iid == IID_IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(
                (CBase *) this, (IUnknown *)(IPrivateUnknown *) this);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
        }
        else if (iid == IID_IServiceProvider )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIServiceProvider;
        }
        else if (iid == IID_IOleWindow)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
        }
        else if (iid == IID_IOleCommandTarget)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIOleCommandTarget;
        }
        else if (iid == IID_IMarkupServices || iid == IID_IMarkupServices2)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIMarkupServices2;
        }
        else if (iid == IID_IHighlightRenderingServices )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIHighlightRenderingServices;
        }       
        else if (iid == IID_IDisplayServices)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIDisplayServices;
        }
#if DBG ==1
        else if (iid == IID_IEditDebugServices)
        {
            pv = Doc();
            apfn = CDoc::s_apfnIEditDebugServices;
        }    
#endif
        else if( iid == IID_IIMEServices )
        {
            pv = Doc();
            apfn = CDoc::s_apfnIIMEServices;
        }
        else
        {
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
        }

        if (pv)
        {
            Assert(apfn);
            hr = THR(CreateTearOffThunk(
                    pv, 
                    apfn, 
                    NULL, 
                    ppv, 
                    (IUnknown *)(IPrivateUnknown *)this, 
                    *(void **)(IUnknown *)(IPrivateUnknown *)this,
                    QI_MASK | ADDREF_MASK | RELEASE_MASK,
                    apIID,
                    appropdescsInVtblOrder));
            if (hr)
                RRETURN(hr);
        }
    }

    // any unknown interface will be handled by the default above
    Assert(*ppv);

    (*(IUnknown **)ppv)->AddRef();

    DbgTrackItf(iid, "CMarkup", FALSE, ppv);

    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PrivateQueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    HRESULT     hr;

    Assert (Doc()->_dwTID == GetCurrentThreadId());

    if (IsEqualGUID(rguidService, SID_SXmlNamespaceMapping))
    {
        CMarkupBehaviorContext *    pContext = BehaviorContext();
        CExtendedTagTable *         pExtendedTagTable = NULL;
        
        if (pContext && pContext->_pExtendedTagTable)
        {
            pExtendedTagTable = pContext->_pExtendedTagTable;
        }
        else if (HtmCtx())
        {
            pExtendedTagTable = HtmCtx()->GetExtendedTagTable();
        }

        if (pExtendedTagTable)
        {
            hr = THR(pExtendedTagTable->QueryInterface(riid, ppvObject));
            goto Cleanup; // done
        }
    }

    if (Document())
    {
        hr = THR_NOTRACE(Document()->QueryService(rguidService, riid, ppvObject));
    }
    else
    {
        hr = THR_NOTRACE(_pDoc->QueryService(rguidService, riid, ppvObject));
    }
    
Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(IStream * pStream, CMarkup * pContextMarkup, BOOL fAdvanceLoadStatus, HTMPASTEINFO * phtmpasteinfo)
{
    HRESULT         hr;
    HTMLOADINFO     htmloadinfo;

    htmloadinfo.pDoc                = _pDoc;
    htmloadinfo.pMarkup             = this;
    htmloadinfo.pContextMarkup      = pContextMarkup;
    htmloadinfo.pDwnDoc             = GetWindowedMarkupContext()->GetDwnDoc();
    if( !htmloadinfo.pDwnDoc )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }


    htmloadinfo.pDwnDoc->SetLoadf( htmloadinfo.pDwnDoc->GetLoadf() | DLCTL_NO_METACHARSET );
    htmloadinfo.pVersions           = _pDoc->_pVersions;
    htmloadinfo.pchUrl              = _pDoc->GetPrimaryUrl();
#if 0
    htmloadinfo.pchUrl              = CMarkup::GetUrl(GetWindowedMarkupContext());
#endif 
    htmloadinfo.fParseSync          = TRUE;
    htmloadinfo.fAdvanceLoadStatus  = fAdvanceLoadStatus;

    htmloadinfo.phpi                = phtmpasteinfo;
    htmloadinfo.pstm                = pStream;

    htmloadinfo.fPendingRoot        = IsPendingRoot();

    hr = THR(Load(&htmloadinfo));

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(
    IMoniker *                          pMoniker,
    IBindCtx *                          pBindCtx,
    BOOL                                fNoProgressUI,
    BOOL                                fOffline,
    FUNC_TOKENIZER_FILTEROUTPUTTOKEN *  pfnTokenizerFilterOutputToken,
    BOOL                                fDownloadHtc /*=FALSE*/ )
{
    HRESULT         hr;
    HTMLOADINFO     htmloadinfo;
    LPTSTR          pchUrl = NULL;

    hr = THR(pMoniker->GetDisplayName(pBindCtx, NULL, &pchUrl));
    if (hr)
        goto Cleanup;

    htmloadinfo.pDoc                            = _pDoc;
    htmloadinfo.pMarkup                         = this;
    htmloadinfo.pDwnDoc                         = GetWindowedMarkupContext()->GetDwnDoc();
    if( !htmloadinfo.pDwnDoc )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    htmloadinfo.pDwnDoc->SetLoadf( htmloadinfo.pDwnDoc->GetLoadf() | DLCTL_NO_METACHARSET );
    htmloadinfo.pInetSess                       = TlsGetInternetSession();
    htmloadinfo.pmk                             = pMoniker;
    htmloadinfo.pbc                             = pBindCtx;
    htmloadinfo.pchUrl                          = pchUrl;
    htmloadinfo.fNoProgressUI                   = fNoProgressUI;
    htmloadinfo.fOffline                        = fOffline;
    htmloadinfo.pfnTokenizerFilterOutputToken   = pfnTokenizerFilterOutputToken;
    htmloadinfo.fDownloadHtc                    = fDownloadHtc;

    htmloadinfo.fPendingRoot                    = IsPendingRoot();
    
    hr = THR(Load(&htmloadinfo));

Cleanup:
    CoTaskMemFree(pchUrl);

    RRETURN (hr);
}

BOOL PathIsFilePath(LPCWSTR lpszPath)
{
    if ((lpszPath[0] == TEXT('\\')) || (lpszPath[0] != TEXT('\0') && lpszPath[1] == TEXT(':')))
        return TRUE;

    return UrlIsFileUrl(lpszPath);
}


//+---------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::EnsureMoniker(struct CDoc::LOADINFO * pLoadInfo)
{
    IMoniker *  pmkNew = NULL;
    HRESULT     hr = S_OK;

    // If there is a file name, regardless of the fact that we have a moniker
    // or not, use the file name.
    if (pLoadInfo->pchFile)
    {
        // Now load the new contents from the appropriate source

        // Make a moniker if all we have is a filename
        // (Also do conversion of an RTF file to a temp HTML file if needed)

        TCHAR achTemp[MAX_PATH];
        TCHAR achPath[MAX_PATH];
        TCHAR * pchExt;
        TCHAR achUrl[pdlUrlLen];
        ULONG cchUrl;
        ULONG cchPath;

        _tcsncpy(achTemp, pLoadInfo->pchFile, MAX_PATH);
        achTemp[MAX_PATH-1] = 0;

        // We now have a file to load from.
        // Make a URL moniker out of it.

        if (!PathIsFilePath(achTemp))
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
        cchPath = GetFullPathName(achTemp, ARRAY_SIZE(achPath), achPath, &pchExt);
        if (!cchPath || cchPath > ARRAY_SIZE(achPath))
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        cchUrl = ARRAY_SIZE(achUrl);
        hr = THR(UrlCreateFromPath(achPath, achUrl, &cchUrl, 0));
        if (hr)
            goto Cleanup;

        hr = THR(CreateURLMoniker(NULL, achUrl, &pmkNew));
        if (hr)
            goto Cleanup;

        ReplaceInterface(&pLoadInfo->pmk, pmkNew);
    }
    else if (!pLoadInfo->pmk && pLoadInfo->pchDisplayName)
    {
        // Make a moniker if all we have is a URL
        hr = THR(CreateURLMoniker(NULL, pLoadInfo->pchDisplayName, &pmkNew));
        if (hr)
            goto Cleanup;

        ReplaceInterface(&pLoadInfo->pmk, pmkNew);
    }

Cleanup:

    ClearInterface(&pmkNew);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function    :   DetermineUrlOfMarkup
//  Parameters  :   
//                  pLoadInfo:  Pointer to the loadinfo structure the LoadFromInfo
//                              is called with.
//                  ppchUrl  :  Address of the TCHAR * to receive the URL to be
//                              loaded into this markup
//                  ppchTask :  Address of the TCHAR * to receive the URL that 
//                              was carried within the moniker. The return value
//                              of this parameter may be NULL if the loadinfo does
//                              not contain a moniker pointer.
//
//      *ppchUrl and *ppchTask may or may not be the same.
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::DetermineUrlOfMarkup( struct CDoc::LOADINFO * pLoadInfo, 
                              TCHAR **  ppchUrl,                    
                              TCHAR **  ppchTask)
{
    HRESULT hr = S_OK;
    TCHAR * pchTask = NULL;


    // we should have a moniker except for the new/empty page case.
    if (pLoadInfo->pmk)
    {
        // get the url to be used.
        hr = THR(pLoadInfo->pmk->GetDisplayName(pLoadInfo->pbctx, NULL, &pchTask));
        if (hr)
            goto Cleanup;

        hr = THR(ReplaceMonikerPtr( pLoadInfo->pmk ));
        if( hr )
            goto Cleanup;

        *ppchUrl = pchTask;
    }
    else
    {
        *ppchUrl = (TCHAR *)CMarkup::GetUrl(this);
    }
    
    *ppchTask = pchTask;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessHTMLLoadOptions(struct CDoc::LOADINFO * pLoadInfo)
{
    HRESULT             hr = S_OK;
    IUnknown *          pUnk = NULL;
    IHtmlLoadOptions *  pHtmlLoadOptions  = NULL;
    CDoc *              pDoc = Doc();

    pLoadInfo->pbctx->GetObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM, &pUnk);

    if (pUnk)
    {
        pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **) &pHtmlLoadOptions);

        if (pHtmlLoadOptions)
        {
            CODEPAGE cp = 0;
            BOOL     fHyperlink = FALSE;
            ULONG    cb = sizeof(CODEPAGE);

            // HtmlLoadOption from the shell can override the codepage
            hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_CODEPAGE, &cp, &cb));
            if (hr == S_OK && cb == sizeof(CODEPAGE))
            {
                HRESULT hrT = THR(mlang().ValidateCodePage(g_cpDefault, cp, pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : 0, 
                                                           FALSE, pDoc->_dwLoadf & DLCTL_SILENT));
                if (OK(hrT))
                {
                    pLoadInfo->fNoMetaCharset = TRUE;
                    pLoadInfo->codepage = cp;
                }
            }

            // Grab the shortcut only if this load came from one of the CDoc::Load* codepaths.  In all
            // other cases, this will get handled via SuperNavigate
            if (pLoadInfo->fCDocLoad)
            {
                TCHAR    achCacheFile[MAX_PATH];
                ULONG    cchCacheFile = ARRAY_SIZE(achCacheFile);

                // now determine if this is a shortcut-initiated load
                hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                       &achCacheFile,
                                                       &cchCacheFile));
                if (hr == S_OK && cchCacheFile)
                {
                    // we are a shortcut!
                    IPersistFile *pISFile = NULL;

                    // create the shortcut object for the provided cachefile
                    hr = THR(CoCreateInstance(CLSID_InternetShortcut,
                                              NULL,
                                              CLSCTX_INPROC_SERVER,
                                                  IID_IPersistFile,
                                              (void **)&pISFile));
                    if (SUCCEEDED(hr))
                    {
                        hr = THR(pISFile->Load(achCacheFile, 0));
                        if (SUCCEEDED(hr))
                        {
                            ClearInterface(&pDoc->_pShortcutUserData);

                            hr = THR(pISFile->QueryInterface(IID_INamedPropertyBag,
                                                             (void **)&pDoc->_pShortcutUserData));
                            if (!hr)
                            {
                                IGNORE_HR(pDoc->_cstrShortcutProfile.Set(achCacheFile));
                            }
                        }

                        pISFile->Release();
                    }
                }
            }

            // determine if we're loading as a result of a hyperlink
            cb = sizeof(fHyperlink);
            hr = THR(pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_HYPERLINK,
                                                   &fHyperlink,
                                                   &cb));
            if (hr == S_OK && cb == sizeof(fHyperlink))
                pLoadInfo->fHyperlink = fHyperlink;

            // override the possible error code.
            hr = S_OK;
        }
    }

    ReleaseInterface(pHtmlLoadOptions);
    ReleaseInterface(pUnk);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessDwnBindInfo( struct CDoc::LOADINFO * pLoadInfo, 
                                struct CMarkup::LOADFLAGS * pFlags, 
                                TCHAR * pchTask,
                                CWindow * pWindowParent)
{
    HRESULT         hr = S_OK;
    IUnknown *      pUnk = NULL;
    CDwnBindInfo *  pDwnBindInfo      = NULL;
    DWORD           dwBindf = pFlags->dwBindf;

    pLoadInfo->pbctx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);

    if (pUnk)
    {
        pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);

        if (pDwnBindInfo)
        {
            CDwnDoc * pDwnDoc = pDwnBindInfo->GetDwnDoc();
            dwBindf &= ~(BINDF_PRAGMA_NO_CACHE|BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE);
            dwBindf |= pDwnDoc->GetBindf() & (BINDF_PRAGMA_NO_CACHE|BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE|BINDF_HYPERLINK);

            // (dinartem)
            // Need to distinguish the frame bind case from the normal
            // hyperlinking case.  Only frame wants to inherit dwRefresh
            // from parent, not the normal hyperlinking of a frame from
            // the <A TARGET="foo"> tag.
            // (dbau) this is now done via HTMLLOADOPTION_FRAMELOAD

            if (pWindowParent && !pLoadInfo->fHyperlink)
            {
                CDwnDoc * pParentDwnDoc = pWindowParent->_pMarkup->GetDwnDoc();

                // inherit dwRefresh from parent
                if (pParentDwnDoc && pLoadInfo->dwRefresh == 0 && !pLoadInfo->fMetaRefresh)
                {
                    pLoadInfo->dwRefresh = pParentDwnDoc->GetRefresh();
                }
            }

            // Cache the header
            {
                TCHAR   achNull[1];
                TCHAR * pchDwnHeader = NULL;

                achNull[0] = 0;

                hr = THR(pDwnBindInfo->BeginningTransaction(pchTask, achNull, 0, &pchDwnHeader));
                if (hr)
                    goto Cleanup;
                hr = SetDwnHeader(pchDwnHeader);
                if (hr)
                    goto Cleanup;
            }

            if (pDwnBindInfo->GetDwnPost())
            {
                if (pLoadInfo->pDwnPost)
                    pLoadInfo->pDwnPost->Release();
                pLoadInfo->pDwnPost = pDwnBindInfo->GetDwnPost();
                pLoadInfo->pDwnPost->AddRef();
            }
            else
            {
                pLoadInfo->pbctx->RevokeObjectParam(SZ_DWNBINDINFO_OBJECTPARAM);
            }

            if (pDwnDoc->GetDocReferer())
            {
                hr = THR(MemReplaceString(Mt(LoadInfo), pDwnDoc->GetDocReferer(),
                            &pLoadInfo->pchDocReferer));
                if (hr)
                    goto Cleanup;
            }

            if (pDwnDoc->GetSubReferer())
            {
                hr = THR(MemReplaceString(Mt(LoadInfo), pDwnDoc->GetSubReferer(),
                            &pLoadInfo->pchSubReferer));
                if (hr)
                    goto Cleanup;
            }

            // If we have a codepage in the hlink info, use it if one wasn't already specified
            if (!pLoadInfo->codepage)
                pLoadInfo->codepage = pDwnDoc->GetDocCodePage();

            if (!pLoadInfo->codepageURL)
                pLoadInfo->codepageURL = pDwnDoc->GetURLCodePage();
        }
    }

Cleanup:
    pFlags->dwBindf = dwBindf;

    ReleaseInterface(pUnk);
    ReleaseInterface((IBindStatusCallback *)pDwnBindInfo);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::ProcessLoadFlags(struct CDoc::LOADINFO * pLoadInfo,
                          TCHAR * pchUrl, 
                          struct CMarkup::LOADFLAGS * pFlags)
{
    HRESULT hr = S_OK;
    
    DWORD   dwBindf = pFlags->dwBindf;
    DWORD   dwDownf = pFlags->dwDownf;
    DWORD   dwDocBindf = pFlags->dwDocBindf;
    DWORD   dwLoadf = pFlags->dwLoadf;

    DWORD   dwOfflineFlag;
    CDoc *  pDoc = Doc();
    BOOL    fDocOffline = FALSE;

    // Require load from local cache if offline,

    pDoc->IsFrameOffline(&dwOfflineFlag);
    dwBindf |= dwOfflineFlag;

    // Require load from local cache if doing a history load (and non-refresh) of the result of a POST
    
    if (pLoadInfo->pstmRefresh && pLoadInfo->pDwnPost
             && !(dwBindf & (BINDF_GETNEWESTVERSION|BINDF_RESYNCHRONIZE)))
    {
        pLoadInfo->pchFailureUrl = _T("about:PostNotCached");
        fDocOffline = TRUE;
    }

    if (pDoc->_dwLoadf & DLCTL_SILENT)
    {
        dwBindf |= BINDF_SILENTOPERATION | BINDF_NO_UI;
    }

    if (pDoc->_dwLoadf & DLCTL_RESYNCHRONIZE)
    {
        dwBindf |= BINDF_RESYNCHRONIZE;
    }

    if (pDoc->_dwLoadf & DLCTL_PRAGMA_NO_CACHE)
    {
        dwBindf |= BINDF_PRAGMA_NO_CACHE;
    }

    if (pLoadInfo->dwRefresh == 0)
    {
        pLoadInfo->dwRefresh = IncrementLcl();
    }

    dwDownf = GetDefaultColorMode();

    if (pDoc->IsPrintDialogNoUI() && dwDownf <= 16)
    {
        dwDownf = 24;
    }

    if (pDoc->_pOptionSettings && !pDoc->_pOptionSettings->fSmartDithering)
    {
        dwDownf |= DWNF_FORCEDITHER;
    }

    if (pDoc->_dwLoadf & DLCTL_DOWNLOADONLY)
    {
        dwDownf |= DWNF_DOWNLOADONLY;
    }

    dwLoadf = pDoc->_dwLoadf;

    if (pLoadInfo->fSync || pLoadInfo->fNoMetaCharset) // IE5 #53582 (avoid RestartLoad if loading from a stream)
    {
        dwLoadf |= DLCTL_NO_METACHARSET;
    }

    if (HasWindowPending())
    {
        CMarkup *pMarkupOld = GetWindowPending()->Markup();
        Assert(pMarkupOld);
        if (pMarkupOld->_fDesignMode || pMarkupOld->DontRunScripts())
            dwLoadf |= DLCTL_NO_SCRIPTS;
    }
    
    // initialize.
    dwDocBindf = dwBindf;

    // note (dbau) to fix bug 18360, we set BINDF_OFFLINEOPERATION only for the doc bind
    if (fDocOffline)
        dwDocBindf |= BINDF_OFFLINEOPERATION;

    pFlags->dwBindf = dwBindf & ~BINDF_FORMS_SUBMIT;    // Never use FORMS_SUBMIT for secondary downloads
    pFlags->dwDownf = dwDownf;
    pFlags->dwDocBindf = dwDocBindf;
    pFlags->dwLoadf = dwLoadf;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::HandleHistoryAndNavContext( struct CDoc::LOADINFO * pLoadInfo)
{
    HRESULT hr = S_OK;

    if (pLoadInfo->pstmHistory)
    {
        CMarkupTransNavContext * ptnc = EnsureTransNavContext();
        if (ptnc)
        {
            Assert( !ptnc->_HistoryLoadCtx.HasData() );

            if (!OK(ptnc->_HistoryLoadCtx.Init(pLoadInfo->pstmHistory)))
            {
                ptnc->_HistoryLoadCtx.Clear();
                EnsureDeleteTransNavContext( ptnc );
            }

            // Remeber that we have to send the DELAY_HISTORY_LOAD notification
            ptnc->_fDoDelayLoadHistory = TRUE;
        }
    }

    //copy the string if there is one of these.
    // Note that we might not have a history, so a NULL return is okay.
    if (pLoadInfo->pchHistoryUserData)
    {
        CMarkupBehaviorContext * pContext = NULL;

        if (S_OK == EnsureBehaviorContext(&pContext))
        {
            hr = pContext->_cstrHistoryUserData.Set(pLoadInfo->pchHistoryUserData);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::HandleSSLSecurity(struct CDoc::LOADINFO *pLoadInfo, 
                           const TCHAR * pchUrl, 
                           struct CMarkup::LOADFLAGS * pFlags, 
                           IMoniker ** ppMonikerSubstitute)
{
    HRESULT hr              = S_OK;
    CDoc *  pDoc            = Doc();
    BOOL    fPendingPrimary = IsPendingPrimaryMarkup();

    //If we are in an object tag we don't want to update the ui (IE6 Bug 28338)
    if (_pDoc->_fInObjectTag)
    {
        goto Cleanup;
    }

    if (IsPrimaryMarkup() || fPendingPrimary)
    {
        if (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS && !pLoadInfo->fUnsecureSource && !(pDoc->_dwLoadf & DLCTL_SILENT))
        {
            pDoc->SetRootSslState(fPendingPrimary, SSL_SECURITY_SECURE, SSL_PROMPT_QUERY, TRUE);
        }
        else
        {
            pDoc->SetRootSslState(fPendingPrimary, SSL_SECURITY_UNSECURE, SSL_PROMPT_ALLOW, TRUE);
        }

        pLoadInfo->fPendingRoot = fPendingPrimary;
    }
    else
    {
        BOOL fPendingRoot;

        if (pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup())
            fPendingRoot = pLoadInfo->pElementMaster->GetMarkup()->IsPendingRoot();
        else
            fPendingRoot = IsPendingRoot();

        pLoadInfo->fPendingRoot = fPendingRoot;

        // If we're not the root doc, we want to ignore security problems if
        // the root doc is unsecure
        if (pDoc->AllowFrameUnsecureRedirect(fPendingRoot))
            pFlags->dwBindf |= BINDF_IGNORESECURITYPROBLEM;
            
        // warn about mixed security (must come after call to SetClientSite)
        if (!ValidateSecureUrl(fPendingRoot, pchUrl, pLoadInfo->fFrameTarget, FALSE, pLoadInfo->fUnsecureSource))
        {
            hr = THR(CreateURLMoniker(NULL, _T("about:NavigationCancelled"), ppMonikerSubstitute));
            if (hr)
                goto Cleanup;

            if (!fPendingRoot)
                pDoc->OnIgnoreFrameSslSecurity();

            _fSslSuppressedLoad = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::ProcessCodepage( struct CDoc::LOADINFO * pLoadInfo, CWindow * pWindowParent)
{
    HRESULT hr;
    CDoc * pDoc = Doc();

    if (!pLoadInfo->codepage)
    {
        // use CP_AUTO when so requested
        if (pDoc->IsCpAutoDetect())
        {
            pLoadInfo->codepage = CP_AUTO;
        }
        else if (pWindowParent)
        {
            CMarkup * pMarkupParent = pWindowParent->_pMarkup;

            // Inherit the codepage from our parent frame
            pLoadInfo->codepage =   pMarkupParent->_fCodePageWasAutoDetect
                                    ? CP_AUTO_JP
                                    : pMarkupParent->GetCodePage();
        }
        else
        {
            // Get it from the option settings default
            pLoadInfo->codepage =
                NavigatableCodePage(pDoc->_pOptionSettings->codepageDefault);
        }
    }

    if (!pLoadInfo->codepageURL)
        pLoadInfo->codepageURL = GetURLCodePage();

    SwitchCodePage(pLoadInfo->codepage);
    hr = SetURLCodePage(pLoadInfo->codepageURL);
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::CheckZoneCrossing(TCHAR * pchTask)
{
    HRESULT hr = S_OK;
    CDoc * pDoc  = Doc();
    
    Assert(HasWindowPending());

    COmWindowProxy * pProxyPending = GetWindowPending();
    
    // If we are having a transition from secure to unsecure, make sure
    // that you get user approval.
    if (!(pDoc->_dwLoadf & DLCTL_SILENT) && pchTask && pProxyPending->Window()->IsPrimaryWindow())
    {
        HWND    hwnd = _pDoc->GetHWND();
        CDoEnableModeless dem(pDoc, pProxyPending->Window());

        LPCTSTR pchUrl = CMarkup::GetUrl(pProxyPending->Markup());

        //
        // Bail for about:blank comparison with first markup.
        //
        if (IsSpecialUrl(pchUrl) && pProxyPending->Markup()->Doc()->_fStartup )
            return S_OK;           

        // pass the URL of the markup that we are replacing, and the URL of this
        if (!hwnd && _pDoc->_pClientSite)
        {
            IOleWindow *pIOleWindow = NULL;

            //
            // if the doc is not in place, get the host hwnd
            //

            hr = THR(_pDoc->_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pIOleWindow));

            //
            //  if QI fails, we still try the wininet call for VS
            //

            if (SUCCEEDED(hr))
            {
                hr = THR(pIOleWindow->GetWindow(&hwnd));
                ReleaseInterface(pIOleWindow);

                if (FAILED(hr))
                {
                    hwnd = NULL;
                }
            }

            hr = S_OK;
        }

        // markup. If they are in different security domains, a dialog will be shown.
        DWORD err = InternetConfirmZoneCrossing(hwnd,
                                                (LPWSTR)pchUrl, 
                                                (LPWSTR) pchTask, 
                                                FALSE);
        if (ERROR_SUCCESS != err) 
        {
            //
            //  Either the user cancelled it or there is not enough
            // memory. Abort the navigation.
            //
            hr = HRESULT_FROM_WIN32(err);

            pProxyPending->Window()->ReleaseMarkupPending(this);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::PrepareDwnDoc( CDwnDoc * pDwnDoc, 
                        struct CDoc::LOADINFO * pLoadInfo, 
                        TCHAR * pchUrl, 
                        struct CMarkup::LOADFLAGS * pFlags,
                        LPCTSTR pchCallerUrl                    /* = NULL */)
{
    HRESULT hr;
    CDoc * pDoc = Doc();

    pDwnDoc->SetDocAndMarkup(pDoc, this);
    pDwnDoc->SetBindf(pFlags->dwBindf);
    pDwnDoc->SetDocBindf(pFlags->dwDocBindf);
    pDwnDoc->SetDownf(pFlags->dwDownf);
    pDwnDoc->SetRefresh(pLoadInfo->dwRefresh);
    pDwnDoc->SetDocCodePage(NavigatableCodePage(pLoadInfo->codepage));
    pDwnDoc->SetURLCodePage(NavigatableCodePage(pLoadInfo->codepageURL));
    pDwnDoc->TakeRequestHeaders(&(pLoadInfo->pbRequestHeaders), &(pLoadInfo->cbRequestHeaders));
    pDwnDoc->SetExtraHeaders(pLoadInfo->pchExtraHeaders);
    pDwnDoc->SetDownloadNotify(pDoc->_pDownloadNotify);
    pDwnDoc->SetDwnTransform(pDoc->IsAggregatedByXMLMime());

    //fix for IE bug 110387. If codepage is UTF-8, and machine id KO, JP or TW (at least), and
    //"Always use UTF-8" in Advanced Options is disabled, we 
    //get garbled bytes sent over the wire instead of URL. The bug is actually in
    //shlwapi but we don't have time to fix it and we feel that sending escaped UTF-8 is 
    //better anyway because it's safer.

/*
    NOTE: (dmitryt) See 110775. shlwapi or no shlwapi, poll among ieintwar showed 
    support for escaped UTF-8 if navigation is initiated by UTF-8 page, even if IE has 
    "use UTF-8 always" *unchecked*. Those 3 codepages below were arbitrary picked 
    according to IE5.5 war team to reduce risk of the fix because it was somewhat late in
    a shipping cycle for IE5.5
    However, it seems to be a right thing to do so I'm opening it for all platforms in Whistler.

    if((g_cpDefault == CP_KOR_5601 ||  g_cpDefault == CP_JPN_SJ ||  g_cpDefault == CP_TWN)
        && (pDwnDoc->GetURLCodePage() == CP_UTF_8)
      )
*/
    if(pDwnDoc->GetURLCodePage() == CP_UTF_8)
        pDwnDoc->SetLoadf((pFlags->dwLoadf & ~DLCTL_URL_ENCODING_DISABLE_UTF8) | DLCTL_URL_ENCODING_ENABLE_UTF8);
    else
        pDwnDoc->SetLoadf(pFlags->dwLoadf);


    if (pDoc->_pOptionSettings->fHaveAcceptLanguage)
    {
        hr = THR(pDwnDoc->SetAcceptLanguage(pDoc->_pOptionSettings->cstrLang));
        if (hr)
            goto Cleanup;
    }

    if (pDoc->_bstrUserAgent)
    {
        hr = THR(pDwnDoc->SetUserAgent(pDoc->_bstrUserAgent));
        if (hr)
            goto Cleanup;
    }

    SetReadyState(READYSTATE_LOADING);

    hr = THR(pDwnDoc->SetDocReferer(pLoadInfo->pchDocReferer));
    if (hr)
        goto Cleanup;

    hr = THR(pDwnDoc->SetSubReferer(pLoadInfo->pchSubReferer ?
                pLoadInfo->pchSubReferer : pchUrl));
    if (hr)
        goto Cleanup;

    if (pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup())
    {
        if (Doc()->_fActiveDesktop && IsActiveDesktopComponent())
            hr = pDwnDoc->SetSecurityID(this, TRUE);
        else 
            hr = pDwnDoc->SetSecurityID(pLoadInfo->pElementMaster->GetMarkup());
    }
    else
    {
        hr = pDwnDoc->SetSecurityID(this);
    }
    
//    hr = pDwnDoc->SetSecurityID(pLoadInfo->pElementMaster && pLoadInfo->pElementMaster->IsInMarkup() ?
//                                pLoadInfo->pElementMaster->GetMarkup() : this);
    if (hr)
        goto Cleanup;

    //
    // This data is used to process UrlActions that occur on redirects
    //

    pDwnDoc->SetCallerUrl(pchCallerUrl);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
HRESULT
CMarkup::PrepareHtmlLoadInfo( HTMLOADINFO * pHtmlLoadInfo, 
                             struct CDoc::LOADINFO * pLoadInfo, 
                             TCHAR * pchUrl,
                             IMoniker * pmkSubstitute, 
                             CDwnDoc * pDwnDoc)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    if (pLoadInfo->fBindOnApt)
        pHtmlLoadInfo->pInetSess = NULL;
    else
        pHtmlLoadInfo->pInetSess = TlsGetInternetSession();

    pHtmlLoadInfo->pDwnDoc         = pDwnDoc;
    pHtmlLoadInfo->pDwnPost        = GetDwnPost();
    pHtmlLoadInfo->pDoc            = pDoc;
    pHtmlLoadInfo->pMarkup         = this;
    pHtmlLoadInfo->pchBase         = pchUrl;
    pHtmlLoadInfo->pmi             = pLoadInfo->pmi;
    pHtmlLoadInfo->fClientData     = pLoadInfo->fKeepOpen;
    pHtmlLoadInfo->fParseSync      = pLoadInfo->fSync;
    pHtmlLoadInfo->ftHistory       = pLoadInfo->ftHistory;
    pHtmlLoadInfo->pchFailureUrl   = pLoadInfo->pchFailureUrl;
    pHtmlLoadInfo->pchUrlOriginal  = pLoadInfo->pchUrlOriginal;
    pHtmlLoadInfo->pchUrlLocation  = pLoadInfo->pchLocation;
    pHtmlLoadInfo->pstmRefresh     = pLoadInfo->pstmRefresh;
    pHtmlLoadInfo->fKeepRefresh    = pLoadInfo->fKeepRefresh;
    pHtmlLoadInfo->pVersions       = pDoc->_pVersions;
    pHtmlLoadInfo->fUnsecureSource = pLoadInfo->fUnsecureSource;
    pHtmlLoadInfo->fPendingRoot    = pLoadInfo->fPendingRoot;

    if (pmkSubstitute)
    {
        pHtmlLoadInfo->pmk = pmkSubstitute;
    }
    else if (pLoadInfo->pDwnBindData)
    {
        pHtmlLoadInfo->pDwnBindData = pLoadInfo->pDwnBindData;
        pHtmlLoadInfo->pstmLeader = pLoadInfo->pstmLeader;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pstmDirty)
    {
        IStream * pStmDirty = GetStmDirty();
        
        pHtmlLoadInfo->pstm = pLoadInfo->pstmDirty;
        ReplaceInterface(&pStmDirty, pLoadInfo->pstmDirty);
        hr = SetStmDirty(pStmDirty);
        if (hr)
            goto Cleanup;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pstm)
    {
        pHtmlLoadInfo->pstm = pLoadInfo->pstm;
        pHtmlLoadInfo->pchUrl = pchUrl;      // used for security assumptions
    }
    else if (pLoadInfo->pmk)
    {
        pHtmlLoadInfo->pmk = pLoadInfo->pmk;
        pHtmlLoadInfo->pchUrl = pchUrl;
        pHtmlLoadInfo->pbc = pLoadInfo->pbctx;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------+
void
CMarkup::HandlePicsSupport(struct CDoc::LOADINFO * pLoadInfo)
{
    // NB: (jbeda) We shouldn't be pics processing.
    // However, in the case of a reload for a cp change
    // we might already have a pics target
    Assert( !_fPicsProcessPending );

    // Set up the PICS monitoring here
    if (    pLoadInfo->fStartPicsCheck    
        &&  _pDoc->_pClientSite
        &&  HasWindowPending() 
        &&  !HasWindow()
        &&  !(_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
    {
        CVariant cvarPrivWindow(VT_UNKNOWN);
        CVariant cvarPicsPending;

        V_UNKNOWN(&cvarPrivWindow) = DYNCAST(IHTMLWindow2, GetWindowPending());
        V_UNKNOWN(&cvarPrivWindow)->AddRef();

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_STARTPICSFORWINDOW, 
                         0, &cvarPrivWindow, &cvarPicsPending));

        // If we now have a pctPics on this markup, we want to start prescanning
        if (V_BOOL(&cvarPicsPending) == VARIANT_TRUE)
        {
            _fPicsProcessPending = TRUE;
            Assert( GetPicsTarget() );
        }
#if DBG==1
        else
            Assert( !GetPicsTarget() );
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadFromInfo
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::LoadFromInfo(struct CDoc::LOADINFO * pLoadInfo, 
                      DWORD dwFlags,                           /* = 0 */
                      LPCTSTR pchCallerUrl                     /* = NULL */)
{
    HRESULT                 hr;
    HTMLOADINFO             htmloadinfo;
    IMoniker *              pmkSubstitute     = NULL;
    TCHAR *                 pchUrl;
    TCHAR *                 pchTask           = NULL;
    struct CDoc::LOADINFO   LoadInfo          = *pLoadInfo;
    CDwnDoc *               pDwnDoc;
    CDoc *                  pDoc              = Doc();
    CWindow *               pWindowParent     = NULL;
    IHTMLWindow2 *          pWindowShdocvw    = NULL;
    IHTMLWindow2 *          pWindow2          = NULL;
    IHTMLDocument2 *        pDocument2        = NULL;
    BSTR                    bstrName          = NULL;
    BSTR                    bstrUrl           = NULL;
    IBindCtx *              pbcNew            = NULL;
    IMoniker *              pmkNew            = NULL;
    CMarkup *               pMarkupForWaitCursor = NULL;
    CStr                    cstrCreatorUrl;
    BOOL                    fSpecialUrl       = FALSE;

    IMoniker* pmkTmp = NULL;              // Used with MIME mime type
    DWORD dwBindfTmp;

    
    struct CMarkup::LOADFLAGS  flags = {0};

    if (HasWindowPending())
    {
        CWindow *pWindow = GetWindowPending()->Window();
        if (pWindow)
        {
            pMarkupForWaitCursor = pWindow->_pMarkup;
            if (pMarkupForWaitCursor)
            {
                pMarkupForWaitCursor->ShowWaitCursor(TRUE);
            }
        }
    }

    pLoadInfo->pDwnPost      = NULL;
    pLoadInfo->pchDocReferer = NULL;
    pLoadInfo->pchSubReferer = NULL;

    if (LoadInfo.pstm)
        LoadInfo.pstm->AddRef();

    if (LoadInfo.pmk)
        LoadInfo.pmk->AddRef();

    BOOL fPendingPrimary = HasWindowPending() && GetWindowPending()->Markup()->IsPrimaryMarkup();
    
    if (fPendingPrimary)
    {
        _pDoc->_fShdocvwNavigate = LoadInfo.fShdocvwNavigate;
    }

    // If we are hosted in an object tag
    // or an HTML dialog, the _fDontFireWebOCEvents 
    // is set in CDoc::SetClientSite() or 
    // CHTMLDlg::SetFlagsOnDoc(), respectively.
    // and reset in CMarkup::OnLoadStatusDone().
    // Therefore, leave it alone.
    //
    if (!_pDoc->_fInObjectTag && !_pDoc->_fInHTMLDlg && !LoadInfo.fCreateDocumentFromUrl) 
    {
        _pDoc->_fDontFireWebOCEvents = LoadInfo.fDontFireWebOCEvents;
    }

    if (fPendingPrimary || LoadInfo.fDontUpdateTravelLog)
    {
        _pDoc->_fDontUpdateTravelLog = LoadInfo.fDontUpdateTravelLog;                
    }
    
    _pDoc->ResetProgressData();

    // We need a moniker.
    hr = THR(EnsureMoniker(&LoadInfo));
    if (hr)
        goto Cleanup;

    /*
    This is a description of how we handle opening MHTML documents in IE4.
    The developers involved in this work are:
    - DavidEbb for the Trident part (Office developer on loan).
    - SBailey for the MimeOle code (in INETCOMM.DLL).
    - JohannP for the URLMON.DLL changes.

    Here are the different scenarios we are covering:
    1. Opening the initial MHTML file:
    - When we initially open the MHTML file in the browser, URLMON will instantiate the MHTML handler (which is Trident), and call its IPersistMoniker::Load(pmkMain).
        - Trident calls GetMimeOleAndMk(pmkMain, &punkMimeOle, &pmkNew) (a new MimeOle API).
        - MimeOle looks at the moniker (which may look like http://server/foo.mhtml ), and checks in a global table whether there already exists a Mime Message object for the moniker. Suppose this is not the case now.
        - MimeOle creates a new Mime Message object, and loads its state from the moniker. It then adds this new Mime Message object to the global table.
        - Now, MimeOle creates a new moniker, which will look like "mhtml: http://server/foo.mhtml !", and it returns it to Trident. The meaning of this moniker is "the root object of the mhtml file". It also returns an AddRef'd IUnknown pointer to
        - Trident holds on to the IUnknown ptr until it (Trident) is destroyed. This guarantees that the Mime Message object stays around as long as Trident is alive.
        - Now Trident goes on to do what it normally does in its IPersistMoniker::Load, except that it uses pmkNew instead of pmkMain.
        - At some point in the Load code, Trident will call pmkNew->BindToStorage().
        - Now, we're in URLMON, which needs to deal with this funky mhtml: moniker. The trick here is that MimeOle will have registered an APP (Asynchronous Pluggable Protocol) for mhtml:. So URLMON instantiates the APP, and uses it to get the bits.
        - The APP looks at the moniker, breaks it into its two parts, " http://server/foo.mhtml " and "" (empty string, meaning root). It finds http://server/foo.mhtml  in its global table, and uses the associated MimeMessage object for the download.


    2. Retrieving images referenced by the root HTML doc of the MHTML file:
    So at this point, Trident is loaded with the root HTML document of the MHTML file. Now let's look at what happens when trident tries to resolve an embedded JPG image (say, bar.jpg):
    - Trident calls CoInternetCombineUrl, passing it "mhtml: http://server/foo.mhtml!" as the base, and "bar.jpg".
        - Now again, URLMON will need some help from the MHTML APP to combine those two guys. So it will end up calling MimeOle to perform the combine operation.
        - MimeOle will combine the two parts into the moniker "mhtml: http://server/foo.mhtml!bar.jpg " (note: if there had been a non empty string after the bang, it would have been removed).
    - Trident then calls BindToStorage on this new moniker. From there on, things are essentially the same as above. It goes into the APP, which finds http://server/foo.mhtml  in its global table, and knows how to get the bits for the part named "ba


    3. Navigating to another HTML document inside the MHTML file:
    Now let's look at what happens when we navigate to another HTML document (say part2.html) which is stored in the MHTML file:
    - As above, the APP will be used to combine the two parts into the moniker "mhtml: http://server/foo.mhtml!part2.html ".
    - Now SHDCOVW calls BindToObject on this moniker.
        - URLMON uses the APP to get the part2.html data (similar to case above, skipping details).
    - The APP reports that the data is of type text/html, so URLMON instantiates Trident, and calls its IPersistMoniker::Load with the moniker mhtml: http://server/foo.mhtml!part2.html .
        - Trident looks at the moniker and sees that it has the mhtml: protocol.
    - Again, it calls GetMimeOleAndMk, but this time it gets back the very same moniker. So the only purpose of this call is to get the Mime Message IUnknown ptr to hold on to. Suggestion: we should use a different API in this case, which simply ret
        - Trident then keeps on going with the moniker, and things happen as in case 1.

    4. Retrieving images referenced by the other (non root) HTML doc of the MHTML file:
    This is almost identical to case 2., except the now the base moniker is "mhtml: http://server/foo.mhtml!part2.html " instead of "mhtml: http://server/foo.mhtml !".

    5. Refreshing the current page:
    This should now work quite nicely because the current moniker that IE uses has enough information to re-get the data "from scratch". The reason it was broken before is that in our old scheme, IE only new the name of the part, and failed when tryi

    6. Resolving a shortcut:
    The very nice thing about this solution is that it will allow the creation of shortcuts to parts of an MHTML file. This works for the same reason that case 5 works.
    */

    // If we've been instantiated as an mhtml handler, or if we are dealing
    // with a 'mhtml:' url, we need to get a special moniker from MimeOle.
    // Also, we get an IUnknown ptr to the Mime Message object, which allows
    // us to keep it alive until we go away.

    if (    LoadInfo.pmk
        &&  HasWindowPending()
        &&  GetWindowPending() == pDoc->_pWindowPrimary
        &&  (pDoc->_fMhtmlDoc || 
                 (pDoc->_fMhtmlDocOriginal && (_fInRefresh || (dwFlags & CDoc::FHL_RESTARTLOAD))) ||
                 (!LoadInfo.pstmHistory && LoadInfo.pchDisplayName && _tcsnicmp(LoadInfo.pchDisplayName, 6, _T("mhtml:"), -1) == 0)
            )
       )
    {
        TCHAR* pchOriginalUrl = NULL;
        
        if ( pDoc->_fMhtmlDocOriginal && ! _fInRefresh )
        {
            // Get the URL from the display name of the moniker:
            hr = pDoc->_pOriginalMoniferForMHTML->GetDisplayName(NULL, NULL, & pchOriginalUrl );
            if (FAILED(hr))
            {
                CoTaskMemFree( pchOriginalUrl );
                goto Cleanup;
            }
        }

        //
        // Either we don't have an original url, or this is a different url. 
        //
        if ((!pDoc->_fMhtmlDocOriginal && !_fInRefresh) ||
            (pchOriginalUrl && _tcsicmp(LoadInfo.pchDisplayName, pchOriginalUrl) != 0 ))

        {
            ClearInterface(&pDoc->_pOriginalMoniferForMHTML);            

            pDoc->_pOriginalMoniferForMHTML = LoadInfo.pmk;
            pDoc->_pOriginalMoniferForMHTML->AddRef();

            pDoc->_fMhtmlDocOriginal = TRUE;
        }

        CoTaskMemFree( pchOriginalUrl );

        if (dwFlags & CDoc::FHL_RESTARTLOAD)
        {
            pmkTmp = LoadInfo.pmk;           
        }
        else
        {
            pmkTmp = pDoc->_pOriginalMoniferForMHTML;  
        }

        if (_fInRefresh)
        {
            dwBindfTmp = LoadInfo.dwBindf; 
        }
        else
        {
            dwBindfTmp = flags.dwBindf;
        }

        pmkTmp->AddRef();  // Make sure the moniker stays alive during this funniness.

        ClearInterface(&pDoc->_punkMimeOle);

        hr = MimeOleObjectFromMoniker((BINDF) dwBindfTmp, 
                                       pmkTmp,
                                       LoadInfo.pbctx, 
                                       IID_IUnknown, 
                                       (void**) 
                                       &pDoc->_punkMimeOle, &pmkNew);

        pmkTmp->Release();

        if (FAILED(hr))
            goto Cleanup;

        // From here on, work with the new moniker instead of the one passed in
        ReplaceInterface(&LoadInfo.pmk, pmkNew);
        hr = THR( ReplaceMonikerPtr( pmkNew ) );

        if( hr )
            goto Cleanup;

        // Create a new bind context if we are an mhtml handler, because this
        // will be a new binding operation.
        if (pDoc->_fMhtmlDoc)
        {
            hr = CreateBindCtx(0, &pbcNew);
            if (FAILED(hr))
                goto Cleanup;

            // We don't hold a reference to LoadInfo.pbctx, so don't use
            // ReplaceInterface here.
            LoadInfo.pbctx = pbcNew;
        }
    }

    // We need to get and set the local URL 
    hr = THR(DetermineUrlOfMarkup(&LoadInfo, &pchUrl, &pchTask));
    if (hr)
        goto Cleanup;

    fSpecialUrl = IsSpecialUrl( pchUrl );
    
    pDwnDoc = new CDwnDoc;
    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = SetDwnDoc(pDwnDoc);
    if (hr)
        goto Cleanup;

    if (HasWindowPending())
    {
        pWindowParent = GetWindowPending()->Window()->_pWindowParent;
    }

    //
    // The _pDoc->_pShellBrowser will only be set when we are hosted in IE. In
    // all other hosts, the host does the check in OnBeforeNavigate2, so we don't
    // want to do it and possibly show UI here.
    //
    if (_fWindowPending && !_pDoc->_fShdocvwNavigate && _pDoc->_fInIEBrowser)
    {
        BOOL fIsError;

        if (pchTask && pDoc->_pTridentSvc)
        {
            hr = THR(pDoc->_pTridentSvc->IsErrorUrl(pchTask, &fIsError));
            if (hr)
                goto Cleanup;
        }
        else
            fIsError = FALSE;

        if (!fIsError)
        {
            hr = THR(CheckZoneCrossing(pchTask));
            if (hr)
                goto Cleanup;
        }
    }

    // TODO (jbeda) this bit remembers if the host set the load
    // bits directly but not if we actually read prefs already.
    // We will make this call twice while loading -- once early
    // in CDoc::LoadFromInfo and once here. However, if we need the
    // call here for the case where we are called from LoadHistory. 
    // Maybe the real answer is to have only one LoadFromInfo?
    if (!pDoc->_fGotAmbientDlcontrol)
    {
        pDoc->SetLoadfFromPrefs();
    }

    // Create CVersions object if we haven't already
    if (!pDoc->_pVersions)
    {
        hr = THR(pDoc->QueryVersionHost());
        if (hr)
            goto Cleanup;
    }

    // Before creating any elements, create the history load context
    hr = THR(HandleHistoryAndNavContext(&LoadInfo));
    if (hr)
        goto Cleanup;

    flags.dwBindf = LoadInfo.dwBindf;

    // Extract information from the pbctx
    if (LoadInfo.pbctx)
    {
        TCHAR * pchCreatorUrl = NULL;
        CVariant varOpener(VT_EMPTY);

        Assert(LoadInfo.pmk); // we should only have a pbctx when we have a pmk

        // TODO (lmollico): temporary hack
        
        {
            hr = pDoc->QueryService(SID_SHTMLWindow2, IID_IHTMLWindow2, (void **) &pWindowShdocvw);
            if (!hr)
            {
                // Make sure we don't already have an opener
                //
                pDoc->_pWindowPrimary->get_opener(&varOpener);

                if (VT_EMPTY == V_VT(&varOpener))
                {
                    varOpener.Clear();

                    hr = pWindowShdocvw->get_opener(&varOpener);
                    if (hr)
                        goto opener_error;

                    hr = pDoc->_pWindowPrimary->put_opener(varOpener);
                    if (hr)
                        goto Cleanup;

                    if (V_VT(&varOpener) == VT_DISPATCH)
                    {
                        hr = V_DISPATCH(&varOpener)->QueryInterface(IID_IHTMLWindow2, (void **) &pWindow2);
                        if (hr)
                            goto opener_error;

                        hr = pWindow2->get_document(&pDocument2);
                        if (hr)
                            goto opener_error;

                        hr = pDocument2->get_URL(&bstrUrl);
                        if (hr)
                            goto opener_error;
                    }
                }

                hr = pWindowShdocvw->get_name(&bstrName);
                if (hr)
                    goto opener_error;

                if (pDoc->_fViewLinkedInWebOC && IsPrimaryMarkup() && (!bstrName || !*bstrName))
                {
                    COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

                    if (pOmWindowProxy)
                        IGNORE_HR(pOmWindowProxy->Window()->get_name(&bstrName));
                }

                if ((IsPrimaryMarkup() || (HasWindowPending() && GetWindowPending()->Markup()->IsPrimaryMarkup())) 
                    && bstrName 
                    && *bstrName)
                {
                    hr = pDoc->_pWindowPrimary->put_name(bstrName);
                    if (hr)
                        goto Cleanup;
                }
            }
            else
                hr = S_OK;

opener_error:
            // We don't want to fail the load just
            // because we couldn't get to the opener.
            hr = S_OK;
        }
                          
        // Always get the creator Url out of the bind context to avoid leaking memory
        //
        THR(GetBindContextParam(LoadInfo.pbctx, &cstrCreatorUrl));        

        TraceTag((tagSecurityContext, "CMarkup::LoadFromInfo- Markup: 0x%x URL: %ws BindCtx_Creator URL: %ws", this, pchUrl, (LPTSTR)cstrCreatorUrl));

        //
        // If we are being opened by a window.open call, then we have the URL for the 
        // document calling us in the bind context. Take that and save it in the cstrCreatorUrl.
        // This variable will be used when communicating with the URLMON and responding security
        // context queries.
        // If primary and don't have an opener, we don't have a creator.
        //        
        if (    (   IsPrimaryMarkup() 
                ||  (   IsPendingPrimaryMarkup() &&  LoadInfo.fErrorPage) 
                || _fNewWindowLoading) 
            &&  V_VT(&varOpener) != VT_EMPTY)
        {               
            if (cstrCreatorUrl.Length())
            {
                pchCreatorUrl = cstrCreatorUrl;
            }
            else if (bstrUrl)
            {
                cstrCreatorUrl.Set(bstrUrl);         
                pchCreatorUrl = cstrCreatorUrl;
            }

#if DBG==1  
            if (IsPendingPrimaryMarkup() && LoadInfo.fErrorPage)
            {
                TraceTag((tagSecurityContext, "                     - Error page load. Creator URL: %ws", pchCreatorUrl ));
            }
            else
            {
                TraceTag((tagSecurityContext, "                     - Window.open load. Creator URL: %ws", pchCreatorUrl ));
            }
#endif
        }        
        else if ((!IsPendingPrimaryMarkup() || (LoadInfo.dwBindf & BINDF_HYPERLINK)) && fSpecialUrl ) 
        {
            // If we are doing a navigation, the creator url should be stored in the bind context. We only
            // need to set this if we are navigating to a special url.
            // The special URL check is only applied if we are a frame nav. or we are navigating the top
            // level with a hyperlink action.
            pchCreatorUrl = cstrCreatorUrl;            

            TraceTag((tagSecurityContext, "                     - Frame nav. or top level nav. with hyperlink action. Creator URL: %ws", pchCreatorUrl ));
        }

        if ( fSpecialUrl )
        {
            TraceTag((tagSecurityContext, "                     - Special URL processing, add creator back into the bindctx"));

            // since the CxxxProtocol::ParseAndBind is going to try to get to the same bindctx params,
            // we should put the information back in.
            hr = THR(AddBindContextParam(LoadInfo.pbctx, &cstrCreatorUrl));
            if (hr)
                goto Cleanup;
        }
                            
        // Set the creatorUrl 
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            TraceTag((tagSecurityContext, "                     - Markup 0x%x SetAACreatorUrl(%ws)", this, pchCreatorUrl));

            hr = THR(SetAAcreatorUrl(pchCreatorUrl));
            if (hr)
                goto Cleanup;

            // HACKHACK (jbeda): if we are in the PICS case
            // we have a blank document that is a place holder
            // Set the creator url on that guy too
            if (    _fNewWindowLoading 
                &&  HasWindowPending() )
            {
                CWindow * pWindow = GetWindowPending()->Window();
                if (    pWindow->_pMarkup
                    &&  pWindow->_pMarkup->_fPICSWindowOpenBlank)
                {
                    pWindow->_pMarkup->SetAAcreatorUrl(pchCreatorUrl);
                }
            }
        }

        hr = THR(ProcessHTMLLoadOptions(&LoadInfo));
        if (hr)
            goto Cleanup;

        hr = THR(ProcessDwnBindInfo(&LoadInfo, &flags, pchTask, pWindowParent));
        if (hr)
            goto Cleanup;
    }

    // set the markup URL 
    if (pchTask)
    {
        // we must have a moniker here,
        Assert(LoadInfo.pmk);

        // now chop of #location part, if any
        TCHAR *pchLoc = const_cast<TCHAR *>(UrlGetLocation(pchTask));
        if (pchLoc)
            *pchLoc = _T('\0');

        hr = THR(SetUrl(this, pchTask));
        if (hr)
            goto Cleanup;

        if (LoadInfo.pchSearch)
        {
             hr = THR(SetUrlSearch(this, LoadInfo.pchSearch));
             if (hr)
                 goto Cleanup;
        }

        hr = THR(SetUrlOriginal(this, LoadInfo.pchUrlOriginal));
        if (hr)
            goto Cleanup;

        UpdateSecurityID();

        pDoc->DeferUpdateTitle(this);
    }

    //
    // If it's a javascript: or vbscript: url - we want to use the creator url.
    //
    hr = THR(HandleSSLSecurity(&LoadInfo, 
                               fSpecialUrl && IsScriptUrl( pchUrl ) ? ( (LPTSTR) cstrCreatorUrl) : pchUrl , 
                               &flags, 
                               &pmkSubstitute));
    if (hr)
        goto Cleanup;

    hr = THR(ProcessLoadFlags(&LoadInfo, pchUrl, &flags));
    if (hr)
        goto Cleanup;

    hr = THR(ProcessCodepage(&LoadInfo, pWindowParent));
    if (hr)
        goto Cleanup;

    hr = THR(PrepareDwnDoc(pDwnDoc, &LoadInfo, pchUrl, &flags, pchCallerUrl));
    if (hr)
        goto Cleanup;

    if (LoadInfo.pDwnPost)
    {
        Assert(!GetDwnPost()); // This is a new Markup

        hr = SetDwnPost(LoadInfo.pDwnPost);
        if (hr)
            goto Cleanup;
        LoadInfo.pDwnPost->AddRef();
    }

    hr = THR(PrepareHtmlLoadInfo(&htmloadinfo, &LoadInfo, pchUrl, pmkSubstitute, pDwnDoc));
    if (hr)
        goto Cleanup;

    // Loading a dirty subframe should dirty the whole world.  However, 
    // loading a clean page only sets us clean if it's the primary
    if( GetStmDirty() )
    {
        Doc()->_lDirtyVersion = MAXLONG;
    } 
    else if( HasPrimaryWindow() )
    {
        Doc()->_lDirtyVersion = 0;
    }

    HandlePicsSupport(&LoadInfo);

    hr = THR(Load(&htmloadinfo));

Cleanup:
    // Clear this flag, we have no further use for it for this markup.
    // If we are loading another mhtml document, we will create another
    // CDoc for it. If we do not clear this flag now, it will confuse
    // the next CMarkup being loaded into thinking it is an MHTML
    // document too.

    pDoc->_fMhtmlDoc = FALSE;

    ReleaseInterface(pmkSubstitute);
    ReleaseInterface(pbcNew);
    ReleaseInterface(pmkNew);
    ReleaseInterface(LoadInfo.pstm);
    ReleaseInterface(LoadInfo.pmk);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    CoTaskMemFree(pchTask);
    ReleaseInterface((IUnknown *) LoadInfo.pDwnPost);
    ReleaseInterface(pWindowShdocvw);
    ReleaseInterface(pWindow2);
    ReleaseInterface(pDocument2);
    FormsFreeString(bstrName);
    FormsFreeString(bstrUrl);
    if (S_OK != hr && pMarkupForWaitCursor)
       pMarkupForWaitCursor->ShowWaitCursor(FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::Load
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::Load(HTMLOADINFO * phtmloadinfo)
{
    HRESULT hr;
    CHtmCtx *       pHtmCtxLocal = NULL;

    //
    // create _pHtmCtx
    //

    hr = THR(NewDwnCtx(DWNCTX_HTM, FALSE, phtmloadinfo, (CDwnCtx **)&_pHtmCtx));
    if (hr)
        goto Cleanup;

    // Addref for the stack
    pHtmCtxLocal = _pHtmCtx;
    pHtmCtxLocal->AddRef();

    //
    // create _pProgSink if necessary:
    //
    // 1. Primary markup always needs it
    // 2. It is always necessary during async download
    // 3. It is necessary if _LoadStatus is requested to be advanced as download progresses
    //

    if (    HasWindowPending()
        ||  !phtmloadinfo->fParseSync
        ||  phtmloadinfo->fAdvanceLoadStatus)
    {
        _pProgSink = new CProgSink(_pDoc, this);
        if (!_pProgSink)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pProgSink->Init());
        if (hr)
            goto Cleanup;

        hr = THR(_pHtmCtx->SetProgSink(_pProgSink));
        if (hr)
            goto Cleanup;


    }

    //
    // set up Url
    //

    if (phtmloadinfo->pchUrl)
    {
        hr = SetUrl(this, (TCHAR*)phtmloadinfo->pchUrl);
        if (hr)
            goto Cleanup;

        hr = THR(SetUrlOriginal(this, phtmloadinfo->pchUrlOriginal));
        if (hr)
            goto Cleanup;

        hr = THR(SetUrlLocation(this, phtmloadinfo->pchUrlLocation));
        if (hr)
            goto Cleanup;

        // If the load operation is not being made into a possibly temporary markup
        // then ensure the script context to be able to show this markup in the 
        // script debugger's running document's window even if it does not contain
        // any script.
        hr = THR(EnsureScriptContext(NULL));
        if (hr)
            goto Cleanup;
    }


    //
    // copy design mode from context
    //   
    if (phtmloadinfo->pContextMarkup)
    {
        _fInheritDesignMode = phtmloadinfo->pContextMarkup->_fInheritDesignMode;
        _fDesignMode = phtmloadinfo->pContextMarkup->_fDesignMode;
    }

    //
    // launch download
    //

    _pHtmCtx->SetLoad(TRUE, phtmloadinfo, FALSE);
    hr = (pHtmCtxLocal->GetState() & DWNLOAD_ERROR) ? E_FAIL : S_OK;
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    if (phtmloadinfo->fAdvanceLoadStatus)
    {
        // cause ProgSink to update it's status synchronously - this will advance LoadStatus if possible
        _pProgSink->OnMethodCall((DWORD_PTR)_pProgSink);
    }

Cleanup:
    if (pHtmCtxLocal)
        pHtmCtxLocal->Release();

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SuspendDownload
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SuspendDownload()
{
    HRESULT hr = S_OK;
    if (HtmCtx())
    {
        HtmCtx()->Sleep(TRUE);
    }
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ResumeDownload
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ResumeDownload()
{
    HRESULT hr = S_OK;
    if (HtmCtx())
    {
        HtmCtx()->Sleep(FALSE);
    }
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadStatus
//
//----------------------------------------------------------------------------

LOADSTATUS
CMarkup::LoadStatus()
{
    return _LoadStatus;
}

//+---------------------------------------------------------------
//
//  Member:     SetMetaToTrident()
//
//  Synopsis:   When we create or edit (enter design mode on) a
//      document the meta generator tag in the header is to be
//      set to Trident and the appropriate build. If a meta generator
//      already exists then it should be replaced.
//             this is called after the creation of head,title... or
//      on switching to design mode. in both cases we can assume that
//      the headelement array is already created.
//
//---------------------------------------------------------------

static BOOL 
LocateGeneratorMeta(CMetaElement * pMeta)
{
    LPCTSTR szMetaName;
    BOOL    fRet;

    szMetaName = pMeta->GetAAname();

    if(szMetaName == NULL)
    {
        fRet = FALSE;
    }
    else
    {
        fRet = ! StrCmpIC( pMeta->GetAAname(), _T( "GENERATOR" ) );
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SetMetaToTrident
//
//  Synopsis:   Set the meta marker to trident
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::SetMetaToTrident()
{
    HRESULT         hr = S_OK;
    TCHAR           achVersion [256];
    CMetaElement *  pMeta=NULL;
    
    if( Doc()->_fDontWhackGeneratorOrCharset
        WHEN_DBG( || IsTagEnabled(tagNoMetaToTrident) ) )
        goto Cleanup;

    hr = THR(LocateOrCreateHeadMeta(LocateGeneratorMeta, &pMeta));
    if (hr || !pMeta)
        goto Cleanup;

    hr = THR(
        pMeta->AddString(
            DISPID_CMetaElement_name, _T("GENERATOR"),
            CAttrValue::AA_Attribute));
    if (hr)
        goto Cleanup;

    hr =
        Format(
            0, achVersion, ARRAY_SIZE(achVersion),
            _T("MSHTML <0d>.<1d2>.<2d4>.<3d>"), VER_PRODUCTVERSION);
    if (hr)
        goto Cleanup;

    hr = THR(pMeta->SetAAcontent(achVersion));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

// defined in mshtml\src\other\misc\weboc.cxx
LPCTSTR VariantToStrCast(const VARIANT *pvar);

HRESULT
CMarkup::ViewLinkWebOC(VARIANT * pvarUrl,
                       VARIANT * pvarFlags,
                       VARIANT * pvarFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders)

{
    HRESULT           hr;
    CObjectElement  * pObjectElement = NULL;
    IWebBrowser2    * pWebBrowser    = NULL;
    IBrowserService * pBrowserSvc    = NULL;

    BSTR              bstrClassId    = SysAllocString(_T("clsid:8856F961-340A-11D0-A96B-00C04FD705A2")); // WebOC

    CVariant          varSize(VT_BSTR);
    CVariant          cvarWindowID(VT_I4);
    COmWindowProxy  * pProxy = GetWindowPending();
    CWindow         * pWindow;
    
    if (bstrClassId == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pProxy == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pWindow = pProxy->Window();

    if (pWindow == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = CreateElement(ETAG_OBJECT, (CElement**) &pObjectElement);
    if (hr)
        goto Cleanup;

    pObjectElement->_fViewLinkedWebOC = TRUE;

    hr = Root()->InsertAdjacent(CElement::AfterBegin, pObjectElement);
    if (hr)
        goto Cleanup;

    V_BSTR(&varSize) = SysAllocString(_T("100%"));

    hr = pObjectElement->put_VariantHelper(varSize, (PROPERTYDESC*)&s_propdescCObjectElementwidth);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->put_VariantHelper(varSize, (PROPERTYDESC*)&s_propdescCObjectElementheight);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->put_classid(bstrClassId);
    if (hr)
        goto Cleanup;

    hr = pObjectElement->QueryInterface(IID_IWebBrowser2, (void**)&pWebBrowser);
    if (hr)
        goto Cleanup;

    Assert(!pWindow->_dwWebBrowserEventCookie);
    Assert(!pWindow->_punkViewLinkedWebOC);

    pWindow->_punkViewLinkedWebOC = pObjectElement->PunkCtrl();
    pWindow->_punkViewLinkedWebOC->AddRef();

    hr = ConnectSink(pWindow->_punkViewLinkedWebOC,
                     DIID_DWebBrowserEvents2,
                     (IUnknown*)(IPrivateUnknown*)pWindow,
                     &pWindow->_dwWebBrowserEventCookie);
    if (hr)
        goto Cleanup;

    hr = IUnknown_QueryService(pWindow->_punkViewLinkedWebOC,
                               SID_SShellBrowser,
                               IID_IBrowserService,
                               (void**)&pBrowserSvc);
    if (hr)
        goto Cleanup;

    if (!pWindow->_dwViewLinkedWebOCID)
    {
        pWindow->_dwViewLinkedWebOCID = pBrowserSvc->GetBrowserIndex();
    }
    else
    {
        V_I4(&cvarWindowID) = pWindow->_dwViewLinkedWebOCID;

        IGNORE_HR(CTExec(pBrowserSvc,
                         &CGID_DocHostCmdPriv,
                         DOCHOST_SETBROWSERINDEX,
                         NULL,
                         &cvarWindowID,
                         NULL));
    }

    if (VariantToStrCast(pvarUrl))
    {
        // This is a bug fix for # 26636.  There is a scenerio where we shdocvw
        // brings up a Modal dialog in CDocObjectHost before navigating to a media
        // page.  If navigation happens via a TIMER message through script before
        // the user responds to the dialog, then the instance of CDocObjectHost
        // gets deleted causing a crash.  There doesn't seem to be a way to block
        // navigation in that particular scenerio from shdocvw.  So we're blocking
        // navigation in Trident before delegating navigation to shdocvw for
        // Media pages.

        HRESULT             hrtmp = E_FAIL;
        IUnknown            *pUnk = NULL;

        if (pWindow->_pBindCtx)
        {
            hrtmp = pWindow->_pBindCtx->GetObjectParam(_T("MediaBarMime"), &pUnk);
            if (hrtmp == S_OK)
                _pDoc->EnableModeless(FALSE);
        }

        hr = NavigateWebOCWithBindCtx(pWebBrowser, pvarUrl, pvarFlags, pvarFrameName,
                                      pvarPostData, pvarHeaders, pWindow->_pBindCtx,
                                      CMarkup::GetUrlLocation(this));

        if (hrtmp == S_OK)
        {
            _pDoc->EnableModeless(TRUE);
            if (pUnk)
                pUnk->Release();
        }
    }
    else
    {
        hr = pWebBrowser->Navigate2(pvarUrl, pvarFlags, pvarFrameName, pvarPostData, pvarHeaders);
    }
    if (hr)
        goto Cleanup;
        
Cleanup:
    if (pObjectElement)
        pObjectElement->Release();

    if (pWebBrowser != NULL)
        ReleaseInterface(pWebBrowser);

    if (bstrClassId != NULL)
        SysFreeString(bstrClassId);

    ReleaseInterface(pBrowserSvc);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::OnLoadStatus
//
//  Synopsis:   Handle change in download status
//
//  [ htc dependency ]
//
//----------------------------------------------------------------------------

void
CMarkup::OnLoadStatus(LOADSTATUS LoadStatus)
{
    // NOTE (lmollico): we need to addref CMarkup because CDoc::OnLoadStatus can cause 
    // this (CMarkup) to be destroyed if the doc is unloaded
    AddRef();

    while (_LoadStatus < LoadStatus)
    {                
        AssertSz(CPeerHolder::IsMarkupStable(this), "CMarkup::OnLoadStatus appears to be called at an unsafe moment of time");
        
        // if we are not yet LOADSTATUS_INTERACTIVE, we will call ProcessPeerTasks when 
        // the posted SetInteractive is processed
        if (_LoadStatus >= LOADSTATUS_INTERACTIVE)
        {
            ProcessPeerTasks(0); // NOTE an important assumption here is that this is ONLY called
                                 // at a safe moment of time to run external code
        }

        _LoadStatus = (LOADSTATUS) (_LoadStatus + 1);

        PerfDbgLog1(tagPerfWatch, this, "+CMarkup::OnLoadStatus %s",
            LoadStatus == LOADSTATUS_INTERACTIVE ? "INTERACTIVE" :
            LoadStatus == LOADSTATUS_PARSE_DONE ? "PARSE_DONE" :
            LoadStatus == LOADSTATUS_QUICK_DONE ? "QUICK_DONE" :
            LoadStatus == LOADSTATUS_DONE ? "DONE" : "?");


        switch (_LoadStatus)
        {
            case LOADSTATUS_INTERACTIVE:
                OnLoadStatusInteractive();
                break;

            case LOADSTATUS_PARSE_DONE:
                {
                    BOOL fComplete = OnLoadStatusParseDone();
                    if (fComplete)
                        goto Cleanup;
                }
                break;

            case LOADSTATUS_QUICK_DONE:
                OnLoadStatusQuickDone();
                break;

            case LOADSTATUS_DONE:
                {
                    BOOL fComplete = OnLoadStatusDone();

                    if (g_fInMoney98 && _pDoc && IsPrimaryMarkup())
                    {
                        // during certain navigations, Money turns off painting
                        // on their host window and never sends a repaint message
                        // to the Trident child window.  Here's a hack to work
                        // around this.  [See bug 106189 - sambent.]
                        _pDoc->Invalidate();
                    }

                    if (fComplete)
                        goto Cleanup;
                }
                break;

            default:
                Assert(0 && "Bad enum value");
                goto Cleanup;
        }

        //
        // send to html component, if any

        if (HasBehaviorContext() && BehaviorContext()->_pHtmlComponent)
        {
            BehaviorContext()->_pHtmlComponent->OnLoadStatus(_LoadStatus);
        }
    }

Cleanup:
    Release();
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusInteractive
//
//  Synopsis:   Handles the LOADSTATUS_INTERACTIVE case for OnLoadStatus
//
//----------------------------------------------------------------------------

void
CMarkup::OnLoadStatusInteractive()
{
    if ((GetReadyState() < READYSTATE_INTERACTIVE) && !_fIsInSetInteractive)
    {
        RequestReadystateInteractive();
    }                                              

    // If we have a task to look for a certain scroll position,
    // make sure we have recalc'd at least to that point before
    // display.

    // Supress scrollbits if we're about to inval the entire window anyway
    // $$anandra Consider if this inval stuff should be on doc or markup.  
    //           has relevance if CView is per CDoc or CMarkup.  
    //
    NavigateNow(!_pDoc->_fInvalNoninteractive);

    // If we have prviously supressed invalidations before LOADSTATUS_INTERACTIVE,
    // we must invalidate now.
    //
    if (_pDoc->_fInvalNoninteractive)
    {
        _pDoc->_fInvalNoninteractive = FALSE;
        _pDoc->Invalidate(NULL, NULL, NULL, INVAL_CHILDWINDOWS);
    }


    // for frame markup's, the only way to get them added to history is to call
    // AddUrl, BUT, at DocNavigate time we didn't know the friendly URL name,
    // so do it now.
    //
    // only do this for windowed (frame) markups and only if this is due ot a navigation
    // and not to inital loading.
    if(   HtmCtx()
       && (   _fNavFollowHyperLink
           && !IsPrimaryMarkup()
           && !IsPendingPrimaryMarkup()
           )
       && Doc()->_pUrlHistoryStg // should have been Ensured in DoNavigate()
       && !_fServerErrorPage) 
    {
        BSTR bstrTitle = NULL;
        BSTR bstrUrl = SysAllocString (GetUrl(this));

        if (bstrUrl)
        {
            if (GetTitleElement() && GetTitleElement()->_cstrTitle)
            {
                GetTitleElement()->_cstrTitle.AllocBSTR(&bstrTitle);
            }
            else
            {
                // This is wrong. Steal the code from CDoc::UpdateTitle() to
                // create the correct title for file:// url's
                bstrTitle = SysAllocString(_T(""));
            }

            Doc()->_pUrlHistoryStg->AddUrl(bstrUrl, 
                                           bstrTitle, 
                                           ADDURL_ADDTOHISTORYANDCACHE);

            SysFreeString(bstrTitle);

            SysFreeString(bstrUrl);
        }
    }
}


//-------------------------------------------------------------------------------------
//
//  used to see if the image toolbar is explicitly disabled by a meta tag or not...
//  see CMetaElement::IsGalleryMeta() in hedelems.cxx
//
//-------------------------------------------------------------------------------------

BOOL CMarkup::IsGalleryMode()
{

    BOOL bFlag=TRUE;

    if (GetHeadElement())
    {
        CTreeNode *pNode;
        CChildIterator ci ( GetHeadElement() );
 
        //
        // ToDO: Query host and detect if theme is on
        //
 
        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META )
            {
                if (!DYNCAST(CMetaElement,pNode->Element())->IsGalleryMeta())
                {
                    bFlag=FALSE;
                }
            }
        }
    }
    return bFlag;
}

//+---------------------------------------------------------------------------
//
//  Member  : CMarkup::OnLoadStatusParseDone
//
//  Synopsis: Handles the LOADSTATUS_PARSE_DONE case for OnLoadStatus
//
//  Return  : TRUE indicates that OnLoadStatus if complete and should not
//            continue processing.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::OnLoadStatusParseDone()
{
    HRESULT hr;
    BOOL    fComplete = FALSE;
    BOOL    fIsPrimaryMarkup = IsPrimaryMarkup();

    // Reset this flag. We may not do navigation delegation so we need the extra initialization
    // This get reset to false when navigating a frame, but that's okay because you must have
    // delegatated -- you're in html.
    _pDoc->_fDelegatedDownload = FALSE;

    // In design mode, set META generator tag to Trident, and
    // clear the dirty bit.
    if (_fDesignMode)
    {
        // Setting this meta tag is still part of the 
        // parse phase.  Because of this, we can safely
        // not save undo info if we end up sticking in a
        // meta tag here.
        Assert(!_fNoUndoInfo );
        _fNoUndoInfo = TRUE;

        IGNORE_HR(SetMetaToTrident());
        _fNoUndoInfo = FALSE;              
    }
/*
    // if a gallery meta tag exists, tell shdocvw to turn off image hoverbar thingie
    ITridentService2 *pTriSvc2;

    if (_pDoc->_pTridentSvc 
        && SUCCEEDED(_pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2))) 
    {
        pTriSvc2->IsGalleryMeta(IsGalleryMode());
        pTriSvc2->Release();
    }
*/
    ProcessMetaPicsDone();

    CHtmCtx * pHtmCtx = HtmCtx();

    // When htm loading is complete, first check for failure
    // and alternate URL. If they exist, do a reload
    //
    if (    pHtmCtx
        &&  (pHtmCtx->GetState() & DWNLOAD_ERROR)
        &&  !IsSpecialUrl(GetUrl(this)))
    {
        HRESULT hrBindResult = pHtmCtx->GetBindResult();

        if ( IsPrimaryMarkup() )
        {
            _pDoc->_fNeedUpdateTitle = FALSE;
        }
        
        if (pHtmCtx->GetFailureUrl())
        {
            IStream * pStreamRefresh;

            pStreamRefresh = pHtmCtx->GetRefreshStream();
            if (pStreamRefresh)
            {
                pStreamRefresh->AddRef();

                // TODO (CARLED) there is currently an assert and memory leak here, 
                // (bug 106014)
                // We are replacing this markup without releaseing it. We're 
                // not navigating to the failureUrl, or switching markups, but just loading 
                // ontop of the current one. See LoadFailureUrl for more comments

                IGNORE_HR(LoadFailureUrl(pHtmCtx->GetFailureUrl(), pStreamRefresh));
                ClearInterface(&pStreamRefresh);

                fComplete = TRUE;
                goto Cleanup;
            }
        }
        else if (hrBindResult)
        {
            if (  hrBindResult == E_ABORT )
            {
                if (pHtmCtx->GetMimeInfo() == g_pmiTextHtml && !(_pDoc->_dwLoadf & DLCTL_SILENT))
                {
                    IGNORE_HR(_pDoc->ShowLoadError(pHtmCtx));
                }
            }
            else if (  hrBindResult != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
                    && hrBindResult != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
            {
                Assert(_pDoc->_pClientSite);

                CTExec(_pDoc->_pClientSite, &CGID_ShellDocView,
                       SHDVID_NAVIGATEFROMDOC, 0, NULL, NULL);

                if (this == GetFrameOrPrimaryMarkup())
                {
                    // If DelegateNavigation returns TRUE, we must
                    // continue processing the rest of this method
                    // but tell the caller that we have completed
                    // our function.
                    //
                    hr = _pDoc->DelegateNavigation(hrBindResult, NULL, NULL, this, NULL, &fComplete);
                    if (hr)
                    {
                        fComplete = TRUE;
                        goto Cleanup;
                    }
                }
            }
        }
    }
    else
    {
        _fLoadingHistory  = FALSE;
    }

    if (fIsPrimaryMarkup)
    {
        _pDoc->_fShdocvwNavigate  = FALSE;
    }
    
    if (HasWindowPending())
    {
        GetWindowPending()->Window()->_fHttpErrorPage = FALSE;
    }

    // If the currency has not been set, set it to the client element.
    _pDoc->DeferSetCurrency(0);

    // Now is the time to ask the sites to load any history
    // that they could not earlier (e.g. scroll/caret positions
    // because they require the doc to be recalced, the site
    // arrays built, etc.)
    {
        CMarkupTransNavContext * ptnc;
        if (    _pDoc->State() >= OS_INPLACE 
            &&  HasTransNavContext()
            &&  (ptnc = GetTransNavContext())->_fDoDelayLoadHistory)
        {
            CNotification   nf;

            ptnc->_fDoDelayLoadHistory = FALSE;
            EnsureDeleteTransNavContext(ptnc);

            nf.DelayLoadHistory(Root());
        
            Assert(!_fNoUndoInfo );
            _fNoUndoInfo = TRUE;

            Notify(&nf);
            _fNoUndoInfo = FALSE;
        }
    }

    // Let the host know that parsing is done and they are free
    // to modify the document.

    if (_pDoc->_pClientSite && fIsPrimaryMarkup)
    {
        CTExec(_pDoc->_pClientSite, (GUID *)&CGID_MSHTML,
               IDM_PARSECOMPLETE, 0, NULL, NULL);
    }

    hr = THR(LoadSlaveMarkupHistory());
    if (hr)
        fComplete = TRUE;

    _fLoadHistoryReady = TRUE;

    if (HasWindow())
       Window()->Window()->_fRestartLoad = FALSE;

Cleanup:
    return fComplete;
}

//+-----------------------------------------------------------------------------
//
//  Member  : CDoc::DelegateNavigation
//
//  Synopsis: Delegates the navigation to shdocvw. This is done primarily
//            for non-html mime types.
//
//  Output  : pfDelegated - TRUE indicates that shdocvw handled the navigation.
//
//------------------------------------------------------------------------------

HRESULT 
CDoc::DelegateNavigation(HRESULT        hrBindResult,
                         const TCHAR  * pchUrl,
                         const TCHAR  * pchLocation,
                         CMarkup      * pMarkup,
                         CDwnBindInfo * pDwnBindInfo,
                         BOOL         * pfDelegated)
{
    HRESULT          hr = S_OK;
    CVariant         varFlags(VT_EMPTY);
    CDwnDoc        * pDwnDoc             = NULL;
    CVariant         cvarUrl(VT_BSTR);
    CDwnPost       * pDwnPost            = NULL;
    TCHAR          * pchHeader           = NULL;
    CVariant       * pvarPostData        = NULL;
    CVariant       * pvarHeader          = NULL;
    CVariant         varHeader(VT_BSTR);
    CVariant         varArray(VT_ARRAY);
    SAFEARRAY      * psaPostData         = NULL;
    BOOL             fDelegated          = FALSE;
    COmWindowProxy * pWindowPrxy         = pMarkup ? pMarkup->GetWindowPending() : NULL;
    CDwnPostStm    * pDwnPostStm         = NULL;
    char           * pBuffer             = NULL;
    
    Assert(!(pMarkup && (pchUrl || pDwnBindInfo)));

    if (pMarkup)
    {
        pMarkup->TerminateLookForBookmarkTask();

        pDwnDoc = pMarkup->GetDwnDoc();
        pDwnPost = pMarkup->GetDwnPost();
    }
    else if (pDwnBindInfo)
    {
        pDwnDoc = pDwnBindInfo->GetDwnDoc();
        pDwnPost = pDwnBindInfo->GetDwnPost();
    }

    if (pDwnDoc && (pDwnDoc->GetBindf() & BINDF_HYPERLINK))
    {
        V_VT(&varFlags) = VT_I4;
        V_I4(&varFlags) = navHyperlink;
    }

    if (pWindowPrxy && pWindowPrxy->Window()->_fRestricted)
    {
        V_VT(&varFlags) = VT_I4;
        V_I4(&varFlags) |= navEnforceRestricted;        
        if (pMarkup->GetDwnDoc()->GetDocIsXML())
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        
            
    }
    
    // This variable is initialized by a call to _pDoc->_fDelegatedDownload = FALSE;

    // Extract postdata and headers
    if (pDwnPost)
    {        
        // TODO (MohanB) Should pass header to Navigate2() even when there is no post data?
        //
        if (!pMarkup)
        {
            TCHAR   achNull[1];
            
            achNull[0] = 0;
            hr = THR(pDwnBindInfo->BeginningTransaction(pchUrl, achNull, 0, &pchHeader));
            if (hr)
                goto Cleanup;
        }
        
        V_BSTR(&varHeader) = SysAllocString(pMarkup ? pMarkup->GetDwnHeader() : pchHeader);
        if (NULL == V_BSTR(&varHeader))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        pvarHeader = &varHeader;

        pDwnPostStm = new CDwnPostStm(pDwnPost);
        if (!pDwnPostStm)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        DWORD dwBufferSize;
        hr = pDwnPostStm->ComputeSize(&dwBufferSize);
        if (hr)
        {
            goto Cleanup;
        }
     
        if (dwBufferSize != 0)
        {
            pBuffer = new(Mt(CDocDelegateNavigation_pBuffer)) char[dwBufferSize];        
            if (!pBuffer)
            {       
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }        
        
            DWORD dwBufferFilled = 0;
            hr = pDwnPostStm->Read(pBuffer, dwBufferSize, &dwBufferFilled);
            if (hr)
            {
                goto Cleanup;
            }

            Assert(dwBufferSize == dwBufferFilled);

            psaPostData = SafeArrayCreateVector(VT_UI1, 0, dwBufferSize);
            if (!psaPostData)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Assert(psaPostData->pvData);
            memcpy(psaPostData->pvData, pBuffer, dwBufferSize);

            V_ARRAY(&varArray) = psaPostData;
            pvarPostData = &varArray;        
        }
    }

    V_BSTR(&cvarUrl) = SysAllocString(pMarkup ? CMarkup::GetUrl(pMarkup) : pchUrl);
    if (NULL == V_BSTR(&cvarUrl))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (   pMarkup
        && pWindowPrxy
        && pWindowPrxy != _pWindowPrimary)
    {
        if (    pWindowPrxy->Window()->_pWindowParent
            ||  (pMarkup->Root()->HasMasterPtr() && hrBindResult == INET_E_TERMINATED_BIND))
        {
            // Note: If there is currently no ViewLinked WebOC releasing is still okay.

            pWindowPrxy->Window()->ReleaseViewLinkedWebOC();

            hr = pMarkup->ViewLinkWebOC(&cvarUrl, &varFlags, NULL, pvarPostData, pvarHeader);
            if (hr == S_OK)
            {
                fDelegated = TRUE;
            }
        }
    }
    else if (_pTopWebOC)
    {
        SetHostNavigation(TRUE);

        IBindCtx * pBindCtx = NULL;

        if (pWindowPrxy)
        {
            pBindCtx = pWindowPrxy->Window()->_pBindCtx;
        }

        hr = NavigateWebOCWithBindCtx(_pTopWebOC, &cvarUrl, &varFlags, NULL,
                                      pvarPostData, pvarHeader, pBindCtx,
                                      pchLocation ? pchLocation : CMarkup::GetUrlLocation(pMarkup));

        fDelegated = TRUE;
        _fDelegatedDownload = TRUE;
    }

Cleanup:
    if (pchHeader)
    {
        CoTaskMemFree(pchHeader);
    }

    if (pfDelegated)
    {
        *pfDelegated  = fDelegated;
    }

    if (pWindowPrxy)
    {
        ClearInterface(&pWindowPrxy->Window()->_pBindCtx);
    }

    if (psaPostData)
    {
        SafeArrayDestroy(psaPostData);  // CVariant won't destroy the safearray.
    }

    if (pDwnPostStm)
    {
        pDwnPostStm->Release();
    }
    
    if (pBuffer)
    {
        delete [] pBuffer;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusQuickDone
//
//  Synopsis:   Handles the LOADSTATUS_QUICK_DONE case for OnLoadStatus
//
//----------------------------------------------------------------------------

void 
CMarkup::OnLoadStatusQuickDone()
{
    CHtmlComponent *pComponent = NULL;
    CScriptCollection * pScriptCollection;

        // TODO (alexz) understand why is this necessary; might be a leftover to remove
    if (HasScriptContext())
    {
        ScriptContext()->_fScriptExecutionBlocked = FALSE;
    }

    IGNORE_HR(_pDoc->CommitDeferredScripts(FALSE, this));
    if (HasBehaviorContext())
    {
        pComponent = BehaviorContext()->_pHtmlComponent;
    }

    if (!pComponent || !pComponent->_fFactoryComponent)
        IGNORE_HR(_pDoc->CommitScripts(this));

    // JHarding: We should only do the SetState once we've finished parsing the frame
    if (!_fDesignMode && HasScriptCollection() )
    {
        pScriptCollection = GetScriptCollection();
        if (pScriptCollection)
            IGNORE_HR(pScriptCollection->SetState(SCRIPTSTATE_CONNECTED));
    }

    Assert(IsSplayValid());

#ifndef NO_DATABINDING
    SetDataBindingEnabled(TRUE);    // do any deferred databinding
#endif // ndef NO_DATABINDING

#if 0
    // CONSIDER (alexz) (1) _fSendDocEndParse can be on per tree basis
    //                  (2) this could be on per element basis, so to avoid full tree walk
    if (_pDoc->_fSendDocEndParse)
    {
        CNotification   nf;

        nf.DocEndParse(Root());
        _pDoc->BroadcastNotify(&nf);
    }
#endif
    IGNORE_HR( SendDocEndParse() );

    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();
        if (ptnc->_fGotHttpExpires)
        {
            ptnc->_fGotHttpExpires = FALSE;
            EnsureDeleteTransNavContext(ptnc);
        }
    }

    if (Document())
    {
        // Try to play the page transitions
        Document()->PlayPageTransitions();
    }

    if (   IsPrimaryMarkup()
        && _pDoc->_fPrintJobPending
        && Window())
    {
        _pDoc->_fPrintJobPending = FALSE;
        Window()->Window()->print();
    }
}

//+---------------------------------------------------------------------------
//
//  Member  :   CMarkup::OnLoadStatusDone
//
//  Synopsis:   Handles the LOADSTATUS_DONE case for OnLoadStatus
//
//  Return  : TRUE indicates that OnLoadStatus if complete and should not
//            continue processing.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::OnLoadStatusDone() 
{
    BOOL fComplete = FALSE;
    CHtmCtx * pHtmCtx = HtmCtx();
    
    if (Doc()->IsShut() || !pHtmCtx)
    {
        return TRUE;
    }

    if (   _pDoc->_pTridentSvc
        && _pDoc->_fIsActiveDesktopComponent
        && IsPrimaryMarkup() )
    {
        IGNORE_HR(_pDoc->_pTridentSvc->UpdateDesktopComponent(Window()));
    }

    // Transfer extended tag table ownership to markup
    //
    IGNORE_HR(pHtmCtx->TransferExtendedTagTable(this));

    CScriptCollection * pScriptCollection = GetScriptCollection();
    COmWindowProxy * pWindowPrxy = Window();            

    if (pScriptCollection)
        pScriptCollection->AddRef();

    CDwnDoc * pDwnDoc = GetDwnDoc();

    ShowWaitCursor(FALSE);    
    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal), 0);
    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }
    
    if (_pDoc->_pClientSite)
    {
        CTExec(_pDoc->_pClientSite, NULL, OLECMDID_HTTPEQUIV_DONE,
               0, NULL, NULL);
    }

    if (pWindowPrxy)
    {
        pWindowPrxy->Window()->StartMetaRefreshTimer();
    }

    // Unfreeze events now that document is fully loaded.
    {
        CNotification nf;
        
        nf.FreezeEvents(Root(), (void *)FALSE);
        Notify(&nf);
    }

    // MULTI_LAYOUT
    // If this root elem has a master ptr, our master might be a layout rect,
    // in which case this document is its content.  We need to notify the
    // containing layout rect so it can measure its view chain.
    // (Moved from CRootElement::Notify handling DOC_END_PARSE, which it wasn't
    // guaranteed to get.
    if ( Root()->HasMasterPtr() )
    {
        CElement *pMaster = Root()->GetMasterPtr();
        if ( pMaster->IsLinkedContentElement() )
        {
            pMaster->UpdateLinkedContentChain();
        }
    }

    SetReadyState(READYSTATE_COMPLETE);

    // Fire the DocumentComplete event. 
    //
    if (   !_fInRefresh
        && pWindowPrxy
        && !(_pDoc->_fHostNavigates && IsPrimaryMarkup()))
    {
#if DBG==1
        // This used to be an assert, changing to a trace tag for Whistler RC1. 
        if(pWindowPrxy->_pCWindow->_pMarkupPending)
        {
            TraceTag((tagPendingAssert, "OnLoadStatusDone: pending markup when none expected - this:[0x%x] pending markup:[0x%x]",
              this, pWindowPrxy->_pCWindow->_pMarkupPending));

        }
#endif

        // Don't fire the event if we are a ViewLinkedWebOC

        if (!pWindowPrxy->Window()->_punkViewLinkedWebOC)
        {
            _pDoc->_webOCEvents.DocumentComplete(pWindowPrxy, GetUrl(this), GetUrlLocation(this));
        }

        if (!HtmCtx() || pWindowPrxy->_pCWindow->_pMarkupPending)
        {
            // The window has been navigated away to a different markup. Leave
            // without firing any other events and without cleaning up the window
            // data (because that data now belongs to the new markup).
            //
            UpdateReleaseHtmCtx();
            fComplete = TRUE;

            goto Cleanup;
        }
    }

    _fInRefresh = FALSE;

    // [kusumav] We really should be checking the following before setting _fDontFireWebOCEvents since
    // we check before setting the flag in DoNavigate and CMarkup::LoadFromInfo. But since we also explicitly
    // check for these flags in the event firing functions where we use the _fDontFireWebOCEvents we are okay
    // See Windows bug 535312 for more info
    //
    // if (pWindowPrxy && !pWindowPrxy->Window()->_fCreateDocumentFromUrl  
    //     && !_pDoc->_fInObjectTag && !_pDoc->_fInHTMLDlg )
        _pDoc->_fDontFireWebOCEvents = FALSE;

    if (IsPrimaryMarkup())
    {
        _pDoc->_fDontUpdateTravelLog = FALSE;
    }
    
    if (IsPrimaryMarkup())
    {
        _pDoc->_fStartup       = FALSE;
        _pDoc->_fNewWindowInit = FALSE;
    }

    _fNewWindowLoading = FALSE;

    // Fire window onfocus() to start with, if we have the focus, after frameset
    // or body has become current as this will not be fired in BecomeCurrent()
    if ((_pDoc->_pElemCurrent == GetElementClient()) && 
        (::GetFocus() == _pDoc->_pInPlace->_hwnd))
    {
        if (pWindowPrxy && _pDoc->_state >= OS_UIACTIVE)
        {
            pWindowPrxy->Post_onfocus();
        }
    }

    if (pWindowPrxy)
    {
        pWindowPrxy->Window()->DetachOnloadEvent();
        pWindowPrxy->Window()->ClearWindowData();
    }

    // We have to get the HtmCtx again because another
    // navigation can occur in a handler for DocumentComplete.
    //
    pHtmCtx = HtmCtx();

    // Do not fire onload if we are not inplace & either scripting is
    // disabled or we are a dialog.
    //
    if ( _pDoc->State() >= OS_INPLACE                                          || 
        (   !(_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE)
         && !_pDoc->_fInHTMLDlg)                                                )
    {
        if (pWindowPrxy)
        {
            Assert(!pWindowPrxy->_pCWindow->_pMarkupPending);

            // Note that Netscape fires onunload later even if it hadn't fired onload
            Assert(!pWindowPrxy->_fFiredOnLoad);
            pWindowPrxy->_fFiredOnLoad = TRUE;
        }

        // 18849: fire onload only if load was not interrupted

        if (  pHtmCtx &&
            !(pHtmCtx->GetState() & (DWNLOAD_ERROR | DWNLOAD_STOPPED)))
        {
            // TODO (carled) this is temporary until we can fix the parser to allow
            // these events at enterTree time.
            // $$anandra This history and shortcut stuff needs to be reworked.  
            // trident should not know anything special about these behaviors.  
            CMarkupBehaviorContext * pContext = NULL;

            THR(EnsureBehaviorContext(&pContext));

            if ((pContext && pContext->_cstrHistoryUserData) || Doc()->_pShortcutUserData)
                FirePersistOnloads();

            if (pWindowPrxy)
            {
                // Report pending script errors 
                pWindowPrxy->Window()->HandlePendingScriptErrors(TRUE);

                Assert(pHtmCtx && GetProgSink());
                pWindowPrxy->Fire_onload();

                if (!pHtmCtx || !GetProgSink())
                {
                    // This markup has been unloaded and passivated during onload event
                    // processing. Cleanup and leave.         
                    //
                    fComplete = TRUE;
                    goto Cleanup;
                }
            }
        }

        // Let the client site know we are loaded
        // Only HTMLDialog pays attention to this
        if (pWindowPrxy && _pDoc->_pClientSite && _pDoc->_fInHTMLDlg)
        {
            CTExec(_pDoc->_pClientSite, &CLSID_HTMLDialog,
                   0, 0, NULL, NULL);
        }
    }

    if (Document() && Document()->HasPageTransitionInfo())
    {
        // make sure we will execute the page-exit for the next navigation
        Document()->GetPageTransitionInfo()->ShiftTransitionStrings();
    }

    if (!_fDesignMode)
    {
        // $$anandra Fix me
        CElement * pElemDefault = _pDoc->_pElemCurrent ?
                                  _pDoc->_pElemCurrent->FindDefaultElem(TRUE) : 0;
        if (pElemDefault)
        {
            CNotification nf;

            nf.AmbientPropChange(pElemDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
            pElemDefault->_fDefault = TRUE;
            pElemDefault->Notify(&nf);
        } 
    }
    else
    {
        //
        // We may have been flipped from edit to browse back to edit.
        // In which case the _fShowZeroBorder Bit is correctly set,
        // but we need to fire a notification through the document to 
        // let everyone know.
        //
        if (IsShowZeroBorderAtDesignTime())
        {
            CNotification nf;
            nf.ZeroGrayChange(GetElementTop());
            Notify(&nf);
        } 
    }
    
    // From now on, new downloads don't follow the refresh binding
    // flags used to load the document.
    // $$anandra fixme.  
    if (pDwnDoc)
        pDwnDoc->SetBindf(pDwnDoc->GetBindf() &
        ~(BINDF_RESYNCHRONIZE|BINDF_GETNEWESTVERSION|
            BINDF_PRAGMA_NO_CACHE));

    // If the document was loaded due to an http 449 status code, we need to kick off a refresh
    // now that we're done loading

    if (pHtmCtx && pHtmCtx->IsHttp449())
    {
        IGNORE_HR(GWPostMethodCall(Window(),
                                   ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                   OLECMDIDF_REFRESH_NORMAL | OLECMDIDF_REFRESH_CLEARUSERINPUT,
                                   FALSE, "COmWindowProxy::ExecRefreshCallback"));
    }

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDocBytesRead))
    {
        VARIANT vt;
        _pDoc->ExecHelper(pWindowPrxy ? pWindowPrxy->Document() : NULL, (GUID *)&CGID_MSHTML, IDM_GETBYTESDOWNLOADED,
            MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &vt);
        Assert(pDwnDoc->GetBytesRead() == (DWORD)vt.lVal);
        PerfDbgLog1(tagDocBytesRead, this, "CDoc::OnLoadStatus (%ld bytes downloaded)", vt.lVal);
    }
#endif

    if (g_pHtmPerfCtl && 
        (g_pHtmPerfCtl->dwFlags &
         (HTMPF_CALLBACK_ONLOAD|HTMPF_CALLBACK_ONLOAD2
#ifndef NO_ETW_TRACING
          |HTMPF_CALLBACK_ONEVENT
#endif
          )) && 
        IsPrimaryMarkup())
    {
#ifndef NO_ETW_TRACING
        // Send event to ETW if it is enabled by the shell.
        // We do NOT want to do a WaitForRecalc.
        if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT) {
            g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_LOADEDPARSED,
                                   (TCHAR *)GetUrl(this));
        }
        else {
#endif
            // We shouldn't calc a print doc at this point because our view isn't initialized yet (42603).
            if (!_pDoc->IsPrintDialogNoUI())
                _pDoc->WaitForRecalc(this);
            
            if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONLOAD)
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONLOAD, (TCHAR *)GetUrl(this));
            
            if (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONLOAD2)
                g_pHtmPerfCtl->pfnCall(HTMPF_CALLBACK_ONLOAD, (IUnknown*)(IPrivateUnknown*)_pDoc);
#ifndef NO_ETW_TRACING
        }
#endif
    }


    // Display the error page if this was a frame
    // and the src URL was not found.
    //
    if (pWindowPrxy && pHtmCtx && !(HasBehaviorContext() && BehaviorContext()->_pHtmlComponent))
    {
        HRESULT hrBindResult = pHtmCtx->GetBindResult();

        if (E_ABORT == hrBindResult || ! IsPrimaryMarkup())
        {
            if (    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrBindResult
                ||  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hrBindResult
                ||  (E_ABORT == hrBindResult && !_fStopDone))
            {
                _pDoc->_fDontUpdateTravelLog = TRUE;
                DoAutoSearch(hrBindResult, pWindowPrxy->_pWindow);
            }
        }
    }

    // release HtmCtx if it is no longer used
    UpdateReleaseHtmCtx();

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();

    return fComplete;
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::DoAutoSearch()
//
//  Synopsis : In the case of a binding error, this method will perform an
//             autosearch for the top-level window. In the case of an HTTP
//             error (e.g., 404) an error page will be displayed. The error
//             page will be displayed for the top-level and frame windows.
//
//----------------------------------------------------------------------------


void
CMarkup::DoAutoSearch(HRESULT        hrReason,
                      IHTMLWindow2 * pHTMLWindow,
                      IBinding     * pBinding /* = NULL */)
{
    long        lIdx = 0;
    HRESULT     hr;
    CVariant    cvarTemp(VT_I4);
    CVariant    cvarargIn(VT_ARRAY);
    CVariant    cvargOut(VT_BOOL);
    SAFEARRAY * psaNavData = NULL;
    SAFEARRAYBOUND sabound;

    Assert(hrReason);
    Assert(pHTMLWindow);

    sabound.cElements = 6;
    sabound.lLbound   = 0;

    psaNavData = SafeArrayCreate(VT_VARIANT, 1, &sabound);
    if (!psaNavData)
        goto Cleanup;

    // 0) hrReason
    //
    V_I4(&cvarTemp) = hrReason;

    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 1) URL
    //
    V_VT(&cvarTemp)   = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(CMarkup::GetUrl(this));

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // Binding
    if (pBinding)
    {
        V_VT(&cvarTemp) = VT_UNKNOWN;
    
        hr = THR(pBinding->QueryInterface(IID_IUnknown,
                                          (void**)&V_UNKNOWN(&cvarTemp)));
        if (hr)
            goto Cleanup;
    }

    // 2) Add the binding to the safearray even if it is NULL.
    //
    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 3) IHTMLWindow2 of the current window.
    //
    V_VT(&cvarTemp)      = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pHTMLWindow;
    V_UNKNOWN(&cvarTemp)->AddRef();

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();

    // 4) Do autosearch or show error page only.
    // If _fShdocvwNavigate is TRUE, we will attempt to 
    // do an autosearch. Otherwise, we will just display
    // the HTTP error page.
    //
    V_VT(&cvarTemp)   = VT_BOOL;
    V_BOOL(&cvarTemp) = _pDoc->_fShdocvwNavigate ? VARIANT_TRUE : VARIANT_FALSE;

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    //
    // 5) Propagate _fInRefresh Flag
    //
    cvarTemp.Clear();
    V_VT(&cvarTemp)   = VT_BOOL;
    V_BOOL(&cvarTemp) = _fInRefresh ? VARIANT_TRUE : VARIANT_FALSE;

    lIdx++;
    hr = SafeArrayPutElement(psaNavData, &lIdx, &cvarTemp);
    if (hr)
        goto Cleanup;

    V_ARRAY(&cvarargIn) = psaNavData;

    if (hrReason >= HTTP_STATUS_BAD_REQUEST && hrReason <= HTTP_STATUS_LAST)
    {
        Assert(GetWindowPending());
        CWindow * pCWindow = GetWindowPending()->Window();

        Assert(pCWindow);

        pCWindow->_fHttpErrorPage = TRUE;

        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NAVIGATION_ERROR, NULL, &cvarargIn, & cvargOut ));

        if ( (V_VT(&cvargOut) == VT_BOOL) && (V_BOOL(&cvargOut) == VARIANT_FALSE ) )
        {
            //
            // shdocvw did not delegate back to us
            // dont' update the travel log.
            //
            _pDoc->_fDontUpdateTravelLog = TRUE;
        }
    } 
    else
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NAVIGATION_ERROR, NULL, &cvarargIn, NULL));
    }

Cleanup:
    if (psaNavData)
    {
        SafeArrayDestroy(psaNavData);  // CVariant won't destroy the safearray.
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::ResetSearchInfo()
//
//  Synopsis : Called upon a successful navigation, this code notifies the browser
//             that the search information should be reset.
//
//----------------------------------------------------------------------------

void
CMarkup::ResetSearchInfo( )
{
    if (_pDoc && _pDoc->_pClientSite)
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_RESETSEARCHINFO, NULL, NULL, NULL));
    }
}

//+---------------------------------------------------------------------------
//
//  Member   : CMarkup::NoteErrorWebPage()
//
//  Synopsis : If a navigation is about to fail and display either the server's
//             or the friendly error page, tell shdocvw to avoid adding the entry
//             to history
//
//----------------------------------------------------------------------------

void
CMarkup::NoteErrorWebPage( )
{
    if (_pDoc && _pDoc->_pClientSite)
    {
        IGNORE_HR(CTExec(_pDoc->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_NOTE_ERROR_PAGE, NULL, NULL, NULL));
    }
}

//+-------------------------------------------------------------------
//
//  Member:     EnsureTitle
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnsureTitle ( )
{
    HRESULT hr = S_OK;
    CElement *  pElementTitle = NULL;

    if (!GetTitleElement())
    {
        if (!GetHeadElement())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( CreateElement( ETAG_TITLE_ELEMENT, & pElementTitle ) );

        if (hr)
            goto Cleanup;
        
        // TODO: watch how this might interfere with the parser!
        hr = THR( AddHeadElement( pElementTitle ) );

        if (hr)
            goto Cleanup;
    }
    
Cleanup:

    CElement::ClearPtr( & pElementTitle );
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::AddHeadElement
//
//  Synopsis:   Stores and addrefs element in HEAD.
//              Also picks out first TITLE element...
//
//--------------------------------------------------------------------

HRESULT
CMarkup::AddHeadElement ( CElement * pElement, long lIndex )
{
    HRESULT hr = S_OK;

    Assert( GetHeadElement() );

    if (lIndex >= 0)
    {
        CTreeNode * pNodeIter;
        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP );

        while ( (pNodeIter = ci.NextChild()) != NULL )
        {
            if (lIndex-- == 0)
            {
                hr = THR(
                    pNodeIter->Element()->InsertAdjacent(
                        CElement::BeforeBegin, pElement ) );

                if (hr)
                    goto Cleanup;

                goto Cleanup;
            }
        }
    }

    // If the parser is still in the head while we are trying
    // to insert an element in the head, make sure we don't insert it in
    // front of the parser's frontier.
    
    if (_pRootParseCtx)
    {
        CTreePosGap tpgFrontier;

        if (_pRootParseCtx->SetGapToFrontier( & tpgFrontier ) 
            && tpgFrontier.Branch()->SearchBranchToRootForScope( GetHeadElement() ))
        {
            CMarkupPointer mp ( Doc() );

            hr = THR( mp.MoveToGap( & tpgFrontier, this ) );

            if (hr)
                goto Cleanup;

            hr = THR( Doc()->InsertElement( pElement, & mp, NULL ) );

            if (hr)
                goto Cleanup;

            goto Cleanup;
        }
    }

    hr = THR(
        GetHeadElement()->InsertAdjacent(
            CElement::BeforeEnd, pElement ) );

    if (hr)
        goto Cleanup;
    
Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     CMarkup::SetXML
//
//  Synopsis:   Treats unqualified tags as xtags.
//
//---------------------------------------------------------------
void
CMarkup::SetXML(BOOL flag)
{
    // pass down to the parser if it is live    
    _fXML = flag ? 1 : 0;
    if (_pHtmCtx)
        _pHtmCtx->SetGenericParse(_fXML);
}

BOOL
CMarkup::IsActiveDesktopComponent()
{
    CDoc * pDoc = Doc();

    if (    pDoc
        &&  pDoc->_fActiveDesktop
        &&  pDoc->_pClientSite )
    {
        IServiceProvider * pSP = NULL;
        HRESULT hr;

        hr = pDoc->_pClientSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);

        if (!hr && pSP)
        {        
            void * pv;
            
            hr = pSP->QueryService(CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, &pv);
            pSP->Release();

            if (hr)     // it should fails in shell32
            {
                COmWindowProxy * pOmWindowProxy = _fWindowPending ? GetWindowPending()
                                                                  : Window();

                if (    pOmWindowProxy
                    &&  pOmWindowProxy->Window()->_pWindowParent
                    &&  pOmWindowProxy->Window()->_pWindowParent->IsPrimaryWindow())
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CMarkup::PasteClipboard
//
//  Synopsis:   Manage paste from clipboard
//
//---------------------------------------------------------------

HRESULT
CMarkup::PasteClipboard()
{
    HRESULT          hr;
    IDataObject    * pDataObj   = NULL;
    CCurs            curs(IDC_WAIT);
    CLock            Lock(this);
    
    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    hr = THR(AllowPaste(pDataObj));
    if (hr)
        goto Cleanup;


Cleanup:
    ReleaseInterface( pDataObj );

    if (hr)
    {
        ClearErrorInfo();
        PutErrorInfoText(EPART_ACTION, IDS_EA_PASTE_CONTROL);
        CloseErrorInfo(hr);
    }

    RRETURN(hr);
}

#ifdef UNIX_NOTYET
/*
 *  CMarkup::PasteUnixQuickTextToRange
 *
 *  @mfunc  Freeze display and paste object
 *
 *  @rdesc  HRESULT from IDataTransferEngine::PasteMotifTextToRange
 *
 */

HRESULT 
CMarkup::PasteUnixQuickTextToRange(
    CTxtRange *prg,
    VARIANTARG *pvarTextHandle
    )
{
    HRESULT      hr;

    {
        CLightDTEngine ldte( this );

        hr = THR(ldte.PasteUnixQuickTextToRange(prg, pvarTextHandle));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
#endif // UNIX

void 
CMarkup::SetModified ( void )
{
    // Tell the form
    Doc()->OnDataChange();
}

//+-------------------------------------------------------------------------
//
//  Method:     createTextRange
//
//  Synopsis:   Get an automation range for the entire document
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::createTextRange( IHTMLTxtRange * * ppDisp, CElement * pElemContainer )
{
    HRESULT hr = S_OK;

    hr = THR(createTextRange(ppDisp, pElemContainer, NULL, NULL, TRUE));

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     createTextRange
//
//  Synopsis:   Get an automation range for the entire document
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::createTextRange( 
    IHTMLTxtRange * * ppDisp, 
    CElement * pElemContainer, 
    IMarkupPointer *pLeft, 
    IMarkupPointer *pRight,
    BOOL fAdjustPointers)
{
    HRESULT hr = S_OK;
    CAutoRange * pAutoRange = NULL;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pAutoRange = new CAutoRange( this, pElemContainer );

    if (!pAutoRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the lookaside entry for this range
    pAutoRange->SetNext( DelTextRangeListPtr() );
    hr = THR( SetTextRangeListPtr( pAutoRange ) );
    if (hr)
        goto Cleanup;

    hr = THR( pAutoRange->Init() );
    if (hr)
        goto Cleanup;

    if (pLeft && pRight)
    {
        hr = THR_NOTRACE( pAutoRange->SetLeftAndRight(pLeft, pRight, fAdjustPointers) );
    }
    else
    {
        hr = THR_NOTRACE( pAutoRange->SetTextRangeToElement( pElemContainer ) );
    }

    Assert( hr != S_FALSE );

    if (hr)
        goto Cleanup;

    *ppDisp = pAutoRange;
    pAutoRange->AddRef();
  
Cleanup:
    if (pAutoRange)
    {
        pAutoRange->Release();
    }
    RRETURN( SetErrorInfo( hr ) );
}




//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::AcceptingUndo
//
//  Synopsis:   Tell the PedUndo if we're taking any changes.
//
//--------------------------------------------------------------------------

BOOL
CMarkup::AcceptingUndo()
{
    return      !_fNoUndoInfo;
//            &&  IsEditable()
}

//+-------------------------------------------------------------------------
//
// IMarkupContainer Method Implementations
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::OwningDoc( IHTMLDocument2 * * ppDoc )
{
    return _pDoc->PrimaryMarkup()->QueryInterface( IID_IHTMLDocument2, (void **) ppDoc );
}

HRESULT 
CMarkup::AddSegment( 
    IDisplayPointer* pIStart, 
    IDisplayPointer* pIEnd,
    IHTMLRenderStyle* pIRenderStyle,
    IHighlightSegment **ppISegment )  
{
    HRESULT hr  = EnsureSelRenSvc();

    if ( !hr )
        hr = _pHighlightRenSvcProvider->AddSegment( pIStart, pIEnd, pIRenderStyle, ppISegment);

    RRETURN ( hr );            
}

HRESULT 
CMarkup::MoveSegmentToPointers( 
    IHighlightSegment *pISegment,
    IDisplayPointer* pDispStart, 
    IDisplayPointer* pDispEnd )  
{
    HRESULT hr = EnsureSelRenSvc();

    if ( !hr )
         hr = _pHighlightRenSvcProvider->MoveSegmentToPointers(pISegment, pDispStart, pDispEnd ) ;

    RRETURN ( hr );        
}    
    
HRESULT 
CMarkup::RemoveSegment( IHighlightSegment *pISegment )
{
    if ( _pHighlightRenSvcProvider)
        RRETURN ( _pHighlightRenSvcProvider->RemoveSegment( pISegment ) );
    else
        return S_OK;
}

HRESULT
CMarkup::EnsureSelRenSvc()
{
    if ( ! _pHighlightRenSvcProvider )
        _pHighlightRenSvcProvider = new CSelectionRenderingServiceProvider( Doc() , this   );
    if ( ! _pHighlightRenSvcProvider )
        return E_OUTOFMEMORY;
    return S_OK;        
}

//+==============================================================================
// 
// Method: GetSelectionChunksForLayout
//
// Synopsis: Get the 'chunks" for a given Flow Layout, as well as the Max and Min Cp's of the chunks
//              
//            A 'chunk' is a part of a SelectionSegment, broken by FlowLayout
//
//-------------------------------------------------------------------------------

VOID
CMarkup::GetSelectionChunksForLayout( 
    CFlowLayout* pFlowLayout, 
    CRenderInfo *pRI,
    CDataAry<HighlightSegment> *paryHighlight, 
    int* piCpMin, 
    int * piCpMax )
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->GetSelectionChunksForLayout( pFlowLayout, pRI, paryHighlight, piCpMin, piCpMax );
    }
    else
    {
        Assert( piCpMax );
        *piCpMax = -1;
    }    
}

VOID
CMarkup::HideSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->HideSelection();
    }
}

VOID
CMarkup::ShowSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->ShowSelection();
    }
}


VOID
CMarkup::InvalidateSelection()
{
    if ( _pHighlightRenSvcProvider )
    {
        _pHighlightRenSvcProvider->InvalidateSelection( TRUE );
    }
}


CElement *
CMarkup::GetElementTop()
{
    CElement * pElement = GetElementClient();

    return pElement ? pElement : Root();
}

CElement *
CMarkup::GetCanvasElementHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetCanvasElement() : NULL;
}


CElement *
CMarkup::GetHtmlElementHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetHtmlElement() : NULL;
}

CElement *
CMarkup::GetElementClientHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetElementClient() : NULL;
}

CElement *
CMarkup::GetElementTopHelper(CMarkup * pMarkup)
{
    return pMarkup ? pMarkup->GetElementTop() : NULL;
}

IProgSink *
CMarkup::GetProgSinkHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->GetProgSink() : NULL);
}

CProgSink *
CMarkup::GetProgSinkCHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->GetProgSinkC() : NULL);
}

CHtmCtx *
CMarkup::HtmCtxHelper(CMarkup * pMarkup)
{
    return(pMarkup ? pMarkup->HtmCtx() : NULL);
}

void
CMarkup::EnsureTopElems ( )
{
    CElement  *     pHtmlElementCached;
    CHeadElement  * pHeadElementCached;
    CTitleElement * pTitleElementCached;
    CElement *      pElementClientCached;
    
    if (GetMarkupTreeVersion() == _lTopElemsVersion
        || !Root())
        return;

    _lTopElemsVersion = GetMarkupTreeVersion();

    static ELEMENT_TAG  atagStop[2] = { ETAG_BODY, ETAG_FRAMESET };
    
    CChildIterator ci(
        Root(), 
        NULL,
        CHILDITERATOR_USETAGS,
        atagStop, ARRAY_SIZE(atagStop));
    int nFound = 0;
    
    CTreeNode * pNode;

    pHtmlElementCached = NULL;
    pHeadElementCached = NULL;
    pTitleElementCached = NULL;
    pElementClientCached = NULL;
    
    while ( nFound < 4 && (pNode = ci.NextChild()) != NULL )
    {
        CElement * pElement = pNode->Element();
        
        switch ( pElement->Tag() )
        {
            case ETAG_HEAD  :
            {
                if (!pHeadElementCached)
                {
                    pHeadElementCached = DYNCAST( CHeadElement, pElement );
                    nFound++;
                }
                
                break;
            }
            case ETAG_TITLE_ELEMENT :
            {
                if (!pTitleElementCached)
                {
                    pTitleElementCached = DYNCAST( CTitleElement, pElement );
                    nFound++;
                }
                
                break;
            }

            case ETAG_HTML  :
            {
                if (!pHtmlElementCached)
                {
                    pHtmlElementCached = pElement;
                    nFound++;
                }
                
                break;
            }
            case ETAG_BODY :
            case ETAG_FRAMESET :
            {
                if (!pElementClientCached)
                {
                    pElementClientCached = pElement;
                    nFound++;
                }
                
                break;
            }
        }
    }

    if (nFound)
    {
        CMarkupTopElemCache * ptec = EnsureTopElemCache();

        if (ptec)
        {
            ptec->__pHtmlElementCached = pHtmlElementCached;
            ptec->__pHeadElementCached = pHeadElementCached;
            ptec->__pTitleElementCached = pTitleElementCached;
            ptec->__pElementClientCached = pElementClientCached;
        }
    }
    else
    {
        delete DelTopElemCache();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::DoesPersistMetaAllow
//
//  Synopsis:   the perist Metatags can enable/disable sets of controls
//      and objects.  This helper function will look for the given
//      element ID and try to determin if the meta tags allow or restrict
//      its default operation (wrt persistence)
//
//--------------------------------------------------------------------

BOOL
CMarkup::MetaPersistEnabled(long eState)
{
    CTreeNode * pNode;

    // search through the list of meta tags for one that would activate
    // the persistData objects

    if (!eState || !GetHeadElement())
        return FALSE;

    CChildIterator ci ( GetHeadElement() );

    while ( (pNode = ci.NextChild()) != NULL )
    {
        if (pNode->Tag() == ETAG_META )
        {
            if (DYNCAST( CMetaElement, pNode->Element() )->IsPersistMeta( eState ))
                return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsThemeEnabled
//
//  returns:
//
//      1 : Theme
//      0 :
//     -1 :
//
// always use this table and check with PM
//
// +--------------------------------------------------------------------------+
// |                App not themed |     App Themed                           |
// +-------------------------------+--------------+---------------+-----------+
// |          Never Themed         | DOCUIFLAG on | DOCUIFLAG off | default   |
// +----------+--------------------+--------------+---------------+-----------+
// | Meta on  |                    |   Themed     |   not Themed  | Themed    |
// +----------+--------------------+--------------+---------------+-----------+
// | Meta off |                    |   not Themed |   not Themed  | not Themed|
// +----------+--------------------+--------------+---------------+-----------+
// | no Meta  |                    |   Themed     |   not Themed  | default   |
// +----------+--------------------+--------------+---------------+-----------+
//
//  Synopsis:   
//              look for a Theme meta
//--------------------------------------------------------------------

THEME_USAGE
CMarkup::GetThemeUsage()
{
    CTreeNode * pNode;

    if (!g_fThemedPlatform)
        return THEME_USAGE_OFF;
    
    CMarkupEditContext *pEditCtx = GetEditContext();

    if (!pEditCtx)
    {
        pEditCtx = EnsureEditContext();
        if (!pEditCtx)
            return THEME_USAGE_OFF;
    }

    if (pEditCtx->_fThemeDetermined)
        goto Cleanup;

    pEditCtx->_fThemeDetermined = TRUE;

    // Turn themes off for non-themed apps

    if (!IsAppThemed())
    {
        pEditCtx->_eThemed = THEME_USAGE_OFF;
        goto Cleanup;
    }

    //Look at DOCHOSTUI flags first

    // DOCHOSTUIFLAG_NOTHEME has highest precedence - always turns themes OFF

    if (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOTHEME)
    {
        pEditCtx->_eThemed = THEME_USAGE_OFF;
        goto Cleanup;
    }
    
    // Turn themes ON for DOCHOSTUIFLAG_THEME - will be turned off by META if exists

    if (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_THEME)
    {
        pEditCtx->_eThemed = THEME_USAGE_ON;
    }

    // look at inetcpl if no DOCHOSTUIFLAG settings

    if ( !(_pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_NOTHEME | DOCHOSTUIFLAG_THEME)) )
    {
        if ( _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fUseThemes)
        {
            // turn themes ON
            pEditCtx->_eThemed = THEME_USAGE_ON;
        }
        else
        {
            // no settings by host and inetcpl is non-themed -> set themes to DEFAULT
            // will be overridden by META if exists
            pEditCtx->_eThemed = THEME_USAGE_DEFAULT;
        }
    }

    // Look at the META tag - we can only get here if DOCHOSTUIFLAG_THEME or default
    // META OFF -> turns off themes completelly
    // META ON  -> turns themes on
    // No META  -> for DOCHOSTUIFLAG_THEME they are already THEME_USAGE_ON, for "default" they are THEME_USAGE_DEFAULT

    if (GetHeadElement())
    {
        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP);

        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META )
            {
                switch (DYNCAST(CMetaElement,pNode->Element())->TestThemeMeta())
                {
                case 1 :
                    pEditCtx->_eThemed = THEME_USAGE_ON;
                    goto Cleanup;
                case 0 :
                    pEditCtx->_eThemed = THEME_USAGE_OFF;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    return pEditCtx->_eThemed;
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::LocateHeadMeta
//
//  Synopsis:   Look for a particular type of meta tag in the head
//
//--------------------------------------------------------------------

HRESULT
CMarkup::LocateHeadMeta (
    BOOL ( * pfnCompare ) ( CMetaElement * ), CMetaElement * * ppMeta )
{
    HRESULT hr = S_OK;
    CTreeNode * pNode;

    Assert( ppMeta );

    *ppMeta = NULL;

    if (GetHeadElement())
    {
        //
        // Attempt to locate an existing meta tag associated with the
        // head (we will not look for meta tags in the rest of the doc).
        //

        CChildIterator ci ( GetHeadElement(), NULL, CHILDITERATOR_DEEP );

        while ( (pNode = ci.NextChild()) != NULL )
        {
            if (pNode->Tag() == ETAG_META)
            {
                *ppMeta = DYNCAST( CMetaElement, pNode->Element() );

                if (pfnCompare( *ppMeta ))
                    break;

                *ppMeta = NULL;
            }
        }
    }
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CRootSite::LocateOrCreateHeadMeta
//
//  Synopsis:   Locate a
//
//--------------------------------------------------------------------

HRESULT
CMarkup::LocateOrCreateHeadMeta (
    BOOL ( * pfnCompare ) ( CMetaElement * ),
    CMetaElement * * ppMeta,
    BOOL fInsertAtEnd )
{
    HRESULT hr;
    CElement *pTempElement = NULL;

    Assert( ppMeta );

    //
    // First try to find one
    //

    *ppMeta = NULL;

    hr = THR(LocateHeadMeta(pfnCompare, ppMeta));
    if (hr)
        goto Cleanup;

    //
    // If we could not locate an existing element, make a new one
    //
    // _pElementHEAD can be null if we are doing a doc.open on a
    // partially created document.(pending navigation scenario)
    //

    if (!*ppMeta && GetHeadElement())
    {
        long lIndex = -1;

        if (_LoadStatus < LOADSTATUS_PARSE_DONE)
        {
            // Do not add create a meta element if we have not finished
            // parsing.
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR( CreateElement( ETAG_META, & pTempElement ) );

        if (hr)
            goto Cleanup;

        * ppMeta = DYNCAST( CMetaElement, pTempElement );
        
        Assert( * ppMeta );

        if (!fInsertAtEnd)
        {
            lIndex = 0;

            //
            // Should not insert stuff before the title
            //

            if (GetTitleElement() &&
                GetTitleElement()->GetFirstBranch()->Parent() &&
                GetTitleElement()->GetFirstBranch()->Parent()->Element() == GetHeadElement())
            {
                lIndex = 1;
            }
        }
            
        hr = THR( AddHeadElement( pTempElement, lIndex ) );
        
        if (hr)
            goto Cleanup;
    }

Cleanup:
    
    CElement::ClearPtr( & pTempElement );

    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::GetProgSinkC
//
//--------------------------------------------------------------------

CProgSink *
CMarkup::GetProgSinkC()
{
    return _pProgSink;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::GetProgSink
//
//--------------------------------------------------------------------

IProgSink *
CMarkup::GetProgSink()
{
    return (IProgSink*) _pProgSink;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsEditable
//
//--------------------------------------------------------------------

BOOL        
CMarkup::IsEditable() const
{
    return _fDesignMode;
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CMarkup::GetLookasidePtr(int iPtr)
{
#if DBG == 1
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CMarkup::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CMarkup::DelLookasidePtr(int iPtr)
{
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

//
// CMarkup ref counting helpers
//

void
CMarkup::ReplacePtr ( CMarkup * * pplhs, CMarkup * prhs )
{
    if (pplhs)
    {
        CMarkup * plhsLocal = *pplhs;
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
        if (plhsLocal)
        {
            plhsLocal->Release();
        }
    }
}

void
CMarkup::SetPtr ( CMarkup ** pplhs, CMarkup * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
    }
}

void
CMarkup::StealPtrSet ( CMarkup ** pplhs, CMarkup * prhs )
{
    SetPtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CMarkup::StealPtrReplace ( CMarkup ** pplhs, CMarkup * prhs )
{
    ReplacePtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CMarkup::ClearPtr ( CMarkup * * pplhs )
{
    if (pplhs && * pplhs)
    {
        CMarkup * pElement = *pplhs;
        *pplhs = NULL;
        pElement->Release();
    }
}

void
CMarkup::ReleasePtr ( CMarkup * pMarkup )
{
    if (pMarkup)
    {
        pMarkup->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Log Manager for TreeSync and Undo
//
//+---------------------------------------------------------------------------
CLogManager *
CMarkup::EnsureLogManager()
{
    CMarkupChangeNotificationContext * pcnc;

    pcnc = EnsureChangeNotificationContext();

    if (!pcnc)
        return NULL;

    if (!pcnc->_pLogManager)
        pcnc->_pLogManager = new CLogManager( this );

    return pcnc->_pLogManager;
}

BOOL                        
CMarkup::HasLogManagerImpl()
{
    Assert( HasChangeNotificationContext() );

    CMarkupChangeNotificationContext * pcnc;

    pcnc = GetChangeNotificationContext();

    return !!pcnc->_pLogManager;
}

CLogManager *   
CMarkup::GetLogManager()
{
    if( HasChangeNotificationContext() )
    {
        CMarkupChangeNotificationContext * pcnc;

        pcnc = GetChangeNotificationContext();

        return pcnc->_pLogManager;
    }
    else
        return NULL;
}

//+---------------------------------------------------------------------------
//
//  Top Elem Cache
//
//----------------------------------------------------------------------------

CMarkupTopElemCache * 
CMarkup::EnsureTopElemCache()
{
    CMarkupTopElemCache * ptec;

    if (HasTopElemCache())
        return GetTopElemCache();

    ptec = new CMarkupTopElemCache;
    if (!ptec)
        return NULL;

    if (SetTopElemCache( ptec ))
    {
        delete ptec;
        return NULL;
    }

    return ptec;
}

//+---------------------------------------------------------------------------
//
//  Transient Navigation Context
//
//----------------------------------------------------------------------------

CMarkupTransNavContext *    
CMarkup::EnsureTransNavContext()
{
    CMarkupTransNavContext * ptnc;

    if (HasTransNavContext())
        return GetTransNavContext();

    ptnc = new CMarkupTransNavContext;
    if (!ptnc)
        return NULL;

    if (SetTransNavContext( ptnc ))
    {
        delete ptnc;
        return NULL;
    }

    return ptnc;
}

void
CMarkup::EnsureDeleteTransNavContext( CMarkupTransNavContext * ptnc )
{
    Assert(HasTransNavContext() && ptnc == GetTransNavContext());

    if(     !ptnc->_pTaskLookForBookmark 
       &&   ptnc->_historyCurElem.lIndex == -1L
       &&   !ptnc->_HistoryLoadCtx.HasData()
       &&   !ptnc->_dwHistoryIndex
       &&   !ptnc->_dwFlags
       &&   !ptnc->_pctPics)
    {
        delete DelTransNavContext();
    }
}

//+---------------------------------------------------------------------------
//
//  Stuff for CComputeFormatState (for psuedo first letter/line elements)
//
//----------------------------------------------------------------------------

CComputeFormatState *    
CMarkup::EnsureCFState()
{
    CComputeFormatState * pcfState;

    if (HasCFState())
        return GetCFState();

    pcfState = new CComputeFormatState;
    if (!pcfState)
        return NULL;

    if (S_OK != AddPointer( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                            (void *) pcfState, 
                            CAttrValue::AA_Internal ))
    {
        delete pcfState;
        return NULL;
    }

    _fHasCFState = TRUE;

    return pcfState;
}

void                     
CMarkup::EnsureDeleteCFState( CComputeFormatState * pcfState )
{
    Assert(HasCFState() && pcfState == GetCFState());

    if(pcfState->IsReset())
    {
        AAINDEX aaIdx = FindAAIndex( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                                     CAttrValue::AA_Internal );
        DeleteAt( aaIdx );
        delete pcfState;

        _fHasCFState = FALSE;
    }
}

CComputeFormatState *    
CMarkup::GetCFState()
{
    CComputeFormatState * pcfState = NULL;
    GetPointerAt( FindAAIndex( DISPID_INTERNAL_COMPUTEFORMATSTATECACHE, 
                               CAttrValue::AA_Internal ),
                  (void **) &pcfState );
    return pcfState;
}

//+---------------------------------------------------------------------------
//
//  Text Frag Service
//
//----------------------------------------------------------------------------

CMarkupTextFragContext * 
CMarkup::EnsureTextFragContext()
{
    CMarkupTextFragContext *    ptfc;

    if (HasTextFragContext())
        return GetTextFragContext();

    ptfc = new CMarkupTextFragContext;
    if (!ptfc)
        return NULL;

    if (SetTextFragContext( ptfc ))
    {
        delete ptfc;
        return NULL;
    }

    return ptfc;
}

CMarkupTextFragContext::~CMarkupTextFragContext()
{
    int cFrag;
    MarkupTextFrag * ptf;

    for( cFrag = _aryMarkupTextFrag.Size(), ptf = _aryMarkupTextFrag; cFrag > 0; cFrag--, ptf++ )
    {
        MemFreeString( ptf->_pchTextFrag );
    }
}

HRESULT     
CMarkupTextFragContext::AddTextFrag( CTreePos * ptpTextFrag, TCHAR* pchTextFrag, ULONG cchTextFrag, long iTextFrag )
{
    HRESULT             hr = S_OK;
    TCHAR *             pchCopy = NULL;
    MarkupTextFrag *    ptf = NULL;

    Assert( iTextFrag >= 0 && iTextFrag <= _aryMarkupTextFrag.Size() );

    // Allocate and copy the string
    hr = THR( MemAllocStringBuffer( Mt(MarkupTextFrag_pchTextFrag), cchTextFrag, pchTextFrag, &pchCopy ) );
    if (hr)
        goto Cleanup;

    // Allocate the TextFrag object in the array
    hr = THR( _aryMarkupTextFrag.InsertIndirect( iTextFrag, NULL ) );
    if (hr)
    {
        MemFreeString( pchCopy );
        goto Cleanup;
    }

    // Fill in the text frag

    ptf = &_aryMarkupTextFrag[iTextFrag];
    Assert( ptf );

    ptf->_ptpTextFrag = ptpTextFrag;
    ptf->_pchTextFrag = pchCopy;

Cleanup:
    RRETURN( hr );
}

HRESULT     
CMarkupTextFragContext::RemoveTextFrag( long iTextFrag, CMarkup * pMarkup )
{
    HRESULT             hr = S_OK;
    MarkupTextFrag *    ptf;

    Assert( iTextFrag >= 0 && iTextFrag <= _aryMarkupTextFrag.Size() );

    // Get the text frag
    ptf = &_aryMarkupTextFrag[iTextFrag];

    // Free the string
    MemFreeString( ptf->_pchTextFrag );

    hr = THR( pMarkup->RemovePointerPos( ptf->_ptpTextFrag, NULL, NULL ) );
    if (hr)
        goto Cleanup;

Cleanup:

    // Remove the entry from the array
    _aryMarkupTextFrag.Delete( iTextFrag );

    RRETURN( hr );
}

long
CMarkupTextFragContext::FindTextFragAtCp( long cpFind, BOOL * pfFragFound )
{
    // Do a binary search through the array to find the spot in the array
    // where cpFind lies

    int             iFragLow, iFragHigh, iFragMid;
    MarkupTextFrag* pmtfAry = _aryMarkupTextFrag;
    MarkupTextFrag* pmtfMid;
    BOOL            fResult;
    long            cpMid;

    iFragLow  = 0;
    fResult   = FALSE;
    iFragHigh = _aryMarkupTextFrag.Size() - 1;

    while (iFragLow <= iFragHigh)
    {
        iFragMid = (iFragLow + iFragHigh) >> 1;

        pmtfMid  = pmtfAry + iFragMid;
        cpMid    = pmtfMid->_ptpTextFrag->GetCp();

        if (cpMid == cpFind)
        {
            iFragLow = iFragMid;
            fResult = TRUE;
            break;
        }
        else if (cpMid < cpFind)
            iFragLow = iFragMid + 1;
        else
            iFragHigh = iFragMid - 1;
    }

    if (fResult && iFragLow > 0)
    {
        // Search backward through all of the entries
        // at the same cp so we return the first one
        
        for ( iFragLow-- ; iFragLow ; iFragLow-- )
        {
            if (pmtfAry[iFragLow]._ptpTextFrag->GetCp() != cpFind)
            {
                iFragLow++;
                break;
            }
        }
    }

    if (pfFragFound)
        *pfFragFound = fResult;

    Assert( iFragLow == 0 || pmtfAry[iFragLow-1]._ptpTextFrag->GetCp() < cpFind );
    Assert(     iFragLow == _aryMarkupTextFrag.Size() - 1 
            ||  _aryMarkupTextFrag.Size() == 0
            ||  cpFind <= pmtfAry[iFragLow]._ptpTextFrag->GetCp() );
    Assert( !fResult || pmtfAry[iFragLow]._ptpTextFrag->GetCp() == cpFind );

    return iFragLow;
}

#if DBG==1
void
CMarkupTextFragContext::TextFragAssertOrder()
{
    // Walk the array and assert order for each pair
    // to make sure that the array is ordered correctly
    int cFrag;
    MarkupTextFrag * ptf, *ptfLast = NULL;

    for( cFrag = _aryMarkupTextFrag.Size(), ptf = _aryMarkupTextFrag; cFrag > 0; cFrag--, ptf++ )
    {
        if (ptfLast)
        {
            Assert( ptfLast->_ptpTextFrag->InternalCompare( ptf->_ptpTextFrag ) == -1 );
        }

        ptfLast = ptf;
    }
}
#endif


//+-------------------------------------------------------------------------
//
// IMarkupTextFrags Method Implementations
//
//--------------------------------------------------------------------------
HRESULT 
CMarkup::GetTextFragCount(long* pcFrags)
{
    HRESULT hr = S_OK;

    if (!pcFrags)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if( !HasTextFragContext() )
        *pcFrags = 0;
    else
        *pcFrags = GetTextFragContext()->_aryMarkupTextFrag.Size();

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::GetTextFrag(long iFrag, BSTR* pbstrFrag, IMarkupPointer* pIPointerFrag)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    MarkupTextFrag *            ptf;
    CMarkupPointer *            pPointerFrag;

    // Check args
    if (    !pbstrFrag
        ||  !pIPointerFrag
        ||  !pDoc->IsOwnerOf( pIPointerFrag )
        ||  !ptfc
        ||  iFrag < 0
        ||  iFrag >= ptfc->_aryMarkupTextFrag.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbstrFrag = NULL;

    // Crack the pointer
    hr = pIPointerFrag->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFrag);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // copy the string
    ptf = &(ptfc->_aryMarkupTextFrag[iFrag]);
    Assert( ptf );

    hr = THR( FormsAllocString( ptf->_pchTextFrag, pbstrFrag ) );
    if (hr)
        goto Cleanup;

    // position the pointer
    {
        CTreePosGap tpgPointer( ptf->_ptpTextFrag, TPG_RIGHT );
        hr = THR( pPointerFrag->MoveToGap( &tpgPointer, this ) );
        if (hr)
        {
            FormsFreeString( *pbstrFrag );
            *pbstrFrag = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::RemoveTextFrag(long iFrag)
{
    HRESULT hr = S_OK;
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    
    // Check args
    if (    !ptfc
        ||  iFrag < 0
        ||  iFrag >= ptfc->_aryMarkupTextFrag.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Remove the text frag
    hr = THR( ptfc->RemoveTextFrag( iFrag, this ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::InsertTextFrag(long iFragInsert, BSTR bstrInsert, IMarkupPointer* pIPointerInsert)
{
    HRESULT                     hr = S_OK;
    CDoc *                      pDoc = Doc();
    CMarkupTextFragContext *    ptfc = EnsureTextFragContext();
    CMarkupPointer *            pPointerInsert;
    CTreePosGap                 tpgInsert;

    // Check for really bad args
    if (    !pIPointerInsert
        ||  !pDoc->IsOwnerOf( pIPointerInsert )
        ||  !bstrInsert)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure we had or created a text frag context
    if (!ptfc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Crack the pointer
    hr = pIPointerInsert->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerInsert);
    if (hr || !pPointerInsert->IsPositioned() || pPointerInsert->Markup() != this)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    // Find the position for insert
    {
        BOOL fFragFound = TRUE;
        BOOL fPosSpecified = TRUE;
        long cFrags = ptfc->_aryMarkupTextFrag.Size();
        long cpInsert = pPointerInsert->GetCp();
        long cpBefore = -1;
        long cpAfter = MAXLONG;

        if (iFragInsert < 0)
        {
            iFragInsert = ptfc->FindTextFragAtCp( cpInsert, &fFragFound );
            fPosSpecified = FALSE;
        }

        // Make sure that the pointer and iFragInsert are in sync
        if (fPosSpecified)
        {
            if (iFragInsert > 0)
            {
                cpBefore = ptfc->_aryMarkupTextFrag[iFragInsert-1]._ptpTextFrag->GetCp();
            }

            if (iFragInsert <= cFrags - 1)
            {
                cpAfter = ptfc->_aryMarkupTextFrag[iFragInsert]._ptpTextFrag->GetCp();
            }

            if (cpBefore > cpInsert || cpAfter < cpInsert || iFragInsert > cFrags)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        // Position it carefully if a neighbor is at the same cp
        if (fPosSpecified && cpBefore == cpInsert)
        {
            hr = THR( tpgInsert.MoveTo( ptfc->_aryMarkupTextFrag[iFragInsert-1]._ptpTextFrag, TPG_RIGHT ) );
            if (hr)
                goto Cleanup;
        }
        else if (fPosSpecified && cpAfter == cpInsert || !fPosSpecified && fFragFound)
        {
            hr = THR( tpgInsert.MoveTo( ptfc->_aryMarkupTextFrag[iFragInsert]._ptpTextFrag, TPG_LEFT ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            // Note: Eric, you will have to split any text poses here if pPointerInsert
            // is ghosted.
            // Note2 (Eric): just force all pointers to embed.  Could make this faster
            //

            hr = THR( EmbedPointers() );

            if (hr)
                goto Cleanup;
            
            hr = THR( tpgInsert.MoveTo( pPointerInsert->GetEmbeddedTreePos(), TPG_LEFT ) );
            if (hr)
                goto Cleanup;
        }
    }

    // Now that we have where we want to insert this text frag, we have to actually insert
    // it an add it to the list
    {
        CTreePos * ptpInsert;

        ptpInsert = NewPointerPos( NULL, FALSE, FALSE );
        if( ! ptpInsert )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( Insert( ptpInsert, &tpgInsert ) );
        if (hr)
        {
            FreeTreePos( ptpInsert );
            goto Cleanup;
        }

        hr = THR( ptfc->AddTextFrag( ptpInsert, bstrInsert, FormsStringLen( bstrInsert), iFragInsert ) );
        if (hr)
        {
            IGNORE_HR( Remove( ptpInsert ) );
            goto Cleanup;
        }
    }

    WHEN_DBG( ptfc->TextFragAssertOrder() );

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::FindTextFragFromMarkupPointer(IMarkupPointer* pIPointerFind,long* piFrag,BOOL* pfFragFound)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CMarkupTextFragContext *    ptfc = GetTextFragContext();
    CMarkupPointer *            pPointerFind;

    // Check args
    if (    !pIPointerFind
        ||  !pDoc->IsOwnerOf( pIPointerFind ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Crack the pointer
    hr = pIPointerFind->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFind);
    if (hr || !pPointerFind->IsPositioned())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    {
        long iFrag;
        BOOL fFragFound = FALSE;

        if (ptfc)
        {
            iFrag = ptfc->FindTextFragAtCp( pPointerFind->GetCp(), &fFragFound );
        }
        else
        {
            // If we don't have a context, return 0/False
            iFrag = 0;
        }

        if (piFrag)
            *piFrag = iFrag;

        if (pfFragFound)
            *pfFragFound = fFragFound;
    }


Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureStyleSheets
//
//  Synopsis:   Ensure the stylesheets collection exists, creates it if not..
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureStyleSheets()
{
    CStyleSheetArray * pStyleSheets;
    if (HasStyleSheetArray())
        return S_OK;

    pStyleSheets = new CStyleSheetArray( this, NULL, 0 );
    if (!pStyleSheets || pStyleSheets->_fInvalid )
        return E_OUTOFMEMORY;

    SetStyleSheetArray(pStyleSheets);
    return S_OK;
}


HRESULT 
CMarkup::ApplyStyleSheets(
        CStyleInfo *    pStyleInfo,
        ApplyPassType   passType,
        EMediaType      eMediaType,
        BOOL *          pfContainsImportant)
{
    HRESULT hr = S_OK;
    CStyleSheetArray * pStyleSheets;
    
    if (Doc()->_pHostStyleSheets)
    {
        hr = THR(Doc()->_pHostStyleSheets->Apply(pStyleInfo, passType, eMediaType, NULL));
        if (hr)
            goto Cleanup;
    }

    if (!HasStyleSheetArray())
        return S_OK;

    pStyleSheets = GetStyleSheetArray();
        
    if (!pStyleSheets->Size())
        return S_OK;

    hr = THR(pStyleSheets->Apply(pStyleInfo, passType, eMediaType, pfContainsImportant));

Cleanup:
    RRETURN(hr);
}


CMarkup *   
CMarkup::GetParentMarkup()
{       
    // First check our root   
    CElement * pRoot;      
    pRoot = Root();

    if (!pRoot)
        return NULL;

    if (pRoot->HasMasterPtr())
    {
        return pRoot->GetMasterPtr()->GetMarkup();
    }

    // HTC link?         
    CMarkupBehaviorContext *    pBehaviorContext;    
    CHtmlComponent *            pHtmlComponent;
    CElement *                  pHtmlComponentElement;   

    pBehaviorContext = BehaviorContext();
    if (pBehaviorContext)
    {                
        pHtmlComponent = pBehaviorContext->_pHtmlComponent;
        if (pHtmlComponent)
        {
            pHtmlComponentElement = pHtmlComponent->_pElement;
            if (pHtmlComponentElement &&
                pHtmlComponentElement->IsInMarkup())
            {
                return pHtmlComponentElement->GetMarkup();          
            }
        }
    }

    else if (_fWindowPending)
    {
        pRoot = GetWindowPending()->Markup()->Root();

        if (!pRoot)
            return NULL;

        if (pRoot->HasMasterPtr())
        {
            return pRoot->GetMasterPtr()->GetMarkup();
        }
    }

    return NULL;
}


//-----------------------------------------------------------------------------
// CMarkup::GetRootMarkup
//    
// fUseNested is used for determining the security ID of the root markup
// in the active desktop case. We don't want to use the ID of the htt
// file that hosts active desktop pages, so we pass in fUseNested to
// avoid doing so. 
//-----------------------------------------------------------------------------

CMarkup *   
CMarkup::GetRootMarkup(BOOL fUseNested /* = FALSE */)
{
    CMarkup * pMarkupPrev;
    CMarkup * pMarkup = NULL; 
    CMarkup * pMarkupParent = this;

    do
    {
        pMarkupPrev = pMarkup;
        pMarkup = pMarkupParent;
        pMarkupParent = pMarkup->GetParentMarkup();
    }
    while(pMarkupParent);    

    if (fUseNested && pMarkupPrev && pMarkupPrev->IsActiveDesktopComponent())
    {
        return pMarkupPrev;
    }
    return pMarkup;
}

#if DBG==1
BOOL
CMarkup::IsConnectedToPrimaryWorld()
{
    CMarkup * pPendingPrimary = Doc()->PendingPrimaryMarkup();
    CMarkup * pPrimary = Doc()->PrimaryMarkup();
    CMarkup * pMarkup = this;

    while( pMarkup != pPendingPrimary && pMarkup != pPrimary )
    {
        // Grab the root element of the appropriate markup 
        CElement * pelRoot = pMarkup->_fWindowPending ? 
                                pMarkup->GetWindowPending()->Markup()->Root() : 
                                pMarkup->Root();

        // No view-link = not connected
        if( !pelRoot->HasMasterPtr() )
            return FALSE;

        // View-linked to element in ether = not connected
        pMarkup = pelRoot->GetMasterPtr()->GetMarkup();
        if( !pMarkup )
            return FALSE;
    }

    // Must have hit primary
    Assert( pMarkup == pPrimary || pMarkup == pPendingPrimary );
    return TRUE;
}
#endif // DBG


BOOL
CMarkup::IsConnectedToPrimaryMarkup()
{
    CMarkup *pPrimary = Doc()->PrimaryMarkup();
    CMarkup *pMarkup = this;

    Assert(pPrimary);

    while (pMarkup != pPrimary)
    {
        CElement *pelRoot;
        pelRoot = pMarkup->Root();

        // stand-alone (ether) markup!
        if (!pelRoot->HasMasterPtr())
            return FALSE;

        // Get the markup in which the master element is in.
        pMarkup = pelRoot->GetMasterPtr()->GetMarkup();

        // stand-alone (ether) master element!
        if (!pMarkup)
            return FALSE;
    }

    Assert(pMarkup == pPrimary || !pMarkup);
    return !!pMarkup;
}

BOOL
CMarkup::IsPendingRoot()
{
    CMarkup * pMarkupRoot = GetRootMarkup();

    if (    pMarkupRoot->_fWindowPending 
        &&  pMarkupRoot->GetWindowPending()->Window()->IsPrimaryWindow())
    {
        return TRUE;
    }

    // If we aren't connected to the root markup in any way, assume that we are
    // created from script/code and we must be in the non pending world.
    return FALSE;

}

HRESULT
CMarkup::ForceRelayout()
{
    CNotification nf;

    Assert(IsConnectedToPrimaryMarkup());

    Root()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    nf.DisplayChange(Root());
    Root()->SendNotification(&nf);     

    CElement *pClient = GetElementClient();
    if(pClient) 
        pClient->ResizeElement(NFLAGS_FORCE);

    return S_OK;
}

BOOL        
CMarkup::CanNavigate()
{ 
    CWindow * pWindow = GetWindowedMarkupContextWindow(); 
    return pWindow ? pWindow->CanNavigate() : (!Doc()->_fDisableModeless && (Doc()->_ulDisableModeless == 0)); 
}


//+---------------------------------------------------------------
//
//  Member:         CMarkup::OnCssChange
//
//---------------------------------------------------------------

HRESULT
CMarkup::OnCssChange(BOOL fStable, BOOL fRecomputePeers)
{
    HRESULT     hr = S_OK;

    if (fRecomputePeers)
    {
        if (fStable)
            hr = THR(RecomputePeers());
        else
            hr = THR(ProcessPeerTask(PEERTASK_MARKUP_RECOMPUTEPEERS_UNSTABLE));

        if (hr)
            goto Cleanup;
    }

    if (IsConnectedToPrimaryMarkup())
    {
        //
        // When we finish downloading embedded fonts, we need to clear 
        // font face cache, which is used during ApplyFontFace.
        // This is because before downloading embedded font we can compute
        // formats and update font face cache, and after downloading
        // we recompute formats, but we use font face cache for perf.
        //
        fc().ClearFaceCache();

        hr = ForceRelayout();
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CMarkup::EnsureFormats
//
//---------------------------------------------------------------

void
CMarkup::EnsureFormats( FORMAT_CONTEXT FCPARAM )
{
    // Walk the tree and make sure all formats are computed

    if (_fEnsuredFormats)
        return;
    _fEnsuredFormats = TRUE; // cleared only at unload time

    CTreePos * ptpCurr = FirstTreePos();
    while (ptpCurr)
    {
        if (ptpCurr->IsBeginNode())
        {
            ptpCurr->Branch()->EnsureFormats( FCPARAM );
        }
        ptpCurr = ptpCurr->NextTreePos();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::CreateWindowHelper
//
//  Synopsis:   We create a window for: 
//                  1) the primary markup 
//                  2) whenever we open a new browser window
//                  3) createDocumentFromUrl
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::CreateWindowHelper()
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;
    COmWindowProxy *pProxy = NULL;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = ARRAY_SIZE(abSID);
    CDocument *     pDocument;
    
    AssertSz (!IsHtcMarkup(), "Attempt to CreateWindowHelper for HTC markup. This is a major perf hit and a likely bug. Contact alexz, lmollico or mohanb for details.");
    AssertSz (!HasWindowPending(), "Don't call this function unless you need a window. (peterlee)");

    //
    // Make sure we have a document
    //

    hr = THR(EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    //
    // Create a window
    //

    pWindow = new CWindow(this);
    if (!pWindow)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Create the Window proxy
    //
    
    pProxy = new COmWindowProxy;
    if (!pProxy)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    pProxy->_fTrusted = TRUE;

    hr = THR(pProxy->Init((IHTMLWindow2 *)pWindow, abSID, cbSID));
    if (hr)
        goto Cleanup;

    // Play ref counting games wrt the proxy/window
    pWindow->SetProxy( pProxy );

    //
    // Add this entry to the thread local cache.
    //

    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;

    hr = THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
            (IHTMLWindow2 *)pWindow,
            abSID,
            cbSID,
            IsMarkupTrusted(),
            (IHTMLWindow2 *)pProxy));
    if (hr)
        goto Cleanup;

    hr = THR(SetWindow(pProxy));
    if (hr) 
        goto Cleanup;

    _fWindow = TRUE;

    pProxy->_fTrustedDoc = !!IsMarkupTrusted();

    pProxy->OnSetWindow();        

    //
    // now transfer ownership of document to the window
    //

    pDocument->SwitchOwnerToWindow( pWindow );

Cleanup:
    if (hr && pWindow)
    {
        // On error sub release markup on behalf of CWindow.
        Assert(this == pWindow->_pMarkup);
        pWindow->_pMarkup = NULL;
        SubRelease();
    }
    if (pWindow)
    {
        pWindow->Release();
    }
    if (pProxy)
    {
        pProxy->Release();
    }
    RRETURN(hr);
}

   
//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::InitWindow
//
//  Synopsis:   Copies over any temporary dispids from the markup onto 
//              the new window.
//
//--------------------------------------------------------------------------
HRESULT
CMarkup::InitWindow()
{
    HRESULT         hr = S_OK;
    CAttrArray *    pAAMarkupNew;
    CAttrArray **   ppAAWindow;
    CAttrValue *    pAV;
   
    //
    // Move over to the window any temporary attributes stored on the new markup 
    //                   
    pAAMarkupNew = *GetAttrArray();    
    if (pAAMarkupNew)
    {        
        // window's attr array should be null since we just cleared it
        ppAAWindow = Window()->GetAttrArray();

        if (!*ppAAWindow)
        {
            // create a new attr array on the window
            *ppAAWindow = new CAttrArray;
            if (!*ppAAWindow)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        // run through the attr array on the new markup
        int i, cIndex;
        for (i = pAAMarkupNew->Size(), cIndex = 0, pAV = *pAAMarkupNew;
                i > 0;
                i--)
        {                           
            Assert (pAV);                          
            if ( CMarkup::IsTemporaryDISPID (pAV->GetDISPID()) )
            {
                Assert (!(*ppAAWindow)->Find(pAV->GetDISPID(), pAV->AAType()));

                // move temporary attr value onto the window                
                (*ppAAWindow)->AppendIndirect(pAV, NULL);
                pAAMarkupNew->Delete(cIndex);

                // after deleting, array elements have been shifted down one
                // so continue at same array index
                continue;
            }
            cIndex++;
            pAV++;
        }
    }   

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------
//
//  Member:     CMarkup::GetFramesCount
//
//  Synopsis:   returns number of frames in frameset;
//              fails if the doc does not contain frameset
//
//-----------------------------------------------------------------------

HRESULT
CMarkup::GetFramesCount (LONG * pcFrames)
{
    HRESULT             hr;
    CElement      *     pElement;

    if (!pcFrames)
        RRETURN (E_POINTER);

    pElement = GetElementClient();
    if (!pElement || pElement->Tag() != ETAG_FRAMESET)
    {
        *pcFrames = 0;
        hr = S_OK;  // TODO: Why return S_OK if GetClientSite failed?
    }
    else
        hr = THR(DYNCAST(CFrameSetSite, pElement)->GetFramesCount(pcFrames));

    RRETURN( hr );
}

////////////////////////////////
// IMarkupContainer2 methods

//+---------------------------------------------------------------
//
//  Member: CreateChangeLog
//
//  Synopsis: Creates a new ChangeLog object and associates it with
//      the given ChangeSink.
//
//+---------------------------------------------------------------

HRESULT
CMarkup::CreateChangeLog(
    IHTMLChangeSink * pChangeSink,
    IHTMLChangeLog ** ppChangeLog,
    BOOL              fForward,
    BOOL              fBackward )
{
    HRESULT hr = S_OK;
    CLogManager * pLogMgr;
    IHTMLChangeSink * pChangeSinkCopy = NULL;

    if( !pChangeSink || !ppChangeLog || ( !fForward && !fBackward ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pChangeSink->QueryInterface( IID_IHTMLChangeSink, (void **)&pChangeSinkCopy ) );
    if( hr )
        goto Cleanup;

    pLogMgr = EnsureLogManager();
    if( !pLogMgr )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pLogMgr->RegisterSink( pChangeSinkCopy, ppChangeLog, fForward, fBackward ) );

Cleanup:
    ReleaseInterface( pChangeSinkCopy );
    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member: ExecChange
//
//  Synopsis: Executes the given Change Record on the markup
//
//+---------------------------------------------------------------

HRESULT
CMarkup::ExecChange(
    BYTE * pbRecord,
    BOOL   fForward )
{
    HRESULT             hr;
    CChangeRecordBase * pchrec;
    CMarkupPointer      mp( Doc() );

    Assert( pbRecord );
    if( !pbRecord )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // We're cheating here to line up the pointer with the actual data in memory
    pchrec = (CChangeRecordBase *)(pbRecord - sizeof(CChangeRecordBase *));

    hr = THR( pchrec->PlayIntoMarkup( this, fForward ) );
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}

#if 0
//+---------------------------------------------------------------
//
//  Member: GetRootElement
//
//  Synopsis: Gets the Root Element for the container
//
//+---------------------------------------------------------------

HRESULT
CMarkup::GetRootElement( IHTMLElement ** ppElement )
{
    HRESULT hr = S_OK;

    if( !ppElement )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElement = NULL;

    Assert( Root() );
    hr = THR( Root()->QueryInterface( IID_IHTMLElement, (void **)ppElement ) );

Cleanup:
    RRETURN( hr );
}
#endif // 0

//+---------------------------------------------------------------------------
//
//  Dirty Range Service
//
//----------------------------------------------------------------------------
HRESULT 
CMarkup::RegisterForDirtyRange( IHTMLChangeSink * pChangeSink, DWORD * pdwCookie )
{
    HRESULT                     hr = S_OK;
    MarkupDirtyRange *          pdr;
    CMarkupChangeNotificationContext *  pcnc;
    IHTMLChangeSink *           pChangeSinkCopy = NULL;

    Assert( pChangeSink && pdwCookie );

    if( !pChangeSink || !pdwCookie )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Did they actually give us a ChangeSink?
    hr = THR( pChangeSink->QueryInterface( IID_IHTMLChangeSink, (void **)&(pChangeSinkCopy) ) );
    if( hr )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pcnc = EnsureChangeNotificationContext();
    if (!pcnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pcnc->_aryMarkupDirtyRange.AppendIndirect( NULL, &pdr ) );
    if (hr)
        goto Cleanup;

    Assert( pdr );

    pdr->_dwCookie      = 
    *pdwCookie          = InterlockedIncrement( (long *) &s_dwDirtyRangeServiceCookiePool );
    pdr->_pChangeSink   = pChangeSinkCopy;

    pdr->_pChangeSink->AddRef();
    pdr->_dtr.Reset();

    // In case anyone cares...
    pcnc->_fReentrantModification = TRUE;

Cleanup:
    ReleaseInterface( pChangeSinkCopy );
    RRETURN( hr );
}

HRESULT 
CMarkup::UnRegisterForDirtyRange( DWORD dwCookie )
{
    HRESULT                     hr = S_OK;
    CMarkupChangeNotificationContext *  pcnc;
    MarkupDirtyRange *          pdr;
    int                         cdr, idr;

    if (!HasChangeNotificationContext())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    for( idr = 0, cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange;
         idr < cdr;
         idr++, pdr++ )
    {
        if( pdr->_dwCookie == dwCookie )
        {
            pdr->_pChangeSink->Release();
            pcnc->_aryMarkupDirtyRange.Delete( idr );
            goto Cleanup;
        }
    }

    // In case anyone cares...
    pcnc->_fReentrantModification = TRUE;

    hr = E_FAIL;

Cleanup:
    RRETURN( hr );
}

HRESULT 
CMarkup::GetAndClearDirtyRange( DWORD dwCookie, CMarkupPointer * pmpBegin, CMarkupPointer * pmpEnd )
{
    HRESULT                     hr = S_OK;
    CMarkupChangeNotificationContext *  pcnc;
    MarkupDirtyRange *          pdr;
    int                         cdr, idr;

    if (!HasChangeNotificationContext())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    for( idr = 0, cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange;
         idr < cdr;
         idr++, pdr++ )
    {
        if (pdr->_dwCookie == dwCookie)
        {
            if (pmpBegin)
            {
                if( pdr->_dtr._cp == -1 )
                    hr = THR( pmpBegin->Unposition() );
                else
                    hr = THR( pmpBegin->MoveToCp( pdr->_dtr._cp, this ) );
                if (hr)
                    goto Cleanup;
            }
            
            if (pmpEnd)
            {
                if( pdr->_dtr._cp == -1 )
                    hr = THR( pmpEnd->Unposition() );
                else
                    hr = THR( pmpEnd->MoveToCp( pdr->_dtr._cp + pdr->_dtr._cchNew, this ) );
                if (hr)
                    goto Cleanup;
            }

            pdr->_dtr.Reset();

            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    RRETURN( hr );
}

HRESULT
CMarkup::GetAndClearDirtyRange( DWORD dwCookie, IMarkupPointer * pIPointerBegin, IMarkupPointer * pIPointerEnd )
{
    HRESULT hr;
    CDoc *  pDoc = Doc();
    CMarkupPointer * pmpBegin, * pmpEnd;

    if (    (pIPointerBegin && !pDoc->IsOwnerOf( pIPointerBegin ))
        ||  (pIPointerEnd && !pDoc->IsOwnerOf( pIPointerEnd )))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerBegin->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpBegin ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pIPointerEnd->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpEnd ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = GetAndClearDirtyRange( dwCookie, pmpBegin, pmpEnd );

Cleanup:
    RRETURN( hr );
}

void    
CMarkup::OnDirtyRangeChange(DWORD_PTR dwContext)
{
    CMarkupChangeNotificationContext * pcnc;
    MarkupDirtyRange            *   pdr;
    long                            cdr;
    BOOL                            fWasNotified;

    Assert( HasChangeNotificationContext() );

    pcnc = GetChangeNotificationContext();
    Assert( pcnc );

    Assert( pcnc->_fOnDirtyRangeChangePosted );
    pcnc->_fOnDirtyRangeChangePosted = FALSE;

    // Clear our flags
    pcnc->_fReentrantModification = FALSE;
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr > 0; cdr--, pdr++ )
    {
        pdr->_fNotified = FALSE;
    }

NotifyLoop:
    // Notify everyone of the change
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr > 0; cdr--, pdr++ )
    {
        Assert( pdr->_pChangeSink );

        fWasNotified = pdr->_fNotified;
        pdr->_fNotified = TRUE;

        // Check to make sure this sink hasn't already been notified, and that it has a dirty range
        if( !fWasNotified && pdr->_dtr.IsDirty() )
        {
            pdr->_pChangeSink->Notify();
        }

        // If they messed with us, we have to restart.
        if( pcnc->_fReentrantModification )
        {
            pcnc->_fReentrantModification = FALSE;
            goto NotifyLoop;
        }
    }

    // Make sure everything is cool, ie, everyone was notified
    Assert( !pcnc->_fReentrantModification );
#if DBG==1
    for( cdr = pcnc->_aryMarkupDirtyRange.Size(), pdr = pcnc->_aryMarkupDirtyRange; cdr; cdr--, pdr++ )
    {
        Assert( pdr->_fNotified );
    }
#endif // DBG


}

CMarkupChangeNotificationContext *    
CMarkup::EnsureChangeNotificationContext()
{
    CMarkupChangeNotificationContext *    pcnc;

    if (HasChangeNotificationContext())
        return GetChangeNotificationContext();

    pcnc = new CMarkupChangeNotificationContext;
    if (!pcnc)
        return NULL;

    if (SetChangeNotificationContext( pcnc ))
    {
        delete pcnc;
        return NULL;
    }

    return pcnc;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::GetVersionNumber
//  
//  Synopsis:   Returns the content version number
//  
//  Returns:    long
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

STDMETHODIMP_(long)
CMarkup::GetVersionNumber()
{
    return GetMarkupContentsVersion();
}

//+----------------------------------------------------------------------------
//
//  Method:     CMarkup::GetMasterElement
//  
//  Synopsis:   Returns the master element for the markup container, or NULL
//                  if the container is not slaved.
//  
//  Returns:    HRESULT
//  
//  Arguments:  
//          IHTMLElement ** ppElementMaster - Pointer to be filled
//  
//+----------------------------------------------------------------------------

STDMETHODIMP
CMarkup::GetMasterElement( IHTMLElement ** ppElementMaster )
{
    HRESULT hr = S_OK;
    CElement * pRootElement = Root();

    if( !ppElementMaster )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppElementMaster = NULL;

    Assert( pRootElement );

    if( pRootElement->HasMasterPtr() )
    {
        Assert( pRootElement->GetMasterPtr() );

        hr = THR( pRootElement->GetMasterPtr()->QueryInterface( IID_IHTMLElement, (void **)ppElementMaster ) );
    }
    else
    {
        pRootElement = GetElementClient();

        if( pRootElement && pRootElement->HasMasterPtr() )
        {
            Assert( pRootElement->GetMasterPtr() );

            hr = THR( pRootElement->GetMasterPtr()->QueryInterface( IID_IHTMLElement, (void **)ppElementMaster ) );
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Layout Rect Registry - Keeps track of incoming layout rect elements
//   and their unsatisfied nextRect connections.
//
//----------------------------------------------------------------------------

CLayoutRectRegistry *
CMarkup::GetLayoutRectRegistry()
{
    CLayoutRectRegistry * pLRR = GetLRRegistry();

    if (!pLRR)
    {
        pLRR = new CLayoutRectRegistry();
    }

    IGNORE_HR(SetLRRegistry(pLRR));

    return pLRR;
}

void
CMarkup::ReleaseLayoutRectRegistry()
{
    CLayoutRectRegistry * pLRR = GetLRRegistry();

    if ( pLRR )
    {
        delete pLRR;
        IGNORE_HR( SetLRRegistry( NULL ) );
    }
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::GetUpdatedCompatibleLayoutContext
//
//-------------------------------------------------------------------------

CCompatibleLayoutContext *
CMarkup::GetUpdatedCompatibleLayoutContext(CLayoutContext *pLayoutContextSrc)
{
    // This assert is important to guarantee validity of the compatible context.
    AssertSz( pLayoutContextSrc && pLayoutContextSrc->IsValid(), "When you ask for a compatible context, you must provide a valid context for it to be compatible with!" );

    CCompatibleLayoutContext *pLayoutContext = (CCompatibleLayoutContext *)GetCompatibleLayoutContext();
    if (pLayoutContext == NULL)
    {
        HRESULT hr; 

        pLayoutContext = new CCompatibleLayoutContext();
        Assert(pLayoutContext != NULL && "Failure to allocate CCompatibleLayoutContext");

        hr = SetCompatibleLayoutContext(pLayoutContext);
        if (hr != S_OK)
        {
            delete pLayoutContext;
            pLayoutContext = NULL;
        }
    }

    if (pLayoutContext != NULL)
    {
        pLayoutContext->Init(pLayoutContextSrc);
    }

    return (pLayoutContext);
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::DelCompatibleLayoutContext
//
//-------------------------------------------------------------------------
void
CMarkup::DelCompatibleLayoutContext()
{
    Assert(HasCompatibleLayoutContext());

    // Make us stop pointing to the context
    CCompatibleLayoutContext * pLayoutContext = (CCompatibleLayoutContext *)DelLookasidePtr(LOOKASIDE_COMPATIBLELAYOUTCONTEXT);

    AssertSz(pLayoutContext, "Better have a context if we said we had one");
    AssertSz(pLayoutContext->RefCount() > 0, "Context better still be alive");
    AssertSz(pLayoutContext->IsValid(), "Context better still be valid");
    
    // Make the context stop pointing to an owner
    pLayoutContext->ClearLayoutOwner();

    // This release corresponds to the addref in SetCompatibleLayoutContext()
    pLayoutContext->Release();
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::SetCompatibleLayoutContext
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SetCompatibleLayoutContext( CCompatibleLayoutContext *pLayoutContext )
{
    Assert( !HasCompatibleLayoutContext() && "Compatible contexts shouldn't be replaced; we should just re-use" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    
    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_COMPATIBLELAYOUTCONTEXT, pLayoutContext);
}

//+------------------------------------------------------------------------
//
//      Member:     CElement::GetFrameOrPrimaryMarkup
//
//-------------------------------------------------------------------------

CMarkup *
CElement::GetFrameOrPrimaryMarkup(BOOL fStrict/*=FALSE*/)
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CElement::GetNearestMarkupForScriptCollection
//
//      Synopsis:   Returns the nearest markup in the hierarchy that has a 
//                  script collection. If there is no script collection,
//                  then the nearest frame or primary markup is returned.
//  
//-------------------------------------------------------------------------

CMarkup *
CElement::GetNearestMarkupForScriptCollection()
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetFrameOrPrimaryMarkup
//
//-------------------------------------------------------------------------

CMarkup *
CMarkup::GetFrameOrPrimaryMarkup(BOOL fStrict/*=FALSE*/)
{
    return GetWindowedMarkupContext();
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetNearestMarkupForScriptCollection
//
//      Synopsis:   Returns the nearest markup in the hierarchy that has a 
//                  script collection. If there is no script collection,
//                  then the nearest frame or primary markup is returned.
//  
//-------------------------------------------------------------------------
CMarkup *
CMarkup::GetNearestMarkupForScriptCollection()
{
    return GetWindowedMarkupContext();
}


//+------------------------------------------------------------------------
//
//  Member   : CMarkup::GetPositionCookie
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetPositionCookie(DWORD * pdwCookie)
{
    CElement * pElement = GetCanvasElement();

    if (   pElement
        && IsScrollingElementClient(pElement)
       )
    {
        *pdwCookie = pElement->GetUpdatedLayout()->GetYScroll();
    }
    else
    {
        *pdwCookie = 0;
    }
    
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CMarkup::SetPositionCookie
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::SetPositionCookie(DWORD dwCookie)
{ 
    return NavigateHere(0, NULL, dwCookie, TRUE);
}

// TODO: (jbeda) I'm not sure that this code works right -- most HTCs have windows!
#if 0
//+------------------------------------------------------------------------
//
//  Member   : CMarkup::NearestWindowHelper()
//
//-------------------------------------------------------------------------

// Helper fn for NearestWindow(); starts with "this" markup and looks up
// through the master chain for the nearest markup that has an OM window
// and returns that window.
COmWindowProxy *
CMarkup::NearestWindowHelper()
{
    CElement *pRootElem;
    CElement *pMasterElem;
    CMarkup *pMarkup = this;
    COmWindowProxy *pWindow = NULL;

    while ( pWindow == NULL )
    {
        pRootElem = pMarkup->Root();
        AssertSz( pRootElem, "Markup must have a root element" );
        if ( pRootElem->HasMasterPtr() )
        {
            pMasterElem = pRootElem->GetMasterPtr();
            pMarkup = pMasterElem->GetMarkup();
            if ( pMarkup )
            {
                pWindow = pMarkup->Window();
                // If our master markup has a window, pWindow will be non-NULL
                // and we'll fall out of the loop.  If it doesn't, we'll
                // try and find our master's master etc.
            }
        }
        else
        {
            // found a root w/o a master; nowhere left to go!
            break;
        }
    }

    return pWindow;
}
#endif

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetFocusItems
//
//      Synopsis:   Returns the focus items array, creating one 
//                  if one does not exist.
//  
//      Arguments:  
//                  fShouldCreate - Whether we should create it, if one does
//                      already not exist
//-------------------------------------------------------------------------

CAryFocusItem * 
CMarkup::GetFocusItems(BOOL fShouldCreate) 
{
    HRESULT hr;
    CAryFocusItem * paryFocusItem = NULL;

    hr = GetPointerAt (FindAAIndex(DISPID_INTERNAL_FOCUSITEMS, CAttrValue::AA_Internal), 
        (void **) &paryFocusItem);    
    
    // create focus items array
    if (hr==DISP_E_MEMBERNOTFOUND && fShouldCreate)
    {    
        paryFocusItem = new CAryFocusItem;            
        if (paryFocusItem)
        {
            hr = AddPointer ( DISPID_INTERNAL_FOCUSITEMS,
                    (void *) paryFocusItem,
                    CAttrValue::AA_Internal );
            if (hr)
            {
                delete paryFocusItem;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr ? NULL : (CAryFocusItem*)paryFocusItem;
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::GetPicsTarget
//
//      Synopsis:   Get the IOleCommandTarget to report pics results to
//  
//-------------------------------------------------------------------------

IOleCommandTarget *
CMarkup::GetPicsTarget() 
{
    if (HasTransNavContext())
        return GetTransNavContext()->_pctPics;
    return NULL;
}

//+------------------------------------------------------------------------
//
//      Member:     CMarkup::SetPicsTarget
//
//      Synopsis:   Set the IOleCommandTarget to report pics results to
//  
//-------------------------------------------------------------------------

HRESULT
CMarkup::SetPicsTarget(IOleCommandTarget * pctPics) 
{
    HRESULT hr = S_OK;

    CMarkupTransNavContext * ptnc;
    if (pctPics)
    {
        ptnc = EnsureTransNavContext();
        if(!ptnc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ReplaceInterface( &(ptnc->_pctPics), pctPics );
    }
    else if(HasTransNavContext())
    {
        ptnc = GetTransNavContext();

        ClearInterface( &(ptnc->_pctPics) );

        EnsureDeleteTransNavContext( ptnc );
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureLocationContext
//  
//  Synopsis:   Ensures the location context
//  
//  Returns:    CMarkupLocationContext * - the location context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

CMarkupLocationContext *
CMarkup::EnsureLocationContext()
{
    CMarkupLocationContext * pmlc;

    if( HasLocationContext() )
        return GetLocationContext();

    pmlc = new CMarkupLocationContext;
    if( !pmlc )
        return NULL;

    if( SetLocationContext( pmlc ) )
    {
        delete pmlc;
        return NULL;
    }

    return pmlc;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetUrl
//  
//  Synopsis:   Sets the url in the MarkupLocationContext.  We must not
//                  currently have an URL set.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          TCHAR * pchUrl - New Url
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrl(TCHAR * pchUrl)
{
    HRESULT hr = S_OK;
    CMarkupLocationContext * pmlc = EnsureLocationContext();

    if (!pmlc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!pmlc->_pchUrl && pchUrl);
    pmlc->_pchUrl = pchUrl;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelUrl
//  
//  Synopsis:   Removes and returns the current url from the 
//                  MarkupLocationContext, if we have one
//  
//  Returns:    TCHAR * - the current url
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

TCHAR *
CMarkup::DelUrl()
{
    TCHAR * pch = NULL;
    
    if( HasLocationContext() )
    {
        CMarkupLocationContext * pmlc = GetLocationContext();
        
        pch = pmlc->_pchUrl;
        pmlc->_pchUrl = NULL;
    }

    return pch;
}

//+----------------------------------------------------------------------------
//  
//  Method  : CMarkup::SetUrlOriginal
//  
//  Synopsis: Sets the original url in the MarkupLocationContext.
//  
//  Input   : pszUrlOriginal - New original Url
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetUrlOriginal(LPTSTR pszUrlOriginal)
{
    CMarkupLocationContext * pmlc = EnsureLocationContext();

    if (!pmlc)
    {
        return E_OUTOFMEMORY;
    }

    MemFreeString(pmlc->_pchUrlOriginal);
    pmlc->_pchUrlOriginal = pszUrlOriginal;

    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method  : CMarkup::SetDomain
//  
//  Synopsis: Sets the domain in the MarkupLocationContext.
//  
//  Input   : pszDomain - New domain
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetDomain(LPTSTR pszDomain)
{
    HRESULT hr = E_FAIL;
    TCHAR * pchAlloc = NULL;
    CMarkupLocationContext * pmlc = NULL;

    if( HasLocationContext() )
    {
        pmlc = GetLocationContext();
        
        MemFreeString(pmlc->_pchDomain);
        pmlc->_pchDomain = NULL;
    }

    if (!pszDomain)
    {
        goto Cleanup;
    }

    if (!pmlc)
    {
        pmlc = EnsureLocationContext();
        if (!pmlc)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(MemAllocString(Mt(CMarkup_pchDomain), pszDomain, &pchAlloc));
    if (hr)
        goto Cleanup;

    pmlc->_pchDomain = pchAlloc;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::ReplaceMonikerPtr
//  
//  Synopsis:   Replaces the existing moniker ptr (if any) w/ a new one
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          IMoniker * pmkNew - new moniker for markup
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::ReplaceMonikerPtr( IMoniker * pmkNew )
{
    CMarkupLocationContext * pmlc;

    if( !pmkNew && !HasLocationContext() )
        return S_OK;

    pmlc = EnsureLocationContext();

    if( !pmlc )
        return E_OUTOFMEMORY;

    ReplaceInterface( &(pmlc->_pmkName), pmkNew );
    
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureTextContext
//  
//  Synopsis:   Ensures the text context
//  
//  Returns:    CMarkupTextContext * - the text context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------

CMarkupTextContext *
CMarkup::EnsureTextContext()
{
    CMarkupTextContext *pContext;

    if( HasTextContext() )
        return GetTextContext();

    pContext = new CMarkupTextContext;
    if( !pContext )
        return NULL;

    if( SetTextContext( pContext ) )
    {
        delete pContext;
        return NULL;
    }

    return pContext;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetTextRangeListPtr
//  
//  Synopsis:   Sets the CAutoRange in the CMarkupTextContext.  We must not
//              have a CAutoRange set.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CAutoRange *pAutoRange - AutoRange
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetTextRangeListPtr( CAutoRange *pAutoRange )
{
    CMarkupTextContext * pContext = EnsureTextContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pAutoRange && pAutoRange );
    pContext->_pAutoRange = pAutoRange;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelTextRangeListPtr
//  
//  Synopsis:   Removes and returns the CAutoRange from the 
//                  MarkupTextContext, if we have one
//  
//  Returns:    CAutoRange * - The auto range
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

CAutoRange *
CMarkup::DelTextRangeListPtr()
{
    CAutoRange *pRange = NULL;
    
    if( HasTextContext() )
    {
        CMarkupTextContext * pContext = GetTextContext();
        
        pRange = pContext->_pAutoRange;
        pContext->_pAutoRange = NULL;
    }

    return pRange;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetTextFragContext
//  
//  Synopsis:   Sets the CMarkupTextFragContext. 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMarkupTextFragContext *ptfc - Text frag context
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetTextFragContext(CMarkupTextFragContext * ptfc)
{
    CMarkupTextContext * pContext = EnsureTextContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pTextFrag && ptfc );
    pContext->_pTextFrag = ptfc;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelTextFragContext
//  
//  Synopsis:   Removes and returns the CMarkupTextFragContext 
//  
//  Returns:    CAutoRange * - The auto range
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

CMarkupTextFragContext *
CMarkup::DelTextFragContext()
{
    CMarkupTextFragContext *ptfc = NULL;
    
    if( HasTextFragContext() )
    {
        CMarkupTextContext * pContext = GetTextContext();
        
        ptfc = pContext->_pTextFrag;
        pContext->_pTextFrag = NULL;
    }

    return ptfc;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetOrphanedMarkup
//
//  Synopsis:   Sets a markup's orphaned state.  If fOrphaned is TRUE, then
//              we'll add ourselves to the  list of orphaned markups
//              and set a bit on ourselves.
//              If fOrphaned is FALSE, then we pull ourselves out of the
//              list and clear the bit.
//
//  Arguments:  fOrphaned - New orphaned state
//
//+----------------------------------------------------------------------------
HRESULT CMarkup::SetOrphanedMarkup( BOOL fOrphaned )
{
    HRESULT hr                      = S_OK;
    CMarkupTextContext * pContext   = NULL;

    if( fOrphaned )
    {
        TraceTag(( tagOrphanedMarkup, "Orphaning markup %d(%x)", _nSerialNumber, this ));

        // Get the appropriate contexts
        pContext = EnsureTextContext();
        if( !pContext )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // We'd better not already be in there
        Assert( Doc()->_aryMarkups.Find( this ) == -1 && !IsOrphanedMarkup() );

        hr = THR( Doc()->_aryMarkups.Append( this ) );
        if( hr )
            goto Cleanup;

        // Remember that we're orphaned
        pContext->_fOrphanedMarkup = TRUE;
    }
    else
    {
        TraceTag(( tagOrphanedMarkup, "Un-Orphaning markup %d(%x)", _nSerialNumber, this ));

        pContext = GetTextContext();
        Assert( pContext && pContext->_fOrphanedMarkup );

        // Either we should be in the live array, or in the process of clearing orphans
        Assert( Doc()->_aryMarkups.Find( this ) != -1 || Doc()->_fClearingOrphanedMarkups );

        Doc()->_aryMarkups.DeleteByValue( this );
        pContext->_fOrphanedMarkup = FALSE;
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureEditRouter
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureEditRouter(CEditRouter **ppEditRouter)
{
    HRESULT     hr = S_OK;
    CEditRouter *pRouter = GetEditRouter();

    if( !pRouter )
    {
        pRouter = new CEditRouter();
        if( !pRouter )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetEditRouter(pRouter));
        if (hr)
            goto Cleanup;
    }

    if( ppEditRouter )
    {
        *ppEditRouter = pRouter;
    }

Cleanup:
    RRETURN (hr);
}
//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetEditRouter
//  
//  Synopsis:   Sets the CEditRouter 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CEditRouter *pRouter = Router
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetEditRouter(CEditRouter *pRouter)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pEditRouter && pRouter );
    pContext->_pEditRouter = pRouter;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelEditRouter
//  
//  Synopsis:   Removes and returns the CEditRouter 
//  
//  Returns:    CEditRouter - The Edit router
//
//+----------------------------------------------------------------------------
CEditRouter *
CMarkup::DelEditRouter()
{
    CEditRouter *pRouter = NULL;
    
    if( HasEditRouter() )
    {
        CMarkupEditContext * pContext = GetEditContext();
        
        pRouter = pContext->_pEditRouter;
        pContext->_pEditRouter = NULL;
    }

    return pRouter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureGlyphTable
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::EnsureGlyphTable(CGlyph **ppGlyphTable)
{
    HRESULT     hr = S_OK;
    CGlyph      *pTable = GetGlyphTable();

    if( !pTable )
    {
        pTable = new CGlyph(Doc());
        if( !pTable )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetGlyphTable(pTable));
        if (hr)
            goto Cleanup;
    }

    if( ppGlyphTable )
    {
        *ppGlyphTable = pTable;
    }

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetGlyphTable
//  
//  Synopsis:   Sets the glyph table 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CGlyphTable *pTable = glyph table
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetGlyphTable(CGlyph *pTable)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( !pContext->_pGlyphTable && pTable );
    pContext->_pGlyphTable = pTable;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelGlyphTable
//  
//  Synopsis:   Removes and returns the glyph table 
//  
//  Returns:    CGlyph - The glyph table
//
//+----------------------------------------------------------------------------
CGlyph *
CMarkup::DelGlyphTable()
{
    CGlyph *pTable = NULL;
    
    if( HasGlyphTable() )
    {
        CMarkupEditContext * pContext = GetEditContext();
        
        pTable = pContext->_pGlyphTable;
        pContext->_pGlyphTable = NULL;
    }

    return pTable;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::EnsureEditContext
//  
//  Synopsis:   Ensures the edit context
//  
//  Returns:    CMarkupEditContext * - the edit context
//  
//  Arguments:  None
//  
//+----------------------------------------------------------------------------
CMarkupEditContext *
CMarkup::EnsureEditContext()
{
    CMarkupEditContext *pContext;

    if( HasEditContext() )
        return GetEditContext();

    pContext = new CMarkupEditContext;
    if( !pContext )
        return NULL;

    if( SetEditContext( pContext ) )
    {
        delete pContext;
        return NULL;
    }

    return pContext;
}


HRESULT
CMarkup::GetTagInfo(CTreePos                *ptp, 
                    int                     gAlign, 
                    int                     gPositioning, 
                    int                     gOrientation, 
                    void                    *invalidateInfo, 
                    CGlyphRenderInfoType    *ptagInfo )
{
    HRESULT hr = S_OK;

    if( HasGlyphTable() )
    {
        hr = GetGlyphTable()->GetTagInfo( ptp, 
                                         (GLYPH_ALIGNMENT_TYPE)gAlign, 
                                         (GLYPH_POSITION_TYPE)gPositioning, 
                                         (GLYPH_ORIENTATION_TYPE)gOrientation, 
                                         invalidateInfo, 
                                         ptagInfo );
    }
    
    return (hr);
}

HRESULT
CMarkup::EnsureGlyphTableExistsAndExecute(  GUID        *pguidCmdGroup,
                                            UINT        idm,
                                            DWORD       nCmdexecopt,
                                            VARIANTARG  *pvarargIn,
                                            VARIANTARG  *pvarargOut)
{
    HRESULT hr = S_OK;

    if( idm == IDM_EMPTYGLYPHTABLE )
    {
        delete DelGlyphTable();
        hr = THR(ForceRelayout());
        RRETURN(hr);
    }

    if( !HasGlyphTable() )
    {
        hr = THR( EnsureGlyphTable(NULL) );
        if( hr )
            goto Cleanup;
            
        hr = GetGlyphTable()->Init();
        if (hr)
            goto Cleanup;
    }
    
    hr = GetGlyphTable()->Exec(pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetMedia
//  
//  Synopsis:   Sets the media type
//  
//  Returns:    HRESULT
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetMedia(mediaType type)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_eMedia = type;

    // Set the bit on the markup accordingly.
    _fForPrint = !!(GetMedia() & mediaTypePrint);

    return S_OK;
}



HRESULT
CMarkup::SetPrintTemplate(BOOL f)
{
    if (f || HasEditContext())
    {
        CMarkupEditContext * pContext = EnsureEditContext();

        if (!pContext)
            return E_OUTOFMEMORY;

        pContext->_fIsPrintTemplate = f;    

        {
            // Walk the tree, setting templateness on any markup children we have
            CTreePos * ptp;
            CElement * pElement;
            CMarkup  * pMarkup;
            for (ptp = FirstTreePos(); ptp; ptp = ptp->NextTreePos() )
            {
                if (ptp->IsBeginElementScope())
                {
                    pElement = ptp->Branch()->Element();
                    if (pElement->HasSlavePtr())
                    {
                        pMarkup = pElement->GetSlavePtr()->GetMarkup();
                        if (    !pMarkup->IsPrintMedia()                // in LayoutRect
                            &&  !pMarkup->IsPrintTemplateExplicit() )   // has been set explicitly
                        {
                            pMarkup->SetPrintTemplate(f);
                        }
                    }
                }
            }    
        }
    }

    return S_OK;
}
HRESULT
CMarkup::SetPrintTemplateExplicit(BOOL f)
{
    if (f || HasEditContext())
    {
        CMarkupEditContext * pContext = EnsureEditContext();

        if (!pContext)
            return E_OUTOFMEMORY;
    
        pContext->_fIsPrintTemplateExplicit = f;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::GetFrameOptions
//  
//  Synopsis:   Gets the frame options
//  
//  Returns:    DWORD that is the frame options
//  
//+----------------------------------------------------------------------------
DWORD
CMarkup::GetFrameOptions()
{
    DWORD dwFrameOptions;
    
    dwFrameOptions = ( HasEditContext() ? GetEditContext()->_dwFrameOptions : 0 );
    
    if ( Doc()->_fViewLinkedInWebOC && IsPrimaryMarkup() )
    {
        HRESULT hr;
        COleSite *pOleSite;
        
        hr = IUnknown_QueryService(Doc()->_pClientSite, CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void**)&pOleSite);
        if (!hr)
        {
            CMarkup *pMarkup;
            pMarkup = pOleSite->GetWindowedMarkupContext();
            if (pMarkup)
            {
                dwFrameOptions = pMarkup->GetFrameOptions();
            }
        }
    }

    return dwFrameOptions;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetFrameOptions
//  
//  Synopsis:   Sets the frame options
//  
//  Returns:    HRESULT
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetFrameOptions(DWORD dwFrameOptions)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_dwFrameOptions = dwFrameOptions;
    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetMapHead
//  
//  Synopsis:   Sets the CMapElement 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CMapElement *pMap = Map
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetMapHead(CMapElement *pMap)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    Assert( pMap );
    pContext->_pMapHead = pMap;

    return S_OK;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetRadioGroupName
//  
//  Synopsis:   Sets the RADIOGRPNAME 
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          RADIOGRPNAME * pRadioGrpName
//  
//+----------------------------------------------------------------------------
HRESULT
CMarkup::SetRadioGroupName(RADIOGRPNAME * pRadioGrpName)
{
    CMarkupEditContext * pContext = EnsureEditContext();

    if( !pContext )
    {
        return E_OUTOFMEMORY;
    }

    pContext->_pRadioGrpName = pRadioGrpName;

    return S_OK;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::DelRadioGroupName
//  
//  Synopsis:   Removes and deletes the list of radio group names
//
//+----------------------------------------------------------------------------
void
CMarkup::DelRadioGroupName()
{    
    Assert( HasRadioGroupName() );

    CMarkupEditContext * pContext      = GetEditContext();
    RADIOGRPNAME       * pRadioGrpName = pContext->_pRadioGrpName;

    do
    {
        RADIOGRPNAME  *pNextRadioGrpName = pRadioGrpName->_pNext;

        SysFreeString((BSTR)pRadioGrpName->lpstrName);
        delete pRadioGrpName;
        pRadioGrpName = pNextRadioGrpName;
    } 
    while (pRadioGrpName);

    pContext->_pRadioGrpName = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ShowWaitCursor
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
void
CMarkup::ShowWaitCursor(BOOL fShowWaitCursor)
{
    if (!!_fShowWaitCursor != !!fShowWaitCursor)
    {
        _fShowWaitCursor = fShowWaitCursor;
        if (_pDoc->_fHasViewSlave )
        {
            CNotification nf;
            
            nf.ShowWaitCursor(Root());
            nf.SetData((DWORD)(!!_fShowWaitCursor));
            Notify(&nf);
        }
        _pDoc->SendSetCursor(0);
    }
}

HRESULT
CMarkup::GetClassID( CLSID * pclsid )
{
    return E_NOTIMPL;
}

HRESULT
CMarkup::IsDirty()
{
    RRETURN1( ( __lMarkupContentsVersion & MARKUP_DIRTY_FLAG ) ? S_OK : S_FALSE, S_FALSE );
}

HRESULT
CMarkup::Load( LPSTREAM pStream )
{
    return E_NOTIMPL;
}

HRESULT
CMarkup::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    HRESULT hr;

    hr = THR( SaveToStream( pStream ) );
    if( hr )
        goto Cleanup;

    if( fClearDirty )
    {
        ClearDirtyFlag();
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CMarkup::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetThemeHelper
//
//  Returns:    HTHEME
//
//----------------------------------------------------------------------------

HTHEME
CMarkup::GetThemeHelper(THEMECLASSID themeId)
{
    if (!HasWindow() && !HasWindowPending() && HasWindowedMarkupContextPtr())
    {
        return GetWindowedMarkupContextPtr()->GetThemeHelper(themeId);
    }
    else if ( GetThemeUsage() == THEME_USAGE_ON || 
            ((GetThemeUsage() == THEME_USAGE_DEFAULT) && (themeId == THEME_SCROLLBAR)) )
    {
        return GetThemeHandle(_pDoc->_pInPlace ? _pDoc->_pInPlace->_hwnd : GetDesktopWindow(), themeId);
    }
    return NULL;
}

BOOL
IsHtmlLayoutHelper(CMarkup * pMarkup)
{
    return pMarkup && pMarkup->IsHtmlLayout();
}

HRESULT                  
CMarkup::SetImageFile(BOOL fImageFile)
{
    HRESULT hr                          = S_OK;
    CMarkupLocationContext * pContext   = NULL;

    if( fImageFile )
    {
        pContext = EnsureLocationContext();
        if( !pContext )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pContext->_fImageFile = TRUE;
    }
    else
    {
        //if we already have context, clear the bit.
        //if no context or no bit set, nothing should be done
        if(IsImageFile())
            GetLocationContext()->_fImageFile = FALSE;
    }

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetCookie
//  
//  Synopsis:   
//
//+----------------------------------------------------------------------------

void
CMarkup::SetCookieOnUIThread(DWORD_PTR pVoid)
{
    MarkupCookieStruct * pmcs = (MarkupCookieStruct*)pVoid;
    SetPrivacyInfo(&pmcs->lpszP3PHeader);
    SetCookie(pmcs->lpszUrl, pmcs->lpszCookieName, pmcs->lpszCookieData);
    Assert(pmcs->lpszCookieName == NULL); //this should only be called from CHtmPre::HandleMETA
    MemFreeString(pmcs->lpszUrl);
    MemFreeString(pmcs->lpszCookieData);
    delete pmcs;
}

BOOL
CMarkup::SetCookie(LPCTSTR lpszUrl, 
                   LPCTSTR lpszCookieName, 
                   LPCTSTR lpszCookieData)
{
    DWORD             bSet           = 0;
    DWORD             dwPrivacyFlags = 0;
    DWORD             dwFlags        = 0;
    TCHAR           * pchP3PHeader   = NULL; 
    CPrivacyInfo    * pPrivacyInfo   = NULL;    
    
    pPrivacyInfo = GetPrivacyInfo();
    if (pPrivacyInfo)
    {            
        pchP3PHeader = pPrivacyInfo->_pchP3PHeader;
        if (!pchP3PHeader)
           pchP3PHeader = _T("");
    }                
    else
    {
        pchP3PHeader = _T("");
    }

    if ((HasWindow() && Window()->Window()->_fRestricted) || 
        (HasWindowedMarkupContextPtr() && 
         GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
         dwFlags |= INTERNET_FLAG_RESTRICTED_ZONE;
       
    dwFlags |= IsMarkupThirdParty() ? INTERNET_COOKIE_THIRD_PARTY     : 0;
    dwFlags |= INTERNET_COOKIE_EVALUATE_P3P;

    bSet = InternetSetCookieEx(lpszUrl, lpszCookieName, lpszCookieData, dwFlags, (DWORD_PTR)pchP3PHeader);

    switch((InternetCookieState)bSet)
    {
    case COOKIE_STATE_ACCEPT:
        dwPrivacyFlags |= COOKIEACTION_ACCEPT;        
        break;
    case COOKIE_STATE_PROMPT:
        AssertSz(0, "InternetSetCookieEx should not pass back prompt for cookie state");
        break;
    case COOKIE_STATE_UNKNOWN:
        // we'll get this for cookie rejected for reasons other than privacy
        break;
    case COOKIE_STATE_REJECT:        
        dwPrivacyFlags |= COOKIEACTION_REJECT;
        break;
    case COOKIE_STATE_LEASH:
        dwPrivacyFlags |= COOKIEACTION_LEASH;
        break;
    case COOKIE_STATE_DOWNGRADE:
        dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
        break;
    default:
        ;
    }                    
    
    THR(Doc()->AddToPrivacyList(lpszUrl, NULL, dwPrivacyFlags));

    return bSet;
}


BOOL
CMarkup::GetCookie(LPCTSTR lpszUrlName, LPCTSTR lpszCookieName, LPTSTR lpszCookieData, DWORD *lpdwSize)
{
    BOOL            bRet           = FALSE;
    long            dwPrivacyFlags = COOKIEACTION_READ; 
    DWORD           dwFlags        = 0;        
    
    dwFlags = IsMarkupThirdParty() ? INTERNET_COOKIE_THIRD_PARTY : 0;

    bRet = InternetGetCookieEx( lpszUrlName, 
                                lpszCookieName, 
                                lpszCookieData, 
                                lpdwSize, 
                                dwFlags,
                                NULL);

    // We want to set the suppress bit only if we didn't fail due to other errors like
    // insufficient buffer error or cookie did not exist. We are depending on the fact 
    // that Wininet does not set the LastError info if cookie is suppressed due to 
    // privacy settings. If they ever change the behavior to set a specific error, we
    // need to check for that instead.
    if (!bRet && !GetLastError()) 
    {
        // We are not using |= to mimic wininet's behavior which does not set the READ flag when suppressing
        dwPrivacyFlags = COOKIEACTION_SUPPRESS;
    }

    THR(Doc()->AddToPrivacyList(lpszUrlName, NULL, dwPrivacyFlags));

    return bRet;
}


BOOL
CMarkup::IsMarkupThirdParty()
{
    CMarkup   * pMarkupContext = GetWindowedMarkupContext();

    if (pMarkupContext)
    {
        CDwnDoc * pDwnDoc = pMarkupContext->GetDwnDoc();

        if (pDwnDoc)
        {
            BYTE  abRootSID[MAX_SIZE_SECURITY_ID];
            DWORD cbRootSID = ARRAY_SIZE(abRootSID);
            BYTE  abCookieSID[MAX_SIZE_SECURITY_ID];
            DWORD cbCookieSID = ARRAY_SIZE(abCookieSID);

            if (    S_OK == pDwnDoc->GetSecurityID(abRootSID, &cbRootSID)
                &&  S_OK == GetSecurityID(abCookieSID, &cbCookieSID, CMarkup::GetUrl(this)))
            {
                if (S_FALSE == CompareSecurityIds(abRootSID, cbRootSID, abCookieSID, cbCookieSID, 0))
                    return TRUE;
            }
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  
//  Method:     CMarkup::SetPrivacyInfo
//  
//  Synopsis:   Stores the privacy information bubbled up by wininet/urlmon  
//              to be used when setting cookies through script
//  
//  Returns:    HRESULT indicating success or failure when setting the 
//              lookaside pointer
//  
//  Arguments:  p3pheader
//              We now own the memory passed in p3pheader and need to free it
//              appropriately
//  
//+----------------------------------------------------------------------------

HRESULT
CMarkup::SetPrivacyInfo(LPTSTR * ppchP3PHeader)
{ 
    HRESULT           hr             = S_OK;
    CPrivacyInfo    * pPrivacyInfo   = NULL;
    BOOL              fHasPrivacyPtr = FALSE;
    BOOL              fHasP3PHeader = (ppchP3PHeader && *ppchP3PHeader && **ppchP3PHeader);
    

    // Do we need to create the lookaside on the markup for the privacy info?
    if (!fHasP3PHeader)
    {
        goto cleanup;
    }

    fHasPrivacyPtr = HasPrivacyInfo();

    if (fHasPrivacyPtr)
    {
        pPrivacyInfo = GetPrivacyInfo();
    }
    else 
    {
        pPrivacyInfo = new CPrivacyInfo();
        
        if (!pPrivacyInfo)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if (fHasP3PHeader)
    {
        delete [] pPrivacyInfo->_pchP3PHeader;
        pPrivacyInfo->_pchP3PHeader = *ppchP3PHeader;
    }

    if (!fHasPrivacyPtr)
    {
        hr = SetLookasidePtr(LOOKASIDE_PRIVACY, pPrivacyInfo);
        if (FAILED(hr))
        {
            // Need to set the p3p hdr to null since we delete
            // the parameter in cleanup. Else the destructor for
            // the class also ends up deleting the same piece of memory
            pPrivacyInfo->_pchP3PHeader = NULL;
            delete pPrivacyInfo;
        }
    }

cleanup:
    if (FAILED(hr) && fHasP3PHeader)
        delete [] *ppchP3PHeader;

    if (fHasP3PHeader) 
        *ppchP3PHeader = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\jsprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       jsprot.cxx
//
//  Contents:   Implementation of the javascript: protocol
//
//  History:    01-14-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

MtDefine(CJSProtocol,  Protocols, "CJSProtocol")
MtDefine(JSProtResult, Protocols, "JavaScript protocol evaluation (temp)")
MtDefine(CJSProtocolParseAndBind_pbOutput, Protocols, "CJSProtocol::ParseAndBind pbOutput")
ExternTag(tagSecurityContext);

HRESULT VariantToPrintableString (VARIANT * pvar, CStr * pstr);

#define WRITTEN_SCRIPT _T("<<HTML><<SCRIPT LANGUAGE=<0s>>var __w=<1s>;if(__w!=null)document.write(__w);<</SCRIPT><</HTML>")

//+---------------------------------------------------------------------------
//
//  Function:   CreateJSProtocol
//
//  Synopsis:   Creates a javascript: Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateJSProtocol(IUnknown *pUnkOuter)
{
    return new CJSProtocol(pUnkOuter);
}


CJSProtocolCF   g_cfJSProtocol(CreateJSProtocol);

//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CJSProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr    cstr;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_SECURITY_URL)
    {
        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;

        *pcchResult = cstr.Length() + 1;
        
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcscpy(pwzResult, cstr);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }
    
Cleanup:    
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CJSProtocol::s_classdesc =
{
    &CLSID_JSProtocol,              // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::CJSProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CJSProtocol::CJSProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::~CJSProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CJSProtocol::~CJSProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CJSProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pchScript = NULL;
    CVariant        Var;
    CStr            cstrResult;
    CStr            cstrProtocol;
    CROStmOnBuffer *prostm = NULL;
    UINT            uProt;
    IHTMLWindow2 *  pHTMLWindow = NULL;
    CWindow *       pWindow = NULL;
    TCHAR *         pchOutput = NULL;
    BYTE *          pbOutput = NULL;
    long            cb = 0;
    BOOL            fAllow = FALSE;
    DWORD           dwPolicyTo;
    CScriptCollection * pScriptCollection = NULL;    

    // skip protocol part
    pchScript = _tcschr(_cstrURL, ':');
    if (!pchScript)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    hr = THR(cstrProtocol.Set(_cstrURL, pchScript - _cstrURL));
    if (hr)
        goto Cleanup;

    // Go past the :
    pchScript++;
    
    uProt = GetUrlScheme(_cstrURL);
    Assert(URL_SCHEME_VBSCRIPT == uProt || 
           URL_SCHEME_JAVASCRIPT == uProt);
    
    hr = THR(QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **) &pHTMLWindow));

    if (hr == S_OK)
    {
        hr = pHTMLWindow->QueryInterface(CLSID_HTMLWindow2, (void **) &pWindow);
        if (hr)
            goto Cleanup;

        pScriptCollection = pWindow->_pMarkup->GetScriptCollection();

        // check cross domain access rights for this script
        if (pScriptCollection)
        {
            CStr    cstrSourceUrl;
            TCHAR * pchUrl = NULL;

            //
            TraceTag((tagSecurityContext, "CJSProtocol::ParseAndBind - GetBindInfoParam"));

            // Get the security ID for the parent document, if the bind context carries one
            if (S_OK == GetBindInfoParam(_pOIBindInfo, &cstrSourceUrl))
                pchUrl = cstrSourceUrl;

            // check if the security settings allow running scripts for this domain
            hr = THR(pWindow->_pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                         &fAllow, 
                                                         0, 
                                                         &dwPolicyTo, 
                                                         pchUrl));
            if (hr)
                goto Cleanup;

            // Only allow script to execute if security settings allow it and security context's match
            //
            if (fAllow && cstrSourceUrl.Length() && 
                !pWindow->_pMarkup->AccessAllowed(cstrSourceUrl))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }
    else
    {
        fAllow = TRUE;
    }

    if (fAllow)
    {
        if (pScriptCollection)
        {
            // Any errors from this are ignored so URLMON doesn't throw
            // an exception to IE which causes them to shutdown due to an
            // unexpected error. -- TerryLu.
            IGNORE_HR(pScriptCollection->ParseScriptText(
                        cstrProtocol,           // pchLanguage
                        NULL,                   // pMarkup
                        NULL,                   // pchType
                        pchScript,              // pchCode
                        DEFAULT_OM_SCOPE,       // pchItemName
                        NULL,                   // pchDelimiter
                        0,                      // ulOffset
                        0,                      // ulStartingLine
                        NULL,                   // pSourceObject
                        SCRIPTTEXT_ISVISIBLE | SCRIPTTEXT_ISEXPRESSION, // dwFlags
                        &Var,                   // pvarResult
                        NULL));                 // pExcepInfo

            if (V_VT(&Var) != VT_EMPTY)
            {
                hr = THR(VariantToPrintableString(&Var, &cstrResult));
                if (hr)
                    goto Cleanup;

                hr = THR(MemAllocString(Mt(JSProtResult), cstrResult, &pchOutput));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                //
                // There was no output from the script.  Since we got back
                // a document from the target frame, abort now.
                //
            
                hr = E_ABORT;
            }
        }
        else
        {
            //
            // New document.  Execute script in this new 
            // document's context.
            //

            hr = THR(Format(
                    FMT_OUT_ALLOC,
                    &pchOutput,
                    0,
                    WRITTEN_SCRIPT,
                    (LPTSTR)cstrProtocol,
                    pchScript));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Convert string into a stream.
    //

    if (pchOutput)
    {
        cb = WideCharToMultiByte(
                _bindinfo.dwCodePage,
                0, 
                pchOutput, 
                -1, 
                NULL, 
                0,
                NULL, 
                NULL);

        pbOutput = new(Mt(CJSProtocolParseAndBind_pbOutput)) BYTE[cb + 1];
        if (!pbOutput)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(
                _bindinfo.dwCodePage,
                0, 
                pchOutput, 
                -1, 
                (char *)pbOutput, 
                cb,
                NULL, 
                NULL);
        
        prostm = new CROStmOnBuffer();
        if (!prostm)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(prostm->Init(pbOutput, cb));
        if (hr)
            goto Cleanup;
            
        _pStm = (IStream *)prostm;
        _pStm->AddRef();
    }
    
Cleanup:
    if (!_fAborted)
    {
        if (!hr)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, CFSTR_MIME_HTML);

            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, cb, cb);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    ReleaseInterface(pHTMLWindow);
    if (prostm)
    {
        prostm->Release();
    }
    MemFreeString(pchOutput);
    delete pbOutput;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\markupundo.cxx ===
//+---------------------------------------------------------------------
//
//   File:      markupundo.cxx
//
//  Contents:   Undo of markup changes
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "seglist.hxx"
#endif

MtDefine(CInsertElementUndoUnit, Undo, "CInsertElementUndoUnit")
MtDefine(CRemoveElementUndoUnit, Undo, "CRemoveElementUndoUnit")
MtDefine(CInsertTextUndoUnit, Undo, "CInsertTextUndoUnit")
MtDefine(CRemoveTextUndoUnit, Undo, "CRemoveTextUndoUnit")
MtDefine(CRemoveTextUndoUnit_pchText, CRemoveTextUndoUnit, "CRemoveTextUndoUnit::pchText")
MtDefine(CInsertSpliceUndoUnit, Undo, "CInsertSpliceUndoUnit")
MtDefine(CRemoveSpliceUndoUnit, Undo, "CRemoveSpliceUndoUnit")
MtDefine(CSelectionUndoUnit, Undo, "CSelectionUndoUnit")
MtDefine(CDeferredSelectionUndoUnit, Undo, "CDeferredSelectionUndoUnit")

DeclareTag(tagUndoSel, "Undo", "Selection Undo ");

//---------------------------------------------------------------------------
//
// CUndoHelper
//
//---------------------------------------------------------------------------

BOOL 
CUndoHelper::UndoDisabled()
{
    return FALSE;
}

HRESULT 
CUndoHelper::CreateAndSubmit( BOOL fDirtyChange /*=TRUE*/)
{
    HRESULT         hr = S_OK;
    IOleUndoUnit *  pUU = NULL;

    if( !UndoDisabled() && _pDoc->QueryCreateUndo( TRUE, fDirtyChange ) )
    {
        pUU = CreateUnit();
        if( !pUU )
        {
            if( fDirtyChange )
                _pDoc->FlushUndoData();

            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( _pDoc->UndoManager()->Add( pUU ) ) ;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if( pUU )
        pUU->Release();

    RRETURN( hr );
}

BOOL
CUndoHelper::AcceptingUndo()
{
    // Query if we create undo but don't flush the stack
    return !UndoDisabled() && _pDoc->QueryCreateUndo( TRUE, FALSE );
}

//---------------------------------------------------------------------------
//
// CInsertElementUndo
//
//---------------------------------------------------------------------------

void    
CInsertElementUndo::SetData( CElement* pElement )
{ 
    Assert( !_pElement );
    CElement::SetPtr( &_pElement, pElement ); 
}

IOleUndoUnit * 
CInsertElementUndo::CreateUnit()
{
    CInsertElementUndoUnit * pUU;

    Assert( _pElement );

    TraceTag((tagUndo, "CInsertElementUndo::CreateUnit"));

    pUU = new CInsertElementUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pElement, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CInsertElementUndoUnit
//
//---------------------------------------------------------------------------

CInsertElementUndoUnit::CInsertElementUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT )
{
}

CInsertElementUndoUnit::~CInsertElementUndoUnit()
{ 
    CElement::ReleasePtr( _pElement ); 
}

void    
CInsertElementUndoUnit::SetData( CElement * pElement, DWORD dwFlags )
{ 
    Assert( !_pElement );
    CElement::SetPtr( &_pElement, pElement );
    _dwFlags = dwFlags;
}

HRESULT
CInsertElementUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;

    Assert( _pElement );
    Assert( _pElement->IsInMarkup() );

    hr = THR( _pElement->Doc()->RemoveElement( _pElement, _dwFlags ) );

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CRemoveElementUndo
//
//---------------------------------------------------------------------------

CRemoveElementUndo::CRemoveElementUndo( CMarkup * pMarkup, CElement * pElementRemove, DWORD dwFlags ) 
    : CMarkupUndoBase( pMarkup->Doc(), pMarkup, dwFlags ), _pElement( NULL )
{
    _fAcceptingUndo = CMarkupUndoBase::AcceptingUndo();

    if( _fAcceptingUndo )
    {
        CElement::SetPtr( &_pElement, pElementRemove );
    }
}

void
CRemoveElementUndo::SetData(
    long cpBegin, 
    long cpEnd )
{
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
}

IOleUndoUnit * 
CRemoveElementUndo::CreateUnit()
{
    CRemoveElementUndoUnit * pUU;

    Assert( _fAcceptingUndo );
    Assert( _pElement );

    TraceTag((tagUndo, "CRemoveElementUndo::CreateUnit"));

    pUU = new CRemoveElementUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pMarkup, _pElement, _cpBegin, _cpEnd, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CRemoveElementUndoUnit
//
//---------------------------------------------------------------------------
CRemoveElementUndoUnit::CRemoveElementUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
}


CRemoveElementUndoUnit::~CRemoveElementUndoUnit()               
{ 
    CMarkup::ReleasePtr( _pMarkup ); 
    CElement::ReleasePtr( _pElement ); 
}

void    
CRemoveElementUndoUnit::SetData( 
    CMarkup * pMarkup, 
    CElement* pElement, 
    long cpBegin, 
    long cpEnd,
    DWORD dwFlags )
{
    Assert( !_pMarkup && !_pElement );

    CMarkup::SetPtr( &_pMarkup, pMarkup );
    CElement::SetPtr( &_pElement, pElement );
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
    _dwFlags = dwFlags;
}

HRESULT
CRemoveElementUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = _pMarkup->Doc();
    CMarkupPointer mpBegin(pDoc), mpEnd(pDoc);

    Assert( _pElement );

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveToCp( _cpEnd, _pMarkup ) );
    if (hr)
        goto Cleanup;

    // The element may have gotten ensured into a markup while it was in the
    // undo stack.  There is no undo unit to pull it out of there, so we have
    // to do it now.
    if( _pElement->IsInMarkup() )
    {
        Assert( _pElement->GetMarkupPtr()->_fEnsuredMarkupDbg );

        hr = THR( _pElement->GetMarkupPtr()->RemoveElementInternal( _pElement ) );
        if( hr )
            goto Cleanup;
    }

    Assert( ! _pElement->IsInMarkup() );

    hr = THR( pDoc->InsertElement( _pElement, & mpBegin, & mpEnd, _dwFlags ) );

Cleanup:
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CInsertSpliceUndo
//
//---------------------------------------------------------------------------
IOleUndoUnit * 
CInsertSpliceUndo::CreateUnit()
{
    CInsertSpliceUndoUnit * pUU = NULL;

    Assert( _cpBegin >= 0 );

    TraceTag((tagUndo, "CInsertSpliceUndo::CreateUnit"));

    pUU = new CInsertSpliceUndoUnit( _pMarkup->Doc() );

    if (pUU)
    {
        pUU->SetData( _pMarkup, _cpBegin, _cpEnd, _dwFlags );
    }

    return pUU;
}

//---------------------------------------------------------------------------
//
// CInsertSpliceUndoUnit
//
//---------------------------------------------------------------------------
CInsertSpliceUndoUnit::CInsertSpliceUndoUnit(CDoc * pDoc)
    : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
    _cpBegin = -1;
}

CInsertSpliceUndoUnit::~CInsertSpliceUndoUnit()
{
    CMarkup::ReleasePtr( _pMarkup );
}

void
CInsertSpliceUndoUnit::SetData(
    CMarkup * pMarkup, 
    long cpBegin, 
    long cpEnd,
    DWORD dwFlags )
{
    Assert( !_pMarkup );

    CMarkup::SetPtr( &_pMarkup, pMarkup );
    _cpBegin = cpBegin;
    _cpEnd = cpEnd;
    _dwFlags = dwFlags;
}

HRESULT
CInsertSpliceUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = _pMarkup->Doc();
    CMarkupPointer  mpBegin(pDoc), mpEnd(pDoc);

    Assert( _cpBegin >= 0 );

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveToCp( _cpEnd, _pMarkup ) );
    
    if (hr)
        goto Cleanup;

    hr = THR( pDoc->Remove( & mpBegin, & mpEnd, _dwFlags ) );

Cleanup:
    
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CRemoveSpliceUndo
//
//---------------------------------------------------------------------------
CRemoveSpliceUndo::CRemoveSpliceUndo( CDoc * pDoc ) 
    : CMarkupUndoBase( pDoc, NULL, NULL )
{
    _paryRegion = NULL;
    _pchRemoved = NULL;
    _cpBegin = -1;
}

void 
CRemoveSpliceUndo::Init( CMarkup * pMarkup, DWORD dwFlags )
{
    CMarkupUndoBase::Init( pMarkup, dwFlags );

    _fAcceptingUndo = CMarkupUndoBase::AcceptingUndo();
}

void
CRemoveSpliceUndo::SetText( long cpBegin, long cchRemoved, TCHAR * pchRemoved )
{
    Assert( AcceptingUndo() );

    _cpBegin    = cpBegin;
    _cchRemoved = cchRemoved;
    _pchRemoved = pchRemoved;
}


IOleUndoUnit * 
CRemoveSpliceUndo::CreateUnit()
{
    CRemoveSpliceUndoUnit * pUU = NULL;

    if( _paryRegion && _pchRemoved )
    {
        Assert( _cpBegin >= 0 );

        TraceTag((tagUndo, "CRemoveSpliceUndo::CreateUnit"));

        pUU = new CRemoveSpliceUndoUnit( _pMarkup->Doc() );

        if (pUU)
        {
            // The undo unit owns the string 
            // and list after this

            pUU->SetData( _pMarkup, 
                          _paryRegion,
                          _cchRemoved, 
                          _pchRemoved, 
                          _cpBegin,
                          _dwFlags );
            
            _paryRegion = NULL;
            _pchRemoved = NULL;
        }
    }

    return pUU;
}

BOOL    
CRemoveSpliceUndo::AcceptingUndo()
{
    return _fAcceptingUndo;
}


//---------------------------------------------------------------------------
//
// CRemoveSpliceUndoUnit
//
//---------------------------------------------------------------------------

CRemoveSpliceUndoUnit::CRemoveSpliceUndoUnit(CDoc * pDoc)
            : CUndoUnitBase( pDoc, IDS_UNDOGENERICTEXT ) 
{
}

CRemoveSpliceUndoUnit::~CRemoveSpliceUndoUnit()
{
    CMarkup::ReleasePtr( _pMarkup );
    delete _paryRegion;
    MemFree(_pchRemoved);
}

void    
CRemoveSpliceUndoUnit::SetData( CMarkup * pMarkup, CSpliceRecordList * paryRegion, 
                                long cchRemoved, TCHAR * pchRemoved, 
                                long cpBegin, DWORD dwFlags )
{
    CMarkup::SetPtr( &_pMarkup, pMarkup );
    _paryRegion = paryRegion;
    _cchRemoved = cchRemoved;
    _pchRemoved = pchRemoved;
    _cpBegin = cpBegin;
    _dwFlags = dwFlags;
}

HRESULT
CRemoveSpliceUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pMarkup->Doc();

    Assert( _cpBegin >= 0 );

    CMarkupPointer mpBegin(pDoc);

    hr = THR( mpBegin.MoveToCp( _cpBegin, _pMarkup ) );
    if (hr)
        goto Cleanup;

    hr = THR( _pMarkup->UndoRemoveSplice( 
                &mpBegin, _paryRegion, _cchRemoved, _pchRemoved, _dwFlags ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\meta.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       meta.cxx
//
//  Contents:   META tag processing
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifdef WIN16
DeclareTag(tagShDocMetaRefresh, "ShDocVwSkel", "HTTP (and meta) Refresh");
#endif

DeclareTag(tagMeta, "Meta", "Trace meta tags");

MtDefine(CDoc_pvPics, CDoc, "CDoc::_pvPics buffer")

#ifdef WIN16
#define BSTRPAD _T("    ")
#else
#  ifdef UNIX
     // On Unix sizeof(WCHAR) == 4
#    define BSTRPAD _T(" ")
#  else
     // or can be 4 ansi spaces.
#    define BSTRPAD _T("  ")
#  endif // UNIX
#endif

BOOL ParseRefreshContent(LPCTSTR pchContent,
    UINT * puiDelay, LPTSTR pchUrlBuf, UINT cchUrlBuf)
{
    // We are parsing the following string:
    //
    //  [ws]* [0-9]+ { ws | ; }* url [ws]* = [ws]* { ' | " } [any]* { ' | " }
    //
    // Netscape insists that the string begins with a delay.  If not, it
    // ignores the entire directive.  There can be more than one URL mentioned,
    // and the last one wins.  An empty URL is treated the same as not having
    // a URL at all.  An empty URL which follows a non-empty URL resets
    // the previous URL.

    enum { PRC_START, PRC_DIG, PRC_DIG_WS_SEMI, PRC_DIG_DOT, PRC_SEMI_URL,
        PRC_SEMI_URL_EQL, PRC_SEMI_URL_EQL_ANY };
    #define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

    UINT uiState = PRC_START;
    UINT uiDelay = 0;
    LPCTSTR pch = pchContent;
    LPTSTR  pchUrl = NULL;
    UINT    cchUrl = 0;
    TCHAR   ch, chDel = 0;

    *pchUrlBuf = 0;

    do
    {
        ch = *pch;

        switch (uiState)
        {
            case PRC_START:
                if (ch >= '0' && ch <= '9')
                {
                    uiState = PRC_DIG;
                    uiDelay = ch - '0';
                }
                else if (ch == '.')
                    uiState = PRC_DIG_DOT;
                else if (!ISSPACE(ch))
                    goto done;
                break;

            case PRC_DIG:
                if (ch >= '0' && ch <= '9')
                    uiDelay = uiDelay * 10 + ch - '0';
                else if (ch == '.')
                    uiState = PRC_DIG_DOT;
                else if (ISSPACE(ch) || ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else
                    goto done;
                break;

            case PRC_DIG_DOT:
                if (ISSPACE(ch) || ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if ((ch < '0' || ch > '9') && (ch != '.'))
                    goto done;
                break;

            case PRC_DIG_WS_SEMI:
                if (    (ch == 'u' || ch == 'U')
                    &&  (pch[1] == 'r' || pch[1] == 'R')
                    &&  (pch[2] == 'l' || pch[2] == 'L'))
                {
                    uiState = PRC_SEMI_URL;
                    pch += 2;
                }
                else if (!ISSPACE(ch) && ch != ';')
                    goto done;
                break;

            case PRC_SEMI_URL:
                if (ch == '=')
                {
                    uiState = PRC_SEMI_URL_EQL;
                    *pchUrlBuf = 0;
                }
                else if (ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if (!ISSPACE(ch))
                    goto done;
                break;

            case PRC_SEMI_URL_EQL:
                if (ch == ';')
                    uiState = PRC_DIG_WS_SEMI;
                else if (!ISSPACE(ch))
                {
                    uiState = PRC_SEMI_URL_EQL_ANY;

                    pchUrl = pchUrlBuf;
                    cchUrl = cchUrlBuf;

                    if (ch == '\''|| ch == '\"')
                        chDel = ch;
                    else
                    {
                        chDel = 0;
                        *pchUrl++ = ch;
                        cchUrl--;
                    }
                }
                break;
                        
            case PRC_SEMI_URL_EQL_ANY:
                if (    !ch
                    ||  ( chDel && ch == chDel)
                    ||  (!chDel && ch == ';'))
                {
                    *pchUrl = 0;
                    uiState = PRC_DIG_WS_SEMI;
                }
                else if (cchUrl > 1)
                {
                    *pchUrl++ = ch;
                    cchUrl--;
                }
                break;
        }

        ++pch;

    } while (ch);

done:

    *puiDelay = uiDelay;

    return(uiState >= PRC_DIG);
}

void
CMarkup::ProcessMetaPics( LPCTSTR pchContent, BOOL fInHeader )
{
    CDoc * pDoc = Doc();
    IOleCommandTarget * pct = GetPicsTarget();
    HRESULT hr;

    if (pct)
    {
        VARIANT var;
        TCHAR *pch;
        DWORD *plen;

        VariantInit(&var);
        var.vt = VT_BSTR;

        // We've got a command target, just send up the string.
        if (Format(FMT_OUT_ALLOC, &pch, 0, BSTRPAD _T("<0s>"), pchContent) == S_OK)
        {
            plen = (DWORD *)pch;
            var.bstrVal = (BSTR) ((LPBYTE) pch + sizeof(DWORD));
            *plen = _tcslen(var.bstrVal) * sizeof(TCHAR);
            pct->Exec(&CGID_ShellDocView, fInHeader ? SHDVID_PICSLABELFOUNDINHTTPHEADER : SHDVID_PICSLABELFOUND, 0, &var, NULL);
            delete (pch);
        }

    }
    else if (pDoc->_fStartup && pDoc->_pvPics != (void *)(LONG_PTR)(-1) && IsPrimaryMarkup())
    {
        // No command target yet.  Save the string until it becomes
        // available later.

        UINT cbOld = pDoc->_pvPics ? *(DWORD *)pDoc->_pvPics : sizeof(DWORD);
        UINT cbNew = (_tcslen(pchContent) + 1) * sizeof(TCHAR);

        hr = MemRealloc(Mt(CDoc_pvPics), &pDoc->_pvPics, cbOld + cbNew);

        if (hr == S_OK)
        {
            *(DWORD *)pDoc->_pvPics = cbOld + cbNew;
            memcpy((BYTE *)pDoc->_pvPics + cbOld, pchContent, cbNew);
        }
    }
}

void    
CMarkup::ProcessMetaPicsDone()
{
    IOleCommandTarget * pct = GetPicsTarget();

    if (pct)
    {
        pct->Exec(&CGID_ShellDocView, SHDVID_NOMOREPICSLABELS, 0, NULL, NULL);
        SetPicsTarget(NULL);
    }
}

void
CMarkup::ProcessHttpEquiv(LPCTSTR pchHttpEquiv, LPCTSTR pchContent)
{
    VARIANT var;
    TCHAR *pch;
    DWORD *plen;
    BOOL fRefresh;
    BOOL fExpireImmediate;
    const TCHAR * pchUrl;
    HRESULT hr;
    CDoc * pDoc = Doc();
    CDocument *pDocument = Document();

    TraceTag((tagMeta, "META http-equiv=\"%S\" content=\"%S\"", pchHttpEquiv, pchContent));

    // All http-equiv must be given to us before parsing is complete.  If
    // not, then we are probably parsing for paste and came across a <META>
    // tag.  Just ignore it.

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        TraceTag((tagMeta, "META _LoadStatus >= LOADSTATUS_PARSE_DONE, we're outta here"));
        return;
    }

    VariantInit(&var);
    var.vt = VT_BSTR;

    // Special case for "PICS-Label" until it gets merged with normal
    // command target mechanism in the shell.

    if (IsPrimaryMarkup() && pDoc->_fStartup && StrCmpIC(pchHttpEquiv, _T("PICS-Label")) == 0)
    {
        ProcessMetaPics( pchContent );
    }

    fRefresh = StrCmpIC(pchHttpEquiv, _T("Refresh")) == 0;

    if (    pDoc->_pClientSite
        &&  (   !(pDoc->_dwLoadf & DLCTL_NO_CLIENTPULL)
            ||  !fRefresh))
    {
        TCHAR   ach[pdlUrlLen];
        UINT    uiDelay;
        TCHAR   cBuf[pdlUrlLen] = {0};
        TCHAR * pchUrl = cBuf;

        // If this is a Refresh header, we have to get the URL and expand
        // it because it could be relative.

        if (fRefresh)
        {
            if (ParseRefreshContent(pchContent, &uiDelay, ach, ARRAY_SIZE(ach)))
            {
                if (ach[0])
                {
                    // Netscape ignores any BASE tags which come before the <META>
                    // when expanding the relative URL.  So do we.

                    hr = THR(CMarkup::ExpandUrl(this, ach, ARRAY_SIZE(cBuf),
                                                pchUrl, EXPANDIGNOREBASETAGS));
                }

                if (HasWindowPending())
                {
                    GetWindowPending()->Window()->ProcessMetaRefresh(pchUrl, uiDelay);
                }
            }
        }
        else if (Format(FMT_OUT_ALLOC, &pch, 0, BSTRPAD _T("<0s>:<1s>"), pchHttpEquiv, pchContent) == S_OK)
        {
            // Send to the command target of the client site.  Note that
            // the string needs to be in the format http-equiv:content.

            plen = (DWORD *)pch;
            var.bstrVal = (BSTR) ((LPBYTE) pch + sizeof(DWORD));
            *plen = _tcslen(var.bstrVal) * sizeof(TCHAR);

            Assert(pDoc->_pClientSite);
        
            CTExec(pDoc->_pClientSite, NULL, OLECMDID_HTTPEQUIV, 0, &var, NULL);
            TraceTag((tagMeta, "META Invoking OLECMDID_HTTPEQUIV"));

            MemFree(pch);

            // Save the page transition info on the document to be used later
            // If this is not a page transition at all the call will do nothing
            if (HasWindowPending())
            {
                CDocument * pDocument = GetWindowPending()->Document();
                if(pDocument)
                    IGNORE_HR(pDocument->SetUpPageTransitionInfo(pchHttpEquiv, pchContent));
            }
        }
    }

    fExpireImmediate = FALSE;

    // Special case for "Pragma: no-cache" http-equiv.
    
    pchUrl = GetUrl(this);

    if (    pchUrl
        &&  !StrCmpIC(pchHttpEquiv, _T("Pragma"))
        &&  !StrCmpIC(pchContent, _T("no-cache")))
    {
        if (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS)
            DeleteUrlCacheEntry(pchUrl);
        else
            fExpireImmediate = TRUE;
    }
    
    // Special case for "ImageToolbar" http-equiv
    if (!StrCmpIC(pchHttpEquiv, _T("ImageToolbar")) &&
        (!StrCmpIC(pchContent, _T("no")) ||
         !StrCmpIC(pchContent, _T("false"))
         ) )
    {
        if (pDocument)
        {
            pDocument->SetGalleryMeta(FALSE);
        }
        else
        {
            // Get a document pointer from the pending window
            CDocument * pDocument = GetWindowPending()->Document();
            if(pDocument)
            {
                pDocument->SetGalleryMeta(FALSE);
            }
        }
    }

    // Special case for "Expires" http-equiv.
    {
        CMarkupTransNavContext * ptnc = NULL;

        if (    fExpireImmediate
            || (  !(    HasTransNavContext() 
                    &&  (ptnc = GetTransNavContext())->_fGotHttpExpires)
                &&  pchUrl
                &&  !StrCmpIC(pchHttpEquiv, _T("Expires")) ) )
        {
            SYSTEMTIME stime;
            INTERNET_CACHE_ENTRY_INFO icei;

            if (fExpireImmediate || !InternetTimeToSystemTime(pchContent, &stime, 0))
            {
                // If the conversion failed, assume the document expires now.
                GetSystemTime(&stime);
            }

            SystemTimeToFileTime(&stime, &icei.ExpireTime);
            SetUrlCacheEntryInfo(pchUrl, &icei, CACHE_ENTRY_EXPTIME_FC);

            // We only care about the first one if there are many.

            if(!ptnc)
                ptnc = EnsureTransNavContext();
            
            ptnc->_fGotHttpExpires = TRUE;
        }
    }
}

void
CDoc::ProcessMetaName(LPCTSTR pchName, LPCTSTR pchContent)
{
    if (!StrCmpIC(pchName, _T("GENERATOR")))
    {
        // NOTE: This check should stop at the first zero of the major version number
        //       since HP98 generates documents with a number of different major/minor
        //       version numbers. (brendand)
        if (!StrCmpNIC(pchContent, _T("MMEditor Version 00.00.0"), 24) ||
            !StrCmpIC(pchContent, _T("IE4 Size and Overflow")) )    // For public consumption.
        {
            _fInHomePublisherDoc = TRUE;
        }
    }
}

HRESULT
CDoc::SetPicsCommandTarget(IOleCommandTarget *pctPics)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkupPrimary = PrimaryMarkup();

    if (!pMarkupPrimary)
        goto Cleanup;

    hr = THR(pMarkupPrimary->SetPicsTarget(pctPics));
    if (hr)
        goto Cleanup;

    if (pctPics == NULL)
    {
        // Setting _pvPics to this value tells ProcessHttpEquiv to ignore
        // any further PICS-Label directives and not attempt to queue them
        // up in _pvPics for later.

        if (_pvPics == NULL)
        {
            _pvPics = (void *)(LONG_PTR)(-1);
        }

        return(S_OK);
    }

    if (_pvPics && _pvPics != (void *)(LONG_PTR)(-1))
    {
        VARIANT var;
        BYTE *  pb    = (BYTE *)_pvPics + sizeof(DWORD);
        BYTE *  pbEnd = pb + *(DWORD *)_pvPics;
        UINT    cb;

        VariantInit(&var);
        var.vt = VT_BSTR;

        while (pb < pbEnd)
        {
            cb = (_tcslen((TCHAR *)pb) + 1) * sizeof(TCHAR);
            *(DWORD *)(pb - sizeof(DWORD)) = cb;
            var.bstrVal = (BSTR)pb;
            pctPics->Exec(&CGID_ShellDocView, SHDVID_PICSLABELFOUND,
                0, &var, NULL);
            pb += cb;
        }

        MemFree(_pvPics);
        _pvPics = NULL;
    }

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        pMarkupPrimary->ProcessMetaPicsDone();
    }

Cleanup:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\markupctx.cxx ===
//+---------------------------------------------------------------------
//
//  File:       markupctx.cxx
//
//  Classes:    CMarkupContext, etc
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MARKUPCTX_HXX_
#define X_MARKUPCTX_HXX_
#include "markupctx.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CMarkupContext, Mem, "CMarkupContext")

///////////////////////////////////////////////////////////////////////////
//
// CMarkupContext
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CMarkupContext constructor
//
//-------------------------------------------------------------------------

CMarkupContext::CMarkupContext()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkupContext destructor
//
//-------------------------------------------------------------------------

CMarkupContext::~CMarkupContext()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\metarefresh.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999
//
//  File    :   metarefresh.cxx
//
//  Contents:   Meta Refresh tag processing
//
//  Classes :   CWindow
//
//  Author  :   Scott Roberts (12/23/1999)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(MetaRefresh, Locals, "Meta refresh")
DeclareTag(tagMetaRefresh, "Meta Refresh", "Trace Meta Refresh Methods");

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::ProcessMetaRefresh
//
//  Synopsis:   Processes the meta refresh URL and delay.
//
//--------------------------------------------------------------------------

void
CWindow::ProcessMetaRefresh(LPCTSTR pszUrl, UINT uiDelay)
{
    TraceTag((tagMetaRefresh, "+CWindow::ProcessMetaRefresh() - this:[0x%x] pszUrl:[%ws]",
              this, pszUrl));

    // Only accept the first Meta Refresh URL.
    //
    if ((!_pszMetaRefreshUrl || !*_pszMetaRefreshUrl) && pszUrl)
    {
        TraceTag((tagMetaRefresh, " CWindow::ProcessMetaRefresh() - Processing Refresh Data"));

        KillMetaRefreshTimer();

        if (_pszMetaRefreshUrl)
        {
            MemFreeString(_pszMetaRefreshUrl);
            _pszMetaRefreshUrl = NULL;
        }

        HRESULT hr = THR(MemAllocString(Mt(MetaRefresh), pszUrl, &_pszMetaRefreshUrl));
        if (hr)
            return;

        _uiMetaRefreshTimeout   = uiDelay*1000;
        _fMetaRefreshTimeoutSet = TRUE;
    }

    TraceTag((tagMetaRefresh, "-CWindow::ProcessMetaRefresh() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::StartMetaRefreshTimer
//
//  Synopsis:   Starts the meta refresh timer.
//
//--------------------------------------------------------------------------

void
CWindow::StartMetaRefreshTimer()
{
    TraceTag((tagMetaRefresh, "+CWindow::StartMetaRefreshTimer() - this:[0x%x]", this));

    if (_fMetaRefreshTimeoutSet) 
    {
        KillMetaRefreshTimer();

        TraceTag((tagMetaRefresh, " CWindow::StartMetaRefreshTimer() - Starting Meta Refresh Timer"));

        HRESULT hr = FormsSetTimer(this, ONTICK_METHOD(CWindow, MetaRefreshTimerCallback, metarefreshtimercallback),
                                   TIMER_METAREFRESH, _uiMetaRefreshTimeout);
        if (S_OK == hr)
            _fMetaRefreshTimerSet = TRUE;
    }

    TraceTag((tagMetaRefresh, "-CWindow::StartMetaRefreshTimer() - this:[0x%x] _fMetaRefreshTimerSet:[%d]",
              this, _fMetaRefreshTimerSet));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::KillMetaRefreshTimer
//
//  Synopsis:   Kills the meta refresh timer.
//
//--------------------------------------------------------------------------

void
CWindow::KillMetaRefreshTimer()
{
    TraceTag((tagMetaRefresh, "+CWindow::KillMetaRefreshTimer() - this:[0x%x]", this));

    if (_fMetaRefreshTimerSet)
    {
        _fMetaRefreshTimeoutSet = FALSE;
        _fMetaRefreshTimerSet   = FALSE;

        TraceTag((tagMetaRefresh, " CWindow::KillMetaRefreshTimer() - killing Meta Refresh Timer"));
        IGNORE_HR(FormsKillTimer(this, TIMER_METAREFRESH));
    }

    TraceTag((tagMetaRefresh, "-CWindow::KillMetaRefreshTimer() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::ClearMetaRefresh
//
//  Synopsis:   Kills the meta refresh timer and clears the refresh url.
//
//--------------------------------------------------------------------------

void 
CWindow::ClearMetaRefresh()
{
    TraceTag((tagMetaRefresh, "+CWindow::ClearMetaRefresh() - this:[0x%x]", this));

    KillMetaRefreshTimer();

    // If we're called here after ProcessMetaRefresh but BEFORE StartMetaRefreshTimer, then
    // _fMetaRefreshTimerSet will be FALSE and _fMetaRefreshTimeoutSet will not be cleared in 
    // KillMetaRefreshTimer.  Do it here.
    //
    _fMetaRefreshTimeoutSet = FALSE;

    MemFreeString(_pszMetaRefreshUrl);
    _pszMetaRefreshUrl = NULL;

    TraceTag((tagMetaRefresh, "-CWindow::ClearMetaRefresh() - this:[0x%x]", this));
}

//+-------------------------------------------------------------------------
//
//  Method  :   CWindow::MetaRefreshTimerCallback
//
//  Synopsis:   Meta refresh callback method.
//
//--------------------------------------------------------------------------

HRESULT BUGCALL
CWindow::MetaRefreshTimerCallback(UINT uTimerID)
{
    Assert(uTimerID == TIMER_METAREFRESH);
    Assert(_pMarkup);

    HRESULT  hr     = S_OK;
    CDoc   * pDoc   = Doc();
    LPTSTR   pszUrl = NULL;

    TraceTag((tagMetaRefresh, "+CWindow::MetaRefreshTimerCallback() - this:[0x%x] _pMarkup:[0x%x] ID:[%d]",
              this, _pMarkup, uTimerID));


    // do nothing if this is the print template or a doc in design mode.
    // Also, don't continue if the CDoc is in a bad state. The window can be alive independently due to
    // external references.
    if (pDoc->DesignMode() || pDoc->IsPassivating() ||
        pDoc->IsPassivated() || Markup()->IsPrintMedia() )
    {
        goto Cleanup;
    }

    // Check if the security zone settings allow refreshing through meta tags...
    //
    BOOL    fAllow = FALSE;
    DWORD   dwPuaf = _fRestricted ? PUAF_ENFORCERESTRICTED : 0;
    DWORD   dwPolicy;

    hr = THR(Markup()->ProcessURLAction( URLACTION_HTML_META_REFRESH, 
                                            &fAllow, 
                                            dwPuaf,
                                            &dwPolicy));

    if (hr || !fAllow || (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW))
    {
        goto Cleanup;
    }

    // A copy of the refresh URL must be made because, 
    // _pszMetaRefreshUrl has to be released. If it is not
    // released, the timer will not be restarted.
    //
    if (_pszMetaRefreshUrl && *_pszMetaRefreshUrl)
    {
        hr = THR(MemAllocString(Mt(MetaRefresh), _pszMetaRefreshUrl, &pszUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO (scotrobe): If the URL is null, we're really supposed 
        // just refresh the document. However, there is a bug in BecomeCurrent()
        // which is called by ExecRefresh which prevents the window from being
        // passivated. This causes this timer proc to be called after navigating
        // away from the page. When the bug in BecomeCurrent is changed, this 
        // method should be changed to refresh the document. Use this code to cause
        // the refresh to occur. Also, remove the code below because ExecHelper will
        // take care of notifying the DocHostUIHandler.  Here is the code to use:
        //
        //       V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;
        //       hr = _pDocument->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, &cvarLevel, NULL);*/
        //
        hr = THR(MemAllocString(Mt(MetaRefresh), CMarkup::GetUrl(_pMarkup), &pszUrl));
        if (hr)
            goto Cleanup;

        if (pDoc->_pHostUICommandHandler)
        {
            // Give the DocHostUIHandler a chance to handle the refresh. Only proceed if 
            // the DocHostUIHandler doesn't handle the command id (i.e., Exec returns a 
            // failure code.)
            //
            CVariant cvarLevel(VT_I4);
            V_I4(&cvarLevel) = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;

            hr = THR_NOTRACE(pDoc->_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                                                OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER,
                                                                &cvarLevel, NULL));
            if (SUCCEEDED(hr))  // Handled by host
            {
                TraceTag((tagMetaRefresh, " CWindow::MetaRefreshTimerCallback() - Refresh handled by host"));
                goto Cleanup;
            }
        }
    }

    TraceTag((tagMetaRefresh, " CWindow::MetaRefreshTimerCallback() - Navigating to [%ws]",
              pszUrl));

    // Need to kill the timer *before* the call to FollowHyperlinkHelper, since this is synchronous and can end
    // up pumping messages (e.g., wininet's "connect or stay offline" dialog).
    ClearMetaRefresh();

    hr = THR(FollowHyperlinkHelper(pszUrl, 
                                   BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE, 
                                   CDoc::FHL_METAREFRESH | 
                                   ( ( 0 == _uiMetaRefreshTimeout) ? CDoc::FHL_DONTUPDATETLOG : 0 ) ));

Cleanup:
    TraceTag((tagMetaRefresh, "-CWindow::MetaRefreshTimerCallback() - this:[0x%x] hr:[0x%x]",
              this, hr));

    MemFreeString(pszUrl);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\mshtmsvr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       mshtmsvr.cxx
//
//  Contents:   Implementation for server-side trident
//
//  History:    04-23-98    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMSVR_H_
#define X_MSHTMSVR_H_
#include "mshtmsvr.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMSVR_HXX_
#define X_MSHTMSVR_HXX_
#include "mshtmsvr.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);
EXTERN_C const GUID CLSID_HTMLServerDoc;


#define SVRTRI_BUFSIZE      4096
#define STRLEN_MSIE     5

MtDefine(CDocSvr, CDoc, "CDocSvr")
PerfDbgTag(tagCDocSvrNoClone, "CDocSvr", "Disable cloning")


//+------------------------------------------------------------------------
//
//  Member:     AddServerDoc
//
//  Synopsis:   Add this document to the TLS cache.
//
//  Notes:      This will null out the passed in document.  Use
//              GetServerDoc to retrieve the doc.  This is for
//              refcount bookkeeping.  
//
//-------------------------------------------------------------------------

HRESULT
AddServerDoc(CDocSvr **ppDoc)
{
    HRESULT hr = S_OK;

    if (!*ppDoc)
        goto Cleanup;
        
    if (!TLS(paryDocSvr))
    {
        TLS(paryDocSvr) = new CTlsDocSvrAry;
        if (!TLS(paryDocSvr))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(TLS(paryDocSvr)->Append(*ppDoc));
    if (hr)
        goto Cleanup;

    (*ppDoc)->AddRef();
    *ppDoc = NULL;
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetServerDoc
//
//  Synopsis:   Get a document of the passed in filename frm the TLS cache.
//
//-------------------------------------------------------------------------

void
GetServerDoc(TCHAR *pchFileName, CDocSvr **ppDoc)
{
    long        i;
    TCHAR       achPath[MAX_PATH];
    TCHAR *     pchExt;
    LPOLESTR    pchFile = NULL;
    
    if (TLS(paryDocSvr))
    {
        for (i = 0; i < TLS(paryDocSvr)->Size(); i++)
        {
            GetFullPathName(pchFileName, ARRAY_SIZE(achPath), achPath, &pchExt);
            if (OK((*TLS(paryDocSvr))[i]->GetCurFile(&pchFile)))
            {
                if (_tcsiequal(achPath, pchFile))
                {
                    *ppDoc = (*TLS(paryDocSvr))[i];
                    CoTaskMemFree(pchFile);
                    return;
                }
            }
            CoTaskMemFree(pchFile);
            pchFile = NULL;
        }
    }
}


BOOL WINAPI 
SvrTri_NormalizeUA(
    CHAR  *pchUA,                      // [in] User agent string
    DWORD *pdwUA                       // [out] User agend id
    )
{
    char *  pchMSIE = "MSIE ";
    char *  pchUAPtr = pchUA;
    long    lVer;
    long    cch;
    
    if (!pchUA || !pdwUA)
        return FALSE;

    *pdwUA = USERAGENT_DEFAULT;

    for (;;)
    {
        pchUAPtr = strchr(pchUAPtr, 'M');
        if (!pchUAPtr)
            goto Cleanup;

        cch = strlen(pchUAPtr);
        if (STRLEN_MSIE < cch &&
            CompareStringA(g_lcidUserDefault, 0, pchMSIE, STRLEN_MSIE,
                pchUAPtr, STRLEN_MSIE) == 2)
            break;
            
        // Increment pchMSIE to get to the next char beyond the 'M'
        pchUAPtr++;
    }

    pchUAPtr += 5;
    
    lVer = atol(pchUAPtr);
    if (lVer >= 5)
    {
        *pdwUA = USERAGENT_IE5;
    }
    else if (lVer == 4)
    {
        *pdwUA = USERAGENT_IE4;
    }
    else if (lVer == 3)
    {
        *pdwUA = USERAGENT_IE3;
    }
    
Cleanup:
    return TRUE;
}


HRESULT
GetServerInfo(
    VOID *                      pvSrvContext,   // [in] Server Context
    PFN_SVR_GETINFO_CALLBACK    pfnInfo,        // [in] GetInfo callback
    CStrInW *                   pcstrInUA,
    CStrInW *                   pcstrInQS,
    CStrInW *                   pcstrInURL)
{
    CHAR        pchBuffer[SVRTRI_BUFSIZE];
    HRESULT     hr = S_OK;
    ULONG       cch;
    CHAR *      pchTemp;
    
    //
    // Get the user agent
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_USERAGENT, pchBuffer, SVRTRI_BUFSIZE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    pcstrInUA->Init(pchBuffer, -1);

    //
    // Get the Query string
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_QUERY_STRING, pchBuffer, SVRTRI_BUFSIZE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    pcstrInQS->Init(pchBuffer, -1);

    //
    // Get the url.  This is retrieved by combining the protocol with 
    // the virtual path.
    //
    
    if (!(*pfnInfo)(pvSrvContext, SVRINFO_PROTOCOL, pchBuffer, 20))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Strp out /1.1 if it exists.  E.g. HTTP/1.1
    //
    
    pchTemp = strchr(pchBuffer, '/');
    cch = pchTemp ? pchTemp - pchBuffer : strlen(pchBuffer);
    strcpy(pchBuffer + cch, "://");
    cch += 3;

    //
    // Now get host name
    //
    
    if (!(*pfnInfo)(
            pvSrvContext, 
            SVRINFO_HOST, 
            pchBuffer + cch, 
            SVRTRI_BUFSIZE - cch))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    cch = strlen(pchBuffer);
    pchBuffer[cch] = '/';
    cch++;

    //
    // Finally get virtual path
    //
    
    if (!(*pfnInfo)(
            pvSrvContext, 
            SVRINFO_PATH, 
            pchBuffer + cch, 
            SVRTRI_BUFSIZE - cch))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pcstrInURL->Init(pchBuffer, -1);

Cleanup:
    RRETURN(hr);
}


HRESULT
RetrieveDocument(TCHAR *pchFileName, IDispatch *pDisp, CDocSvr **ppDoc)
{
    HRESULT     hr = S_OK;
    MSG         msg;
    IUnknown *  pUnk = NULL;
    CDocSvr *   pDoc;
    CDocSvr *   pDocSvrToClone = NULL;
    IUnknown *  pUnk2 = NULL;
    BOOL        fAdd = FALSE;
    
    hr = THR(CoCreateInstance(
            CLSID_HTMLServerDoc,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IUnknown,
            (void **)&pUnk));
    if (hr)
        goto Cleanup;
    
    hr = THR(pUnk->QueryInterface(CLSID_HTMLServerDoc, (void **)&pDoc));
    if (hr)
        goto Cleanup;

    *ppDoc = pDoc;
    pUnk = NULL;        // Transfer ref over to *ppDoc
    
    //
    // Set up the doc with the initial settings.
    //
    
    pDoc->SetLoadfFromPrefs();
    pDoc->_fGotAmbientDlcontrol = TRUE;
    pDoc->_dwLoadf = 
                DLCTL_NO_SCRIPTS | 
                DLCTL_NO_JAVA |
                DLCTL_NO_RUNACTIVEXCTLS |
                DLCTL_NO_DLACTIVEXCTLS |
                DLCTL_NO_FRAMEDOWNLOAD |
                DLCTL_NO_CLIENTPULL |
                DLCTL_SILENT;
    pDoc->_fNoFixupURLsOnPaste = TRUE;
    
    if (pDisp)
    {
        pDoc->_pDispSvr = pDisp;
        pDisp->AddRef();
    }

#if DBG==1 || defined(PERFTAGS)
    if (!IsPerfDbgEnabled(tagCDocSvrNoClone))
#endif
    {
        GetServerDoc(pchFileName, &pDocSvrToClone);
    }

    if (!pDocSvrToClone)
    {
        //
        // Didn't find the requested document in the cache.  Create it 
        // and put it into the cache.
        //
        
        hr = THR(CoCreateInstance(
                CLSID_HTMLServerDoc,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                (void **)&pUnk2));
        if (hr)
            goto Cleanup;
        
        hr = THR(pUnk2->QueryInterface(
                CLSID_HTMLServerDoc, (void **)&pDocSvrToClone));
        if (hr)
            goto Cleanup;

        //
        // Set up the doc with the initial settings.
        //
        
        pDocSvrToClone->SetLoadfFromPrefs();
        pDocSvrToClone->_fGotAmbientDlcontrol = TRUE;
        pDocSvrToClone->_dwLoadf = pDoc->_dwLoadf | DLCTL_NO_BEHAVIORS;
        pDocSvrToClone->_fNoFixupURLsOnPaste = TRUE;
    
        //
        // Now load the document with this file.
        //

        hr = THR(pDocSvrToClone->Load(pchFileName, 0));
        if (hr)
            goto Cleanup;
            
        //
        // Push a loop till we're done.  This api is synchronous.
        //
        
        while (pDocSvrToClone->_pPrimaryMarkup->LoadStatus() < LOADSTATUS_DONE)
        {
            ::GetMessage(&msg, NULL, 0, 0);
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }

#if DBG==1 || defined(PERFTAGS)
        if (!IsPerfDbgEnabled(tagCDocSvrNoClone))
#endif
        {
            fAdd = TRUE;
        }
    }
    
    Assert(pDocSvrToClone);
    hr = THR(pDocSvrToClone->Clone(pDoc));
    if (hr)
        goto Cleanup;

    if (fAdd)
    {
        hr = THR(AddServerDoc(&pDocSvrToClone));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pUnk2);
    RRETURN(hr);
}

void WINAPI
SvrTri_ClearCache()
{
    extern DWORD g_dwTls;
    CPtrAry<CDocSvr *> *pary;
    
    if (!TlsGetValue(g_dwTls))
        return;

    pary = TLS(paryDocSvr);
    if (pary)
    {
        TLS(paryDocSvr) = NULL;
        pary->ReleaseAll();
        delete pary;
    }
}


BOOL WINAPI
SvrTri_GetDLText(
    VOID *pvSrvContext,                // [in] Server Context
    DWORD dwUA,                        // [in] User Agent
    CHAR *pchFileName,                 // [in] Physical file name of htm file
    IDispatch *pDisp,                  // [in] OA 'Server' object for scripting
    PFN_SVR_GETINFO_CALLBACK pfnInfo,  // [in] GetInfo callback
    PFN_SVR_MAPPER_CALLBACK pfnMapper, // [in] Mapper callback
    PFN_SVR_WRITER_CALLBACK pfnWriter, // [in] Writer callback
    DWORD *rgdwUAEquiv,                // [in, out] Array of ua equivalences
    DWORD cUAEquivMax,                 // [in] Size of array of ua equiv
    DWORD *pcUAEquiv                   // [out] # of UA Equivalencies filled in
    )
{
    if (pcUAEquiv)
    {
        *pcUAEquiv = 0;
    }
    
    if (dwUA >= USERAGENT_IE5)
        return TRUE;

    CEnsureThreadState ets;
    if (FAILED(ets._hr))
        return FALSE;
        
    HRESULT     hr = S_OK;
    CDocSvr *   pDoc = NULL;
    CStrInW     cstrInFile(pchFileName);

    CoInitialize(NULL);

    //
    // Retrieve the document first.
    //

    hr = THR(RetrieveDocument(cstrInFile, pDisp, &pDoc));
    if (hr)
        goto Cleanup;
        
    //
    // Now write it out the contents of pDoc.
    //

    if (pfnWriter)
    {
        hr = THR(pDoc->DoSave(pvSrvContext, pfnWriter));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    CoUninitialize();
        
    return hr ? FALSE : TRUE;
}


BEGIN_TEAROFF_TABLE_(CDocSvr, IServiceProvider)
        TEAROFF_METHOD(CDocSvr, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

//+------------------------------------------------------------------------
//
//  Member:     CreateServerDoc
//
//  Synopsis:   Creates a new server-side doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//-------------------------------------------------------------------------

CBase *
CreateServerDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;

    Assert(!pUnkOuter);
    pBase = new CDocSvr;
    return(pBase);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::PrivateQueryInterface
//
//  Synopsis:   QueryInterface on our private unknown
//
//---------------------------------------------------------------

HRESULT
CDocSvr::PrivateQueryInterface(REFIID riid, void **ppv)
{
    if (riid == CLSID_HTMLServerDoc)
    {
        *ppv = this;
        return S_OK;
    }

    return super::PrivateQueryInterface(riid, ppv);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::Passivate
//
//  Synopsis:   First stage destruction. 
//
//---------------------------------------------------------------

void
CDocSvr::Passivate()
{
    ClearInterface(&_pDispSvr);
    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::DoSave
//
//  Synopsis:   Save the doc out. 
//
//---------------------------------------------------------------

HRESULT
CDocSvr::DoSave(void *pvSrvContext, PFN_SVR_WRITER_CALLBACK pfnWriter)
{
    HRESULT         hr = S_OK;
    IStream *       pStm = NULL;
    ULARGE_INTEGER  luZero = {0, 0};
    LARGE_INTEGER   lZero =  {0, 0};
    TCHAR           achFileName[MAX_PATH];
    DWORD           dwRet;
    BYTE            pBuf[SVRTRI_BUFSIZE];
    ULONG           cbReal = 0;

#if 0    
    Assert(_pPrimaryMarkup->_LoadStatus == LOADSTATUS_DONE);
#endif

    //
    // TODO: Need to fire some event here maybe?
    //
        
    if (!GetTempFileName(_T("tri"), 0, achFileName))
        goto Cleanup;

    hr = THR(CreateStreamOnFile(
             achFileName,
             STGM_READWRITE | STGM_SHARE_DENY_WRITE |
                     STGM_CREATE | STGM_DELETEONRELEASE,
             &pStm));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->SetSize(luZero));
    if (hr)
        goto Cleanup;

    hr = THR(SaveToStream(pStm, WBF_FORMATTED, GetCodePage()));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Seek(lZero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    for (;;)
    {
        hr = THR_NOTRACE(pStm->Read(pBuf, SVRTRI_BUFSIZE, &cbReal));
        if (!cbReal || hr)
            break;
            
        (*pfnWriter)(pvSrvContext, pBuf, cbReal);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::QueryService
//
//  Synopsis:   Override of super's QueryService.  
//
//---------------------------------------------------------------

HRESULT
CDocSvr::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr;
    
    hr = THR_NOTRACE(super::QueryService(guidService, riid, ppv));
    if (hr == E_NOINTERFACE)
    {
        if (_pDispSvr && guidService == SID_SServerOM)
        {
            hr = THR_NOTRACE(_pDispSvr->QueryInterface(riid, ppv));
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDocSvr::Clone
//
//  Synopsis:   Clones this document and outputs a new one.  
//              Assumption is that the new document is empty.
//
//---------------------------------------------------------------

HRESULT
CDocSvr::Clone(CDocSvr *pDoc)
{
    HRESULT             hr;
    CProgSink *         pProgSink = NULL;
    CDwnDoc *           pDwnDoc = NULL;
    
    pDwnDoc = new CDwnDoc;
    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDoc->_pDwnDoc = pDwnDoc;
    pDwnDoc->SetDoc(pDoc);
    pDwnDoc->SetBindf(_pDwnDoc->GetBindf());
    pDwnDoc->SetDocBindf(_pDwnDoc->GetDocBindf());
    pDwnDoc->SetDownf(_pDwnDoc->GetDownf());
    pDwnDoc->SetLoadf(_pDwnDoc->GetLoadf());
    pDwnDoc->SetRefresh(_pDwnDoc->GetRefresh());
    pDwnDoc->SetDocCodePage(_pDwnDoc->GetDocCodePage());
    pDwnDoc->SetURLCodePage(_pDwnDoc->GetURLCodePage());
    hr = THR(pDwnDoc->SetAcceptLanguage(_pDwnDoc->GetAcceptLanguage()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetUserAgent(_pDwnDoc->GetUserAgent()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetDocReferer(_pDwnDoc->GetDocReferer()));
    if (hr)
        goto Cleanup;
    hr = THR(pDwnDoc->SetSubReferer(_pDwnDoc->GetSubReferer()));
    if (hr)
        goto Cleanup;
    
    pProgSink = new CProgSink(pDoc, pDoc->_pPrimaryMarkup);
    if (pProgSink == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pProgSink->Init());
    if (hr)
        goto Cleanup;

    Assert(!pDoc->_pPrimaryMarkup->_pProgSink);
    pDoc->_pPrimaryMarkup->_pProgSink = pProgSink;
    pProgSink = NULL;   // Transfer ref over.

    {
        CDoc * pDocSource = _pPrimaryMarkup->Doc();
        CMarkupPointer mpSourceBegin( pDocSource ), mpSourceEnd( pDocSource ), mpTarget( pDoc );

        hr = THR( mpSourceBegin.MoveToContainer( _pPrimaryMarkup, TRUE ) );
        if (hr)
            goto Cleanup;
        hr = THR( mpSourceEnd.MoveToContainer( _pPrimaryMarkup, FALSE ) );
        if (hr)
            goto Cleanup;
        hr = THR( mpTarget.MoveToContainer( pDoc->_pPrimaryMarkup, TRUE ) );
        if (hr)
            goto Cleanup;

        hr = THR( _pPrimaryMarkup->Doc()->Copy( & mpSourceBegin, & mpSourceEnd, & mpTarget ) );
        if (hr)
            goto Cleanup;
    }

    pDoc->PeerDequeueTasks(0);
    
Cleanup:
    if (pProgSink)
    {
        pProgSink->Release();
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\notify.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994, 1995, 1996, 1997, 1998
//
//  File:       notify.cxx
//
//  Contents:   Notification base classes
//
//  Classes:    CNotification, et. al.
//
//-----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif


MtDefine(CNotification, Tree, "CNotification")

#if DBG==1
      DWORD CNotification::s_snNext = 0;
#endif

const DWORD CNotification::s_aryFlags[NTYPE_MAX] =
{
#define  _NOTIFYTYPE_TABLE_
#include "notifytype.h"
};

//-----------------------------------------------------------------------------
//
//  Member:     SetElement
//
//  Synopsis:   Change the CElement associated with a notification and
//              optionally update the associated range
//
//  Arguments:  pElement   - Pointer to new affected CElement
//              fKeepRange - Flag to keep/update range
//
//-----------------------------------------------------------------------------
void
CNotification::SetElement(
    CElement *  pElement,
    BOOL        fKeepRange)
{
    Assert(fKeepRange || pElement || IsFlagSet(NFLAGS_TREECHANGE));

    _pElement = pElement;

    if (_pElement)
    {
        //
        //  Set the associated range
        //

        if (!fKeepRange)
        {
            if (!IsFlagSet(NFLAGS_LAZYRANGE))
            {
                EnsureRange();
            }
            else
            {
                SetTextRange(-1, -1);
            }
        }
        
        //
        //  Determine the starting node in the tree
        //  (If not already set)
        //

        CTreeNode * pNode = _pElement->GetFirstBranch();

        if (_pNode && _pNode->Element() != _pElement)
        {
            if (!pNode || pNode->IsLastBranch())
            {
                _pNode = pNode;
            }
            else // overlapping involved
            {
                // Update _pNode to the appropriate ancestor
                _pNode = _pNode->SearchBranchToRootForScope(_pElement);
                Assert(_pNode);
            }
        }
        if (!_pNode)
        {
            _pNode = pNode;
        }

        Assert(!_pNode || SameScope(_pNode, _pElement));

        //
        //  Ensure the handler is cleared
        //  (Changing the pElement changes the notification and implies that
        //   it is no longer "handled")
        //

        _pHandler = NULL;
    }
}

//-----------------------------------------------------------------------------
//
//  Member:     EnsureRange
//
//  Synopsis:   Update the associated range with the given pElement
//
//-----------------------------------------------------------------------------

void
CNotification::EnsureRange()
{
    BOOL    fInTree = !!(_pElement->GetFirstBranch());
    
    if (fInTree)
    {
        _pElement->GetRange(&_cp, &_cch);
    }

    if (    !fInTree
        ||  _cp < 0)
    {
        _cp  = -1;
        _cch = -1;
    }

    ClearFlag(NFLAGS_LAZYRANGE);
}


//+----------------------------------------------------------------------------
//
//  Member:     LayoutFlags
//
//  Synopsis:   Convert internal NFLAGS_xxxx to external LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
DWORD
CNotification::LayoutFlags() const
{
    DWORD   grfLayout = 0;

    if (_grfFlags & NFLAGS_FORCE)
        grfLayout |= LAYOUT_FORCE;

    return grfLayout;
}


#if DBG==1
//+----------------------------------------------------------------------------
//
//  Member:     Name
//
//  Synopsis:   Returns a static string describing the notification
//
//-----------------------------------------------------------------------------

LPCTSTR
CNotification::Name() const
{
    LPCTSTR pch;

    switch (_ntype)
    {
    #define  _NOTIFYTYPE_NAMES_
    #include "notifytype.h"

        default:
            AssertSz(FALSE, "Unknown CNotification type");
            pch = _T("???");
            break;
    }

    return pch;
}
#endif


//+----------------------------------------------------------------------------
//
//  Member:     Accumulate
//
//  Synopsis:   Accumulate the dirty tree region described by a CNotification
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTreeRegion::Accumulate(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->IsTreeChange());

    AssertSz(FALSE, "CDirtyTreeRegion::Accumulate is not written");
}


//+----------------------------------------------------------------------------
//
//  Member:     Adjust
//
//  Synopsis:   Adjust the recorded dirty region to take into account
//              nested changes
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTreeRegion::Adjust(
    CNotification * pnf)
{
    Assert(pnf);
    Assert(pnf->IsTreeChange());

    AssertSz(FALSE, "CDirtyTreeRegion::Adjust is not written");

    if (IsDirty())
    {
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     Accumulate
//
//  Synopsis:   Accumulate the dirty text region described by a CNotification
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::Accumulate(
    CNotification * pnf,
    long            cpFirst,
    long            cpLast,
    BOOL            fInnerRange)
{
    Assert(pnf);
    Assert(     pnf->IsTextChange()
            ||  pnf->IsLayoutChange());
    Assert(cpFirst >= 0);

    long    cp  = pnf->Cp(cpFirst) - cpFirst;
    long    cch = pnf->Cch();

    //
    //  Adjust the range to exclude the WCH_NODE chars
    //  (The cp is correctly bounded using the passed cpFirst,
    //   only the cch needs correction at this point)
    //

    if(fInnerRange)
    {
        cch -= 2;
    }

    switch (pnf->Type())
    {
    case NTYPE_CHARS_ADDED:
        TextAdded(cp, cch);
        break;

    case NTYPE_CHARS_DELETED:
        TextDeleted(cp, cch);
        break;

    default:
        TextChanged(cp, cch);
        break;
    }

    _cchNew = min(_cchNew, (cpLast - (_cp + cpFirst)));

#if DBG==1
    if (_cp != -1)
    {
        Assert(_cp >= 0);
        Assert(_cchNew >= 0);
        Assert(_cchOld >= 0);
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     Adjust
//
//  Synopsis:   Adjust the recorded dirty region to take into account
//              nested changes
//
//  Arguments:  pnf - Notification documenting the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::Adjust(
    CNotification * pnf,
    long            cpFirst,
    long            cpLast)
{
    if (IsDirty())
    {
        long cp         = pnf->Cp(cpFirst) - cpFirst;
        long cchChanged = pnf->CchChanged(cpLast);

        Assert(pnf->IsTextChange());

        if (cp < _cp)
        {
            _cp += cchChanged;
        }
        else if (cp < _cp + _cchNew)
        {
            _cchNew += cchChanged;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextAdded
//
//  Synopsis:   Accumulate information about a text addition
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextAdded(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchNew = cch;
    }
    else
    {
        if (cp < _cp)
        {
            long dch = _cp - cp;
            _cp      = cp;
            _cchNew += dch + cch;
            _cchOld += dch;
        }
        else if (cp > _cp + _cchNew)
        {
            long dch = cp - (_cp + _cchNew);
            _cchNew += dch + cch;
            _cchOld += dch;
        }
        else
        {
            _cchNew += cch;
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextDeleted
//
//  Synopsis:   Accumulate information about a text deletion
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextDeleted(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchOld = cch;
    }
    else
    {
        long dch = _cchOld - _cchNew;

        if (cp < _cp)
        {
            _cchNew = max((_cp + _cchNew) - (cp + cch), 0L);
            _cp     = cp;
        }
        else if (cp < _cp + _cchNew)
        {
            _cchNew = cp - _cp + max((_cp + _cchNew) - (cp + cch), 0L);
        }
        else
        {
            _cchNew = cp - _cp;
        }

        _cchOld = _cchNew + dch + cch;
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     TextChanged
//
//  Synopsis:   Accumulate information about a text change
//
//  Arguments:  pnf - Pointer to CNotification describing the change
//
//-----------------------------------------------------------------------------
void
CDirtyTextRegion::TextChanged(
    long cp,
    long cch)
{
    if (_cp == -1)
    {
        _cp     = cp;
        _cchOld = cch;
        _cchNew = cch;
    }
    else
    {
        long dch = _cchOld - _cchNew;

        if (cp < _cp)
        {
            _cchNew = max(_cp - cp + _cchNew, cch);
            _cp     = cp;
        }
        else
        {
            _cchNew = max(cp - _cp + cch, _cchNew);
        }

        _cchOld = _cchNew + dch;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\optshold.cxx ===
//=================================================================
//
//   File:      optshold.cxx
//
//  Contents:   COptionsHolder class
//
//  Classes:    COptionsHolder
//              CFontNameOptions
//              CFontSizeOptions
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#define _cxx_
#include "optshold.hdl"

MtDefine(COptionsHolder, ObjectModel, "COptionsHolder")
MtDefine(COptionsHolder_aryFontSizeObjects_pv, COptionsHolder, "COptionsHolder::_aryFontSizeObjects::_pv")
MtDefine(CFontNameOptions, ObjectModel, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")
MtDefine(CFontSizeOptions, ObjectModel, "CFontSizeOptions")
MtDefine(CFontSizeOptions_aryFontSizes_pv, CFontSizeOptions, "CFontSizeOptions::_aryFontSize::_pv")

#define  START_OF_SAMPLE_STRINGS    0x0700

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];
extern BSTR                     g_bstrFindText;

HRESULT
SetFindText(LPCTSTR bstr)
{
    LOCK_GLOBALS;

    FormsFreeString(g_bstrFindText);
    g_bstrFindText = NULL;
    RRETURN(FormsAllocString(bstr, &g_bstrFindText));
}


//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

int CALLBACK
GetFontSizeProc(LOGFONT FAR *    lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    if (lParam)
       ((CFontSizeOptions *)lParam)->AddSize(lplf->lfHeight);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : classdesc
//
//  Synopsis : CBase Class Descriptor Structure
//
//+----------------------------------------------------------------

const CBase::CLASSDESC COptionsHolder::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLOptionsHolder,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------

COptionsHolder::COptionsHolder(CWindow * pWindow) : super(), _pWindow(pWindow)
{
    Assert(pWindow);

    _pWindow->AddRef();
    _pFontNameObj=NULL;

    VariantInit(&_execArg);
    _hParentWnd = NULL;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

COptionsHolder::~COptionsHolder()
{
    _aryFontSizeObjects.ReleaseAll();

    _pWindow->Release();
    ReleaseInterface(_pFontNameObj);

    VariantClear(&_execArg);
}

void
COptionsHolder::Passivate()
{
    IGNORE_HR(SetFindText(GetAAfindText()));

    super::Passivate();
}


//+---------------------------------------------------------------
//
//  Member  : COptionsHolder::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COptionsHolder::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLOptionsHolder)
        {
           *ppv = (IHTMLOptionsHolder *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+----------------------------------------------------------------
//
//  member : get_document
//
//  Synopsis : IHTMLOptionsHolder property. returns the document
//      member
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_document(IHTMLDocument2 ** ppDocDisp)
{
    HRESULT hr = S_OK;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDocDisp = NULL;

    hr = THR_NOTRACE(_pWindow->Document()->QueryInterface(IID_IHTMLDocument2,
                                            (void**) ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_unsecuredWindowOfDocument
//
//  Synopsis : IHTMLOptionsHolder property. returns the unsecured
//              window of the document
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_unsecuredWindowOfDocument(IHTMLWindow2 ** ppDocDisp)
{
    HRESULT         hr = S_OK;
    CWindow *       pWindow = NULL;

    if (!ppDocDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pWindow = _pWindow;
    Assert(pWindow);

    hr = THR_NOTRACE(pWindow->QueryInterface(IID_IHTMLWindow2,
                                            (void**)ppDocDisp));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_fonts(IHTMLFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CFontNameOptions();
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ReleaseDC(hWndInPlace, hdc);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHTMLFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : secureProtocolInfo
//
//  Synopsis : IHTMLOptionsHolder Property. returns a BSTR which 
//      describes the secure connection info. 
//      Empty string if current connection is insecure
//+----------------------------------------------------------------

HRESULT
COptionsHolder::get_secureConnectionInfo(BSTR * p)
{
    HRESULT hr = S_OK;
    BOOL bSuccess = FALSE;

    if ( p == NULL)
    {
        return E_POINTER;
    }
                
    if (CMarkup::HtmCtxHelper(_pWindow->_pMarkup) != NULL)
    {
        INTERNET_SECURITY_CONNECTION_INFO * pSCI = NULL;
        CMarkup::HtmCtxHelper(_pWindow->_pMarkup)->GetSecConInfo(&pSCI);

        if (!pSCI)
        {
            // Without benefit of INTERNET_SECURITY_CONNECTION_INFO, report "Encrypted."
            // if we believe the original source of the page to be secure
            
            TCHAR achMessage[FORMS_BUFLEN + 1];
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            _pWindow->Doc()->GetRootSslState(FALSE, &sss, &sps);

            if (sss > SSL_SECURITY_MIXED)
            {
                if (!LoadString(GetResourceHInst(), IDS_SECURESOURCE, achMessage, ARRAY_SIZE(achMessage)))
                    return E_FAIL;

                *p = SysAllocString(achMessage);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    bSuccess = TRUE;
                }
            }
        }
        
        if (pSCI != NULL && pSCI->fSecure)
        {
            // These are way beyond the sizes required for protocol & algorithm names (SSL 2.0, RC4, ...)
            // Assert's added in case the strings ever exceed the limit. 
            TCHAR achProtocol[32]; 
            TCHAR achAlgCipher[64];
            TCHAR achAlgExch[64];
            DWORD dwProtocol = ARRAY_SIZE(achProtocol);;
            DWORD dwAlgCipher = ARRAY_SIZE(achAlgCipher);
            DWORD dwAlgExch = ARRAY_SIZE(achAlgExch);
             
            if ( InternetSecurityProtocolToString(pSCI->dwProtocol, achProtocol, &dwProtocol, 0) && 
                 InternetAlgIdToString(pSCI->aiCipher, achAlgCipher, &dwAlgCipher, 0) &&
                 InternetAlgIdToString(pSCI->aiExch, achAlgExch, &dwAlgExch, 0)
               )
            {
                int idCipherQuality;
                
                if ( pSCI->dwCipherStrength < 56 )
                    idCipherQuality = IDS_SECURE_LOW;
                else if ( pSCI->dwCipherStrength < 128 )
                    idCipherQuality = IDS_SECURE_MEDIUM;
                else
                    idCipherQuality = IDS_SECURE_HIGH;
                
                TCHAR achSecurityInfo[256]; // This is way beyond what we can handle. 
                                
                hr = THR(Format(0,
                                achSecurityInfo,
                                ARRAY_SIZE(achSecurityInfo),
                                MAKEINTRESOURCE(IDS_SECURECONNECTIONINFO),
                                achProtocol,
                                achAlgCipher,
                                pSCI->dwCipherStrength,
                                GetResourceHInst(), idCipherQuality,
                                achAlgExch,
                                pSCI->dwExchStrength
                            ));

                if (SUCCEEDED(hr))
                {
                    *p = SysAllocString(achSecurityInfo);
                    if (*p == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        bSuccess = TRUE;
                    }
                }
            }
            else
            {
                DWORD dwError = GetLastError();
                // This implies the stack buffers we have allocated are not big enough!!
                Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }  /* if the connection was secure */
    } /* if we found a _pHtmCtx */

    // If we failed somewhere along the way. just allocate an empty string and return quietly. 
    if (!bSuccess)
    {
        *p = SysAllocString(_T(""));
        if (*p == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }                                                                                                                
                                         
    return hr;    
}



//+----------------------------------------------------------------
//
//  member : sizes
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole Collecion of
//      longs of the available sizes available for the given font
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::sizes( BSTR bstrFontName,
                       IHTMLFontSizesCollection ** ppOptsCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    CStr    strName;
    long    lIndex;

    if (!ppOptsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!bstrFontName || !SysStringLen(bstrFontName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lIndex = GetObjectLocation(bstrFontName);
    if (lIndex<0)
    {
        // some error happened
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If we don't have the sizes cached for this font....
    if (lIndex == _aryFontSizeObjects.Size())
    {
        CFontSizeOptions * pfsObject=NULL;

        // add a new one to the list
        hr = THR(_aryFontSizeObjects.EnsureSize(lIndex+1));
        if (hr)
            goto Cleanup;

        pfsObject = new CFontSizeOptions();
        if (!pfsObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pfsObject->_cstrFont.SetBSTR(bstrFontName);
        pfsObject->SetSize(0);

        _pWindow->Doc()->GetWindow(&hWndInPlace);

        hdc = GetDC(hWndInPlace);
        EnumFonts( hdc, pfsObject->_cstrFont,
                   (FONTENUMPROC) GetFontSizeProc,
                   (LPARAM)pfsObject);
        ReleaseDC(hWndInPlace, hdc);

        _aryFontSizeObjects[lIndex] = pfsObject;
    }

        // QI for an interface to return
    hr = THR_NOTRACE(_aryFontSizeObjects[lIndex]->QueryInterface(
                                    IID_IHTMLFontSizesCollection,
                                    (void**)ppOptsCollection));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : openfiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::openfiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, FALSE)));
}

//+----------------------------------------------------------------
//
//  member : savefiledlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

HRESULT
COptionsHolder::savefiledlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName)
{
    RRETURN(SetErrorInfo(OpenSaveFileDlg(initFile, initDir, filter, title, pathName, TRUE)));
}

//+----------------------------------------------------------------
//
//  member : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//              returns the selected filename
//
//+----------------------------------------------------------------

#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
COptionsHolder::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    hr = THR(FormsAllocStringLen(NULL, MAX_PATH, &bstrFile));
    if (hr)
    {
        goto Cleanup;
    }

    if (pvarInitFile)
    {
        _tcscpy(bstrFile, V_BSTR(pvarInitFile));
    }
    else
    {
        *bstrFile = _T('\0');
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    Assert(_hParentWnd);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    // ofn.hwndOwner       = hWndInPlace;
    ofn.hwndOwner       = _hParentWnd;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;     // file name buffer
    ofn.nMaxFile        = MAX_PATH;     // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    while (*pstrExt)
        pstrExt++;
    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }
            pSearch += _tcslen(pSearch);
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    {
        LOCK_SECTION(g_csFile);

        _tcscpy(achPath, g_achSavePath);
        ofn.lpstrInitialDir = *achPath ? achPath : NULL;
    }

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        FormsFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        LOCK_SECTION(g_csFile);

        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:

    *pathName = bstrFile;

    return hr;
}

HRESULT
COptionsHolder::choosecolordlg( VARIANTARG initColor, long *rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult;
    VARIANTARG      varArgTmp;

    hr = THR (VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    _pWindow->Doc()->GetWindow(&hWndInPlace);

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = _hParentWnd;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    RRETURN(SetErrorInfo( hr ));
#endif // WINCE
}

HRESULT
COptionsHolder::showSecurityInfo()
{
    HWND    hwnd = _hParentWnd;
    CDoc *  pDoc = _pWindow->Doc();

    if (!_hParentWnd)
        pDoc->GetWindow(&hwnd);
        
    InternetShowSecurityInfoByURL((TCHAR*)CMarkup::GetUrl(_pWindow->Markup()), hwnd);

    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
COptionsHolder::isApartmentModel( IHTMLObjectElement* object, 
                                 VARIANT_BOOL * fApartment)
{
    HRESULT             hr = S_OK;
    IClientSecurity    *pCL = NULL;
    VARIANT_BOOL        vbRetVal = VB_FALSE;
    VARIANT             var;
    IOleCommandTarget  *pCT = NULL;

    VariantInit(&var);

    hr = THR(object->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
    if (hr)
        goto Cleanup;

    hr = THR(pCT->Exec((GUID *)&CGID_MSHTML, 
                        IDM_GETPUNKCONTROL, 
                        0, 
                        NULL, 
                        &var));
    if (hr)
        goto Cleanup;

    //
    //  QI IClientSecurity returns S_OK if the control is NOT 
    //  apartment model!
    //
    hr = var.punkVal->QueryInterface(IID_IClientSecurity, (void **) &pCL);
    if (!hr)
    {
        hr = S_OK;      // It really is OK.
        goto Cleanup;
    }

    vbRetVal = VB_TRUE;

Cleanup:
    ReleaseInterface(pCL);
    ReleaseInterface(pCT);

    *fApartment = vbRetVal;

    RRETURN( SetErrorInfo( S_OK ) );
}


HRESULT
COptionsHolder::getCharset(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    lf.lfFaceName[LF_FACESIZE - 1] = 0;
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    RRETURN( SetErrorInfo( hr ) );
}



//+----------------------------------------------------------------
//
//  Member GetObjetLocation
//
//  Synopsis : helper function for sizes. this will search the
//      pointer array of size collections to see if this one
//      already exists. if not, size() is returned.
//
//-----------------------------------------------------------------

long
COptionsHolder::GetObjectLocation(BSTR strTargetFontName)
{
    long    lSize = _aryFontSizeObjects.Size();
    long    l;

    // Look for a free slot in the non-reserved part of the cache.
    for (l=0; l < lSize; ++l)
    {
        if (!FormsStringICmp(_aryFontSizeObjects[l]->_cstrFont,
                             strTargetFontName))
            break;
    }

    return l;
}


HRESULT
STDMETHODCALLTYPE COptionsHolder::put_execArg(VARIANT varExecArg)
{
    VariantClear(&_execArg);
    RRETURN(SetErrorInfo(VariantCopy(&_execArg, &varExecArg)));
}

HRESULT 
STDMETHODCALLTYPE COptionsHolder::get_execArg(VARIANT *pexecArg)
{
    HRESULT     hr;

    if (pexecArg == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pexecArg, &_execArg);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontNameOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontNameOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontNamesCollection,  // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontNamesCollection)
        {
           *ppv = (IHTMLFontNamesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHTMLFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::_newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontNames.EnumVARIANT(VT_BSTR,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CFontSizeOptions
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CFontSizeOptions::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFontSizesCollection,  // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLFontSizesCollection)
        {
           *ppv = (IHTMLFontSizesCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::AddSize
//
//  Sysnopsis : adds the given size to the aryFontSizes
//          in ascending order.
//
//----------------------------------------------------------------
HRESULT
CFontSizeOptions::AddSize(long lFSize)
{
    HRESULT hr = S_OK;
    int     i, value, iSizeAry = _aryFontSizes.Size();

    for (i=0; i<iSizeAry; i++)
    {
        value = _aryFontSizes[i];

        // is it already in the list
        if (lFSize == value)
            goto Cleanup;

        // is it smaller than the thing we're looking at
        if (lFSize < value)
            break;
    }

    // it is not in the list and smaller than the value at index i
    // or i = iSizeAry and we want to tack this at the end.
    hr = THR(_aryFontSizes.Insert(i, lFSize));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::length
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontSizes.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::item
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::item(long lIndex, long *plSize)
{
    HRESULT hr = S_OK;

    if (!plSize)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontSizes.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plSize = _aryFontSizes[lIndex];

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CFontSizeOptions::_newEnum
//
//  Sysnopsis : IHTMLFONTSizesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontSizeOptions::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryFontSizes.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\paint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       paint.cxx
//
//  Contents:   Painting and invalidation
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_UPDSINK_HXX_
#define X_UPDSINK_HXX_
#include "updsink.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifdef WIN16
#ifndef X_PRINT_H_
#define X_PRINT_H_
#include <print.h>
#endif
#ifndef UNICODE
#define iswspace isspace
#endif
#endif // WIN16

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

DeclareTagOther(tagPaintShow,    "DocPaintShow",    "erase bkgnd before paint")
DeclareTagOther(tagPaintPause,   "DocPaintPause",   "pause briefly before paint")
DeclareTagOther(tagPaintWait,    "DocPaintWait",    "wait for shift key before paint")
PerfDbgTagOther(tagInvalShow,    "DocInvalShow",    "paint hatched brush over invalidated areas")
PerfDbgTagOther(tagInvalWait,    "DocInvalWait",    "wait after invalidating")
PerfDbgTagOther(tagInvalPaint,	 "DocInvalPaint",   "paint during invalidation")
PerfDbgTag(tagDocPaint,          "DocPaint",        "painting")
DeclareTag(tagFormInval,         "DocInval",        "invalidation")
DeclareTag(tagFormInvalT,        "DocInvalStack",   "invalidation stack trace")
DeclareTag(tagPrintClearBkgrnd,  "Print",           "No parent site background clearing")
PerfDbgTag(tagNoGdiBatch,        "DocBatch",        "disable GDI batching")
PerfDbgTag(tagNoOffScr,          "DocOffScreen",    "disable off-screen rendering")
PerfDbgTag(tagNoTile,            "DocTile",         "disable tiling")
DeclareTagOther(tagForceClip,    "DocForceClip",    "force physical clipping always");
DeclareTagOther(tagUpdateInt,    "DocUpdateInt",    "trace UpdateInterval stuff");
DeclareTag(tagTile,              "DocTile",         "tiling information");
DeclareTag(tagDisEraseBkgnd,     "Erase Background: disable", "Disable erase background")
MtDefine(CSiteDrawList, Locals, "CSiteDrawList")
MtDefine(CSiteDrawList_pv, CSiteDrawList, "CSiteDrawList::_pv")
MtDefine(CSiteDrawSiteList_aryElements_pv, Locals, "CSite::DrawSiteList aryElements::_pv")
MtDefine(CSiteGetSiteDrawList_aryElements_pv, Locals, "CSite::GetSiteDrawList aryElements::_pv")

ExternTag(tagPalette);
ExternTag(tagTimePaint);
ExternTag(tagView);

#ifdef PRODUCT_PROF_FERG
// for PROFILING perposes only
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall SuspendCAP(void);
#endif

//+------------------------------------------------------------------------
//
//  Function:   DumpRgn
//
//  Synopsis:   Write region to debug output
//
//-------------------------------------------------------------------------

#if DBG==1
void
DumpRgn(HRGN hrgn)
{
    struct
    {
        RGNDATAHEADER rdh;
        RECT arc[128];
    } data;

    if (GetRegionData(hrgn, ARRAY_SIZE(data.arc), (RGNDATA *)&data) != 1)
    {
        TraceTag((0, "HRGN=%08x: buffer too small", hrgn));
    }
    else
    {
        TraceTag((0, "HRGN=%08x, iType=%d, nCount=%d, nRgnSize=%d, t=%d b=%d l=%d r=%d",
                hrgn,
                data.rdh.iType,
                data.rdh.nCount,
                data.rdh.nRgnSize,
                data.rdh.rcBound.top,
                data.rdh.rcBound.bottom,
                data.rdh.rcBound.left,
                data.rdh.rcBound.right));
        for (DWORD i = 0; i < data.rdh.nCount; i++)
        {
            TraceTag((0, "    t=%d, b=%d, l=%d, r=%d",
                data.arc[i].top,
                data.arc[i].left,
                data.arc[i].bottom,
                data.arc[i].right));
        }
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateForm
//
//  Synopsis:   Update the form's window
//
//-------------------------------------------------------------------------

void
CDoc::UpdateForm()
{
    if (_pInPlace)
    {
        UpdateChildTree(_pInPlace->_hwnd);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::Invalidate
//
//  Synopsis:   Invalidate an area in the form.
//
//              We keep track of whether the background should be
//              erased on paint privately.  If we let Windows keep
//              track of this, then we can get flashing because
//              the WM_ERASEBKGND message can be delivered far in
//              advance of the WM_PAINT message.
//
//              Invalidation flags:
//
//              INVAL_CHILDWINDOWS
//                  Invaildate child windows. Causes the RDW_ALLCHILDREN
//                  flag to be passed to RedrawWindow.
//
//  Arguments:  prc         The physical rectangle to invalidate.
//              prcClip     Clip invalidation against this rectangle.
//              hrgn        ...or, the region to invalidate.
//              dwFlags     See description above.
//
//-------------------------------------------------------------------------

void
CDoc::Invalidate(const RECT *prc, const RECT *prcClip, HRGN hrgn, DWORD dwFlags)
{
    UINT uFlags;
    RECT rc;
    
    if (_state >= OS_INPLACE)
    {
        if (prcClip)
        {
            Assert(prc);
            if (!IntersectRect(&rc, prc, prcClip))
                return;

            prc = &rc;
        }

        // Do not invalidate when not yet INTERACTIVE.
        
        // INTERACTIVE is when we want to start doing our own drawing. It means we've had
        // to process an externally triggered WM_PAINT, or we've loaded enough of the
        // document to draw the initial scroll position correctly, or five seconds
        // have passed since we've tried to do the initial scroll position.

        if (LoadStatus() < LOADSTATUS_INTERACTIVE)
        {
            _fInvalNoninteractive = TRUE; // When we become interactive, we must inval
            return;
        }


#if (DBG==1 || defined(PERFTAGS)) && !defined(WINCE)
#if DBG==1
        if (prc)
        {
            TraceTag((tagFormInval,
                    "%08lX Inval%s l=%ld, t=%ld, r=%ld, b=%ld",
                    this,
                    dwFlags & INVAL_CHILDWINDOWS ? " CHILD" : "",
                    prc->left, prc->top, prc->right, prc->bottom));
        }
        else
        {
            TraceTag((tagFormInval, "%08lX Inval%s",
                    this,
                    dwFlags & INVAL_CHILDWINDOWS ? " CHILD" : ""));
        }
        TraceCallers(tagFormInvalT, 2, 4);
#endif

        if (IsPerfDbgEnabled(tagInvalShow))
        {
            static int s_iclr;
            static COLORREF s_aclr[] =
            {
                    RGB(255, 0, 0), RGB(0, 255, 0),
                    RGB(255, 255, 0), RGB(0, 255, 255),
            };

            s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
            HDC hdc = ::GetDC(_pInPlace->_hwnd);
            HBRUSH hbrush = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
            int bkMode = SetBkMode(hdc, TRANSPARENT);
            if (prc)
            {
                FillRect(hdc, prc, hbrush);
            }
            else if (hrgn)
            {
                FillRgn(hdc, hrgn, hbrush);
            }
            DeleteObject((HGDIOBJ)hbrush);
            SetBkMode(hdc, bkMode);
            ::ReleaseDC(_pInPlace->_hwnd, hdc);
        }
        if (IsPerfDbgEnabled(tagInvalWait))
            Sleep(120);
#endif // (DBG==1 || defined(PERFTAGS)) && !defined(WINCE)

        uFlags = RDW_INVALIDATE | RDW_NOERASE;


#if defined(PERFTAGS)
        if (IsPerfDbgEnabled(tagInvalPaint))
            uFlags |= RDW_UPDATENOW;
#endif

        if (dwFlags & INVAL_CHILDWINDOWS)
        {
            uFlags |= RDW_ALLCHILDREN;
        }

        Assert(_pInPlace && " about to crash");

        _cInval++;

        if ( !_pUpdateIntSink )
        {
            RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
        }
        else if ( _pUpdateIntSink->_state < UPDATEINTERVAL_ALL )
        {
            // accumulate invalid rgns until the updateInterval timer fires
            HRGN    hrgnSrc;
            TraceTag((tagUpdateInt, "Accumulating invalid Rect/Rgn"));
            if ( prc )
            {
                hrgnSrc = CreateRectRgnIndirect( prc );
                if ( !hrgnSrc )
                {
                    RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                }
                else if ( UPDATEINTERVAL_EMPTY == _pUpdateIntSink->_state )
                {
                    _pUpdateIntSink->_hrgn = hrgnSrc;
                    _pUpdateIntSink->_state = UPDATEINTERVAL_REGION;
                    _pUpdateIntSink->_dwFlags |= uFlags;
                }
                else
                {
                    Assert( UPDATEINTERVAL_REGION == _pUpdateIntSink->_state );
                    if ( ERROR == CombineRgn(_pUpdateIntSink->_hrgn,
                                             _pUpdateIntSink->_hrgn,
                                             hrgnSrc, RGN_OR) )
                    {
                        TraceTag((tagUpdateInt, "Error in accumulating invalid Rect"));
                        RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                    }
                    else
                    {
                        _pUpdateIntSink->_dwFlags |= uFlags;
                    }
                    DeleteObject( hrgnSrc );
                }
            }
            else if ( hrgn )
            {
                if ( UPDATEINTERVAL_EMPTY == _pUpdateIntSink->_state )
                {
                    _pUpdateIntSink->_hrgn = hrgn;
                    _pUpdateIntSink->_state = UPDATEINTERVAL_REGION;
                    _pUpdateIntSink->_dwFlags |= uFlags;
                }
                else
                {
                    Assert( UPDATEINTERVAL_REGION == _pUpdateIntSink->_state );
                    if ( ERROR == CombineRgn(_pUpdateIntSink->_hrgn,
                                             _pUpdateIntSink->_hrgn,
                                             hrgn, RGN_OR) )
                    {
                        TraceTag((tagUpdateInt, "Error in accumulating invalid Rgn"));
                        RedrawWindow(_pInPlace->_hwnd, prc, hrgn, uFlags);
                    }
                    else
                    {
                        _pUpdateIntSink->_dwFlags |= uFlags;
                    }
                }
            }
            else
            {
                // update entire client area, no need to accumulate anymore
                _pUpdateIntSink->_state = UPDATEINTERVAL_ALL;
                DeleteObject( _pUpdateIntSink->_hrgn );
                _pUpdateIntSink->_hrgn = NULL;
                _pUpdateIntSink->_dwFlags |= uFlags;
            }
        }

        OnViewChange(DVASPECT_CONTENT);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::Invalidate
//
//  Synopsis:   Invalidate the form's entire area.
//
//-------------------------------------------------------------------------

void
CDoc::Invalidate()
{
    Invalidate(NULL, NULL, NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DisabledTilePaint()
//
//  Synopsis:   return true if tiled painting disabled
//
//----------------------------------------------------------------------------

inline BOOL
CDoc::TiledPaintDisabled()
{
#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagNoTile))
        return TRUE;
#endif

    return _fDisableTiledPaint;
}

#ifdef DISPLAY_FRAMERATE  //turn this on to get a framerate printed in the upper left corner of the primary display   
void
CDoc::UpdateFrameRate()
{
    static int iPaintCount = 0;
    static LARGE_INTEGER liLastOutput;
    LARGE_INTEGER liCurTime;
    static LARGE_INTEGER liFrequency;
    static bool bFirstTime = true;

    if (bFirstTime == true) //need to determine the counter frequency
    {
        bFirstTime = false;
        QueryPerformanceFrequency(&liFrequency);
        QueryPerformanceCounter(&liLastOutput);
    }
    
    iPaintCount++;

    QueryPerformanceCounter(&liCurTime);

    //output performance numbers
    if ((liCurTime.QuadPart - liLastOutput.QuadPart) >= liFrequency.QuadPart) //at least a second has past
    {
        WCHAR cFrameRate[25] = {0};
        HDC dc = 0;
        COLORREF color = CLR_INVALID;
        // create the string
        wsprintfW(cFrameRate, L"framerate: %d   \n", iPaintCount);
        //get the HDC to the desktop
        dc = ::GetDC(0); 

        //output the string
        ::MoveToEx(dc, 10, 10, NULL);
        color = ::SetBkColor(dc, RGB(50, 255, 50));
        ::ExtTextOut(dc, 10, 10, ETO_OPAQUE, NULL, cFrameRate, 13, NULL);
        if (color != CLR_INVALID)
        {
            //restore the background color
            ::SetBkColor(dc, color);
        }
        //release the DC
        ::ReleaseDC(0, dc);

        //update the framerate values
        iPaintCount = 0;
        liLastOutput = liCurTime;
    }
}
#endif //DISPLAY_FRAMERATE

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnPaint
//
//  Synopsis:   Handle WM_PAINT
//
//----------------------------------------------------------------------------

#ifndef NO_RANDOMRGN
typedef int WINAPI GETRANDOMRGN(HDC, HRGN, int);
static GETRANDOMRGN * s_pfnGetRandomRgn;
static BOOL s_fGetRandomRgnFetched = FALSE;
#endif

void
CDoc::OnPaint()
{
    IF_WIN16(RECT rc;)
    PAINTSTRUCT         ps;
    CFormDrawInfo       DI;
    BOOL                fViewIsReady;
    BOOL                fHtPalette;
#ifndef NO_RANDOMRGN
    HRGN                hrgn = NULL;
    POINT               ptBefore;
    POINT               ptAfter;
#endif
    HWND                hwndInplace;
#ifndef NO_ETW_TRACING
    BOOL                fNoPaint = FALSE;
#endif

    TraceTagEx((tagView, TAG_NONAME,
           "View : CDoc::OnPaint"));

#ifdef DISPLAY_FRAMERATE  //turn this on to get a framerate printed in the upper left corner of the primary display
        UpdateFrameRate();
#endif //DISPLAY_FRAMERATE

    _fInvalInScript = FALSE;

    DI._hdc = NULL;

    // Don't allow OnPaint to recurse.  This can occur as a result of the
    // call to RedrawWindow in a random control.

    // TODO: StylesheetDownload should be linked to the LOADSTATUS interactive?
    if (TestLock(SERVERLOCK_BLOCKPAINT) || IsStylesheetDownload() || _fPageTransitionLockPaint)
    {
        // We get endless paint messages when we try to popup a messagebox...
        // and prevented the messagebox from getting paint !
        BeginPaint(_pInPlace->_hwnd, &ps);
        EndPaint(_pInPlace->_hwnd, &ps);

        // Post a delayed paint to make up for what was missed
        _view.Invalidate(&ps.rcPaint, FALSE, FALSE, FALSE);

        TraceTagEx((tagView, TAG_NONAME,
               "View : CDoc::OnPaint - Exit"));

        return;
    }

    // If we're not interactive by the time we get the first paint, we should be
    if (PrimaryMarkup()->LoadStatus() < LOADSTATUS_INTERACTIVE)
    {
        PrimaryMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
    }

    PerfDbgLog(tagDocPaint, this, "+CDoc::OnPaint");
    CDebugPaint debugPaint;
    debugPaint.StartTimer();

    fViewIsReady = _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_INPAINT | LAYOUT_DEFERPAINT);
    Assert( !fViewIsReady
        ||  !_view.IsDisplayTreeOpen());

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    SwitchesBegTimer(SWITCHES_TIMER_PAINT);

    // since we're painting, paint any accumulated regions if any
    if ( _pUpdateIntSink && _pUpdateIntSink->_state != UPDATEINTERVAL_EMPTY )
    {
        ::InvalidateRgn( _pInPlace->_hwnd, _pUpdateIntSink->_hrgn, FALSE );
        if ( _pUpdateIntSink->_hrgn )
        {
            DeleteObject( _pUpdateIntSink->_hrgn );
            _pUpdateIntSink->_hrgn = NULL;
            _pUpdateIntSink->_state = UPDATEINTERVAL_EMPTY;
            _pUpdateIntSink->_dwFlags = 0;
        }
    }

#ifndef NO_RANDOMRGN
    ptBefore.x = ptBefore.y = 0;
    MapWindowPoints(_pInPlace->_hwnd, NULL, &ptBefore, 1);
#endif

    // Setup DC for painting.

    // This is bad, in some cases (bug 106098) our _pInplace goes away because
    // one of the controls runs a message loop that gets a message posted by the
    // test program. So on return from paint our _pInPlace is NULL and we crash
    // when doing an EndPaint. THis is why I cache the hwnd in a local variable.
    hwndInplace = _pInPlace->_hwnd;
    BeginPaint(hwndInplace, &ps);

    if (IsRectEmpty(&ps.rcPaint))
    {
        // It appears there are cases when our window is obscured yet
        // internal invalidations still trigger WM_PAINT with a valid
        // update region but the PAINTSTRUCT RECT is empty.
#ifndef NO_ETW_TRACING
        fNoPaint = TRUE;
#endif
        goto Cleanup;
    }

    // If the view could not be properly prepared, accumulate the invalid rectangle and return
    // (The view will issue the invalidation/paint once it is safe to do so)
    if (!fViewIsReady)
    {
        _view.Invalidate(&ps.rcPaint);
        _view.SetFlag(CView::VF_FORCEPAINT);

        TraceTagEx((tagView, TAG_NONAME,
               "View : CDoc::OnPaint - !fViewIsReady, Setting VF_FORCEPAINT for rc(%d, %d, %d, %d)",
               ps.rcPaint.left,
               ps.rcPaint.top,
               ps.rcPaint.right,
               ps.rcPaint.bottom));

#ifndef NO_ETW_TRACING
        fNoPaint = TRUE;
#endif
        goto Cleanup;
    }

#ifndef NO_RANDOMRGN
#ifdef WIN32
    if (!s_fGetRandomRgnFetched)
    {
        s_pfnGetRandomRgn = (GETRANDOMRGN *)GetProcAddress(GetModuleHandleA("GDI32.DLL"), "GetRandomRgn");
        s_fGetRandomRgnFetched = TRUE;
    }

    if (s_pfnGetRandomRgn)
    {
        Verify((hrgn = CreateRectRgnIndirect(&g_Zero.rc)) != NULL);
        Verify(s_pfnGetRandomRgn(ps.hdc, hrgn, 4) != ERROR);
        if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
        {
            Verify(OffsetRgn(hrgn, -ptBefore.x, -ptBefore.y) != ERROR);
        }

        // Don't trust the region if the window moved in the meantime

        ptAfter.x = ptAfter.y = 0;
        MapWindowPoints(hwndInplace, NULL, &ptAfter, 1);

        if (ptBefore.x != ptAfter.x || ptBefore.y != ptAfter.y)
        {
            Verify(DeleteObject(hrgn));
            hrgn = NULL;
#ifndef NO_ETW_TRACING
            fNoPaint = TRUE;
#endif
            goto Cleanup;
        }
    }
#endif
#endif

    GetPalette(ps.hdc, &fHtPalette);

#ifndef NO_PERFDBG
#if DBG==1
    // If it looks like we are the foreground application, check to see
    // if we have an identify palette.  Turn on "warn if not identity palette"
    // trace tag to see the output.

    if (_pElemUIActive == PrimaryRoot() &&
        _pInPlace->_fFrameActive)
    {
        extern BOOL IsSameAsPhysicalPalette(HPALETTE);
        if (!IsSameAsPhysicalPalette(GetPalette()))
            TraceTag((tagError, "Logical palette does not match physical palette"));
    }
#endif
#endif

#if DBG==1
    if (!CDebugPaint::UseDisplayTree() &&
        (IsTagEnabled(tagPaintShow) || IsTagEnabled(tagPaintPause)))
    {
        // Flash the background.

        HBRUSH hbr;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(  0,   0, 255),
                RGB(  0, 255,   0),
                RGB(  0, 255, 255),
                RGB(255,   0,   0),
                RGB(255,   0, 255),
                RGB(255, 255,   0)
        };

        GetAsyncKeyState(VK_SHIFT);

        do
        {
            // Fill the rect and pause.

            if (IsTagEnabled(tagPaintShow))
            {
                s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
                hbr = GetCachedBrush(s_aclr[s_iclr]);
                FillRect(ps.hdc, &ps.rcPaint, hbr);
                ReleaseCachedBrush(hbr);
                GdiFlush();
            }

            if (IsTagEnabled(tagPaintPause))
            {
                DWORD dwTick = GetTickCount();
                while (GetTickCount() - dwTick < 100) ;
            }
        }
        while (GetAsyncKeyState(VK_SHIFT) & 0x8000);
    }
#endif // DBG==1

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagNoGdiBatch))
        GdiSetBatchLimit(1);
#endif // DBG==1 || defined(PERFTAGS)

    if (_pTimerDraw)
        _pTimerDraw->Freeze(TRUE);      // time stops so controls can synchronize
#if !defined(WIN16) && !defined(NO_RANDOMRGN)
    if (!TiledPaintDisabled())
    {
#endif
        // Invalidation was not on behalf of an ActiveX control.  Paint the
        // document in one pass here and tile if required in CSite::DrawOffscreen.

        DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()), XHDC(ps.hdc, NULL));
        DI.CDocScaleInfo::Copy(_dciRender);
        DI._rcClip = ps.rcPaint;
        DI._rcClipSet = ps.rcPaint;
#ifndef NO_RANDOMRGN
        DI._hrgnPaint = hrgn;
#else
        DI._hrgnPaint = NULL;
#endif
        DI._fHtPalette = fHtPalette;

        Assert(!_view.IsDisplayTreeOpen());

#ifndef NO_RANDOMRGN
        _view.RenderView(&DI, DI._hrgnPaint);
#else
#if DBG==1
        int i = GetObjectType(DI._pSurface._hdc);
#endif
        _view.RenderView(&DI, &ps.rcPaint);
#endif
        WHEN_DBG(debugPaint.StopTimer(tagTimePaint, "Display Tree Paint", TRUE));

#if !defined(WIN16) && !defined(NO_RANDOMRGN)
    }
    else
    {
        RECT *   prc;
        int      c;
        struct REGION_DATA
        {
            RGNDATAHEADER rdh;
            RECT          arc[MAX_INVAL_RECTS];
        } rd;

        // Invalidation was on behalf of an ActiveX Control.  We chunk things
        // up here based on the inval region with the hope that the ActiveX
        // Control will be painted in a single pass.  We do this because
        // some ActiveX Controls (controls using Direct Animation are an example)
        // have very bad performance when painted in tiles.

        // if we have more than one invalid rectangle, see if we can combine
        // them so drawing will be more efficient. Windows chops up invalid
        // regions in a funny, but predicable, way to maintain their ordered
        // listing of rectangles. Also, some times it is more efficient to
        // paint a little extra area than to traverse the hierarchy multiple times.

        if (hrgn &&
            GetRegionData(hrgn, sizeof(rd), (RGNDATA *)&rd) &&
            rd.rdh.iType == RDH_RECTANGLES &&
            rd.rdh.nCount <= MAX_INVAL_RECTS)
        {
            c = rd.rdh.nCount;
            prc = rd.arc;

            CombineRectsAggressive(&c, prc);
        }
        else
        {
            c = 1;
            prc = &ps.rcPaint;
        }

        // Paint each rectangle.

        for (; --c >= 0; prc++)
        {
            DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));
            DI._hdc = XHDC(ps.hdc, NULL);
            DI._hic = XHDC(ps.hdc, NULL);
            DI._rcClip = *prc;
            DI._rcClipSet = *prc;
            DI._fHtPalette = fHtPalette;

            if (prc != &ps.rcPaint)
            {
                // If painting the update region in more than one
                // pass and painting directly to the screen, then
                // we explicitly set the clip rectangle to insure correct
                // painting.  If we don't do this, the FillRect for the
                // background of a later pass will clobber the foreground
                // for an earlier pass.

                Assert(DI._hdc == ps.hdc);
                IntersectClipRect(DI._hdc,
                        DI._rcClip.left, DI._rcClip.top,
                        DI._rcClip.right, DI._rcClip.bottom);

            }

            PerfDbgLog6(tagDocPaint, this,
                    "CDoc::OnPaint Draw(i=%d %s l=%ld, t=%ld, r=%ld, b=%ld)",
                    c,
                    DI._hdc != ps.hdc ? "OFF" : "ON",
                    DI._rcClip.left, DI._rcClip.top,
                    DI._rcClip.right, DI._rcClip.bottom);

            _view.RenderView(&DI, &DI._rcClip);

            PerfDbgLog(tagDocPaint, this, "-CDoc::OnPaint Draw");

            if (c != 0)
            {
                // Restore the clip region set above.
                SelectClipRgn(DI._hdc, NULL);
            }
        }
    }
#endif

    if (_pTimerDraw)
        _pTimerDraw->Freeze(FALSE);

Cleanup:
    if (!DI._hdc.IsEmpty())
        SelectPalette(DI._hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    AssertSz(IsWindow(hwndInplace), "oops, the window was destroyed while we were painting");
    EndPaint(hwndInplace, &ps);
    _fDisableTiledPaint = FALSE;

#ifndef NO_ETW_TRACING
    // Send event to ETW if it is enabled by the shell.
    if (!fNoPaint && g_pHtmPerfCtl &&
        (g_pHtmPerfCtl->dwFlags & HTMPF_CALLBACK_ONEVENT)) {
        g_pHtmPerfCtl->pfnCall(EVENT_TRACE_TYPE_BROWSE_PAINT,
                               (TCHAR *)GetPrimaryUrl());
    }
#endif

#ifndef NO_RANDOMRGN
    // Find out if the window moved during paint

    ptAfter.x = ptAfter.y = 0;
    MapWindowPoints(hwndInplace, NULL, &ptAfter, 1);

    if (ptBefore.x != ptAfter.x || ptBefore.y != ptAfter.y)
    {
        TraceTag((tagDocPaint, "CDoc::OnPaint (Window moved during paint!)"));
        Invalidate(hrgn ? NULL : &ps.rcPaint, NULL, hrgn, 0);
    }

    if (hrgn)
    {
        Verify(DeleteObject(hrgn));
    }
#endif

    SwitchesEndTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "-CDoc::OnPaint");

    TraceTagEx((tagView, TAG_NONAME,
           "View : CDoc::OnPaint - Exit"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnEraseBkgnd
//
//  Synopsis:   Handle WM_ERASEBKGND
//
//----------------------------------------------------------------------------

BOOL
CDoc::OnEraseBkgnd(HDC hdc)
{
    CFormDrawInfo         DI;
    BOOL                  fHtPalette;

    if (   TestLock(SERVERLOCK_BLOCKPAINT) 
        || _fPageTransitionLockPaint)
        return FALSE;

#if DBG==1
    if(IsTagEnabled(tagDisEraseBkgnd))
        return TRUE;
#endif

    // this is evil: some nasty OLE controls (in particular, the IE Label
    // control) pass us their DC and expect us to draw our background into it.
    // This was a hack to try to simulate transparency, but it doesn't
    // even work very well. In this case, we have to avoid normal clipping
    // regions we set on the DC.  Blech.
    BOOL fDrawBackgroundForChildWindow =
        (WindowFromDC(hdc) != InPlace()->_hwnd);

    if (TestLock(SERVERLOCK_IGNOREERASEBKGND) && !fDrawBackgroundForChildWindow)
        return TRUE;

    // Framesets leave the background to the embedded frames.

    if (!fDrawBackgroundForChildWindow && PrimaryMarkup()->_fFrameSet)
        return TRUE;

    SwitchesBegTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "+CDoc::OnEraseBkgnd");

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    GetPalette(hdc, &fHtPalette);
    DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));
    GetClipBox(hdc, &DI._rcClip);
    DI._rcClipSet = DI._rcClip;
    DI._hdc = XHDC(hdc, NULL);
    DI._hic = XHDC(hdc, NULL);
    DI._fInplacePaint = TRUE;
    DI._fHtPalette = fHtPalette;

    PerfDbgLog1(tagDocPaint, this, "CDoc::OnEraseBkgnd l=%ld, t=%ld, r=%ld, b=%ld", *DI.ClipRect());

#if DBG==1

    if (IsTagEnabled(tagPaintShow) || IsTagEnabled(tagPaintPause))
    {
        HBRUSH hbr;

        // Fill the rect with blue and pause.
        hbr = GetCachedBrush(RGB(0,0,255));
        FillRect(hdc, DI.ClipRect(), hbr);
        ReleaseCachedBrush(hbr);
        GdiFlush();
        Sleep(IsTagEnabled(tagPaintPause) ? 160 : 20);
    }
#endif

#ifdef WIN16
        // when OE 16 uses us the option settings are not read immediately,
        // so we check here.
        if ( _pOptionSettings == NULL )
        {
                if ( UpdateFromRegistry(0) )
                        return TRUE;
        }
#endif

    _view.EraseBackground(&DI, &DI._rcClip, fDrawBackgroundForChildWindow);
    
    SwitchesEndTimer(SWITCHES_TIMER_PAINT);

    PerfDbgLog(tagDocPaint, this, "-CDoc::OnEraseBkgnd");

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Draw, CServer
//
//  Synopsis:   Draw the form.
//              Called from CServer implementation if IViewObject::Draw
//
//----------------------------------------------------------------------------

HRESULT
CDoc::Draw(CDrawInfo * pDI, RECT *prc)
{
    CServer::CLock Lock(this, SERVERLOCK_IGNOREERASEBKGND);

    CFormDrawInfo   DI;
    int             r;
    CSize           sizeOld;
    CSize           sizeNew;
    CPoint          ptOrgOld;
    CPoint          ptOrg;
    HRESULT         hr = S_OK;
    BOOL            fHadView = !!_view.IsActive();

    RECT            rc = *prc;
    float           clientScale[2];
    float*          pClientScale = 0;

    // CLayout *       pLayoutRoot = PrimaryRoot()->GetLayout();

    if (DVASPECT_CONTENT  != pDI->_dwDrawAspect &&
        DVASPECT_DOCPRINT != pDI->_dwDrawAspect)
    {
        RRETURN(DV_E_DVASPECT);
    }

    //
    // Do not display if we haven't received all the stylesheets
    //

    if (IsStylesheetDownload())
        return hr;

    //{
        //(mikhaill 4/6/00) Since in IE 5.5 CDocScaleInfo have lost
        //the ability to scale (not at all yet, however this ability
        //is not used and/or blocked in many places), we need to
        //promote scaling other way. So clientScale[] was added.

        SIZE sizeOutput, sizeDisplay, sizeInch;

        sizeOutput.cx = prc->right - prc->left;
        sizeOutput.cy = prc->bottom - prc->top;

        sizeInch.cx = GetDeviceCaps(pDI->_hic, LOGPIXELSX);
        sizeInch.cy = GetDeviceCaps(pDI->_hic, LOGPIXELSY);

        g_uiDisplay.DeviceFromHimetric(sizeDisplay, _sizel);

        clientScale[0] = float(sizeOutput.cx) / float(sizeDisplay.cx);
        clientScale[1] = float(sizeOutput.cy) / float(sizeDisplay.cy);

        if (clientScale[0] != 1 || clientScale[1] != 1)
            pClientScale = clientScale;

        if (_pInPlace)
        {   //hack size
            SIZE sizeDev;
            sizeDev.cx = MulDiv(_sizel.cx, sizeInch.cx, 2540);
            sizeDev.cy = MulDiv(_sizel.cy, sizeInch.cy, 2540);
            rc = _pInPlace->_rcPos;
            rc.right  = rc.left + sizeDev.cx;
            rc.bottom = rc.top  + sizeDev.cy;

            prc = &rc;
        }
    //}

    //
    // Setup drawing info.
    //

    DI.Init(CMarkup::GetElementTopHelper(PrimaryMarkup()));

    //
    // Copy the CDrawInfo information into CFormDrawInfo
    //

    *(CDrawInfo*)&DI = *pDI;

    ::SetViewportOrgEx(DI._hdc, 0, 0, &ptOrg);

    ((CRect *)prc)->OffsetRect(ptOrg.AsSize());

    DI._pDoc     = this;
    DI._pMarkup  = PrimaryMarkup();
    DI._hrgnClip = CreateRectRgnIndirect(prc);

    r = GetClipRgn(DI._hdc, DI._hrgnClip);
    if (r == -1)
    {
        DeleteObject(DI._hrgnClip);
        DI._hrgnClip = NULL;
    }

#ifdef _MAC
    DI._rcClipSet = (*prc);
#else
    r = GetClipBox(DI._hdc, &DI._rcClip);
    if (r == 0)
    {
        // No clip box, assume very large clip box to start.
        DI._rcClip.left   =
        DI._rcClip.top    = SHRT_MIN;
        DI._rcClip.right  =
        DI._rcClip.bottom = SHRT_MAX;
    }
    DI._rcClipSet = DI._rcClip;
#endif

    DI.SetUnitInfo(&g_uiDisplay);

    Assert(!DI._hic.IsEmpty());

    _dciRender = *((CDocInfo *)&DI);
    
    //
    //  *********************************** HACK FOR HOME PUBLISHER ***********************************
    //
    //  Home Publisher subclasses our HWND, taking control of WM_PAINT processing. Instead of allowing us to
    //  see the WM_PAINT, they catch the message and use IVO::Draw instead. Our asynch collect/send techniques
    //  causes them both performance problems and never-ending loops, as well as scrolling difficulties.
    //  So, the following special cases Home Publisher to make them work better (even though what they're doing
    //  is very, very bad!).
    //
    //  Essentially, the hack assumes that the IVO::Draw call is a replacement for WM_PAINT and behaves just
    //  as if WM_PAINT had been received instead. This only works when the IVO::Draw call is used by our
    //  host to supercede our WM_PAINT handling.
    //
    //  This hack can be removed once we no longer share the layout/display information maintained for our
    //  primary HWND with that used to service an IVO::Draw request.
    //
    //  (brendand)
    //
    //  *********************************** HACK FOR HOME PUBLISHER ***********************************
    //

    if (g_fInHomePublisher98)
    {
        BOOL    fViewIsReady;

        Assert(fHadView);

        fViewIsReady = _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_INPAINT | LAYOUT_DEFERPAINT);
        Assert( !fViewIsReady
            ||  !_view.IsDisplayTreeOpen());

        if (fViewIsReady)
        {
            _view.RenderView(&DI, DI._hrgnClip, &DI._rcClip);
        }
        else
        {
            _view.Invalidate(&DI._rcClip);
        }
    }

    //
    //  Otherwise, proceed as normal
    //

    else
    {
        CRegion rgnInvalid;

        //
        // Update layout if needed
        // NOTE: Normally, this code should allow the paint to take place (in fact, it should force one), but doing so
        //       can cause problems for clients that use IVO::Draw at odd times.
        //       So, instead of pushing the paint through, the simple collects the invalid region and holds on to it
        //       until it's safe (see below). (brendand)
        //

        if (!fHadView)
        {
            _view.Activate();
        }
        else
        {
            _view.EnsureView(   LAYOUT_NOBACKGROUND
                            |   LAYOUT_SYNCHRONOUS
                            |   LAYOUT_DEFEREVENTS
                            |   LAYOUT_DEFERINVAL
                            |   LAYOUT_DEFERPAINT);

            rgnInvalid = _view._rgnInvalid;
            _view.ClearInvalid();
        }

        _view.GetViewSize(&sizeOld);
        sizeNew = ((CRect *)prc)->Size();

        _view.SetViewSize(sizeNew);

        _view.GetViewPosition(&ptOrgOld);
        _view.SetViewPosition(ptOrg);

        //
        //  In all cases, ensure the view is up-to-date with the passed dimensions
        //  (Do not invalidate the in-place HWND (if any) or do anything else significant as result (e.g., fire events)
        //   since the information backing it all is transient and only relevant to this request.)
        //

        _view.EnsureView(   LAYOUT_FORCE
                        |   LAYOUT_NOBACKGROUND
                        |   LAYOUT_SYNCHRONOUS
                        |   LAYOUT_DEFEREVENTS
                        |   LAYOUT_DEFERENDDEFER
                        |   LAYOUT_DEFERINVAL
                        |   LAYOUT_DEFERPAINT);
        _view.ClearInvalid();

        //
        //  Render the sites.
        //

        _view.RenderView(&DI, DI._hrgnClip, &DI._rcClip, pClientScale);

        //
        // Restore layout if inplace.
        // (Now, bring the view et. al. back in-sync with the document. Again, do not force a paint or any other
        //  significant work during this layout pass. Once it completes, however, re-establish any held invalid
        //  region and post a call such that layout/paint does eventually occur.)
        //

        if (fHadView)
        {
            _view.SetViewSize(sizeOld);
            _view.SetViewPosition(ptOrgOld);
            _view.EnsureView(   LAYOUT_FORCE
                            |   LAYOUT_NOBACKGROUND
                            |   LAYOUT_SYNCHRONOUS
                            |   LAYOUT_DEFEREVENTS
                            |   LAYOUT_DEFERENDDEFER
                            |   LAYOUT_DEFERINVAL
                            |   LAYOUT_DEFERPAINT);
            _view.ClearInvalid();

            if (!rgnInvalid.IsEmpty())
            {
                _view.OpenView();
                _view._rgnInvalid = rgnInvalid;
            }
        }
        else
        {
            _view.Deactivate();
        }
    }

//Cleanup:
    if (DI._hrgnClip)
        DeleteObject(DI._hrgnClip);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::DrawImageFlags
//
//  Synopsis:   Return DRAWIMAGE flags to be used when drawing with the DI
//
//----------------------------------------------------------------------------
DWORD
CFormDrawInfo::DrawImageFlags()
{
    return _fHtPalette ? 0 : DRAWIMAGE_NHPALETTE;
}

//-----------------------------------------------------
//
//  Member:     GetPalette
//
//  Synopsis:   Returns the current document palette and optionally
//              selects it into the destation DC.
//
//              The palette returned depends on several factors.
//              If there is an ambient palette, we always use that.
//              If the buffer depth or the screen depth is 8 (actually
//              if the screen is palettized) then we use whatever we
//              use _pColors
//      The final choice of palette is affected by several things:
//      _hpalAmbient (modified by OnAmbientPropertyChange)
//      _pColors (modified by InvalidateColors)
//
//

HPALETTE
CDoc::GetPalette(HDC hdc, BOOL *pfHtPal, BOOL * pfPaletteSwitched)
{
    HPALETTE    hpal;
    BOOL        fHtPal;
    BOOL        fPaletteSwitched = FALSE;
    
    // IE5 bug 65066 (dbau)
    // A buggy host can delete our ambient palette without warning us; 
    // let's detect and partially protect against that situation;
    // With a bit of paranoia, we also give _hpalDocument the same treatment.
    
    if (_hpalAmbient && GetObjectType((HGDIOBJ)_hpalAmbient) != OBJ_PAL)
    {
        TraceTag((tagError, "Error! Ambient palette was deleted from underneath mshtml.dll. Clearing value."));
        _hpalAmbient = NULL;
        _fHtAmbientPalette = FALSE;
    }
    
    if (_hpalDocument && GetObjectType((HGDIOBJ)_hpalDocument) != OBJ_PAL)
    {
        TraceTag((tagError, "Error! Document palette was deleted from underneath mshtml.dll. Clearing value."));
        _hpalDocument = NULL;
        _fHtDocumentPalette = FALSE;
    }
    
    hpal = _hpalAmbient;
    fHtPal = _fHtAmbientPalette;
    
    if (!hpal && (_bufferDepth == 8 || (GetDeviceCaps(TLS(hdcDesktop), RASTERCAPS) & RC_PALETTE)))
    {
        if (_hpalDocument)
        {
            hpal = _hpalDocument;
            fHtPal = _fHtDocumentPalette;
        }
        else
        {
            if (!_pColors)
            {
                CColorInfo CI;
                UpdateColors(&CI);
            }

            if (_pColors)
            {
                hpal = _hpalDocument = CreatePalette(_pColors);
                _fHtDocumentPalette = fHtPal = IsHalftonePalette(hpal);
            }
            else
            {
                hpal = GetDefaultPalette();
                fHtPal = TRUE;
            }
        }
    }

    if (pfHtPal)
    {
        *pfHtPal = fHtPal;
    }

    if (hpal && hdc)
    {
        SelectPalette(hdc, hpal, TRUE);
        RealizePalette(hdc);

        fPaletteSwitched = TRUE;
    }
    
    if (pfPaletteSwitched)
    {
        *pfPaletteSwitched = fPaletteSwitched;
    }

    return hpal;
}

//---------------------------------------
//
//  Member:     GetColors
//
//  Synopsis:   Computes the document color set (always for DVASPECT_CONTENT)
//              Unlike IE 3, we don't care about the UIActive control, instead
//              we allow the author to define colors.
//
//
HRESULT
CDoc::GetColors(CColorInfo *pCI)
{
    HRESULT hr = S_OK;

    if (_fGotAuthorPalette)
    {
        // REVIEW - michaelw (Can I count on having a _pDwnDoc)
        Assert(PrimaryMarkup()->GetDwnDoc());
        hr = PrimaryMarkup()->GetDwnDoc()->GetColors(pCI);
    }

    if (SUCCEEDED(hr) && !pCI->IsFull())
    {
        CElement *pElementClient = CMarkup::GetElementClientHelper(PrimaryMarkup());
        
        hr = pElementClient ? pElementClient->GetColors(pCI) : S_FALSE;
    }

    //
    // Add the halftone colors in, only if we are not
    // hosted as a frame.  This isn't the place to
    // add system colors, that will get done by GetColorSet
    //
    if (SUCCEEDED(hr) && !pCI->IsFull())
        hr = pCI->AddColors(236, &g_lpHalftone.ape[10]);

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::UpdateColors(CColorInfo *pCI)
{
    HRESULT hr = GetColors(pCI);

    if (SUCCEEDED(hr))
    {
        hr = pCI->GetColorSet(&_pColors);
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CDoc::GetColorSet(DWORD dwDrawAspect, LONG lindex, void * pvAspect, DVTARGETDEVICE * ptd, HDC hicTargetDev, LPLOGPALETTE * ppColorSet)
{
    if (ppColorSet == NULL)
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    // We only cache the colors for DVASPECT_CONTENT

    if (dwDrawAspect != DVASPECT_CONTENT)
    {
        CColorInfo CI(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev);

        hr = GetColors(&CI);

        if (SUCCEEDED(hr))
            hr = CI.GetColorSet(ppColorSet);
    }
    else
    {
        if (!_pColors)
        {
            CColorInfo CI(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev);

            hr = UpdateColors(&CI);
        }

        if (hr == S_OK && _pColors)
        {
            unsigned cbColors = GetPaletteSize(_pColors);
            *ppColorSet = (LPLOGPALETTE) CoTaskMemAlloc(cbColors);
            if (*ppColorSet)
            {
                memcpy(*ppColorSet, _pColors, cbColors);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            *ppColorSet = NULL;
            hr = S_FALSE;
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InvalidateColors()
//
//  Synopsis:   Invalidates the color set of the document.
//
//----------------------------------------------------------------------------
void
CDoc::InvalidateColors()
{
    TraceTag((tagPalette, "InvalidateColors"));
    if (!_fColorsInvalid)
    {
        _fColorsInvalid = TRUE;

        GWPostMethodCallEx(GetThreadState(), (void *)this,
                           ONCALL_METHOD(CDoc, OnRecalcColors, onrecalccolors),
                           0, FALSE, "CDoc::OnRecalcColors");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::RecalcColors()
//
//  Synopsis:   Recalcs the colors of the document and if necessary, notify's
//              our container.
//
//----------------------------------------------------------------------------

void
CDoc::OnRecalcColors(DWORD_PTR dwContext)
{
    TraceTag((tagPalette, "OnRecalcColors"));
    LOGPALETTE *pColors = NULL;

    CColorInfo CI;

    if (SUCCEEDED(GetColors(&CI)))
    {
        CI.GetColorSet(&pColors);
    }


    //
    // If the palettes are different, we need to broadcast the change
    //

    if ((pColors == 0) && (_pColors == 0))
        goto Cleanup;

    if (!pColors || !_pColors || ComparePalettes(pColors, _pColors))
    {
        TraceTag((tagPalette, "Document palette has changed!"));
        CoTaskMemFree(_pColors);
        _pColors = pColors;

#if 0
        _fNonhalftonePalette = ComparePalettes((LOGPALETTE *)&g_lpHalftone, pColors);
#endif

        //
        // Force the document palette (if any) to be recreated
        //
        if (_hpalDocument)
        {
            DeleteObject(_hpalDocument);
            _hpalDocument = 0;
            _fHtDocumentPalette = FALSE;
        }

        // If our container doesn't implement the ambient palette then we must
        // be faking it.  Now is the time to broadcast the change.
        if (GetAmbientPalette() == NULL)
        {
            CNotification   nf;

            nf.AmbientPropChange(PrimaryRoot(), (void *)DISPID_AMBIENT_PALETTE);
            BroadcastNotify(&nf);
        }

        //
        // This is the new, efficient way to say that our colors have changed.
        // The shell can avoid setting and advise sink (since it really doesn't
        // need it for any other reason) and just watch for this.  This prevents
        // palette recalcs everytime we do OnViewChange.
        //
        if (_pClientSite)
        {
            IOleCommandTarget *pCT;
            HRESULT hr = THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **) &pCT));
            if (!hr)
            {
                VARIANT v;

                VariantInit(&v);

                V_VT(&v) = VT_BYREF;
                V_BYREF(&v) = pColors;

                THR_NOTRACE(pCT->Exec(
                        &CGID_ShellDocView,
                        SHDVID_ONCOLORSCHANGE,
                        OLECMDEXECOPT_DONTPROMPTUSER,
                        &v,
                        NULL));
                pCT->Release();
            }
        }
        OnViewChange(DVASPECT_CONTENT);
    }
    else
        CoTaskMemFree(pColors);

Cleanup:
    // Clear the way for the next InvalidateColors to force a RecalcColors.  If
    // for some bizarre reason RecalcColors (and by implication GetColors) causes
    // someone to call InvalidateColors after we've checked them, tough luck.
    _fColorsInvalid = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::updateInterval
//
//  Synopsis:   Set the paint update interval. Throttles multiple controls
//              that are randomly invalidating into a periodic painting
//              interval.
//
//----------------------------------------------------------------------------
void
CDoc::UpdateInterval(long interval)
{
    ITimerService  *pTM = NULL;
    VARIANT         vtimeMin, vtimeMax, vtimeInt;

    interval = interval < 0 ? 0 : interval; // no negative values
    VariantInit( &vtimeMin );    V_VT(&vtimeMin) = VT_UI4;
    VariantInit( &vtimeMax );    V_VT(&vtimeMax) = VT_UI4;
    VariantInit( &vtimeInt );    V_VT(&vtimeInt) = VT_UI4;

    if ( !_pUpdateIntSink )
    {
        if ( 0 == interval )
            return;

        // allocate timer and sink
        TraceTag((tagUpdateInt, "creating updateInterval sink"));
        Assert( !_pUpdateIntSink );
        _pUpdateIntSink = new CDocUpdateIntSink( this );
        if ( !_pUpdateIntSink )
            goto error;

        if ( FAILED(QueryService( SID_STimerService, IID_ITimerService, (void **)&pTM )) )
            goto error;

        if ( FAILED(pTM->GetNamedTimer( NAMEDTIMER_DRAW,
                                        &_pUpdateIntSink->_pTimer )) )
            goto error;

        pTM->Release();
        pTM = NULL;
    }

    if ( 0 == interval )
    {
        // disabling updateInterval, invalidate what we have
        HRGN    hrgn = _pUpdateIntSink->_hrgn;
        DWORD hrgnFlags = _pUpdateIntSink->_dwFlags;

        TraceTag((tagUpdateInt, "deleting updateInterval sink. Cookie = %d", _pUpdateIntSink->_cookie));
        _pUpdateIntSink->_pDoc = NULL;      // let sink know not to respond.
        _pUpdateIntSink->_pTimer->Unadvise( _pUpdateIntSink->_cookie );
        _pUpdateIntSink->_pTimer->Release();
        _pUpdateIntSink->Release();
        _pUpdateIntSink = NULL;
        Invalidate( NULL, NULL, hrgn, hrgnFlags );
        DeleteObject( hrgn );

    }
    else if ( interval != _pUpdateIntSink->_interval )
    {
        // reset timer interval
        _pUpdateIntSink->_pTimer->GetTime(&vtimeMin);
        V_UI4(&vtimeMax) = 0;
        V_UI4(&vtimeInt) = interval;
        _pUpdateIntSink->_pTimer->Unadvise( _pUpdateIntSink->_cookie );     // ok if 0
        if ( FAILED(_pUpdateIntSink->_pTimer->Advise(vtimeMin, vtimeMax,
                                                     vtimeInt, 0,
                                                     (ITimerSink *)_pUpdateIntSink,
                                                     &_pUpdateIntSink->_cookie )) )
            goto error;

        _pUpdateIntSink->_interval = interval;
        TraceTag((tagUpdateInt, "setting updateInterval = %d", _pUpdateIntSink->_interval));
    }

cleanup:
    return;

error:
    if ( _pUpdateIntSink )
    {
        ReleaseInterface( _pUpdateIntSink->_pTimer );
        _pUpdateIntSink->Release();
        _pUpdateIntSink = NULL;
    }
    ReleaseInterface( pTM );
    goto cleanup;
}

LONG CDoc::GetUpdateInterval()
{
    return _pUpdateIntSink ? _pUpdateIntSink->_interval : 0;
}

BOOL IntersectRgnRect(HRGN hrgn, RECT *prc, RECT *prcIntersect)
{
    BOOL fIntersects;
    HRGN hrgnScratch;

    if (!hrgn)
    {
        Assert(prc && prcIntersect);

        *prcIntersect = *prc;
        fIntersects = TRUE;

        return fIntersects;
    }

    hrgnScratch = CreateRectRgnIndirect(prc);
    if (hrgnScratch)
    {
        switch (CombineRgn(hrgnScratch, hrgnScratch, hrgn, RGN_AND))
        {
        case NULLREGION:
            memset(prcIntersect, 0, sizeof(*prcIntersect));
            fIntersects = FALSE;
            break;

        default:
            if (GetRgnBox(hrgnScratch, prcIntersect) != ERROR)
            {
                fIntersects = TRUE;
                break;
            }
            // fall through

        case ERROR:
            *prcIntersect = *prc;
            fIntersects = TRUE;
            break;
        }

        DeleteObject(hrgnScratch);
    }
    else
        fIntersects = FALSE;

    return fIntersects;
}


/******************************************************************************
                CDocUpdateIntSink
******************************************************************************/
CDocUpdateIntSink::CDocUpdateIntSink( CDoc *pDoc )
{
    _pDoc = pDoc;
    _hrgn = 0;
    _dwFlags = 0;
    _state = UPDATEINTERVAL_EMPTY;
    _interval = 0;
    _pTimer = NULL;
    _cookie = 0;
    _ulRefs = 1;
}

CDocUpdateIntSink::~CDocUpdateIntSink( )
{
    Assert( !_pDoc );     // Makes sure CDoc knows we are on our way out.
}

ULONG
CDocUpdateIntSink::AddRef()
{
    return ++_ulRefs;
}

ULONG
CDocUpdateIntSink::Release()
{
    if ( 0 == --_ulRefs )
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CDocUpdateIntSink::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerSink *)this, IUnknown)
        QI_INHERITS(this, ITimerSink)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method:     OnTimer             [ITimerSink]
//
//  Synopsis:   Takes the accumulated region and invalidates the window
//
//  Arguments:  timeAdvie - the time that the advise was set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CDocUpdateIntSink::OnTimer( VARIANT vtimeAdvise )
{
    TraceTag((tagUpdateInt, "CDocUpdateIntSink::OnTimer "));
    if ( _state != UPDATEINTERVAL_EMPTY &&
         _pDoc && _pDoc->_state >= OS_INPLACE &&
         _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
    {
        TraceTag((tagUpdateInt, "CDocUpdateIntSink::OnTimer redrawing window at %d", V_UI4(&vtimeAdvise) ));
        Assert(_pDoc->_pInPlace);

        Assert(_pDoc->_pInPlace->_hwnd);
        RedrawWindow( _pDoc->_pInPlace->_hwnd, (GDIRECT *)NULL, _hrgn, _dwFlags );

        if ( _hrgn )
        {
            DeleteObject( _hrgn );
            _hrgn = NULL;
        }
        _state = UPDATEINTERVAL_EMPTY;
        _dwFlags = 0;

        UpdateWindow( _pDoc->_pInPlace->_hwnd );
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    XHDC    hdc,
    RECT *  prcClip)
{
    _hdc = (hdc != NULL) ?
                hdc :
                XHDC(TLS(hdcDesktop), NULL);
    _hic = _hdc;

    _fInplacePaint = TRUE;
    _dwDrawAspect  = DVASPECT_CONTENT;
    _lindex        = -1;

    _dvai.cb       = sizeof(_dvai);
    _dvai.dwFlags  = DVASPECTINFOFLAG_CANOPTIMIZE;
    _pvAspect      = (void *)&_dvai;

    _rcClip.top    =
    _rcClip.left   = LONG_MIN;
    _rcClip.bottom =
    _rcClip.right  = LONG_MAX;

    // TODO (KTam, GregLett): Do we need equivalent functionality
    // to FixupForPrint under NATIVE_FRAME?
    if(_pDoc->State()     >= OS_INPLACE            &&
             _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
    {
        IntersectRect(&_rcClipSet,
                      &_pDoc->_pInPlace->_rcClip,
                      &_pDoc->_pInPlace->_rcPos);
    }
    else
    {
        _rcClipSet = g_Zero.rc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    CElement * pElement,
    XHDC    hdc,
    RECT *  prcClip)
{
    memset(this, 0, sizeof(*this));

    Assert(pElement);

    CDocInfo::Init(pElement);

    Init(hdc, prcClip);

    InitToSite(pElement->GetUpdatedLayout(), prcClip);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::Init
//
//  Synopsis:   Initialize paint info for painting to form's hwnd
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::Init(
    CLayout * pLayout,
    XHDC    hdc,
    RECT *  prcClip)
{
    Assert(pLayout);

    Init(pLayout->ElementOwner(), hdc, prcClip);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormDrawInfo::InitToSite
//
//  Synopsis:   Reduce/set the clipping RECT to the visible portion of
//              the passed CSite
//
//----------------------------------------------------------------------------

void
CFormDrawInfo::InitToSite(CLayout * pLayout, RECT * prcClip)
{
    RECT    rcClip;
    RECT    rcUserClip;

    //
    // For CRootElement (no layout) on normal documents,
    // initialize the clip RECT to that of the entire document
    //
    if (!pLayout && !_pMarkup->IsPrintMedia())
    {
        if (_pDoc->State()     >= OS_INPLACE            &&
            _pDoc->LoadStatus() >= LOADSTATUS_INTERACTIVE )
        {
            IntersectRect(&rcClip,
                          &_pDoc->_pInPlace->_rcClip,
                          &_pDoc->_pInPlace->_rcPos);
        }
        else
        {
            rcClip = g_Zero.rc;
        }

        rcUserClip = rcClip;
    }

    //
    // For all sites other than CRootSite or CRootSite on print documents,
    // set _rcClip to the visible client RECT
    // NOTE: Do not pass _rcClip to prevent its modification during initialization
    //

    else
    {
// TODO: This needs to be fixed! (brendand)
        rcClip     =
        rcUserClip = g_Zero.rc;
    }

    //
    // Reduce the current clipping RECT
    //

    IntersectRect(&_rcClip, &_rcClip, &rcClip);

    //
    // If the clip RECT is empty, canonicalize it to all zeros
    //

    if (IsRectEmpty(&_rcClip))
    {
        _rcClip = g_Zero.rc;
    }

    //
    // If passed a clipping RECT, use it to reduce the clip RECT
    //

    if (prcClip)
    {
        IntersectRect (&_rcClip, &_rcClip, prcClip);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     GetDC, GetGlobalDC, GetDirectDrawSurface, GetSurface
//
//  Synopsis:   Each of these is a simple layer over the true CDispSurface call
//
//----------------------------------------------------------------------------

XHDC
CFormDrawInfo::GetDC(const RECT& rcWillDraw, BOOL fGlobalCoords)
{
    if (_pSurface)
    {
        HDC hdcT;
        _pSurface->SetClip(rcWillDraw, fGlobalCoords);
        _pSurface->GetDC(&hdcT);
        _hdc = XHDC(hdcT, _pSurface);
    }
    else
    {
        _hdc = NULL;
    }

    return _hdc;
}


HRESULT
CFormDrawInfo::GetDirectDrawSurface(
    IDirectDrawSurface **   ppSurface,
    SIZE *                  pOffset)
{
    return _pSurface
                ? _pSurface->GetDirectDrawSurface(ppSurface, pOffset)
                : E_FAIL;
}


HRESULT
CFormDrawInfo::GetSurface(
    BOOL        fPhysicallyClip,
    const IID & iid,
    void **     ppv,
    SIZE *      pOffset)
{
    HRESULT hr =  _pSurface
                ? _pSurface->GetSurface(iid, ppv, pOffset)
                : E_FAIL;

    if (!hr)
    {
        Assert(_pSurface);
        _pSurface->SetClip( fPhysicallyClip ? _rc : _rcClip );
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSetDrawInfo::CSetDrawInfo
//
//  Synopsis:   Initialize a CSetDrawInfo
//
//----------------------------------------------------------------------------

CSetDrawSurface::CSetDrawSurface(
    CFormDrawInfo * pDI,
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pSurface)
{
    Assert(pDI);
    Assert(pSurface);

    _pDI      = pDI;
    _hdc      = pDI->_hdc;
    _pSurface = pDI->_pSurface;

    _pDI->_pSurface = pSurface;
    _pDI->_rc       = *prcBounds;
    _pDI->_rcClip   = *prcRedraw;
    _pDI->_fIsMemoryDC = _pDI->_pSurface->IsMemory();
    _pDI->_fIsMetafile = _pDI->_pSurface->IsMetafile();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDocInfo::Init
//
//  Synopsis:   Initialize a CDocInfo.
//
//----------------------------------------------------------------------------

void
CDocInfo::Init(CElement * pElement)
{
    Assert(pElement);

    //  TODO  The _pDoc set here will be overwritten in the memcpy Init below.
    _pDoc = pElement->Doc();
    Assert(_pDoc);

    Init(_pDoc->GetView()->GetMeasuringDevice(mediaTypeNotSet));

    _pMarkup = pElement->GetMarkup();
    Assert(_pMarkup);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentInfo::Init
//
//  Synopsis:   Initialize a CParentInfo.
//
//----------------------------------------------------------------------------

void
CParentInfo::Init()
{
    _sizeParent = g_Zero.size;
}

void
CParentInfo::Init(const CDocInfo * pdci)
{
    Assert(pdci);

    ::memcpy(this, pdci, sizeof(CDocInfo));

    Init();
}

void
CParentInfo::Init(const CCalcInfo * pci)
{
    ::memcpy(this, pci, sizeof(CParentInfo));
}

void
CParentInfo::Init(SIZE * psizeParent)
{
    SizeToParent(psizeParent
                    ? psizeParent
                    : &g_Zero.size);
}

void
CParentInfo::Init(CLayout * pLayout)
{
    Assert(pLayout);
    
    CDocInfo::Init(pLayout->ElementOwner());

    // Pick up measurement resolution from context if available.

    SetLayoutContext( pLayout->DefinedLayoutContext() );
    if ( !GetLayoutContext() )
        SetLayoutContext( pLayout->LayoutContext() );

    CLayoutContext *pLayoutContext = GetLayoutContext();

    if ( pLayoutContext
        && pLayoutContext->IsValid())
    {
        CDocScaleInfo::Copy(*pLayoutContext->GetMeasureInfo());
    }
    
    SizeToParent(pLayout);

    Assert(pLayoutContext || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
    Assert(    pLayout->DefinedLayoutContext() == pLayoutContext
           || !pLayout->DefinedLayoutContext() && pLayout->LayoutContext() == pLayoutContext);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentInfo::SizeToParent
//
//  Synopsis:   Set the parent size to the client RECT of the passed CLayout
//
//----------------------------------------------------------------------------

void
CParentInfo::SizeToParent(CLayout * pLayout)
{
    RECT    rc;

    Assert(pLayout);

    pLayout->GetClientRect(&rc);
    SizeToParent(&rc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCalcInfo::Init
//
//  Synopsis:   Initialize a CCalcInfo.
//
//----------------------------------------------------------------------------

void
CCalcInfo::Init()
{
    _smMode     = SIZEMODE_NATURAL;
    _grfLayout  = 0L;
    _hdc        = XHDC(( _pDoc ? _pDoc->GetHDC() : TLS(hdcDesktop) ), NULL);
    _cyAvail    = 0;
    _cxAvailForVert = 0;
    _yConsumed  = 0;
    _yBaseLine  = 0;
    _grfFlags   = 0;
    _sizeParentForVert = _sizeParent;
}

void
CCalcInfo::Init(const CDocInfo * pdci, CLayout * pLayout)
{
    CView *     pView;
    DWORD       grfState;

    Assert(pdci);
    Assert(pLayout);

    ::memcpy(this, pdci, sizeof(CDocInfo));

    CParentInfo::Init(pLayout);

    Init();

    pView = pLayout->GetView();
    Assert(pView);

    grfState = pView->GetState();

    if (!(grfState & (CView::VS_OPEN | CView::VS_INLAYOUT | CView::VS_INRENDER)))
    {
        Verify(pView->OpenView());
    }
    
    Assert(GetLayoutContext() || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
}

void
CCalcInfo::Init(CLayout * pLayout, SIZE * psizeParent, XHDC hdc)
{
    CView *     pView;
    DWORD       grfState;

    CParentInfo::Init(pLayout);

    _smMode    = SIZEMODE_NATURAL;
    _grfLayout = 0L;

    // If a DC was passed in, use that one - else ask the doc which DC to use.
    // Only if there is no doc yet, use the desktop DC.
    if (hdc != NULL)
        _hdc = hdc;
    else if (_pDoc)
        _hdc = XHDC(_pDoc->GetHDC(), NULL);
    else
        _hdc = XHDC(TLS(hdcDesktop), NULL);

    _cyAvail   = 0;
    _cxAvailForVert = 0;
    _yConsumed = 0;
    _yBaseLine = 0;
    _grfFlags  = 0;
    _sizeParentForVert = _sizeParent;
    
    pView = pLayout->GetView();
    Assert(pView);

    grfState = pView->GetState();

    if (!(grfState & (CView::VS_OPEN | CView::VS_INLAYOUT | CView::VS_INRENDER)))
    {
        Verify(pView->OpenView());
    }
    
    Assert(GetLayoutContext() || (!pLayout->DefinedLayoutContext() && !pLayout->LayoutContext()));
}

#if DBG == 1
const TCHAR * achSizeModeNames[SIZEMODE_MAX] =
{
    _T("NATURAL"),      // SIZEMODE_NATURAL
    _T("SET"),          // SIZEMODE_SET
    _T("FULLSIZE"),     // SIZEMODE_FULLSIZE
    _T("MMWIDTH"),      // SIZEMODE_MMWIDTH
    _T("MINWIDTH"),     // SIZEMODE_MINWIDTH
    _T("PAGE"),         // SIZEMODE_PAGE
    _T("NATURALMIN"),   // SIZEMODE_NATURALMIN
};

const TCHAR *
CCalcInfo::SizeModeName() const
{
    return (_smMode >= 0 && _smMode < SIZEMODE_MAX) ? achSizeModeNames[_smMode] : _T("#ERR");
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLabel
//
//  Synopsis:   Return any label element associated with this element. If the
//              element has no label, return NULL. If the element has more than
//              one label, return the first one encountered in the collection.
//
//----------------------------------------------------------------------------

CLabelElement *
CElement::GetLabel() const
{
    HRESULT         hr = S_OK;
    CElement *      pElem;
    CLabelElement * pLabel = NULL;
    int             iCount, iIndex;
    LPCTSTR         pszIdFor, pszId;
    CCollectionCache *pCollectionCache;
    CMarkup *       pMarkup;

    // check if there is label associated with this site

    pszId = GetAAid();
    if (!pszId || lstrlen(pszId) == 0)
        goto Cleanup;

    pMarkup = GetMarkupPtr();
    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::LABEL_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = pMarkup->CollectionCache();
    iCount = pCollectionCache->SizeAry(CMarkup::LABEL_COLLECTION);
    if (iCount <= 0)
        goto Cleanup;

    for (iIndex = iCount - 1; iIndex >= 0; iIndex--)
    {
        hr = THR(pCollectionCache->GetIntoAry(
                CMarkup::LABEL_COLLECTION,
                iIndex,
                &pElem));
        if (hr)
            goto Cleanup;

        pLabel = DYNCAST(CLabelElement, pElem);
        pszIdFor = pLabel->GetAAhtmlFor();
        if (!pszIdFor || lstrlen(pszIdFor) == 0)
            continue;

        if (!FormsStringICmp(pszIdFor, pszId))
            break; // found the associated label
    }

    if (iIndex < 0)
        pLabel = NULL;

Cleanup:
    // ignore hr
    return pLabel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\omdoc.cxx ===
//+------------------------------------------------------------------------
//
//  File:       OMDOC.CXX
//
//  Contents:   OmDocument
//
//  Classes:    COmDocument
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

IMPLEMENT_SUBOBJECT_IUNKNOWN(COmDocument, CDoc, Doc, _OmDocument)


//+-------------------------------------------------------------------------
//
//  Method:     COmDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
COmDocument::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;
    const IID * const * apIID = NULL;
    extern const IID * const g_apIID_IDispatchEx[];

    *ppv = NULL;

    if (!IsMyParentAlive())
    {
        RRETURN(E_UNEXPECTED);
    }
    else if (iid == IID_IProvideMultipleClassInfo ||
        iid == IID_IProvideClassInfo ||
        iid == IID_IProvideClassInfo2)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIProvideMultipleClassInfo;
    }
    else if (iid == IID_IDispatchEx || iid == IID_IDispatch)
    {
        apIID = g_apIID_IDispatchEx;
        pv = (IDispatchEx *)Doc();
        apfn = *(void **)pv;
    }
    else if (iid == IID_IHTMLDocument ||
        iid == IID_IHTMLDocument2)
    {
        pv = (IHTMLDocument2 *)Doc();
        apfn = *(void **)pv;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(Doc(), this);
        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
    }
    else if (iid == IID_IUnknown)
    {
        *ppv = (IUnknown *)this;
    }
    else if (iid == IID_IMarkupServices)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIMarkupServices;
    }
    else if (iid == IID_IHTMLViewServices)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIHTMLViewServices;
    }
#if DBG == 1
    else if ( iid == IID_IEditDebugServices )
    {
        pv = Doc();
        apfn = CDoc::s_apfnIEditDebugServices;        
    }
#endif
    else if (iid == IID_IServiceProvider )
    {
        pv = Doc();
        apfn = CDoc::s_apfnIServiceProvider;
    }
    else if (iid == IID_IOleWindow)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
    }
    else if (iid == IID_IOleCommandTarget)
    {
        pv = Doc();
        apfn = CDoc::s_apfnIOleCommandTarget;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    if (pv)
    {
        Assert(apfn);
        hr = THR(CreateTearOffThunk(
                pv, 
                apfn, 
                NULL, 
                ppv, 
                (IUnknown *)this, 
                *(void **)(IUnknown *)this,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                apIID));
        if (hr)
            RRETURN(hr);
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();

    DbgTrackItf(iid, "COmDocument", FALSE, ppv);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peerdoc.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

DeclareTag(tagPeerCMarkupAttachPeerUrl,                    "Peer", "trace CMarkup::AttachPeerUrl")
DeclareTag(tagPeerCMarkupAttachPeers,                      "Peer", "trace CMarkup::AttachPeers[Css]")
DeclareTag(tagPeerCMarkupAttachPeersEmptyPH,               "Peer", "CMarkup::AttachPeers: add empty peer holders to the list")
DeclareTag(tagPeerCMarkupPeerDequeueTasks,                 "Peer", "trace CMarkup::PeerDequeueTasks")
DeclareTag(tagPeerCMarkupProcessPeerTasks,                 "Peer", "trace CMarkup::ProcessPeerTasks")

MtDefine(CDoc_aryElementChangeVisibility_pv, CDoc, "CDoc::_aryElementChangeVisibility_pv::_pv")
MtDefine(CMarkupPeerTaskContext_aryPeerQueue_pv, CMarkup, "CMarkup::AttachPeers::aryUrls")
MtDefine(CMarkupBehaviorContext_aryPeerElems_pv, CMarkup, "CMarkup::_aryPeerElems_pv::_pv")

HRESULT CLSIDFromHtmlString(TCHAR *pchClsid, CLSID *pclsid);

#if DBG == 1
void TraceProcessPeerTask(CElement * pElement, BOOL fIdentity, CBehaviorInfo * pCss, LPTSTR pchMsg);
#endif

//////////////////////////////////////////////////////////////////////
//
// CDoc - parsing generic elements
//
//////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsGenericElement
//
//--------------------------------------------------------------------

ELEMENT_TAG
CDoc::IsGenericElement (LPTSTR pchFullName, LPTSTR pchColon)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;

    if (pchColon)
    {
        //
        // sprinkle in a host defined namespace?
        //

        etag = IsGenericElementHost(pchFullName, pchColon);
        if (ETAG_UNKNOWN != etag)
            goto Cleanup;           // done
    }
    else
    {
        //
        // builtin tag?
        //

        if (GetBuiltinGenericTagDesc(pchFullName))
            etag = ETAG_GENERIC_BUILTIN;
    }

Cleanup:

    return etag;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsGenericElementHost
//
//--------------------------------------------------------------------

ELEMENT_TAG
CDoc::IsGenericElementHost (LPTSTR pchFullName, LPTSTR pchColon)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;
    LPTSTR          pchHost;
    int             l;

    Assert (pchColon);

    pchHost = _cstrHostNS;
    
    // for debugging
    // pchHost = _T("FOO;A;AA;AAA;B");
    
    if (pchHost)
    {
        l = pchColon - pchFullName;

        // CONSIDER (alexz): use an optimal linear algorithm here instead of this one with quadratic behavior

        for (;;)
        {
            if (0 == StrCmpNIC(pchHost, pchFullName, l) &&
                (0 == pchHost[l]) || _T(';') == pchHost[l])
            {
                etag = ETAG_GENERIC;
                goto Cleanup;
            }

            pchHost = StrChr(pchHost, _T(';'));
            if (!pchHost)
                break;

            pchHost++;  // advance past ';'
        }
    }

Cleanup:

    return etag;
}

//////////////////////////////////////////////////////////////////////
//
// CDoc - behavior hosting code
//
//////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CDoc::FindHostBehavior
//
//--------------------------------------------------------------------

HRESULT
CDoc::FindHostBehavior(
    const TCHAR *           pchPeerName,
    const TCHAR *           pchPeerUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT hr = E_FAIL;

    if (_pHostPeerFactory)
    {
        hr = THR_NOTRACE(FindPeer(_pHostPeerFactory, pchPeerName, pchPeerUrl, pSite, ppPeer));
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     GetUrlFromDefaultBehaviorName
//
//--------------------------------------------------------------------

HRESULT
GetUrlFromDefaultBehaviorName(LPCTSTR pchName, LPTSTR pchUrl, UINT cchUrl)
{
    HRESULT     hr = S_OK;
    LONG        lRet;
    HKEY        hKey = NULL;
    DWORD       dwBufSize;
    DWORD       dwKeyType;

    //
    // read registry
    //

    lRet = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        _T("Software\\Microsoft\\Internet Explorer\\Default Behaviors"),
        0,
        KEY_QUERY_VALUE,
        &hKey);
    if (ERROR_SUCCESS != lRet || !hKey)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwBufSize = cchUrl;
    lRet = RegQueryValueEx(hKey, pchName, NULL, &dwKeyType, (LPBYTE)pchUrl, &dwBufSize);
    if (ERROR_SUCCESS != lRet || REG_SZ != dwKeyType)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (hKey)
        RegCloseKey (hKey);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::FindDefaultBehaviorFactory
//
//--------------------------------------------------------------------

HRESULT
CDoc::FindDefaultBehaviorFactory(
    LPTSTR                      pchName,
    LPTSTR                      pchUrl,
    IElementBehaviorFactory **  ppFactory,
    LPTSTR                      pchUrlDownload,
    UINT                        cchUrlDownload)
{
    HRESULT                     hr = E_FAIL;
    HRESULT                     hr2;
    BOOL                        fRegistry = TRUE;
    TCHAR                       achUrl[pdlUrlLen];
    uCLSSPEC                    classpec;
    IElementBehaviorFactory *   pPeerFactory = NULL;
    CPeerFactoryDefault *       pPeerFactoryDefault = NULL;

    CLock                       lock(this); // this is to make sure the doc does not passivate while inside FaultInIEFeature

    Assert (ppFactory);
    *ppFactory = NULL;

    if (pchName)
    {
        //
        // look it up in registry and negotiate with host
        //

        hr2 = THR_NOTRACE(GetUrlFromDefaultBehaviorName(pchName, achUrl, ARRAY_SIZE(achUrl)));
        if (S_OK == hr2)
        {
            //
            // found the name in registry. Now make sure host does not implement this behavior;
            // if it does, let the one from host get thru
            // TODO (alexz) reconsider this; remove the call if possible
            //

            hr2 = THR_NOTRACE(FindHostBehavior(pchName, pchUrl, NULL, NULL));
            if (S_OK == hr2)
            {
                fRegistry = FALSE;
            }
        }
        else
        {
            fRegistry = FALSE;
        }

        //
        // prepare the factory info from url
        //

        if (fRegistry)
        {
            hr2 = THR_NOTRACE(CLSIDFromHtmlString(achUrl, &classpec.tagged_union.clsid));
            if (S_OK == hr2)
            {
                //
                // if this is a "CLSID:", ensure it is JIT downloaded and cocreate it's factory;
                //

                // TODO (alexz, kgallo) if FaultInIEFeatureHelper returns S_FALSE,
                // this means that the feature is not IE JIT-able.
                // temporarily, we allow the following situation:
                //      HTML+TIME is no longer marked in registry as IE JIT-able feature, but we 
                //      still call FaultInIEFeatureHelper for it.
                // This is now more fragile for anyone who introduces a new feature but forgets
                // to mark it as JIT-able feature in registry. In that case we we will no longer
                // assert as we used to do before.
                // opened IE 5.5 B3 bug 93581 for this

                classpec.tyspec = TYSPEC_CLSID;

                hr = THR(FaultInIEFeatureHelper(GetHWND(), &classpec, NULL, 0));
#if 0
                Assert (S_FALSE != hr);
                if (hr)
                    goto Cleanup;
#else
                if (FAILED(hr))
                    goto Cleanup;
#endif

                hr = THR(CoCreateInstance(
                    classpec.tagged_union.clsid,
                    NULL,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                    IID_IElementBehaviorFactory,
                    (void **)&pPeerFactory));
                if (hr)
                    goto Cleanup;

                Assert (pPeerFactory);
            }
            else
            {
                //
                // if this is a usual URL, expand it and return it
                //

                hr = THR(CMarkup::ExpandUrl(PrimaryMarkup(), achUrl, cchUrlDownload, pchUrlDownload, NULL));
                goto Cleanup; // done
            }
        }
    }

    //
    // set up CPeerFactoryDefault
    //

    pPeerFactoryDefault = new CPeerFactoryDefault(this);
    if (!pPeerFactoryDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pPeerFactory)
    {
        pPeerFactoryDefault->_pPeerFactory = pPeerFactory;
        pPeerFactoryDefault->_pPeerFactory->AddRef();
    }

    hr = THR(pPeerFactoryDefault->QueryInterface(IID_IElementBehaviorFactory, (void**) ppFactory));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pPeerFactoryDefault)
        pPeerFactoryDefault->Release();

    ReleaseInterface (pPeerFactory);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsureIepeersFactory
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsureIepeersFactory()
{
    static const CLSID CLSID_DEFAULTPEERFACTORY = {0x3050f4cf, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};

    HRESULT hr = S_OK;

    if (!_fIepeersFactoryEnsured)
    {
        _fIepeersFactoryEnsured = TRUE;

        hr = THR(CoCreateInstance(
            CLSID_DEFAULTPEERFACTORY,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehaviorFactory,
            (void **)&_pIepeersFactory));
        if (hr)
            _pIepeersFactory = NULL;
    }

    if (!_pIepeersFactory)
        hr = E_FAIL;

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::SetCssPeersPossible
//
//--------------------------------------------------------------------

void
CDoc::SetCssPeersPossible()
{
    if (_fCssPeersPossible)
        return;

    if (_dwLoadf & DLCTL_NO_BEHAVIORS)
        return;

    _fCssPeersPossible = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::StopPeerFactoriesDownloads
//
//--------------------------------------------------------------------

void
CMarkup::StopPeerFactoriesDownloads()
{
    CPeerFactoryUrlMap * pPeerFactoryUrlMap = GetPeerFactoryUrlMap();
    
    if (pPeerFactoryUrlMap)
    {
        IGNORE_HR(pPeerFactoryUrlMap->StopDownloads());
    }
}

//+-------------------------------------------------------------------
//
//  Helper:     ReportAccessDeniedError
//
//--------------------------------------------------------------------

HRESULT
ReportAccessDeniedError(CElement * pElement, CMarkup * pMarkup, LPTSTR pchUrlBehavior)
{
    HRESULT             hr = S_OK;
    CDoc *              pDoc;
    TCHAR               achMessage[pdlUrlLen + 32];
    CPendingScriptErr * pErrRec;
    COmWindowProxy *    pWindowProxy;
    CMarkup *           pWMC;

    Assert (pElement || pMarkup);

    pDoc = pElement ? pElement->Doc() : pMarkup->Doc();

    Assert (pDoc->_dwTID == GetCurrentThreadId());

    Format(0, achMessage, ARRAY_SIZE(achMessage), _T("Access is denied to: <0s>"), pchUrlBehavior);

    if (!pMarkup)
    {
        Assert (pElement);

        pMarkup = pElement->IsInMarkup() ? pElement->GetMarkup() : pDoc->PrimaryMarkup();
    }

    Assert (pMarkup);

    // queue the event firing on the closest window
    pWMC = pMarkup->GetWindowedMarkupContext();
    
    if( pWMC->HasWindow() )
    {
        ErrorRecord errorRecord;
        LPTSTR      pchUrlBehaviorHost = (LPTSTR) CMarkup::GetUrl(pMarkup);

        errorRecord.Init(E_ACCESSDENIED, achMessage, pchUrlBehaviorHost);

        hr = THR(pWMC->ReportScriptError(errorRecord));
    }
    else
    {
        pWindowProxy = pWMC->GetWindowPending();
        if (pWindowProxy)
        {
            pErrRec = pWindowProxy->Window()->_aryPendingScriptErr.Append();

            if (pErrRec)
            {
                pErrRec->_pMarkup = pMarkup; 
                pMarkup->SubAddRef();
                pErrRec->_cstrMessage.Set(achMessage);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     ExpandPeerUrl
//
//--------------------------------------------------------------------

HRESULT
ExpandPeerUrl(LPTSTR * ppchUrl, CElement * pElement, LPTSTR pchUrlBuf, LONG cUrlBuf)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    if (!(*ppchUrl) ||
        _T('#') == (*ppchUrl)[0])
        goto Cleanup; // done

    pMarkup = pElement->GetWindowedMarkupContext();

    hr = THR(CMarkup::ExpandUrl(pMarkup, *ppchUrl, cUrlBuf, pchUrlBuf, pElement));
    if (hr)
        goto Cleanup;

    *ppchUrl = pchUrlBuf;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeersCss
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeersCss(
    CElement *      pElement,
    CAtomTable *    pacstrBehaviorUrls)
{
    HRESULT                 hr = S_OK;

    //
    // control reentrance: if we are in process of attaching peer, do not
    // allow to attach any other peer
    //

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        HRESULT                 hr2;
        int                     i, cUrls;
        CPeerHolder *           pPeerHolder;
        LPTSTR                  pchUrl;
        TCHAR                   achUrl[pdlUrlLen];
        CPeerHolder::CListMgr   ListPrev;
        CPeerHolder::CListMgr   ListNew;

        TraceTag((tagPeerCMarkupAttachPeers,
                  "CMarkup::AttachPeersCss, <%ls id = %ls SN = %ld>, peers to be attached:",
                  pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->SN()));

        cUrls = pacstrBehaviorUrls->TableSize();

        ListPrev.Init (pElement->DelPeerHolder()); // DelPeerHolder will disconnect the old list from element
        ListNew.BuildStart (pElement);

        //
        // move identity peers to the new list (there can only be 1 identity peer for now)
        //

        while (!ListPrev.IsEnd() && ListPrev.Current()->IsIdentityPeer())
        {
            ListPrev.MoveCurrentToHeadOf(&ListNew);
            ListNew.BuildStep();
        }

        //
        // Pass 1: build new list of peer holders:
        //          -   moving existing peers that we don't change into the new list intact, and
        //          -   creating new peers
        //

        for (i = 0; i < cUrls; i++)
        {
            //
            // handle url
            //

            pchUrl = pacstrBehaviorUrls->TableItem(i);
            if (!pchUrl || 0 == pchUrl[0])  // if empty
                continue;

            hr = THR(ExpandPeerUrl(&pchUrl, pElement, achUrl, ARRAY_SIZE(achUrl)));
            if (hr)
                goto Cleanup;

            TraceTag((tagPeerCMarkupAttachPeers, "           '%ls'", pchUrl));

            //
            // attempt to find existing peer holder for the url.
            // if found, move it to the new list; otherwise, create a new empty peer holder
            //

            if (ListPrev.Find(pchUrl))
            {
                ListPrev.MoveCurrentToTailOf(&ListNew);
                ListNew.BuildStep();
            }
            else
            {
                pPeerHolder = new CPeerHolder(pElement);
                if (!pPeerHolder)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                ListNew.AddToTail(pPeerHolder);
                ListNew.BuildStep();

                //
                // AttachPeerUrl
                //

                pPeerHolder->SetFlag(CPeerHolder::CSSPEER);

                hr2 = THR_NOTRACE(AttachPeerUrl(pPeerHolder, pchUrl));

                if (hr2) // if error creating the peer
                {
                    if (E_ACCESSDENIED == hr2)
                    {
                        IGNORE_HR(ReportAccessDeniedError(pElement, /* pMarkup = */ NULL, pchUrl));
                    }

                    {
                        // ( the lock prevents DetachCurrent from passivating pPeerHolder. We want pPeerHolder passivate
                        // after BuildStep so that element does not have pPeerHolder attached when passivation happens )
                        CPeerHolder::CLock lock (pPeerHolder);
                        ListNew.DetachCurrent();
                        ListNew.BuildStep();
                    }
                }
            }
        }

        //
        // Pass 2: release all css created peers left in the old list
        // (and leave host and "attachBehavior" peers intact)
        //

        ListPrev.Reset();
        while (!ListPrev.IsEnd())
        {
            Assert (!ListPrev.Current()->IsIdentityPeer()); // identity peers have been moved already

            if (ListPrev.Current()->IsCssPeer())            // if css peer to save and remove
            {
                ListPrev.DetachCurrent(/*fSave = */TRUE);
            }
            else                                            // behavior added by addBehavior
            {
                ListPrev.MoveCurrentToTailOf(&ListNew);
            }
        }

        //
        // debug stuff
        //

#if DBG == 1
        if (IsTagEnabled(tagPeerCMarkupAttachPeersEmptyPH))
        {
            if (!ListNew.Head() || !ListNew.Head()->IsIdentityPeer())
            {
                ListNew.AddToHead(new CPeerHolder(pElement));
                ListNew.BuildStep();
            }
            ListNew.AddToTail(new CPeerHolder(pElement));
            ListNew.BuildStep();
        }
#endif
        //
        // finalize
        //

        hr = THR(ListNew.BuildDone());
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeer
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeer(
    CElement *              pElement,
    LPTSTR                  pchUrl,
    BOOL                    fIdentity,
    CPeerFactory *          pFactory,
    LONG *                  pCookie)
{
    HRESULT     hr = S_OK;

    if ((!pchUrl || !pchUrl[0]) && !pFactory)  // if empty
        goto Cleanup;

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        CPeerHolder *           pPeerHolder;
        TCHAR                   achUrl[pdlUrlLen];
        CPeerHolder::CListMgr   List;

        List.BuildStart (pElement);

        //
        // expand url and check if the peer already exists
        //

        hr = THR(ExpandPeerUrl(&pchUrl, pElement, achUrl, ARRAY_SIZE(achUrl)));
        if (hr)
            goto Cleanup;

        TraceTag((tagPeerCMarkupAttachPeers,
                  "CMarkup::AttachPeer, <%ls id = %ls SN = %ld>, peer to be attached:",
                  pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->SN()));

        TraceTag((tagPeerCMarkupAttachPeers, "           '%ls'", STRVAL(pchUrl)));

        if (!pchUrl || !List.Find(pchUrl))
        {
            //
            // create peer holder and initiate attaching peer
            //

            pPeerHolder = new CPeerHolder(pElement);
            if (!pPeerHolder)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (fIdentity)
            {
                AssertSz( List.IsEmpty(), "Attempting to attach element behavior with a behavior already attached!" );

                List.AddToHead(pPeerHolder);
                pPeerHolder->SetFlag(CPeerHolder::IDENTITYPEER);
            }
            else
            {
                List.AddToTail(pPeerHolder);
            }

            List.BuildStep ();

            if (!pFactory)
            {
                Assert (pchUrl && pchUrl[0]);

                hr = THR_NOTRACE(AttachPeerUrl(pPeerHolder, pchUrl));
            }
            else
            {
                hr = THR_NOTRACE(pFactory->AttachPeer(pPeerHolder));
            }

            if (S_OK == hr)
            {
                if (pCookie)
                {
                    (*pCookie) = pPeerHolder->CookieID();
                }
            }
            else // if error
            {
                // ( the lock prevents DetachCurrent from passivating pPeerHolder. We want pPeerHolder passivate
                // after BuildStep so that element does not have pPeerHolder attached when passivation happens )
                CPeerHolder::CLock lock (pPeerHolder);

                List.DetachCurrent();
                List.BuildStep ();

                if( fIdentity )
                {
                    CPeerMgr * pPeerMgr;

                    hr = THR( CPeerMgr::EnsurePeerMgr( pElement, &pPeerMgr ) );
                    if( hr )
                        goto Cleanup;

                    pPeerMgr->_fIdentityPeerFailed = TRUE;
                }

                goto Cleanup;
            }
        } // eo if not found

        //
        // finalize
        //

        hr = THR(List.BuildDone());
        if (hr)
            goto Cleanup;

    } // eo if lock

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::RemovePeer
//
//--------------------------------------------------------------------

HRESULT
CDoc::RemovePeer(
    CElement *      pElement,
    LONG            cookie,
    VARIANT_BOOL *  pfResult)
{
    HRESULT     hr = E_UNEXPECTED;

    if (!pfResult)
        RRETURN (E_POINTER);

    *pfResult = VB_FALSE;

    if (!pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER))
    {
        CElement::CLock         lock(pElement, CElement::ELEMENTLOCK_ATTACHPEER);
        CView::CEnsureDisplayTree edt(GetView());

        CPeerHolder::CListMgr   List;

        List.BuildStart (pElement);

        // search for the cookie

        while (!List.IsEnd())
        {
            if (cookie == List.Current()->CookieID())
            {   //..todo lock
                *pfResult = VB_TRUE;
                List.DetachCurrent(/*fSave = */TRUE);
                List.BuildStep();
                break;
            }

            List.Step();
        }

        // finalize

        hr = THR(List.BuildDone());
    }


    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsurePeerFactoryUrl
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsurePeerFactoryUrl(LPTSTR pchUrl, CElement * pElement, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT                 hr = S_OK;
    CMarkup *               pHostMarkup;
    CPeerFactoryUrlMap *    pPeerFactoryUrlMap;

    Assert (pElement || pMarkup);
    Assert (ppFactory);
    Assert (pchUrl && pchUrl[0]);

    *ppFactory = NULL;

    // consider the following interesting cases here:
    // - most typical, both pElement and pMarkup is not NULL
    // - pElement is not NULL, but the element lives in ether (it is not in any markup). Then pMarkup is NULL
    // - pElement is NULL, but we want to ensure PeerFactoryUrl object in a given markup (ETT usage), so pMarkup is not NULL

    if (pElement)
    {
        pHostMarkup = pElement->GetFrameOrPrimaryMarkup();
    }
    else
    {
        pHostMarkup = pMarkup->GetFrameOrPrimaryMarkup();
    }

    Assert (pHostMarkup && pHostMarkup->GetProgSink());

    //
    // First check to see if we already have a factory
    // If we do, we can skip an expensive security check.
    pPeerFactoryUrlMap = pHostMarkup->GetPeerFactoryUrlMap();

    if (pPeerFactoryUrlMap)
    {
        if (pPeerFactoryUrlMap->HasPeerFactoryUrl(pchUrl, ppFactory))
            goto Cleanup;
    }

    //
    // security check
    //

    if (_T('#') != pchUrl[0] && !_tcsnipre(_T("cdl:"), 4, pchUrl, -1))
    {
        // TODO (alexz) (1) test coverage for this; (2) security review
        if (!pHostMarkup->AccessAllowed(pchUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    //
    // ensure PeerFactoryUrlMap in the correct markup and PeerFactoryUrl in the map
    //

    hr = THR(pHostMarkup->EnsurePeerFactoryUrlMap(&pPeerFactoryUrlMap));
    if (hr)
        goto Cleanup;

    hr = THR(pPeerFactoryUrlMap->EnsurePeerFactoryUrl(pchUrl, pMarkup, ppFactory));

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::AttachPeerUrl
//
//--------------------------------------------------------------------

HRESULT
CDoc::AttachPeerUrl(CPeerHolder * pPeerHolder, LPTSTR pchUrl)
{
    HRESULT             hr;
    CPeerFactoryUrl *   pFactory = NULL;

    TraceTag((tagPeerCMarkupAttachPeerUrl,
              "CMarkup::AttachPeerUrl, attaching peer to <%ls id = %ls SN = %ld>, url: '%ls'",
              pPeerHolder->_pElement->TagName(),
              STRVAL(pPeerHolder->_pElement->GetAAid()),
              pPeerHolder->_pElement->SN(),
              pchUrl));

    hr = THR(EnsurePeerFactoryUrl(pchUrl, pPeerHolder->_pElement, pPeerHolder->_pElement->GetMarkup(), &pFactory));
    if (hr)
        goto Cleanup;

    Assert (pFactory);

    hr = THR_NOTRACE(pFactory->AttachPeer(pPeerHolder, /* fAfterDownload = */FALSE));

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnqueuePeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueuePeerTask(CBase * pTarget, PEERTASK task)
{
    HRESULT             hr = S_OK;
    CPeerQueueItem *    pQueueItem;
    CMarkupPeerTaskContext * pPTC;

    hr = THR( EnsureMarkupPeerTaskContext( &pPTC ) );
    if( hr )
        goto Cleanup;

    //
    // post message to commit, if not posted yet (and not unloading)
    //

    if (0 == pPTC->_aryPeerQueue.Size() && !Doc()->TestLock(FORMLOCK_UNLOADING))
    {
        IProgSink * pProgSink;

        hr = THR(GWPostMethodCall(
            this, ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks),
            0, FALSE, "CMarkup::ProcessPeerTasks"));
        if (hr)
            goto Cleanup;

        pProgSink = GetProgSink();

        Assert (0 == pPTC->_dwPeerQueueProgressCookie);

        if (pProgSink)
        {
            pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &pPTC->_dwPeerQueueProgressCookie);
        }
    }

    //
    // add to the queue
    //

    pQueueItem = pPTC->_aryPeerQueue.Append();
    if (!pQueueItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pQueueItem->Init(pTarget, task);

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ProcessPeerTasks
//
//  NOTE:   it is important that the queue gets processed in the order
//          it was queued - this is how we guarantee that all behaviors are attached
//          to parents before all behaviors are attached to children
//
//--------------------------------------------------------------------

void
CMarkup::ProcessPeerTasks(DWORD_PTR dwFlags)
{
    int                         i;
    ULONG                       cDie;
    CBase *                     pTarget;
    CElement *                  pElement;
    CPeerQueueItem *            pQueueItem;
    CMarkupPeerTaskContext *    pPTC = HasMarkupPeerTaskContext() ? GetMarkupPeerTaskContext() : NULL;

    // We can't process peer tasks until we're switched in.
    if (!pPTC || !pPTC->HasPeerTasks() || (_fWindowPending && dwFlags != PROCESS_PEER_TASK_UNLOAD))
    {
        goto Cleanup;
    }
    else if (_fWindowPending && dwFlags == PROCESS_PEER_TASK_UNLOAD)
    {
        goto DeleteQueue;
    }

    // startup
    //


    TraceTag((tagPeerCMarkupPeerDequeueTasks, "CMarkup::PeerDequeueTasks, queue size: %ld", pPTC->_aryPeerQueue.Size()));

    if (NULL == pPTC->_aryPeerQueue[0]._pTarget)  // if reentered the method
    {
#if DBG == 1
        if (IsTagEnabled(tagPeerCMarkupPeerDequeueTasks))
        {
            TraceTag((tagPeerCMarkupPeerDequeueTasks, "CMarkup::PeerDequeueTasks, REENTRANCE detected, call stack:"));
            TraceCallers(0, 0, 20);
        }
#endif

        goto Cleanup;                                               // bail out
    }

    //
    // go up to interactive state if necessary
    //

    // if need to be inplace active in order execute scripts and we need
    // to have our markup switched in...
    if (!AllowScriptExecution())
    {
        // request in-place activation by going interactive
        RequestReadystateInteractive(TRUE);

        // and wait until activated or switched - the activation codepath will 
        // call PeerDequeueTasks again
        goto Cleanup;
    }

    //
    // dequeue all the elements in queue
    //

    // note that the queue might get blown away while we are in this loop.
    // this can happen in CDoc::UnloadContents, resulted from document.write, executed
    // during creation of a behavior (e.g. in inline script of a scriptlet). We use cDie
    // to be robust for this reentrance.

    cDie = Doc()->_cDie;

    for (i = 0; cDie == Doc()->_cDie && i < pPTC->_aryPeerQueue.Size(); i++)
    {
        pQueueItem = &( pPTC->_aryPeerQueue[i] );

        pTarget = pQueueItem->_pTarget;

        Assert (pTarget); // (we should detect reentrance sitiation in the beginning of this function)
        if (!pTarget)
            goto Cleanup;

        pQueueItem->_pTarget = NULL;

        if (PEERTASK_ELEMENT_FIRST <= pQueueItem->_task && pQueueItem->_task <= PEERTASK_ELEMENT_LAST)
        {
            pElement = DYNCAST(CElement, pTarget);

            TraceTag((tagPeerCMarkupPeerDequeueTasks, "                [%lx] <%ls id = %ls SN = %ld>", pElement, STRVAL(pElement->TagName()), STRVAL(pElement->GetAAid()), pElement->SN()));

            IGNORE_HR(pElement->ProcessPeerTask(pQueueItem->_task));
        }
        else
        {
            Assert (PEERTASK_MARKUP_FIRST <= pQueueItem->_task && pQueueItem->_task <= PEERTASK_MARKUP_LAST);

            TraceTag((tagPeerCMarkupPeerDequeueTasks, "                [%lx] <<MARKUP>>", pTarget));

            IGNORE_HR(DYNCAST(CMarkup, pTarget)->ProcessPeerTask(pQueueItem->_task));
        }
    }

DeleteQueue:
    pPTC->_aryPeerQueue.DeleteAll();

    //
    // remove progress
    //

    if (0 != pPTC->_dwPeerQueueProgressCookie)
    {
        IProgSink * pProgSink = GetProgSink();

        //
        // progsink must have been available in order to AddProgress return _dwPeerQueueProgressCookie.
        // Now it can be released only when the doc is unloading (progsink living on tree is destroyed
        // before we dequeue the queue)
        //
        TraceTag((tagPeerCMarkupProcessPeerTasks,
                  "CMarkup::ProcessPeerTasks pProgSink = %x, Doc()->TestLock(FORMLOCK_UNLOADING) = %ld", 
                        pProgSink, 
                        Doc()->TestLock(FORMLOCK_UNLOADING)));

        if (pProgSink)
        {
            pProgSink->DelProgress (pPTC->_dwPeerQueueProgressCookie);
        }

        pPTC->_dwPeerQueueProgressCookie = 0;
    }

Cleanup:
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnqueueIdentityPeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueueIdentityPeerTask(CElement * pElement)
{
    HRESULT hr = S_OK;
    CMarkupPeerTaskContext * pPTC;

    Assert (!HasMarkupPeerTaskContext() || !GetMarkupPeerTaskContext()->_pElementIdentityPeerTask);
    Assert (pElement->NeedsIdentityPeer(NULL));

    hr = THR( EnsureMarkupPeerTaskContext( &pPTC ) );
    if( hr )
        goto Cleanup;

    pElement->PrivateAddRef();

    pPTC->_pElementIdentityPeerTask = pElement;

#if DBG == 1
    TraceProcessPeerTask (pPTC->_pElementIdentityPeerTask, TRUE, NULL, _T("ENQUEUE"));
#endif

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::ProcessIdentityPeerTask
//
//--------------------------------------------------------------------

HRESULT
CMarkup::ProcessIdentityPeerTask()
{
    HRESULT         hr = S_OK;
    CElement *      pElement = NULL;
    CMarkup *       pMarkup = NULL;
    CPeerHolder *   pPeerHolder;
    CPeerMgr *      pPeerMgr;
    CMarkupPeerTaskContext * pPTC;

    Assert( HasMarkupPeerTaskContext() );
    pPTC = GetMarkupPeerTaskContext();
    pElement = pPTC->_pElementIdentityPeerTask;
    pMarkup = pElement->GetMarkupPtr();

    Assert (pPTC->_pElementIdentityPeerTask);
    Assert (pElement->NeedsIdentityPeer(NULL));

#if DBG == 1
    TraceProcessPeerTask (pPTC->_pElementIdentityPeerTask, TRUE, NULL, _T("DEQUEUE"));
#endif

    pPTC->_pElementIdentityPeerTask = NULL;

    if (!Doc()->TestLock(FORMLOCK_UNLOADING))
    {
        Assert(!_fWindowPending);

        pElement->EnsureIdentityPeer();

        pPeerHolder = pElement->GetIdentityPeerHolder();

        if (pPeerHolder &&
            pPeerHolder->TestFlag(CPeerHolder::BLOCKPARSERWHILEINCOMPLETE))
        {
            READYSTATE  readyState = pPeerHolder->GetReadyState();

            if (READYSTATE_UNINITIALIZED < readyState && readyState < READYSTATE_COMPLETE)
            {
                // suspend download in the current markup if the identity peer requests it
                // it will get resumed when the identity peer reports readyState 'complete'

                hr = THR(CPeerMgr::EnsurePeerMgr(pElement, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SuspendDownload();
            }
        }
    }

Cleanup:
    pElement->PrivateRelease();

    RRETURN (hr);
}

HRESULT
CMarkup::RequestDocEndParse( CElement * pElement )
{
    HRESULT hr = S_OK;
    CMarkupBehaviorContext * pBC;

    // We may already have passed Quickdone.
    if( LoadStatus() >= LOADSTATUS_QUICK_DONE )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( EnsureBehaviorContext( &pBC ) );
    if( hr )
        goto Cleanup;

    // We'll filter out dupes when we send the notification.
    hr = THR( pBC->_aryPeerElems.Append( pElement ) );
    if( hr )
        goto Cleanup;

    // Subref for the array - we don't want to keep behaviors attached
    pElement->SubAddRef();

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CMarkup::SendDocEndParse()
{
    HRESULT                     hr  = S_OK;
    CAryPeerElems               aryPeerElems;
    CMarkupBehaviorContext  *   pBC;
    long                        c;
    CElement                **  ppElem;

    // No context, no notifications
    if( !HasBehaviorContext() )
        goto Cleanup;

    pBC = BehaviorContext();

    for( c = pBC->_aryPeerElems.Size(), ppElem = pBC->_aryPeerElems; c > 0; c--, ppElem++ )
    {
        // Make sure the element is still in this markup
        if( (*ppElem)->GetMarkup() == this )
        {
            // Can't be passivated and in the markup
            Assert( !(*ppElem)->IsPassivated() );

            hr = THR( aryPeerElems.Append( *ppElem ) );
            if( hr )
                goto Cleanup;

            // Convert our sub ref into a full ref while we notify
            (*ppElem)->AddRef();
        }
        (*ppElem)->SubRelease();
    }

    pBC->_aryPeerElems.DeleteAll();

    for( c = aryPeerElems.Size(), ppElem = aryPeerElems; c > 0; c--, ppElem++ )
    {
        CNotification nf;

        nf.DocEndParse(*ppElem);
        (*ppElem)->Notify(&nf);
        (*ppElem)->Release();
    }

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::get_namespaces
//              CDoc::get_namespaces
//
//--------------------------------------------------------------------

HRESULT
CDocument::get_namespaces(IDispatch ** ppdispNamespaces)
{
    HRESULT     hr;

    hr = THR(CHTMLNamespaceCollection::Create(Markup(), ppdispNamespaces));

    RRETURN (SetErrorInfo(hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnsureExtendedTagTableHost
//
//--------------------------------------------------------------------

HRESULT
CDoc::EnsureExtendedTagTableHost()
{
    HRESULT     hr = S_OK;

    if (!_pExtendedTagTableHost)
    {
        _pExtendedTagTableHost = new CExtendedTagTable(this, /* pMarkup = NULL */ NULL, /* fShareBooster = */FALSE);
        if (!_pExtendedTagTableHost)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::RequestElementChangeVisibility
//
//  Synopsis:   The filter behavior needs to override an element's visibility
//              while playing a transition from visible to invisible or
//              vice-versa.  We need to handle these changes asynchronously
//              to avoid firing events while rendering.  We keep a list of
//              elements whose visibility is changing, and post ourselves
//              a message to react to the changes.
//
//--------------------------------------------------------------------

HRESULT
CDoc::RequestElementChangeVisibility(CElement *pElement)
{
    HRESULT             hr = S_OK;

    //
    // post message to commit, if not posted yet (and not unloading)
    //

    if (0 == _aryElementChangeVisibility.Size() && !TestLock(FORMLOCK_UNLOADING))
    {
        hr = THR(GWPostMethodCall(
            this, ONCALL_METHOD(CDoc, ProcessElementChangeVisibility, processelementchangevisibility),
            0, FALSE, "CDoc::ProcessElementChangeVisibility"));
        if (hr)
            goto Cleanup;
    }

    //
    // add to the queue (with a weak reference)
    //

    hr = _aryElementChangeVisibility.Append(pElement);
    if (!hr)
    {
        pElement->SubAddRef();
    }

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ProcessElementChangeVisibility
//
//--------------------------------------------------------------------

void
CDoc::ProcessElementChangeVisibility(DWORD_PTR)
{
    int i;
    int cEntries = _aryElementChangeVisibility.Size();

    // process only the entries that are present when we start.  (More
    // could be added as we do this.)
    for (i = 0;  i < cEntries;  ++i)
    {
        // In the call to OnPropertyChange, we do not use the propdesc, bcoz, DISPID_A_VISIBILITY is not
        // actually supported by Element, and so, if we provide a propdesc, the call to Findpropdescfromdispid
        // which should actually fail is avoided, and events get fired wrongly
        _aryElementChangeVisibility[i]->OnPropertyChange(DISPID_A_VISIBILITY, ELEMCHNG_CLEARCACHES | ELEMCHNG_INLINESTYLE_PROPERTY);
    }

    // we release in a separate pass - the release code is also called
    // at shutdown
    ReleaseElementChangeVisibility(0, cEntries);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseElementChangeVisibility
//
//--------------------------------------------------------------------

void
CDoc::ReleaseElementChangeVisibility(int iStart, int iFinish)
{
    Assert(0<=iStart && iStart<=iFinish && iFinish<=_aryElementChangeVisibility.Size());
    int i;

    for (i = iStart;  i < iFinish;  ++i)
    {
        _aryElementChangeVisibility[i]->SubRelease();
    }

    if (iFinish > iStart)
    {
        _aryElementChangeVisibility.DeleteMultiple(iStart, iFinish-1);
    }

    // if there are still unprocessed requests (and we're not shutting down),
    // post another message to get them processed.
    if (_aryElementChangeVisibility.Size() > 0 && !TestLock(FORMLOCK_UNLOADING))
    {
        GWPostMethodCall(
            this, ONCALL_METHOD(CDoc, ProcessElementChangeVisibility, processelementchangevisibility),
            0, FALSE, "CDoc::ProcessElementChangeVisibility");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\optnobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       optnobj.cxx
//
//  Contents:   Contains the implementation of the User Option settings for
//              CDoc, including OM access.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_FONTLINK_HXX_
#define X_FONTLINK_HXX_
#include "fontlink.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifdef WIN16
#define MIN_JAVA_MEMORY 8192L+1L        // must be over 8Meg to run Java
extern DWORD WINAPI DetectPhysicalMem();

#ifndef X_INETREG_H_
#define X_INETREG_H_
#include <inetreg.h>
#endif

#endif

#ifdef UNIX
// Unix uses this global variable to memorize users selected Font size View->Font
// and passes this to each new CDoc, if it's been changed.
int g_SelectedFontSize = -1;
#endif

MtDefine(CodePageSettings, CDoc, "CDoc::_pCodePageSettings")
MtDefine(CDocReadContextMenuExtFromRegistry_pCME, Locals, "CDoc::ReadContextMenuExtFromRegistry pCME")

BOOL IsInIEBrowser(CDoc * pDoc);

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::Init, public
//
//  Synopsis:   Initializes data that should only be initialized once.
//
//  Arguments:  [psz] -- String to initialize achKeyPath to. Cannot be NULL.
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::Init(
    TCHAR *psz,
    BOOL fUseCodePageBasedFontLinkingArg )
{
    _tcscpy(achKeyPath, psz);
    fSettingsRead = FALSE;
    fUseCodePageBasedFontLinking = !!fUseCodePageBasedFontLinkingArg;
    sBaselineFontDefault = BASELINEFONTDEFAULT;

    InvalidateScriptBasedFontInfo();
}

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::InvalidateScriptBasedFontInfo, public
//
//  Synopsis:   Invalidates script based font info.
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::InvalidateScriptBasedFontInfo()
{
    memset(alatmProporitionalFonts,   -1, sizeof(alatmProporitionalFonts));
    memset(alatmFixedPitchFonts,      -1, sizeof(alatmFixedPitchFonts));
    memset(alatmProporitionalAtFonts, -1, sizeof(alatmProporitionalAtFonts));
    memset(alatmFixedPitchAtFonts,    -1, sizeof(alatmFixedPitchAtFonts));
}

//+---------------------------------------------------------------------------
//
//  Member:     CODEPAGESETTINGS::SetDefaults, public
//
//  Synopsis:   Sets the default values for the CODEPAGESETTINGS struct.
//
//----------------------------------------------------------------------------

void
CODEPAGESETTINGS::SetDefaults(
    UINT  uiFamilyCodePageDefault,
    SHORT sOptionSettingsBaselineFontDefault)
{
    fSettingsRead = FALSE;
    bCharSet = DEFAULT_CHARSET;
    sBaselineFontDefault = sOptionSettingsBaselineFontDefault;
    uiFamilyCodePage = uiFamilyCodePageDefault;
    latmFixedFontFace = -1;
    latmPropFontFace  = -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::SetDefaults, public
//
//  Synopsis:   Sets the default values of the struct
//
//----------------------------------------------------------------------------

void
OPTIONSETTINGS::SetDefaults( )
{
    colorBack            = OLECOLOR_FROM_SYSCOLOR(COLOR_WINDOW);
    colorText            = OLECOLOR_FROM_SYSCOLOR(COLOR_WINDOWTEXT);
    colorAnchor          = RGB(0, 0, 0xFF);
    colorAnchorVisited   = RGB(0x80, 0, 0x80);
    colorAnchorHovered   = RGB(0, 0, 0x80);

    fPageTransitions     = TRUE;
    fUseDlgColors        = TRUE;
    fExpandAltText       = FALSE;
    fShowImages          = TRUE;
#ifndef NO_AVI
    fShowVideos          = TRUE;
#endif // ndef NO_AVI
    fPlaySounds          = TRUE;
    fPlayAnimations      = TRUE;
    fPrintBackground     = FALSE;
    fUseStylesheets      = TRUE;
    fSmoothScrolling     = TRUE;
    fShowImagePlaceholder = FALSE;
    fShowFriendlyUrl     = FALSE;
    fSmartDithering      = TRUE;
    fAlwaysUseMyColors   = FALSE;
    fAlwaysUseMyFontSize = FALSE;
    fAlwaysUseMyFontFace = FALSE;
    fUseMyStylesheet     = FALSE;
    fUseHoverColor       = FALSE;
    fDisableScriptDebugger = TRUE;
    fMoveSystemCaret     = FALSE;
    fHaveAcceptLanguage  = FALSE;
    fCpAutoDetect        = FALSE;
    fAllowCutCopyPaste   = FALSE;
    fDisableCachingOfSSLPages  = FALSE;
    fHKSCSSupport        = FALSE;
    fForceOffscreen      = FALSE;
    fEnableImageResize   = TRUE;
    fUsePlugin           = FALSE;
    fUseThemes           = TRUE;
    fUseHiRes            = FALSE;
    fRouteEditorOnce     = FALSE;
    fLocalMachineCheck   = TRUE;
    fCleanupHTCs         = FALSE;

    nAnchorUnderline     = ANCHORUNDERLINE_YES;

    nStrictCSSInterpretation = STRICT_CSS_DOCTYPE;

    // HACKHACK (johnv) For japanese, default to Autodetect.  This hack
    // can be removed once setup does its job properly.
    codepageDefault      = (g_cpDefault == 932) ? CP_AUTO_JP : g_cpDefault;

    dwMaxStatements      = CWindow::RUNAWAY_SCRIPT_STATEMENTCOUNT;

    dwRtfConverterf      = RTFCONVF_ENABLED;    // enabled, but not for dbcs

    dwMiscFlags          = 0;

    dwNoChangingWallpaper = 0;

    // Free the context menu extension array
    {
        CONTEXTMENUEXT **   ppCME;
        int                 n;

        for (ppCME = aryContextMenuExts,
             n = aryContextMenuExts.Size();
             n;
             n--, ppCME++)
        {
            delete *ppCME;
        }

        aryContextMenuExts.DeleteAll();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureOptionSettings, public
//
//  Synopsis:   Ensures that this CDoc is pointing to a valid OPTIONSETTINGS
//              object. Should only be called by ReadOptionSettingsFromRegistry.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureOptionSettings()
{
    HRESULT             hr = S_OK;
    int                 c;
    OPTIONSETTINGS   *  pOS;
    OPTIONSETTINGS   ** ppOS;
    TCHAR             * pstr=NULL;
    BOOL                fUseCodePageBasedFontLinking;

    static TCHAR pszDefaultKey[] = _T("Software\\Microsoft\\Internet Explorer");
    static TCHAR pszOE4Key[] = _T("Software\\Microsoft\\Outlook Express\\Trident");

    if (_pOptionSettings)
        return S_OK;

    if (_pHostUIHandler)
    {
        _pHostUIHandler->GetOptionKeyPath(&pstr, 0);
    }

    if (!pstr)
    {
        pstr = pszDefaultKey;
    }

    _fOE4 = (0 == StrCmpC(pstr, pszOE4Key));

#ifndef UNIX
    // On Unix, we create new option setting for each new CDoc, because all IEwindows
    // run on the same thread.

    for (c = TLS(optionSettingsInfo.pcache).Size(),
         ppOS = TLS(optionSettingsInfo.pcache);
         c > 0;
         c--, ppOS++)
    {
        if (!StrCmpC((*ppOS)->achKeyPath, pstr))
        {
            _pOptionSettings = *ppOS;
            goto Cleanup;
        }
    }
#endif
    // We only make it here if we didn't find an existing entry.

    // OPTIONSETTINGS has one character already in it, which accounts for a
    // NULL terminator.

    pOS = new ( _tcslen(pstr) * sizeof(TCHAR) ) OPTIONSETTINGS;
    if (!pOS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // New clients, such as OE5, will set the UIHost flag.  For compatibility with OE4, however,
    // we need to employ some trickery to get the old font regkey values.

    fUseCodePageBasedFontLinking = 0 != (_dwFlagsHostInfo & DOCHOSTUIFLAG_CODEPAGELINKEDFONTS);
    if (!fUseCodePageBasedFontLinking)
    {
        fUseCodePageBasedFontLinking = _fOE4;
    }

    MemSetName((pOS, "OPTIONSETTINGS object, index %d",
                    TLS(optionSettingsInfo.pcache).Size()));

    pOS->Init(pstr, fUseCodePageBasedFontLinking);
    pOS->SetDefaults( );

    hr = TLS(optionSettingsInfo.pcache).Append(pOS);
    if (hr)
        goto Cleanup;

    _pOptionSettings = pOS;

    PrimaryMarkup()->ClearDefaultCharFormat();

Cleanup:
    if (pstr != pszDefaultKey)
        CoTaskMemFree(pstr);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureCodepageSettings, public
//
//  Synopsis:   Ensures that this CDoc is pointing to a valid CODEPAGESETTINGS
//              object. Should only be called by ReadCodepageSettingsFromRegistry.
//
//  Arguments:  uiFamilyCodePage - the family to check for
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureCodepageSettings(UINT uiFamilyCodePage)
{
    HRESULT            hr = S_OK;
    int                n;
    CODEPAGESETTINGS** ppCS, *pCS;
    OPTIONSETTINGS *   pOptionSettings = Doc()->_pOptionSettings;

    // Make sure we have a valid pOptionSettings object
    Assert(pOptionSettings);

    // The first step is to look up the entry in the codepage cache

    for (n = pOptionSettings->aryCodepageSettingsCache.Size(),
                ppCS = pOptionSettings->aryCodepageSettingsCache;
                n > 0;
                n--, ppCS++)
    {
        if ( (*ppCS)->uiFamilyCodePage == uiFamilyCodePage )
        {
            hr = SetCodepageSettings(*ppCS);
            goto Cleanup;
        }
    }

    // We're out of luck, need to read in the codepage setting from the registry

    pCS = (CODEPAGESETTINGS *) MemAlloc(Mt(CodePageSettings), sizeof(CODEPAGESETTINGS) );
    if (!pCS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    MemSetName((pCS, "CODEPAGESETTINGS"));

    pCS->Init( );
    pCS->SetDefaults( uiFamilyCodePage, pOptionSettings->sBaselineFontDefault );

    hr = pOptionSettings->aryCodepageSettingsCache.Append(pCS);
    if (hr)
        goto Cleanup;

    hr = SetCodepageSettings(pCS);
    if (hr)
        goto Cleanup;

    ClearDefaultCharFormat();

Cleanup:
    RRETURN(hr);
}

#ifndef NO_RTF
//+-------------------------------------------------------------------------
//
//  Method:     CDoc::RtfConverterEnabled
//
//  Synopsis:   TRUE if this rtf conversions are enabled, FALSE otherwise.
//
//--------------------------------------------------------------------------

BOOL
CDoc::RtfConverterEnabled()
{
    DWORD  dwConvf = _pOptionSettings->dwRtfConverterf; // for shorthand
    CPINFO cpinfo;

    //
    // Rtf conversions can be disabled on an sbcs-dbcs basis, or even
    // completely.  See the RTFCONVF flags in formkrnl.hxx.
    //
    return (dwConvf & RTFCONVF_ENABLED) &&
        ((dwConvf & RTFCONVF_DBCSENABLED) ||
        (GetCPInfo(g_cpDefault, &cpinfo) && cpinfo.MaxCharSize == 1));
}

BOOL
CMarkup::RtfConverterEnabled()
{
    return( Doc()->RtfConverterEnabled() &&
            ( GetAAcodepage() == 1255 || GetAAcodepage() == 1256 ) );
}

#endif // ndef NO_RTF

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateFromRegistry, public
//
//  Synopsis:   Load configuration information from the registry. Needs to be
//              called after we have our client site so we can do a
//              QueryService.
//
//  Arguments:  flags - REGUPDATE_REFRESH - read even if we find a cache entry
//                    - REGUPDATE_KEEPLOCALSTATE - true if we do not want to
//                                                 override local state
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

struct SAVEDSETTINGS
{
    OLE_COLOR colorBack;
    OLE_COLOR colorText;
    OLE_COLOR colorAnchor;
    OLE_COLOR colorAnchorVisited;
    OLE_COLOR colorAnchorHovered;
    LONG      latmFixedFontFace;
    LONG      latmPropFontFace;
    LONG      nAnchorUnderline;
    SHORT     sBaselineFontDefault;
    BYTE      fAlwaysUseMyColors;
    BYTE      fAlwaysUseMyFontSize;
    BYTE      fAlwaysUseMyFontFace;
    BYTE      fUseMyStylesheet;
    BYTE      bCharSet;
};

static void
SaveSettings(OPTIONSETTINGS *pOptionSettings,
             CODEPAGESETTINGS *pCodepageSettings,
             SAVEDSETTINGS *pSavedSettings)
{
    memset(pSavedSettings, 0, sizeof(SAVEDSETTINGS));
    pSavedSettings->colorBack             = pOptionSettings->colorBack;
    pSavedSettings->colorText             = pOptionSettings->colorText;
    pSavedSettings->colorAnchor           = pOptionSettings->colorAnchor;
    pSavedSettings->colorAnchorVisited    = pOptionSettings->colorAnchorVisited;
    pSavedSettings->colorAnchorHovered    = pOptionSettings->colorAnchorHovered;
    pSavedSettings->nAnchorUnderline      = pOptionSettings->nAnchorUnderline;
    pSavedSettings->fAlwaysUseMyColors    = pOptionSettings->fAlwaysUseMyColors;
    pSavedSettings->fAlwaysUseMyFontSize  = pOptionSettings->fAlwaysUseMyFontSize;
    pSavedSettings->fAlwaysUseMyFontFace  = pOptionSettings->fAlwaysUseMyFontFace;
    pSavedSettings->fUseMyStylesheet      = pOptionSettings->fUseMyStylesheet;
    pSavedSettings->bCharSet              = pCodepageSettings->bCharSet;
    pSavedSettings->latmFixedFontFace     = pCodepageSettings->latmFixedFontFace;
    pSavedSettings->latmPropFontFace      = pCodepageSettings->latmPropFontFace;
    pSavedSettings->sBaselineFontDefault  = pCodepageSettings->sBaselineFontDefault;
}

HRESULT
CDoc::UpdateFromRegistry(DWORD dwFlags, BOOL *pfNeedLayout)
{
    HRESULT         hr = S_OK;
    CODEPAGE        codepage;
    BOOL            fFirstTime = !_pOptionSettings;
    SAVEDSETTINGS   savedSettings1;
    SAVEDSETTINGS   savedSettings2;
    CODEPAGESETTINGS *pCodepageSettings = _pWindowPrimary ? PrimaryMarkup()->GetCodepageSettings() : NULL;

    // Use the cached values unless we are forced to re-read
    if (!fFirstTime && !(dwFlags & REGUPDATE_REFRESH))
        return hr;

    if (pfNeedLayout)
    {
        if (!_pOptionSettings || !pCodepageSettings)
        {
            // We assume that in this context, the caller is interested
            // only in whether or not we want to relayout, and not to
            // force us to read in registry settings.
            *pfNeedLayout = FALSE;
            return hr;
        }
        SaveSettings(_pOptionSettings, pCodepageSettings, &savedSettings1);
    }

    // First read in the standard option settings
    hr = THR(ReadOptionSettingsFromRegistry(dwFlags));
    if (hr)
        goto Cleanup;

    if (g_fTerminalServer)
        _pOptionSettings->fSmoothScrolling = FALSE;

    // For HTML applications, override registry settings for multimedia components.
    // We don't want (for example) images in an HTA to fail to appear due to
    // custom internet options settings...

    if (IsHostedInHTA())
    {
        _pOptionSettings->fShowImages      = TRUE;
#ifndef NO_AVI
        _pOptionSettings->fShowVideos      = TRUE;
#endif // ndef NO_AVI
        _pOptionSettings->fPlaySounds      = TRUE;
        _pOptionSettings->fPlayAnimations  = TRUE;
        _pOptionSettings->fSmartDithering  = TRUE;
    }

    _dwMiscFlags() = _pOptionSettings->dwMiscFlags;

    SetEditBitsForMarkup( PrimaryMarkup() );
    
    // If we are getting settings for the first time, use the default
    //  codepage.  Otherwise, read based on our current setting.
    codepage = pCodepageSettings ? PrimaryMarkup()->GetCodePage() :
                                    _pOptionSettings->codepageDefault;
    IGNORE_HR( PrimaryMarkup()->ReadCodepageSettingsFromRegistry( codepage, WindowsCodePageFromCodePage( codepage ), dwFlags ) );

    // ReadCodepageSettingsFromRegistry could change _pCodepageSettings and hence we need to
    // reinitialize it.
    pCodepageSettings = _pWindowPrimary ? PrimaryMarkup()->GetCodepageSettings() : NULL;

    if (pCodepageSettings)
    {
        // Set the baseline font only the first time we read from the registry
#ifdef UNIX
        if (g_SelectedFontSize != -1) // Copy the previous selected font size.
            _sBaselineFont = pCodepageSettings->sBaselineFontDefault = g_SelectedFontSize;
    else
#endif
        _sBaselineFont = pCodepageSettings->sBaselineFontDefault;
    }

    // Request the accept language header info from shlwapi.
    {
        TCHAR achLang[256];
        DWORD cchLang = ARRAY_SIZE(achLang);
        _pOptionSettings->fHaveAcceptLanguage = (GetAcceptLanguages(achLang, &cchLang) == S_OK)
                                                && (_pOptionSettings->cstrLang.Set(achLang, cchLang) == S_OK);
    }

    if (pfNeedLayout)
    {
        SaveSettings(_pOptionSettings, pCodepageSettings, &savedSettings2);
        *pfNeedLayout = !!memcmp(&savedSettings1, &savedSettings2, sizeof(SAVEDSETTINGS));
    }

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadSettingsFromRegistry, public
//
//  Synopsis:   A generic function to read from the registry.
//
//  Arguments:  pAryKeys - a pointer to an array of keys
//              iKeyCount - the number of keys in this array
//              pBase - a pointer to which offsets in pAryKeys are relative.
//              dwFlags - see UpdateWithRegistry
//              fSettingsRead - True if the settings were already read
//              pUserData - may hold some user data.  for now if we are looking
//                          for a RPI_CPKEY, this is assumed to point to a codepage enum.
//
//----------------------------------------------------------------------------

#define MAX_REG_VALUE_LENGTH   50

enum RKI_TYPE
{
    RKI_KEY,
    RKI_CPKEY,
    RKI_BOOL,
    RKI_COLOR,
    RKI_FONT,
    RKI_SIZE,
    RKI_CP,
    RKI_BYTEBOOL,
    RKI_STRING,
    RKI_ANCHORUNDERLINE,
    RKI_STRICT_CSS,
    RKI_DWORD,
    RKI_TYPE_Last_Enum
};

struct REGKEYINFORMATION
{
    TCHAR *   pszName;            // Name of the value or key
    BYTE      rkiType;            // Type of entry
    size_t    cbOffset;           // Offset of member to store data in
    size_t    cbOffsetCondition;  // Offset of member that must be false (true only
                                  //  for type RKI_STRING) to use this value. If
                                  //  it's true (false for type RKI_STRING)
                                  //  this value is left as its default value. Assumed
                                  //  to be data that's sizeof(BYTE). If 0 then
                                  //  no condition is used.
    BOOL      fLocalState;        // True if this is local state which may not always get
                                  //  updated when read again from the registry.
};

HRESULT
ReadSettingsFromRegistry(
    TCHAR * pchKeyPath,
    const REGKEYINFORMATION* pAryKeys, int iKeyCount,
    void* pBase, DWORD dwFlags, BOOL fSettingsRead,
    void* pUserData )
{
    LONG                lRet;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeySub  = NULL;
    int                 i;
    DWORD               dwType;
    DWORD               dwSize;

    //
    // IEUNIX
    // Note we access dwDataBuf as a byte array through bDataBuf
    // but DWORD align it by declaring it a DWORD array (dwDataBuf).
    //
    DWORD               dwDataBuf[pdlUrlLen / sizeof(DWORD) +1 ];
    BYTE              * bDataBuf = (BYTE*) dwDataBuf;

    TCHAR               achCustomKey[64], * pch;
    BYTE              * pbData;
    BYTE                bCondition;
    BOOL                fUpdateLocalState;
    const REGKEYINFORMATION * prki;
    LONG              * pl;

    Assert( pBase );

    // Do not re-read unless explictly asked to do so.
    if( fSettingsRead && !(dwFlags & REGUPDATE_REFRESH) )
        return S_OK;

    // Always read local settings at least once
    fUpdateLocalState = !fSettingsRead || (dwFlags & REGUPDATE_OVERWRITELOCALSTATE );

    // Get a registry key handle

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, pchKeyPath, 0, KEY_READ, &hKeyRoot);
    if( lRet != ERROR_SUCCESS )
        return S_FALSE;

    for (i = 0; i < iKeyCount; i++)
    {
        prki = &pAryKeys[i];
        // Do not update local state unless asked to do so.
        if( !fUpdateLocalState && prki->fLocalState )
            continue;
        switch (prki->rkiType)
        {
        case RKI_KEY:
        case RKI_CPKEY:
            if (!prki->pszName)
            {
                hKeySub = hKeyRoot;
            }
            else
            {
                if (hKeySub && (hKeySub != hKeyRoot))
                {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;
                }

                if (prki->rkiType == RKI_CPKEY)
                {
                    // N.B. (johnv) It is assumed here that pUserData points
                    // to a codepage if we are looking for codepage settings.
                    // RKI_CPKEY entries are per family codepage.

                    Assert(pUserData);

                    Format( 0, achCustomKey, ARRAY_SIZE( achCustomKey ),
                            prki->pszName,
                            *(DWORD*)pUserData );

                    pch = achCustomKey;
                }
                else
                {
                    pch = prki->pszName;
                }

                lRet = RegOpenKeyEx(hKeyRoot,
                                    pch,
                                    0,
                                    KEY_READ,
                                    &hKeySub);

                if (lRet != ERROR_SUCCESS)
                {
                    // We couldn't get this key, skip it.
                    i++;
                    while (i < iKeyCount &&
                           pAryKeys[i].rkiType != RKI_KEY &&
                           pAryKeys[i].rkiType != RKI_CPKEY )
                    {
                        i++;
                    }

                    i--; // Account for the fact that continue will increment i again.
                    hKeySub = NULL;
                    continue;
                }
            }
            break;

        case RKI_SIZE:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                short s;

                if (dwType == REG_BINARY)
                {
                    s = (short)*(BYTE *)bDataBuf;
                }
                else if (dwType == REG_DWORD)
                {
                    s = (short)*(DWORD *)bDataBuf;
                }
                else
                {
                    break;
                }

                *(short*)((BYTE *)pBase + prki->cbOffset) =
                    min( short(BASELINEFONTMAX), max( short(BASELINEFONTMIN), s ) );
            }
            break;

        case RKI_BOOL:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;
            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                if (dwType == REG_DWORD)
                {
                    *pbData = (*(DWORD*)bDataBuf != 0);
                }
                else if (dwType == REG_SZ)
                {
                    TCHAR ch = *(TCHAR *)bDataBuf;

                    if (ch == _T('1') ||
                        ch == _T('y') ||
                        ch == _T('Y'))
                    {
                        *pbData = TRUE;
                    }
                    else
                    {
                        *pbData = FALSE;
                    }
                } else if (dwType == REG_BINARY)
                {
                    *pbData = (*(BYTE*)bDataBuf != 0);
                }

                // Can't convert other types. Just leave it the default.
            }
            break;

        case RKI_FONT:
            Assert(hKeySub);
            dwSize = LF_FACESIZE * sizeof(TCHAR);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            pl = (LONG *)((BYTE *)pBase + prki->cbOffset);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                TCHAR * pchFontFace = (TCHAR *)bDataBuf;
                if (*pchFontFace)
                {
                    // Make sure we don't overflow static buffer
                    AssertSz(_tcsclen(pchFontFace) < LF_FACESIZE, "String length > LF_FACESIZE");
                    pchFontFace[LF_FACESIZE - 1] = 0;

                    *pl = fc().GetAtomFromFaceName(pchFontFace);
                }
            }
            break;

        case RKI_COLOR:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            bCondition = *(BYTE*)((BYTE *)pBase + prki->cbOffsetCondition);
            if (prki->cbOffsetCondition && bCondition)
            {
                //
                // The appropriate flag is set that says we should not pay
                // attention to this value, so just skip it and keep the
                // default.
                //
                break;
            }

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS)
            {
                if (dwType == REG_SZ)
                {
                    //
                    // Crack the registry format for colors which is a string
                    // of the form "R,G,B" where R, G, and B are decimal
                    // values for Red, Green, and Blue, respectively.
                    //

                    DWORD   colors[3];
                    TCHAR * pchStart  = (TCHAR*)bDataBuf;
                    TCHAR * pchEnd;
                    int     i;

                    pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                    for (i = 0; i < 3; i++)
                    {
                        colors[i] = wcstol(pchStart, &pchEnd, 10);

                        if (*pchEnd == _T('\0') && i != 2)
                            break;

                        pchStart  = pchEnd + 1;
                    }

                    if (i != 3) // We didn't get all the colors. Abort.
                        break;

                    *(COLORREF*)pbData = RGB(colors[0], colors[1], colors[2]);
                }
                // Can't convert other types. Just leave it the default.
            }
            break;

        case RKI_CP:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                *(CODEPAGE*)((BYTE *)pBase + prki->cbOffset) = *(CODEPAGE *)bDataBuf;
            }
            break;

        case RKI_BYTEBOOL:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_BINARY)
            {
                *(BYTE*)((BYTE *)pBase + prki->cbOffset) = (BYTE) !! (*((DWORD*)bDataBuf));
            }
            break;

        case RKI_DWORD:
            Assert(hKeySub);

            dwSize = sizeof(DWORD);

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
            {
                *(DWORD*)((BYTE *)pBase + prki->cbOffset) = *(DWORD*)bDataBuf;
            }
            break;

        case RKI_ANCHORUNDERLINE:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                int nAnchorunderline = ANCHORUNDERLINE_YES;

                LPTSTR pchBuffer = (TCHAR *)bDataBuf;
                Assert (pchBuffer != NULL);

                if (pchBuffer)
                {
                    if (_tcsicmp(pchBuffer, _T("yes")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_YES;
                    else if (_tcsicmp(pchBuffer, _T("no")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_NO;
                    else if (_tcsicmp(pchBuffer, _T("hover")) == 0)
                        nAnchorunderline = ANCHORUNDERLINE_HOVER;
                }

                *(int*)((BYTE *)pBase + prki->cbOffset) = nAnchorunderline;

            }
            break;

        case RKI_STRICT_CSS:
            Assert(hKeySub);

            dwSize = MAX_REG_VALUE_LENGTH;

            lRet = RegQueryValueEx(hKeySub,
                                   prki->pszName,
                                   0,
                                   &dwType,
                                   bDataBuf,
                                   &dwSize);

            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                int nStrictCSS = STRICT_CSS_DOCTYPE;

                LPTSTR pchBuffer = (TCHAR *)bDataBuf;
                Assert (pchBuffer != NULL);

                if (pchBuffer)
                {
                    if (_tcsicmp(pchBuffer, _T("never")) == 0)
                        nStrictCSS = STRICT_CSS_NEVER;
                    else if (_tcsicmp(pchBuffer, _T("always")) == 0)
                        nStrictCSS = STRICT_CSS_ALWAYS;
                }

                *(int*)((BYTE *)pBase + prki->cbOffset) = nStrictCSS;

            }
            break;

        case RKI_STRING:
            Assert(hKeySub);

            dwSize = 0;
            bCondition = *(BYTE*)((BYTE *)pBase + prki->cbOffsetCondition);

            if ((prki->cbOffsetCondition && bCondition) || !prki->cbOffsetCondition)
            {
                //
                // The appropriate flag is set that says we should pay
                // attention to this value or the flag is 0, then do it
                // else skip and keep the default.
                //

                // get the size of string
                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       NULL,
                                       &dwSize);

                if (   lRet == ERROR_SUCCESS 
                    && (dwSize <= pdlUrlLen)) // to prevent buffer overrun
                {
                    lRet = RegQueryValueEx(hKeySub,
                                           prki->pszName,
                                           0,
                                           &dwType,
                                           bDataBuf,
                                           &dwSize);

                    if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
                    {
                        ((CStr *)((BYTE *)pBase + prki->cbOffset))->Set((LPCTSTR)bDataBuf);
                    }
                }
            }

            break;

        default:
            AssertSz(FALSE, "Unrecognized RKI Type");
            break;
        }
    }

    if (hKeySub && (hKeySub != hKeyRoot))
        RegCloseKey(hKeySub);

    RegCloseKey( hKeyRoot );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadCodepageSettingsFromRegistry, public
//
//  Synopsis:   Read settings for a particular codepage from the registry.
//
//  Arguments:  cp - the codepage to read
//              dwFlags - See UpdateFromRegistry
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ReadCodepageSettingsFromRegistry(
    CODEPAGE cp,
    UINT uiFamilyCodePage,
    DWORD dwFlags )
{
    HRESULT    hr = S_OK;
    SCRIPT_ID  sid = RegistryAppropriateSidFromSid(DefaultSidForCodePage(uiFamilyCodePage));

    Assert(uiFamilyCodePage != CP_UNDEFINED && uiFamilyCodePage != CP_ACP);

    hr = THR(EnsureCodepageSettings(uiFamilyCodePage));
    if( hr )
        goto Cleanup;

    Doc()->_pOptionSettings->ReadCodepageSettingsFromRegistry(GetCodepageSettings(), dwFlags, sid);

    // Remember if we were autodetected
    _fCodePageWasAutoDetect = GetCodePage() == CP_AUTO_JP;

    // Set the codepage on the doc to the actual codepage requested
    hr = SetCodePage(cp);
    if (hr)
        goto Cleanup;
    hr = SetFamilyCodePage(uiFamilyCodePage);

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     OPTIONSETTINGS::ReadCodePageSettingsFromRegistry
//
//  Synopsis:   Read the fixed and proportional
//  
//----------------------------------------------------------------------------

void
   OPTIONSETTINGS::ReadCodepageSettingsFromRegistry(
    CODEPAGESETTINGS * pCS,
    DWORD dwFlags,
    SCRIPT_ID sid )
{
    static const REGKEYINFORMATION aScriptBasedFontKeys[] =
    {
        { _T("International\\Scripts\\<0d>"),      RKI_CPKEY, (long)0 },
        { _T("IEFontSize"),                        RKI_SIZE, offsetof(CODEPAGESETTINGS, sBaselineFontDefault),    0, FALSE },
        { _T("IEPropFontName"),                    RKI_FONT, offsetof(CODEPAGESETTINGS, latmPropFontFace),  1, FALSE },
        { _T("IEFixedFontName"),                   RKI_FONT, offsetof(CODEPAGESETTINGS, latmFixedFontFace), 0, FALSE },
    };

    static const REGKEYINFORMATION aCodePageBasedFontKeys[] =
    {
        { _T("International\\<0d>"),               RKI_CPKEY, (long)0 },
        { _T("IEFontSize"),                        RKI_SIZE, offsetof(CODEPAGESETTINGS, sBaselineFontDefault),    0, FALSE },
        { _T("IEPropFontName"),                    RKI_FONT, offsetof(CODEPAGESETTINGS, latmPropFontFace),  1, FALSE },
        { _T("IEFixedFontName"),                   RKI_FONT, offsetof(CODEPAGESETTINGS, latmFixedFontFace), 0, FALSE },
    };

    // NB (cthrash) (CP_UCS_2,sidLatin) is for Unicode documents.  So for OE, pick the Unicode font.
    // (CP_UCS_2,!sidAsciiLatin), on the other hand, is for codepageless fontlinking.  In OE, we obviously
    // can't use codepage-based fontlinking; use instead IE5 fontlinking.
    
    fUseCodePageBasedFontLinking &=    sid == sidAsciiLatin
                                    || sid == sidLatin
                                    || DefaultCharSetFromScriptAndCharset(sid, DEFAULT_CHARSET) != DEFAULT_CHARSET;
    
    DWORD dwArg = fUseCodePageBasedFontLinking ? DWORD(pCS->uiFamilyCodePage) : DWORD(sid);

    IGNORE_HR( ReadSettingsFromRegistry( achKeyPath,
                                         fUseCodePageBasedFontLinking ? aCodePageBasedFontKeys : aScriptBasedFontKeys,
                                         ARRAY_SIZE(aCodePageBasedFontKeys),
                                         pCS,
                                         dwFlags,
                                         pCS->fSettingsRead,
                                         (void *)&dwArg ) );

    // Determine the appropriate GDI charset

    pCS->bCharSet = DefaultCharSetFromScriptAndCodePage( sid, pCS->uiFamilyCodePage );

    // Do a little fixup on the fonts if not present.  Note that we avoid
    // doing this in CODEPAGESETTINGS::SetDefault as this could be expensive
    // and often unnecessary.
    if (    pCS->latmPropFontFace  == -1 
        ||  pCS->latmFixedFontFace == -1)
    {
        fl().ScriptAppropriateFaceNameAtom(sid, pCS->latmPropFontFace, pCS->latmFixedFontFace);
    }

    pCS->fSettingsRead = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadContextMenuExtFromRegistry, public
//
//  Synopsis:   Load information about context menu extensions
//              from the registry
//
//  Arguments:  dwFlags - See UpdateFromRegistry.
//
//  Returns:    HRESULT, S_FALSE says nothing was there to read
//
//----------------------------------------------------------------------------
HRESULT
CDoc::ReadContextMenuExtFromRegistry( DWORD dwFlags /* = 0 */)
{
    HRESULT             hr = S_OK;
    CONTEXTMENUEXT *    pCME = NULL;
    int                 nExtMax, nExtCur;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeyMenuExt = NULL;
    HKEY                hKeySub = NULL;
    TCHAR               achSubName[MAX_PATH + 1];
    long                lRegRet;
    DWORD               dwType;
    DWORD               dwSize;
    BYTE                bDataBuf[pdlUrlLen];

    // Do not re-read unless explictly asked to do so.
    if( _pOptionSettings->fSettingsRead && !(dwFlags & REGUPDATE_REFRESH) )
        return S_OK;

    //
    //  Open up our root key
    //
    lRegRet = RegOpenKeyEx(HKEY_CURRENT_USER, _pOptionSettings->achKeyPath,
                        0, KEY_READ, &hKeyRoot);
    if( lRegRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Get the menu extensions sub key
    //
    lRegRet = RegOpenKeyEx(hKeyRoot, _T("MenuExt"),
                           0, KEY_READ, &hKeyMenuExt);
    if( lRegRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Make sure our array is big enough
    //
    nExtMax = IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__;
    hr = _pOptionSettings->aryContextMenuExts.EnsureSize(nExtMax);
    if(hr)
        goto Cleanup;

    //
    // add an entry for each sub key
    //

    for(nExtCur = 0; nExtCur < nExtMax; nExtCur++)
    {
        lRegRet = RegEnumKey(hKeyMenuExt, nExtCur, achSubName, MAX_PATH+1);
        if(lRegRet != ERROR_SUCCESS)
        {
            break;
        }

        // Open the sub key
        lRegRet = RegOpenKeyEx(hKeyMenuExt, achSubName, 0, KEY_READ, &hKeySub);
        if(lRegRet != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // we have a key so create an extension object
        pCME = new(Mt(CDocReadContextMenuExtFromRegistry_pCME)) CONTEXTMENUEXT;
        if(!pCME)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // set the menu name
        pCME->cstrMenuValue.Set(achSubName);

        // read the default value
        dwSize = pdlUrlLen;
        bDataBuf[0] = 0;
        lRegRet = RegQueryValueEx(hKeySub, NULL,
                                  0, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS && dwType == REG_SZ)
        {
            pCME->cstrActionUrl.Set((LPCTSTR)bDataBuf);
        }

        // look for flags
        dwSize = sizeof(DWORD);
        lRegRet = RegQueryValueEx(hKeySub, _T("Flags"),
                                  0, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS &&
           (dwType == REG_DWORD || dwType == REG_BINARY) )
        {
            pCME->dwFlags = *((DWORD*)bDataBuf);
        }

        // look for contexts
        dwSize = sizeof(DWORD);
        lRegRet = RegQueryValueEx(hKeySub, _T("Contexts"),
                                  NULL, &dwType, bDataBuf, &dwSize);
        if(lRegRet == ERROR_SUCCESS &&
           (dwType == REG_DWORD || dwType == REG_BINARY) )
        {
            pCME->dwContexts = *((DWORD*)bDataBuf);
        }

        // check to make sure we have a good extension
        if(pCME->cstrMenuValue.Length() != 0 &&
           pCME->cstrActionUrl.Length() != 0)
        {
            _pOptionSettings->aryContextMenuExts.Append(pCME);
        }
        else
        {
            delete pCME;
        }

        pCME = NULL;
        RegCloseKey(hKeySub);
        hKeySub = NULL;
    }

Cleanup:
    delete pCME;

    if(hKeySub)
        RegCloseKey(hKeySub);

    if(hKeyMenuExt)
        RegCloseKey(hKeyMenuExt);

    if(hKeyRoot)
        RegCloseKey(hKeyRoot);

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReadOptionSettingsFromRegistry, public
//
//  Synopsis:   Read the general option settings from the registry.
//
//  Arguments:  dwFlags - See UpdateFromRegistry.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

BOOL g_fUseHR = FALSE;

HRESULT
CDoc::ReadOptionSettingsFromRegistry( DWORD dwFlags )
{
    HRESULT hr = S_OK;

    //
    // keys in main registry location
    //

    static const REGKEYINFORMATION aOptionKeys[] =
    {
        { NULL,                         RKI_KEY, 0 },
        { _T("Show_FullURL"),           RKI_BOOL,  offsetof(OPTIONSETTINGS, fShowFriendlyUrl), 0, FALSE },
        { _T("SmartDithering"),         RKI_BOOL,  offsetof(OPTIONSETTINGS, fSmartDithering),  0, FALSE },
        { _T("RtfConverterFlags"),      RKI_DWORD, offsetof(OPTIONSETTINGS, dwRtfConverterf),  0, FALSE },

        { _T("Main"),                   RKI_KEY, 0 },
        { _T("Page_Transitions"),       RKI_BOOL, offsetof(OPTIONSETTINGS, fPageTransitions), 0, FALSE },
        { _T("Use_DlgBox_Colors"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fUseDlgColors),    0, FALSE },
        { _T("Anchor Underline"),       RKI_ANCHORUNDERLINE, offsetof(OPTIONSETTINGS, nAnchorUnderline), 0, FALSE },
        { _T("CSS_Compat"),             RKI_STRICT_CSS, offsetof(OPTIONSETTINGS, nStrictCSSInterpretation), 0, FALSE },
        { _T("Expand Alt Text"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fExpandAltText),   0, FALSE },
        { _T("Display Inline Images"),  RKI_BOOL, offsetof(OPTIONSETTINGS, fShowImages),      0, FALSE },
#ifndef NO_AVI
        { _T("Display Inline Videos"),  RKI_BOOL, offsetof(OPTIONSETTINGS, fShowVideos),      0, FALSE },
#endif // ndef NO_AVI
        { _T("Play_Background_Sounds"), RKI_BOOL, offsetof(OPTIONSETTINGS, fPlaySounds),      0, FALSE },
        { _T("Play_Animations"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fPlayAnimations),  0, FALSE },
        { _T("Print_Background"),       RKI_BOOL, offsetof(OPTIONSETTINGS, fPrintBackground),   0, FALSE },
        { _T("Use Stylesheets"),        RKI_BOOL, offsetof(OPTIONSETTINGS, fUseStylesheets),  0, FALSE },
        { _T("SmoothScroll"),           RKI_BOOL, offsetof(OPTIONSETTINGS, fSmoothScrolling), 0, FALSE },
        { _T("Show image placeholders"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fShowImagePlaceholder), 0, FALSE },
        { _T("Disable Script Debugger"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fDisableScriptDebugger), 0, TRUE },
        { _T("Move System Caret"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fMoveSystemCaret), 0, FALSE },
        { _T("Force Offscreen Composition"), RKI_BOOL, offsetof(OPTIONSETTINGS, fForceOffscreen), 0, FALSE },
        { _T("Enable AutoImageResize"), RKI_BOOL, offsetof(OPTIONSETTINGS, fEnableImageResize), 0, FALSE },
        { _T("Q051873"),                RKI_BOOL,   offsetof(OPTIONSETTINGS, fUsePlugin),   0, FALSE },
        { _T("UseThemes"),              RKI_BOOL,   offsetof(OPTIONSETTINGS, fUseThemes),   0, FALSE },
        { _T("UseHR"),                  RKI_BOOL,   offsetof(OPTIONSETTINGS, fUseHiRes),   0, FALSE },
        { _T("Q300829"),                RKI_BOOL,   offsetof(OPTIONSETTINGS, fRouteEditorOnce), 0, FALSE },
        { _T("Disable_Local_Machine_Navigate"), RKI_BOOL,   offsetof(OPTIONSETTINGS, fLocalMachineCheck),   0, FALSE },
        { _T("Cleanup HTCs"),           RKI_BOOL,   offsetof(OPTIONSETTINGS, fCleanupHTCs), 0, FALSE },

        { _T("International"),          RKI_KEY,   0 },
        { _T("Default_CodePage"),       RKI_CP,   offsetof(OPTIONSETTINGS, codepageDefault),  0, TRUE },
#ifndef UNIX // Unix doesn't support AutoDetect
        { _T("AutoDetect"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fCpAutoDetect),    0, FALSE },
#endif

        { _T("International\\Scripts"), RKI_KEY,   0 },
        { _T("Default_IEFontSize"),     RKI_SIZE,   offsetof(OPTIONSETTINGS, sBaselineFontDefault),  0, FALSE },

        { _T("Settings"),               RKI_KEY, 0 },
        { _T("Background Color"),       RKI_COLOR, offsetof(OPTIONSETTINGS, colorBack),          offsetof(OPTIONSETTINGS, fUseDlgColors), FALSE },
        { _T("Text Color"),             RKI_COLOR, offsetof(OPTIONSETTINGS, colorText),          offsetof(OPTIONSETTINGS, fUseDlgColors), FALSE },
        { _T("Anchor Color"),           RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchor),        0, FALSE },
        { _T("Anchor Color Visited"),   RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchorVisited), 0, FALSE },
        { _T("Anchor Color Hover"),     RKI_COLOR, offsetof(OPTIONSETTINGS, colorAnchorHovered), 0, FALSE },
        { _T("Always Use My Colors"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyColors),  0, FALSE },
        { _T("Always Use My Font Size"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyFontSize),  0, FALSE },
        { _T("Always Use My Font Face"),   RKI_BOOL, offsetof(OPTIONSETTINGS, fAlwaysUseMyFontFace),  0, FALSE },
        { _T("Use Anchor Hover Color"),    RKI_BOOL, offsetof(OPTIONSETTINGS, fUseHoverColor),        0, FALSE },
        { _T("MiscFlags"),              RKI_DWORD,   offsetof(OPTIONSETTINGS, dwMiscFlags),   0, TRUE },

        { _T("Styles"),                 RKI_KEY, 0 },
        { _T("Use My Stylesheet"),      RKI_BOOL, offsetof(OPTIONSETTINGS, fUseMyStylesheet),  0, FALSE },
        { _T("User Stylesheet"),        RKI_STRING, offsetof(OPTIONSETTINGS, cstrUserStylesheet),  offsetof(OPTIONSETTINGS, fUseMyStylesheet), FALSE },
        { _T("MaxScriptStatements"),    RKI_DWORD,   offsetof(OPTIONSETTINGS, dwMaxStatements),   0, FALSE },
    };

    //
    // keys in windows location
    //

    static TCHAR achWindowsSettingsPath [] = _T("Software\\Microsoft\\Windows\\CurrentVersion");

    static const REGKEYINFORMATION aOptionKeys2[] =
    {
        { _T("Policies\\ActiveDesktop"),RKI_KEY, 0 },
        { _T("NoChangingWallpaper"),    RKI_DWORD,  offsetof(OPTIONSETTINGS, dwNoChangingWallpaper), 0, FALSE },
        { _T("Policies"), RKI_KEY, 0 },
        { _T("Allow Programmatic Cut_Copy_Paste"), RKI_BOOL, offsetof(OPTIONSETTINGS, fAllowCutCopyPaste), 0, FALSE },
        { _T("Internet Settings"), RKI_KEY, 0 },
        { _T("DisableCachingOfSSLPages"),    RKI_BOOL,   offsetof(OPTIONSETTINGS, fDisableCachingOfSSLPages),   0, FALSE },
    };

    hr = THR(EnsureOptionSettings());
    if (hr)
        goto Cleanup;

    // Make sure we get back the default windows colors, etc.
    if(dwFlags & REGUPDATE_REFRESH)
        _pOptionSettings->SetDefaults();
    IGNORE_HR( ReadSettingsFromRegistry(
        _pOptionSettings->achKeyPath,
        aOptionKeys,
        ARRAY_SIZE(aOptionKeys),
        _pOptionSettings,
        dwFlags,
        _pOptionSettings->fSettingsRead,
        (void *)&_pOptionSettings->codepageDefault ) );

    IGNORE_HR( ReadSettingsFromRegistry(
        achWindowsSettingsPath,
        aOptionKeys2,
        ARRAY_SIZE(aOptionKeys2),
        _pOptionSettings, dwFlags,
        _pOptionSettings->fSettingsRead, NULL ) );

    // fUseThemes should be read from InetCpl settings only if we are hosted inside IE or Explorer

    if ( !(GetModuleHandle(TEXT("EXPLORER.EXE")) || GetModuleHandle(TEXT("IEXPLORE.EXE"))) )
    {
        _pOptionSettings->fUseThemes = FALSE;
    }

    // check if there is an overriding set of properties over the defaults provided
    if (_pHostUIHandler)
    {
        IDocHostUIHandler2 * pDHUIHandler2 = NULL;

        if (SUCCEEDED(_pHostUIHandler->QueryInterface(IID_IDocHostUIHandler2, 
                                                        (void **)&pDHUIHandler2)))
        {
            TCHAR   * pstr = NULL;

            Assert(pDHUIHandler2);

            if (SUCCEEDED(pDHUIHandler2->GetOverrideKeyPath(&pstr, 0)) && pstr)
            {
                IGNORE_HR( ReadSettingsFromRegistry(
                    pstr,
                    aOptionKeys,
                    ARRAY_SIZE(aOptionKeys),
                    _pOptionSettings,
                    dwFlags,
                    _pOptionSettings->fSettingsRead,
                    (void *)&_pOptionSettings->codepageDefault ) );

                // clear the buffer.
                CoTaskMemFree(pstr);
            }

            // release the interface pointer
            ReleaseInterface(pDHUIHandler2);
        }
    }

    // Look at the registry for context menu extensions
    IGNORE_HR( ReadContextMenuExtFromRegistry( dwFlags ) );

    // Look at the registry for HKSCS Support
    // If HKSCS support is enabled, need to perform special fontlinking
    {
        static TCHAR pszNlsCodePageKey[] = _T("System\\CurrentControlSet\\Control\\Nls\\CodePage");
        static TCHAR pszNlsCP950[] = _T("950");
        static TCHAR pszNlsCP950HK[] = _T("c_951.nls");
        static TCHAR pszNlsCP950HK_ForWin9x_Ugh[] = _T("cp_951.nls");

        HKEY hKeyNlsCP;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszNlsCodePageKey, 0, KEY_READ, &hKeyNlsCP);
        if (lRet == ERROR_SUCCESS)
        {
            DWORD dwType;
            TCHAR pszNlsData[16];
            pszNlsData[0] = 0;
            DWORD dwSize = sizeof(pszNlsData);
            lRet = RegQueryValueEx(hKeyNlsCP, pszNlsCP950, 0, &dwType, (BYTE *)pszNlsData, &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                _pOptionSettings->fHKSCSSupport = (0 == _tcsicmp(pszNlsCP950HK, pszNlsData));
                if (!_pOptionSettings->fHKSCSSupport)
                {
                    _pOptionSettings->fHKSCSSupport = (0 == _tcsicmp(pszNlsCP950HK_ForWin9x_Ugh, pszNlsData));
                }
            }

            RegCloseKey(hKeyNlsCP);
        }
    }

    _pOptionSettings->fSettingsRead = TRUE;

#ifdef WIN16_NEVER
    // BUGWIN16: the Flag in OPTIONSETTINGS just went away ??!! in beta2 Trident code !!
    // Make sure that we have enough memory to run Java
    if (_pOptionSettings->fRunJava && (DetectPhysicalMem() < MIN_JAVA_MEMORY))
    {
        _pOptionSettings->fRunJava = FALSE;

        // Update the registry to disable java
        HKEY    hkey;
        DWORD dw;

        if (RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNETSETTINGS,
                0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {
            dw = FALSE;
            RegSetValueEx(hkey, REGSTR_VAL_SECURITYJAVA, 0,
                REGSTR_VAL_SECURITYJAVA_TYPE, (LPBYTE)&dw, sizeof(dw));
        }
    }
#endif

    g_fUseHR = _pOptionSettings->fUseHiRes;

    g_uiDisplay.SetResolution(GetDeviceCaps(GetThreadState()->hdcDesktop, LOGPIXELSX),
                              GetDeviceCaps(GetThreadState()->hdcDesktop, LOGPIXELSY));
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   DeinitOptionSettings
//
//  Synopsis:   Frees up memory stored in the TLS(optionSettingsInfo) struct.
//
//  Notes:      Called by the DllThreadDetach code.
//
//----------------------------------------------------------------------------

void
DeinitOptionSettings( THREADSTATE* pts )
{
    int c, n;
    OPTIONSETTINGS ** ppOS;
    CODEPAGESETTINGS ** ppCS;
    CONTEXTMENUEXT **   ppCME;

    // Free all entries in the options cache
    for (c = pts->optionSettingsInfo.pcache.Size(),
         ppOS = pts->optionSettingsInfo.pcache;
         c;
         c--, ppOS++)
    {
        (*ppOS)->cstrUserStylesheet.Free();

        // Free all entries in the codepage settings cache
        for (ppCS = (*ppOS)->aryCodepageSettingsCache,
            n = (*ppOS)->aryCodepageSettingsCache.Size();
            n;
            n--, ppCS++ )
        {
            MemFree(*ppCS);
        }

        // Free the context menu extension array
        for (ppCME = (*ppOS)->aryContextMenuExts,
             n = (*ppOS)->aryContextMenuExts.Size();
             n;
             n--, ppCME++)
        {
            delete *ppCME;
        }

        delete (*ppOS);
    }

    pts->optionSettingsInfo.pcache.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peerelem.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////////////////////////////

DeclareTag(tagPeerCMarkupProcessPeerTask,      "Peer", "trace CElement::ProcessPeerTask queueing");
DeclareTag(tagPeerIncDecPeerDownloads,      "Peer", "trace CElement::[Inc|Dec]PeerDownloads");

//////////////////////////////////////////////////////////////////////////////
//
// CElement - peer hosting code
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Helper:     TraceProcessPeerTask, DEBUG ONLY helper
//
//----------------------------------------------------------------------------

#if DBG == 1
void
TraceProcessPeerTask(CElement * pElement, BOOL fIdentity, CBehaviorInfo * pCss, LPTSTR pchMsg)
{
    int i, c;

    //if (fIdentity ||
    //    (pCss && pCss->_acstrBehaviorUrls.Size()))
    {
        TraceTag((
            tagPeerCMarkupProcessPeerTask,
            "CElement::ProcessPeerTask, <%ls id = %ls SN = %ld>; %ls:",
            pElement->TagName(), STRVAL(pElement->GetAAid()), pElement->_nSerialNumber, pchMsg));
    }

    if (fIdentity)
        TraceTag((tagPeerCMarkupProcessPeerTask, "         '%ls' identity", STRVAL(pElement->TagName())));

    if (pCss)
    {
        for (i = 0, c = pCss->_acstrBehaviorUrls.TableSize(); i < c; i++)
        {
            TraceTag((tagPeerCMarkupProcessPeerTask, "            '%ls'", STRVAL(pCss->_acstrBehaviorUrls.TableItem(i))));
        }
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Member: CElement::ProcessPeerTask
//
//----------------------------------------------------------------------------

HRESULT
CElement::ProcessPeerTask(PEERTASK task)

{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    CPeerMgr *      pPeerMgr;

    switch (task)
    {

    case PEERTASK_ENTERTREE_UNSTABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_ENTERTREE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            Assert (IsInMarkup());

            //
            // identity peer handling
            //

            if (!HasIdentityPeerHolder() && NeedsIdentityPeer(NULL))
            {
                hr = THR(GetFrameOrPrimaryMarkup()->EnqueueIdentityPeerTask(this));
                if (hr)
                    goto Cleanup;
            }

            // Have our new markup tell us when he's done loading.
            if( HasPeerHolder() )
            {
                IGNORE_HR( GetMarkup()->RequestDocEndParse( this ) );
            }


            //
            // optimizations
            //

            BOOL fNeedStableNotifications = ( HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDDOCUMENTCONTEXTCHANGE) ) ||
                                            ( HasIdentityPeerHolder() && GetPeerHolder()->_fNotifyOnEnterTree );

            if (!pDoc->AreCssPeersPossible() && !fNeedStableNotifications)
                goto Cleanup;   // done: no need to post the task

            if (GetMarkup()->_fMarkupServicesParsing)
                goto Cleanup;   // done: don't post the task when parsing auxilary markup - the element will be 
                                // spliced into target markup later and that is when we post the task
        
            pPeerMgr = GetPeerMgr();

            if (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending())
            {
                goto Cleanup;   // done: the task is already pending
            }

            //
            // post the task
            //

            {
                CBehaviorInfo   info(GetFirstBranch());

                // (note that we compute behavior css here only to figure out if we need to
                // queue up the element. That's why we don't compute it when fNeedsIdentityPeer set:
                // in that case we queue it up anyway.)
                hr = THR(ApplyBehaviorCss(&info));
                if (hr)
                    goto Cleanup;

                // needs to do something at a safe moment of time?
                if (info._acstrBehaviorUrls.TableSize() || fNeedStableNotifications)
                {
                    //
                    // post a task to do that
                    //

                    hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                    if (hr)
                        goto Cleanup;

                    pPeerMgr->SetEnterExitTreeStablePending(TRUE);

                    AddRef();

                    IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_ENTEREXITTREE_STABLE));
#if DBG == 1
                    TraceProcessPeerTask (this, FALSE, &info, _T("ENTERTREE_UNSTABLE"));
#endif
                }

                break;
            }
        }
        break;


    case PEERTASK_EXITTREE_UNSTABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_EXITTREE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            if (HasPeerHolder())
            {
                pPeerMgr = GetPeerMgr();

                if (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending())
                    goto Cleanup; // done

                hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SetEnterExitTreeStablePending(TRUE);

                AddRef();

                IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_ENTEREXITTREE_STABLE));
#if DBG == 1
                TraceProcessPeerTask (this, FALSE, NULL, _T("EXITTREE_UNSTABLE"));
#endif
            }
        }
        break;


    case PEERTASK_ENTEREXITTREE_STABLE:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_ENTEREXITTREE_STABLE
            //
            //----------------------------------------------------------------------------

#if DBG == 1
            TraceProcessPeerTask (this, FALSE, NULL, _T("ENTEREXITTREE_STABLE"));
#endif

            CBehaviorInfo   info(GetFirstBranch());

            // update peer mgr state and ensure identity peer

            pPeerMgr = GetPeerMgr();

            Assert (pPeerMgr && pPeerMgr->IsEnterExitTreeStablePending());

            pPeerMgr->SetEnterExitTreeStablePending(FALSE);
            CPeerMgr::EnsureDeletePeerMgr(this);

            //
            // process css peers
            //

            if (IsInMarkup())
            {
                //
                // in the tree now
                //

                if (!pDoc->IsShut())
                {
                    hr = THR(ApplyBehaviorCss(&info));
                    if (hr)
                        goto Cleanup;

                    IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));

                    if (HasPeerHolder())
                    {
                        GetPeerHolder()->HandleEnterTree();
                    }
                }

                Release(); // NOTE that this element may passivate after this release
            }
            else
            {
                //
                // out of the tree now
                //

                ULONG ulElementRefs;

                Assert (!IsInMarkup());

                if (HasPeerHolder() && !GetPeerHolder()->_fNotifyOnEnterTree)
                {
                    GetPeerHolder()->NotifyMulti(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
                }

                if (!pDoc->IsShut())
                {
                    hr = THR(ApplyBehaviorCss(&info));
                    if (hr)
                        goto Cleanup;

                    // because 0 == info._acstrBehaviorUrls, this will cause all css-attached behaviors to be removed
                    IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));
                }
        
                ulElementRefs = GetObjectRefs() - 1;        // (can't use return value of Release())
                                                            // this should happen after AttachPeersCss
                Release();                                  // NOTE that this element may passivate after this release

                if (ulElementRefs && HasPeerHolder())       // if still has not passivated and has peers
                {                                           // then there is risk of refcount loops
                    CMarkup * oldMarkup = GetWindowedMarkupContext();

                    if (pDoc->IsShut() || oldMarkup->IsPassivated() || oldMarkup->IsPassivating())
                    {
                        DelPeerHolder()->PrivateRelease();  // delete the ptr and release peer holders,
                    }                                       // thus breaking possible loops right here
                    else
                    {
                        oldMarkup->RequestReleaseNotify(this);   // defer breaking refcount loops (until CDoc::UnloadContents)
                    }
                }
            }
        }
        break;


    case PEERTASK_RECOMPUTEBEHAVIORS:
        {
            //+---------------------------------------------------------------------------
            //
            // PEERTASK_RECOMPUTEBEHAVIORS
            //
            //----------------------------------------------------------------------------

            CBehaviorInfo   info(GetFirstBranch());

            hr = THR(ApplyBehaviorCss(&info));
            if (hr)
                goto Cleanup;

            IGNORE_HR(pDoc->AttachPeersCss(this, &info._acstrBehaviorUrls));
        }
        break;

    case PEERTASK_APPLYSTYLE_UNSTABLE:

            //+---------------------------------------------------------------------------
            //
            // PEERTASK_APPLYSTYLE_UNSTABLE
            //
            //----------------------------------------------------------------------------

            if (HasPeerHolder())
            {
                // don't post the task if already did that; update peer mgr state

                pPeerMgr = GetPeerMgr();

                if (pPeerMgr && pPeerMgr->IsApplyStyleStablePending())
                    goto Cleanup; // done

                hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
                if (hr)
                    goto Cleanup;

                pPeerMgr->SetApplyStyleStablePending(TRUE);

                // post the task

                AddRef();

                IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_APPLYSTYLE_STABLE));
            }
            break;

            
    case PEERTASK_APPLYSTYLE_STABLE:

            //+---------------------------------------------------------------------------
            //
            // PEERTASK_APPLYSTYLE_STABLE
            //
            //----------------------------------------------------------------------------

            // update peer mgr state

            pPeerMgr = GetPeerMgr();
            Assert (pPeerMgr && pPeerMgr->IsApplyStyleStablePending());

            pPeerMgr->SetApplyStyleStablePending(FALSE);
            // don't do "CPeerMgr::EnsureDeletePeerMgr(this)" to avoid frequent memallocs

            // do the notification

            if (HasPeerHolder())
            {
                //::StartCAP();
                IGNORE_HR(GetPeerHolder()->ApplyStyleMulti());
                //::StopCAP();
            }

            Release(); // NOTE that this element may passivate after this release

            break;


    } // eo switch (task)

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CElement::ApplyBehaviorCss
//
//--------------------------------------------------------------------

HRESULT
CElement::ApplyBehaviorCss(CBehaviorInfo * pInfo)
{
    HRESULT      hr = S_OK;
    CAttrArray * pInLineStyleAA;
    CMarkup *    pMarkup = GetMarkup();

    // NOTE per rules of css application, inline styles take precedence so they should be applied last

    if (pMarkup)
    {
        if (pMarkup->IsSkeletonMode())
            goto Cleanup;

        // apply user style sheets
        // TODO (alexz): investigate why Apply crashes if the element is in not in any markup
        IGNORE_HR(Doc()->EnsureUserStyleSheets());

        if (TLS(pUserStyleSheets))
        {
            hr = THR(TLS(pUserStyleSheets)->Apply(pInfo, APPLY_Behavior));
            if (hr)
                goto Cleanup;
        }

        // apply markup rules
        hr = THR(pMarkup->ApplyStyleSheets(pInfo, APPLY_Behavior));
        if (hr)
            goto Cleanup;
    }
    
    // apply inline style rules
    pInLineStyleAA = GetInLineStyleAttrArray();
    if (pInLineStyleAA)
    {
        CMarkup * pMC = GetWindowedMarkupContext();

        if (!pMC->IsPassivated() && !pMC->IsPassivating())
        {
            hr = THR(ApplyAttrArrayValues(pInfo, &pInLineStyleAA, NULL, APPLY_Behavior));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CElement::addBehavior
//
//----------------------------------------------------------------------------

HRESULT
CElement::addBehavior(BSTR bstrUrl, VARIANT * pvarFactory, LONG * pCookie)
{
    HRESULT                     hr;
    CPeerFactoryBinaryOnstack   factory;
    CPeerFactory *              pFactory = NULL;
    LONG                        lCookieTemp;

    //
    // startup
    //

    if (!pCookie)
    {
        pCookie = &lCookieTemp;
    }

    *pCookie = 0;

    //
    // extract factory if any
    //

    if (pvarFactory)
    {
        // dereference
        if (V_VT(pvarFactory) & VT_BYREF)
        {
            pvarFactory = (VARIANT*) V_BYREF(pvarFactory);
            if (!pvarFactory)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        switch (V_VT(pvarFactory))
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:

            // behavior factory?
            hr = THR_NOTRACE(V_UNKNOWN(pvarFactory)->QueryInterface(
                IID_IElementBehaviorFactory, (void**)&factory._pFactory));
            if (hr)
            {
                // behavior instance?
                hr = THR_NOTRACE(V_UNKNOWN(pvarFactory)->QueryInterface(
                    IID_IElementBehavior, (void**)&factory._pPeer));
                if (hr)
                    goto Cleanup;
            }

            factory.Init(bstrUrl);

            pFactory = &factory;

            break;

        case VT_NULL:
        case VT_EMPTY:
        case VT_ERROR:
            // just null
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // attach
    //

    hr = THR(Doc()->AttachPeer(this, bstrUrl, /* fIdentity = */ FALSE, pFactory, pCookie));

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member: CElement::removeBehavior
//
//----------------------------------------------------------------------------

HRESULT
CElement::removeBehavior(LONG cookie, VARIANT_BOOL * pfResult)
{
    HRESULT     hr;

    hr = THR(Doc()->RemovePeer(this, cookie, pfResult));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::NeedsIdentityPeer
//
//----------------------------------------------------------------------------

BOOL
CElement::NeedsIdentityPeer(CExtendedTagDesc *  pDesc)
{
    //
    // builtin or literal?
    //

    //
    // TODO (alexz)   currently if the tag is generic literal tag it implies that it has
    //                identity behavior (XML behavior in particular). This will not be true
    //                when we fully support literally parsed sprinkles: there will be literal
    //                tags that do not have identity behaviors.
    //

    Assert( Tag() != ETAG_GENERIC_NESTED_LITERAL );
    switch (Tag())
    {
    case ETAG_GENERIC_BUILTIN:
#ifndef V4FRAMEWORK
    case ETAG_GENERIC_LITERAL:
#endif
        return TRUE;
    }

    //
    // extended tag?
    //

    if (!pDesc)
    {
        pDesc = GetExtendedTagDesc();
    }
    if (    pDesc 
        &&  pDesc->HasIdentityPeerFactory() 
        &&    (    !HasPeerMgr()                            // If at first you don't succeed,
             ||    !GetPeerMgr()->_fIdentityPeerFailed ) )  // Give up.
        return TRUE;

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::EnsureIdentityPeer()
//
//-------------------------------------------------------------------------

HRESULT
CElement::EnsureIdentityPeer()
{
    HRESULT                 hr;
    CExtendedTagDesc *      pDesc;

    if (HasIdentityPeerHolder())
        return S_OK;

    Assert (NeedsIdentityPeer(NULL));

    pDesc = GetExtendedTagDesc();

    Assert (pDesc && pDesc->HasIdentityPeerFactory());

    hr = THR(Doc()->AttachPeer(this, /* pchUrl = */ NULL, /* fIdentity = */ TRUE, pDesc->GetIdentityPeerFactory()));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::HasIdentityPeerHolder
//
//----------------------------------------------------------------------------

BOOL
CElement::HasIdentityPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->HasIdentityPeerHolder() : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetIdentityPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetIdentityPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->GetIdentityPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::HasDefault
//
//----------------------------------------------------------------------------

BOOL
CElement::HasDefaults()
{
    return HasPeerMgr() && GetPeerMgr()->GetDefaults();
}

//+---------------------------------------------------------------------------
//
//  Members:     CElement::GetDefault
//
//----------------------------------------------------------------------------

CDefaults *
CElement::GetDefaults()
{
    return HasPeerMgr() ? GetPeerMgr()->GetDefaults() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetPeerHolderInQI
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetPeerHolderInQI()
{
    return HasPeerHolder() ? GetPeerHolder()->GetPeerHolderInQI() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasRenderPeerHolder
//
//----------------------------------------------------------------------------

BOOL
CElement::HasRenderPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->HasRenderPeerHolder() : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetRenderPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetRenderPeerHolder()
{
    return HasPeerHolder() ? GetPeerHolder()->GetRenderPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFilterPeerHolder
//
//----------------------------------------------------------------------------

CPeerHolder *
CElement::GetFilterPeerHolder(BOOL fCanRedirect/* = TRUE*/, BOOL * pfRedirected /* = NULL */)
{
    // We attach filter for page transitions to the root element and delegate
    // everything to the canvas element (it is not parsed soon enough for our purposes)
    // Here we do the reverse, return the root peerholder when asked for the body or
    // frameset and we are doing a transition
    if(fCanRedirect && (Tag() == ETAG_BODY || Tag() == ETAG_FRAMESET || Tag() == ETAG_HTML))
    {
        CMarkup *pMarkup = GetMarkup();
        if(pMarkup && pMarkup->Root()->HasPeerHolder()
            && Document() && Document()->HasPageTransitions() )
        {
            if(pfRedirected)
                *pfRedirected = TRUE;
            return GetMarkup()->Root()->GetPeerHolder()->GetFilterPeerHolder();
        }
    }
    if(pfRedirected)
        *pfRedirected = FALSE;
    return HasPeerHolder() ? GetPeerHolder()->GetFilterPeerHolder() : NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetLayoutPeerHolder
//
//----------------------------------------------------------------------------
CPeerHolder *   
CElement::GetLayoutPeerHolder()
{   
    return HasPeerHolder() ? GetPeerHolder()->GetLayoutPeerHolder() : NULL; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HasPeerWithUrn
//
//----------------------------------------------------------------------------

BOOL
CElement::HasPeerWithUrn(LPCTSTR Urn)
{
    CPeerHolder::CListMgr   List;

    List.Init(GetPeerHolder());

    return List.HasPeerWithUrn(Urn);
}

//+------------------------------------------------------------------------------
//
//  Member:     get_behaviorUrns
//
//  Synopsis:   returns the urn collection for the behaviors attached to this element
//      
//+------------------------------------------------------------------------------

HRESULT
CElement::get_behaviorUrns(IDispatch ** ppDispUrns)
{
    HRESULT                 hr = S_OK;
    CPeerUrnCollection *    pCollection = NULL;

    if (!ppDispUrns)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pCollection = new CPeerUrnCollection(this);
    if (!pCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pCollection->QueryInterface (IID_IDispatch, (void **) ppDispUrns));
    if ( hr )
        goto Cleanup;

Cleanup:
    if (pCollection)
        pCollection->Release();

    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_behaviorUrns));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::PutUrnAtom, helper
//
//----------------------------------------------------------------------------

HRESULT
CElement::PutUrnAtom (LONG urnAtom)
{
    HRESULT     hr;

    Assert (-1 != urnAtom);

    hr = THR(AddSimple(DISPID_A_URNATOM, urnAtom, CAttrValue::AA_Internal));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetUrnAtom, helper
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetUrnAtom(LONG * pAtom)
{
    HRESULT         hr = S_OK;
    AAINDEX         aaIdx;

    Assert (pAtom);

    aaIdx = FindAAIndex(DISPID_A_URNATOM, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR(GetSimpleAt(aaIdx, (DWORD*)pAtom));
    }
    else
    {
        *pAtom = -1;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetUrn(LPTSTR * ppchUrn)
{
#if 1

    HRESULT             hr = S_OK;
    CExtendedTagDesc *  pDesc;

    pDesc = GetExtendedTagDesc();
    if (pDesc)
    {
        *ppchUrn = pDesc->Urn();
    }
    else
    {
        *ppchUrn = NULL;
    }

    RRETURN (hr);

#else

    HRESULT             hr;
    LONG                urnAtom;

    Assert (ppchUrn);

    hr = THR(GetUrnAtom(&urnAtom));
    if (hr)
        goto Cleanup;

    if (-1 != urnAtom)
    {
        Assert (Doc()->_pXmlUrnAtomTable);      // should have been ensured when we stored urnAtom

        hr = THR(Doc()->_pXmlUrnAtomTable->GetUrn(urnAtom, ppchUrn));
    }
    else
    {
    }

Cleanup:
    RRETURN (hr);

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::put_tagUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::put_tagUrn (BSTR bstrUrn)
{
#if 1
    RRETURN (SetErrorInfo(E_UNEXPECTED));
#else
    HRESULT             hr;
    LPCTSTR             pchNamespace = Namespace();
    CXmlUrnAtomTable *  pUrnAtomTable;
    LONG                urnAtom;

    if (!pchNamespace)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(Doc()->EnsureXmlUrnAtomTable(&pUrnAtomTable));
    if (hr)
        goto Cleanup;

    hr = THR(pUrnAtomTable->EnsureUrnAtom(bstrUrn, &urnAtom));
    if (hr)
        goto Cleanup;

    hr = THR(PutUrnAtom(urnAtom));

Cleanup:
    RRETURN (SetErrorInfo(hr));
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::get_tagUrn, per IHTMLElement2
//
//----------------------------------------------------------------------------

HRESULT
CElement::get_tagUrn(BSTR * pbstrUrn)
{
    HRESULT             hr = S_OK;
    LPCTSTR             pchNamespace = Namespace();
    LPTSTR              pchUrn = NULL;

    if (!pbstrUrn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pchNamespace)
    {
        hr = THR(GetUrn(&pchUrn));
        if (hr)
            goto Cleanup;
    }

    if (pchUrn)
    {
        hr = THR(FormsAllocString(pchUrn, pbstrUrn));
    }
    else
    {
        // CONSIDER: (anandra, alexz) return urn of html
        *pbstrUrn = NULL;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetExtendedTagDesc
//
//----------------------------------------------------------------------------

HRESULT
CElement::SetExtendedTagDesc(CExtendedTagDesc * pDesc)
{
    HRESULT     hr;

    Assert (pDesc && pDesc->IsValid());

    hr = THR(AddUnknownObject(DISPID_A_EXTENDEDTAGDESC, pDesc, CAttrValue::AA_Internal));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CElement::GetExtendedTagDesc()
{
    HRESULT             hr;
    CExtendedTagDesc *  pDesc = NULL;
    AAINDEX             aaIdx;

    aaIdx = FindAAIndex(DISPID_A_EXTENDEDTAGDESC, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR(GetUnknownObjectAt(aaIdx, (IUnknown**)&pDesc));
        if (hr)
            goto Cleanup;

        Assert (pDesc && pDesc->IsValid());

        pDesc->Release(); // users of GetExtendedTagDesc use the pDesc as a weak ref and don't cache it
                          // this release compensates AddRef in GetUnknownObjectAt
    }

Cleanup:
    return pDesc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetReadyState
//
//----------------------------------------------------------------------------

long
CElement::GetReadyState()
{
    return HasPeerMgr() ? GetPeerMgr()->_readyState : READYSTATE_COMPLETE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(GetReadyState(), &V_BSTR(pVarRes)));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement:get_readyStateValue
//
//+------------------------------------------------------------------------------

HRESULT
CElement::get_readyStateValue(long * plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);

    *plRetValue = GetReadyState();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CElement::OnReadyStateChange()
{
    if (ElementDesc()->TestFlag(ELEMENTDESC_OLESITE))
    {
        COleSite::OLESITE_TAG olesiteTag = DYNCAST(COleSite, this)->OlesiteTag();

        if (olesiteTag == COleSite::OSTAG_ACTIVEX || olesiteTag == COleSite::OSTAG_APPLET)
        {
            DYNCAST(CObjectElement, this)->Fire_onreadystatechange();

            return; // done
        }
    }

    Fire_onreadystatechange();
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::IncPeerDownloads
//
//----------------------------------------------------------------------------

void
CElement::IncPeerDownloads()
{
    HRESULT     hr;
    CPeerMgr *  pPeerMgr;

#if DBG==1
    if (IsTagEnabled(tagPeerIncDecPeerDownloads))
    {
        TraceTag((0, "CElement::IncPeerDownloads on <%ls> element (SSN = %ld, %lx)", TagName(), SN(), this));
        TraceCallers(0, 0, 12);
    }
#endif

    hr = THR(CPeerMgr::EnsurePeerMgr(this, &pPeerMgr));
    if (hr)
        goto Cleanup;

    pPeerMgr->IncPeerDownloads();
    pPeerMgr->UpdateReadyState();

Cleanup:
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DecPeerDownloads
//
//----------------------------------------------------------------------------

void
CElement::DecPeerDownloads()
{
    CPeerMgr *  pPeerMgr = GetPeerMgr();

#if DBG==1
    if (IsTagEnabled(tagPeerIncDecPeerDownloads))
    {
        TraceTag((0, "CElement::DecPeerDownloads on <%ls> element (SSN = %ld, %lx)", TagName(), SN(), this));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert (pPeerMgr);
    if (!pPeerMgr)
        return;

    pPeerMgr->DecPeerDownloads();
    pPeerMgr->UpdateReadyState();

    CPeerMgr::EnsureDeletePeerMgr(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::OnPeerListChange
//
//----------------------------------------------------------------------------

HRESULT
CElement::OnPeerListChange()
{
    HRESULT         hr = S_OK;

    CPeerMgr::UpdateReadyState(this, READYSTATE_UNINITIALIZED);

#ifdef PEER_NOTIFICATIONS_AFTER_INIT
    if (HasPeerHolder())
    {
        IGNORE_HR(GetPeerHolder()->EnsureNotificationsSentMulti());
    }
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::InitExtendedTag
//
//  called from Init2
//
//-------------------------------------------------------------------------

HRESULT
CElement::InitExtendedTag(CInit2Context * pContext)
{
    HRESULT             hr = S_OK;
    CExtendedTagDesc *  pDesc = NULL;

    if (pContext &&                 // TODO (alexz) make this an assert? investigate implications of pContext->_pTargetMarkup check
        pContext->_pht &&
        pContext->_pTargetMarkup)
    {
        if (pContext->_pht->IsExtendedTag())
        {
            Assert (pContext->_pht->GetPch());

            CTagNameCracker tagNameCracker(pContext->_pht->GetPch());

            pDesc = pContext->_pTargetMarkup->GetExtendedTagDesc(
                tagNameCracker._pchNamespace, tagNameCracker._pchTagName, /* fEnsure =*/FALSE);

            Assert (pDesc);
        }

        if (pDesc)
        {
            hr = THR(SetExtendedTagDesc(pDesc));
            if (hr)
                goto Cleanup;
        }

        if (pContext->_pht->IsDynamic() && NeedsIdentityPeer(pDesc))
        {
            hr = THR(EnsureIdentityPeer());
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peer.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

extern IDirectDraw * g_pDirectDraw;

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerHolder,                       Elements, "CPeerHolder")
MtDefine(CPeerHolder_CEventsBag,            Elements, "CPeerHolder::CEventsBag")
MtDefine(CPeerHolder_CEventsBag_aryEvents,  Elements, "CPeerHolder::CEventsBag::_aryEvents")
MtDefine(CPeerHolder_CPaintAdapter,         Elements, "CPeerHolder::CPaintAdapter")
MtDefine(CPeerHolder_CRenderBag,            Elements, "CPeerHolder::CRenderBag")
MtDefine(CPeerHolder_CLayoutBag,            Elements, "CPeerHolder::CLayoutBag")
MtDefine(CPeerHolder_CMiscBag,              Elements, "CPeerHolder::CMiscBag")
MtDefine(CPeerHolder_CMiscBag_aryDispidMap, Elements, "CPeerHolder::CMiscBag::aryDispidMap")
MtDefine(CPeerHolder_CPeerHolderIterator_aryPeerHolders, Elements, "CPeerHolder::CPeerHolderIterator::aryPeerHolders")

DeclareTag(tagPeerAttach,       "Peer", "trace CPeerHolder::AttachPeer")
DeclareTag(tagPeerPassivate,    "Peer", "trace CPeerHolder::Passivate")
DeclareTag(tagPeerNoOM,         "Peer", "Don't expose OM of peers (fail CPeerHolder::EnsureDispatch)")
DeclareTag(tagPeerNoRendering,  "Peer", "Don't allow peers to do drawing (disable CPeerHolder::Draw)")
DeclareTag(tagPeerNoHitTesting, "Peer", "Don't allow peers to do hit testing (clear hit testing bit in CPeerHolder::InitRender)")
DeclareTag(tagPeerApplyStyle,   "Peer", "trace CPeerHolder::ApplyStyleMulti")
DeclareTag(tagPeerNotifyMulti,  "Peer", "trace CPeerHolder::NotifyMulti");
DeclareTag(tagPainterDraw,      "Peer", "trace IHTMLPainter::Draw");
DeclareTag(tagPainterHit,       "Peer", "trace IHTMLPainter::HitTest");
DeclareTag(tagVerifyPeerDraw,   "Peer", "verify Draw");
DeclareTag(tagPeerDrawObject,   "Peer", "trace CPeerHolder::_pRenderBag::_fWantsDrawObject")
DeclareTag(tagFilterVisible,    "Filter", "trace filter visibility");
DeclareTag(tagPrintFilterRect,  "Filter", "Paint red rect under filtered element area when printing.")
ExternTag(tagDisableLockAR);

PerfDbgTag(tagPeer, "Peer", "Trace Peer Calls")

// implemented in olesite.cxx
extern HRESULT
InvokeDispatchWithNoThis (
    IDispatch *         pDisp,
    DISPID              dispidMember,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo);

extern const CLSID CLSID_CHtmlComponent;

//+---------------------------------------------------------------------------
//
//  Helper function:    GetNextUniquePeerNumber
//
//----------------------------------------------------------------------------

DWORD
GetNextUniquePeerNumber(CElement * pElement)
{
    HRESULT         hr;
    DWORD           n = 0;
    AAINDEX         aaIdx;

    // get previous number

    //  ( TODO perf(alexz) these 2 searches can actually show up on perf numbers (up to 1%) )

    aaIdx = pElement->FindAAIndex(DISPID_A_UNIQUEPEERNUMBER, CAttrValue::AA_Internal);
    if (AA_IDX_UNKNOWN != aaIdx)
    {
        hr = THR_NOTRACE(pElement->GetSimpleAt(aaIdx, &n));
    }

    // increment it

    n++;
    // (the very first access here will return '1')

    // store it

    IGNORE_HR(pElement->AddSimple(DISPID_A_UNIQUEPEERNUMBER, n, CAttrValue::AA_Internal));

    return n;
}

//////////////////////////////////////////////////////////////////////////////
//
// CPeerHolder::CListMgr methods
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr constructor
//
//----------------------------------------------------------------------------

CPeerHolder::CListMgr::CListMgr()
{
    _pHead     = NULL;
    _pCurrent  = NULL;
    _pPrevious = NULL;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Init
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::Init(CPeerHolder * pPeerHolder)
{
    HRESULT     hr = S_OK;

    _pHead    = pPeerHolder;
    _pCurrent = _pHead;
    Assert (NULL == _pPrevious);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildStart
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildStart(CElement * pElement)
{
    HRESULT     hr;

    _pElement = pElement;

    hr = THR(Init(_pElement->DelPeerHolder()));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildStep
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildStep()
{
    HRESULT     hr = S_OK;

    Assert (_pElement);

    if (!_pElement->HasPeerHolder())
    {
        if (!IsEmpty())
        {
            hr = THR(_pElement->SetPeerHolder(Head()));
        }
    }
    else
    {
        if (IsEmpty())
        {
            _pElement->DelPeerHolder();
        }
        else
        {
            // assert that we are exclusively building peer holder list for the element
            Assert (_pElement->GetPeerHolder() == Head());
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::BuildDone
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CListMgr::BuildDone()
{
    HRESULT     hr;

    Assert (_pElement);

    hr = THR(BuildStep());
    if (hr)
        goto Cleanup;

    hr = THR(_pElement->OnPeerListChange());

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::AddTo
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::AddTo(CPeerHolder * pItem, BOOL fAddToHead)
{
    if (!_pHead)
    {
        _pHead = _pCurrent = pItem;
        Assert (!_pPrevious);
    }
    else
    {
        if (fAddToHead)
        {
            // add to head

            pItem->_pPeerHolderNext = _pHead;

            _pPrevious = NULL;
            _pHead = _pCurrent = pItem;
        }
        else
        {
            // add to tail

            // if not at the end of the list, move there
            if (!_pCurrent || _pCurrent->_pPeerHolderNext)
            {
                Assert(_pHead);

                for (_pCurrent = _pHead;
                     _pCurrent->_pPeerHolderNext;
                     _pCurrent = _pCurrent->_pPeerHolderNext)
                     ;
            }

            // add
            _pPrevious = _pCurrent;
            _pCurrent  = pItem;
            _pPrevious->_pPeerHolderNext = _pCurrent;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Reset
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::Reset()
{
    _pPrevious = NULL;
    _pCurrent = _pHead;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Step
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::Step()
{
    Assert (!IsEnd());

    _pPrevious = _pCurrent;
    _pCurrent = _pCurrent->_pPeerHolderNext;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::Find
//
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CListMgr::Find(LPTSTR pchUrl)
{
    Assert (pchUrl);
    Reset();
    while  (!IsEnd())
    {
        if (_pCurrent->_pPeerFactoryUrl && _pCurrent->_pPeerFactoryUrl->_cstrUrl &&
            0 == StrCmpIC(_pCurrent->_pPeerFactoryUrl->_cstrUrl, pchUrl))
        {
            return TRUE;
        }
        Step();
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::MoveCurrentTo
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::MoveCurrentTo(CListMgr * pTargetList, BOOL fHead, BOOL fSave /* = FALSE */)
{
    CPeerHolder * pNext;

    Assert (!IsEmpty() && !IsEnd());

    pNext = _pCurrent->_pPeerHolderNext;

    _pCurrent->_pPeerHolderNext = NULL;             // disconnect current from this list

    if (pTargetList)
    {
        pTargetList->AddTo(_pCurrent, fHead);       // add current to the new list
    }
    else
    {
        if (fSave)
        {
            _pCurrent->Save();
        }

        _pCurrent->PrivateRelease();                // or release
    }

    if (_pHead == _pCurrent)                        // update _pHead member in this list
    {
        _pHead = pNext;
    }

    _pCurrent = pNext;                              // update _pCurrent

    if (_pPrevious)                                 // update _pPrevious->_pPeerHolderNext
    {
        _pPrevious->_pPeerHolderNext = _pCurrent;
    }
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::InsertInHeadOf
//
//  Note:   ! assumes that the list was iterated to the end before calling here
//
//----------------------------------------------------------------------------

void
CPeerHolder::CListMgr::InsertInHeadOf (CListMgr * pTargetList)
{
    if (IsEmpty())  // if empty
        return;     // nothing to insert

    Assert (IsEnd() && _pPrevious); // assert that we've been iterated to the end

    // connect tail of this list to target list
    _pPrevious->_pPeerHolderNext = pTargetList->_pHead;

    // set target list head to this list
    pTargetList->_pHead = _pHead;
    pTargetList->Reset();
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::GetPeerHolderCount
//
//----------------------------------------------------------------------------

long
CPeerHolder::CListMgr::GetPeerHolderCount(BOOL fNonEmptyOnly)
{
    long        lCount = 0;

    Reset();
    while  (!IsEnd())
    {
        if (Current()->_pPeer || !fNonEmptyOnly)
        {
            lCount++;
        }
        Step();
    }

    return lCount;
}


//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::GetPeerHolderByIndex
//
//----------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::CListMgr::GetPeerHolderByIndex(long lIndex, BOOL fNonEmptyOnly)
{
    long            lCurrent = 0;
    CPeerHolder *   pPeerHolder;

    Reset();
    while  (!IsEnd())
    {
        if (Current()->_pPeer || !fNonEmptyOnly) // if we either have peer, or we were not asked to always have peer
        {
            if (lCurrent == lIndex)
                break;

            lCurrent++;
        }
        Step();
    }

    if (!IsEnd())
    {
        Assert(lCurrent == lIndex && (Current()->_pPeer || !fNonEmptyOnly));
        pPeerHolder = Current();
    }
    else
    {
        pPeerHolder = NULL;
    }

    return pPeerHolder;
}

//+---------------------------------------------------------------------------
//
//  CPeerHolder::CListMgr::HasPeerWithUrn
//
//  Returns TRUE if we find a peer with the given Urn
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CListMgr::HasPeerWithUrn(LPCTSTR Urn)
{
    Reset();
    while  (!IsEnd())
    {
        if (!Current()->_cstrUrn.IsNull() && 0 == StrCmpIC(Current()->_cstrUrn, Urn))
            return TRUE;

        Step();
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////
//
// CPeerHolder methods
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerHolder
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CPeerHolder::CPeerHolder(CElement * pElement)
{
    _pElement = pElement;
    _pElement->SubAddRef();     // lock the element in memory while peer holder exists;
                                // the balancing SubRelease is in CPeerHolder::Passivate

    PrivateAddRef();            // set main refcount to 1. This is balanced in CElement::Passivate or
                                // when the element releases the CPeerHolder.
    SubAddRef();                // set subrefcount to 1
                                // this is balanced in PrivateRelease when refcount drops to 0

    // this should be done as early as possible, so that during creation peer could use the _dispidBase.
    // Another reason to do it here is that it is also used as a unique identier of the peer holder
    // on the element (e.g. in addBehavior)
    _dispidBase = UniquePeerNumberToBaseDispid(GetNextUniquePeerNumber(pElement));

#if DBG == 1
    _PeerSite._pPeerHolderDbg = this;

    // check integrity of notifications enums with flags
    Assert (NEEDCONTENTREADY          == FlagFromNotification(BEHAVIOREVENT_CONTENTREADY         ));
    Assert (NEEDDOCUMENTREADY         == FlagFromNotification(BEHAVIOREVENT_DOCUMENTREADY        ));
    Assert (NEEDAPPLYSTYLE            == FlagFromNotification(BEHAVIOREVENT_APPLYSTYLE           ));
    Assert (NEEDDOCUMENTCONTEXTCHANGE == FlagFromNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE));
    Assert (NEEDCONTENTSAVE           == FlagFromNotification(BEHAVIOREVENT_CONTENTSAVE          ));

    Assert (BEHAVIOREVENT_CONTENTREADY          == NotificationFromFlag(NEEDCONTENTREADY         ));
    Assert (BEHAVIOREVENT_DOCUMENTREADY         == NotificationFromFlag(NEEDDOCUMENTREADY        ));
    Assert (BEHAVIOREVENT_APPLYSTYLE            == NotificationFromFlag(NEEDAPPLYSTYLE           ));
    Assert (BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE == NotificationFromFlag(NEEDDOCUMENTCONTEXTCHANGE));
    Assert (BEHAVIOREVENT_CONTENTSAVE           == NotificationFromFlag(NEEDCONTENTSAVE          ));
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::~CPeerHolder
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CPeerHolder::~CPeerHolder()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Passivate
//
//-------------------------------------------------------------------------

void
CPeerHolder::Passivate()
{
    TraceTag((tagPeerPassivate, "CPeerHolder::Passivate, peer holder: %ld", CookieID()));

    AssertSz( !_fPassivated, "CPeerHolder::Passivate called more than once!" );

    IGNORE_HR(DetachPeer());

    delete _pEventsBag;
    _pEventsBag = NULL;
    delete _pMiscBag;
    _pMiscBag = NULL;

    if (_pPeerHolderNext)
    {
        _pPeerHolderNext->PrivateRelease();
        _pPeerHolderNext = NULL;
    }

    if (_pElement)
    {
#if DBG == 1
        {
            CPeerHolderIterator itr;
            for (itr.Start(_pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                Assert (itr.PH() != this);
            }
        }
#endif

        _pElement->SubRelease();
        _pElement = NULL;
    }

    WHEN_DBG( _fPassivated = TRUE );

    GWKillMethodCall( this, ONCALL_METHOD(CPeerHolder, SendNotificationAsync, sendnotificationasync), 0 );
    GWKillMethodCall( this, ONCALL_METHOD(CPeerHolder, NotifyDisplayTreeAsync, notifydisplaytreeasync), 0 );
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::DetachPeer
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::DetachPeer()
{
    HRESULT     hr = S_OK;

    if (IsRenderPeer())
    {
        NotifyDisplayTree();
    }

    if (_pPeer)
    {

        PerfDbgLog(tagPeer, this, "+CPeerHolder::DetachPeer");
	    _pPeer->Detach();
        PerfDbgLog1(tagPeer, this, "-CPeerHolder::DetachPeer(%S)", (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"");

        ClearInterface (&_pDisp);
        ClearInterface (&_pPeerUI);
        ClearInterface (&_pPeerCmdTarget);

        delete _pRenderBag; // releases _pBehaviorRender
        _pRenderBag = NULL;

        delete _pLayoutBag;
        _pLayoutBag = NULL;

        // final reference on the peer
        ClearInterface (&_pPeer);
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPeerHolder::CLock methods
//
//---------------------------------------------------------------

CPeerHolder::CLock::CLock(CPeerHolder * pPeerHolder, FLAGS enumFlags)
{
    _pPeerHolder = pPeerHolder;

    if (!_pPeerHolder)
        return;

    // assert that only lock flags are passed in here
    Assert (0 == ((WORD)enumFlags & ~LOCKFLAGS));

    _wPrevFlags = _pPeerHolder->_wFlags;
    _pPeerHolder->_wFlags |= (WORD) enumFlags;

    _fNoRefs = pPeerHolder->_ulRefs == 0;

    if( !_fNoRefs
#if DBG==1
       && !IsTagEnabled(tagDisableLockAR)
#endif
      )
    {
       _pPeerHolder->PrivateAddRef();
       if (_pPeerHolder->_pElement)
       {
            // AddRef the element so it does not passivate while are keeping peer and peer holder alive
            _pPeerHolder->_pElement->AddRef();
       }
    }
}


CPeerHolder::CLock::~CLock()
{
    if (!_pPeerHolder)
        return;

    // restore only lock flags; don't touch others
    _pPeerHolder->_wFlags = (_wPrevFlags & LOCKFLAGS) | (_pPeerHolder->_wFlags & ~LOCKFLAGS);

    if( !_fNoRefs
#if DBG==1
       && !IsTagEnabled(tagDisableLockAR)
#endif
      )
    {
        if (_pPeerHolder->_pElement)
        {
            _pPeerHolder->_pElement->Release();
        }
        _pPeerHolder->PrivateRelease();
    }
}

//+---------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryInterface
//
//
//  CPeerHolder objects do not have COM object identity!
//
//  The only reason why QI, AddRef and Release exist on peer holder
//  is to serve as IUnknown part of interface thunks created when
//  peer QI-s element for an interface. CElement, when performing
//  PrivateQueryInterface, always checks if there is a CPeerHolder
//  attached in QueryInterface (indicated by LOCK_INQI)) and then returns
//  thunk with IUnknown part wired to the CPeerHolder. As a result, QI on
//  CElement, if originated from peer, does not increase CElement
//  main refcount (_ulRefs), but affects subrefcount (_ulAllRefs).
//  This logic breaks refcount loops when peer caches element pointer
//  received from IElementBehaviorSite::GetElement - peer has no way
//  to touch main refcount of it's element and therefore delay moment
//  of passivation of the element (with a few exceptions - see below).
//  Because QI of the thunks is also wired to this method, all
//  subsequent QIs on the returned interfaces will also go through
//  this method and the bit LOCK_INQI will be set correctly.
//
//  The only way a peer can touch main refcount of CElement it is attached
//  to is by QI-ing for IUnknown - but we do not wrap that case so to
//  preserve object identity of CElement. However, that case is naturally
//  not dangerous in terms of creating refloops because there is no really
//  reason to cache IUnknown in peer when caching of IHTMLElement is so much
//  more natural (a peer has to have malicious intent to create refcount loop
//  to do it).
//
//  Note that as a result of this logic, no object but tearoff thunks or
//  CPeerSite should be able to get to this method directly. The thunks
//  and peer site use the method only as a helper which sets proper bits
//  and then QIs CElement - they expect interface returned to be identity
//  of CElement this peer is attached to.
//
//---------------------------------------------------------------

HRESULT
CPeerHolder::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    Assert (!TestFlag(LOCKINQI));

    if (!TestFlag(LOCKINQI))
    {
        CLock   lock(this, LOCKINQI);

        hr = THR_NOTRACE(_pElement->PrivateQueryInterface(riid, ppv));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetPeerHolderInQI
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetPeerHolderInQI()
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(LOCKINQI))
            return itr.PH();
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::PrivateAddRef
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::PrivateAddRef()
{
    AssertSz( !_fPassivated, "CPeerHolder::PrivateAddRef called after passivated!" );
    _ulRefs++;
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::PrivateRelease
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::PrivateRelease()
{
    _ulRefs--;
    if (0 == _ulRefs)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        _ulRefs = 0;
        SubRelease();
        return 0;
    }
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SubAddRef
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::SubAddRef()
{
    _ulAllRefs++;
    return _ulAllRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SubRelease
//
//-------------------------------------------------------------------------

ULONG
CPeerHolder::SubRelease()
{
    _ulAllRefs--;
    if (0 == _ulAllRefs)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulRefs;
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryPeerInterface
//
//  Synposis:   for explicit QI's into the peer
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::QueryPeerInterface(REFIID riid, void ** ppv)
{
    RRETURN(_pPeer ? _pPeer->QueryInterface(riid, ppv) : E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::QueryPeerInterfaceMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::QueryPeerInterfaceMulti(REFIID riid, void ** ppv, BOOL fIdentityOnly)
{
    HRESULT             hr2;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (fIdentityOnly && !itr.PH()->IsIdentityPeer())
            continue;

        hr2 = THR_NOTRACE(itr.PH()->QueryPeerInterface(riid, ppv));
        if (S_OK == hr2)
            RRETURN (S_OK);
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Create
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Create(CPeerFactory *  pPeerFactory)
{
    HRESULT                 hr;
    WHEN_DBG(CDoc *                  pDoc = _pElement->Doc();)
    IElementBehavior *      pPeer = NULL;

    Assert (pPeerFactory);

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::Create appears to be called at an unsafe moment of time");

    //
    // setup peer holder
    //

    // _pElement should be set before FindPeer so at the moment of creation
    // the peer has valid site and element available
    Assert (_pElement);

    if( _pElement->IsPassivated() )
    {
        hr = E_ABORT;
        goto Cleanup;
    }
    
    {
        CElement::CLock lock(_pElement);    // if the element is blown away by peer while we create the peer,
                                            // this should keep us from crashing
        //
        // get the peer
        //

        hr = THR_NOTRACE(pPeerFactory->FindBehavior(this, &_PeerSite, &pPeer));
        if (hr)
            goto Cleanup;
    }

    //
    // attach peer to the peer holder and peer holder to the element
    //

    Assert (!_pPeer);

    hr = THR(AttachPeer(pPeer));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    Assert (!IsCssPeer() || pDoc->AreCssPeersPossible());
    if( _pElement->GetMarkup() )
    {
        IGNORE_HR( _pElement->GetMarkup()->RequestDocEndParse( _pElement ) );
    }

Cleanup:

    ReleaseInterface (pPeer);

    Assert (S_OK == hr &&  _pPeer ||
            S_OK != hr && !_pPeer);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::AttachPeer
//
//  Synopsis:   attaches the peer to this peer holder
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::AttachPeer(IElementBehavior * pPeer)
{
    HRESULT     hr = S_OK;
    CHtmlComponent *pComponent = NULL;
    CDoc::CLock lock (_pElement->Doc(), FORMLOCK_FILTER);  // do not want filter tasks to be executed

    if (!pPeer)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert (pPeer);
    _pPeer = pPeer;
    _pPeer->AddRef();

    //
    // initialize and QI
    //

    hr = THR(_pPeer->QueryInterface(CLSID_CHtmlComponent, (void**)&pComponent));
    if (!hr && pComponent)
        _fHtcPeer = TRUE;

    PerfDbgLog(tagPeer, this, "+CPeerHolder::InitPeer");
    hr = THR(_pPeer->Init(&_PeerSite));
    PerfDbgLog1(tagPeer, this, "-CPeerHolder::InitPeer(%S)", (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"");
    if (hr)
        goto Cleanup;

    if (_pPeerFactoryUrl)
    {
        hr = THR(_pPeerFactoryUrl->PersistMonikerLoad(_pPeer, FALSE));
        if (hr)
            goto Cleanup;
    }

    hr = THR(InitAttributes()); // dependencies: this should happen before InitRender, InitUI, or InitCategory
    if (hr)
        goto Cleanup;

    hr = THR(InitReadyState());
    if (hr)
        goto Cleanup;

    hr = THR(InitRender());
    if (hr)
        goto Cleanup;

    hr = THR(InitUI());
    if (hr)
        goto Cleanup;

    hr = THR(InitCategory());
    if (hr)
        goto Cleanup;

    hr = THR(InitCmdTarget());
    if (hr)
        goto Cleanup;

    hr = THR(InitLayout());
    if (hr)
        goto Cleanup;

    SetFlag(NEEDDOCUMENTREADY);
    SetFlag(NEEDCONTENTREADY);
    SetFlag(AFTERINIT);

    //
    // Here's the deal:
    // Since element behaviors get hooked up immediately, it's easy for them to be running in a 
    // state which they're not really going to understand (ie, temporary parsing for innerHTML, etc.)
    // So what we actually do for them is delay sending content/document ready until they actually
    // enter a tree somewhere.  Otherwise, the act of asking for their document will give them one, and
    // it will not be the one they want (ie, someone does createElement and then appendChild).
    // Unfortunately, it's too late to do this for attach behaviors.
    //
    if( IsIdentityPeer() &&
        ( !_pElement->IsInMarkup() ||
          ( _pElement->Doc()->_fInHTMLInjection &&
            _pElement->GetMarkupPtr()->_fMarkupServicesParsing ) ) )
    {
        _fNotifyOnEnterTree = TRUE;
    }
    else
    {
        IGNORE_HR(EnsureNotificationsSent());
    }

    if (IsRenderPeer())
    {
        NotifyDisplayTree();
    }

    //
    // finalize
    //

Cleanup:

    TraceTag((
        tagPeerAttach,
        "CPeerHolder::AttachPeer, peer holder: %ld, tag: %ls, tag id: %ls, SN: %ld, peer: %ls, hr: %x",
        CookieID(),
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN(),
        STRVAL(_pPeerFactoryUrl ? (LPTSTR)_pPeerFactoryUrl->_cstrUrl : NULL),
        hr));

    if (hr)
    {
        // DetachPeer is important to handle Init case gracefully
        IGNORE_HR(DetachPeer());
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitUI
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitUI()
{
    _pPeerUI = NULL;
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitCmdTarget
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitCmdTarget()
{
    HRESULT     hr;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IOleCommandTarget, (void **)&_pPeerCmdTarget));
    if (hr)
    {
        _pPeerCmdTarget = NULL; // don't trust peers to set it to NULL when they fail QI - it could be uninitialized
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitAttributes
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitAttributes()
{
    HRESULT                 hr;
    IPersistPropertyBag2 *  pPersistPropertyBag2 = NULL;
    IPersistPropertyBag *   pPersistPropertyBag = NULL;
    CPropertyBag *          pPropertyBag;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IPersistPropertyBag2, (void **)&pPersistPropertyBag2));
    if (hr || !pPersistPropertyBag2)
    {
        hr = THR_NOTRACE(QueryPeerInterface(IID_IPersistPropertyBag, (void **)&pPersistPropertyBag));
        if (hr || !pPersistPropertyBag)
           return S_OK;
    }

    // ( TODO perf(alexz) the property bag implementation is terribly inefficient. SaveAttributes actually
    // shows up on perf profiles - up to 6%. It should not do explicit copy of attributes, but should
    // rather just link to element )

    pPropertyBag = new CPropertyBag();
    if (!pPropertyBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pPropertyBag->_pElementExpandos = _pElement; // this transitions it to expandos loading mode

    hr = THR(_pElement->SaveAttributes(pPropertyBag));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // ignore hr here so that if it does not implement Load method we still use the behavior
    if (pPersistPropertyBag2)
    {
        IGNORE_HR(pPersistPropertyBag2->Load(pPropertyBag, NULL));
    }
    else
    {
        Assert (pPersistPropertyBag);
        IGNORE_HR(pPersistPropertyBag->Load(pPropertyBag, NULL));
    }

Cleanup:
    ReleaseInterface(pPersistPropertyBag2);
    ReleaseInterface(pPersistPropertyBag);
    if (pPropertyBag)
    {
        pPropertyBag->Release();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitRender
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitRender()
{
    // NOTE: startup should be minimal if rendering interfaces are not supported
    HRESULT                     hr;
    IHTMLPainter *              pPainter;
    IElementBehaviorRender *    pPeerRender;
    BOOL                        fUpdateLayout;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IHTMLPainter, (void**)&pPainter));
    if (hr || !pPainter)
    {
        hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorRender, (void**)&pPeerRender));
        if (hr || !pPeerRender)
            return S_OK;

        pPainter = NULL;
    }
    else
    {
        pPeerRender = NULL;
    }

    _pRenderBag = new CRenderBag();
    if (!_pRenderBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pPainter)
    {
        _pRenderBag->_pPainter = pPainter;
    }
    else
    {
        // for compatability with behaviors that support IEBR, create an adapter
        CPaintAdapter *pAdapter = new CPaintAdapter(this);
        if (!pAdapter)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pRenderBag->_pAdapter = pAdapter;
        _pRenderBag->_pPainter = (IHTMLPainter*)pAdapter;

        Assert(pPeerRender);
        pAdapter->_pPeerRender = pPeerRender;
    }

    // get the painter's info, flags, preferences, etc.
    UpdateRenderBag();

    // by this time, the element's initial visibilty is known
    if (IsFilterPeer())
    {
        SetFilteredElementVisibility(!_pElement->GetFirstBranch()->GetCharFormat()->_fVisibilityHidden);
    }

    fUpdateLayout = (_pRenderBag->_sPainterInfo.lZOrder != HTMLPAINT_ZORDER_NONE);

    // NOTE (KTam): This is wrong -- it needs to be multi-layout aware.  Unfortunately,
    // OnLayoutAvailable() assumes it's only going to get 1 layout and calls GetSize on it
    // (which conceptually doesn't make sense for CLayoutInfo).   Invalidate should probably
    // be moved onto CLayoutInfo.
    if (fUpdateLayout)
    {
        CLayout    * pLayout;
        if(_pElement->HasLayoutAry())
        {
            CLayoutAry * pLayoutAry = _pElement->GetLayoutAry();
            int nLayoutCookie = 0;

            for(;;)
            {
                pLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
                if(nLayoutCookie == -1 || !pLayout)
                    break;

                // we must have missed the moment when layout was created and attached to the element
                // so simulate OnLayoutAvailable now
                IGNORE_HR(OnLayoutAvailable( pLayout ));

                // and invalidate the layout to cause initial redraw
                pLayout->Invalidate();
            }
        }
        else
        {
            // don't call GetUpdatedLayout unless you want the layout to actually be
            // created at this time.
            pLayout = _pElement->GetLayoutPtr();

            if (pLayout)
            {
                // we must have missed the moment when layout was created and attached to the element
                // so simulate OnLayoutAvailable now
                IGNORE_HR(OnLayoutAvailable( pLayout ));

                // and invalidate the layout to cause initial redraw
                pLayout->Invalidate();
            }
        }
    }

Cleanup:
    // do not do ReleaseInterface(pPainter);
    // do not do ReleaseInterface(pPeerRender);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitLayout
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::InitLayout()
{
    HRESULT                  hr;
    IElementBehaviorLayout * pPeerLayout;
    IElementBehaviorLayout2 * pPeerLayout2 = NULL;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorLayout, (void**)&pPeerLayout));
    if (hr || !pPeerLayout)
        return S_OK;

    THR_NOTRACE(pPeerLayout->QueryInterface(IID_IElementBehaviorLayout2, (void**)&pPeerLayout2));
    
    _pLayoutBag = new CLayoutBag();
    if (!_pLayoutBag)
    {
        ReleaseInterface(pPeerLayout);
        ReleaseInterface(pPeerLayout2);
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _pLayoutBag->_pPeerLayout = pPeerLayout;
    _pLayoutBag->_pPeerLayout2 = pPeerLayout2;

    // now get the Layout info
    hr = THR(_pLayoutBag->_pPeerLayout->GetLayoutInfo(&_pLayoutBag->_lLayoutInfo));
    if (hr)
        goto Cleanup;

    //
    // peers that participate in layout need a relayout to happen
    //
    _pElement->ResizeElement(NFLAGS_FORCE);

Cleanup:
    // do not do ReleaseInterface(pPeerLayout);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitReadyState
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitReadyState()
{
    HRESULT                         hr;
    HRESULT                         hr2;
    DWORD                           dwCookie;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IConnectionPointContainer, (void**)&pCPC));
    if (hr || !pCPC)
        return S_OK;

    hr = THR_NOTRACE(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pCP->Advise((IPropertyNotifySink*)&_PeerSite, &dwCookie));
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE(UpdateReadyState());
    if (hr2)
    {
        _readyState = READYSTATE_UNINITIALIZED;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::UpdateReadyState
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::UpdateReadyState()
{
    HRESULT     hr = S_OK;
    CInvoke     invoke;
    CVariant    varReadyState;

    EnsureDispatch();
    if (!_pDisp)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    if (TestFlag(DISPEX))
        hr = THR(invoke.Init((IDispatchEx*)_pDisp));
    else
        hr = THR(invoke.Init(_pDisp));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Invoke(DISPID_READYSTATE, DISPATCH_PROPERTYGET));
    if (hr)
        goto Cleanup;

    hr = THR(VariantChangeType(&varReadyState, invoke.Res(), 0, VT_I4));
    if (hr)
        goto Cleanup;

    _readyState = (READYSTATE) V_I4(&varReadyState);

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetReadyStateMulti
//
//-------------------------------------------------------------------------

READYSTATE
CPeerHolder::GetReadyStateMulti()
{
    READYSTATE          readyState;
    CPeerHolderIterator itr;

    // get min readyState of all peers that support readyState

    readyState = READYSTATE_COMPLETE;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (READYSTATE_UNINITIALIZED == itr.PH()->_readyState)
            continue;

        readyState = min(itr.PH()->GetReadyState(), readyState);
    }

    return readyState;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetIdentityReadyState
//
//-------------------------------------------------------------------------

READYSTATE
CPeerHolder::GetIdentityReadyState()
{
    CPeerHolder * pPeerHolder = GetIdentityPeerHolder();
    READYSTATE    readyState;

    if (pPeerHolder)
    {
        readyState = pPeerHolder->GetReadyState();
        if (READYSTATE_UNINITIALIZED == readyState)
            readyState = READYSTATE_COMPLETE;
    }
    else
        readyState = READYSTATE_COMPLETE;

    return readyState;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ContentSavePass, static helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ContentSavePass(CTreeSaver * pTreeSaver, BOOL fText)
{
    Assert (pTreeSaver);

    HRESULT         hr = S_OK;
    INT             i,c;
    CChildIterator  ci (pTreeSaver->GetFragment(), NULL, CHILDITERATOR_DEEP);
    CTreeNode *     pNode;
    CElement *      pElement;

    CStackPtrAry <CElement*, 16> aryElements(Mt(Mem));

    //
    // pass 1 - lock and store elements with behaviors participating in contentSave
    //

    pElement = pTreeSaver->GetFragment();
    do {
        Assert (pElement);

        if (pElement->HasPeerHolder())
        {
            CPeerHolderIterator     itr;

            for (itr.Start(pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                if (itr.PH()->TestFlag(NEEDCONTENTSAVE) && !itr.PH()->TestFlag(LOCKINCONTENTSAVE))
                {
                    pElement->PrivateAddRef(); // balanced in pass 2

                    hr = THR(aryElements.Append(pElement));
                    if (hr)
                        goto Cleanup;

                    break;
                }
            }
        }

        pNode = ci.NextChild();
        pElement = pNode ? pNode->Element() : NULL;
    } while( pElement );

    //
    // pass 2 - fire the content save
    //

    for (i = 0, c = aryElements.Size(); i < c; i++)
    {
        pElement = aryElements[i];

        if (pElement->HasPeerHolder())
        {
            CPeerHolderIterator     itr;

            for (itr.Start(pElement->GetPeerHolder()); !itr.IsEnd(); itr.Step())
            {
                if (itr.PH()->TestFlag(NEEDCONTENTSAVE))
                {
                    VARIANT vt;
                    BSTR bstrSaveType;

                    if( SUCCEEDED( FormsAllocString( fText ? _T("TEXT") : _T("HTML"), &bstrSaveType ) ) )
                    {
                        V_VT(&vt) = VT_BSTR;
                        V_BSTR(&vt) = bstrSaveType;

                        Assert( !itr.PH()->TestFlag(LOCKINCONTENTSAVE));

                        {
                            CPeerHolder::CLock Lock(itr.PH(), LOCKINCONTENTSAVE);

                            IGNORE_HR(itr.PH()->Notify(BEHAVIOREVENT_CONTENTSAVE, &vt));
                        }

                        FormsFreeString( bstrSaveType );
                    }

                    break;
                }
            }
        }

        pElement->PrivateRelease(); // balanced in pass 1
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     NormalizeDoubleNullStr
//
//-------------------------------------------------------------------------

LPTSTR
NormalizeDoubleNullStr(LPTSTR pchSrc)
{
    LPTSTR      pch;
    LPTSTR      pch2;
    int         l;

    if (!pchSrc)
        return NULL;

    // count total length

    pch = pchSrc;
    while (pch[1]) // while second char is not null, indicating that there is at least one more string to go
    {
        pch = _tcschr(pch + 1, 0);
    }

    l = pch - pchSrc + 2;

    // allocate and copy string

    pch = new TCHAR [l];
    if (!pch)
        return NULL;

    memcpy (pch, pchSrc, sizeof(TCHAR) * l);

    // flip 0-s to 1-s so the string becomes usual null-terminated string

    pch2 = pch;
    while (pch2[1])
    {
        pch2 = _tcschr(pch + 1, 0);
        *pch2 = 1;
    }

    return pch;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InitCategory
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::InitCategory()
{
    HRESULT     hr;
    LPTSTR      pchCategory;
    LPTSTR      pchCategoryNorm;

    IElementBehaviorCategory * pPeerCategory;

    hr = THR_NOTRACE(QueryPeerInterface(IID_IElementBehaviorCategory, (void**)&pPeerCategory));
    if (hr || !pPeerCategory)
        return S_OK;

    hr = THR(pPeerCategory->GetCategory(&pchCategory));
    if (hr)
        goto Cleanup;

    // TODO (alexz) this all should be optimized to use hash tables

    pchCategoryNorm = NormalizeDoubleNullStr(pchCategory);

    if (pchCategoryNorm)
    {
        hr = THR(_cstrCategory.Set(pchCategoryNorm));

        delete pchCategoryNorm;
    }

Cleanup:
    ReleaseInterface(pPeerCategory);

    if (pchCategory)
        CoTaskMemFree (pchCategory);


    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ApplyStyleMulti
//
//  Synopsis:   Send down an applystyle to all behaviors.  Need to do this
//              in reverse order so that the behavior in the beginning
//              takes precedence.
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ApplyStyleMulti()
{
    HRESULT                 hr = S_OK;
    long                    c;
    CPeerHolderIterator     itr;
    BYTE                    fi[sizeof(CFormatInfo)];
    CFormatInfo *           pfi = (CFormatInfo*)&fi;
    CStyle *                pStyle = NULL;
    CTreeNode *             pNode;
    CVariant                varStyle;
    IHTMLCurrentStyle *     pCurrentStyle = NULL;
    CAttrArray **           ppAA;

    CStackPtrAry <CPeerHolder *, 16> aryPeers(Mt(Mem));

    //
    // If not in markup, or any of the formats are not valid, bail out now.
    // We will compute the formats later so we will come back in here afterwards.
    //

    Assert(_pElement);
    if (!_pElement->IsInMarkup())
        goto Cleanup;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::ApplyStyleMulti appears to be called at an unsafe moment of time");

    //
    // If any of the formats are not valid, bail out now.
    // We will compute the formats later
    // so we will come back in here afterwards.
    //

    if (!_pElement->IsFormatCacheValid())
        goto Cleanup;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(NEEDAPPLYSTYLE))
        {
            hr = THR(aryPeers.Append(itr.PH()));
            if (hr)
                break;
        }
    }

    if (!aryPeers.Size())
        goto Cleanup;

    //
    // Create and initialize write-able style object.
    //

    pStyle = new CStyle(
        _pElement, DISPID_UNKNOWN,
        CStyle::STYLE_NOCLEARCACHES | CStyle::STYLE_SEPARATEFROMELEM | CStyle::STYLE_REFCOUNTED);
    if (!pStyle)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_pElement->get_currentStyle(&pCurrentStyle, NULL));
    if (hr)
        goto Cleanup;

    pStyle->_pStyleSource = pCurrentStyle;
    pStyle->_pStyleSource->AddRef();

    //
    // Iterate thru array backwards applying the style.
    //

    TraceTag((
        tagPeerApplyStyle,
        "CPeerHolder::ApplyStyleMulti, tag: %ls, id: %ls, sn: %ld; calling _pPeer->Notify",
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

    V_VT(&varStyle) = VT_DISPATCH;
    hr = THR(pStyle->QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(&varStyle)));
    if (hr)
        goto Cleanup;

    for (c = aryPeers.Size() - 1; c >= 0; c--)
    {
        IGNORE_HR(aryPeers[c]->Notify(BEHAVIOREVENT_APPLYSTYLE, &varStyle));
    }

    // NOTE (sambent) The comment below ("Do a force compute...") suggests an
    // intent to do no more work if the peer didn't change anything in the style.
    // But there is no code to implement that intent.  The filter behavior needs
    // to listen for the ApplyStyle notification, and without the check for no
    // changes, there was an infinite loop when an element had a filter whose
    // value was given by an expression (recalc.htm in the DRT).  The following
    // test was suggested by AlexZ as a way to detect no change in the style.

    ppAA = pStyle->GetAttrArray();
    if (!ppAA || !*ppAA || (*ppAA)->Size() == 0)
    {
        goto Cleanup;
    }

    //
    // Do a force compute on the element now with this style object,
    // but only if the caches are cleared.  This implies that
    // the peer did not change any props in the style.
    //

    pNode = _pElement->GetFirstBranch();
    if (!pNode)
        goto Cleanup;

    _pElement->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);

    pfi->_eExtraValues = ComputeFormatsType_ForceDefaultValue;
    pfi->_pStyleForce = pStyle;

    while (pNode)
    {
        TraceTag((
            tagPeerApplyStyle,
            "CPeerHolder::ApplyStyleMulti, tag: %ls, id: %ls, sn: %ld; calling _pElement->ComputeFormats",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

        pfi->_lRecursionDepth = 0;
        _pElement->ComputeFormats(pfi, pNode);
        pNode = pNode->NextBranch();
    }

Cleanup:

    if (pStyle)
    {
        pStyle->PrivateRelease();
    }
    ReleaseInterface(pCurrentStyle);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureNotificationsSentMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::EnsureNotificationsSentMulti()
{
    HRESULT             hr = S_OK;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        IGNORE_HR(itr.PH()->EnsureNotificationsSent());
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureNotificationsSent
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::EnsureNotificationsSent()
{
    HRESULT     hr = S_OK;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::EnsureNotificationsSent appears to be called at an unsafe moment of time");

    if (_pPeer)
    {
        // if need contentReady, but missed moment of parsing closing tag, or know that we won't get it
        if (TestFlag(NEEDCONTENTREADY) &&
            (_pElement->_fExplicitEndTag ||                         // (if we got the notification already)
             HpcFromEtag(_pElement->Tag())->_scope == SCOPE_EMPTY)) // (if we know that we are not going to get it)
        {
            ClearFlag(NEEDCONTENTREADY);
            IGNORE_HR(Notify(BEHAVIOREVENT_CONTENTREADY));
        }

        // if missed moment of quick done, then post a callback to notify.
        // We have to do this async so that they can come back and do attach peer outside of the lock
        if (    TestFlag(NEEDDOCUMENTREADY) 
             && (   _pElement->GetMarkup() 
                 && (   LOADSTATUS_QUICK_DONE <= _pElement->GetMarkup()->LoadStatus() 
                     || !_pElement->GetMarkup()->HtmCtx() ) ) )
        {
            GWPostMethodCall( this, ONCALL_METHOD(CPeerHolder, SendNotificationAsync, sendnotificationasync), BEHAVIOREVENT_DOCUMENTREADY, FALSE, "CPeerHolder::SendNotificationAsync" );
        }
    }

    RRETURN (hr);
}

void
CPeerHolder::SendNotificationAsync(DWORD_PTR dwContext)
{
    Assert( dwContext <= BEHAVIOREVENT_LAST );

    ClearFlag( FlagFromNotification(dwContext) );
    IGNORE_HR( Notify( dwContext ) );
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnElementNotification
//
//-------------------------------------------------------------------------

void
CPeerHolder::OnElementNotification(CNotification * pNF)
{
    LONG                lEvent;

    // We may get these while parsing for innerHTML, and should postpone them
    if( !_fNotifyOnEnterTree )
    {
        switch (pNF->Type())
        {
        case NTYPE_END_PARSE:
            lEvent = BEHAVIOREVENT_CONTENTREADY;
            break;

        case NTYPE_DOC_END_PARSE:
            if( TestFlag(AFTERDOCREADY) )
                return;

            SetFlag(AFTERDOCREADY);
            lEvent = BEHAVIOREVENT_DOCUMENTREADY;
            break;

        default:
            return;
        }

        NotifyMulti(lEvent);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Notify
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Notify(LONG lEvent, VARIANT * pvarParam)
{
    HRESULT     hr;
    CLock       lock(this); // reason to lock: case if the peer blows itself and the element away using outerHTML

    // Make sure we never send these notifications out of markup or in temp markup
    Assert( !IsIdentityPeer() ||
            ( ( lEvent != BEHAVIOREVENT_CONTENTREADY || ( !_fNotifyOnEnterTree && _pElement->IsInMarkup() ) ) &&
              ( lEvent != BEHAVIOREVENT_DOCUMENTREADY || ( !_fNotifyOnEnterTree && _pElement->IsInMarkup() ) ) ) );

    PerfDbgLog(tagPeer, this, "+CPeerHolder::NotifyPeer");
	hr = THR(_pPeer->Notify(lEvent, pvarParam));
    PerfDbgLog2(tagPeer, this, "-CPeerHolder::NotifyPeer(%S, %d)",  (_pPeerFactoryUrl && (LPCTSTR)_pPeerFactoryUrl->_cstrUrl) ? (LPCTSTR)_pPeerFactoryUrl->_cstrUrl : L"", lEvent);

    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::NotifyMulti
//
//-------------------------------------------------------------------------

void
CPeerHolder::NotifyMulti(LONG lEvent)
{
    CPeerHolderIterator itr;
    IElementBehavior *  pPeer;
    FLAGS               flag;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::NotifyMulti appears to be called at an unsafe moment of time");

    TraceTag((
        tagPeerNotifyMulti,
        "CPeerHolder::NotifyMulti, event: %ld, ph: %ld, tag: %ls, id: %ls, SN: %ld, peer: %ls",
        lEvent, CookieID(), _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN(),
        STRVAL(_pPeerFactoryUrl ? (LPTSTR)_pPeerFactoryUrl->_cstrUrl : NULL)));

    flag = FlagFromNotification(lEvent);

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        pPeer = itr.PH()->_pPeer;

        if (!pPeer || !itr.PH()->TestFlag(flag))
            continue;

        IGNORE_HR(itr.PH()->Notify(lEvent));
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     HandleEnterTree
//
//  Synopsis:   Called when an element behavior enters the tree.  This
//              takes care of the two cases where we're either sending
//              delayed content/document-Ready notification for entering
//              its destination tree, or sending a context change
//
//  Returns:    HRESULT
//
//  Arguments:
//
//+----------------------------------------------------------------------------

HRESULT
CPeerHolder::HandleEnterTree()
{
    if( _fNotifyOnEnterTree )
    {
        // If attach behaviors can attach in ether, we should make this a multi
        _fNotifyOnEnterTree = FALSE;
        IGNORE_HR( EnsureNotificationsSent() );
    }
    else
    {
        NotifyMulti(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
    }

    RRETURN( S_OK );
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::ExecMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::ExecMulti(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    HRESULT             hr = MSOCMDERR_E_NOTSUPPORTED;
    CPeerHolderIterator itr;

    AssertSz(IsMarkupStable(_pElement->GetMarkup()), "CPeerHolder::ExecMulti appears to be called at an unsafe moment of time");

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->_pPeerCmdTarget)
        {
            hr = THR_NOTRACE(itr.PH()->_pPeerCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut));
            if (MSOCMDERR_E_NOTSUPPORTED != hr) // if (S_OK == hr || MSOCMDERR_E_NOTSUPPORTED != hr)
                break;
        }
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::TestFlagMulti
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::TestFlagMulti(FLAGS flag)
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->TestFlag(flag))
            return TRUE;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::Save
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL * pfAny)
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    IPersistPropertyBag2 *  pPersistPropertyBag = NULL;
    CPropertyBag *          pPropertyBag = NULL;
    int                     i, c;
    PROPNAMEVALUE *         pPropPair;
    BSTR                    bstrPropName = NULL;
    BOOL                    fAny = FALSE;

    //
    // startup
    //

    if (!_pPeer)
        goto Cleanup;

    hr = _pPeer->QueryInterface(IID_IPersistPropertyBag2, (void**)&pPersistPropertyBag);
    if (hr)
        goto Cleanup;

    pPropertyBag = new CPropertyBag();
    if (!pPropertyBag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // save
    //

    hr = THR(pPersistPropertyBag->Save(pPropertyBag, FALSE, FALSE));
    if (hr)
        goto Cleanup;

    //
    // process results
    //

    c = pPropertyBag->_aryProps.Size();

    if (pfAny)
        *pfAny = (0 < c);   // note that if c is 0, pfAny should not be touched (it can be TRUE already)
                            // (this is how it is used in the codepath)
    for (i = 0; i < c; i++)
    {
        fAny = TRUE;

        pPropPair = &pPropertyBag->_aryProps[i];

        if (pStreamWriteBuff)
        {
            CVariant    varStr;

            //
            // saving to stream
            //

            hr2 = THR(VariantChangeTypeSpecial(&varStr, &pPropPair->_varValue, VT_BSTR));
            if (hr2)
                continue;

            hr = THR(_pElement->SaveAttribute(
                    pStreamWriteBuff, pPropPair->_cstrName, V_BSTR(&varStr),
                    NULL, NULL, /* fEqualSpaces = */ TRUE, /* fAlwaysQuote = */ TRUE));
            if (hr)
                goto Cleanup;
        }
        else
        {
            //
            // saving to expandos
            //

            hr = THR(FormsAllocString(pPropPair->_cstrName, &bstrPropName));
            if (hr)
                goto Cleanup;

            {
                // lock GetDispID method so that the attribute gets set as expando
                CLock lock (this, LOCKGETDISPID);

                hr = THR(_pElement->setAttribute(bstrPropName, pPropPair->_varValue, 0));
                if (hr)
                    goto Cleanup;
            }

            FormsFreeString(bstrPropName);
            bstrPropName = NULL;
        }
    }

Cleanup:
    delete pPropertyBag;

    ReleaseInterface(pPersistPropertyBag);

    if (bstrPropName)
    {
        FormsFreeString(bstrPropName);
        bstrPropName = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SaveMulti
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::SaveMulti(CStreamWriteBuff * pStreamWriteBuff, BOOL * pfAny)
{
    HRESULT                 hr = S_OK;
    CPeerHolderIterator     itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        IGNORE_HR(itr.PH()->Save(pStreamWriteBuff, pfAny));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IllegalSiteCall
//
//  Synopsis:   returns TRUE if call is illegal
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IllegalSiteCall()
{
    if (!_pElement)
        return TRUE;

    if (_pElement->Doc()->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "peer object called MSHTML across apartment thread boundary (not from thread it was created on) (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::EnsureDispatch
//
//  Synposis:   ensures either IDispatch or IDispatchEx pointer cached
//
//-----------------------------------------------------------------------------------

void
CPeerHolder::EnsureDispatch()
{
#if DBG == 1
    if (IsTagEnabled(tagPeerNoOM))
        return;
#endif

    if (TestFlag(DISPCACHED) || !_pPeer)
        return;

    SetFlag (DISPCACHED);

    Assert (!_pDisp);

    IGNORE_HR(_pPeer->QueryInterface(IID_IDispatchEx, (void**)&_pDisp));
    if (_pDisp)
    {
        SetFlag (DISPEX);
    }
    else
    {
        IGNORE_HR(_pPeer->QueryInterface(IID_IDispatch, (void**)&_pDisp));
        Assert (!TestFlag(DISPEX));
    }
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetDispIDMulti
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::GetDispIDMulti(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    DISPID              dispid;
    CPeerHolderIterator itr;

    if (!TestFlag(LOCKGETDISPID))
    {
        CLock lock (this, LOCKGETDISPID);

        STRINGCOMPAREFN pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;

        //
        // check if the requested name is name of a peer in the list
        //

        dispid = DISPID_PEER_NAME_BASE;

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (itr.PH()->_cstrName.Length() && bstrName &&
                0 == pfnStrCmp(itr.PH()->_cstrName, bstrName))
                break;

            dispid++;
        }
        if (!itr.IsEnd())
        {
            if (!pid)
            {
                RRETURN (E_POINTER);
            }

            (*pid) = dispid;
            RRETURN (S_OK);
        }

        //
        // check if the name is exposed by a peer
        //

        grfdex &= (~fdexNameEnsure);  // disallow peer to ensure the name

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (!itr.PH()->TestFlag(AFTERINIT)) // if the peer has not initialized yet
                continue;                       // don't invoke it in name resolution yet

            hr = THR_NOTRACE(itr.PH()->GetDispIDSingle(bstrName, grfdex, pid));
            if (S_OK == hr)
                break;
        }
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvokeExMulti
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::InvokeExMulti(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    if (DISPID_PEER_NAME_BASE <= dispid && dispid <= DISPID_PEER_NAME_MAX)
    {
        if (0 == (wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        //
        // return IDispatch of a peer holder
        //

        // find corresponding peer holder
        dispid -= DISPID_PEER_NAME_BASE;
        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (0 == dispid)
                break;

            dispid--;
        }
        if (itr.IsEnd())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        if (!pvarResult)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR_NOTRACE(itr.PH()->QueryPeerInterface(IID_IDispatch, (void**)&V_DISPATCH(pvarResult)));
        if (hr)
            goto Cleanup;

        V_VT(pvarResult) = VT_DISPATCH;
    }
    else if (DISPID_PEER_HOLDER_FIRST_RANGE_BASE <= dispid)
    {
        //
        // delegate to the corresponding peer holder
        //

        for (itr.Start(this); !itr.IsEnd(); itr.Step())
        {
            if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
                break;
        }

        if (itr.IsEnd())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        hr = THR_NOTRACE(itr.PH()->InvokeExSingle(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR_NOTRACE(InvokeExSingle(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetEventDispidMulti, helper
//
//  called from CScriptElement::CommitFunctionPointersCode
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetEventDispidMulti(LPOLESTR pchEvent, DISPID * pdispid)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    hr = DISP_E_UNKNOWNNAME;
    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        hr = THR_NOTRACE(itr.PH()->_PeerSite.GetEventDispid(pchEvent, pdispid));
        if (S_OK == hr)
            break;
    }

    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetDispIDSingle
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::GetDispIDSingle(BSTR bstrName, DWORD grfdex, DISPID *pdispid)
{
    HRESULT         hr;

    if (IllegalSiteCall())
        RRETURN (E_UNEXPECTED);

    if (!pdispid)
        RRETURN (E_POINTER);

    //
    // check to see if the name is a registered event
    //

    if (0 < CustomEventsCount())
    {
        hr = THR_NOTRACE(_PeerSite.GetEventDispid(bstrName, pdispid));
        if (S_OK == hr)     // if found
            goto Cleanup;   // nothing more todo
    }

    //
    // delegate to the peer object
    //

    EnsureDispatch();

    if (_pDisp)
    {
        if (TestFlag(DISPEX))
        {
            hr = THR_NOTRACE(((IDispatchEx*)_pDisp)->GetDispID(
                bstrName,
                grfdex,
                pdispid));
        }
        else
        {
            hr = THR_NOTRACE(_pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, 0, pdispid));
        }

        if (S_OK == hr)
        {
            if (DISPID_PEER_BASE <= (*pdispid) && (*pdispid) <= DISPID_PEER_MAX)
            {
                (*pdispid) = MapToExternalRange(*pdispid);
            }
            else if (DISPID_PEER_MAX < (*pdispid))
            {
                hr = THR(MapToCompactedRange(pdispid));
                if (hr)
                    goto Cleanup;

                (*pdispid) = MapToExternalRange(*pdispid);
            }
        }
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvokeExSingle
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::InvokeExSingle(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider)
{
    HRESULT         hr;

    if (IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    //
    // OM surfacing of custom peer events
    //

    if (IsCustomEventDispid(dispid))
    {
        hr = THR(_pElement->InvokeAA(dispid, CAttrValue::AA_Internal, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
        goto Cleanup;   // nothing more todo
    }

    //
    // delegate to the peer object
    //

    if (DISPID_PEER_HOLDER_FIRST_RANGE_BASE <= dispid)
    {
        dispid = MapFromExternalRange(dispid);
    }

    EnsureDispatch();

    if (_pDisp)
    {
        CLock Lock( this, LOCKNODRAW );

        if (DISPID_PEER_COMPACTED_BASE <= dispid && dispid <= DISPID_PEER_COMPACTED_MAX)
        {
            hr = THR_NOTRACE(MapFromCompactedRange(&dispid));
            if (hr)
                goto Cleanup;
        }

        if (TestFlag(DISPEX))
        {
            hr = THR_NOTRACE(((IDispatchEx*)_pDisp)->InvokeEx(
                dispid,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo,
                pSrvProvider));
        }
        else
        {
            hr = THR_NOTRACE(InvokeDispatchWithNoThis (
                _pDisp,
                dispid,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo));
        }
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::MapToCompactedRange
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::MapToCompactedRange(DISPID * pdispid)
{
    HRESULT     hr = S_OK;
    int         idx;
    DISPID *    pItem;

    Assert (pdispid);

    //
    // start up
    //

    if (!_pMiscBag)
    {
        _pMiscBag = new CMiscBag();
        if (!_pMiscBag)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // check if we've mapped the dispid already
    // (a trivial euristic: search backwards so to find properties added later faster)
    //

    for (idx = _pMiscBag->_aryDispidMap.Size() - 1; 0 <= idx; idx--)
    {
        if (_pMiscBag->_aryDispidMap[idx] == *pdispid)
        {
            *pdispid = DISPID_PEER_COMPACTED_BASE + idx;
            goto Cleanup; // done
        }
    }

    if (DISPID_PEER_COMPACTED_MAX - DISPID_PEER_COMPACTED_BASE <= _pMiscBag->_aryDispidMap.Size())
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // map
    //

    pItem = _pMiscBag->_aryDispidMap.Append();
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *pItem   = *pdispid;
    *pdispid = DISPID_PEER_COMPACTED_BASE + (_pMiscBag->_aryDispidMap.Size() - 1);

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::MapFromCompactedRange
//
//-----------------------------------------------------------------------------------

HRESULT
CPeerHolder::MapFromCompactedRange(DISPID * pdispid)
{
    HRESULT     hr;
    DISPID      dispid = *pdispid - DISPID_PEER_COMPACTED_BASE;

    if (!_pMiscBag ||
        dispid < 0 || _pMiscBag->_aryDispidMap.Size() <= dispid)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    *pdispid = _pMiscBag->_aryDispidMap[dispid];
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetNextDispIDMulti, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetNextDispIDMulti(
    DWORD       grfdex,
    DISPID      dispid,
    DISPID *    pdispid)
{
    HRESULT             hr;
    CPeerHolderIterator itr;

    itr.Start(this);

    //
    // make a step within peer holder the current dispid belongs to
    //

    if (IsPeerDispid(dispid))
    {
        // find peer holder this dispid belongs to

        for (;;)
        {
            if (itr.PH()->TestFlag(DISPCACHED))
            {
                // if dispid belongs to the itr.PH() range
                if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
                    break;
            }

            itr.Step();
            if (itr.IsEnd())
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }

        Assert (itr.PH()->TestFlag(DISPEX));

        hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetNextDispID(
            grfdex, itr.PH()->MapFromExternalRange(dispid), pdispid));
        switch (hr)
        {
        case S_OK:
            *pdispid = itr.PH()->MapToExternalRange(*pdispid);
            goto Cleanup;   // done;
        case S_FALSE:
            break;          // keep searching
        default:
            goto Cleanup;   // fatal error
        }

        Assert (S_FALSE == hr);

        itr.Step();
        if (itr.IsEnd())
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    //
    // find first peer holder that:
    // - supports IDispatchEx, and
    // - returns next dispid
    //

    for (;;)
    {
        // find first peer holder that supports IDispatchEx
        for (;;)
        {
            itr.PH()->EnsureDispatch();

            if (itr.PH()->TestFlag(DISPEX))
                break;

            itr.Step();
            if (itr.IsEnd())
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }

        // check that it returns next dispid
        hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetNextDispID(grfdex, -1, pdispid));
        switch (hr)
        {
        case S_OK:
            *pdispid = itr.PH()->MapToExternalRange(*pdispid);
            goto Cleanup;   // done;
        case S_FALSE:
            break;          // keep searching
        default:
            goto Cleanup;   // fatal error
        }

        itr.Step();
        if (itr.IsEnd())
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetMemberNameMulti, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetMemberNameMulti(DISPID dispid, BSTR * pbstrName)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->_dispidBase <= dispid && dispid < itr.PH()->_dispidBase + DISPID_PEER_HOLDER_RANGE_SIZE)
        {
            if (itr.PH()->TestFlag(DISPEX))
            {
                hr = THR_NOTRACE(((IDispatchEx*)itr.PH()->_pDisp)->GetMemberName(
                    itr.PH()->MapFromExternalRange(dispid), pbstrName));
            }
            break;
        }
    }

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CustomEventName, helper
//
//----------------------------------------------------------------------------

LPTSTR CPeerHolder::CustomEventName(int cookie)
{
    DISPID  dispid = CustomEventDispid(cookie);
    LPTSTR  pchName = NULL;

    if (IsStandardDispid(dispid))
    {
        PROPERTYDESC * pPropDesc;

        // CONSIDER (alexz): Because of the search below, we have a slight perf hit
        // when building typeinfo: we make a search in prop descs for every registered event.
        // To solve that, we could store prop desc ptr in the array instead of dispid;
        // but then all the rest of code will be slightly penalized for that by having to do
        // more complex access to dispid, especially in normal case of non-standard events.
        _pElement->FindPropDescFromDispID (dispid, &pPropDesc, NULL, NULL);

        Assert(pPropDesc);

        pchName = (LPTSTR)pPropDesc->pstrName;
    }
    else
    {
        CAtomTable * pAtomTable = NULL;

        Assert (IsCustomEventDispid(dispid));

        pAtomTable = _pElement->GetAtomTable();

        Assert(pAtomTable && "missing atom table ");

        pAtomTable->GetNameFromAtom(AtomFromEventDispid(dispid), (LPCTSTR*)&pchName);
    }

    Assert(pchName && "(bad atom table entries?)");

    return pchName;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CanElementFireStandardEventMulti, helper
//
//----------------------------------------------------------------------------

BOOL
CPeerHolder::CanElementFireStandardEventMulti(DISPID dispid)
{
    CPeerHolderIterator         itr;
    int                         i, c;
    CEventsBag *                pEventsBag;
    CEventsBag::CEventsArray *  pEventsArray;
    CEventsItem *               pEventItem;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        pEventsBag = itr.PH()->_pEventsBag;
        if (!pEventsBag)
            continue;

        pEventsArray = &pEventsBag->_aryEvents;
        if (!pEventsArray)
            continue;

        for (i = 0, c = itr.PH()->CustomEventsCount(); i < c; i++)
        {
            pEventItem = &((*pEventsArray)[i]);

            if (dispid == pEventItem->dispid && !(pEventItem->lFlags & BEHAVIOREVENTFLAGS_STANDARDADDITIVE))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetCustomEventsTypeInfoCount, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::GetCustomEventsTypeInfoCount(ULONG * pCount)
{
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (0 < itr.PH()->CustomEventsCount())
        {
            itr.PH()->_pEventsBag->_ulTypeInfoIdx = (*pCount);
            (*pCount)++;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CreateCustomEventsTypeInfo, helper
//
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CreateCustomEventsTypeInfo(ULONG iTI, ITypeInfo ** ppTICoClass)
{
    HRESULT             hr = S_FALSE;
    CPeerHolderIterator itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (0 < itr.PH()->CustomEventsCount() && iTI == itr.PH()->_pEventsBag->_ulTypeInfoIdx)
        {
            hr = THR(itr.PH()->CreateCustomEventsTypeInfo(ppTICoClass));
            break;
        }
    }

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CreateCustomEventsTypeInfo, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CreateCustomEventsTypeInfo(ITypeInfo ** ppTICoClass)
{
    HRESULT     hr;
    int         i, c;
    FUNCDESC    funcdesc;
    LPTSTR      pchName;

    CCreateTypeInfoHelper Helper;

    if (!ppTICoClass)
        RRETURN (E_POINTER);

    //
    // start creating the typeinfo
    //

    hr = THR(Helper.Start(DIID_HTMLElementEvents));
    if (hr)
        goto Cleanup;

    //
    // set up the funcdesc we'll be using
    //

    memset (&funcdesc, 0, sizeof (funcdesc));
    funcdesc.funckind = FUNC_DISPATCH;
    funcdesc.invkind = INVOKE_FUNC;
    funcdesc.callconv = CC_STDCALL;
    funcdesc.cScodes = -1;

    //
    // add all registered events to the typeinfo
    //

    for (i = 0, c = CustomEventsCount(); i < c; i++)
    {
        funcdesc.memid = CustomEventDispid(i);

        hr = THR(Helper.pTypInfoCreate->AddFuncDesc(i, &funcdesc));
        if (hr)
            goto Cleanup;

        pchName = CustomEventName(i);
        hr = THR(Helper.pTypInfoCreate->SetFuncAndParamNames(i, &pchName, 1));
        if (hr)
            goto Cleanup;
    }

    //
    // finalize creating the typeinfo
    //

    hr = THR(Helper.Finalize(IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE));
    if (hr)
        goto Cleanup;

    ReplaceInterface (ppTICoClass, Helper.pTICoClassOut);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnLayoutAvailable
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::OnLayoutAvailable(CLayout * pLayout)
{
    HRESULT     hr = S_OK;

    if (_pRenderBag)
    {
        hr = THR(UpdateRenderBag());

        // Simulate OnResize
        SIZE size;

        pLayout->GetSize(&size);
        OnResize(size);
    }

    RRETURN (hr);
}


void
CPeerHolder::NotifyDisplayTreeAsync(DWORD_PTR dwContext)
{
    NotifyDisplayTree();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::NotifyDisplayTree
//
//-------------------------------------------------------------------------

void
CPeerHolder::NotifyDisplayTree()
{
    Assert(_pRenderBag && _pElement);
    CElement * pElemToUse = NULL;

    // if we're in the middle of drawing (or hit-testing), post the notification
    // to be handled asynchronously.  This should be a rare event - behaviors normally
    // don't change themselves during draw.
    if (_pRenderBag->_pCallbackInfo)
    {
        GWPostMethodCall( this,
                            ONCALL_METHOD(CPeerHolder, NotifyDisplayTreeAsync, notifydisplaytreeasync),
                            0, TRUE, "CPeerHolder::NotifyDisplayTreeAsync" );
        return;
    }

    pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        pElemToUse = _pElement;


    // TODO (KTam): This is bad; no one should be touching the display
    // tree outside of rendering code (text/layout/display).  It's not
    // multi-layout aware.  We need a CLayoutInfo method that exposes this
    // functionality.

    // don't call GetUpdatedLayout unless you want the layout to actually be
    // created at this time.

    if(pElemToUse->HasLayoutAry())
    {
        CLayoutAry * pLayoutAry = pElemToUse->GetLayoutAry();
        CLayout    * pCurLayout;
        int nLayoutCookie = 0;

        for(;;)
        {
            pCurLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
            if(nLayoutCookie == -1 || !pCurLayout)
                break;

            CDispNode *pDispNode = pCurLayout->GetElementDispNode();
            if (pDispNode)
            {
                CView::CEnsureDisplayTree edt(_pElement->Doc()->GetView());
                InvalidateRect(pDispNode, NULL);
                pDispNode->RequestRecalc();
            }
        }
    }
    else
    {
        CLayout *  pLayout = pElemToUse->GetLayoutPtr();

        if (pLayout)
        {
            CDispNode *pDispNode = pLayout->GetElementDispNode();
            if (pDispNode)
            {
                CView::CEnsureDisplayTree edt(pElemToUse->Doc()->GetView());
                InvalidateRect(pDispNode, NULL);
                pDispNode->RequestRecalc();
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvalidateRect
//
//-------------------------------------------------------------------------

void
CPeerHolder::InvalidateRect(CDispNode *pDispNode, RECT* prcInvalid)
{
    Assert(pDispNode && _pRenderBag);
    CRect rc;
    BOOL fHasExpand = _pRenderBag->_fHasExpand;
    COORDINATE_SYSTEM cs = (fHasExpand || PaintZOrder() == HTMLPAINT_ZORDER_REPLACE_ALL)
                    ? COORDSYS_BOX
                    : COORDSYS_CONTENT;

    if (!prcInvalid)
    {
        if (cs == COORDSYS_CONTENT)
        {
            pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);
        }
        else
        {
            rc = pDispNode->GetSize();
            if (fHasExpand)
            {
                rc.Expand(_pRenderBag->_sPainterInfo.rcExpand);
            }
        }
    }
    else
    {
        rc = *prcInvalid;
        if (fHasExpand)
        {
            rc.OffsetRect(_pRenderBag->_sPainterInfo.rcExpand.left,
                          _pRenderBag->_sPainterInfo.rcExpand.top);
        }
    }

    if (PaintZOrder() != HTMLPAINT_ZORDER_WINDOW_TOP)
    {
        pDispNode->Invalidate(rc, cs);
    }
    else
    {
        pDispNode->InvalidateAtWindowTop(rc, cs);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::UpdateRenderBag
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::UpdateRenderBag()
{
    HRESULT     hr = S_OK;
    IHTMLFilterPainter *pFilterPainter;
    IHTMLPainterOverlay *pPainterOverlay;
    IHTMLPainterEventInfo *pEventInfo;
    CElement * pElemToUse;

    Assert (_pRenderBag && _pRenderBag->_pPainter);

    hr = THR(_pRenderBag->_pPainter->GetPainterInfo(&_pRenderBag->_sPainterInfo));
    if (hr)
        goto Cleanup;

    pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        pElemToUse = _pElement;

    // if SURFACE or SURFACE3D bits are set
    if (_pRenderBag->_sPainterInfo.lFlags & (HTMLPAINTER_SURFACE | HTMLPAINTER_3DSURFACE))
    {
        pElemToUse->SetSurfaceFlags(0 != (_pRenderBag->_sPainterInfo.lFlags  & HTMLPAINTER_SURFACE),
                                 0 != (_pRenderBag->_sPainterInfo.lFlags  & HTMLPAINTER_3DSURFACE));
    }


    TraceTag((tagPeerDrawObject, 
              "+ CPeerHolder::UpdateRenderBag, _fWantsDrawObject: %s",
              _pRenderBag->_fWantsDrawObject ? "true" : "false"));

    _pRenderBag->_fWantsDrawObject = !IsEqualIID(_pRenderBag->_sPainterInfo.iidDrawObject, g_Zero.iid);

    TraceTag((tagPeerDrawObject, 
              "- CPeerHolder::UpdateRenderBag, _fWantsDrawObject: %s",
              _pRenderBag->_fWantsDrawObject ? "true" : "false"));

    _pRenderBag->_fHasExpand = !(_pRenderBag->_sPainterInfo.rcExpand.top == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.bottom == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.left == 0 &&
                                _pRenderBag->_sPainterInfo.rcExpand.right == 0);

    _pRenderBag->_fIsFilter = FALSE;
    if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
    {
        _pRenderBag->_fIsFilter = TRUE;
        ReleaseInterface(pFilterPainter);
    }

    _pRenderBag->_fIsOverlay = FALSE;
    if (OK(QueryPeerInterface(IID_IHTMLPainterOverlay, (void**)&pPainterOverlay)))
    {
        _pRenderBag->_fIsOverlay = TRUE;
        ReleaseInterface(pPainterOverlay);
    }

    if ((_pRenderBag->_pAdapter == NULL) && SUCCEEDED(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo)))
    {
        Assert(pEventInfo);

        long flags = 0;

        pEventInfo->GetEventInfoFlags(&flags);

        if (flags & HTMLPAINT_EVENT_TARGET)
            _pRenderBag->_fEventTarget = 1;

        if (flags & HTMLPAINT_EVENT_SETCURSOR)
            _pRenderBag->_fSetCursor = 1;

        pEventInfo->Release();

    }

#if DBG == 1
    if (IsTagEnabled(tagPeerNoHitTesting))
    {
        _pRenderBag->_sPainterInfo.lFlags &= ~HTMLPAINTER_HITTEST;
    }
#endif

    NotifyDisplayTree();

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member: CPeerHolder::OnResize, delegate to the behavior
//
//-------------------------------------------------------------------------
void
CPeerHolder::OnResize(SIZE size)
{
    Assert(_pRenderBag);

    size.cx += _pRenderBag->_sPainterInfo.rcExpand.left + _pRenderBag->_sPainterInfo.rcExpand.right;
    size.cy += _pRenderBag->_sPainterInfo.rcExpand.top + _pRenderBag->_sPainterInfo.rcExpand.bottom;

    _pRenderBag->_pPainter->OnResize(size);
}
//  Member: CPeerHolder::OnResize, delegate to the behavior


extern BOOL g_fInVizAct2000;

//+------------------------------------------------------------------------
//
//  Member: CPeerHolder::Draw, IHTMLPainter
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::Draw(CDispDrawContext * pContext, LONG lRenderInfo)
{
    HRESULT         hr              = S_OK;
    HDC             hdc             = NULL;
    CFormDrawInfo * pDI             = (CFormDrawInfo *)pContext->GetClientData();
    LONG            lDrawFlags      = 0;    // TODO display tree should supply
    IUnknown *      punkDrawObject  = NULL; // TODO display tree should supply
    CRect           rcBounds        = pDI->_rc;
    CRect           rcClip          = pDI->_rcClip;
    CRect           rcClipPrinter;
    int             nSavedDC        = 0;
    HDC             hdcDD           = NULL;
    IDirectDrawSurface *    
                    pDDSurface      = NULL;
    HTML_PAINTER_INFO & 
                    sPainterInfo    = _pRenderBag->_sPainterInfo;
    RENDER_CALLBACK_INFO sCallbackInfo;



    Assert(_pRenderBag && _pRenderBag->_pPainter);

    // fCreateSurface           If we're rendering to an actual printer and the
    //                          filter has requested a DirectDraw surface to
    //                          draw onto, we'll need to create one since
    //                          there's no screen buffer surface during printing.

    bool    fCreateSurface  = false;

    // fWantsDirectDrawObject   True if this rendering behavior would like to
    //                          render to a DirectDraw surface.

    bool    fWantsDirectDrawObject  = 
                   _pRenderBag->_fWantsDrawObject 
                && (IID_IDirectDrawSurface == _pRenderBag->_sPainterInfo.iidDrawObject);

    // fHighResolution          True if the display device is a high resolution
    //                          display.

    bool    fHighResolution = g_uiDisplay.IsDeviceScaling() ? true : false;




    rcClipPrinter.SetRectEmpty();

#if DBG == 1
    // Variables to track hdc origin to ensure the peer doesn't change it on us.

    CPoint ptOrgBefore = g_Zero.pt; // keep compiler happy
    CPoint ptOrgAfter;

    if (IsTagEnabled(tagPeerNoRendering))
        goto Cleanup;
#endif

    // Don't re-enter behaviors from an invoke.

    if (g_fInVizAct2000 && TestFlag(LOCKNODRAW))
    {
        goto Cleanup;
    }

    // Store the information needed if painter calls us back during Draw
    {
        const CDispClipTransform& transform = pContext->GetClipTransform();

        transform.Transform(rcClip, &sCallbackInfo._rcgClip);
        sCallbackInfo._pContext = pContext;

        if (!pContext->GetRedrawRegion()->Contains(sCallbackInfo._rcgClip))
            lDrawFlags |= HTMLPAINT_DRAW_UPDATEREGION;
    }

    // The following code block covers three scenarios, although it looks more 
    // like two.
    //
    // 1.  The painter wants a draw object.  Fill in our punkDrawObject local
    //     variable.
    // 2.  The painter wants an HDC, fill in our hdc local variable.
    // 3.  The painter doesn't want either (implied) in which case both will
    //     be left empty and passed to the painter as NULL.  (Who knows what the
    //     painter will do then.)

    if (_pRenderBag->_fWantsDrawObject)
    {
        // If the renderer wants to draw onto a special draw object, we'll get 
        // the object it wants with the GetSurface call.  Currently only 
        // DirectDraw surfaces are supported as draw objects.  If any other 
        // draw objects are requested, we'll fail and leave the method.

        CSize sizeOffset;

        hr = pDI->GetSurface(!(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP),
                                _pRenderBag->_sPainterInfo.iidDrawObject,
                                (void**)&punkDrawObject, &sizeOffset);

        if (   (E_FAIL == hr)
            && (pContext->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
            && (pContext->GetLayoutContext()->GetMedia() & mediaTypePrint)
            && fWantsDirectDrawObject)
        {
            // If pDI->GetSurface wasn't able to return a surface, and we're
            // print media (print preview or actual printing), and the draw 
            // object requested is a DirectDraw surface it means we're printing
            // to an actual printer and will have to create a surface for the 
            // peer.

            fCreateSurface  = true;
            hr              = S_OK;
        }
        else if (hr)
        {
            goto Cleanup;
        }

        // If we give the painter the DirectDraw surface, they may not be using
        // GDI to paint.  We need to make sure GDI does all of it's cached
        // drawing now so that it won't do it later on top of what the painter
        // is about to draw.

        ::GdiFlush();

        // If the only transformation for this object is a translation to 
        // position it correctly, we'll just add the translation offset into
        // the rectangles we pass the painter.  If not, we'll tell the painter
        // that they need to call us back to get the full tranformation matrix
        // to use.  If the painter doesn't support painting with a 
        // transformation matrix, we just won't draw anything.

        if (   pDI->IsOffsetOnly()
            && !(fHighResolution && fWantsDirectDrawObject))
        {
            rcBounds.OffsetRect(sizeOffset);
            rcClip.OffsetRect(sizeOffset);
        }
        else if (sPainterInfo.lFlags & HTMLPAINTER_SUPPORTS_XFORM)
        {
            lDrawFlags |= HTMLPAINT_DRAW_USE_XFORM;
        }
        else
        {
            goto Cleanup;
        }

        // If we're working with an object that renders to a DirectDraw surface
        // we will have to scale the coordinates down if we're printing or in 
        // high resolution drawing mode.

        if (fWantsDirectDrawObject)
        {
            if (   (pContext->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
                && (pContext->GetLayoutContext()->GetMedia() & mediaTypePrint))
            {
                // If we're printing an object that's rendering to a DirectDraw
                // surface we need to convert the coordinates from print
                // measurement coordinates to screen coordinates.  These
                // painters should not know the difference between screen
                // rendering and print rendering.

                // Save clip bounds in printer device coordinates in case we're 
                // rendering to a printer.

                CopyRect(&rcClipPrinter, &rcClip);

                // Transform bounds into screen coordinates.

                // 2001/03/28 mcalkins:
                // Should really use DocPixelsFromDevice, why didn't I notice
                // that before?

                g_uiVirtual.TargetFromDevice(rcBounds,  g_uiDisplay);
                g_uiVirtual.TargetFromDevice(rcClip,    g_uiDisplay);

    #if DBG == 1
                if (IsTagEnabled(tagPrintFilterRect))
                {
                    XHDC    xhdc    = pDI->GetDC(
                                      !(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP));
                    HBRUSH  hbr     = CreateSolidBrush(RGB(255, 0, 0));

                    xhdc.FillRect(&rcClipPrinter, hbr);

                    DeleteObject(hbr);
                }
    #endif
            }
            else if (fHighResolution)
            {
                // If we're in high resolution mode, we need to convert from the
                // screen device DPI down to the document DPI (generally 96dpi.)

                g_uiDisplay.DocPixelsFromDevice(&rcBounds);
                g_uiDisplay.DocPixelsFromDevice(&rcClip);
            }
        }

    }
    else if (!(sPainterInfo.lFlags & HTMLPAINTER_NODC))
    {
        XHDC    xhdc            = pDI->GetDC(!(sPainterInfo.lFlags 
                                               & HTMLPAINTER_NOPHYSICALCLIP));
        CSize   sizeTranslate   = g_Zero.size;

        // Similar to the logic for when the painter wants a draw object above.
        // If the transformation for the element is merely a translation, 
        // XHDC::GetTranslatedDC will return true and fill in the sizeTranslate
        // structure.  Otherwise if the painter supports drawing with a 
        // complex transformation matrix, we'll tell them to call Trident back
        // to ask for the matrix.  Otherwise, if we're printing, we'll use the
        // NoTransformDrawHelper.

        if (xhdc.GetTranslatedDC(&hdc, &sizeTranslate))
        {
            rcBounds.OffsetRect(sizeTranslate);
            rcClip.OffsetRect(sizeTranslate);
        }
        else if (sPainterInfo.lFlags & HTMLPAINTER_SUPPORTS_XFORM)
        {
            // The painter says it can deal with transforms.  Give it the raw
            // DC, and wish it luck.  If it screws up, don't blame Trident.

            lDrawFlags |= HTMLPAINT_DRAW_USE_XFORM;
            hdc         = xhdc.GetPainterDC();
        }
        else
        {
            // If the painter can't deal with transforms, then we need to help
            // them out (back compat) when printing.  IsPrintPreviewDoc()
            // returns true if we're print previewing or if we're actually
            // printing to a printer device.
            if (_pElement->IsPrintMedia())
            {
                // set up the callback info
                sCallbackInfo._lFlags = lDrawFlags;
                _pRenderBag->_pCallbackInfo = &sCallbackInfo;

                hr = NoTransformDrawHelper(pContext);
            }

            goto Cleanup;
        }
    }

#if DBG == 1
    if (hdc && IsTagEnabled(tagVerifyPeerDraw))
    {
        ::GetViewportOrgEx(hdc, &ptOrgBefore);
    }
#endif

    // If we're sending an HDC and the painter has asked us to save the state
    // of the device context, then save it.  This takes the pressure of the 
    // painter for leaving the device context as it was given.
    
    if (hdc && !(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC))
    {
        nSavedDC = ::SaveDC(hdc);
    }

    // set up the callback info
    sCallbackInfo._lFlags = lDrawFlags;
    _pRenderBag->_pCallbackInfo = &sCallbackInfo;

    TraceTag((tagPainterDraw, "Draw %x (%ld,%ld,%ld,%ld) (%ld,%ld,%ld,%ld) %x",
                this,
                rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom,
                rcClip.left, rcClip.top, rcClip.right, rcClip.bottom,
                lDrawFlags
            ));

    // If we don't have to create a DirectDraw surface for the painter we're
    // prepared to ask the painter to draw at this point.

    if (!fCreateSurface)
    {
        // Some painters, like the 64 bit VML change the DC setting (like ViewportOrg)
        // And that problem in this branch because here we ususally reuse the surface.
        // We used to save and restore the hdc, but not the one from the surface
        int nSaveDCSurf = 0;
        HDC hdcSurface = NULL;
        // Painters can promise they will not change the DC, and in that case we can save
        // 2 system calls.
        if((!(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC)) && pDI->_pSurface)
        {
            pDI->_pSurface->GetDC(&hdcSurface);
            nSaveDCSurf = SaveDC(hdcSurface);
        }

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds, rcClip, lDrawFlags,
                                              hdc, (void *)punkDrawObject));

        if (hr == E_NOTIMPL)
        {
            hr = S_OK;
        }

        if(!(sPainterInfo.lFlags & HTMLPAINTER_NOSAVEDC))
        {
            if (nSaveDCSurf)
            {
                ::RestoreDC(hdcSurface, nSaveDCSurf);
            }
        }

    }
    else 
    {
        // At this point we're printing to an actual printer device for a
        // painter that's requested a DirectDraw surface.  We need to create the
        // surface.

        CElement *      pElemParent     = NULL;
        DWORD           dwBackground    = 0xFFFFFFFF; // Default to white.
        XHDC            xhdc            = pDI->GetDC(!(sPainterInfo.lFlags & HTMLPAINTER_NOPHYSICALCLIP));
        DDSURFACEDESC   ddsd;
        DDBLTFX         ddbfx;

        Assert(NULL == hdc);

        // Translate the rects so that their origin is {0, 0}.

        OffsetRect(&rcClip,   -rcClip.left,   -rcClip.top);
        OffsetRect(&rcBounds, -rcBounds.left, -rcBounds.top);

        // Clear the surface description and blit effects structures.

        ZeroMemory(&ddsd, sizeof(ddsd));
        ZeroMemory(&ddbfx, sizeof(ddbfx));

        // Prepare a surface description of the surface that will be passed
        // to the painter.

        ddsd.dwSize     = sizeof(DDSURFACEDESC);
        ddsd.dwFlags    = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
        ddsd.dwHeight   = rcClip.bottom - rcClip.top;
        ddsd.dwWidth    = rcClip.right  - rcClip.left;

        ddsd.ddsCaps.dwCaps = DDSCAPS_DATAEXCHANGE | DDSCAPS_OWNDC 
                              | DDSCAPS_3DDEVICE;

        ddsd.ddpfPixelFormat.dwSize             = sizeof(DDPIXELFORMAT);
        ddsd.ddpfPixelFormat.dwFlags            = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwFourCC           = 0;
        ddsd.ddpfPixelFormat.dwRGBBitCount      = 32;
        ddsd.ddpfPixelFormat.dwRBitMask         = 0x00FF0000;
        ddsd.ddpfPixelFormat.dwGBitMask         = 0x0000FF00;
        ddsd.ddpfPixelFormat.dwBBitMask         = 0x000000FF;
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask  = 0x00000000;

        // Create the surface.

        hr = g_pDirectDraw->CreateSurface(&ddsd, &pDDSurface, NULL);

        if (hr)
        {
            goto Cleanup;
        }

        // Get parent element.

        pElemParent = _pElement->GetFirstBranch()->Parent()->Element();

        if (pElemParent)
        {
            COLORREF colorBackground = pElemParent->GetInheritedBackgroundColor();

            // COLORREFs come in a different format than traditional AARRGGBB
            // so we need to assemble a traditional DWORD representation of the
            // color to be used by ddraw.

            dwBackground =    0xFF000000 
                            | GetRValue(colorBackground) << 16
                            | GetGValue(colorBackground) << 8
                            | GetBValue(colorBackground);
        }

        // Draw parent's background color onto the surface.  We would like to
        // be able to draw everything behind the element onto the surface but
        // that is too complex for IE6.0.  In the future, we should use GDIPlus
        // or some other technology that is capable of blitting to printers
        // using alpha blending.

        ddbfx.dwSize        = sizeof(ddbfx);
        ddbfx.dwFillColor   = dwBackground;

        hr = pDDSurface->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddbfx);

        if (hr)
        {
            goto Cleanup;
        }

        // Get the DC from the DirectDraw surface to create the XHDC that
        // will be used for the StretchBlt calls.
        
        hr = pDDSurface->GetDC(&hdcDD);

        if (hr)
        {
            goto Cleanup;
        }
        else
        {
            // Create the XHDC for the DirectDraw surface.

            BOOL        fResult                 = FALSE;
            XHDC        xhdcDD(hdcDD, NULL);

            // TODO:    (mcalkins) Some function should be called here to draw
            //          the page behind the element onto the surface being
            //          passed to the painter.

            // We don't want the painter to use the transform because we'll use
            // StretchBlt later to do both the appropriate scaling and offset.

            lDrawFlags &= (~HTMLPAINT_DRAW_USE_XFORM);

            // Ask the painter to draw.

            hr = THR(_pRenderBag->_pPainter->Draw(rcBounds, rcClip,
                                                  lDrawFlags, hdc, 
                                                  (void *)pDDSurface));

            if (hr)
            {
                if (hr == E_NOTIMPL)
                {
                    hr = S_OK;
                }

                goto Cleanup;
            }

            fResult = xhdc.StretchBlt(rcClipPrinter.left, rcClipPrinter.top, 
                                      rcClipPrinter.right - rcClipPrinter.left,
                                      rcClipPrinter.bottom - rcClipPrinter.top,
                                      xhdcDD,
                                      rcClip.left, rcClip.top, 
                                      rcClip.right - rcClip.left,
                                      rcClip.bottom - rcClip.top,
                                      SRCCOPY);

            if (!fResult)
            {
#if DBG == 1
                DWORD dw = GetLastError();

                TraceTag((tagVerifyPeerDraw, 
                          "In CPeerHolder::Draw, "
                          "XHDC::StretchBlt failed.  GetLastError: %x",
                          dw));
#endif

                hr = E_FAIL;

                goto Cleanup;
            }
        }
    }

Cleanup:

    _pRenderBag->_pCallbackInfo = NULL;


#if DBG == 1
    if (hdc && IsTagEnabled(tagVerifyPeerDraw))
    {
        ::GetViewportOrgEx(hdc, &ptOrgAfter);
        if (ptOrgBefore != ptOrgAfter)
        {
            TraceTag((tagVerifyPeerDraw, "peer %x changed DC %x origin from %d,%d to %d,%d",
                      this, hdc,
                      ptOrgBefore.x, ptOrgBefore.y,
                      ptOrgAfter.x, ptOrgAfter.y));
        }
    }
#endif

    if (nSavedDC)
    {
        ::RestoreDC(hdc, nSavedDC);
    }

    if (hdcDD)
    {
        ReleaseDC(NULL, hdcDD);
    }

    ReleaseInterface(pDDSurface);

    RRETURN(hr);
}
//  Member: CPeerHolder::Draw, IHTMLPainter


//+----------------------------------------------------------------------
//
//  Member :    CPeerHolder:NoTransformDrawHelper
//
//  Synopsis :  This is called for printing renderingBehaviors that do NOT
//      themselves support transformations.  To make this work (back compat)
//      what we do is:
//          1. create a base-white bitmap and have the behavior draw into that
//          2. create a base-black bintmap and have the behavior draw into that
//          3. xor the bitmaps to get a mask
//          4. use the mask to whiten the bits to draw in the destination DC
//          5. now transfer (using bit-wise-and) the white-base drawing to the
//                  destination
//
//-----------------------------------------------------------------------
HRESULT
CPeerHolder::NoTransformDrawHelper(CDispDrawContext * pContext)
{
    HRESULT         hr     = S_OK;

    HDC             hdcBmpWhite   = NULL;
    HBITMAP         hbmpWhite     = NULL;
    HBRUSH          hbrWhite      = NULL;
    XHDC            xhdcSrcWhite  = NULL;

    HDC             hdcBmpBlack   = NULL;
    HBITMAP         hbmpBlack     = NULL;
    HBRUSH          hbrBlack      = NULL;
    XHDC            xhdcSrcBlack  = NULL;

    CFormDrawInfo * pDI    = (CFormDrawInfo *) pContext->GetClientData();
    CRect           rcBounds = pDI->_rc;
    CRect           rcClip   = pDI->_rcClip;
    HANDLE          hbmpOrg  = NULL;
    XHDC            xhdcDest = pDI->GetDC();

    {
        //TODO (mikhaill) -- this seem works correct, but I'm not sure
        //that these weird coordinate conversions should be made here
        if (xhdcDest.GetObjectType() == OBJ_DC)
        {
            const CWorldTransform &xf = xhdcDest.transform();
            xf.Transform(&rcBounds);
            xf.Transform(&rcClip);
        }
        else
        {
            rcBounds.left   = pDI->DocPixelsFromDeviceX(rcBounds.left  );
            rcBounds.top    = pDI->DocPixelsFromDeviceY(rcBounds.top   );
            rcBounds.right  = pDI->DocPixelsFromDeviceX(rcBounds.right );
            rcBounds.bottom = pDI->DocPixelsFromDeviceY(rcBounds.bottom);
            rcClip.left   = pDI->DocPixelsFromDeviceX(rcClip.left  );
            rcClip.top    = pDI->DocPixelsFromDeviceY(rcClip.top   );
            rcClip.right  = pDI->DocPixelsFromDeviceX(rcClip.right );
            rcClip.bottom = pDI->DocPixelsFromDeviceY(rcClip.bottom);
        }
    }

    rcClip.OffsetRect(-rcBounds.TopLeft().AsSize());
    rcBounds.MoveToOrigin();

    //
    // 1. get a white-based bitmap in compatible DC
    //------------------------------------------------
    {
        hdcBmpWhite = CreateCompatibleDC(xhdcDest);
        if (!hdcBmpWhite)
        {
            hr = GetLastError();
            goto Cleanup;
        }

        hbmpWhite = CreateCompatibleBitmap(xhdcDest,
                                           rcBounds.Width(),
                                           rcBounds.Height());
        if (!hbmpWhite )
        {
            WHEN_DBG(GetLastError());
            hr = S_OK;
            goto Cleanup;
        }

        hbmpOrg = SelectObject(hdcBmpWhite, hbmpWhite);
        hbrWhite = CreateSolidBrush(0xffffff);      // white
        xhdcSrcWhite = XHDC(hdcBmpWhite, NULL);

        // fill with white
        xhdcSrcWhite.FillRect(&rcBounds, hbrWhite);

        // do the actual draw into that bitmap
        //--------------------------------------------------

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds,
                                              rcBounds,
                                              0,
                                              hdcBmpWhite,
                                              NULL));

    }

    if (hr)
        goto Cleanup;

    //
    // 3. get a black-based bitmap in compatible DC
    //------------------------------------------------
    {
        hdcBmpBlack = CreateCompatibleDC(xhdcDest);
        if (!hdcBmpBlack)
        {
            hr = GetLastError();
            goto Cleanup;
        }

        hbmpBlack = CreateCompatibleBitmap(xhdcDest,
                                           rcBounds.Width(),
                                           rcBounds.Height());
        if (!hbmpBlack)
        {
            WHEN_DBG(GetLastError());
            hr = S_OK;
            goto Cleanup;
        }

        hbmpOrg = SelectObject(hdcBmpBlack, hbmpBlack);
        hbrBlack = CreateSolidBrush(0x0);            // Black
        xhdcSrcBlack = XHDC(hdcBmpBlack, NULL);

        // fill with Black
        xhdcSrcBlack.FillRect(&rcBounds, hbrBlack);

        // do the actual draw into that bitmap
        //--------------------------------------------------

        hr = THR(_pRenderBag->_pPainter->Draw(rcBounds,
                                              rcBounds,
                                              0,
                                              hdcBmpBlack,
                                              NULL));

    }


    if (hr)
        goto Cleanup;
    //
    // 4. create a mask from the two bitmaps
    //------------------------------------------------
    {
        if (!xhdcSrcBlack.StretchBlt(
                     rcBounds.left,
                     rcBounds.top,
                     rcBounds.Width(),
                     rcBounds.Height(),
                     xhdcSrcWhite,
                     rcBounds.left,
                     rcBounds.top,
                     rcBounds.Width(),
                     rcBounds.Height(),
                     SRCINVERT))
        {
            hr = GetLastError();
            goto Cleanup;
        }
    }

    //
    // 5.  Use the mask to maskBlt to whiten the destinate bits
    //      that we know we want to print to
    //------------------------------------------------
    if (!xhdcDest.StretchBlt(
                        pDI->_rcClip.left,   // Destination values
                        pDI->_rcClip.top,
                        pDI->_rcClip.Width(),
                        pDI->_rcClip.Height(),
                        xhdcSrcBlack,      // Black is currently the Mask
                        rcClip.left,       // Source values
                        rcClip.top,
                        rcClip.Width(),
                        rcClip.Height(),
                        MERGEPAINT))       // invert the mask, Bitwise OR into the dest
    {
        hr = GetLastError();
    }

    // we have now whitened the destination bits that we want to print to.

    //
    // 6. transfer the white-based drawn image into the whitened destination
    //-----------------------------------------------------------------------
    if (SUCCEEDED(hr))
    {
        // now StretchBlt into the place where we render
        //-----------------------------------------------
        if (!xhdcDest.StretchBlt(
                            pDI->_rcClip.left,   // Destination values
                            pDI->_rcClip.top,
                            pDI->_rcClip.Width(),
                            pDI->_rcClip.Height(),
                            xhdcSrcWhite,
                            rcClip.left,       // Source values
                            rcClip.top,
                            rcClip.Width(),
                            rcClip.Height(),
                            SRCAND))          // DWORD dwRop
        {
            hr = GetLastError();
        }
    }

Cleanup:
    if (hr == E_NOTIMPL)
        hr = S_OK;

    if (hdcBmpWhite)
        DeleteDC(hdcBmpWhite);

    if (hbmpWhite)
        DeleteObject(hbmpWhite);

    if (hbrWhite)
        DeleteObject(hbrWhite);

    if (hdcBmpBlack)
        DeleteDC(hdcBmpBlack);

    if (hbmpBlack)
        DeleteObject(hbmpBlack);

    if (hbrBlack)
        DeleteObject(hbrBlack);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::HitTestPoint, helper for IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::HitTestPoint(CDispHitContext *pContext, BOOL fHitContent, POINT * pPoint, BOOL * pfHit)
{
    HRESULT     hr;
    Assert(_pRenderBag && _pRenderBag->_pPainter);
    Assert(_pRenderBag->_pCallbackInfo == NULL);
    CHitTestInfo *phti = (CHitTestInfo *)(pContext->_pClientData);
    RENDER_CALLBACK_INFO sCallbackInfo;

    *pfHit = FALSE;
    sCallbackInfo._pContext = pContext;
    _pRenderBag->_pCallbackInfo = &sCallbackInfo;
    _pRenderBag->_fHitContent = fHitContent;

    // this is a bad assert.  the reason is that a "psuedo hit" fills in this
    // structure, but RETURNS FALSE so that hit testing can continue looking for a
    // "hard" hit.
    // Assert(phti->_htc == HTC_NO);

    LONG lPartID;

    TraceTag((tagPainterHit, "%x +HitTest at %ld,%ld",
                    this, pPoint->x, pPoint->y));

    // TODO (michaelw) sambent should fix this
    //
    // Behaviors expect coordinates to be local to their 0, 0 based rect
    //
    // The display tree incorrectly assumes a rect of -something, -something, ...
    //

    POINT pt = *pPoint;

    pt.x += _pRenderBag->_sPainterInfo.rcExpand.left;
    pt.y += _pRenderBag->_sPainterInfo.rcExpand.top;
    hr = THR(_pRenderBag->_pPainter->HitTestPoint(pt, pfHit, &lPartID));

    TraceTag((tagPainterHit, "%x -HitTest at %ld,%ld  returns %s  part %ld",
                    this, pPoint->x, pPoint->y, (*pfHit? "true" : "false"), lPartID));

    _pRenderBag->_pCallbackInfo = NULL;

    if (!hr && *pfHit)
    {
        // If the behavior is actually a filter and is nesting hit-tests and it succeeded then
        // _htc has already been set.  Otherwise, the hit is really on this element/behavior
        if (phti->_htc == HTC_NO)
        {
            // We can't set the htc code here because the layout
            // code needs to see if it has been set or not
            if (phti->_plBehaviorCookie)
                *phti->_plBehaviorCookie = CookieID();

            if (phti->_plBehaviorPartID)
                *phti->_plBehaviorPartID = lPartID;

            if (phti->_ppElementEventTarget)
                IGNORE_HR(GetEventTarget(phti->_ppElementEventTarget));
        }

    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetEventTarget
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::GetEventTarget(CElement **ppElement)
{
    Assert(ppElement);
    HRESULT hr = S_FALSE;

    *ppElement = NULL;
    if (_pRenderBag->_fEventTarget)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            IHTMLElement *pElement = 0;

            hr = THR(pEventInfo->GetEventTarget(&pElement));
            if (!hr && pElement)
            {
                hr = THR(pElement->QueryInterface(CLSID_CElement, (LPVOID *)ppElement));
                if (!hr)
                    *ppElement = NULL;

                ReleaseInterface(pElement);
            }
            ReleaseInterface(pEventInfo);
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SetCursor
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::SetCursor(LONG lPartID)
{
    HRESULT hr = S_FALSE;
    if (_pRenderBag && _pRenderBag->_fSetCursor)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            hr = pEventInfo->SetCursor(lPartID);

            ReleaseInterface(pEventInfo);
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::StringFromPartID
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::StringFromPartID(LONG lPartID, BSTR *pbstrPartID)
{
    HRESULT hr = S_FALSE;
    if (_pRenderBag && _pRenderBag->_pPainter && _pRenderBag->_pAdapter == NULL)
    {
        IHTMLPainterEventInfo *pEventInfo = NULL;

        hr = THR(_pRenderBag->_pPainter->QueryInterface(IID_IHTMLPainterEventInfo, (LPVOID *)&pEventInfo));
        if (!hr && pEventInfo)
        {
            hr = pEventInfo->StringFromPartID(lPartID, pbstrPartID);

            ReleaseInterface(pEventInfo);
        }
        
        if (hr == E_NOINTERFACE)
            hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::OnMove, helper for IHTMLPainter
//
//-------------------------------------------------------------------------
HRESULT
CPeerHolder::OnMove(CRect *prcScreen)
{
    HRESULT hr = S_OK;
    if (_pRenderBag && _pRenderBag->_fIsOverlay)
    {
        IHTMLPainterOverlay *pPainterOverlay = NULL;

        hr = THR(QueryPeerInterface(IID_IHTMLPainterOverlay, (LPVOID *)&pPainterOverlay));
        if (!hr && pPainterOverlay)
        {
            hr = pPainterOverlay->OnMove(*prcScreen);

            ReleaseInterface(pPainterOverlay);
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::InvalidateFilter, helper for filter behavior
//
//-------------------------------------------------------------------------

void
CPeerHolder::InvalidateFilter(
                const RECT* prc,
                HRGN hrgn,
                BOOL fSynchronousRedraw)
{
    Assert(IsFilterPeer());
    IHTMLFilterPainter *pFilterPainter = NULL;

    if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
    {
        BOOL fSyncRedrawSave = _pRenderBag->_fSyncRedraw;
        _pRenderBag->_fSyncRedraw = fSynchronousRedraw;

        if (hrgn)
        {
            pFilterPainter->InvalidateRgnUnfiltered(hrgn);
        }
        else
        {
            if(prc)
            {
                CRect rcInvalid = *prc;
                pFilterPainter->InvalidateRectUnfiltered(&rcInvalid);
            }
            else
            {
                pFilterPainter->InvalidateRectUnfiltered(NULL);
            }
        }

        _pRenderBag->_fSyncRedraw = fSyncRedrawSave;
    }

    ReleaseInterface(pFilterPainter);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::SetFilteredElementVisibility, helper for filter behavior
//
//  Synopsis:   Sets the element's desired visibility to the given value,
//              and returns the value to use for the actual visibility.
//              A transition may override the element's visibility in order
//              to keep rendering  until the transition finishes.
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::SetFilteredElementVisibility(BOOL fElementVisible)
{
    Assert(IsFilterPeer());

    if (!!_pRenderBag->_fElementInvisible != !fElementVisible)
    {
        _pRenderBag->_fElementInvisible = !fElementVisible;

        TraceTag((tagFilterVisible, "%ls %d (%x) set eltVis=%d  Now eltVis=%d filVis=%d",
                    _pElement->TagName(), _pElement->SN(), _pElement,
                    fElementVisible,
                    !_pRenderBag->_fElementInvisible,
                    !_pRenderBag->_fFilterInvisible));
                    
        // tell filter - give it a chance to update _fElementInvisible
        IHTMLFilterPainter *pFilterPainter = NULL;
        if (OK(QueryPeerInterface(IID_IHTMLFilterPainter, (void**)&pFilterPainter)))
        {
            // we're changing on behalf of the element, so don't fire OnPropertyChange
            _pRenderBag->_fBlockPropertyNotify = TRUE;

            IGNORE_HR(pFilterPainter->ChangeElementVisibility(fElementVisible));

            _pRenderBag->_fBlockPropertyNotify = FALSE;
        }

        ReleaseInterface(pFilterPainter);
    }

    BOOL fElementVisibleNow = !_pRenderBag->_fFilterInvisible;

    // save a trace that filter have changed visibility
    _pRenderBag->_fVisibilityForced = fElementVisible != fElementVisibleNow;

    return fElementVisibleNow;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsRelated, helper
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IsRelated(LPTSTR pchCategory)
{
    return _cstrCategory.IsNull() ?
        FALSE :
        NULL != StrStrI(_cstrCategory, pchCategory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsRelatedMulti, helper
//
//-------------------------------------------------------------------------

BOOL
CPeerHolder::IsRelatedMulti(LPTSTR pchCategory, CPeerHolder ** ppPeerHolder)
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsRelated(pchCategory))
        {
            if (ppPeerHolder)
            {
                *ppPeerHolder = itr.PH();
            }
            return TRUE;
        }
    }

    if (ppPeerHolder)
    {
        *ppPeerHolder = NULL;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::IsCorrectIdentityPeerHolder, DEBUG ONLY helper
//
//-------------------------------------------------------------------------

#if DBG == 1
BOOL
CPeerHolder::IsCorrectIdentityPeerHolder()
{
    int                                 c;
    CPeerHolder::CPeerHolderIterator    itr;

    c = 0;
    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsIdentityPeer())
        {
            Assert (itr.PH() == this);

            c++;
        }
    }

    return c <= 1;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetRenderPeerHolder
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetRenderPeerHolder()
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsRenderPeer())
            return itr.PH();
    }
    return NULL;
}

//+------------------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetElementToUseForPageTransitions
//                    This will return the element that the peer is attached.
//                    If in the middle of a page transition and the element is
//                  the root element it will return the canvas (body, frameset, html)
//                  element of the old or new markup, depending on the transition state
//-------------------------------------------------------------------------------------

CElement *
CPeerHolder::GetElementToUseForPageTransitions()
{
    CElement * pElemToUse;

    pElemToUse = _pElement;

    if(pElemToUse && pElemToUse->IsRoot())
    {
        CDocument * pDocument = pElemToUse->DocumentOrPendingDocument();

        // We need to delagate the rendering to the old or new markup, depending
         // on the page transition state
        if(pDocument && pDocument->HasPageTransitions())
        {
            CMarkup * pMarkupOld = pDocument->GetPageTransitionInfo()->GetTransitionFromMarkup();
            if(pMarkupOld)
                // pMarkupOld is only set during the Apply() call and forces
                // the rendering to happen with the old markup and html (body, frameset) element
                pElemToUse = pMarkupOld->GetCanvasElement();
            else
                // Use the new html (body, frameset) element (current markup should be the new one)
                pElemToUse = pElemToUse->GetMarkup()->GetCanvasElement();
            }
    }

   return pElemToUse;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::GetFilterPeerHolder
//
//-------------------------------------------------------------------------

CPeerHolder *
CPeerHolder::GetFilterPeerHolder()
{
    CPeerHolder::CPeerHolderIterator    itr;

    for (itr.Start(this); !itr.IsEnd(); itr.Step())
    {
        if (itr.PH()->IsFilterPeer())
            return itr.PH();
    }
    return NULL;
}


///////////////////////////////////////////////////////////////////////////
//
//  CPaintAdapter is a helper class to provide backwards compatibility for
//  existing behaviors that use IElementBehaviorRender.  When we see one of
//  these behaviors, we create an adapter and use it as the IHTMLPainter.
//  In turn, it forwards the work to IEBR.  There's a corresponding
//  translation between IHTMLPaintSite and IElementBehaviorSiteRender that's
//  handled by the peer site directly.
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::Draw  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::Draw(RECT rcBounds,
                                RECT rcUpdate,
                                LONG lDrawFlags,
                                HDC hdc,
                                LPVOID pvDrawObject)
{
    HRESULT hr;

    LONG lRenderInfo = _lRenderInfo & BEHAVIORRENDERINFO_ALLLAYERS;

    // A few VML shapes need to draw at AFTERBACKGROUND (to set up scale) as
    // well as BEFORECONTENT.  We're only prepared to make one call to Draw, which
    // we'll do at below-flow time, but retaining the original lRenderInfo.  This
    // gets VML to draw both layers, although the AFTERBACKGROUND layer will come
    // after any child content with negative z-index.  The VML/PPT folks tell me
    // that Office doesn't generate any -z content, and OK'd this workaround.
    // (Otherwise, we'd have to figure out a mechanism to call the same peer twice,
    // and fill in some context to get the first call to specify AFTERBACKGROUND and
    // the second one BEFORECONTENT.  Possible, but not particularly pleasant.)

    //if (lRenderInfo == 6)               // VML bug
        //lRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT;

    // old-style behaviors can't handle non-zero based rcBounds
    POINT ptOrg;
    ::GetViewportOrgEx(hdc, &ptOrg);
    ptOrg.x += rcBounds.left;
    ptOrg.y += rcBounds.top;

    // don't bother to draw on Win9x if our coordinate values exceed
    // what SetViewportOrgEx can handle
    if ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS) &&
        (ptOrg.x < SHRT_MIN || ptOrg.x > SHRT_MAX ||
         ptOrg.y < SHRT_MIN || ptOrg.y > SHRT_MAX))
    {
        AssertSz(FALSE, "Behavior can't be drawn at large coordinate values");
        RRETURN(S_OK);
    }

    // pass zero-based bounds with offset contained in DC
    rcBounds.right -= rcBounds.left;
    rcBounds.bottom -= rcBounds.top;
    rcBounds.left = rcBounds.top = 0;
    ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, &ptOrg);

    hr = THR(_pPeerRender->Draw(hdc, lRenderInfo, &rcBounds, (IPropertyBag *)NULL));

    ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::GetPainterInfo  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::GetPainterInfo(HTML_PAINTER_INFO* pInfo)
{
    Assert(pInfo && _pPeerHolder && _pPeerHolder->_pRenderBag);

    HRESULT     hr;
    LONG lFlags = 0;

    hr = THR(_pPeerRender->GetRenderInfo(&_lRenderInfo));
    if (hr)
        goto Cleanup;

    lFlags |= HTMLPAINTER_TRANSPARENT;      // have to assume it's transparent

    if (_lRenderInfo & BEHAVIORRENDERINFO_HITTESTING)
        lFlags |= HTMLPAINTER_HITTEST;

    if (_lRenderInfo & BEHAVIORRENDERINFO_SURFACE)
        lFlags |= HTMLPAINTER_SURFACE;
    if (_lRenderInfo & BEHAVIORRENDERINFO_3DSURFACE)
        lFlags |= HTMLPAINTER_3DSURFACE;

    pInfo->lFlags = lFlags;

    pInfo->lZOrder = HTMLPAINT_ZORDER_NONE;     // assume the worst

    switch (_lRenderInfo & (BEHAVIORRENDERINFO_ALLLAYERS))
    {
    case 6:                                     // VML - they used an ancient IDL by mistake
    case BEHAVIORRENDERINFO_BEFORECONTENT:      // this is what VML meant to say
        pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_FLOW;
        break;

    case BEHAVIORRENDERINFO_AFTERCONTENT:       // HTML + TIME media behavior
        pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_FLOW;
        break;

    case BEHAVIORRENDERINFO_AFTERBACKGROUND:    // Access grid dots
        pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_CONTENT;
        // fall through...

    case BEHAVIORRENDERINFO_BEFOREBACKGROUND:
        if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) == BEHAVIORRENDERINFO_DISABLEBACKGROUND)
            pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_BACKGROUND;
        break;

    case BEHAVIORRENDERINFO_AFTERFOREGROUND:
    case BEHAVIORRENDERINFO_ABOVECONTENT:
        pInfo->lZOrder = HTMLPAINT_ZORDER_ABOVE_CONTENT;

    case 0:
        if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) == BEHAVIORRENDERINFO_DISABLEALLLAYERS)
            pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_ALL;
        break;

    default:
        break;
    }

    if ((_lRenderInfo & BEHAVIORRENDERINFO_DISABLEALLLAYERS) ==
                            (BEHAVIORRENDERINFO_DISABLENEGATIVEZ |
                             BEHAVIORRENDERINFO_DISABLECONTENT   |
                             BEHAVIORRENDERINFO_DISABLEPOSITIVEZ)   &&
        pInfo->lZOrder != HTMLPAINT_ZORDER_NONE)   // i.e. the enabled layers are something we recognized already
    {
        pInfo->lZOrder = HTMLPAINT_ZORDER_REPLACE_CONTENT;
    }

    AssertSz((pInfo->lZOrder != HTMLPAINT_ZORDER_NONE) || (0 == (_lRenderInfo & BEHAVIORRENDERINFO_ALLLAYERS)),
            "5.0-style rendering behavior has layer flags that don't map to 5.5-style");

    pInfo->iidDrawObject = g_Zero.iid;

    pInfo->rcExpand = g_Zero.rc;

Cleanup:
    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPaintAdapter::HitTestPoint  per IHTMLPainter
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPaintAdapter::HitTestPoint(POINT pt, BOOL* pfHit, LONG *plPartID)
{
    Assert(_pPeerHolder && _pPeerHolder->_pRenderBag);
    HRESULT     hr;

    Assert (0 != (BEHAVIORRENDERINFO_HITTESTING & _lRenderInfo));

    *pfHit = FALSE;
    *plPartID = 0;

    hr = THR(_pPeerRender->HitTestPoint(&pt, NULL, pfHit));

    RRETURN (hr);
}


void
CPeerHolder::CPeerHolderIterator::Start(CPeerHolder * pPH)
{
    CPeerHolder * pPHWalk = pPH;
    HRESULT hr = S_OK;

    Reset();

    while( pPHWalk )
    {
        hr = THR( _aryPeerHolders.Append(pPHWalk) );
        if( hr )
            goto Cleanup;

        pPHWalk->SubAddRef();
        pPHWalk = pPHWalk->_pPeerHolderNext;
    }

Cleanup:
    // Need to set up _nCurr before possibly resetting.
    _nCurr = _aryPeerHolders.Size() ? 0 : -1;
    if( hr )
    {
        Reset();
    }
}


void
CPeerHolder::CPeerHolderIterator::Step()
{
    Assert (!IsEnd());
    
    // SubRelease the current guy, now that we're done with him.
    _aryPeerHolders[_nCurr++]->SubRelease();

    // Make sure that we don't hand out someone who's been detached
    while( _nCurr < _aryPeerHolders.Size() && !_aryPeerHolders[_nCurr]->_pElement )
    {
        _aryPeerHolders[_nCurr++]->SubRelease();
    }

    // If there was nothing left, we're done.
    if( _nCurr >= _aryPeerHolders.Size() )
        _nCurr = -1;
}


void
CPeerHolder::CPeerHolderIterator::Reset()
{
    if( _nCurr != -1 )
    {
        Assert( _aryPeerHolders.Size() > 0 );
        // Release everyone we haven't hit yet.
        while( _nCurr < _aryPeerHolders.Size() )
        {
            _aryPeerHolders[_nCurr++]->SubRelease();
        }
        _nCurr = -1;
    }

    _aryPeerHolders.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peermgr.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////////////////////////////

MtDefine(CPeerMgr, Elements, "CPeerMgr")

DeclareTag(tagPeerMgrSuspendResumeDownload, "Peer", "trace CPeerMgr::[Suspend|Resume]Download")

//////////////////////////////////////////////////////////////////////////////
//
// CPeerMgr methods
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr constructor
//
//----------------------------------------------------------------------------

CPeerMgr::CPeerMgr(CElement * pElement)
{
    Assert (!_cPeerDownloads);
    _readyState = READYSTATE_COMPLETE;
    _pElement = pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr destructor
//
//----------------------------------------------------------------------------

CPeerMgr::~CPeerMgr()
{
    DelDownloadProgress();
    ResumeDownload();

    if (_pDefaults)
        _pDefaults->PrivateRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::OnExitTree, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::OnExitTree()
{
    DelDownloadProgress();
    ResumeDownload();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsurePeerMgr, static helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::EnsurePeerMgr(CElement * pElement, CPeerMgr ** ppPeerMgr)
{
    HRESULT            hr = S_OK;

    (*ppPeerMgr) = pElement->GetPeerMgr();

    if (*ppPeerMgr)     // if we already have peer mgr
        goto Cleanup;   // done

    // create it

    (*ppPeerMgr) = new CPeerMgr(pElement);
    if (!(*ppPeerMgr))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElement->SetPeerMgr(*ppPeerMgr);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsureDeletePeerMgr, static helper
//
//  Synopsis:   if no one needs the PeerMgr, this method deletes it and removes ptr
//              to it from the element
//
//----------------------------------------------------------------------------

void
CPeerMgr::EnsureDeletePeerMgr(CElement * pElement, BOOL fForce)
{
    CPeerMgr *  pPeerMgr = pElement->GetPeerMgr();

    if (!pPeerMgr)
        return;

    if (!fForce && !pPeerMgr->CanDelete())
        return;

    delete pElement->DelPeerMgr();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::UpdateReadyState, static helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::UpdateReadyState(CElement * pElement, READYSTATE readyStateNew)
{
    HRESULT         hr;
    CPeerMgr *      pPeerMgr;
    CPeerHolder *   pPeerHolder = pElement->GetPeerHolder();
    READYSTATE      readyState = pPeerHolder ? pPeerHolder->GetReadyStateMulti() : READYSTATE_COMPLETE;

    if (READYSTATE_UNINITIALIZED != readyStateNew)
    {
        readyState = min (readyState, readyStateNew);
    }

    if (readyState < READYSTATE_COMPLETE)
    {
        hr = THR(CPeerMgr::EnsurePeerMgr(pElement, &pPeerMgr));
        if (hr)
            goto Cleanup;

        pPeerMgr->UpdateReadyState(readyState);
    }
    else
    {
        Assert (readyState == READYSTATE_COMPLETE);

        pPeerMgr = pElement->GetPeerMgr();

        if (pPeerMgr)
        {
            pPeerMgr->UpdateReadyState(READYSTATE_UNINITIALIZED);

            CPeerMgr::EnsureDeletePeerMgr(pElement);
        }
    }

Cleanup:
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::UpdateReadyState
//
//----------------------------------------------------------------------------

void
CPeerMgr::UpdateReadyState(READYSTATE readyStateNew)
{
    CPeerHolder *   pPeerHolder = _pElement->GetPeerHolder();
    READYSTATE      readyStatePrev;
    CPeerMgr::CLock Lock(this);

    readyStatePrev = _readyState;

    if (READYSTATE_UNINITIALIZED == readyStateNew)
        readyStateNew = pPeerHolder ? pPeerHolder->GetReadyStateMulti() : READYSTATE_COMPLETE;

    _readyState = min (_cPeerDownloads ? READYSTATE_LOADING : READYSTATE_COMPLETE, readyStateNew);

    if (readyStatePrev == READYSTATE_COMPLETE && _readyState <  READYSTATE_COMPLETE)
    {
        AddDownloadProgress();
    }

    if ( readyStatePrev != _readyState )
    {
        _pElement->OnReadyStateChange();
    }

    if (readyStatePrev <  READYSTATE_COMPLETE && _readyState == READYSTATE_COMPLETE)
    {
        DelDownloadProgress();
    }

    if (!pPeerHolder ||
         pPeerHolder->GetIdentityReadyState() == READYSTATE_COMPLETE)
    {
        // ensure that script execution is unblocked if we blocked it before while waiting for the identity peer
        ResumeDownload();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::AddDownloadProgress, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::AddDownloadProgress()
{
    CMarkup *   pMarkup = _pElement->GetMarkup();

    if (pMarkup)
    {
        IProgSink * pProgSink = pMarkup->GetProgSink();

        Assert (0 == _dwDownloadProgressCookie);

        if (pProgSink)
        {
            pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &_dwDownloadProgressCookie);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::DelDownloadProgress, helper
//
//----------------------------------------------------------------------------

void
CPeerMgr::DelDownloadProgress()
{
    DWORD dwDownloadProgressCookie;

    if (0 != _dwDownloadProgressCookie)
    {
        // element should be in markup if _dwDownloadProgressCookie is set;
        // if element leaves markup before progress is released, OnExitTree should release the progress
        Assert (_pElement->GetMarkup());

        // progsink on markup should be available because we did AddProgress on it
        Assert (_pElement->GetMarkup()->GetProgSink());

        dwDownloadProgressCookie = _dwDownloadProgressCookie;
        _dwDownloadProgressCookie = 0;

        _pElement->GetMarkup()->GetProgSink()->DelProgress (dwDownloadProgressCookie);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::SuspendDownload
//
//----------------------------------------------------------------------------

void
CPeerMgr::SuspendDownload()
{

    Assert (!_fDownloadSuspended);

    TraceTag((tagPeerMgrSuspendResumeDownload,
        "CPeerMgr::SuspendDownload for element <%ls id = %ls SN = %ld>",
        _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

    _fDownloadSuspended = TRUE;

    Assert (_pElement->IsInMarkup());

    _pElement->GetMarkup()->SuspendDownload();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::ResumeDownload
//
//----------------------------------------------------------------------------

void
CPeerMgr::ResumeDownload()
{
    if (_fDownloadSuspended)
    {
        TraceTag((tagPeerMgrSuspendResumeDownload,
            "CPeerMgr::ResumeDownload for element <%ls id = %ls SN = %ld>",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));

        _fDownloadSuspended = FALSE;

        Assert (_pElement->IsInMarkup());

        _pElement->GetMarkup()->ResumeDownload();

    }
#if DBG == 1
    else
    {
        TraceTag((tagPeerMgrSuspendResumeDownload,
            "CPeerMgr::ResumeDownload for element <%ls id = %ls SN = %ld> - not blocked",
            _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->SN()));
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::EnsureDefaults
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::EnsureDefaults(CDefaults **ppDefaults)
{
    HRESULT     hr = S_OK;

    Assert (ppDefaults);

    if (_pDefaults)
        goto Cleanup;

    _pDefaults = new CDefaults(_pElement);
    if (!_pDefaults)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    *ppDefaults = _pDefaults;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerMgr::OnDefaultsPassivate, static
//
//----------------------------------------------------------------------------

HRESULT
CPeerMgr::OnDefaultsPassivate(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CPeerMgr *  pPeerMgr = pElement->GetPeerMgr();

    if (pPeerMgr)
    {
        pPeerMgr->_pElement = NULL;
        EnsureDeletePeerMgr(pElement);
    }

    RRETURN (hr);
}

//
// CPeerMgr::CLock
//

CPeerMgr::CLock::CLock( CPeerMgr * pPeerMgr )
{
    Assert( pPeerMgr );

    _pPeerMgr = pPeerMgr;
    if( !pPeerMgr->_fPeerMgrLock )
    {
        _fPrimaryLock = TRUE;
        pPeerMgr->_fPeerMgrLock = TRUE;
    }
}

CPeerMgr::CLock::~CLock()
{
    if( _fPrimaryLock )
    {
        _pPeerMgr->_fPeerMgrLock = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peerfact.cxx ===
//------------------------------------------------------------------------
//
//  File:       peerfact.cxx
//
//  Contents:   peer factories
//
//  Classes:    CPeerFactoryUrl, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_SCRPTLET_H_
#define X_SCRPTLET_H_
#include "scrptlet.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// (doc) implementation details that are not obvious
//
///////////////////////////////////////////////////////////////////////////

/*

Typical cases how CPeerFactoryUrls may be created.

  1.    <span style = "behavior:url(http://url)" >

        When css is applied to the span, CDoc::AttachPeerCss does not find matching 
        CPeerFactoryUrl in the list, and creates CPeerFactoryUrl for the url

  2.    <span style = "behavior:url(#default#foo)" >

        When css is applied to the span, CDoc::AttachPeerCss does not find matching 
        "#default" or "#default#foo" in the list, and creates CPeerFactoryUrl "#default"; then
        it immediately clones it into "#default#foo" and inserts it before "#default".

  3.    <object id = bar ... >...</object>

        <span id = span1 style = "behavior:url(#bar#foo)" >
        <span id = span2 style = "behavior:url(#bar#zoo)" >

        When css is applied to the span1, CDoc::AttachPeerCss does not find matching 
        "#bar#foo" or "#bar" in the list, and creates CPeerFactoryUrl "#bar"; then 
        it immediately clones it into "#bar#foo" and inserts it before "#bar".

        When css is applied to the span2, CDoc::AttachPeerCss finds matching "#bar" and
        clones it into "#bar#zoo".

  4.    (olesite #bar is missing)
        <span id = span1 style = "behavior:url(#bar#foo)" >
        <span id = span2 style = "behavior:url(#bar#foo)" >

        When css is applied to span1, we can't find matching "#bar" or "#bar#foo". We then
        search the whole page trying to find olesite "#bar", and we fail. We then create CPeerFactoryUrl "#bar"
        with DOWNLOANLOADSTATE_DONE and TYPE_NULL. The factory will be failing creating any behaviors:
        it's whole purpose is to avoid any additional searches of the page for olesite "#bar". CPeerFactoryUrl
        "#bar" is then immediately cloned into CPeerFactoryUrl "#bar#foo", that is also going to be failing
        creating behaviors.

        When css is applied to span2, we find CPeerFactoryUrl "#bar#foo", and reuse it.


*/

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerFactoryUrl,           CDoc,   "CPeerFactoryUrl")
MtDefine(CPeerFactoryBinaryOnstack,   CDoc,   "CPeerFactoryBinaryOnstack")
MtDefine(CPeerFactoryDefault,       CDoc,   "CPeerFactoryDefault")

MtDefine(CPeerFactoryUrl_aryDeferred,   CPeerFactoryUrl, "CPeerFactoryUrl::_aryDeferred")
MtDefine(CPeerFactoryUrl_aryETN,        CPeerFactoryUrl, "CPeerFactoryUrl::_aryETN")

// SubobjectThunk
HRESULT (STDMETHODCALLTYPE  CVoid::*const CPeerFactoryUrl::s_apfnSubobjectThunk[])(void) =
{
#ifdef UNIX //IEUNIX: This first item is null on Unix Thunk format
    TEAROFF_METHOD_NULL
#endif
    TEAROFF_METHOD(CPeerFactoryUrl,  SubobjectThunkQueryInterface, subobjectthunkqueryinterface, (REFIID, void **))
    TEAROFF_METHOD_(CPeerFactoryUrl, SubobjectThunkAddRef,         subobjectthunkaddref,         ULONG, ())
    TEAROFF_METHOD_(CPeerFactoryUrl, SubobjectThunkSubRelease,     subobjectthunkrelease,        ULONG, ())
};
HRESULT CreateNamespaceHelper( IUnknown * pBehFactory, IElementNamespace * pNamespace, TCHAR * pchImplementation, BOOL fNeedSysAlloc );

///////////////////////////////////////////////////////////////////////////
//
// misc helpers
//
///////////////////////////////////////////////////////////////////////////

LPTSTR
GetPeerNameFromUrl (LPTSTR pch)
{
    if (!pch || !pch[0])
        return NULL;

    if (_T('#') == pch[0])
        pch++;

    pch= StrChr(pch, _T('#'));
    if (pch)
    {
        pch++;
    }

    return pch;
}

//+-------------------------------------------------------------------
//
//  Helper:     FindOleSite
//
//--------------------------------------------------------------------

HRESULT
FindOleSite(LPTSTR pchName, CMarkup * pMarkup, COleSite ** ppOleSite)
{
    HRESULT                 hr;
    CElementAryCacheItem    cacheItem;
    CBase *                 pBase;
    int                     i, c;

    Assert (ppOleSite);

    *ppOleSite = NULL;

    // There is a chance that the markup pointer is NULL. In that case just
    // return an error.
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pMarkup->CollectionCache()->BuildNamedArray(
        CMarkup::ELEMENT_COLLECTION,
        pchName,
        FALSE,              // fTagName
        &cacheItem,
        0,                  // iStartFrom
        FALSE));            // fCaseSensitive
    if (hr)
        goto Cleanup;

    hr = E_FAIL;
    for (i = 0, c = cacheItem.Length(); i < c; i++)
    {
        pBase = (CBase*)(cacheItem.GetAt(i));
        if (pBase->BaseDesc()->_dwFlags & CElement::ELEMENTDESC_OLESITE)
        {
            hr = S_OK;
            *ppOleSite = DYNCAST(COleSite, pBase);
            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     QuerySafePeerFactory
//
//-------------------------------------------------------------------------

HRESULT
QuerySafePeerFactory(COleSite * pOleSite, IElementBehaviorFactory ** ppPeerFactory)
{
    HRESULT                     hr;

    Assert (ppPeerFactory);

    hr = THR_NOTRACE (pOleSite->QueryControlInterface(IID_IElementBehaviorFactory, (void**)ppPeerFactory));
    if (S_OK == hr && (*ppPeerFactory))
    {
        if (!pOleSite->IsSafeToScript() ||                             // do not allow unsafe activex controls
            !pOleSite->IsSafeToInitialize(IID_IPersistPropertyBag2))   // to workaround safety settings by
        {                                                              // exposing scriptable or loadable peers
            ClearInterface(ppPeerFactory);
            hr = E_ACCESSDENIED;
        }
    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Helper:     IsDefaultUrl
//
//--------------------------------------------------------------------

BOOL
IsDefaultUrl(LPTSTR pchUrl, LPTSTR * ppchName = NULL)
{
    BOOL    fDefault = (0 == StrCmpNIC(_T("#default"), pchUrl, 8) &&
                        (0 == pchUrl[8] || _T('#') == pchUrl[8]));

    if (fDefault && ppchName)
    {
        *ppchName = pchUrl + 8;         // advance past "#default"

        if (_T('#') == (*ppchName)[0])
        {
            (*ppchName)++;              // advance past second "#"
        }
        else
        {
            Assert (0 == (*ppchName)[0]);
            (*ppchName) = NULL;
        }
    }

    return fDefault;
}

//+-------------------------------------------------------------------
//
//  Helper:     FindPeer
//
//--------------------------------------------------------------------

HRESULT
FindPeer(
    IElementBehaviorFactory *   pFactory,
    const TCHAR *               pchName,
    const TCHAR *               pchUrl,
    IElementBehaviorSite *      pSite,
    IElementBehavior**          ppPeer)
{
    HRESULT     hr;
    BSTR        bstrName = NULL;
    BSTR        bstrUrl  = NULL;

    hr = THR(FormsAllocString(pchName, &bstrName));
    if (hr)
        goto Cleanup;

    hr = THR(FormsAllocString(pchUrl, &bstrUrl));
    if (hr)
        goto Cleanup;

    hr = THR(pFactory->FindBehavior(bstrName, bstrUrl, pSite, ppPeer));

Cleanup:
    FormsFreeString(bstrName);
    FormsFreeString(bstrUrl);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactory
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactory::AttachPeer
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactory::AttachPeer (CPeerHolder * pPeerHolder)
{
    HRESULT     hr;

    hr = THR_NOTRACE(pPeerHolder->Create(this));

    RRETURN (hr);
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactory::GetElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT 
CPeerFactory::GetElementNamespaceFactoryCallback( IElementNamespaceFactoryCallback ** ppNSFactory )
{
    if (!ppNSFactory)
        return E_POINTER;

    *ppNSFactory = NULL;

    return E_NOINTERFACE;
};

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryUrl
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CPeerFactoryUrl
//
//  Synopsis:   constructor
//
//-------------------------------------------------------------------------

CPeerFactoryUrl::CPeerFactoryUrl(CMarkup * pHostMarkup)
{
    _pHostMarkup = pHostMarkup;
    _pHostMarkup->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::~CPeerFactoryUrl
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CPeerFactoryUrl::~CPeerFactoryUrl()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Passivate
//
//-------------------------------------------------------------------------

void
CPeerFactoryUrl::Passivate()
{
    StopBinding();

    ClearInterface (&_pFactory);
    ClearInterface (&_pMoniker);

    if (_pOleSite)
    {
        _pOleSite->PrivateRelease();
        _pOleSite = NULL;
    }

    _aryDeferred.ReleaseAll();

    _pHostMarkup->SubRelease();
    _pHostMarkup = NULL;

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::QueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS2(this, IUnknown, IWindowForBindingUI)
    QI_INHERITS(this, IWindowForBindingUI)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::QueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = E_NOINTERFACE;

    if (IsEqualGUID(rguidService, IID_IMoniker) && _pMoniker)
    {
        hr = THR(_pMoniker->QueryInterface(riid, ppvService));
    }
    else if (IsEqualGUID(rguidService, CLSID_HTMLDocument))
    {
        (*ppvService) = Doc();
        hr = S_OK;
    }
    else
    {
        hr = THR_NOTRACE(super::QueryService(rguidService, riid, ppvService));
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Create
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Create(LPTSTR pchUrl, CMarkup * pHostMarkup, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT             hr;

    Assert (pchUrl && ppFactory);

    (*ppFactory) = new CPeerFactoryUrl(pHostMarkup);
    if (!(*ppFactory))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_T('#') != pchUrl[0] || IsDefaultUrl(pchUrl))       
    {
        //
        // if "http://", "file://", etc., or "#default" or "#default#foo"
        //

        hr = THR((*ppFactory)->Init(pchUrl));           // this will launch download if necessary
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // if local page reference
        //

        // assert that it is "#foo" but not "#foo#bar"
        Assert (_T('#') == pchUrl[0] && NULL == StrChr(pchUrl + 1, _T('#')));

        COleSite *          pOleSite;

        hr = THR(FindOleSite(pchUrl + 1, pMarkup, &pOleSite));
        if (hr)
            goto Cleanup;

        hr = THR((*ppFactory)->Init(pchUrl, pOleSite));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {   // we get here when #foo is not found on the page
        (*ppFactory)->Release();
        (*ppFactory) = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Init(LPTSTR pchUrl)
{
    HRESULT     hr;
    LPTSTR      pchName;

    Assert (pchUrl);

    hr = THR(_cstrUrl.Set(pchUrl));
    if (hr)
        goto Cleanup;

    if (IsHostOverrideBehaviorFactory())
    {
        _type = TYPE_NULL;
        _downloadStatus = DOWNLOADSTATUS_DONE;
        goto Cleanup; // done
    }

    if (_T('#') != pchUrl[0])
    {
        _type = TYPE_CLASSFACTORY;
        _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

        hr = THR(LaunchUrlDownload(_cstrUrl));
    }
    else
    {
        if (IsDefaultUrl(pchUrl, &pchName))
        {
            TCHAR   achUrlDownload[pdlUrlLen];

            hr = THR(Doc()->FindDefaultBehaviorFactory(
                pchName,
                pchUrl,
                (IElementBehaviorFactory**)&_pFactory,
                achUrlDownload, ARRAY_SIZE(achUrlDownload)));
            if (hr)
                goto Cleanup;

            if (_pFactory)
            {
                _type = TYPE_PEERFACTORY;
                _downloadStatus = DOWNLOADSTATUS_DONE;
            }
            else
            {
                _type = TYPE_CLASSFACTORY;
                _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

                hr = THR(LaunchUrlDownload(achUrlDownload));
            }
        }
        else
        {
            _type = TYPE_NULL;
            _downloadStatus = DOWNLOADSTATUS_DONE;
        }
    }

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Init(LPTSTR pchUrl, COleSite * pOleSite)
{
    HRESULT     hr;

    Assert (pchUrl && _T('#') == pchUrl[0]);

    hr = THR(_cstrUrl.Set(pchUrl));
    if (hr)
        goto Cleanup;

    _type = TYPE_PEERFACTORY;
    _downloadStatus = DOWNLOADSTATUS_DONE;

    // NOTE that it is valid for pOleSite to be null. In this case this CPeerFactoryUrl only serves as a bit
    // of cached information to avoid search for the olesite again

    _pOleSite = pOleSite;

    if (!_pOleSite)
        goto Cleanup;

    _pOleSite->AddRef();                         // balanced in passivate
    _pOleSite->_fElementBehaviorFactory = TRUE;  // without this we can't print EB's

    if (READYSTATE_LOADED <= _pOleSite->_lReadyState)
    {
        hr = THR(OnOleObjectAvailable());
    }
    else
    {
        hr = THR(_oleReadyStateSink.SinkReadyState()); // causes OnStartBinding, OnOleObjectAvailable, OnStopBinding
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::Clone
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::Clone(LPTSTR pchUrl, CPeerFactoryUrl ** ppFactory)
{
    HRESULT     hr;

    Assert (
        pchUrl && _T('#') == pchUrl[0] &&
        TYPE_PEERFACTORY == _type &&
        0 == StrCmpNIC(_cstrUrl, pchUrl, _cstrUrl.Length()));

    *ppFactory = new CPeerFactoryUrl(_pHostMarkup);
    if (!(*ppFactory))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_pOleSite)
    {
        hr = THR((*ppFactory)->Init(pchUrl, _pOleSite));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR((*ppFactory)->Init(pchUrl));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if( hr && *ppFactory )
    {
        (*ppFactory)->Release();
        *ppFactory = NULL;
    }
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::LaunchUrlDownload
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::LaunchUrlDownload(LPTSTR pchUrl)
{
    HRESULT                 hr;
    IMoniker *              pMk = NULL;
    IUnknown *              pUnk = NULL;
    IBindCtx *              pBindCtx = NULL;
    IBindStatusCallback *   pBSC = NULL;

    hr = THR(SubobjectThunkQueryInterface(IID_IBindStatusCallback, (void**)&pBSC));
    if (hr)
        goto Cleanup;

    hr = THR(CreateAsyncBindCtx(0, pBSC, NULL, &pBindCtx));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, pchUrl, &pMk));
    if (hr)
        goto Cleanup;

    _pMoniker = pMk;        // this has to be done before BindToObject, so that if OnObjectAvailable
    _pMoniker->AddRef();    // happens synchronously _pMoniker is available

    hr = THR(pMk->BindToObject(pBindCtx, NULL, IID_IUnknown, (void**)&pUnk));
    if (S_ASYNCHRONOUS == hr)
    {
        hr = S_OK;
    }
    else if (S_OK == hr && pUnk)
    {
        pUnk->Release();
    }

Cleanup:

    ReleaseInterface (pMk);
    ReleaseInterface (pBindCtx);
    ReleaseInterface (pBSC);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachPeer, virtual
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachPeer (CPeerHolder * pPeerHolder)
{
    HRESULT     hr;

    hr = THR(AttachPeer(pPeerHolder, /* fAfterDownload = */FALSE));

    RRETURN (hr);
};

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachPeer
//
//  Synopsis:   either creates and attaches peer, or defers  it until download
//              complete
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachPeer (CPeerHolder * pPeerHolder, BOOL fAfterDownload)
{
    HRESULT     hr = S_OK;

    // this should be set up before creation of peer, and before even download is completed, so that we
    // don't attach same behavior twice
    pPeerHolder->_pPeerFactoryUrl = this;    

    switch (_downloadStatus)
    {
    case DOWNLOADSTATUS_NOTSTARTED:
        Assert (0 && "AttachPeer called on CPeerFactoryUrl before Init");
        break;

    case DOWNLOADSTATUS_INPROGRESS:

        //
        // download in progress - defer attaching peer until download completed
        //

        pPeerHolder->_pElement->IncPeerDownloads();
        pPeerHolder->PrivateAddRef();   // so it won't go away before we attach peer to it
                                        // balanced in DOWNLOADSTATUS_DONE when fAfterDownload set

        hr = THR(_aryDeferred.Append (pPeerHolder));
        if (hr)
            goto Cleanup;

        break;

    case DOWNLOADSTATUS_DONE:

        //
        // download ready - attach right now
        //

        if (TYPE_NULL != _type)
        {
            Assert (!pPeerHolder->_pPeer);

            IGNORE_HR(pPeerHolder->Create(this));
        }

        if (fAfterDownload)
        {
            if( !pPeerHolder->_pElement->IsPassivated() )
            {
                pPeerHolder->_pElement->DecPeerDownloads();
            }
            pPeerHolder->PrivateRelease();
        }

        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::AttachAllDeferred
//
//  Synopsis:   attaches the peer to all elements put on hold before
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::AttachAllDeferred()
{
    int             c;
    CPeerHolder **  ppPeerHolder;

    Assert (DOWNLOADSTATUS_DONE == _downloadStatus);

    for (c = _aryDeferred.Size(), ppPeerHolder = _aryDeferred; 
         c; 
         c--, ppPeerHolder++)
    {
        IGNORE_HR (AttachPeer(*ppPeerHolder, /* fAfterDownload = */ TRUE));
    }

    _aryDeferred.DeleteAll();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::FindBehavior, per IElementBehaviorFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT         hr = E_FAIL;
    const TCHAR *   pchPeerName = GetPeerNameFromUrl(_cstrUrl);

    if( !pchPeerName && pPeerHolder->IsIdentityPeer() )
    {
        pchPeerName = pPeerHolder->_pElement->TagName();
    }

    if (IsHostOverrideBehaviorFactory())
    {
        hr = THR_NOTRACE(Doc()->FindHostBehavior(pchPeerName, _cstrUrl, pSite, ppPeer));
        goto Cleanup;   // done
    }
    
    switch (_type)
    {
    case TYPE_CLASSFACTORYEX:
        if (_pFactory)
        {
            hr = THR(((IClassFactoryEx*)_pFactory)->CreateInstanceWithContext(
                pSite, NULL, IID_IElementBehavior, (void **)ppPeer));
        }
        break;

    case TYPE_CLASSFACTORY:
        if (_pFactory)
        {
            hr = THR(((IClassFactory*)_pFactory)->CreateInstance(NULL, IID_IElementBehavior, (void **)ppPeer));
        }
        break;

    case TYPE_PEERFACTORY:
        if (_pFactory)
        {
            hr = THR(FindPeer((IElementBehaviorFactory *)_pFactory, pchPeerName, _cstrUrl, pSite, ppPeer));
        }
        break;

    default:
        Assert (0 && "wrong _type");
        break;
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SubobjectThunkQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::SubobjectThunkQueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT     hr;
    IUnknown *  punk;

    hr = THR_NOTRACE(QueryInterface(riid, (void**)&punk));
    if (S_OK == hr)
    {
        hr = THR(CreateTearOffThunk(
                punk,
                *(void **)punk,
                NULL,
                ppv,
                this,
                (void **)s_apfnSubobjectThunk,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                NULL));

        punk->Release();

        if (S_OK == hr)
        {
            ((IUnknown*)*ppv)->AddRef();
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetBindInfo, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    HRESULT hr;

    hr = THR(super::GetBindInfo(pdwBindf, pbindinfo));

    if (S_OK == hr)
    {
        *pdwBindf |= BINDF_GETCLASSOBJECT;
    }

    // If we're doing a synchronous load, we can't bind asynchronously.  Duh.
    if( _pHostMarkup->Doc()->_fSyncParsing )
    {
        *pdwBindf &= ~BINDF_ASYNCHRONOUS;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStartBinding, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStartBinding()
{
    IProgSink * pProgSink = CMarkup::GetProgSinkHelper(_pHostMarkup);

    _downloadStatus = DOWNLOADSTATUS_INPROGRESS;

    if (pProgSink)
    {
        IGNORE_HR(pProgSink->AddProgress (PROGSINK_CLASS_CONTROL, &_dwBindingProgCookie));
        Assert (_dwBindingProgCookie);
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStopBinding, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStopBinding()
{
    _downloadStatus = DOWNLOADSTATUS_DONE;

    // note that even if _pFactory is NULL, we still want to do AttachAllDeferred so to balance Inc/DecPeersPending
    IGNORE_HR(AttachAllDeferred());

    IGNORE_HR(SyncETN());

    if (_dwBindingProgCookie)
    {
        CMarkup::GetProgSinkHelper(_pHostMarkup)->DelProgress (_dwBindingProgCookie);
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStartBinding, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStartBinding(DWORD grfBSCOption, IBinding * pBinding)
{
    IGNORE_HR(super::OnStartBinding(grfBSCOption, pBinding));

    IGNORE_HR(OnStartBinding());
    
    _pBinding = pBinding;
    _pBinding->AddRef();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnStopBinding, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnStopBinding(HRESULT hrErr, LPCWSTR szErr)
{
    IGNORE_HR(super::OnStopBinding(hrErr, szErr));

    ClearInterface(&_pBinding);

    IGNORE_HR(OnStopBinding());

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnProgress, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode, LPCWSTR pszText)
{
    IGNORE_HR(super::OnProgress(ulPos, ulMax, ulCode, pszText));

    if (    (ulCode == BINDSTATUS_REDIRECTING)
        &&  !_pHostMarkup->AccessAllowed(pszText))
    {
        if (_pBinding)
            _pBinding->Abort();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::PersistMonikerLoad, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::PersistMonikerLoad(IUnknown * pUnk, BOOL fLoadOnce)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    IPersistMoniker *   pPersistMoniker;

    if (!_pMoniker || !pUnk)
        goto Cleanup;

    hr2 = THR(pUnk->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMoniker));
    if (S_OK == hr2)
    {
        IGNORE_HR(pPersistMoniker->Load(FALSE, _pMoniker, NULL, NULL));

        if (fLoadOnce)
        {
            ClearInterface(&_pMoniker);
        }

        ReleaseInterface (pPersistMoniker);
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnObjectAvailable, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnObjectAvailable(REFIID riid, IUnknown * pUnk)
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    IUnknown*   pUnk2;

    //
    // super
    //

    IGNORE_HR(super::OnObjectAvailable(riid, pUnk));

    if (!pUnk)
        goto Cleanup; // done

    pUnk->AddRef();

    //
    // do something weirdly special for HTCs: one level of indirection.
    // this is only necessary to have mshtmpad pick local mshtml.dll for HTCs -
    // as dictated by mechanics of wiring between mshtmpad.exe doing CoRegisterClassObject
    // and mshtml.dll DllEnumClassObjects and DllGetClassObject
    //

    {
        void *          pv;
        CClassFactory * pCF;

        hr2 = THR_NOTRACE(pUnk->QueryInterface(CLSID_CHtmlComponentConstructorFactory, &pv));
        if (S_OK == hr2)    // if recognized HTC constructor factory
        {
            hr = THR(pUnk->QueryInterface(IID_IClassFactory, (void**)&pCF));
            if (hr)
                goto Cleanup;

            pUnk->Release();
                
            // the indirection: get HTC constructor from the factory
            hr = THR(pCF->CreateInstance(NULL, IID_IUnknown, (void**) &pUnk));

            ReleaseInterface(pCF);

            if (hr)
                goto Cleanup;

            Assert (pUnk);
        }
    }

    //
    // extract factory from the IUnknown
    //

    hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IElementBehaviorFactory, (void**)&pUnk2));
    if (S_OK == hr2 && pUnk2)
    {
        _type = TYPE_PEERFACTORY;
        _pFactory = pUnk2;
    }
    else
    {
        hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IClassFactoryEx, (void**)&pUnk2));
        if (S_OK == hr2 && pUnk2)
        {
            _type = TYPE_CLASSFACTORYEX;
            _pFactory = pUnk2;
        }
        else
        {
            hr2 = THR_NOTRACE(pUnk->QueryInterface(IID_IClassFactory, (void**)&pUnk2));
            if (S_OK == hr2 && pUnk2)
            {
                Assert (TYPE_CLASSFACTORY == _type);
                _pFactory = pUnk2;
            }
        }
    }

    //
    // finalize
    //

    IGNORE_HR(PersistMonikerLoad(_pFactory, /* fLoadOnce = */TRUE));

Cleanup:
    ReleaseInterface(pUnk);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::OnOleObjectAvailable, helper
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::OnOleObjectAvailable()
{
    HRESULT     hr;

    hr = THR(QuerySafePeerFactory(_pOleSite, (IElementBehaviorFactory**)&_pFactory));
    if (hr)
    {
        hr = S_OK;
        _type = TYPE_NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::StopBinding, helper
//
//-------------------------------------------------------------------------

void
CPeerFactoryUrl::StopBinding()
{
    if (_pBinding)
        _pBinding->Abort();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetWindow, per IWindowForBindingUI
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    HRESULT hr;

    hr = THR(Doc()->GetWindow(phwnd));

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETNHelper
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETNHelper(CExtendedTagNamespace * pNamespace)
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;
    DWORD                           dwCookie;

    if( !_pFactory )
        goto Cleanup;

    {
        CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, this);

        hr = THR_NOTRACE( CreateNamespaceHelper( _pFactory, pNamespace, pNamespace->_cstrFactoryUrl, /* fNeedSysAlloc = */ TRUE ) );
    }

    switch (hr)
    {
    case S_OK:
        break;

    case E_PENDING:

        //
        // the factory is not ready yet; sink it's readyState
        //

        hr2 = THR_NOTRACE(_pFactory->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC));
        if (hr2)
            goto Cleanup;

        hr2 = THR_NOTRACE(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
        if (hr2)
            goto Cleanup;

        IGNORE_HR(pCP->Advise(&_ETNReadyStateSink, &dwCookie));

        Assert (E_PENDING == hr);
        goto Cleanup; // done; we will get called by the sink again when readyState COMPLETE is reached

    default:
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETN
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETN(CExtendedTagNamespace * pNamespace)
{
    HRESULT         hr = S_OK;
    int             i, c;

    //
    // add the table (if passed) to the array, and bail out if nothing to do
    //

    if (pNamespace)
    {
        hr = THR(_aryETN.Append(pNamespace));
        if (hr)
            goto Cleanup;
    }

    if (0 == _aryETN.Size())
        goto Cleanup;

    //
    // still downloading the factory object?
    //

    if (DOWNLOADSTATUS_INPROGRESS == _downloadStatus)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    Assert (DOWNLOADSTATUS_DONE == _downloadStatus);

    //
    // query the information from the factory object and broadcast it to the listening tables
    //

    for (i = 0, c = _aryETN.Size(); i < c; i++)
    {
        pNamespace = _aryETN[i];
        if (pNamespace)
        {
            // will return S_OK or E_PENDING (E_PENDING is typical for HTCs when called the first time)
            hr = THR_NOTRACE(SyncETNHelper(pNamespace));
            if (E_PENDING == hr)  // (if error other then E_PENDING we still want to complete and do Sync2)
                goto Cleanup;

            _aryETN[i] = NULL; // (possible recursive entry) // TODO (alexz) is the architecture setup right for this?

            hr = THR(pNamespace->Sync2());
            if (hr)
                goto Cleanup;
        }
    }

    _aryETN.DeleteAll();

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::SyncETNAbort
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::SyncETNAbort(CExtendedTagNamespace * pNamespace)
{
    _aryETN.DeleteByValue(pNamespace);

    RRETURN (S_OK);
}

///////////////////////////////////////////////////////////////////////////
//
// CTagDescReadyStateSink
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CETNReadyStateSink::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::CETNReadyStateSink::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IPropertyNotifySink)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::CETNReadyStateSink::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::CETNReadyStateSink::OnChanged(DISPID dispid)
{
    HRESULT         hr = S_OK;
    IDispatchEx *   pdispex = NULL;
    CInvoke         invoke;
    CVariant        varReadyState;

    switch (dispid)
    {
    case DISPID_READYSTATE:

        Assert(PFU()->_pFactory);

        hr = THR(PFU()->_pFactory->QueryInterface(IID_IDispatchEx, (void**)&pdispex));
        if (hr)
            goto Cleanup;

        hr = THR(invoke.Init(pdispex));
        if (hr)
            goto Cleanup;

        hr = THR(invoke.Invoke(DISPID_READYSTATE, DISPATCH_PROPERTYGET));
        if (hr)
            goto Cleanup;

        hr = THR(VariantChangeType(&varReadyState, invoke.Res(), 0, VT_I4));
        if (hr)
            goto Cleanup;

        if (READYSTATE_COMPLETE == (READYSTATE) V_I4(&varReadyState))
        {
            IGNORE_HR(PFU()->SyncETN());
        }

        break;
    }

Cleanup:
    ReleaseInterface(pdispex);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryUrl::COleReadyStateSink class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CPeerFactoryUrl::COleReadyStateSink::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDispatch)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::Invoke, per IDispatch
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::COleReadyStateSink::SinkReadyState()
{
    HRESULT         hr = S_OK;
    BSTR            bstrEvent = NULL;

    hr = THR(FormsAllocString(_T("onreadystatechange"), &bstrEvent));
    if (hr)
        goto Cleanup;
    
    hr = THR(PFU()->_pOleSite->attachEvent(bstrEvent, (IDispatch*)this, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(PFU()->OnStartBinding());

Cleanup:
    FormsFreeString(bstrEvent);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::COleReadyStateSink::Invoke, per IDispatch
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryUrl::COleReadyStateSink::Invoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT         hr = S_OK;
    BSTR            bstrEvent = NULL;

    Assert (PFU()->_pOleSite && DISPID_VALUE == dispid);

    if (READYSTATE_LOADED <= PFU()->_pOleSite->_lReadyState &&
        PFU()->_downloadStatus < DOWNLOADSTATUS_DONE)
    {
        hr = THR(PFU()->OnOleObjectAvailable());
        if (hr)
            goto Cleanup;
        
        hr = THR(PFU()->OnStopBinding());
        if (hr)
            goto Cleanup;

        hr = THR(FormsAllocString(_T("onreadystatechange"), &bstrEvent));
        if (hr)
            goto Cleanup;
        
        // TODO (alexz) can't do the following: this will prevent it from firing into the next sink point
        // hr = THR(PFU()->_pOleSite->detachEvent(bstrEvent, (IDispatch*)this));
    }

Cleanup:
    FormsFreeString(bstrEvent);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBuiltin class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBuiltin::Init, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBuiltin::Init(const CTagDescBuiltin * pTagDescBuiltin)
{
    HRESULT     hr = S_OK;

    _pTagDescBuiltin = pTagDescBuiltin;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBuiltin::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBuiltin::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT     hr = E_FAIL;

    Assert (_pTagDescBuiltin);

    switch (_pTagDescBuiltin->type)
    {
    case CTagDescBuiltin::TYPE_HTC:

        hr = THR(CHtmlComponent::FindBehavior(
            (HTC_BEHAVIOR_TYPE)_pTagDescBuiltin->extraInfo.dwHtcBehaviorType, pSite, ppPeer));

        break;

    case CTagDescBuiltin::TYPE_OLE:

        hr = THR(CoCreateInstance(
            _pTagDescBuiltin->extraInfo.clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            IID_IElementBehavior, (void **)ppPeer));

        break;

    default:
        Assert ("invalid BuiltinGenericTagDesc");
        hr = E_FAIL;
        break;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBinary class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary constructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinary::CPeerFactoryBinary()
{
    _pFactory = NULL;
    _ulRefs = 1;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary destructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinary::~CPeerFactoryBinary()
{
    ReleaseInterface(_pFactory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::QueryInterface (REFIID riid, LPVOID * ppv)
{
    Assert (FALSE && "Unexpected");
    RRETURN (E_UNEXPECTED);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::Init(IElementBehaviorFactory * pFactory)
{
    HRESULT hr = S_OK;

    Assert (pFactory);

    _pFactory = pFactory;
    _pFactory->AddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinary::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT             hr;
    CElement *          pElement = pPeerHolder->_pElement;
    CExtendedTagDesc *  pDesc = pElement->GetExtendedTagDesc();
    const TCHAR *       pchName;

    Assert (_pFactory);
    Assert (pDesc); // (that means the factory for now can only be used for identity behaviors)

    pchName = pDesc->TagName();

    hr = THR(FindPeer(_pFactory, pchName, /* pchUrl = */ NULL, pSite, ppPeer));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinary::GetElementNamespaceFactory, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT 
CPeerFactoryBinary::GetElementNamespaceFactoryCallback( IElementNamespaceFactoryCallback ** ppNSFactory )
{
    HRESULT hr;

    hr = THR_NOTRACE(_pFactory->QueryInterface( IID_IElementNamespaceFactoryCallback, (void**)ppNSFactory));

    RRETURN_NOTRACE( hr );
};


///////////////////////////////////////////////////////////////////////////
//
// CPeerFactoryBinaryOnstack class
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack constructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinaryOnstack::CPeerFactoryBinaryOnstack()
{
    _pFactory = NULL;
    _pPeer    = NULL;
    _pchUrl   = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack destructor
//
//-------------------------------------------------------------------------

CPeerFactoryBinaryOnstack::~CPeerFactoryBinaryOnstack()
{
    ReleaseInterface(_pPeer);
    ReleaseInterface(_pFactory);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack::Init
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinaryOnstack::Init(LPTSTR pchUrl)
{
    HRESULT hr = S_OK;
    _pchUrl  = pchUrl;
    _pchName = _pchUrl ? GetPeerNameFromUrl(_pchUrl) : NULL;
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryBinaryOnstack::FindBehavior, virtual per CPeerFactory
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryBinaryOnstack::FindBehavior(
    CPeerHolder *           pPeerHolder,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppPeer)
{
    HRESULT     hr;

    if (_pFactory)
    {
        hr = THR(FindPeer(_pFactory, _pchName, _pchUrl, pSite, ppPeer));
    }
    else if (_pPeer)
    {
        *ppPeer = _pPeer;
        (*ppPeer)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Class:       CPeerFactoryDefault
//
///////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault constructor
//
//--------------------------------------------------------------------

CPeerFactoryDefault::CPeerFactoryDefault(CDoc * pDoc)
{
    AddRef();

    _pDoc = pDoc;
    _pDoc->SubAddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault destructor
//
//--------------------------------------------------------------------

CPeerFactoryDefault::~CPeerFactoryDefault()
{
    _pDoc->SubRelease();
    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehaviorFactory*)this, IUnknown)
    QI_INHERITS(this, IElementBehaviorFactory)
    QI_INHERITS(this, IElementNamespaceFactory)
    QI_INHERITS(this, IElementNamespaceFactory2)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::FindBehavior
//
//  Synopsis:   lookup in host and iepeers.dll.
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::FindBehavior(
    BSTR                    bstrName,
    BSTR                    bstrUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT hr = E_FAIL;
    CDoc *pDoc = _pDoc;

    *ppBehavior= NULL;

    //
    // use the specific default factory if present
    //

    if (_pPeerFactory)
    {
        hr = THR_NOTRACE(_pPeerFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));
        goto Cleanup;       // done, don't try others
    }

    //
    // try the host
    //

    while(pDoc->_fPopupDoc)
    {
        pDoc = pDoc->_pPopupParentWindow->Doc();
    }

    if (pDoc->_pHostPeerFactory)
    {
        hr = THR_NOTRACE(pDoc->_pHostPeerFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));
        if (S_OK == hr)
            goto Cleanup;       // done;
    }

    //
    // lookup in iepeers.dll
    //

    hr = THR(_pDoc->EnsureIepeersFactory());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(_pDoc->_pIepeersFactory->FindBehavior(bstrName, bstrUrl, pSite, ppBehavior));

Cleanup:

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPeerFactoryDefault::Create
//
//--------------------------------------------------------------------

HRESULT
CPeerFactoryDefault::Create(IElementNamespace * pNamespace)
{
    AssertSz( FALSE, "No one outside of Trident should have been able to get here, and Trident doesn't want to" );
    RRETURN( CreateWithImplementation( pNamespace, NULL ) );
}

HRESULT
CPeerFactoryDefault::CreateWithImplementation(IElementNamespace * pNamespace, BSTR bstrImplementation)
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2;
    IElementNamespaceFactory *      pFactory = NULL;
    CDoc *                          pDoc = _pDoc;

    Assert (pNamespace);

    //
    // use the specific default factory if present
    //

    if (_pPeerFactory)
    {
        hr2 = THR_NOTRACE( CreateNamespaceHelper( _pPeerFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );
        goto Cleanup;       // done, don't try others
    }

    //
    // host
    //

    while(pDoc->_fPopupDoc)
    {
        pDoc = pDoc->_pPopupParentWindow->Doc();
    }

    if (pDoc->_pHostPeerFactory)
    {
        hr2 = THR_NOTRACE( CreateNamespaceHelper( pDoc->_pHostPeerFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );
    }

    //
    // iepeers.dll
    //

    hr = THR(_pDoc->EnsureIepeersFactory());
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE( CreateNamespaceHelper( _pDoc->_pIepeersFactory, pNamespace, bstrImplementation, /* fNeedSysAlloc = */ FALSE ) );

#ifdef V4FRAMEWORK
    //
    // external COM+ MSUI framework
    //
    {
        IExternalDocument *pExtFactory;

        pExtFactory = _pDoc->EnsureExternalFrameWork();
        if (!pExtFactory) 
            goto Cleanup;

        hr = pExtFactory->GetTags((long)pNamespace);
        if (hr)
            goto Cleanup;
    }
#endif

Cleanup:
    ReleaseInterface(pFactory);

    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CreateNamespaceHelper
//
//  Synopsis:   Helper function for getting a NamespaceFactory and
//              having it populate a namespace.
//
//  Arguments:  IUnknown * pBehFactory - Behavior Factory ptr
//              IElementNamespaceFactory * pNamespace - Namespace to populate
//              TCHAR * pchImpl - Implementation string (#default#foo)
//              BOOL fNeedSysAlloc - FALSE if pchImpl is already a BSTR
//  
//--------------------------------------------------------------------

HRESULT CreateNamespaceHelper( IUnknown * pBehFactory, IElementNamespace * pNamespace, TCHAR * pchImplementation, BOOL fNeedSysAlloc )
{
    HRESULT                     hr          = S_OK;
    HRESULT                     hr2         = E_NOINTERFACE;
    IElementNamespaceFactory  * pFactory    = NULL;
    IElementNamespaceFactory2 * pFactory2   = NULL;
    BSTR                        bstrImpl    = fNeedSysAlloc ? NULL : pchImplementation;

    Assert( pBehFactory && pNamespace );

    // First go for a Factory2, then try for a Factory
    hr2 = THR_NOTRACE( pBehFactory->QueryInterface( IID_IElementNamespaceFactory2, (void **)&pFactory2 ) );
    if( !hr2 && fNeedSysAlloc && pchImplementation )
    {
        bstrImpl = SysAllocString( pchImplementation );
        if( !bstrImpl )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if( hr2 )
    {
        // If we can't get either  factory, we're hosed.
        hr = THR_NOTRACE( pBehFactory->QueryInterface( IID_IElementNamespaceFactory, (void **)&pFactory ) );
        if( hr )
            goto Cleanup;
    }

    if( pFactory2 )
    {
        hr = THR( pFactory2->CreateWithImplementation( pNamespace, bstrImpl ) );
        goto Cleanup;
    }
    else
    {
        hr = THR( pFactory->Create( pNamespace ) );
        goto Cleanup;
    }

Cleanup:
    if( fNeedSysAlloc )
    {
        SysFreeString( bstrImpl );
    }
    ReleaseInterface( pFactory );
    ReleaseInterface( pFactory2 );
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peermarkup.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  misc
//
//////////////////////////////////////////////////////////////////////////////

MtDefine(CMarkupBehaviorContext, CMarkup, "CMarkupBehaviorContext")

DeclareTag(tagPeerCMarkupIsGenericElement, "Peer", "trace CMarkup::IsGenericElement")

//////////////////////////////////////////////////////////////////////////////
//
//  Class:      CMarkupBehaviorContext
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupBehaviorContext constructor
//
//----------------------------------------------------------------------------

CMarkupBehaviorContext::CMarkupBehaviorContext()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkupBehaviorContext destructor
//
//----------------------------------------------------------------------------

CMarkupBehaviorContext::~CMarkupBehaviorContext()
{
    int c;
    CElement ** ppElem;

    for( c = _aryPeerElems.Size(), ppElem = _aryPeerElems; c > 0; c--, ppElem++ )
    {
        (*ppElem)->SubRelease();
    }

    if (_pExtendedTagTable)
        _pExtendedTagTable->Release();

    delete _pExtendedTagTableBooster;

    if (_pXmlNamespaceTable)
        _pXmlNamespaceTable->Release();

    _cstrHistoryUserData.Free();

    ClearInterface(&_pXMLHistoryUserData);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Class:      CMarkup
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::ProcessPeerTask
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::ProcessPeerTask(PEERTASK task)
{
    HRESULT     hr = S_OK;

    switch (task)
    {
    case PEERTASK_MARKUP_RECOMPUTEPEERS_UNSTABLE:

        PrivateAddRef();

        IGNORE_HR(GetFrameOrPrimaryMarkup()->EnqueuePeerTask(this, PEERTASK_MARKUP_RECOMPUTEPEERS_STABLE));

        break;

    case PEERTASK_MARKUP_RECOMPUTEPEERS_STABLE:

        if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
        {
            IGNORE_HR(RecomputePeers());
        }

        PrivateRelease(); // the markup may passivate after this call

        break;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RecomputePeers
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::RecomputePeers()
{
    HRESULT     hr = S_OK;

    if (_pDoc->_fCssPeersPossible)
    {
        AssertSz(CPeerHolder::IsMarkupStable(this), "CMarkup::RecomputePeers appears to be called at an unsafe moment of time");

        CNotification   nf;
        nf.RecomputeBehavior(Root());
        Notify(&nf);
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureBehaviorContext
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureBehaviorContext(CMarkupBehaviorContext ** ppBehaviorContext)
{
    HRESULT                     hr = S_OK;
    CMarkupBehaviorContext *    pBehaviorContext;

    Assert (Doc()->_dwTID == GetCurrentThreadId());

    if (!HasBehaviorContext())
    {
        pBehaviorContext = new CMarkupBehaviorContext();
        if (!pBehaviorContext)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(SetBehaviorContext(pBehaviorContext));
        if (hr)
            goto Cleanup;

        if (ppBehaviorContext)
        {
            *ppBehaviorContext = pBehaviorContext;
        }
    }
    else
    {
        if (ppBehaviorContext)
        {
            *ppBehaviorContext = BehaviorContext();
        }
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::IsGenericElement
//
//----------------------------------------------------------------------------

ELEMENT_TAG
CMarkup::IsGenericElement(LPTSTR pchFullName, BOOL fAllSprinklesGeneric)
{
    ELEMENT_TAG     etag = ETAG_UNKNOWN;
    LPTSTR          pchColon;

    pchColon = StrChr (pchFullName, _T(':'));

    if (pchColon)
    {
        CStringNullTerminator   nullTerminator(pchColon);

        //
        // is it a valid sprinkle ?
        //

        etag = IsXmlSprinkle(/* pchNamespace = */pchFullName);
        if (ETAG_UNKNOWN != etag)
            goto Cleanup;
    }

    //
    // delegate to doc (host provided behaviors?, builtin behaviors?, etc)
    //

    etag = _pDoc->IsGenericElement(pchFullName, pchColon);
    if (ETAG_UNKNOWN != etag)
        goto Cleanup;

    if (pchColon)
    {
        // (NOTE: these checks should be after _pDoc->IsGenericElement)

        //
        // all sprinkles are generic elements within context of the current operation?
        //

        if (fAllSprinklesGeneric)
        {
            etag = ETAG_GENERIC;
            goto Cleanup;           // done
        }

        //
        // markup services parsing? any sprinkle goes as generic element
        //

        if (_fMarkupServicesParsing)
        {
            etag = ETAG_GENERIC;
            goto Cleanup;           // done
        }
    }

Cleanup:

    TraceTag((tagPeerCMarkupIsGenericElement,
              "CMarkup::IsGenericElement, name <%ls> recognized as %ls",
              pchFullName,
              ETAG_UNKNOWN == etag ? _T("UNKNOWN") :
                ETAG_GENERIC_BUILTIN == etag ? _T("GENERIC_BUILTIN") : _T("GENERIC")));

    return etag;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureXmlNamespaceTable
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureXmlNamespaceTable(CXmlNamespaceTable ** ppXmlNamespaceTable)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pXmlNamespaceTable)
    {
        pContext->_pXmlNamespaceTable = new CXmlNamespaceTable(_pDoc);
        if (!pContext->_pXmlNamespaceTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pContext->_pXmlNamespaceTable->Init());
        if (hr)
            goto Cleanup;
    }

    if (ppXmlNamespaceTable)
    {
        *ppXmlNamespaceTable = pContext->_pXmlNamespaceTable;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RegisterXmlNamespace
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::RegisterXmlNamespace(LPTSTR pchNamespace, LPTSTR pchUrn, XMLNAMESPACETYPE namespaceType)
{
    HRESULT                 hr;
    CXmlNamespaceTable *    pNamespaceTable;

    hr = THR(EnsureXmlNamespaceTable(&pNamespaceTable));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespaceTable->RegisterNamespace(pchNamespace, pchUrn, namespaceType));

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::IsXmlSprinkle
//
//----------------------------------------------------------------------------

ELEMENT_TAG
CMarkup::IsXmlSprinkle (LPTSTR pchNamespace)
{
    HRESULT                 hr;
    CXmlNamespaceTable *    pNamespaceTable;

    hr = THR(EnsureXmlNamespaceTable(&pNamespaceTable));
    if (hr)
        return ETAG_UNKNOWN;

    return pNamespaceTable->IsXmlSprinkle(pchNamespace);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::SaveXmlNamespaceAttrs
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::SaveXmlNamespaceAttrs (CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT                     hr = S_OK;
    CMarkupBehaviorContext *    pContext = BehaviorContext();

    if (pContext && pContext->_pExtendedTagTable)
    {
        hr = THR(pContext->_pExtendedTagTable->SaveXmlNamespaceStdPIs(pStreamWriteBuff));
    }
    else if (HtmCtx())
    {
        hr = THR(HtmCtx()->SaveXmlNamespaceStdPIs(pStreamWriteBuff));
    }
    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsurePeerFactoryUrlMap
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsurePeerFactoryUrlMap(CPeerFactoryUrlMap ** ppPeerFactoryUrlMap)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    Assert (ppPeerFactoryUrlMap);

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pPeerFactoryUrlMap)
    {
        pContext->_pPeerFactoryUrlMap = new CPeerFactoryUrlMap(this);
        if (!pContext->_pPeerFactoryUrlMap)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppPeerFactoryUrlMap = pContext->_pPeerFactoryUrlMap;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetPeerFactoryUrlMap
//
//----------------------------------------------------------------------------

CPeerFactoryUrlMap *
CMarkup::GetPeerFactoryUrlMap()
{
    if (!HasBehaviorContext())
        return NULL;

    return BehaviorContext()->_pPeerFactoryUrlMap;
}

#ifdef GETDHELPER
//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CMarkup::GetExtendedTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsure, BOOL * pfQueryHost)
{
    return CExtendedTagTable::GetExtendedTagDesc( NULL, 
                                                  this, 
                                                  Doc()->_pExtendedTagTableHost,
                                                  pchNamespace,
                                                  pchTagName,
                                                  fEnsure,
                                                  FALSE,
                                                  pfQueryHost );
}
#else
//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagDesc
//
//----------------------------------------------------------------------------

CExtendedTagDesc *
CMarkup::GetExtendedTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsure, BOOL * pfQueryHost)
{
    CExtendedTagDesc *          pDesc = NULL;

    if( pfQueryHost )
        *pfQueryHost = FALSE;

    // There was an assumption that if behaviors are going to be involved, then we 
    // would have transferred the extended tag table from the htmload to the behavior
    // context when the markup was done loading.  However, if you just want to do
    // a createElement for XML, then none of this would have happened, and we
    // will have no load on which to put a tag table.
    if( !HtmCtx() || ( !HtmCtx()->HasLoad() && !HtmCtx()->GetExtendedTagTable() ) )
    {
        CMarkupBehaviorContext * pBehaviorContext = NULL;
        CExtendedTagTable * pExtendedTagTable = NULL;

        // Ensure a Behavior Context
        if SUCCEEDED( EnsureBehaviorContext( &pBehaviorContext ) )
        {
            Assert( pBehaviorContext );

            // Ensure a tag table
            if( !pBehaviorContext->_pExtendedTagTable )
            {
                pExtendedTagTable = new CExtendedTagTable( Doc(), this, FALSE );
                if( !pExtendedTagTable )
                {
                    // If we couldn't make one, then we'll fail through to the normal path.
                    delete DelBehaviorContext();
                }
                else
                {
                    pBehaviorContext->_pExtendedTagTable = pExtendedTagTable;
                }
            }
        }
    }

    if( BehaviorContext() && BehaviorContext()->_pExtendedTagTable )
    {
        pDesc = BehaviorContext()->_pExtendedTagTable->FindTagDesc( pchNamespace, pchTagName );
    }
    else if( HtmCtx() )
    {
        pDesc = HtmCtx()->GetExtendedTagDesc( pchNamespace, pchTagName, FALSE );
    }

    if( pDesc )
        goto Cleanup;

    if( Doc()->_pExtendedTagTableHost )
    {
        pDesc = Doc()->_pExtendedTagTableHost->FindTagDesc( pchNamespace, pchTagName, pfQueryHost );
        if( pDesc )
            goto Cleanup;
    }

    if( fEnsure && ( !pfQueryHost || FALSE == *pfQueryHost ) )
    {
        if(    BehaviorContext()
            && BehaviorContext()->_pExtendedTagTable )
        {
            pDesc = BehaviorContext()->_pExtendedTagTable->EnsureTagDesc( pchNamespace, pchTagName );
        }
        else
        {
            pDesc = HtmCtx()->GetExtendedTagDesc( pchNamespace, pchTagName, TRUE );
        }
    }

Cleanup:
    return pDesc;
}
#endif // GETDHELPER

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::EnsureExtendedTagTableBooster
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureExtendedTagTableBooster(CExtendedTagTableBooster ** ppExtendedTagTableBooster)
{
    HRESULT                     hr;
    CMarkupBehaviorContext *    pContext;

    Assert (ppExtendedTagTableBooster);
    Assert (Doc()->_dwTID == GetCurrentThreadId());

    AssertSz (!IsHtcMarkup(), "Attempt to ensure ExtendedTagTableBooster for HTC markup - a serious perf speed and memory hit for HTCs.");

    hr = THR(EnsureBehaviorContext(&pContext));
    if (hr)
        goto Cleanup;

    if (!pContext->_pExtendedTagTableBooster)
    {
        pContext->_pExtendedTagTableBooster = new CExtendedTagTableBooster();
        if (!pContext->_pExtendedTagTableBooster)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppExtendedTagTableBooster = pContext->_pExtendedTagTableBooster;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::GetExtendedTagTableBooster
//
//----------------------------------------------------------------------------

CExtendedTagTableBooster *
CMarkup::GetExtendedTagTableBooster()
{
    if (!HasBehaviorContext())
        return NULL;

    return BehaviorContext()->_pExtendedTagTableBooster;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peerxtag.cxx ===
//+---------------------------------------------------------------------
//
//  File:       peerxtag.cxx
//
//  Classes:    CExtendedTagTable, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#define _cxx_
#include "peerxtag.hdl"

///////////////////////////////////////////////////////////////////////////
//
//  misc
//
///////////////////////////////////////////////////////////////////////////

#define HASHBOOST

// HASHBOOST notes. ..todo

MtDefine(CExtendedTagDesc,                      Behaviors,              "CExtendedTagDesc");
MtDefine(CExtendedTagDescBuiltin,               Behaviors,              "CExtendedTagDescBuiltin");
MtDefine(CExtendedTagNamespace,                 Behaviors,              "CExtendedTagNamespace");
MtDefine(CExtendedTagNamespaceBuiltin,          Behaviors,              "CExtendedTagNamespaceBuiltin");
MtDefine(CExtendedTagTable,                     Behaviors,              "CExtendedTagTable");
MtDefine(CExtendedTagTableBooster,              Behaviors,              "CExtendedTagTableBooster");

MtDefine(CExtendedTagNamespace_CItemsArray,     CExtendedTagNamespace,  "CExtendedTagNamespace::CItemsArray");
MtDefine(CExtendedTagTable_CItemsArray,         CExtendedTagTable,      "CExtendedTagTable::CItemsArray");

MtDefine(CHTMLNamespace,                        Behaviors,              "CHTMLNamespace")
MtDefine(CHTMLNamespaceCollection,              Behaviors,              "CHTMLNamespaceCollection")

DeclareTag(tagPeerExtendedTagNamespace,             "Peer",                   "trace CExtendedTagTable namespaces")
DeclareTag(tagPeerExtendedTagDesc,                  "Peer",                   "trace CExtendedTagTable tag descs")
DeclareTag(tagPeerExtendedTagTableBooster,          "Peer",                   "trace CExtendedTagTableBooster hits and misses")
DeclareTag(tagPeerExtendedTagTableBoosterResults,   "Peer",                   "trace CExtendedTagTableBooster results")

DeclareTag(tagPeerExtendedTagHostResolve,           "Peer",             "Trace host tag resolution")

const CBase::CLASSDESC CHTMLNamespaceCollection::s_classdesc =
{
    &CLSID_HTMLNamespaceCollection,         // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLNamespaceCollection,          // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

const CBase::CLASSDESC CHTMLNamespace::s_classdesc =
{
    &CLSID_HTMLNamespace,                   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLNamespace,                    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

EXTERN_C const GUID SID_SXmlNamespaceMapping = {0x3050f628,0x98b5,0x11cf, {0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
EXTERN_C const GUID CGID_XmlNamespaceMapping = {0x3050f629,0x98b5,0x11cf, {0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
#define XMLNAMESPACEMAPPING_GETURN 1

///////////////////////////////////////////////////////////////////////////
//
//  misc helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Helper:     TraceNamespace
//
//-------------------------------------------------------------------------

#if DBG == 1
void
TraceNamespace(LPTSTR pchEvent, CExtendedTagNamespace * pSyncItem)
{
    TraceTag((
        tagPeerExtendedTagNamespace,
        "%ls, [%lx] namespace = '%ls', factory = '%ls'",
        pchEvent,
        pSyncItem,
        STRVAL(pSyncItem->_cstrNamespace),
        STRVAL(pSyncItem->_cstrFactoryUrl)));
}
#endif

//+------------------------------------------------------------------------
//
//  Helper:     IsDefaultNamespace
//
//-------------------------------------------------------------------------

inline BOOL IsDefaultNamespace(LPTSTR pchNamespace, LONG cchNamespace = -1)
{
    if (!pchNamespace)
        return TRUE;

    if (-1 == cchNamespace)
    {
        return 0 == StrCmpIC(DEFAULT_NAMESPACE, pchNamespace);
    }
    else
    {
        return cchNamespace == DEFAULT_NAMESPACE_LEN && 0 == StrCmpIC(DEFAULT_NAMESPACE, pchNamespace);
    }
}

//+------------------------------------------------------------------------
//
//  Helper:     IsDefaultUrn
//
//-------------------------------------------------------------------------

inline BOOL IsDefaultUrn(LPTSTR pchUrn, LONG cchUrn = -1)
{
    if (!pchUrn)
        return FALSE;

    if (-1 == cchUrn)
    {
        return 0 == StrCmpIC(DEFAULT_NAMESPACE_URN, pchUrn);
    }
    else
    {
        return cchUrn == DEFAULT_NAMESPACE_URN_LEN && 0 == StrCmpIC(DEFAULT_NAMESPACE_URN, pchUrn);
    }
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CBuiltinTagDesc
//
///////////////////////////////////////////////////////////////////////////

//
// NOTE when changing this table, also change CExtendedTagNamespaceBuiltin::_aryItemsBuiltin size.
// (this is asserted in the code anyway)

const CTagDescBuiltin g_aryTagDescsBuiltin[] =
{
    {_T("XML"),        ETAG_GENERIC_LITERAL,    CTagDescBuiltin::TYPE_OLE,      {0x379E501F, 0xB231, 0x11d1, 0xad, 0xc1, 0x00, 0x80, 0x5F, 0xc7, 0x52, 0xd8}},
    {_T("HTC"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DESC},
    {_T("COMPONENT"),  ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DESC},
    {_T("PROPERTY"),   ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_PROPERTY},
    {_T("METHOD"),     ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_METHOD},
    {_T("EVENT"),      ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_EVENT},
    {_T("ATTACH"),     ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_ATTACH},
    {_T("PUT"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_NONE},
    {_T("GET"),        ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_NONE},
    {_T("DEFAULTS"),   ETAG_GENERIC_BUILTIN,    CTagDescBuiltin::TYPE_HTC,      HTC_BEHAVIOR_DEFAULTS},
#ifdef NEW_SELECT // TODO (alexz) the clsid should be switched to "#default#select" for perf reasons
    {_T("SELECT"),     ETAG_SELECT,             CTagDescBuiltin::TYPE_OLE,      {0x3050f688, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}},
#endif
    {NULL}
};

//+------------------------------------------------------------------------
//
//  Helper:     GetTagDescBuiltinIdx
//
//-------------------------------------------------------------------------

LONG
GetTagDescBuiltinIdx(const CTagDescBuiltin * pTagDescBuiltin)
{
    return pTagDescBuiltin - g_aryTagDescsBuiltin;
}

//+------------------------------------------------------------------------
//
//  Helper:     GetTagDescBuiltin
//
//-------------------------------------------------------------------------

const CTagDescBuiltin *
GetTagDescBuiltin(LPTSTR pchName, CExtendedTagTable * pTable)
{
    const CTagDescBuiltin * pTagDescBuiltin;

    Assert (NULL == StrChr(pchName, _T(':')));

#ifdef HASHBOOST
    LONG        idx;

    idx = pTable->GetHint(g_aryTagDescsBuiltin, pchName);
    if (0 <= idx && idx < ARRAY_SIZE(g_aryTagDescsBuiltin) - 1)
    {
        pTagDescBuiltin = &g_aryTagDescsBuiltin[idx];
        if (0 == StrCmpIC(pchName, pTagDescBuiltin->pchTagName))
        {
            TraceTag ((tagPeerExtendedTagTableBoosterResults, "::GetTagDescBuiltin:                HIT for %ls", pchName));

            return pTagDescBuiltin;
        }
    }
#endif

    TraceTag ((tagPeerExtendedTagTableBoosterResults, "::GetTagDescBuiltin:                LOOKUP %ld for %ls", ARRAY_SIZE(g_aryTagDescsBuiltin) - 1, pchName));

    for (pTagDescBuiltin = g_aryTagDescsBuiltin; pTagDescBuiltin->pchTagName; pTagDescBuiltin++)
    {
        if (0 == StrCmpIC(pchName, pTagDescBuiltin->pchTagName))
        {
#ifdef HASHBOOST
            pTable->SetHint(g_aryTagDescsBuiltin, pchName, pTagDescBuiltin - g_aryTagDescsBuiltin);
#endif
            return pTagDescBuiltin;
        }
    }

    return NULL;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagDesc
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::CExtendedTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc::CExtendedTagDesc()
{
    AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::~CExtendedTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc::~CExtendedTagDesc()
{
    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
    }

    _cstrTagName.Free();

    if (_pNamespace)
        _pNamespace->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDesc::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDesc::Init(CExtendedTagNamespace * pNamespace, LPTSTR pchTagName, CPeerFactory * pPeerFactory, ELEMENT_TAG etagBase, BOOL fLiteral)
{
    HRESULT     hr = S_OK;

    Assert (pNamespace && pchTagName && ETAG_NULL != etagBase);
    Assert (!_pNamespace && _cstrTagName.IsNull() && ETAG_NULL == _etagBase);

    _pPeerFactory = pPeerFactory;
    if (_pPeerFactory)
    {
        _pPeerFactory->AddRef();
    }

    _pNamespace = pNamespace;
    _pNamespace->SubAddRef();

    _etagBase = etagBase;
    _fLiteral = fLiteral;

    hr = THR(_cstrTagName.Set(pchTagName));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Namespace
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Namespace()
{
    Assert (_pNamespace && _pNamespace->_cstrNamespace.Length());
    return _pNamespace->_cstrNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::TagName
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::TagName()
{
    return _cstrTagName;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Urn
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Urn()
{
    Assert (_pNamespace);
    return _pNamespace->_cstrUrn;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::Implementation
//
//-------------------------------------------------------------------------

LPTSTR
CExtendedTagDesc::Implementation()
{
    if (_pPeerFactory)
    {
        return _pPeerFactory->GetUrl();
    }
    else
    {
        return NULL;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDesc::IsPIRequired
//
//-------------------------------------------------------------------------

BOOL
CExtendedTagDesc::IsPIRequired()
{
    Assert (_pNamespace);
    return !_pNamespace->_fNonPersistable;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagDescBuiltin
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::CExtendedTagDescBuiltin
//
//-------------------------------------------------------------------------

CExtendedTagDescBuiltin::CExtendedTagDescBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::~CExtendedTagDescBuiltin
//
//-------------------------------------------------------------------------

CExtendedTagDescBuiltin::~CExtendedTagDescBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagDescBuiltin::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagDescBuiltin::Init(CExtendedTagNamespace * pNamespace, const CTagDescBuiltin * pTagDescBuiltin)
{
    HRESULT     hr = S_OK;

    Assert (pNamespace && pTagDescBuiltin);
    Assert (!_pNamespace && _cstrTagName.IsNull());

    _pNamespace = pNamespace;
    _pNamespace->SubAddRef();

    hr = THR(_cstrTagName.Set(pTagDescBuiltin->pchTagName));
    if (hr)
        goto Cleanup;

    _etagBase = pTagDescBuiltin->etagBase;

    hr = THR(_factory.Init(pTagDescBuiltin));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespace
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExtendedTagNamespace(CExtendedTagTable * pTable)
{
    _pTable = pTable;

    AddRef();
    SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::~CExtendedTagNamespace()
{
    _cstrNamespace.Free();
    _cstrUrn.Free();
    _cstrFactoryUrl.Free();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Passivate
//
//-------------------------------------------------------------------------

void
CExtendedTagNamespace::Passivate()
{
    int         c;
    CItem **    ppItem;

    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        (*ppItem)->Release();
    }
    _aryItems.DeleteAll();

    ClearFactory();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::PrivateQueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementNamespace*)this, IUnknown)
    QI_INHERITS(this, IElementNamespace)
    QI_INHERITS(this, IServiceProvider)
    QI_INHERITS(this, IElementNamespacePrivate)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

STDMETHODIMP
CExtendedTagNamespace::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = E_NOINTERFACE;

    if (IsEqualGUID(rguidService, CLSID_HTMLDocument) && _pTable)
    {
        (*ppvService) = _pTable->_pDoc;
        hr = S_OK;
    }
    else if( IsEqualGUID(rguidService, CLSID_CMarkup) && _pTable)
    {
        (*ppvService) = _pTable->_pMarkup;
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Init
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Init(LPTSTR pchNamespace, LPTSTR pchUrn)
{
    HRESULT     hr = S_OK;

    Assert (_cstrNamespace.IsNull() && _cstrUrn.IsNull());

    if (pchNamespace)
    {
        hr = THR(_cstrNamespace.Set(pchNamespace));
    }

    if (pchUrn)
    {
        hr = THR(_cstrUrn.Set(pchUrn));
    }

#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::Init"), this);
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::ClearFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::ClearFactory()
{
    HRESULT     hr = S_OK;

    if (_pPeerFactory)
    {
        _pPeerFactory->Release();
        _pPeerFactory = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SetFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SetFactory(CPeerFactory * pFactory, BOOL fPeerFactoryUrl)
{
    HRESULT     hr;

    hr = THR(ClearFactory());
    if (hr)
        goto Cleanup;

    _pPeerFactory = pFactory;
    if (_pPeerFactory)
        _pPeerFactory->AddRef();

    _fPeerFactoryUrl = fPeerFactoryUrl;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SetFactory
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SetFactory(CMarkup * pMarkup, LPTSTR pchFactoryUrl)
{
    HRESULT             hr = S_OK;
    CPeerFactoryUrl *   pFactory;
    TCHAR               achFactoryUrl[pdlUrlLen];
    CDoc *              pDoc;

    Assert (pMarkup);

    pDoc = pMarkup->Doc();

    if (pchFactoryUrl)
    {
        if (_T('#') != pchFactoryUrl[0])
        {
            hr = THR(CMarkup::ExpandUrl(pMarkup, pchFactoryUrl, ARRAY_SIZE(achFactoryUrl), achFactoryUrl, NULL));
            if (hr)
                goto Cleanup;

            pchFactoryUrl = achFactoryUrl;
        }

        hr = THR_NOTRACE(pDoc->EnsurePeerFactoryUrl(pchFactoryUrl, NULL, pMarkup, &pFactory));
        if (hr)
        {
            // failed to ensure peer factory - for example, because of E_ACCESSDENIED or unavailable file.
            // in this case the entry in the table will only define a namespace valid for sprinkles
            if (E_ACCESSDENIED == hr)
            {
                ReportAccessDeniedError (/* pElement = */NULL, pMarkup, pchFactoryUrl);
            }

            hr = THR(ClearFactory());
            goto Cleanup;
        }

        hr = THR(_cstrFactoryUrl.Set(pchFactoryUrl));
        if (hr)
            goto Cleanup;

        hr = THR(SetFactory(pFactory, /* fPeerFactoryUrl */TRUE));
        if (hr)
            goto Cleanup;
    }

Cleanup:
#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::SetFactory"), this);
#endif

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Sync1
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Sync1(SYNCMODE syncMode)
{
    HRESULT     hr = S_OK;

    Assert (_fPeerFactoryUrl && _pPeerFactory);

    switch (syncMode)
    {
    case SYNCMODE_TABLE:
        _fSyncTable = TRUE;
        break;

    case SYNCMODE_COLLECTIONITEM:
        _fSyncTable = FALSE;
        Assert (_pCollectionItem);
        _pCollectionItem->AddRef();
        break;
    }

    hr = THR(DYNCAST(CPeerFactoryUrl, _pPeerFactory)->SyncETN(this));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::Sync2
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::Sync2()
{
    HRESULT     hr = S_OK;

    if (_fSyncTable)
    {
        Assert (_pTable);
        hr = THR(_pTable->Sync2());
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert (_pCollectionItem);

        hr = THR(_pCollectionItem->OnImportComplete());
        if (hr)
            goto Cleanup;

        _pCollectionItem->Release();
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::SyncAbort
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::SyncAbort()
{
    HRESULT     hr;

    Assert (_fPeerFactoryUrl);

    hr = THR(DYNCAST(CPeerFactoryUrl, _pPeerFactory)->SyncETNAbort(this));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagNamespace::FindTagDesc(LPTSTR pchTagName)
{
    LONG        c;
    CItem **    ppItem;

#ifdef HASHBOOST
    LONG        idx;

    if (_pTable)
    {
        idx = _pTable->GetHint(this, pchTagName);
        if (0 <= idx && idx < _aryItems.Size())
        {
            _ppLastItem = &_aryItems[idx];
        }
    }
#endif

    // check last item value
    if (_ppLastItem)
    {
        if (0 == StrCmpIC((*_ppLastItem)->_cstrTagName, pchTagName))
        {
            TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagNamespace::FindTagDesc: HIT for %ls", pchTagName));
            goto Cleanup;
        }
    }

    TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagNamespace::FindTagDesc: LOOKUP {%ld} for %ls", _aryItems.Size(), pchTagName));

    // search the array
    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        if (ppItem != _ppLastItem &&
            0 == StrCmpIC((*ppItem)->_cstrTagName, pchTagName))
        {
            // found
            _ppLastItem = ppItem;
            Assert (*_ppLastItem);

#ifdef HASHBOOST
            if (_pTable)
            {
                _pTable->SetHint(this, pchTagName, _ppLastItem - &(_aryItems[0]));
            }
#endif

            goto Cleanup; // done
        }
    }

    // failed to find
    _ppLastItem = NULL;

Cleanup:

    return _ppLastItem ? (*_ppLastItem) : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::AddTagDesc, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::AddTagDesc(LPTSTR pchTagName, BOOL fOverride, LPTSTR pchBaseTagName, DWORD dwFlags, CExtendedTagDesc ** ppDesc)
{
    HRESULT             hr = S_OK;
    ELEMENT_TAG         etagBase;
    CItem *             pItem;
    CExtendedTagDesc *  pTagDesc;
    BOOL                fLiteral;

    //
    // startup
    //

    Assert (pchTagName && pchTagName[0]);

    if (!ppDesc)
        ppDesc = &pItem;

    *ppDesc = NULL;

    pItem = FindTagDesc(pchTagName);

    if (pItem && !fOverride)
    {
        *ppDesc = pItem;
        goto Cleanup;   // done
    }

    switch( dwFlags )
    {
    case ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL:
        etagBase = ETAG_GENERIC_NESTED_LITERAL;
        fLiteral = TRUE;
        break;
    case ELEMENTDESCRIPTORFLAGS_LITERAL:
        etagBase = ETAG_GENERIC_LITERAL;
        fLiteral = TRUE;
        break;
    default:
        etagBase = ETAG_GENERIC;
        fLiteral = FALSE;
    }

    // TODO (jharding, alexz): We need to revisit literal parsing for derived tags, when we support it
    etagBase = pchBaseTagName ? EtagFromName(pchBaseTagName, _tcslen(pchBaseTagName)) : etagBase;

    //
    // create the new desc
    //

    pTagDesc = new CExtendedTagDesc();
    if (!pTagDesc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#if DBG == 1
    TraceNamespace(_T("CExtendedTagNamespace::AddTagDesc"), this);
    TraceTag((tagPeerExtendedTagDesc, "             tagDesc: [%lx], tagName = '%ls'", pTagDesc, STRVAL(pchTagName)));
#endif

    hr = THR(pTagDesc->Init(this, pchTagName, _pPeerFactory, etagBase, fLiteral));
    if (hr)
        goto Cleanup;

    //
    // put it in the array
    //

    if (!pItem)
    {
        // normal case, tag desc for the tagName not found

        hr = THR(_aryItems.AppendIndirect(&pTagDesc));
        if (hr)
            goto Cleanup;

        _ppLastItem = &_aryItems[_aryItems.Size() - 1];
    }
    else
    {
        // unusual case, the call overrides tagName previously registered

        Assert (_ppLastItem);

        (*_ppLastItem)->Release();  // release the previous tagDesc for tagName

        (*_ppLastItem) = pTagDesc;  // store the new one in the table
    }

    Assert (*_ppLastItem);

    //
    // finalize
    //

#ifdef HASHBOOST
    if (_pTable)
    {
        _pTable->SetHint(this, pchTagName, _ppLastItem - &_aryItems[0]);
    }
#endif

    *ppDesc = pTagDesc;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::AddTag, per IElementIdentityTableNamespace
//  AND         CExtendedTagNamespace::AddTagPrivate, per IElementNamespacePrivate
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagNamespace::AddTag(BSTR bstrTagName, LONG lFlags)
{
    if(     lFlags & ELEMENTDESCRIPTORFLAGS_LITERAL
        &&  lFlags & ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL )
    {
        RRETURN( E_INVALIDARG );
    }
    else
    {
        RRETURN( AddTagPrivate( bstrTagName, NULL, lFlags ) );
    }
}

HRESULT
CExtendedTagNamespace::AddTagPrivate(BSTR bstrTagName, BSTR bstrBaseTagName, LONG lFlags)
{
    HRESULT     hr;
    LPTSTR      pchBaseTagName  = NULL;

    Assert( !(     lFlags & ELEMENTDESCRIPTORFLAGS_LITERAL
               &&  lFlags & ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL ) );

    if (!_fExternalUpdateAllowed)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!bstrTagName || !bstrTagName[0] ||
        (bstrBaseTagName && !bstrBaseTagName[0]))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (for trident v3 baseTagName is publicly disabled, but it is still privately exercised in DRT to maintain the codepath alive)
#if 1
    if (bstrBaseTagName)
    {
        Assert (6 == _tcslen(_T("__MS__")));

        if (6 <= FormsStringLen(bstrBaseTagName) &&
            0 == StrCmpNIC(_T("__MS__"), bstrBaseTagName, 6))
        {
            pchBaseTagName = bstrBaseTagName + 6;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
#endif

    hr = THR(AddTagDesc(bstrTagName, /* fOverride = */TRUE, pchBaseTagName, lFlags));

Cleanup:
    RRETURN (hr);
}


///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespace::CExternalUpdateLock
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::CExternalUpdateLock constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExternalUpdateLock::CExternalUpdateLock(CExtendedTagNamespace * pNamespace, CPeerFactory * pPeerFactory)
{
    Assert (pNamespace && pPeerFactory);

    _pNamespace = pNamespace;

    _pPeerFactoryPrevious = _pNamespace->_pPeerFactory;
    _pNamespace->_pPeerFactory = pPeerFactory;

    Assert (!_pNamespace->_fExternalUpdateAllowed);
    _pNamespace->_fExternalUpdateAllowed = TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespace::CExternalUpdateLock destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespace::CExternalUpdateLock::~CExternalUpdateLock()
{
    _pNamespace->_pPeerFactory = _pPeerFactoryPrevious;

    Assert (_pNamespace->_fExternalUpdateAllowed);
    _pNamespace->_fExternalUpdateAllowed = FALSE;
};

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagNamespaceBuiltin
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin constructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespaceBuiltin::CExtendedTagNamespaceBuiltin(CExtendedTagTable * pExtendedTagTable) :
    CExtendedTagNamespace(pExtendedTagTable)
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin destructor
//
//-------------------------------------------------------------------------

CExtendedTagNamespaceBuiltin::~CExtendedTagNamespaceBuiltin()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin::Passivate
//
//