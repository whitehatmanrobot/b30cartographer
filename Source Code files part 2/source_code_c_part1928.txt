nvalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class036SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class036SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class036SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class036Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class01f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** NV1_IMAGE_BLIT ********************************\
*                                                                           *
* Module: CLASS01F.C                                                        *
*   This module implements the NV1_IMAGE_BLIT object class                  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class01FValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation == NV_SRCCOPY_AND  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL) &&
        (pRenderObject->RCPatchContext.SurfaceSource != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;    
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class01FSetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_SOLID:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01FSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class01FSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextSurfaceSource
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextSurfaceSource\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_1:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.SurfaceSource = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class01FSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class01FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class01FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class038.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV4_DVD_SUBPICTURE ******************************\
*                                                                           *
* Module: CLASS038.C                                                        *
*   This module implements the NV4_DVD_SUBPICTURE object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class042.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_CONTEXT_SURFACES_2D ****************************\
*                                                                           *
* Module: CLASS042.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACES_2D object class         *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class037.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV3_SCALED_IMAGE_FROM_MEMORY *************************\
*                                                                           *
* Module: CLASS037.C                                                        *
*   This module implements the NV3_SCALED_IMAGE_FROM_MEMORY object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class037Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class037SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class037SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class037SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class037Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class043.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** NV3_CONTEXT_ROP *******************************\
*                                                                           *
* Module: CLASS043.C                                                        *
*   This module implements the NV3_CONTEXT_ROP object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class044.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_CONTEXT_PATTERN ******************************\
*                                                                           *
* Module: CLASS044.C                                                        *
*   This module implements the NV4_CONTEXT_PATTERN object class             *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class039.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV3_MEMORY_TO_MEMORY_FORMAT **************************\
*                                                                           *
* Module: CLASS039.C                                                        *
*   This module implements the NV3_MEMORY_TO_MEMORY_FORMAT object class     *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class047.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY methods.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047StopOverlayNow
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEO_OVERLAY_OBJECT           pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT       pOverlayHalObject;
    RM_STATUS                       status;
    U032                            Head = 0; // this is a single-head class

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;
    VidLutCurDac.Head = Head;

    //
    // Stop the current data transfer immediately.
    //
    if (pOverlayHalObject->Overlay[0].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0, // info32
                                0, // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(0));
        pOverlayHalObject->Overlay[0].State = OVERLAY_BUFFER_IDLE;
    }
    if (pOverlayHalObject->Overlay[1].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0,  // info32
                                0,  // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(1));
        pOverlayHalObject->Overlay[1].State = OVERLAY_BUFFER_IDLE;
    }

    //
    // Notify this one
    //
    if (pOverlayObject->Common.Base.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                0, // info32
                                0, // info16
                                RM_OK, 
                                NV047_NOTIFIERS_SET_OVERLAY(BuffNum));
    }     

    //
    // Issue stop-immediately call to HAL.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, NV047_STOP_OVERLAY(BuffNum), NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE, &status);

    //
    // Transition state of object back to uninitialized.
    //
    pOverlayObject->InitState = 0;

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    //
    // Clear the active overlay object.
    //
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pOverlayObject)
    {
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;
        pDev->Video.HalInfo.Enabled = 0;
    }

    return status;
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                   status;
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;

    if (pOverlayObject->CBase.NotifyTrigger)
        return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->CBase.NotifyXlate));
    if (status)
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pOverlayObject->CBase.NotifyXlate, 
                              0, 
                              (3 * 0x0010));
    if (status)
    {
        pOverlayObject->CBase.NotifyXlate = NULL;
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class047SetNotifyCtxDma

RM_STATUS class047SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    pOverlayObject->CBase.NotifyAction  = Data;
    pOverlayObject->CBase.NotifyTrigger = TRUE;
    
    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047SetNotify

RM_STATUS class047StopOverlay
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    U032                  buffNum;
  
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047StopOverlay\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    buffNum = (Offset == NV047_STOP_OVERLAY(0)) ? 0 : 1;
    if (Data == NV047_STOP_OVERLAY_AS_SOON_AS_POSSIBLE) 
    {
        class047StopOverlayNow(pDev, (POBJECT)pOverlayObject, 
                               0 /* param1 */, buffNum, 
                               NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
    }
    else
    {
        if (pOverlayObject->HalObject.Overlay[buffNum].State != OVERLAY_BUFFER_STOP_PENDING) {
            // setup so we get a callback to do the stop at the next VBlank.
            pOverlayObject->Overlay[buffNum].OverlayCallback.Proc   = class047StopOverlayNow;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Object = (POBJECT) pOverlayObject;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Next    = NULL;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pOverlayObject->Overlay[buffNum].OverlayCallback.Param2  = buffNum;
            pOverlayObject->Overlay[buffNum].OverlayCallback.Status  = NV047_NOTIFICATION_STATUS_DONE_SUCCESS;

            // Defaults to head 0.
            VBlankAddCallback(pDev, 0, &(pOverlayObject->Overlay[buffNum].OverlayCallback));
            pOverlayObject->HalObject.Overlay[buffNum].State = OVERLAY_BUFFER_STOP_PENDING;
        }
    }

    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047StopOverlay

RM_STATUS class047SetOverlayCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    buffNum = (Offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);    

	if (Data == NV01_NULL_OBJECT)
    {
       	pOverlayObject->Overlay[buffNum].OverlayCtxDma = NULL;
        pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = NULL;
        return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->Overlay[buffNum].OverlayCtxDma));
    if (status)
        return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    // The overlay context dma MUST point to the frame buffer.
    if (pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        return NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }

    // Give HAL access to context dma.
    pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = &pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo;

    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class047SetOverlayCtxDma

RM_STATUS class047GetOffset
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047GetOffset\r\n");
    
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    if (!pOverlayObject->CBase.NotifyTrigger)
        // nothing to do.
        return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;

    //
    // The caller is expecting a notification. 
    //
    if (pOverlayObject->CBase.NotifyXlate) 
    {
        //
        // Give HAL chance to setup offset if necessary.
        //
        (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
        if (status)
            return status;
        status = notifyFillNotifierArray(pDev, pOverlayObject->CBase.NotifyXlate, 
                                         pOverlayObject->HalObject.Overlay[Data].Offset,   // info32
                                         NV047_NOTIFICATION_INFO16_VALID_OFFSET, // info16
                                         NV047_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV047_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pOverlayObject->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pOverlayObject, 
                          NV047_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pOverlayObject->CBase.NotifyAction);
        }
    }
    pOverlayObject->CBase.NotifyTrigger = FALSE; 
    return (NV047_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class047GetOffset

RM_STATUS class047SetOverlayValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS status;
    U032                         Head = 0; // this is a single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayValues\r\n");

    VidLutCurDac.Head = Head;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
	//
    // Initialize the overlay description via the HAL video engine manager.
    //
    switch (Offset)
    {
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
            (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
            return status;
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            U032 buffNum;

            buffNum = (Offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            pOverlayObject->Overlay[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV047_SET_OVERLAY_FORMAT_NOTIFY))) ? 1 : 0;


#if 0
            //
            // Below is commented out because of race condition problems when we have
            // an overlay object in a DMA channel and a PIO channel as is the case with 
            // VPE (jsun)
            //
            if (pOverlayObject->InitState == 0)
            {
                if (pDev->Video.HalInfo.ActiveVideoOverlayObject != NULL)
                {
                    return NV_OUT_OF_RESOURCES;
                }
            }
#endif

            (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

            //
            // Ensure class-dependent video service handler is
            // setup properly.
            //
            if (status == RM_OK)
            {
                //
                // If video has just been enabled, then refresh arb settings.
                //
                if (pOverlayObject->InitState == 0)
                {
                    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);
                    pOverlayObject->InitState = 1;
                }

                pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pOverlayObject;
                pDev->pOverlayServiceHandler = videoOverlayService;
            }
            return status;
        }
        default:
            return NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class047SetOverlayValues

RM_STATUS class047SetOverlayPointOutNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class047SetOverlayPointOutNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV04_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class046.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class046.C                                                        *
*   This module implements the NV04_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class046SetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class046SetNotifyCtxDma

RM_STATUS class046SetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046SetNotify

RM_STATUS class046StopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopImage\r\n");

    // class046 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopImage

RM_STATUS class046StopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopLUT\r\n");
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopLUT

RM_STATUS class046StopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopCursorImage

RM_STATUS class046StopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046StopDAC\r\n");

    // class046 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046StopDAC

RM_STATUS class046SetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class046SetImageCtxDma

RM_STATUS class046SetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class046SetLUTCtxDma

RM_STATUS class046SetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV046_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

        if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class046SetCursorCtxDma

RM_STATUS class046SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV046_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class046SetPanOffset

RM_STATUS class046GetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV046_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV046_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV046_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class046GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class046ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // increment the flip count and send it back through the notifier
    pVidLutCurDac->CompletedFlipCount++;

    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                pVidLutCurDac->CompletedFlipCount, // Info32
                                0, 
                                Status,
                                NV046_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class046SetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV046_SET_IMAGE_OFFSET(0):
        case NV046_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV046_SET_IMAGE_FORMAT(0):
        case NV046_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  Head = 0;   // single-head class
            U032  flags;
            
            buffNum = (Offset == NV046_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x1F) != 0)
                // the minimum pitch must be a multiple of 32 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            flags = DRF_VAL(046, _SET_IMAGE_FORMAT, _FLAGS, Data);

            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;

            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV046_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                               pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
                return NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // setup so we get a callback to do the notify at the next VBlank.
            pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class046ImageNotify;
            pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
            pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
            pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
            pVidLutCurDac->Image[buffNum].ImageCallback.Flags   = 0;

            if (flags & NV046_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

            // Defaults to head 0.
            VBlankAddCallback(pDev, 0, &(pVidLutCurDac->Image[buffNum].ImageCallback));
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class046SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class046ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032    Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV046_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class046SetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV046_SET_LUT_OFFSET(0):
        case NV046_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV046_SET_LUT_FORMAT(0):
        case NV046_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV046_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class046ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class046SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class046CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV046_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV046_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class046SetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
        //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV046_SET_CURSOR_IMAGE_OFFSET(0):
        case NV046_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV046_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV046_SET_CURSOR_IMAGE_FORMAT(0):
        case NV046_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032    Head = 0;   // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV046_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            // The cursor is always 32x32 image with a color format LE_ROP1R5G5B5. 
            pVidLutCurDac->CursorImage[buffNum].Width       = 32; 
            pVidLutCurDac->CursorImage[buffNum].Height      = 32; 
            pVidLutCurDac->CursorImage[buffNum].ColorFormat = 0;  // LE_ROP1R5G5B5

            pVidLutCurDac->CursorImage[buffNum].NotifyAction = Data; 

            // Kick off the trasfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                                pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           32 /* width */, 
                                           32 /* height */, 0 /* colorFormat LE_ROP1R5G5B5 */,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class046CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class046SetCursorImageValues

// This proc is called from VBlank to program the cursor position.
RM_STATUS class046ProgramCursorPoint
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Data,
    V032      DummyParm,
    RM_STATUS Status
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 Head = 0;   // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
                                      
    // signal that the callback is done
    pVidLutCurDac->CursorPointCallback.Proc = NULL;
    
    return (NV046_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class046ProgramCursorPoint()

RM_STATUS class046SetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetCursorPoint\r\n");
    
    // update the cursor position
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    pVidLutCurDac->CursorPointCallback.Param1      = Data;
    if (pVidLutCurDac->CursorPointCallback.Proc == NULL)
    {
        // add the cursor position callback
        pVidLutCurDac->CursorPointCallback.Proc    = class046ProgramCursorPoint;
        pVidLutCurDac->CursorPointCallback.Object  = (POBJECT)pVidLutCurDac;
        pVidLutCurDac->CursorPointCallback.Next    = NULL;
        pVidLutCurDac->CursorPointCallback.Param2  = 0;
        pVidLutCurDac->CursorPointCallback.Status  = NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        VBlankAddCallback(pDev, Head, &(pVidLutCurDac->CursorPointCallback));
    }
    
    return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class046SetCursorPoint

RM_STATUS class046SetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class046SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV046_SET_DAC_IMAGE_SIZE(0):
        case NV046_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV046_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set Horizontal Blank
        //
        case NV046_SET_DAC_HORIZONTAL_BLANK(0):
        case NV046_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))       // width greater than 1024
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV046_SET_DAC_HORIZONTAL_SYNC(0):
        case NV046_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV046_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical Blank
        //
        case NV046_SET_DAC_VERTICAL_BLANK(0):
        case NV046_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))  // width greater than 128
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV046_SET_DAC_VERTICAL_SYNC(0):
        case NV046_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV046_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV046_SET_DAC_TOTAL_SIZE(0):
        case NV046_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV046_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV046_SET_DAC_PIXEL_CLOCK(0):
        case NV046_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV046_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV046_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV046_SET_DAC_FORMAT(0):
        case NV046_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV046_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR) pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;
            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV046_SET_DAC_FORMAT_COLOR);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV046_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;
			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV046_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV046_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth     = pDev->Dac.HalInfo.Depth;
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice = 
                DRF_VAL(046, _SET_DAC_FORMAT, _PRIMARY_DEVICE, Data);

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV046_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid display type ", pVidLutCurDac->DisplayType);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV046_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV046_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            
            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV046_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV046_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class046SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class048.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV3_DX3_TEXTURED_TRIANGLE **************************\
*                                                                           *
* Module: CLASS048.C                                                        *
*   This module implements the NV3_DX3_TEXTURED_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class048Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Surface != NULL) &&
        (pRenderObject->RCPatchContext.SurfaceZeta != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

        
    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class048SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
    
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class048SetContextSurfaceColor
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextSurfaceColor\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_2:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class048SetContextSurfaceZeta
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class048SetContextSurfaceZeta\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_3:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.SurfaceZeta = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class048Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class04a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** NV4_GDI_RECTANGLE_TEXT ****************************\
*                                                                           *
* Module: CLASS04A.C                                                        *
*   This module implements the NV4_GDI_RECTANGLE_TEXT object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04AValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class04ASetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04ASetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ASetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04AValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class049.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class049.C                                                        *
*   This module implements the NV05_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class049SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class049SetNotifyCtxDma

RM_STATUS class049SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049SetNotify

RM_STATUS class049StopImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopImage\r\n");

    // class049 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopImage

RM_STATUS class049StopLUT
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopLUT\r\n");
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopLUT

RM_STATUS class049StopCursorImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopCursorImage

RM_STATUS class049StopDAC
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049StopDAC\r\n");

    // class049 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049StopDAC

RM_STATUS class049SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
       	pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class049SetImageCtxDma

RM_STATUS class049SetLUTCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class049SetLUTCtxDma

RM_STATUS class049SetCursorCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV049_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

	if (Data == NV01_NULL_OBJECT)
    {
       	pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class049SetCursorCtxDma

RM_STATUS class049SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV049_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class049SetPanOffset

RM_STATUS class049GetOffset
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV049_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV049_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV049_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class049GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class049ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // increment the flip count and send it back through the notifier
    pVidLutCurDac->CompletedFlipCount++;

    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                pVidLutCurDac->CompletedFlipCount, // Info32
                                0, 
                                Status,
                                NV049_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class049SetImageValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV049_SET_IMAGE_OFFSET(0):
        case NV049_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
            	// The image offset must be a multiple of 4 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV049_SET_IMAGE_FORMAT(0):
        case NV049_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  when, flags;
            
            buffNum = (Offset == NV049_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x1F) != 0)
            	// the minimum pitch must be a multiple of 32 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;
            
            when = (Data >> DRF_SHIFT(NV049_SET_IMAGE_FORMAT_WHEN)) & DRF_MASK(NV049_SET_IMAGE_FORMAT_WHEN);
            flags = DRF_VAL(049, _SET_IMAGE_FORMAT, _FLAGS, Data);
            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV049_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            if (when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) 
            {
                // Change the default flip functionality to end of hsync.

                // Unfortunately the HSYNC bit is in different locations on NV5/NV10
                if (IsNV10orBetter(pDev))
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10);
                else
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV5);
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);
            }

            // Program the hardware.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                                pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
            {
                pVidLutCurDac->Image[buffNum].NotifyTrigger = FALSE;
                return NV049_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
            }
            if (when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Do the notify right here.
                class049ImageNotify(pDev, (POBJECT)pVidLutCurDac, 
                                    0 /* param 1*/, buffNum,
                                    NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
            }
            else
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class049ImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags   = 0;

                if (flags & NV049_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

                // Default to head 0.
                VBlankAddCallback(pDev, 0, &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class049SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class049ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032    Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV049_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class049SetLUTValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV049_SET_LUT_OFFSET(0):
        case NV049_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
            	// The LUT offset must be a multiple of 1024 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV049_SET_LUT_FORMAT(0):
        case NV049_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV049_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class049ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class049SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class049CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV049_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV049_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class049SetCursorImageValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV049_SET_CURSOR_IMAGE_OFFSET(0):
        case NV049_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV049_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
            	// The cursor image offset must be a multiple of 1024 bytes.
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV049_SET_CURSOR_IMAGE_FORMAT(0):
        case NV049_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032    Head = 0;   // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV049_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            // The cursor is always 32x32 image with a color format LE_ROP1R5G5B5. 
            pVidLutCurDac->CursorImage[buffNum].Width       = 32; 
            pVidLutCurDac->CursorImage[buffNum].Height      = 32; 
            pVidLutCurDac->CursorImage[buffNum].ColorFormat = 0;  // LE_ROP1R5G5B5

            pVidLutCurDac->CursorImage[buffNum].NotifyAction = Data; 

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           32 /* width */, 
                                           32 /* height */, 0 /* colorFormat LE_ROP1R5G5B5 */,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class049CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class049SetCursorImageValues

// This proc is called from VBlank to program the cursor position.
RM_STATUS class049ProgramCursorPoint
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Data,
    V032      DummyParm,
    RM_STATUS Status
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 Head = 0;   // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
                                      
    // signal that the callback is done
    pVidLutCurDac->CursorPointCallback.Proc = NULL;
    
    return (NV049_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class049ProgramCursorPoint()

RM_STATUS class049SetCursorPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetCursorPoint\r\n");
    
    // update the cursor position
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    pVidLutCurDac->CursorPointCallback.Param1      = Data;
    if (pVidLutCurDac->CursorPointCallback.Proc == NULL)
    {
        // add the cursor position callback
        pVidLutCurDac->CursorPointCallback.Proc    = class049ProgramCursorPoint;
        pVidLutCurDac->CursorPointCallback.Object  = (POBJECT)pVidLutCurDac;
        pVidLutCurDac->CursorPointCallback.Next    = NULL;
        pVidLutCurDac->CursorPointCallback.Param2  = 0;
        pVidLutCurDac->CursorPointCallback.Status  = NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        VBlankAddCallback(pDev, Head, &(pVidLutCurDac->CursorPointCallback));
    }
    
    return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class049SetCursorPoint

RM_STATUS class049SetDACValues
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
	RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class049SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
	//
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV049_SET_DAC_IMAGE_SIZE(0):
        case NV049_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV049_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV049_SET_DAC_HORIZONTAL_SYNC(0):
        case NV049_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV049_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical sync
        //
        case NV049_SET_DAC_VERTICAL_SYNC(0):
        case NV049_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV049_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV049_SET_DAC_TOTAL_SIZE(0):
        case NV049_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV049_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV049_SET_DAC_PIXEL_CLOCK(0):
        case NV049_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV049_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV049_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV049_SET_DAC_FORMAT(0):
        case NV049_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV049_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV049_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV049_SET_DAC_FORMAT_COLOR);

			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pDev->Dac.PixelDepth                   = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice = 
               DRF_VAL(049, _SET_DAC_FORMAT, _PRIMARY_DEVICE, Data);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV049_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;

            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV049_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class049: invalid display type ", pVidLutCurDac->DisplayType);
                return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV049_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV049_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class046: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }


            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV049_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV049_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV049_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class049SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class04b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** NV3_GDI_RECTANGLE_TEXT ****************************\
*                                                                           *
* Module: CLASS04B.C                                                        *
*   This module implements the NV3_GDI_RECTANGLE_TEXT object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04BValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class04BSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_SURFACE_0:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class04BSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04BSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV3_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class04BValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class04d.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04D.C                                                        *
*   This module implements the NV03_EXTERNAL_VIDEO_DECODER methods.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

// See kernel/mp/mpobj.c.

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DNotify\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class04DStopTransferVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStopTransferVbi\r\n");

    pDecoder = (PVIDEODECODEROBJECT)Object;

    //
    // Stop the current vbi data transfer immediately.
    //

    //
    // Probably should error check this data again
    // NV04F_STOP_TRANSFER_VBI_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_STOP_TRANSFER_VBI, Data, &status);

	 return (status);
}

RM_STATUS class04DStopTransferImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStopTransferImage\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    //
    // Probably should error check this data again
    // NV04F_STOP_TRANSFER_IMAGE_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_STOP_TRANSFER_IMAGE, Data, &status);

    return (status);
}

RM_STATUS class04DSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04DSetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaImage\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecoder->ContextDmaImage[Buffer] = NULL;
        pDecoder->HalObject.SetImage[Buffer].CtxDma = NULL;
        return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the image DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecoder->ContextDmaImage[Buffer]));
    if (status)
        return (status);

    //
    // Give HAL access to context dma.
    //
    pDecoder->HalObject.SetImage[Buffer].CtxDma = &pDecoder->ContextDmaImage[Buffer]->HalInfo;

    return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;    
}

RM_STATUS class04DSetContextDmaVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetContextDmaVbi\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecoder->ContextDmaVbi[Buffer] = NULL;
        pDecoder->HalObject.SetVbi[Buffer].CtxDma = NULL;
        return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecoder->ContextDmaVbi[Buffer]));
    if (status)
        return (status);

    //
    // Give HAL access to context dma.
    //
    pDecoder->HalObject.SetVbi[Buffer].CtxDma = &pDecoder->ContextDmaVbi[Buffer]->HalInfo;
    
    return (RM_OK);
}

RM_STATUS class04DSetImageConfig
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImageStartLine\r\n");

    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_SET_IMAGE_CONFIG, Data, &status);
    
    return (status);
    
}

RM_STATUS class04DSetImageStartLine
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImageStartLine\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, NV04D_SET_IMAGE_START_LINE, Data, &status);

    return (status);
    
}

RM_STATUS class04DSetVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;


    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetVbi\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    return (status);
}

RM_STATUS class04DSetImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DSetImage\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    return (status);
}

RM_STATUS class04DGetVbiOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT pDecoder;
    U032                        Buffer;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DGetVbiOffsetNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = ((Offset - Method->Low) <= 0x03) ? 0 : 1;

    //
    // Get current position from HAL.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    //
    // Send back the data
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate,
                            pDecoder->HalObject.SetVbi[Buffer].GetOffsetData,
                            0,
                            RM_OK,
                            NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(Buffer) );

    if (Data)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(Buffer),
                      0, 
                      1, 
                      RM_OK, 
                      Data);

    return (status);
    
}

RM_STATUS class04DGetImageOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECODEROBJECT         pDecoder;
    U032                        Buffer;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DGetImageOffsetNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecoder = (PVIDEODECODEROBJECT)Object;

    Buffer = ((Offset - Method->Low) <= 0x03) ? 0 : 1;

    //
    // Get current position from HAL.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECODER, &pDecoder->HalObject, Offset, Data, &status);

    //
    // Send back the data
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate,
                            pDecoder->HalObject.SetImage[Buffer].GetOffsetData,
                            0,
                            RM_OK,
                            NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(Buffer));

    if (Data)
        osNotifyEvent(pDev, (POBJECT)pDecoder,
                      NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(Buffer),
                      0, 
                      1, 
                      RM_OK, 
                      Data);

    return (status);
}

//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

// This is a helper proc for VbiEvent.
// This procedure actually does the notification for the given buffer.
static void NotifyVbiBuffer
(
	PHWINFO				pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032                BuffNum
)
{
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(BuffNum));

    if (pDecoder->HalObject.SetVbi[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(BuffNum),
                      0, 
                      0, 
                      RM_OK, 
                      pDecoder->HalObject.SetVbi[BuffNum].Notify);
}

// This is a helper proc for ImageEvent.
// This procedure actually does the notification for the given buffer.
static VOID NotifyImageBuffer
(
	PHWINFO				pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032                BuffNum
)
{
    //
    // Include 32bit info value.
    //
    notifyFillNotifierArray(pDev, pDecoder->CBase.NotifyXlate, 
                             pDecoder->HalObject.SetImage[BuffNum].Info32,
                             0,
                             RM_OK, 
                             NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(BuffNum));

    if (pDecoder->HalObject.SetImage[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecoder, 
                      NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(BuffNum),
                      0, 
                      1, 
                      RM_OK, 
                      pDecoder->HalObject.SetImage[BuffNum].Notify);
}

static VOID VbiEvents
(
    PHWINFO pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecoder->HalObject;
    U032 events = CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1);

    //
    // Call into HAL and get status on VBI events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (pDecoder->LastVbiBufferProcessed == 1)
    {
        // Check buffer 0 first.
        if (events & CLASS04D_VBI_EVENT(0))
        {
            NotifyVbiBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
        // Now buffer 1.
        if (events & CLASS04D_VBI_EVENT(1))
        {
            NotifyVbiBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
    }
    else
    {
        // Check buffer 1 first.
        if (events & CLASS04D_VBI_EVENT(1))
        {
            NotifyVbiBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }
        // Now buffer 0.
        if (events & CLASS04D_VBI_EVENT(0))
        {
            NotifyVbiBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_VBI_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastVbiBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_VBI;
        }

    }

    return;
}

static VOID ImageEvents
(
    PHWINFO pDev,
    PVIDEODECODEROBJECT pDecoder,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecoder->HalObject;
    U032 events = CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1);

    //
    // Call into HAL and get status on Image events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (pDecoder->LastImageBufferProcessed == 1)
    {
        // Check buffer 0 first.
        if (events & CLASS04D_IMAGE_EVENT(0))
        {
            NotifyImageBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
        // Now buffer 1.
        if (events & CLASS04D_IMAGE_EVENT(1))
        {
            NotifyImageBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
    }
    else
    {
        // Check buffer 1 first.
        if (events & CLASS04D_IMAGE_EVENT(1))
        {
            NotifyImageBuffer(pDev, pDecoder, 1);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(1),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 1;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }
        // Now buffer 0.
        if (events & CLASS04D_IMAGE_EVENT(0))
        {
            NotifyImageBuffer(pDev, pDecoder, 0);
            (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECODER,
                                       pMpHalObj,
                                       CLASS04D_IMAGE_EVENT(0),
                                       pIntrStatus);
            pDecoder->LastImageBufferProcessed = 0;
            pDecoder->LastEventProcessed = EVENT_PROCESSED_IMAGE;
        }

    }

    //
    // If we had any pending image events, issue os-dependent callback.
    //
    if (events)
        osmpCheckCallbacks(pDev, 1);

    return;
}

//
// class04DService
//
V032 class04DService
(
    PHWINFO pDev
)
{
    PVIDEODECODEROBJECT pDecoder;
    U032 eventsPending, intrStatus;

    //
    // Handle case where we don't have a current decoder object.
    //
    pDecoder = (PVIDEODECODEROBJECT)(pDev->MediaPort.CurrentDecoder);
    if (pDecoder == NULL)
    {
        //
        // This exception is spurious.  Call into HAL to give it a
        // chance to reset the pending condition and then we're done.
        //
        eventsPending = 0xffffffff;
        (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECODER, NULL, &eventsPending, &intrStatus);
        return (intrStatus);
    }

    //
    // The order in which we process this interrupt is dependent on
    // the last event/buffer processed.
    //
    if (pDecoder->LastEventProcessed == EVENT_PROCESSED_IMAGE) 
    {
        VbiEvents(pDev, pDecoder, &intrStatus);
        ImageEvents(pDev, pDecoder, &intrStatus);
    }
    else
    {
        ImageEvents(pDev, pDecoder, &intrStatus);
        VbiEvents(pDev, pDecoder, &intrStatus);
    }

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class04e.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

// See kernel/mp/mpobj.c.


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04ENotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ENotify\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class04EStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStopTransfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    //
    // Stop the current data transfer immediately.
    //
    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, NV04E_STOP_TRANSFER, Data, &status);

    return (RM_OK);
}
RM_STATUS class04ESetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextNotifies\r\n");
    //
    // Set the notify DMA context
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04ESetContextDmaData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextDmaDma\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecompress->ContextDmaData[Buffer] = NULL;
        pDecompress->HalObject.ReadData[Buffer].CtxDma = NULL;
        return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecompress->ContextDmaData[Buffer]));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }

    //
    // Give the HAL access to the context dma.
    //
    pDecompress->HalObject.ReadData[Buffer].CtxDma = &pDecompress->ContextDmaData[Buffer]->HalInfo;

    return (RM_OK);
}
RM_STATUS class04ESetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    U032                        Buffer;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04ESetContextDmaImage\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    Buffer = (Offset - Method->Low) >> 2;

	if (Data == NV01_NULL_OBJECT)
    {
       	pDecompress->ContextDmaImage[Buffer] = NULL;
        pDecompress->HalObject.WriteImage[Buffer].CtxDma = NULL;
        return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
    }

    //
    // Set the data DMA contexts
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pDecompress->ContextDmaImage[Buffer]));
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }

    //
    // Give the HAL access to the context dma.
    //
    pDecompress->HalObject.WriteImage[Buffer].CtxDma = &pDecompress->ContextDmaImage[Buffer]->HalInfo;
    
    return (RM_OK);
}

RM_STATUS class04EReadData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EReadData\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, Offset, Data, &status);

    return status;
}

RM_STATUS class04EWriteImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEODECOMPRESSOROBJECT    pDecompress;
    RM_STATUS                   status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EWriteImage\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)Object;

    (void) nvHalMpMethod(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, &pDecompress->HalObject, Offset, Data, &status);

    return status;
}

//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

static void NotifyDataBuffer
(
	PHWINFO				        pDev,
    PVIDEODECOMPRESSOROBJECT    pDecompress,
    U032                        BuffNum
)
{
    notifyFillNotifierArray(pDev,  pDecompress->CBase.NotifyXlate, 
                            0, 
                            0, 
                            RM_OK, 
                            NV04E_NOTIFIERS_SET_DATA_NOTIFY(BuffNum) );

    if (pDecompress->HalObject.ReadData[BuffNum].Notify)
        osNotifyEvent(pDev, (POBJECT)pDecompress, 
                      NV04E_NOTIFIERS_SET_DATA_NOTIFY(BuffNum),
                      0, 
                      0, 
                      RM_OK, 
                      pDecompress->HalObject.ReadData[BuffNum].Notify);
}

static void NotifyImageBuffer
(
	PHWINFO				        pDev,
    PVIDEODECOMPRESSOROBJECT    pDecompress,
    U032                        BuffNum
)
{
    //
    // Only call the completion routine if one was expected
    //
    notifyFillNotifierArray(pDev,  pDecompress->CBase.NotifyXlate, 
                            0, 
                            0, 
                            RM_OK, 
                            NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(BuffNum) );
}

static VOID VideoEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_VIDEO_EVENT(0))
    {
        NotifyDataBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_VIDEO_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_VIDEO_EVENT(1))
    {
        NotifyDataBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_VIDEO_EVENT(1),
                                   pIntrStatus);
    }

    return;
}

static VOID AudioEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_AUDIO_EVENT(0))
    {
        NotifyDataBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_AUDIO_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_AUDIO_EVENT(1))
    {
        NotifyDataBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_AUDIO_EVENT(1),
                                   pIntrStatus);
    }

    return;
}

#ifdef NOTYET
static VOID ImageEvents
(
    PHWINFO pDev,
    PVIDEODECOMPRESSOROBJECT pDecompress,
    U032 *pIntrStatus
)
{
    VOID *pMpHalObj = &pDecompress->HalObject;
    U032 events = CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1);

    //
    // Call into HAL and get status on Video events.
    //
    (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, pMpHalObj, &events, pIntrStatus);

    //
    // If the pending bit comes back set, then the event needs servicing.
    //
    if (events & CLASS04E_IMAGE_EVENT(0))
    {
        NotifyImageBuffer(pDev, pDecompress, 0);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_IMAGE_EVENT(0),
                                   pIntrStatus);
    }

    if (events & CLASS04E_IMAGE_EVENT(1))
    {
        NotifyImageBuffer(pDev, pDecompress, 1);
        (void) nvHalMpServiceEvent(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR,
                                   pMpHalObj,
                                   CLASS04E_IMAGE_EVENT(1),
                                   pIntrStatus);
    }

    return;
}
#endif // NOTYET

//
// class04EService
//
V032 class04EService
(
    PHWINFO pDev
)
{
    PVIDEODECOMPRESSOROBJECT pDecompress;
    U032 eventsPending, intrStatus;

    //
    // Handle case where we don't have a current decompressor object.
    //
    pDecompress = (PVIDEODECOMPRESSOROBJECT)(pDev->MediaPort.CurrentDecompressor);
    if (pDecompress == NULL)
    {
        //
        // This exception is spurious.  Call into HAL to give it a
        // chance to reset the pending condition and then we're done.
        //
        eventsPending = 0xffffffff;
        (void) nvHalMpGetEventStatus(pDev, NV03_EXTERNAL_VIDEO_DECOMPRESSOR, NULL, &eventsPending, &intrStatus);
        return (intrStatus);
    }

    //
    // Process events.
    //
    VideoEvents(pDev, pDecompress, &intrStatus);
    AudioEvents(pDev, pDecompress, &intrStatus);
#ifdef NOTYET
    ImageEvents(pDev, pDecompress, &intrStatus);
#endif

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class050.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Monitor Bus Manager ******************************\
*                                                                           *
* Module: CLASS050.C                                                        *
*   This module implements the NV_EXTERNAL_MONITOR_BUS object               *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <class.h>
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#include <nv32.h>

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

RM_STATUS class050Create
(
	PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Create\r\n");
    //
    // Create the NV_EXTERNAL_PARALLEL_BUS object.
    //
    status = osAllocMem((VOID **)Object, sizeof(MONITORBUSOBJECT));
    if (status)
        return (status);
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, UserName);

    //
    // Initialize the new object structure.
    //
    pBus->Write.AddressSize = 0;
    pBus->Write.DataSize = 0;
    pBus->Write.Address  = 0;
    pBus->Write.Data     = 0;
    pBus->Read.AddressSize = 0;
    pBus->Read.DataSize  = 0;
    pBus->Read.Address   = 0;
    pBus->Read.Notify    = 0;
    pBus->InterruptNotifyPending = 0;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pBus->CBase, 
                                      pBus->CBase.ChID, 
                                      pBus->CInstance);
    if (status != RM_OK)
    {
        osFreeMem(*Object);
    }

    return(RM_OK);
}

RM_STATUS class050Destroy
(
	PHWINFO pDev,
    POBJECT Object
)
{
    PMONITORBUSOBJECT  pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Destroy\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pBus->CBase, pBus->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class050SetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050SetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class050Notify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Notify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class050StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050StopTransfer\r\n");
    return (RM_OK);
}


RM_STATUS class050Write
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Write\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Write.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Write.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Write.Address = Data;
            break;
        //
        // Set Data
        //
        case 0x08:

            pBus->Write.Data = Data;

            //
            // I2C Bus
            //
            //i2cWrite( (U008)pPioBus->Write.Address,
            //          pPioBus->Write.AddressSize-1,
            //          ((U008 *)&(pPioBus->Write.Address))+1,
            //          pPioBus->Write.DataSize,
            //          (U008 *)&(pPioBus->Write.Data));
                              
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}


RM_STATUS class050Read
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;
    U032                data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050Read\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Read.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Read.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Read.Address = Data;
            break;
        //
        // Get Data
        //
        case 0x08:

            pBus->Read.Notify = Data;

            //
            // I2C Bus
            //
            //i2cRead( (U008)pPioBus->Read.Address,
            //         pPioBus->Read.AddressSize-1,
            //         ((U008 *)&(pPioBus->Read.Address))+1,
            //         pPioBus->Read.DataSize,
            //         (U008 *)&(pPioBus->Read.Data));
            data32 = 0;
                                          
            //
            // Send back the data
            //
            notifyFillNotifierArray(pDev,  pBus->CBase.NotifyXlate, 
                                     data32, 
                                     0, 
                                     RM_OK, 
                                     NV050_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}

RM_STATUS class050SetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PMONITORBUSOBJECT   pBus;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class050SetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PMONITORBUSOBJECT)Object;
    
    //
    // Make sure the interrupt is enabled
    //
    
    return (RM_OK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class053.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_CONTEXT_SURFACES_ARGB_ZS *************************\
*                                                                           *
* Module: CLASS053.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACES_ARGB_ZS object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//
RM_STATUS class053SetClipHorizontal
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class053SetClipHorizontal\r\n");

    //
    // ERROR CHECKING??
    //

    return (status);
}

RM_STATUS class053SetClipVertical
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS               status = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class053SetClipVertical\r\n");

    //
    // ERROR CHECKING??
    //

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class051.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* Serial Bus Manager *******************************\
*                                                                           *
* Module: CLASS051.C                                                        *
*   This module implements the NV_EXTERNAL_SERIAL_BUS object                *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <class.h>
#include <dma.h>   
#include <modular.h>
#include <mp.h>
#include <os.h>
#include <vga.h>
#include <i2c.h>
#include <tmr.h>
#include <nv32.h>

// XXX hack - since BusType is unused, use it as a flag to indicate autoincrement mode
#define SET_AUTO_INCREMENT_FLAG(v)    pBus->BusType = (v)
#define AUTO_INCREMENT_FLAG()         pBus->BusType

//
// Externs.
//

extern char strDevNodeRM[];
char strExternalSerialOnPrimary[] = "ExternalSerialOnPrimary";

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

RM_STATUS class051Create
(
	PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PSERIALBUSOBJECT    pBus;
    U032                data32;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Create\r\n");
    //
    // Create the NV_EXTERNAL_PARALLEL_BUS object.
    //
    status = osAllocMem((VOID **)Object, sizeof(SERIALBUSOBJECT));
    if (status)
        return (status);
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, UserName);

    //
    // Initialize the new object structure.
    //
    pBus->Write.AddressSize = 0;
    pBus->Write.DataSize = 0;
    pBus->Write.Address  = 0;
    pBus->Write.Data     = 0;
    pBus->Read.AddressSize = 0;
    pBus->Read.DataSize  = 0;
    pBus->Read.Address   = 0;
    pBus->Read.Notify    = 0;
    pBus->InterruptNotifyPending = 0;
	//
	// initialize the Default Port ID (only affects hw with multiple I2C ports)
	//
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strExternalSerialOnPrimary, &data32) == RM_OK) {
        pBus->DefaultPortID = NV_I2C_PORT_PRIMARY;
    }
    else {
        pBus->DefaultPortID = NV_I2C_PORT_SECONDARY;
    }

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pBus->CBase, 
                                      pBus->CBase.ChID, 
                                      pBus->CInstance);
    if (status != RM_OK)
    {
        osFreeMem(*Object);
    }

    SET_AUTO_INCREMENT_FLAG(0);



    return(RM_OK);

}

RM_STATUS class051Destroy
(
	PHWINFO pDev,
    POBJECT Object
)
{
    PSERIALBUSOBJECT  pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Destroy\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pBus->CBase, pBus->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class051SetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051SetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class051Notify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Notify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class051StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051StopTransfer\r\n");
    return (RM_OK);
}


RM_STATUS class051Write
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;
    U008               lock;
    U032               NoStopFlag;
    U032               portID;
    U032               Head = 0;    // TO DO: make the class usable on other heads
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Write\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Write.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Write.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Write.Address = Data;
            SET_AUTO_INCREMENT_FLAG(0);
            break;
        //
        // Set Data
        //
        case 0x08:

            pBus->Write.Data = Data;

            // unlock the extended regs
            lock = UnlockCRTC(pDev, Head);

            //
            // I2C Bus
            //
            //
            // Check for the hack I2C interface on the MPC daughterboard
            //
            if ((pBus->Write.Address & 0xFF) == pDev->MediaPort.HalInfo.MPCDeviceAddr) {
                i2cWrite_ALT( pDev, Head, pBus->DefaultPortID, 
                          (U008)pBus->Write.Address,
                          (U016)(pBus->Write.AddressSize-1),
                          ((U008 *)&(pBus->Write.Address))+1,
                          pBus->Write.DataSize,
                          (U008 *)&(pBus->Write.Data));
			}
            else {
				// check for override of DefaultPortID 
				// (XXX temporary until PortID is added as a method )
			    if ( pBus->Write.AddressSize & 0x8000 ) {
				    pBus->Write.AddressSize &= 0x7fff;
					portID = NV_I2C_PORT_PRIMARY;
				}
				else {
					portID = pBus->DefaultPortID;
				}

                NoStopFlag = Data & 0xFF000000;
                if ( ((pBus->Write.DataSize <= 3) && NoStopFlag) || AUTO_INCREMENT_FLAG() ) {
                    if ( AUTO_INCREMENT_FLAG() ) {
                        i2cSend ( pDev, Head, portID,
                                  (U008)0,
                                  (U016)0,
                                  NULL,
                                  pBus->Write.DataSize,
                                  (U008 *)&(pBus->Write.Data),
                                  NoStopFlag);
                    }
                    else {
                        i2cSend ( pDev, Head, portID,
                                  (U008)pBus->Write.Address,
                                  (U016)(pBus->Write.AddressSize-1),
                                  ((U008 *)&(pBus->Write.Address))+1,
                                  pBus->Write.DataSize,
                                  (U008 *)&(pBus->Write.Data),
                                  NoStopFlag);
                        SET_AUTO_INCREMENT_FLAG(1);
                    }
                    if ( NoStopFlag == 0 )
                        SET_AUTO_INCREMENT_FLAG(0);
                }
                else {
                    i2cWrite( pDev, Head, portID,
                              (U008)pBus->Write.Address,
                              (U016)(pBus->Write.AddressSize-1),
                              ((U008 *)&(pBus->Write.Address))+1,
                              pBus->Write.DataSize,
                              (U008 *)&(pBus->Write.Data));
                }
			}
               
            RestoreLock(pDev, Head, lock);                              
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}


RM_STATUS class051Read
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;
    U032               val32;
    U008               lock;
    U032               Head = 0;    // TO DO: make the class usable on other heads

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051Read\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;

    //
    // Process the write request.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Size
        //
        case 0x00:
            pBus->Read.DataSize = (U016)(Data & 0x0000FFFF);
            pBus->Read.AddressSize = (U016)((Data >> 16) & 0x0000FFFF);
            break;
        //
        // Set Address
        //
        case 0x04:
            pBus->Read.Address = Data;
            break;
        //
        // Get Data
        //
        case 0x08:

            pBus->Read.Notify = Data;

            //
            // I2C Bus
            //
            lock = UnlockCRTC(pDev, Head);
                   
            //
            // Check for the hack I2C interface on the MPC daughterboard
            //
            if ((pBus->Read.Address & 0xFF) == pDev->MediaPort.HalInfo.MPCDeviceAddr) {
                i2cRead_ALT( pDev, Head, pBus->DefaultPortID, 
                         (U008)pBus->Read.Address,
                         (U016)(pBus->Read.AddressSize-1),
                         ((U008 *)&(pBus->Read.Address))+1,
                         pBus->Read.DataSize,
                         (U008 *)&(val32));
			}
            else {
				// check for override of DefaultPortID 
				// (XXX temporary until PortID is added as a method )
			    if ( pBus->Read.AddressSize & 0x8000 ) {
				    pBus->Read.AddressSize &= 0x7fff;
					i2cRead( pDev, Head, NV_I2C_PORT_PRIMARY,
							 (U008)pBus->Read.Address,
							 (U016)(pBus->Read.AddressSize-1),
							 ((U008 *)&(pBus->Read.Address))+1,
							 pBus->Read.DataSize,
							 (U008 *)&(val32));
				}
				else {
					i2cRead( pDev, Head, pBus->DefaultPortID,
							 (U008)pBus->Read.Address,
							 (U016)(pBus->Read.AddressSize-1),
							 ((U008 *)&(pBus->Read.Address))+1,
							 pBus->Read.DataSize,
							 (U008 *)&(val32));
				}
			}
                           
            RestoreLock(pDev, Head, lock);
                              
            //
            // Send back the data
            //
            notifyFillNotifierArray( pDev, pBus->CBase.NotifyXlate, 
                                     val32,
                                     0, 
                                     RM_OK, 
                                     NV051_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            break;
            
        default:
            break;            

    }
    return (RM_OK);
}

RM_STATUS class051SetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PSERIALBUSOBJECT   pBus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class051SetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PSERIALBUSOBJECT)Object;
    
    //
    // Make sure the interrupt is enabled
    //
    
    return (RM_OK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class04f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <nvhw.h>
#include <nv32.h>

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/mp/mpobj.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FSetContextDmaNotifies\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04FNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS class04FStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PPARALLELBUSOBJECT pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FStopTransfer\r\n");

    pBus = (PPARALLELBUSOBJECT)Object;

    //
    // Probably should error check this data again NV04F_STOP_TRANSFER_VALUE.
    //
    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, NV04F_STOP_TRANSFER, Data, &status);

    return (status);
}

RM_STATUS class04FWrite
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT      pBus;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FWrite\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    return (status);
}


RM_STATUS class04FRead
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT      pBus;
    PPARALLELBUSHALOBJECT   pBusHalObj;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FRead\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;
    pBusHalObj = (PPARALLELBUSHALOBJECT)&pBus->HalObject;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    //
    // If this is the transfer method, handle posting of the notify.
    //
    switch (Offset - Method->Low)
    {
        //
        // Get Data
        //
        case 0x08:

            //
            // Send back the data.
            // XXX (scottl):  should 'status' be written to notify
            // area in this case?
            //
            notifyFillNotifierArray(pDev,  pBus->CBase.NotifyXlate, 
                                    pBusHalObj->Read.ReadData,
                                    0, 
                                    RM_OK, 
                                    NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY );
            
            //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "r");
            
            //tmrDelay(100000);         // 500ns delay    
            
            break;
        default:
            break;            
    }

    return (status);
}

RM_STATUS class04FSetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PPARALLELBUSOBJECT   pBus;
    RM_STATUS status;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04FSetInterruptNotify\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pBus = (PPARALLELBUSOBJECT)Object;

    //
    // Set the notify data
    //
    pBus->InterruptNotifyPending = Data;

    (void) nvHalMpMethod(pDev, NV1_EXTERNAL_PARALLEL_BUS, &pBus->HalObject, Offset, Data, &status);

    return (status);
}    


//---------------------------------------------------------------------------
//
// Exception Handling
//
//---------------------------------------------------------------------------

//
// Handle parallel bus portion of MediaPort exceptions.
//
V032 class04FService
(
    PHWINFO pDev
)
{
    PPARALLELBUSOBJECT pParallelBus;
    VOID *pMpHalObj;
    U032 eventPending = CLASS04F_PBUS_EVENT;
    V032 intrStatus = 0;

    //
    // Handle parallel bus exceptions.
    //
    pParallelBus = (PPARALLELBUSOBJECT)(pDev->MediaPort.CurrentParallelBusObj);
    if (pParallelBus)
        pMpHalObj = (VOID *)&pParallelBus->HalObject;
    else
        pMpHalObj = NULL;

    //
    // Call into the HAL to get pending status.
    //
    (void) nvHalMpGetEventStatus(pDev, NV01_EXTERNAL_PARALLEL_BUS, pMpHalObj, &eventPending, &intrStatus);

    //
    // Now process any pending events.
    //
    if (pParallelBus && eventPending == CLASS04F_PBUS_EVENT)
    {    
         notifyFillNotifierArray(pDev, pParallelBus->CBase.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY );

        if (pParallelBus->InterruptNotifyPending)
            osNotifyEvent(pDev, (POBJECT)pParallelBus,
                          NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY,
                          0, 
                          1, 
                          RM_OK, 
                          pParallelBus->InterruptNotifyPending);

        //
        // This is a single-shot notify.  Clear the notify type.
        //
        pParallelBus->InterruptNotifyPending = 0;            
    }

    //
    // Call into HAL to finish processing exception (will clear
    // pending bit in interrupt register).
    //
    (void) nvHalMpServiceEvent(pDev, NV01_EXTERNAL_PARALLEL_BUS, pMpHalObj, eventPending, &intrStatus);

    return (intrStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class055.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* NV4_DX6_MULTI_TEXTURE_TRIANGLE ************************\
*                                                                           *
* Module: CLASS055.C                                                        *
*   This module implements the NV4_DX6_MULTI_TEXTURE_TRIANGLE object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class052.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_CONTEXT_SURFACE_SWIZZLED ************************\
*                                                                           *
* Module: CLASS052.C                                                        *
*   This module implements the NV4_CONTEXT_SURFACE_SWIZZLED object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class054.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_DX5_TEXTURED_TRIANGLE **************************\
*                                                                           *
* Module: CLASS054.C                                                        *
*   This module implements the NV4_DX5_TEXTURED_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class057.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_CONTEXT_COLOR_KEY ****************************\
*                                                                           *
* Module: CLASS057.C                                                        *
*   This module implements the NV4_CONTEXT_COLOR_KEY object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class058.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_0 ****************************\
*                                                                           *
* Module: CLASS058.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_0 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class056.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_CELSIUS_PRIMITIVE **************************\
*                                                                           *
* Module: CLASS056.C                                                        *
*   This module implements the NV10_CELSIUS_PRIMITIVE object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_2 ****************************\
*                                                                           *
* Module: CLASS05A.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_2 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_3 ****************************\
*                                                                           *
* Module: CLASS05B.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_3 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class059.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV3_CONTEXT_SURFACE_1 ****************************\
*                                                                           *
* Module: CLASS059.C                                                        *
*   This module implements the NV3_CONTEXT_SURFACE_1 object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ NV4_RENDER_SOLID_LIN *****************************\
*                                                                           *
* Module: CLASS05C.C                                                        *
*   This module implements the NV4_RENDER_SOLID_LIN object class            *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05CValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05CSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //            
                andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05CSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05CSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;
    U032                    andMask, orMask;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05CSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05CValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05d.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV4_RENDER_SOLID_TRIANGLE **************************\
*                                                                           *
* Module: CLASS05D.C                                                        *
*   This module implements the NV4_RENDER_SOLID_TRIANGLE object class       *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05DValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05DSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask =  DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05DSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05DSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05DSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05DValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class061.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV4_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS061.C                                                        *
*   This module implements the NV4_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class061Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class061SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class061SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class061SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class061SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class061SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class061Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class062.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_CONTEXT_SURFACES_2D ***************************\
*                                                                           *
* Module: CLASS062.C                                                        *
*   This module implements the NV10_CONTEXT_SURFACES_2D object class        *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class060.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_INDEXED_IMAGE_FROM_CPU **************************\
*                                                                           *
* Module: CLASS060.C                                                        *
*   This module implements the NV4_INDEXED_IMAGE_FROM_CPU object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"
#include "nvhw.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class060Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class060SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class060SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class060SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class060Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class060SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class060SetColorConversion\r\n");

    //
    // If we're an NV10, kick it back as an error, since POSTDITHER_2D lives
    // in PGRAPH_DEBUG_2 there (and NV5_INDEXED_IMAGE should be used anyway).
    //
    if (IsNV10orBetter(pDev))
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode.
    //
    // Since this comes in as a synchronous graphics exception, we can
    // assume we own the channel and can change the dither mode.
    //
    // The HAL graphics exception handler will be sure that we modify the
    // hardware, so we just handle error checking here.
    // 
    if ((Data != NV064_SET_COLOR_CONVERSION_DITHER) &&
        (Data != NV064_SET_COLOR_CONVERSION_TRUNCATE))
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
        return (NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05e.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV4_RENDER_SOLID_RECTANGLE **************************\
*                                                                           *
* Module: CLASS05E.C                                                        *
*   This module implements the NV4_RENDER_SOLID_RECTANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05EValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05ESetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05ESetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05ESetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05ESetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05EValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class05f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV4_IMAGE_BLIT *********************************\
*                                                                           *
* Module: CLASS05F.C                                                        *
*   This module implements the NV4_IMAGE_BLIT object class                  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class05FValidate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class05FSetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05FSetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class05FSetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetContextSurfaces2d
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class05FSetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class05FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class05FValidate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class064.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************* NV05_INDEXED_IMAGE_FROM_CPU **************************\
*                                                                           *
* Module: CLASS064.C                                                        *
*   This module implements the NV05_INDEXED_IMAGE_FROM_CPU object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class064Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class064SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class064SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        andMask = 0xffffffff;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class064SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class064Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class064SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class064SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV064_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class063.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV05_SCALED_IMAGE_FROM_MEMORY ************************\
*                                                                           *
* Module: class063.C                                                        *
*   This module implements the NV05_SCALED_IMAGE_FROM_MEMORY object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class063Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class063SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.  
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class063SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class063SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
                
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class063SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class063Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class063SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class063SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV063_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV063_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class067.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class067.C                                                        *
*   This module implements the NV10_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class067SetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    
    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate, 
                              0, 
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class067SetNotifyCtxDma

RM_STATUS class067SetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067SetNotify

RM_STATUS class067StopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopImage\r\n");

    // class067 supports only one head (head 0)
    dacDisableImage(pDev, 0);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopImage

RM_STATUS class067StopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopLUT\r\n");
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopLUT

RM_STATUS class067StopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, Head);

    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopCursorImage

RM_STATUS class067StopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067StopDAC\r\n");

    // class067 supports only one head (head 0).
    dacDisableDac(pDev, 0);

    // reset display type
    SETDISPLAYTYPE(pDev, 0, 0xffffffff);
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067StopDAC

RM_STATUS class067SetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;
    
    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetImageCtxDma

RM_STATUS class067SetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;
    
    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma, 
                              0, 
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class067SetLUTCtxDma

RM_STATUS class067SetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV067_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;
    
    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma, 
                              0, 
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class067SetCursorCtxDma

RM_STATUS class067SetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // For this head, this becomes the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV067_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class067SetPanOffset

RM_STATUS class067GetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067GetOffset\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 
                                         pVidLutCurDac->Image[Data].Offset, 
                                         NV067_NOTIFICATION_INFO16_VALID_OFFSET, 
                                         NV067_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV067_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE; 
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class067GetOffset

// This proc writes the notification for an image buffer.
RM_STATUS class067ImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // increment the flip count and send it back through the notifier
    pVidLutCurDac->CompletedFlipCount++;

    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                pVidLutCurDac->CompletedFlipCount, // Info32
                                0, 
                                Status,
                                NV067_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    U032    Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV067_SET_IMAGE_OFFSET(0):
        case NV067_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV067_SET_IMAGE_FORMAT(0):
        case NV067_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  startAddr;
            U032  when, flags;
            
            buffNum = (Offset == NV067_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;
            
            when = (Data >> DRF_SHIFT(NV067_SET_IMAGE_FORMAT_WHEN)) & DRF_MASK(NV067_SET_IMAGE_FORMAT_WHEN);
            flags = DRF_VAL(067, _SET_IMAGE_FORMAT, _FLAGS, Data);
            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;

            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) 
            {
                // Change the default flip functionality to end of hsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10);
            }
            else
            {
                // Change the default flip functionality to end of vsync.
                FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);
            }

            // Program the hardware.
            // The imageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr) + 
                               pVidLutCurDac->Image[buffNum].Offset);
            // add in the panning offset
            startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

            status = dacProgramVideoStart(pDev, Head, startAddr, pitch);
            if (status) 
            {
                pVidLutCurDac->Image[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
            }
            if (when == NV067_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
            {
                // Do the notify right here.
                class067ImageNotify(pDev, (POBJECT)pVidLutCurDac, 
                                    0 /* param 1*/, buffNum,
                                    NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
            }
            else
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class067ImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next    = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2  = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags   = 0;

                if (flags & NV067_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class067SetImageValues

// This proc is called from VBlank to program the LUT.
RM_STATUS class067ProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032*     startAddr;
    U032      numEntries;
    U032      Head = 0;   // single-head class

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset, 
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, Head, startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                myStatus,
                                NV067_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          myStatus, 
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;   
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class067SetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV067_SET_LUT_OFFSET(0):
        case NV067_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV067_SET_LUT_FORMAT(0):
        case NV067_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV067_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class067ProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class067CursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate) 
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                Status,
                                NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                          NV067_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */, 
                          0 /* Data */, 
                          Status, 
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;   
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class067SetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorImageValues\r\n");
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV067_SET_CURSOR_IMAGE_OFFSET(0):
        case NV067_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV067_SET_CURSOR_IMAGE_FORMAT(0):
        case NV067_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            U032 Head = 0; // single-head class
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV067_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width = 
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =  
                (Data >> DRF_SHIFT(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV067_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) + 
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            status = nvHalDacProgramCursorImage(pDev, startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width, 
                                           pVidLutCurDac->CursorImage[buffNum].Height, 
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status) 
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, Head);

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class067CursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
    
                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class067SetCursorImageValues

// This proc is called from VBlank to program the cursor position.
RM_STATUS class067ProgramCursorPoint
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Data,
    V032      DummyParm,
    RM_STATUS Status
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 Head = 0;   // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, Head,
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
                                      
    // signal that the callback is done
    pVidLutCurDac->CursorPointCallback.Proc = NULL;
    
    return (NV067_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class067ProgramCursorPoint()

RM_STATUS class067SetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         Head = 0;   // single-head class
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetCursorPoint\r\n");
    
    // update the cursor position
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    pVidLutCurDac->CursorPointCallback.Param1      = Data;
    if (pVidLutCurDac->CursorPointCallback.Proc == NULL)
    {
        // add the cursor position callback
        pVidLutCurDac->CursorPointCallback.Proc    = class067ProgramCursorPoint;
        pVidLutCurDac->CursorPointCallback.Object  = (POBJECT)pVidLutCurDac;
        pVidLutCurDac->CursorPointCallback.Next    = NULL;
        pVidLutCurDac->CursorPointCallback.Param2  = 0;
        pVidLutCurDac->CursorPointCallback.Status  = NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        VBlankAddCallback(pDev, Head, &(pVidLutCurDac->CursorPointCallback));
    }
    
    return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class067SetCursorPoint

RM_STATUS class067SetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class067SetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV067_SET_DAC_IMAGE_SIZE(0):
        case NV067_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.    
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048. 
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV067_SET_DAC_HORIZONTAL_BLANK(0):
        case NV067_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV067_SET_DAC_HORIZONTAL_SYNC(0):
        case NV067_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256. 
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set Vertical Blank
        //
        case NV067_SET_DAC_VERTICAL_BLANK(0):
        case NV067_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV067_SET_DAC_VERTICAL_SYNC(0):
        case NV067_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV067_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.    
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16. 
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        //
        // Set total size.
        //
        case NV067_SET_DAC_TOTAL_SIZE(0):
        case NV067_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV067_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.    
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2. 
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
                
            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
            
        // Set pixel clock.
        case NV067_SET_DAC_PIXEL_CLOCK(0):
        case NV067_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV067_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV067_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV067_SET_DAC_FORMAT(0):
        case NV067_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV067_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV067_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV067_SET_DAC_FORMAT_COLOR);

			switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
				case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
					pDev->Dac.HalInfo.Depth = 8;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
					pDev->Dac.HalInfo.Depth = 15;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
					pDev->Dac.HalInfo.Depth = 16;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
					break;
				case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
					pDev->Dac.HalInfo.Depth = 32;
					// pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
					break;
			}

            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice = 
                DRF_VAL(067, _SET_DAC_FORMAT, _PRIMARY_DEVICE, Data);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV067_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;
            
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;   

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.PixelDepth              = pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;

            // Get output device...
            pVidLutCurDac->DisplayType		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV067_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid display type ", pVidLutCurDac->DisplayType);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard		  = (Data >> DRF_SHIFT(NV067_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV067_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class067: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);

            if (pVidLutCurDac->CBase.NotifyXlate) 
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0, 
                                                 modeSetStatus,
                                                 NV067_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac, 
                                  NV067_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */, 
                                  0 /* Data */, 
                                  modeSetStatus, 
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;   

            return modeSetStatus;
        }
        
        default:
            return NV067_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class067SetDACValues
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class066.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV05_STRETCHED_IMAGE_FROM_CPU ************************\
*                                                                           *
* Module: CLASS066.C                                                        *
*   This module implements the NV05_STRETCHED_IMAGE_FROM_CPU object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class066Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class066SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class066SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class066SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}

RM_STATUS class066SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV066_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}

RM_STATUS class066SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class066SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class066Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class072.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV4_CONTEXT_BETA *******************************\
*                                                                           *
* Module: CLASS072.C                                                        *
*   This module implements the NV4_CONTEXT_BETA object class                *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class065.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV05_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS065.C                                                        *
*   This module implements the NV05_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class065Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class065SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextClip
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class065SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0 );
    
    return (status);
}


RM_STATUS class065SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class065SetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class065Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}

RM_STATUS class065SetColorConversion
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class065SetColorConversion\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Set the dither mode
    //
    switch (Data)
    {
        case NV065_SET_COLOR_CONVERSION_DITHER:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_DITHER),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_TRUNCATE),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        case NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE:
            nvHalGrSetObjectContext(pDev,
                                    ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_DITHER_MODE)),
                                    DRF_NUM(_PGRAPH, _CTX_SWITCH1, _DITHER_MODE, NV_PGRAPH_CTX_SWITCH1_DITHER_MODE_MS),
                                    pRenderObject->Common.Base.ChID,
                                    pRenderObject->Common.Instance);
            break;
        default:
            //
            // Data invalid.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetColorConversion with invalid data: ", Data);
            return (NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class077.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_SCALED_IMAGE_FROM_MEMORY *************************\
*                                                                           *
* Module: CLASS077.C                                                        *
*   This module implements the NV4_SCALED_IMAGE_FROM_MEMORY object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class077Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
          ((pRenderObject->RCPatchContext.Surface != NULL) && 
           (pRenderObject->RCPatchContext.Surface->Base.Class->Type != NV4_CONTEXT_SURFACE_SWIZZLED)))  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class077SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class077SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    andMask = ~(DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE));

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        orMask = 0;
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
	        case NV4_CONTEXT_SURFACE_SWIZZLED:
                //
                // This is a valid swizzled object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _SWIZZLE, _ENABLE);
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
                
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class077SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class077SetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class077Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class076.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV4_STRETCHED_IMAGE_FROM_CPU *************************\
*                                                                           *
* Module: CLASS076.C                                                        *
*   This module implements the NV4_STRETCHED_IMAGE_FROM_CPU object class    *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class076Validate
(
	PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||  
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||  
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||  
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
	    (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;
    } else {
        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class076SetContextColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}


RM_STATUS class076SetContextPattern
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextRop
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta1
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextBeta4
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetContextSurface
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT) 
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
        
    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //            
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;
            
            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;
                
            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT); 
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, 0xffffffff, 0);
    
    return (status);
}


RM_STATUS class076SetOperation
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class076SetOperation\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS) 
    {
        //
        // Set the new value
        //
        andMask = ~(DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG) << DRF_SHIFT(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG));
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    //
    // Update object validation
    //
    status = class076Validate(pDev, pRenderObject, andMask, orMask);
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class07b.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_TEXTURE_FROM_CPU ***************************\
*                                                                           *
* Module: CLASS07B.C                                                        *
*   This module implements the NV10_TEXTURE_FROM_CPU object class           *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class07a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07a.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY methods.                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#if 0
static RM_STATUS class07AOverlayService(PHWINFO, POBJECT);
#endif

BOOL   HwOwnsBuffer(PHWINFO, U032, POBJECT);
extern VOID NV10_AdjustScalarForTV(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07ASetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    pOverlayHalObject = &pOverlayObject->HalObject;
    
    if (pOverlayObject->CBase.NotifyTrigger)
        return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->CBase.NotifyXlate));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pOverlayObject->CBase.NotifyXlate, 
                              0, 
                              (3 * 0x0010));
    if (status)
    {
        pOverlayObject->CBase.NotifyXlate = NULL;
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    
    return (status);
} // end of class07ASetNotifyCtxDma

RM_STATUS class07ASetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    pOverlayObject->CBase.NotifyAction  = Data;
    pOverlayObject->CBase.NotifyTrigger = TRUE;
    
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07ASetNotify

RM_STATUS class07AStopOverlay
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    RM_STATUS                    status;
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;


    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

    return status;
} // end of class07AStopOverlay

RM_STATUS class07ASetOverlayCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U032                         buffNum;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    buffNum = (Offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;

    //
    // Give HAL a chance to reject this method.
    //
    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
    if (status)
        return (status);

    if (Data == NV01_NULL_OBJECT)
    {
        pOverlayObject->Overlay[buffNum].OverlayCtxDma = NULL;
        pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = NULL;
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pOverlayObject->Overlay[buffNum].OverlayCtxDma));
    if (status)
        return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    
    // The overlay context dma MUST point to the frame buffer.
    if (pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo.AddressSpace != ADDR_FBMEM)
    {
        return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }

    // Give HAL access to context dma.
    pOverlayObject->HalObject.Overlay[buffNum].OverlayCtxDma = &pOverlayObject->Overlay[buffNum].OverlayCtxDma->HalInfo;

    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07ASetOverlayCtxDma

RM_STATUS class07AGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07AGetOffset\r\n");
    
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;
    if (!pOverlayObject->CBase.NotifyTrigger)
        // nothing to do.
        return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification. 
    // Write the image offset in the INFO32 of the notification.
    if (pOverlayObject->CBase.NotifyXlate) 
    {
        //
        // Give HAL chance to setup offset if necessary.
        //
        (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
        if (status)
            return status;
        status = notifyFillNotifierArray(pDev, pOverlayObject->CBase.NotifyXlate, 
                                         pOverlayObject->HalObject.Overlay[Data].Offset,   // info32
                                         NV07A_NOTIFICATION_INFO16_VALID_OFFSET, // info16
                                         NV07A_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07A_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pOverlayObject->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pOverlayObject, 
                          NV07A_NOTIFIERS_NOTIFY,
                          0 /* Method */, 
                          0 /* Data */, 
                          status, 
                          pOverlayObject->CBase.NotifyAction);
        }
    }

    pOverlayObject->CBase.NotifyTrigger = FALSE; 
    return (NV07A_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07AGetOffset

RM_STATUS class07ASetOverlayValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayValues\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    // Initialize the overlay description.
    //
    switch (Offset)
    {
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);
            return status;
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            RM_STATUS status;
            U032 buffNum;

            buffNum = (Offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            // Check to see if we should awaken and notify 
            if (Data & 0x80000000 ) {
                // if so, set the appropriate action
                //pOverlayObject->Overlay[buffNum].NotifyAction = NV_OS_WRITE_THEN_AWAKEN;
                pOverlayObject->Overlay[buffNum].NotifyAction = 1;
            
            }

            (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, &pOverlayObject->HalObject, Offset, Data, &status);

            //
            // Ensure class-dependent video service handler is
            // setup properly.
            //
            if (status == RM_OK)
            {
                pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pOverlayObject;
                pDev->pOverlayServiceHandler = videoOverlayService;
            }
            return status;
        }
        default:
            return NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07ASetOverlayValues

RM_STATUS class07ASetOverlayPointOutNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayPointOutNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);
    
    return status;
}

RM_STATUS class07ASetOverlayLuminanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayLuminanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}

RM_STATUS class07ASetOverlayChrominanceNow
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_OVERLAY_OBJECT       pOverlayObject;
    RM_STATUS                   status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07ASetOverlayChrominanceNow\r\n");

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV10_VIDEO_OVERLAY, (VOID *)&pOverlayObject->HalObject, Offset, Data, &status);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class089.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************** NV10_SCALED_IMAGE_FROM_MEMORY ************************\
*                                                                           *
* Module: class089.C                                                        *
*   This module implements the NV10_SCALED_IMAGE_FROM_MEMORY object class   *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class08a.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_IMAGE_FROM_CPU ******************************\
*                                                                           *
* Module: CLASS08A.C                                                        *
*   This module implements the NV10_IMAGE_FROM_CPU object class              *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class07c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class07C.C                                                        *
*   This module implements the NV15_VIDEO_LUT_CURSOR_DAC object class and   *
*   its corresponding methods.                                              *
*                                                                           *
*   For now, support for NV20_VIDEO_LUT_CURSOR_DAC is in here as well.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

#define IS_2D_BASED_FLIP(pDev, Object)    \
    ((pDev)->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)(Object))

static VOID class07CSetScreenDeltaXY(PHWINFO, PVIDEO_LUT_CURSOR_DAC_OBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class07CSetNotifyCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->CBase.NotifyTrigger          ||
        pVidLutCurDac->Image[0].NotifyTrigger       ||
        pVidLutCurDac->Image[1].NotifyTrigger       ||
        pVidLutCurDac->LUT[0].NotifyTrigger       ||
        pVidLutCurDac->LUT[1].NotifyTrigger       ||
        pVidLutCurDac->CursorImage[0].NotifyTrigger ||
        pVidLutCurDac->CursorImage[1].NotifyTrigger ||
        pVidLutCurDac->Dac[0].NotifyTrigger         ||
        pVidLutCurDac->Dac[1].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CBase.NotifyXlate));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidLutCurDac->CBase.NotifyXlate,
                              0,
                              (9 * 0x0010));
    if (status)
    {
        pVidLutCurDac->CBase.NotifyXlate = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return (status);
} // end of class07CSetNotifyCtxDma

RM_STATUS class07CSetNotify
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CBase.NotifyAction  = Data;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CSetNotify

RM_STATUS class07CStopImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopImage\r\n");

    dacDisableImage(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopImage

RM_STATUS class07CStopLUT
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopLUT\r\n");
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopLUT

RM_STATUS class07CStopCursorImage
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopCursorImage\r\n");

    //
    // Disable the current cursor.  Note this will currently not preempt any
    // pending notifies via our vblank callback mechanism.  Should probably
    // add that at some point.
    //
    dacDisableCursor(pDev, DACGETHEAD(pVidLutCurDac));

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CStopCursorImage

RM_STATUS class07CStopDAC
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CStopDAC\r\n");

    // only allow this method if this object was the last one to set a mode on this head
    if (pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac == (VOID_PTR)pVidLutCurDac)
    {
        dacDisableDac(pDev, DACGETHEAD(pVidLutCurDac));

        // reset display type
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), 0xffffffff);
    }
    
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
    
} // end of class07CStopDAC

RM_STATUS class07CSetImageCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_IMAGE(0)) ? 0 : 1;

    if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Image[buffNum].ImageCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    // The image context dma must point to the frame buffer.
    if (pVidLutCurDac->Image[buffNum].ImageCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->Image[buffNum].ImageCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetImageCtxDma

RM_STATUS class07CSetLUTCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTCtxDma\r\n");
    //
    // Set the Image DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_LUT(0)) ? 0 : 1;

    if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->LUT[buffNum].LUTCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->LUT[buffNum].LUTCtxDma,
                              0,
                              0x400);
    if (status)
    {
        pVidLutCurDac->LUT[buffNum].LUTCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of  class07CSetLUTCtxDma

RM_STATUS class07CSetCursorCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorCtxDma\r\n");
    //
    // Set the Cursor DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    buffNum = (Offset == NV07C_SET_CONTEXT_DMA_CURSOR(0)) ? 0 : 1;

    if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // Validate the dma context.
    //
    status = dmaValidateXlate(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma,
                              0,
                              0x800);
    if (status)
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }
    // The cursor image context dma must point to the frame buffer.
    if (pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->HalInfo.AddressSpace != ADDR_FBMEM) 
    {
        pVidLutCurDac->CursorImage[buffNum].CursorCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class07CSetCursorCtxDma


RM_STATUS class07CSetPanOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // only 2D panning flips should occur here
    RM_ASSERT(IS_2D_BASED_FLIP(pDev, Object));

    // determine screen delta x,y from the previous/new pan offset
    class07CSetScreenDeltaXY(pDev, pVidLutCurDac, Data);

    // For this head, set the current pan offset
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset = Data;

    // 
    // Set Image[].Offset (like the NV07C_SET_IMAGE_OFFSET method) to this
    // heads CurrentImageOffset. Note, we're assuming the display driver is
    // doing its flips through buffNum0 (similar to the mode set).
    //
    pVidLutCurDac->Image[0x0].Offset =
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset;

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetPanOffset

RM_STATUS class07CSetSemaphoreCtxDma
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreCtxDma\r\n");

    //
    // Set the semaphore DMA context.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaCtxdma: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    if (Data == NV01_NULL_OBJECT)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    //
    // Connect to dma buffer.
    //
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidLutCurDac->Semaphore.SemaphoreCtxDma));
    if (status)
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    //
    // There are some rules on alignment of both base/offset.
    // The hardware expects a single page of memory.
    //

    //
    // Validate the dma context.
    // Needs to be one page big at least.
    //
    status = dmaValidateXlate(pVidLutCurDac->Semaphore.SemaphoreCtxDma,
                              0,
                              0x1000);
    if (status)
    {
        pVidLutCurDac->Semaphore.SemaphoreCtxDma = NULL;
        return (NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
} // end of class07CSetSemaphoreCtxDma

RM_STATUS class07CSetSemaphoreOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreOffset: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;


    if (pVidLutCurDac->Semaphore.ReleaseTrigger)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: SetSemaOffset: trigger active!\n");
        DBG_BREAKPOINT();
        return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
    }

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    //
    // Alignment check...for the host, 4byte aligned is OK.
    //
    // Note that for nv20 graphics (kelvin) release methods, the
    // alignment must be 16byte to workaround a hw bug.
    //
    if (Data & 0x3)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);

    pVidLutCurDac->Semaphore.Offset = Data;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetSemaphoreRelease
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 *ReleaseAddr;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetSemaphoreRelease: ", Data);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Better have the semaphore ctxdma plugged in.
    //
    if (pVidLutCurDac->Semaphore.SemaphoreCtxDma == NULL)
        return (NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE);

    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: semaphore trigger active!\n");
        DBG_BREAKPOINT();
        return (NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);
    }

    status = dmaGetMappedAddress(pDev, pVidLutCurDac->Semaphore.SemaphoreCtxDma, pVidLutCurDac->Semaphore.Offset, 0x0003, (VOID **)&(ReleaseAddr));
    if (status)
        return (status);

    //
    // The actual release will occur after the next flip...
    //
    pVidLutCurDac->Semaphore.ReleaseAddr = ReleaseAddr;
    pVidLutCurDac->Semaphore.ReleaseValue = Data;
    pVidLutCurDac->Semaphore.ReleaseTrigger = TRUE;

    return status;

} // end of class07CSetSemaphoreOffset

RM_STATUS class07CSetOffsetRange
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         start, stop, polarity;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetOffsetRange\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->Polarity   = Data & 0x80000000;  // top bit is polarity (in/out of range)
    pVidLutCurDac->ScanRegion = Data & 0x7FFFFFFF;  // remaining bits are start/stop offsets

    // Extract the data (polarity indicates if the stall occurs inside or outside the start/stop range)
    start    = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_START)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_START);
    stop     = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_STOP)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_STOP);
    polarity = (Data >> DRF_SHIFT(NV07C_SET_OFFSET_RANGE_POLARITY)) & DRF_MASK(NV07C_SET_OFFSET_RANGE_POLARITY);

    // Program the hardware
    status = dacProgramScanRegion(pDev, DACGETHEAD(pVidLutCurDac), start, stop, polarity);

    if (status)
        return(NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    else
        return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class07CSetOffsetRange


RM_STATUS class07CGetOffset
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CGetOffset\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (!pVidLutCurDac->CBase.NotifyTrigger)
        // nothing to do.
        return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

    // The caller is expecting a notification.
    // Write the image offset in the INFO32 of the notification.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                         pVidLutCurDac->Image[Data].Offset,
                                         NV07C_NOTIFICATION_INFO16_VALID_OFFSET,
                                         NV07C_NOTIFICATION_STATUS_DONE_SUCCESS,
                                         NV07C_NOTIFIERS_NOTIFY);
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CBase.NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_NOTIFY,
                          0 /* Method */,
                          0 /* Data */,
                          status,
                          pVidLutCurDac->CBase.NotifyAction);
        }
    }
    pVidLutCurDac->CBase.NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
} // end of class07CGetOffset

#ifdef DEBUG
//
// Print out the current read/write values and ASSERT that incrementing
// the read pointer will not put us into the stall condition
//
static U032 debug_hwflip = 0;

// these PGRAPH_SURFACE fields are common to nv15/nv11/nv20
#define NV_PGRAPH_SURFACE                                0x00400710 /* RW-4R */
#define NV_PGRAPH_SURFACE_WRITE_3D                            22:20 /* RWIVF */
#define NV_PGRAPH_SURFACE_READ_3D                             26:24 /* RWIVF */
#define NV_PGRAPH_SURFACE_MODULO_3D                           30:28 /* RWIVF */

#define DBG_PRINT_READ_WRITE_3D_STATE()                                            \
    if (debug_hwflip) {                                                            \
        U032 m,r,w;                                                                \
        U032 surface = REG_RD32(NV_PGRAPH_SURFACE);                                \
                                                                                   \
        m = DRF_VAL(_PGRAPH, _SURFACE, _MODULO_3D, surface);                       \
        r = DRF_VAL(_PGRAPH, _SURFACE, _READ_3D,   surface);                       \
        w = DRF_VAL(_PGRAPH, _SURFACE, _WRITE_3D,  surface);                       \
                                                                                   \
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: hwflip write = ", w);   \
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM:         read = ", r);   \
        RM_ASSERT(((r + 1) % m) != w);                                             \
    }
#define DBG_ASSERT_START_PROPERLY_LATCHED()                                            \
    if (debug_hwflip) {                                                                \
        U032 raster = REG_RD32(NV_PCRTC_RASTER);                                       \
        switch (raster & 0x3000)                                                       \
        {                                                                              \
            case 0x0000: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: latch 'display'\n");\
                         break;                                                        \
            case 0x1000: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: latch 'before'\n"); \
                         break;                                                        \
            case 0x2000: DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: latch 'after'\n");  \
                         break;                                                        \
        }                                                                              \
    }
#else
#define DBG_PRINT_READ_WRITE_3D_STATE()
#define DBG_ASSERT_START_PROPERLY_LATCHED()
#endif

// This proc writes the notification for an image buffer.
RM_STATUS class07CImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 startAddr;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // assert we're on the expected vblank
    RM_ASSERT(pVidLutCurDac->Image[BuffNum].ImageCallback.VBlankCount ==
              pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter);

    // Program the new start address
    startAddr = (U032)((size_t)(pVidLutCurDac->Image[BuffNum].ImageCtxDma->DescAddr) +
                pVidLutCurDac->Image[BuffNum].Offset);
    startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

    if (dacProgramVideoStart(pDev, DACGETHEAD(pVidLutCurDac), startAddr, pVidLutCurDac->Image[BuffNum].Pitch))
    {
        pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;
        return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;
    }

    // increment the flip count and send it back through the notifier
    pVidLutCurDac->CompletedFlipCount++;

    // Send all notifications
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate,
                                pVidLutCurDac->CompletedFlipCount, // Info32
                                0,
                                Status,
                                NV07C_NOTIFIERS_SET_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->Image[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->Image[BuffNum].NotifyAction);
        }
    }

    // Check if this is a 2D or 3D flip
    if (IS_2D_BASED_FLIP(pDev, Object)) {
        //
        // For 2D panning flips, on a head with an active video overlay, update
        // the window start since DDraw won't see this as windows move event.
        //
        if (pDev->Video.HalInfo.ActiveVideoOverlayObject &&
            (pDev->Video.HalInfo.Head == DACGETHEAD(pVidLutCurDac))) {

            videoUpdateWindowStart(pDev,
                                   pVidLutCurDac->Image[BuffNum].DeltaX,
                                   pVidLutCurDac->Image[BuffNum].DeltaY);
        }
    } else {
        //
        // For 3D flips, if this is a synchronized multihead flip, only
        // the last head that completes their flip will increment READ_3D.
        //
        if (pVidLutCurDac->Image[BuffNum].MultiSync) {
            pDev->Dac.MultiSyncCounter--;
            if (pDev->Dac.MultiSyncCounter == 0) {
                DBG_PRINT_READ_WRITE_3D_STATE();
                FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
                pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;
            }
        } else {
            DBG_PRINT_READ_WRITE_3D_STATE();
            FLD_WR_DRF_DEF(_PGRAPH, _INCREMENT, _READ_3D, _TRIGGER);
        }
    }

    DBG_ASSERT_START_PROPERLY_LATCHED();

    //
    // Handle semaphore release.
    //
    if (pVidLutCurDac->Semaphore.ReleaseTrigger == TRUE)
    {
        *pVidLutCurDac->Semaphore.ReleaseAddr = pVidLutCurDac->Semaphore.ReleaseValue;
        pVidLutCurDac->Semaphore.ReleaseTrigger = FALSE;
    }

    pVidLutCurDac->Image[BuffNum].NotifyTrigger = FALSE;

    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

static
VOID class07CSetScreenDeltaXY
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032 newPanOffset
)
{
    S032 pitch, bpp;
    S016 deltaX, deltaY;
    S016 oldDeltaX, oldDeltaY;
    S016 newDeltaX, newDeltaY;

    // set the pitch and bytes per pixel
    pitch = pVidLutCurDac->Image[0].Pitch;
    bpp   = (pVidLutCurDac->HalObject.Dac[0].PixelDepth + 1) >> 3; // bytes per pixel

    // if either is uninitialized, return avoiding a divide by 0
    if (!bpp || !pitch)
    {
        pVidLutCurDac->Image[0].DeltaX = 0;
        pVidLutCurDac->Image[0].DeltaY = 0;
        return;
    }

    // get x,y info from new pan offset
    newDeltaY = (S016)(newPanOffset / pitch);
    newDeltaX = (S016)(((newPanOffset) % pitch) / bpp);

    // get x,y info from current pan offset
    oldDeltaY = (S016)(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset / pitch);
    oldDeltaX = (S016)(((pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset) % pitch) / bpp);

    deltaY = (S016)(newDeltaY - oldDeltaY);
    deltaX = (S016)(newDeltaX - oldDeltaX);

    pVidLutCurDac->Image[0].DeltaX = deltaX;
    pVidLutCurDac->Image[0].DeltaY = deltaY;

    //
    // Keep a running tab of pan offset deltas for overlay.
    //
    pDev->Video.HalInfo.PanOffsetDeltaX[DACGETHEAD(pVidLutCurDac)] += deltaX;
    pDev->Video.HalInfo.PanOffsetDeltaY[DACGETHEAD(pVidLutCurDac)] += deltaY;
}

RM_STATUS class07CSetImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Image Offset
        //
        case NV07C_SET_IMAGE_OFFSET(0):
        case NV07C_SET_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x03) != 0)
                // The image offset must be a multiple of 4 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            // Save the CurrentImageOffset for this head
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentImageOffset = Data;
            pVidLutCurDac->Image[buffNum].Offset = Data;

            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Image Format
        //
        case NV07C_SET_IMAGE_FORMAT(0):
        case NV07C_SET_IMAGE_FORMAT(1):
        {
            U016  pitch;
            U032  when, multisync, flags;

            buffNum = (Offset == NV07C_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Image[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if (pVidLutCurDac->Image[buffNum].ImageCtxDma == NULL)
                return NV07C_NOTIFICATION_STATUS_ERROR_INVALID_STATE;

            // pitch is specified by bits 15:0.
            pitch = (U016) (Data & 0x0000ffff);
            if ((pitch & 0x3F) != 0)
                // the pitch must be a multiple of 64 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->Image[buffNum].Pitch = pitch;
            pDev->Dac.DisplayPitch = pitch;

            when = DRF_VAL(07C, _SET_IMAGE_FORMAT, _WHEN, Data);
            multisync = DRF_VAL(07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, Data);
            flags = DRF_VAL(07C, _SET_IMAGE_FORMAT, _FLAGS, Data);

            pVidLutCurDac->Image[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_IMAGE_FORMAT_NOTIFY))) ? 1 : 0;
            pVidLutCurDac->Image[buffNum].NotifyTrigger = TRUE;
            pVidLutCurDac->Image[buffNum].MultiSync = multisync;

            //
            // Always latch the startAddr at hsync, just control when it's written
            // (either now, or during vsync). XXX shouldn't be done on every flip,
            // but once somewhere during dacCreateObj or nvHalDacControl.
            //
            DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV10, DACGETHEAD(pVidLutCurDac));

            //
            // Programming the new PCRTC_START occurs during class07CImageNotify,
            // which is called immediately in the case of a flip on hsync or as
            // part of a vblank callback on vsync flips.
            //
            if (when == NV07C_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY) {

                // This hsync flip happens on the current VBlankCounter
                pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount =
                    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter;

                if (pDev->pStereoParams && pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED)
                {
                    //Shouldn't ever happen because we always force waiting for VSync for stereo.
                    RM_ASSERT(FALSE);
                } else
                    // Do the flip/notify right here.
                    class07CImageNotify(pDev, (POBJECT)pVidLutCurDac,
                                        0 /* param 1*/, buffNum,
                                        NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
            } else {
                U032  startAddr;

                if (pDev->pStereoParams)
                {
                    // DescAddr is really just an offset in this case.

                    startAddr = (U032)((NV_UINTPTR_T)(pVidLutCurDac->Image[buffNum].ImageCtxDma->DescAddr)) +
                                pVidLutCurDac->Image[buffNum].Offset;
                    pDev->pStereoParams->FlipOffsets[3][0] = startAddr;
                }

                pVidLutCurDac->Image[buffNum].ImageCallback.Proc   = class07CImageNotify;
                pVidLutCurDac->Image[buffNum].ImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->Image[buffNum].ImageCallback.Next   = NULL;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param1 = 0;
                pVidLutCurDac->Image[buffNum].ImageCallback.Param2 = buffNum;
                pVidLutCurDac->Image[buffNum].ImageCallback.Status = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
                pVidLutCurDac->Image[buffNum].ImageCallback.Flags = 0;

                if (flags & NV07C_SET_IMAGE_FORMAT_FLAGS_COMPLETE_ON_OBJECT_CLEANUP)
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP;

                // Check if the other buffer is already pending ...
                if (pVidLutCurDac->Image[buffNum ^ 1].NotifyTrigger == FALSE) {
                    // No, program/notify on the next vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 1;
                } else {
                    // Yes, program/notify on the next + 1 vblank
                    pVidLutCurDac->Image[buffNum].ImageCallback.VBlankCount = pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].VBlankCounter + 2;
                    pVidLutCurDac->Image[buffNum].ImageCallback.Flags |= CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT;
                }

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->Image[buffNum].ImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }

    return RM_OK;

} // end of class07CSetImageValues


// This proc is called from VBlank to program the LUT.
RM_STATUS class07CProgramLUT
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    RM_STATUS myStatus;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032     *startAddr;
    U032      numEntries;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    // Program the LUT.
    numEntries = 256;
    myStatus = dmaGetMappedAddress(pDev, pVidLutCurDac->LUT[BuffNum].LUTCtxDma, pVidLutCurDac->LUT[BuffNum].Offset,
                                   numEntries * 4, (void **)(&startAddr));
    if (!myStatus)
    {
        myStatus = dacProgramLUT(pDev, DACGETHEAD(pVidLutCurDac), startAddr, numEntries);
    }


    // Notify.
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                myStatus,
                                NV07C_NOTIFIERS_SET_LUT(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->LUT[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_LUT(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          myStatus,
                          pVidLutCurDac->LUT[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->LUT[BuffNum].NotifyTrigger = FALSE;
    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
}

RM_STATUS class07CSetLUTValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetLUTValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the LUT buffer description.
    //
    switch (Offset)
    {
        //
        // Set LUT Offset
        //
        case NV07C_SET_LUT_OFFSET(0):
        case NV07C_SET_LUT_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3FF) != 0)
                // The LUT offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->LUT[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set LUT Format
        //
        case NV07C_SET_LUT_FORMAT(0):
        case NV07C_SET_LUT_FORMAT(1):
        {
            buffNum = (Offset == NV07C_SET_LUT_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->LUT[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->LUT[buffNum].NotifyAction = Data;
            pVidLutCurDac->LUT[buffNum].NotifyTrigger = TRUE;
            // We can only program the LUT during VBlank.
            // Setup a callback.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Proc   = class07CProgramLUT;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Object = (POBJECT) pVidLutCurDac;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Next    = NULL;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param1  = 0;
            // Set param2 to the buffer number so we know which notifier to write.
            pVidLutCurDac->LUT[buffNum].LUTCallback.Param2  = buffNum;
            pVidLutCurDac->LUT[buffNum].LUTCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

            VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->LUT[buffNum].LUTCallback));
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
            break;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetLUTValues

// This proc writes the notification for an Cursor buffer.
RM_STATUS class07CCursorImageNotify
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      param1,
    V032      BuffNum,
    RM_STATUS Status
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    if (pVidLutCurDac->CBase.NotifyXlate)
    {
        notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                Status,
                                NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum));
        //
        // Do any OS specified action related to this notification.
        //
        if (pVidLutCurDac->CursorImage[BuffNum].NotifyAction)
        {
            osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                          NV07C_NOTIFIERS_SET_CURSOR_IMAGE(BuffNum),
                          0 /* Method */,
                          0 /* Data */,
                          Status,
                          pVidLutCurDac->CursorImage[BuffNum].NotifyAction);
        }
    }
    pVidLutCurDac->CursorImage[BuffNum].NotifyTrigger = FALSE;
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);
}

RM_STATUS class07CSetCursorImageValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorImageValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set Cursor Image Offset
        //
        case NV07C_SET_CURSOR_IMAGE_OFFSET(0):
        case NV07C_SET_CURSOR_IMAGE_OFFSET(1):
        {
            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_OFFSET(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            if ((Data & 0x3ff) != 0)
                // The cursor image offset must be a multiple of 1024 bytes.
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;

            pVidLutCurDac->CursorImage[buffNum].Offset = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Cursor Image Format
        //
        case NV07C_SET_CURSOR_IMAGE_FORMAT(0):
        case NV07C_SET_CURSOR_IMAGE_FORMAT(1):
        {
            U032 startAddr;
            BOOL queue_callback = TRUE;

            // Unlike the other IMAGE_FORMAT routines, we do allow multiple calls
            // during a single frame time. But, we still have only one callback struct.
            // So allow the args to be updated and the HW to be reprogrammed for the
            // new cursor. Just don't requeue the callback struct, since this could
            // lose an existing callback already on the list.

            buffNum = (Offset == NV07C_SET_CURSOR_IMAGE_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->CursorImage[buffNum].NotifyTrigger)
                queue_callback = FALSE;

            pVidLutCurDac->CursorImage[buffNum].Width =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_WIDTH);
            pVidLutCurDac->CursorImage[buffNum].Height =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_HEIGHT);
            pVidLutCurDac->CursorImage[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR);

            pVidLutCurDac->CursorImage[buffNum].NotifyAction =
                (Data >> DRF_SHIFT(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY)) & DRF_MASK(NV07C_SET_CURSOR_IMAGE_FORMAT_NOTIFY);

            // Kick off the transfer at this time.
            pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = TRUE;

            // Program the hardware. It will take effect at the next VBlank.
            // The cursorImageCtxDma points to the frame buffer. DescAddr has the offset of this buffer
            // from the start of the frame buffer.
            startAddr = (U032)((size_t)(pVidLutCurDac->CursorImage[buffNum].CursorCtxDma->DescAddr) +
                               pVidLutCurDac->CursorImage[buffNum].Offset);
            
            status = nvHalDacProgramCursorImage(pDev, 
                                           startAddr, NV_CIO_CRE_HCUR_ASI_FRAMEBUFFER,
                                           pVidLutCurDac->CursorImage[buffNum].Width,
                                           pVidLutCurDac->CursorImage[buffNum].Height,
                                           pVidLutCurDac->CursorImage[buffNum].ColorFormat,
                                           (VOID *)&pVidLutCurDac->HalObject);
            if (status)
            {
                pVidLutCurDac->CursorImage[buffNum].NotifyTrigger = FALSE;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Program was successful, so enable the cursor
            dacEnableCursor(pDev, DACGETHEAD(pVidLutCurDac));

            if (queue_callback)
            {
                // setup so we get a callback to do the notify at the next VBlank.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Proc   = class07CCursorImageNotify;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Object = (POBJECT) pVidLutCurDac;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Next    = NULL;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param1  = 0;
                // Set param2 to the buffer number so we know which notifier to write.
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Param2  = buffNum;
                pVidLutCurDac->CursorImage[buffNum].CursorImageCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

                VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
            }
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
     }

} // end of class07CSetCursorImageValues

// This proc is called from VBlank to program the cursor position.
RM_STATUS class07CProgramCursorPoint
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Data,
    V032      DummyParm,
    RM_STATUS Status
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CProgramCursorPoint\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    pVidLutCurDac->CursorPoint = Data;
    status = dacProgramCursorPosition(pDev, DACGETHEAD(pVidLutCurDac),
                                      (Data & 0xffff), /* cursorX */
                                      (Data >> 16));   /* cursorY */
                                      
    // signal that the callback is done
    pVidLutCurDac->CursorPointCallback.Proc = NULL;
    
    return (NV07C_NOTIFICATION_STATUS_DONE_SUCCESS);

} // end of class07CProgramCursorPoint()

RM_STATUS class07CSetCursorPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetCursorPoint\r\n");
    
    // update the cursor position
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    pVidLutCurDac->CursorPointCallback.Param1      = Data;

    if (pVidLutCurDac->CursorPointCallback.Proc == NULL)
    {
        // add the cursor position callback
        pVidLutCurDac->CursorPointCallback.Proc    = class07CProgramCursorPoint;
        pVidLutCurDac->CursorPointCallback.Object  = (POBJECT)pVidLutCurDac;
        pVidLutCurDac->CursorPointCallback.Next    = NULL;
        pVidLutCurDac->CursorPointCallback.Param2  = 0;
        pVidLutCurDac->CursorPointCallback.Status  = NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        VBlankAddCallback(pDev, DACGETHEAD(pVidLutCurDac), &(pVidLutCurDac->CursorPointCallback));
    }
    
    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;

} // end of class07CSetCursorPoint

RM_STATUS class07CSetDACValues
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS                    status;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032                         buffNum;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class07CSetDACValues\r\n");

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    //
    // Initialize the image buffer description.
    //
    switch (Offset)
    {
        //
        // Set DAC image size
        //
        case NV07C_SET_DAC_IMAGE_SIZE(0):
        case NV07C_SET_DAC_IMAGE_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_IMAGE_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width and bits 31:16 contain the height in pixels.
            // Width must be a multiple of 8.
            // Width and height must be less than or equal 2048.
            if (((Data & 0x3) != 0)                 || // width not a multiple of 8
                ((Data & 0x0000ffff) > 2048)        || // width greater than 2048
                (((Data & 0xffff0000) >> 16) > 2048))  // height greater than 2048
            {
                // Something is wrong, but the display driver won't do anything with the error, so use the closest acceptable value.
                pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000fffe;
                pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xfffe0000) >> 16;
                
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal Blank
        //
        case NV07C_SET_DAC_HORIZONTAL_BLANK(0):
        case NV07C_SET_DAC_HORIZONTAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 1024.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 1024))          // width greater than 1024
            {
                // Something is wrong, but the display driver won't do anything with the error, so we use the closest acceptable value.
                pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000fffe;
                pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xfffe0000) >> 16;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Horizontal sync
        //
        case NV07C_SET_DAC_HORIZONTAL_SYNC(0):
        case NV07C_SET_DAC_HORIZONTAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_HORIZONTAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be a multiple of 8 and less than or equal to 4088.
            // Width must be a multiple of 8 and less than or equal to 256.
            if (((Data & 0x3) != 0)                        || // start not a multiple of 8
                ((Data & 0x0000ffff) > 4088)               || // start greater than 4088
                ((((Data & 0xffff0000) >> 16) & 0x3) != 0) || // width not a multiple of 8
                (((Data & 0xffff0000) >> 16) > 256))          // width greater than 256
            {
                // Something is wrong, but the display driver won't do anything with the error, so use the closest acceptable value.
                pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000fffe;
                pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xfffe0000) >> 16;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set Vertical Blank
        //
        case NV07C_SET_DAC_VERTICAL_BLANK(0):
        case NV07C_SET_DAC_VERTICAL_BLANK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_BLANK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 128.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 128))   // width greater than 128
            {
                // Something is wrong, but the display driver won't do anything with the error, so use the closest acceptable value.
                if ((Data & 0x0000ffff) > 2047)
                {
                    pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = 2047;
                }
                if (((Data & 0xffff0000) >> 16) > 128)
                {
                    pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = 128;
                }
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }
        //
        // Set Vertical sync
        //
        case NV07C_SET_DAC_VERTICAL_SYNC(0):
        case NV07C_SET_DAC_VERTICAL_SYNC(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_VERTICAL_SYNC(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the start and bits 31:16 contain the width in pixels.
            // Start must be less than or equal to 2047.
            // Width must be less than or equal to 16.
            if (((Data & 0x0000ffff) > 2047)       || // start greater than 2047
                (((Data & 0xffff0000) >> 16) > 16))   // width greater than 16
            {
                // Something is wrong, but the display driver won't do anything with the error, so use the closest acceptable value.
                if ((Data & 0x0000ffff) > 2047)
                    pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = 2047;
                if (((Data & 0xffff0000) >> 16) > 16)
                    pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = 16;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set total size.
        //
        case NV07C_SET_DAC_TOTAL_SIZE(0):
        case NV07C_SET_DAC_TOTAL_SIZE(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_TOTAL_SIZE(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Bits 15:0 contain the width in pixels and bits 31:16 contain the height in lines.
            // Width must be a multiple of 8, less than or equal to 4128 and greater than or
            // equal to 40
            // Height must be less than or equal to 2049 and greater than or equal to 2.
            if (((Data & 0x3) != 0)                  || // width not a multiple of 8
                ((Data & 0x0000ffff) > 4128)         || // width greater than 4128
                ((Data & 0x0000ffff) < 40)           || // width less than 40
                (((Data & 0xffff0000) >> 16) > 2049) || // height greater than 2049
                (((Data & 0xffff0000) >> 16) < 2))      // height less than 2
            {
                // Something is wrong, but the display driver won't do anything with the error, so use the closest acceptable value.
                pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000fffe;
                pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xfffe0000) >> 16;
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth  = Data & 0x0000ffff;
            pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight = (Data & 0xffff0000) >> 16;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        // Set pixel clock.
        case NV07C_SET_DAC_PIXEL_CLOCK(0):
        case NV07C_SET_DAC_PIXEL_CLOCK(1):
        {
            buffNum = (Offset == NV07C_SET_DAC_PIXEL_CLOCK(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pVidLutCurDac->HalObject.Dac[buffNum].PixelClock = Data;
            return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
        }

        //
        // Set format
        //
        case NV07C_SET_DAC_FORMAT(0):
        case NV07C_SET_DAC_FORMAT(1):
        {
            RM_STATUS modeSetStatus;

            buffNum = (Offset == NV07C_SET_DAC_FORMAT(0)) ? 0 : 1;
            if (pVidLutCurDac->Dac[buffNum].NotifyTrigger)
                return NV07C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //Copy to a head-specific pointer.  In addition to allowing reference
            // to dac properties on a per-display basis, this pointer can be used
            // to determine if the head is enabled (non-NULL ptr) or disabled (NULL ptr)
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
            pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = &(pVidLutCurDac->HalObject);

            // Bit 0 contains double scan mode setting.
            // Bit 1 contains interlaced mode setting.
            // Bit 2 contains horizontal sync polarity setting.
            // Bit 3 contains vertical sync polarity setting.
            pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_DOUBLE_SCAN))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.InterlacedMode          = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_INTERLACE))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity  = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_HORIZONTAL_SYNC))) ? 1 : 0;
            pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity    = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_VERTICAL_SYNC))) ? 1 : 0;

            // color is specified by bits 19:16.
            pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat =
                (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_COLOR)) & DRF_MASK(NV07C_SET_DAC_FORMAT_COLOR);

            pVidLutCurDac->Dac[buffNum].NotifyAction = (Data & BIT(DEVICE_BASE(NV07C_SET_DAC_FORMAT_NOTIFY))) ? 1 : 0;

            pVidLutCurDac->Dac[buffNum].NotifyTrigger = TRUE;

            // NOTE: the modeset parameters are copied into pDev. This will be changed when we pass the pobject as a parameter to
            // the modeset function.

            // Save off the timing values in the pDev.
            pDev->Dac.HorizontalVisible       = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageWidth;
            pDev->Dac.HorizontalBlankStart    = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart;
            pDev->Dac.HorizontalRetraceEnd    = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalSyncWidth);
            pDev->Dac.HorizontalBlankEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].HorizontalBlankWidth);
            pDev->Dac.HorizontalTotal         = pVidLutCurDac->HalObject.Dac[buffNum].TotalWidth;
            pDev->Dac.VerticalVisible         = pVidLutCurDac->HalObject.Dac[buffNum].VisibleImageHeight;
            pDev->Dac.VerticalBlankStart      = pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart;
            pDev->Dac.VerticalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalSyncHeight);
            pDev->Dac.VerticalBlankEnd        = (pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankStart +
                                                 pVidLutCurDac->HalObject.Dac[buffNum].VerticalBlankHeight);
            pDev->Dac.VerticalTotal           = pVidLutCurDac->HalObject.Dac[buffNum].TotalHeight;
            pDev->Dac.HalInfo.PixelClock      = pVidLutCurDac->HalObject.Dac[buffNum].PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = pVidLutCurDac->HalObject.Dac[buffNum].Format.HorizontalSyncPolarity;
            pDev->Dac.VerticalSyncPolarity    = pVidLutCurDac->HalObject.Dac[buffNum].Format.VerticalSyncPolarity;
            pDev->Dac.DoubleScannedMode       = pVidLutCurDac->HalObject.Dac[buffNum].Format.DoubleScanMode;

            pDev->Framebuffer.HalInfo.HorizDisplayWidth = pDev->Dac.HorizontalVisible;
            pDev->Framebuffer.HalInfo.VertDisplayWidth = pDev->Dac.VerticalVisible;
                        switch(pVidLutCurDac->HalObject.Dac[buffNum].ColorFormat)
            {
                                case NV07C_SET_DAC_FORMAT_COLOR_LUT_LE_Y8:
                                        pDev->Dac.HalInfo.Depth = 8;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 1;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1R5G5B5:
                                        pDev->Dac.HalInfo.Depth = 15;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_BYPASS_LE_R5G6B5:
                                        pDev->Dac.HalInfo.Depth = 16;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 2;
                                        break;
                                case NV07C_SET_DAC_FORMAT_COLOR_LE_BYPASS1X7R8G8B8:
                                        pDev->Dac.HalInfo.Depth = 32;
                                        //pDev->Dac.DisplayPitch =  pDev->Framebuffer.HalInfo.HorizDisplayWidth * 4;
                                        break;
                        }

            pDev->Dac.PixelDepth              = pDev->Dac.HalInfo.Depth;
            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice =
                DRF_VAL(07C, _SET_DAC_FORMAT, _PRIMARY_DEVICE, Data);

            //LPL: this is a per-buffer, not per-head property -- are there times it
            // will differ between buffers?  I'm assuming not.
//            pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PixelDepth = pDev->Dac.HalInfo.Depth;
            pVidLutCurDac->HalObject.Dac[buffNum].PixelDepth = pDev->Dac.HalInfo.Depth;

            // Get output device...
            pVidLutCurDac->DisplayType            = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE)) & DRF_MASK(NV07C_SET_DAC_FORMAT_DISPLAY_TYPE);
            if (pVidLutCurDac->DisplayType > 3)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid display type ", pVidLutCurDac->DisplayType);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Get TV output format...
            pVidLutCurDac->TVStandard             = (Data >> DRF_SHIFT(NV07C_SET_DAC_FORMAT_TV_STANDARD)) & DRF_MASK(NV07C_SET_DAC_FORMAT_TV_STANDARD);
            if (pVidLutCurDac->TVStandard > 5)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class07c: invalid TV standard ", pVidLutCurDac->TVStandard);
                return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            // Do the mode set.
            modeSetStatus = stateSetModeMultiHead(pDev, pVidLutCurDac);
            
            if (pVidLutCurDac->CBase.NotifyXlate)
            {
                status = notifyFillNotifierArray(pDev, pVidLutCurDac->CBase.NotifyXlate, 0, 0,
                                                 modeSetStatus,
                                                 NV07C_NOTIFIERS_SET_DAC(buffNum));
                //
                // Do any OS specified action related to this notification.
                //
                if (pVidLutCurDac->Dac[buffNum].NotifyAction)
                {
                    osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                                  NV07C_NOTIFIERS_SET_DAC(buffNum),
                                  0 /* Method */,
                                  0 /* Data */,
                                  modeSetStatus,
                                  pVidLutCurDac->Dac[buffNum].NotifyAction);
                }
            }
            pVidLutCurDac->Dac[buffNum].NotifyTrigger = FALSE;

            return modeSetStatus;
        }

        default:
            return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            break;
     }
} // end of class07CSetDACValues

RM_STATUS class07CSetHotPlug
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    //this function will turn or off the hotplug detection on the NV11 board
    //functionality will be added to the HAL to control hotplug mechanism
    U032 Head;
    U032 HotPlugDetect=0;
    U032 HotUnplugDetect=0;
    
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac_rmVersion;
    
    DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO, "NVRM: class07CSetDACValues\r\n"));
    
    //extract the pVidLutCurDac and the Head number
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;
    Head = DACGETHEAD(pVidLutCurDac);
    
    //verify we aren't bein' slipped a loaded value
    if((~(NV07C_SET_HOTPLUG_PLUG|NV07C_SET_HOTPLUG_UNPLUG|NV07C_NOTIFY_WRITE_THEN_AWAKEN))&Data)
    {
        DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_ERRORS,"NVRM: Bad mask sent to 7c set hotplug method.\n"));
    
        return NV07C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
    }
    
    //setup the notifier
    pVidLutCurDac->CBase.NotifyAction  = (Data&NV07C_NOTIFY_WRITE_THEN_AWAKEN)?NV07C_NOTIFY_WRITE_THEN_AWAKEN:NV07C_NOTIFY_WRITE_ONLY;
    pVidLutCurDac->CBase.NotifyTrigger = TRUE;
    
    //now we need to save our intelligence
    pVidLutCurDac->HotPlug.HotPlugEventDescriptor=Data;
    
    //another Mac spec workaround
    //special case for Macintosh -- if the pVidLutCurDac we have is a faked one,
    //copy the notifier data from the real one to the fake one
    //we consider the one passed to us the real one, and the RM
    //version to be fake if the pointers do not match (make sure RM version not NULL)
    //because the one passed to us is related to the handle that we joined to the object
    //that display driver uses. This is nasty, but necessary.
    if(pVidLutCurDac!=((PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac))
    {
        if(!pDev->Dac.CrtcInfo[Head].pVidLutCurDac)
        {
            //if the rm version's pointer is null, we can place this one into RM without consequence
            pDev->Dac.CrtcInfo[Head].pVidLutCurDac = (VOID_PTR)pVidLutCurDac;
        }
        else
        {
            pVidLutCurDac_rmVersion=(PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
            //set the hotplug event descriptor data on the fake one, too
            pVidLutCurDac_rmVersion->HotPlug.HotPlugEventDescriptor=Data;
            
            //copy notifier data from real one to fake one (for hotplug only)
            osMemCopy((U008 *)&(pVidLutCurDac_rmVersion->Common),(U008 *)&(pVidLutCurDac->Common),sizeof(COMMONOBJECT));
        }
    }
    
    HotPlugDetect=((pVidLutCurDac->HotPlug.HotPlugEventDescriptor)&NV07C_SET_HOTPLUG_PLUG)?1:0;
    HotUnplugDetect=((pVidLutCurDac->HotPlug.HotPlugEventDescriptor)&NV07C_SET_HOTPLUG_UNPLUG)?1:0;
    
    //enable the hotplug interrupts as perscribed
    dacSetHotPlugInterrupts(pDev, Head, HotPlugDetect, HotUnplugDetect);
    
    DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO,"NVRM: HotPlugInterrupt configured.\n"));
    
    return NV07C_NOTIFICATION_STATUS_DONE_SUCCESS;
}

V032 HotPlugService(PHWINFO pDev)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 Head, HotPlugStatus[MAX_CRTCS], HotUnplugStatus[MAX_CRTCS];
    U032 NotifierData=NV07C_SET_HOTPLUG_NOHOTSWAP;
    U032 TriggerOSCall=0;
    
    DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO,"NVRM: Processing PBUS event.\n"));
    
    //do service for each head that notes interest
    for(Head=0;Head<pDev->Dac.HalInfo.NumCrtcs;Head++)
    {
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        dacGetHotPlugInterrupts(pDev, Head, &HotPlugStatus[Head], &HotUnplugStatus[Head], (Head==(pDev->Dac.HalInfo.NumCrtcs-1))?TRUE:FALSE /* reset status */ );
        DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO,"NVRM: Hot   plug status - %d.\n",HotPlugStatus[Head]));
        DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO,"NVRM: Hot unplug status - %d.\n",HotUnplugStatus[Head]));
        
        if(pVidLutCurDac)
        {
            if(pVidLutCurDac->HotPlug.HotPlugEventDescriptor)
            {                
                //reset data that we pass to notifier
                NotifierData=0;
                
                if(HotPlugStatus[Head])
                {
                    NotifierData|=NV07C_SET_HOTPLUG_PLUG;
                }
                
                if(HotUnplugStatus[Head])
                {
                    NotifierData|=NV07C_SET_HOTPLUG_UNPLUG;
                }
                
                if(NotifierData)
                {
                    TriggerOSCall=1;
                }
                
                //now do the notifier
                if(pVidLutCurDac->CBase.NotifyXlate)
                {
                    notifyFillNotifierArray(
                        pDev,
                        pVidLutCurDac->CBase.NotifyXlate,
                        NotifierData, // Info32
                        0,
                        NV07C_NOTIFICATION_STATUS_DONE_SUCCESS,
                        NV07C_NOTIFIERS_SET_HOTPLUG
                    );
                    
                    if (pVidLutCurDac->HotPlug.NotifyAction)
                    {
                        //this was a nasty abstraction.... but it looks OK if I copy the common object, which I do
                        //when its the Mac and the bloody fake VIDEO_LUT_CURSOR_DAC_OBJECT.... much grief!
                        osNotifyEvent(pDev, (POBJECT)pVidLutCurDac,
                                      NV07C_NOTIFIERS_SET_HOTPLUG,
                                      0 /* Method */,
                                      0 /* Data */,
                                      NV07C_NOTIFICATION_STATUS_DONE_SUCCESS,
                                      pVidLutCurDac->HotPlug.NotifyAction);
                    }
                }
                
                //print msg
                DBG_PRINTF((DBG_MODULE_DACCLASS,DBG_LEVEL_INFO,"NVRM: Posted notifier for hotplug event with data value U032 = 0x%x.\n",NotifierData));
            }
        }
    }
    
    if(TriggerOSCall)
    {
#ifdef MACOS
        osTriggerOSHotplug(pDev);
#endif
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class093.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_CONTEXT_SURFACES_3D ***************************\
*                                                                           *
* Module: CLASS093.C                                                        *
*   This module implements the NV10_CONTEXT_SURFACES_3D object class        *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class094.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/********************** NV10_DX5_TEXTURED_TRIANGLE *************************\
*                                                                           *
* Module: CLASS094.C                                                        *
*   This module implements the NV10_DX5_TEXTURED_TRIANGLE object class      *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class088.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV10_DVD_SUBPICTURE ******************************\
*                                                                           *
* Module: CLASS088.C                                                        *
*   This module implements the NV10_DVD_SUBPICTURE object class             *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class096.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************* NV15_CELSIUS_PRIMITIVE **************************\
*                                                                           *
* Module: CLASS096.C                                                        *
*   This module implements the NV15_CELSIUS_PRIMITIVE object class          *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

extern VOID grGetState(PHWINFO, U032, BOOL);
extern VOID grPutState(PHWINFO, U032, BOOL);
extern VOID grSnapshotPrimAssm(PHWINFO, U032);
extern VOID grReloadPrimAssm(PHWINFO, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class095.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************** NV10_DX6_MULTI_TEXTURE_TRIANGLE ************************\
*                                                                           *
* Module: CLASS095.C                                                        *
*   This module implements the NV10_DX6_MULTI_TEXTURE_TRIANGLE object class *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class64.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER methods.                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS class64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class64SetDeltaDuDx
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDuDx\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DU_DX(0), Data, &status);

    return (status);
}

RM_STATUS class64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetDeltaDvDy\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_DELTA_DV_DY(0), Data, &status);

    return (status);
}

RM_STATUS class64SetPoint
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class64SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_SCALER, &pVidScaler->HalObject, NVFF7_SET_POINT(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class63.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class63.C                                                         *
*   This module implements the NV_VIDEO_FROM_MEMORY methods.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"
#include "smp.h"

// statics
static RM_STATUS class63XferComplete(PHWINFO, POBJECT, U032, V032, RM_STATUS);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// See kernel/video/videoobj.c
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
static RM_STATUS class63WaitVBlank
(
    PHWINFO       pDev,
    PVBLANKNOTIFY VBlankNotify,
    U032          buffer,
    U032          waitCount
)
{   
    //
    // Check for in-use.
    //
    if (VBlankNotify->Next)
        return (RM_ERR_NOTIFY_IN_USE);
    //
    // Stick this object on the appropriate queue waiting for the next VBlank
    //
    VBlankNotify->Next   = pDev->DBclass63VBlankList[buffer];
    pDev->DBclass63VBlankList[buffer] = VBlankNotify;

    pDev->Video.class63VBlankCount[buffer] = waitCount;

    return (RM_OK);
}

RM_STATUS class63VBlank
(
    PHWINFO pDev
)
{
    PVBLANKNOTIFY VBlankNotify;
    PVBLANKNOTIFY VBlankNext;

    //
    // Pull all notifies annd complete them.
    //
    if (--pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] == 0)
    {
    VBlankNotify = pDev->DBclass63VBlankList[pDev->Framebuffer.Current];
    while (VBlankNotify)
    {
        VBlankNext         = VBlankNotify->Next;
        VBlankNotify->Next = NULL;
        VBlankNotify->Proc(pDev,
                           VBlankNotify->Object,
                           VBlankNotify->Param1,
                           VBlankNotify->Param2,
                           RM_OK);
        VBlankNotify = VBlankNext;

        //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "n");
        
    }
    pDev->DBclass63VBlankList[pDev->Framebuffer.Current] = NULL;
    pDev->Video.class63VBlankCount[pDev->Framebuffer.Current] = 0;
    }
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------
RM_STATUS class63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    PVIDEOFROMMEMOBJECT pVidFromMem;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotifyCtxDma\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    if (pVidFromMem->BufferObj.Base.NotifyTrigger)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE);

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &(pVidFromMem->BufferObj.Base.NotifyXlate));
    if (status)
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    
    //
    // Validate notification parameters.
    //
    status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate, 0, (5 * 0x0010));
    if (status)
    {
        pVidFromMem->BufferObj.Base.NotifyXlate   = NULL;
        return (NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT);
    }
    
    //
    // Since NV4 uses the same notify buffer for all buffers, plug them into everywhere
    //
    pVidFromMem->BufferObj.Buffer[0].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    pVidFromMem->BufferObj.Buffer[1].NotifyXlate = pVidFromMem->BufferObj.Base.NotifyXlate;
    
    return (status);
}

RM_STATUS class63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetNotify\r\n");
    //
    // Set the notification style (note that these will be s/w notifies!)
    //
    pVidFromMem->BufferObj.Base.NotifyAction  = Data;
    pVidFromMem->BufferObj.Base.NotifyTrigger = TRUE;
    
    return (RM_OK);
}

RM_STATUS class63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    RM_STATUS           status;
    U032                Head = 0; // single head class
    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    VidLutCurDac.Head = Head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StopTransfer\r\n");

    //
    // Stop the current data transfer immediately.
    //

    if (pVidFromMem->HalObject.Buffer[0].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
        pVidFromMem->HalObject.Buffer[0].State = OVERLAY_BUFFER_IDLE;
    }
    if (pVidFromMem->HalObject.Buffer[1].State != OVERLAY_BUFFER_IDLE)
    {
        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                 0, 
                                 0, 
                                 RM_OK, 
                                 NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
        pVidFromMem->HalObject.Buffer[1].State = OVERLAY_BUFFER_IDLE;
    }

    //
    // Notify this one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(0) );
                    
    //
    // And the other one
    //
    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             RM_OK, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(1) );
    //
    // Issue stop-immediately call to HAL.
    //
    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_STOP_TRANSFER(0), NVFF8_STOP_TRANSFER_VALUE, &status);
    
    //
    // Transition state of object back to uninitialized.
    //
    pVidFromMem->InitState = 0;

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    // Clear the active overlay object.
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) NULL;

    return status;
}

RM_STATUS class63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032 buffNum;
    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63SetImageCtxDma\r\n");

    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    buffNum = (Offset - Method->Low) >> 2;

    //
    // Set the image buffer DMA context.
    //
    status = mthdSetBufferCtxDma(pDev, Object, Method, Offset, Data);

    //
    // Give HAL access to context dma.
    //
    pVidFromMem->HalObject.Buffer[buffNum].bufferCtxDma = &pVidFromMem->BufferObj.Buffer[buffNum].Xlate->HalInfo;

    return status;
}

RM_STATUS class63ImageScan
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    PVIDEOFROMMEMOBJECT     pVidFromMem;
    PVIDEOFROMMEMHALOBJECT  pVidFromMemHalObj;
    PBUFFEROBJECT           pBuffObject;
    U032                    Buffer;
    RM_STATUS               status;
    U032                    Size;
    U032                    Head = 0; // single-head class

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63ImageScan\r\n");

    VidLutCurDac.Head = Head;

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    pVidFromMemHalObj = &pVidFromMem->HalObject;
    pBuffObject = (PBUFFEROBJECT)Object;
    Buffer = ((Offset - Method->Low) <= 0x10) ? 0 : 1;

    //
    // Initialize the image buffer description.
    //
    switch (Offset - Method->Low)
    {
        //
        // Set Offset
        //
        case 0x00:
        case 0x14:
            dmaSetBufferStart(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Start = pBuffObject->Buffer[Buffer].Start;
            break;
        //
        // Set Pitch
        //
        case 0x04:
        case 0x18:
            dmaSetBufferPitch(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Data);
            pVidFromMemHalObj->Buffer[Buffer].Pitch = pBuffObject->Buffer[Buffer].Pitch;
            break;
        //
        // Set Size
        //
        case 0x08:
        case 0x1C:

            //
            // Save away the width separately
            //
            pBuffObject->Buffer[Buffer].Width = (Data & 0xFFFF);
            pVidFromMemHalObj->Buffer[Buffer].Width = (Data & 0xFFFF);

            // Cheat for now to get the length
            Size = (Data & 0xFFFF) * ((Data & 0xFFFF0000)>>16);
            dmaSetBufferLength(pBuffObject, &(pBuffObject->Buffer[Buffer]), Offset, Size);
            pVidFromMemHalObj->Buffer[Buffer].Length = pBuffObject->Buffer[Buffer].Length;
            break;
        //
        // Set Format.
        //
        case 0x0C:
        case 0x20:
			//
			// For now, we must make the assumption that both buffers
			// have the same format.  Makes sense -- but if we want
			// different formats in the future, just move the format
			// field down from the BufferObj into the individual buffers.
			//
            pBuffObject->Sample.Format = Data;
            pVidFromMemHalObj->Format = Data;

            // Q: How do we know that this object is the one pointing to the h/w?
            // If this is a s/w only object then need to disable any writes to h/w!
			
            break;
        //
        // Set Notify
        //
        case 0x10:
        case 0x24:
#ifdef DEBUG_TIMING            
            if ((Offset - Method->Low) == 0x10)
            {    
                //DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_1) - time0hi);
                DBG_PRINT_TIME("VideoKickoff0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                    
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
            } 
            else
            {    
                //DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_1) - time1hi);
                DBG_PRINT_TIME("VideoKickoff1: ",REG_RD32(NV_PTIMER_TIME_0) - time1lo);
             
                time1hi = REG_RD32(NV_PTIMER_TIME_1);
                time1lo = REG_RD32(NV_PTIMER_TIME_0);
            }
#endif // DEBUG_TIMING            
            //
            // Verify all required data has been sent
            //  verify rest of imagescan

            //
            // YUV Buffers will be handled normally; RGB buffer will be
            // special cased, since they really aren't double-buffered.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
                ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
            {
                U032 when;
                U032 Head = 0;  // this is a single-head class
                //
                // We assume the format, pitch, and length are the same as the 
                // framebuffer.
                //
                // RGB video is not handled as a true double-buffered object,
                // but instead acts as a single-shot transfer with notify.
                // When the app wants a transfer, it sets a notify.  Nothing
                // really moves automatically (unlike back-end Video).
                //

                //
                // !!!!! SIMPLE VALIDATATION NEEDED !!!!!
                //  verify contexts

                //
                // Make sure outstanding notification doesn't exist.
                //
                if (pVidFromMem->VBlankNotify[Buffer].Pending)
                    return (NVFF8_NOTIFICATION_STATUS_IN_PROGRESS);

                //
                // This class does not have support for flipping on HSync.
                // That support is only in class 049 (NV05_VIDEO_LUT_CURSOR_DAC).
                // Simulate it with a registry setting.
                //
                if (IsNV5orBetter(pDev) && pDev->Video.FlipOnHsync == 0x1) 
                {
                    // Flip on HSync instead of VSync.
                    when = NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY; // just use the class 49 define.
                }
                else
                {
                    when = NV049_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER;
                }

                //
                // Validate notification.
                //
                status = dmaValidateXlate(pVidFromMem->BufferObj.Base.NotifyXlate,
                                          0,
                                          0x000F);

                dacProgramVideoStart(pDev, Head,
                                     pBuffObject->Buffer[Buffer].Start,
                                     pBuffObject->Buffer[Buffer].Pitch);

                if (!IsNV10orBetter(pDev) && when == NV049_SET_IMAGE_FORMAT_WHEN_IMMEDIATELY)
                {
                    // Change the default flip functionality to end of hsync.
                    FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _HSYNC_NV5);

                    // Don't wait for VSync for the notify. Just do it right here. The assumption is that
                    // HSync will happen before the driver pays attention to the notification.
                    // Do everything that would have normally been done in VBlank.
                    pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
                    pDev->Framebuffer.FlipTo   = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.Current  ^= 1;

                    class63XferComplete(pDev, Object, Offset, Buffer, RM_OK);
                }
                else
                {
                    //
                    // We want to get a notify when done transferring to Buffer.  The
                    // VBlank notify algorithm works on which buffer you're transferring
                    // from, so we need to flip from the current buffer.  This dictates
                    // that the next vblank will cause this callback.
                    //
                    pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current ^ 1] = pBuffObject->Buffer[Buffer].Start;
                    pDev->Framebuffer.FlipTo = pDev->Framebuffer.Current ^ 1;
                    pDev->Framebuffer.UpdateFlags |= UPDATE_HWINFO_BUFFER_FLIP;
                    pVidFromMem->VBlankNotify[Buffer].Object  = Object;
                    pVidFromMem->VBlankNotify[Buffer].Proc    = class63XferComplete;
                    pVidFromMem->VBlankNotify[Buffer].Next    = NULL;
                    pVidFromMem->VBlankNotify[Buffer].Pending = FALSE;
                    pVidFromMem->VBlankNotify[Buffer].Xlate   = pVidFromMem->BufferObj.Base.NotifyXlate;
                    pVidFromMem->VBlankNotify[Buffer].Action  = Data;
                    pVidFromMem->VBlankNotify[Buffer].Param1  = Offset;
                    pVidFromMem->VBlankNotify[Buffer].Param2  = Buffer;

                    status = class63WaitVBlank(pDev, &(pVidFromMem->VBlankNotify[Buffer]), 
                                               pDev->Framebuffer.Current ^ 1, 1);
                }
            } // RGB Video
            else
            {
                //
                // YUV
                //
				// Here is an overview of how hardware overlay works:
                // VideoFroMem, VideoScaler and VideoColorKey objects are setup by DDraw before calling
                // the VideoFromMem->Notify method (which is where we are now).
                // 
                // The Notify method on VideoFromMemory class tells the RM that all the values for one
                // frame are setup and we should program the hardware. The RM then marks the appropriate
                // buffer as BUFFER_BUSY. 
                //
                // class63VideoService is the interrupt handler that handles the "scanout complete"
                // interrupt from the video engine. The video engine is double buffered. So the video
                // engine is constantly toggling the "current buffer". The RM tries to keep feeding
                // the video engine with new values.
                //
                // After handling the notification (if any) of a buffer completion, VideoService tries
                // to kickoff the other buffer. (For example, at the completion of buffer 0, we will try
                // to kickoff buffer 1 if it is in state BUFFER_BUSY). When a buffer is actually kicked off
                // (i.e loaded into the hardware registers), its state is marked BUFFER_NOTIFY_PENDING.
                //
                // If the other buffer is not BUFFER_BUSY at the completion of a buffer, we will restart
                // the same buffer by forcing the hardware to flip to the same buffer again. This is so
                // that we will always get an interrupt even when there are no new values to be loaded.
                // It is necessary to get an interrupt because the interrupt handler is the only place
                // (other than the first time) we actually kickoff a buffer by programming the hardware
                // registers.
                // 
                // State transitions of a buffer:
                // A buffer goes from state BUFFER_IDLE to BUFFER_BUSY when the notify method is invoked.
                // It goes from BUFFER_BUSY to BUFFER_NOTIFY_PENDING when its values are actually programmed
                // into the appropriate hardware registers (in class63InitXfer the very first time and in
                // class63VideoService the rest of the time).
                // It goes from BUFFER_NOTIFY_PENDING to BUFFER_IDLE when the hardware is finished scanning out
                // that buffer and a notification is written for it (in class63VideoService).
                //

                //
                // This will also kick off a call to the bufferXfer proc for this buffer.
                // The very first time the bufferXfer proc is setup to call class63InitXfer.
                //
                if (pBuffObject->Buffer[Buffer].Length) // KJK quick hack so we don't start running immediately!!
                {
                    if (pVidFromMemHalObj->Buffer[Buffer].State != OVERLAY_BUFFER_IDLE)
                    {
                        // Trying to kickoff a busy buffer.
#ifdef DEBUG_TIMING
                        DBG_PRINT_STRING_VALUE(0x10, "******TRYING TO KICKOFF BUSY BUFFER********: ",Buffer);
#endif
                        return NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                    }

                    //
                    // Check for DMA translation instances.
                    //
                    if (!pBuffObject->Buffer[Buffer].Xlate->HalInfo.Instance ||
                        !pBuffObject->Buffer[Buffer].NotifyXlate->HalInfo.Instance)
                        return (RM_ERR_INVALID_XLATE);
                    
                    pBuffObject->Buffer[Buffer].NotifyAction = Data;

                    //
                    // If this is the init stage on this object,
                    // make sure the video overlay hardware is available.
                    //
                    if (pVidFromMem->InitState == 0)
                    {
                        if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject != (POBJECT) NULL)
                        {
                            return NV_OUT_OF_RESOURCES;
                        }

                        //
                        // Validate patch
                        // XXX (scottl): do we need this anymore?!?!?
                        if (!pBuffObject->Valid)
                        {
                            pVidFromMem->CBase.ChID = pBuffObject->Base.ChID;
                            pBuffObject->Valid = TRUE;
                        }
                    }


                    //
                    // Call into HAL to program up any hw.
                    //
                    (void) nvHalVideoMethod(pDev, NV_VIDEO_FROM_MEMORY, &pVidFromMem->HalObject, NVFF8_IMAGE_SCAN_NOTIFY(0, Buffer), Data, &status);
                    if (status)
                    {
                        notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                                                 0, 
                                                 0, 
                                                 status, 
                                                 NVFF8_NOTIFIERS_IMAGE_SCAN(Buffer) );
                    }
                    else
                    {
                        //
                        // If video has just been enabled, then refresh arb settings.
                        //
                        if (pVidFromMem->InitState == 0)
                        {
                            nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);
                            pVidFromMem->InitState = 1;
                        }

                        // Make this the active overlay object.
                        pDev->Video.HalInfo.ActiveVideoOverlayObject = (VOID_PTR) pVidFromMem;
                        pDev->pOverlayServiceHandler   = videoFromMemService;
                    }
                }
                else
                {
                	// Length is 0. Assume we want to stop the overlay.
                    class63StopTransfer(pDev, (POBJECT)pVidFromMem, 
                                        0 /*Method */, 0 /* Offset */, 0 /* data */);
                }
            }
            break;
    }
    return (RM_OK);
}

RM_STATUS class63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return (RM_OK);
}    

//---------------------------------------------------------------------------
//
//  Buffer transfer routines. 
//
//---------------------------------------------------------------------------

static RM_STATUS class63XferComplete
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63XferComplete\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;

    notifyFillNotifierArray( pDev, pVidFromMem->BufferObj.Base.NotifyXlate, 
                             0, 
                             0, 
                             Status, 
                             NVFF8_NOTIFIERS_IMAGE_SCAN(Data) );
                             
    //KJK dmaEndXfer(pVidFromMem->BBuffer[Data].NotifyXlate, NULL);
    //
    // Do any OS specified action related to this notification.
    //
    if (pVidFromMem->BBuffer[Data].NotifyAction)
    {
        osNotifyEvent(pDev, Object, 
                      NVFF8_NOTIFIERS_IMAGE_SCAN(Data),
                      0, 
                      1, 
                      RM_OK, 
                      pVidFromMem->BBuffer[Data].NotifyAction);
                       
    }
    pVidFromMem->VBlankNotify[Data].Pending = FALSE;
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c047nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047SizeIn Invalid Height!!\r\n"));
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047SizeIn Invalid Height!!\r\n"));
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;

            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class09f.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************** NV15_IMAGE_BLIT ********************************\
*                                                                           *
* Module: CLASS09F.C                                                        *
*   This module implements the NV15_IMAGE_BLIT object class                 *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <gr.h>
#include <dma.h>
#include <modular.h>
#include <fifo.h>
#include <os.h>
#include <nv32.h>
#include "smp.h"

//
// Externs.
//


//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


#ifdef SHOULD_BE_HW_METHODS

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class validation routines.
//
//---------------------------------------------------------------------------

RM_STATUS class09FValidate
(
    PHWINFO             pDev,
    PRENDERCOMMONOBJECT pRenderObject,
    U032                andMask,
    U032                orMask
)
{
    RM_STATUS status = RM_OK;

    //
    // Validate the current configuration of this object.  Update the object
    // instance data structure accordingly.
    //
    if ((pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.ColorKey == NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Pattern != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_ROP_AND  ||
                    pRenderObject->RCPatchContext.Rop != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_AND  ||
                    pRenderObject->RCPatchContext.Beta1 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_SRCCOPY_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Operation != NV_BLEND_PREMULT  ||
                    pRenderObject->RCPatchContext.Beta4 != NULL)  &&
        (pRenderObject->RCPatchContext.Surface != NULL))
    {
        //
        // Patch status is valid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) | orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = TRUE;

    } else {

        //
        // Patch status is invalid
        //
        nvHalGrSetObjectContext(pDev,
                                ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _PATCH_STATUS, _VALID) & andMask,
                                orMask,
                                pRenderObject->Common.Base.ChID,
                                pRenderObject->Common.Instance);
        pRenderObject->CValid = FALSE;
    }

    return (status);
}


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
//  NOTE: Any method not listed here is most likely aliased to HWMethod()
//

RM_STATUS class09FSetContextColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_COLOR_KEY:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _CHROMA_KEY, _ENABLE);
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.ColorKey = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextClip
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextClip\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // We'll be updating this bit.
    //
    andMask = ~DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object and disable the colorkey.
        //
        orMask = 0;
        pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_IMAGE_BLACK_RECTANGLE:
                //
                // This is a valid colorkey object
                //
                orMask = DRF_DEF(_PGRAPH, _CTX_SWITCH1, _USER_CLIP, _ENABLE);
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                orMask = 0;
                pRenderObject->RCPatchContext.Clip = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextPattern
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextPattern\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_PATTERN:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Pattern = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextRop
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextRop\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV3_CONTEXT_ROP:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Rop = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta1
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta1\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV1_BETA_SOLID:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta1 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextBeta4
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextBeta4\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_BETA:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Beta4 = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetContextSurfaces2d
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    POBJECT                 TempObject;
    PRENDERCOMMONOBJECT     pRenderObject;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetContextSurface\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object
        //
        pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;

    }
    else if (fifoSearchObject(pDev, Data, pRenderObject->CBase.ChID, &TempObject) == RM_OK)
    {
        //
        // There is a corresponding object in this channel.  Validate.
        //
        switch (TempObject->Class->Type)
        {
            case NV4_CONTEXT_SURFACES_2D:
                //
                // This is a valid object
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)TempObject;
                break;

            case NV1_NULL:
            case NV1_NULL_OBJECT:
                //
                // A NULL class should disable
                //
                pRenderObject->RCPatchContext.Surface = (PCOMMONOBJECT)NULL;
                break;

            default:
                //
                // Any other class is an error
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
                return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
                break;
        }
    }
    else
    {
        //
        // Object not found or data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid object: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}


RM_STATUS class09FSetOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    PRENDERCOMMONOBJECT     pRenderObject;
    U032                    andMask, orMask;
    RM_STATUS               status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class09FSetOperation\r\n");
    //
    // A nice cast to make the code more readable.
    //
    pRenderObject = (PRENDERCOMMONOBJECT)Object;

    //
    // Verify the incoming data is valid for this method
    //
    if (Data < NV4_GR_OPERATIONS)
    {
        //
        // Set the new value
        //
        andMask = ~DRF_MASK(NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG);
        orMask = DRF_NUM(_PGRAPH, _CTX_SWITCH1, _PATCH_CONFIG, Data);
        pRenderObject->RCPatchContext.Operation = Data;     // save the arch value for validation
    }
    else
    {
        //
        // Data invalid.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetContext with invalid data: ", Data);
        return (NV09F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
    }

    //
    // Update object validation
    //
    status = class09FValidate(pDev, pRenderObject, andMask, orMask);

    return (status);
}

#endif // SHOULD_BE_HW_METHODS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\class65.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <nv32.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "smp.h"

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotifyCtxDma\r\n");
    //
    // Set the notify DMA context.
    //
    return (mthdSetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetNotify\r\n");
    //
    // Set the notification style.
    //
    return (mthdSetNotify(pDev, Object, Method, Offset, Data));
}
RM_STATUS class65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoOutput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetVideoInput\r\n");

    return (RM_OK);
}

RM_STATUS class65SetColorFormat
(
    PHWINFO pDev,
    POBJECT Object, 
    PMETHOD Method, 
    U032    Offset, 
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorFormat\r\n");
    
    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_FORMAT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetColorKey
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetColorKey\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_COLOR_KEY(0), Data, &status);

    return (status);
}

RM_STATUS class65SetPoint
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetPoint\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_POINT(0), Data, &status);

    return (status);
}

RM_STATUS class65SetSize
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class65SetSize\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    //
    // Initialize the color key rectangle.
    //
    // Set the width and height of the color key rectangle.
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
    {
        U032 tempData;

        tempData = (Data & 0x0000FFFF);
        if (tempData > 0x00007FFF)
            tempData = 0x00007FFF;
        Data &= 0xFFFF0000;
        Data |= tempData;
    }

    (void) nvHalVideoMethod(pDev, NV_VIDEO_COLOR_KEY, &pVidColorKey->HalObject, NVFF6_SET_SIZE(0), Data, &status);

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c04dnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV10.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04DMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8_BIT);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16_BIT);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
	// clear the interrupt, in case another shows up!
	REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV10: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv\classcmn.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Common Class Routines ************************\
*                                                                           *
* Module: classcmn.c                                                        *
*   This module implements the common class routines referenced in the      *
*   classTable in class.c                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <gr.h>   
#include <dma.h>   
#include <modular.h>
#include <os.h>
#include <nv32.h>
#include "nvhw.h"
#include "dac.h"

/*
 * class04D common routines
 */
RM_STATUS Commonclass04DNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DStopTransferImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DStopTransferImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaImage(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetContextDmaVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04DSetContextDmaVbi(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageConfig
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageConfig(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetImageStartLine
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImageStartLine(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass04DSetVbi
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetVbi(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DSetImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DSetImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetVbiOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetVbiOffsetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04DGetImageOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    V032    Data
)
{
  return(class04DGetImageOffsetNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class04E common routines
 */
RM_STATUS Commonclass04ENotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ENotify(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04EStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04ESetContextDmaData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaData(pDev, Object, Method, Offset, Data));
} 
 
RM_STATUS Commonclass04ESetContextDmaImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04ESetContextDmaImage(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04EReadData
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EReadData(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04EWriteImage
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04EWriteImage(pDev, Object, Method, Offset, Data));
}

/*
 * class04F common routines
 */
RM_STATUS Commonclass04FSetContextDmaNotifies
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetContextDmaNotifies(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass04FNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FNotify(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass04FStopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FStopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FWrite
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FWrite(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FRead
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FRead(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass04FSetInterruptNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class04FSetInterruptNotify(pDev, Object, Method, Offset, Data));
}  

/*
 * class63 common routines
 */
RM_STATUS Commonclass63SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  
  
RM_STATUS Commonclass63SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63StopTransfer
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63StopTransfer(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63SetImageCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63SetImageCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass63ImageScan
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class63ImageScan(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass63GetOffsetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    return(class63GetOffsetNotify(pDev, Object, Method, Offset, Data));
}    

/*
 * class64 common routines
 */
RM_STATUS Commonclass64SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetNotify(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoOutput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetVideoInput(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDuDx
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDuDx(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetDeltaDvDy
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetDeltaDvDy(pDev, Object, Method, Offset, Data));
}  

RM_STATUS Commonclass64SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class64SetPoint(pDev, Object, Method, Offset, Data));
}  

/*
 * class65 common routines
 */
RM_STATUS Commonclass65SetNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotifyCtxDma(pDev, Object, Method, Offset, Data));
}
  
RM_STATUS Commonclass65SetNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetNotify(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoOutput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoOutput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetVideoInput
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetVideoInput(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorFormat
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorFormat(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetColorKey
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetColorKey(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetPoint
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetPoint(pDev, Object, Method, Offset, Data));
}

RM_STATUS Commonclass65SetSize
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
  return(class65SetSize(pDev, Object, Method, Offset, Data));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c07anv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV10.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000);
static RM_STATUS class07aUpdatePointIn_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
static RM_STATUS class07aUpdateSizeOut_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
static RM_STATUS class07aUpdatePointOut_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV10(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV10 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                VIDEOCLASS_PRINTF((DBG_LEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r"));
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                VIDEOCLASS_PRINTF((DBG_LEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r"));
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class07ASizeIn Invalid Height!!\r\n"));
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class07ASizeIn Invalid Height!!\r\n"));
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // save a copy of the POINT_IN values
            pOverlayHalObj->Overlay[buffNum].PointIn_s = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_IN, _S, data));
            pOverlayHalObj->Overlay[buffNum].PointIn_t =
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_IN, _T, data));

            class07aUpdatePointIn_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].DsDx = data;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].DtDy = data;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // save a copy of the POINT_OUT values
            pOverlayHalObj->Overlay[buffNum].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));
            pOverlayHalObj->Overlay[buffNum].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));

            class07aUpdatePointOut_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
			videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // save a copy of the SIZE_OUT values
            pOverlayHalObj->Overlay[buffNum].SizeOut_width = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_SIZE_OUT, _WIDTH, data));
            pOverlayHalObj->Overlay[buffNum].SizeOut_height =
                (U016)(DRF_VAL(07A, _SET_OVERLAY_SIZE_OUT, _HEIGHT, data));

            class07aUpdateSizeOut_NV10(pHalHwInfo, pOverlayHalObj, buffNum);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV10(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV10(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            // save a copy of the POINT_OUT values
            pOverlayHalObj->Overlay[0].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));
            pOverlayHalObj->Overlay[0].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));
            pOverlayHalObj->Overlay[1].PointOut_x = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _X, data));
            pOverlayHalObj->Overlay[1].PointOut_y = 
                (U016)(DRF_VAL(07A, _SET_OVERLAY_POINT_OUT, _Y, data));


            class07aUpdatePointOut_NV10(pHalHwInfo, pOverlayHalObj, 0);
            class07aUpdatePointOut_NV10(pHalHwInfo, pOverlayHalObj, 1);

            videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
            videoAdjustScalarForTV_NV10(pHalHwInfo, 1);

            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//
// Apply possible panning delta to POINT_IN method data.
//
static RM_STATUS
class07aUpdatePointIn_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PVIDEOHALINFO pVideoHalInfo;
    U016 pointoutX, pointoutY;
    U032 pointinS, pointinT;
    U032 dsdx, dtdy;

    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    // apply any panning deltas to the SIZE_OUT data
    pointoutX = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_x +
        (S016)(pVideoHalInfo->PanOffsetDeltaX[pVideoHalInfo->Head] * -1);
    pointoutY = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_y +
        (S016)(pVideoHalInfo->PanOffsetDeltaY[pVideoHalInfo->Head] * -1);

    pointinS = (S032)pOverlayHalObj->Overlay[buffNum].PointIn_s;
    // PointInT is 12.4 in the class def, but 12.3 in the hw
    pointinT = (S032)pOverlayHalObj->Overlay[buffNum].PointIn_t >> 1;

    // handle negative X
    if (pointoutX & 0x8000)
    {
        dsdx = pOverlayHalObj->Overlay[buffNum].DsDx;
        pointinS +=(((((S016)pointoutX * -1) * dsdx) + (1 << 15)) >> (20 - 4));
    }

    // handle negative Y
    if (pointoutY & 0x8000)
    {
        dtdy = pOverlayHalObj->Overlay[buffNum].DtDy;
        pointinT += (((((S016)pointoutY * -1) * dtdy) + (1 << 15)) >> (20 - 3));
    }

    // finally, write out new SIZE_OUT value
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             DRF_NUM(_PVIDEO, _POINT_IN, _S, pointinS) |
             DRF_NUM(_PVIDEO, _POINT_IN, _T, pointinT));

    return RM_OK;
}

//
// Apply possible panning delta to SIZE_OUT method data.
//
static RM_STATUS
class07aUpdateSizeOut_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PVIDEOHALINFO pVideoHalInfo;
    U016 pointoutX, pointoutY;
    U016 sizeoutW, sizeoutH;

    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    // apply any panning deltas to the SIZE_OUT data
    pointoutX = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_x +
        (S016)(pVideoHalInfo->PanOffsetDeltaX[pVideoHalInfo->Head] * -1);
    pointoutY = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_y +
        (S016)(pVideoHalInfo->PanOffsetDeltaY[pVideoHalInfo->Head] * -1);

    sizeoutW = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_width;
    sizeoutH = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_height;

    // handle negative X
    if (pointoutX & 0x8000)
    {
        // redo sizeout_width
        sizeoutW += (S016)pointoutX;
        if (sizeoutW & 0x8000)
            sizeoutW = 0;
    }

    // handle negative Y
    if (pointoutY & 0x8000)
    {
        sizeoutH += (S016)pointoutY;
        if (sizeoutH & 0x8000)
            sizeoutH = 0;
    }

    // finally, write out new SIZE_OUT value
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum),
             DRF_NUM(_PVIDEO, _SIZE_OUT, _HEIGHT, sizeoutH)|
             DRF_NUM(_PVIDEO, _SIZE_OUT, _WIDTH, sizeoutW));

    return RM_OK;
}

//
// The point out method require updates to other state if we're in panning
// mode and move the overlay window in the negative x or y direction.
//
static RM_STATUS
class07aUpdatePointOut_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    PVIDEOHALINFO pVideoHalInfo;
    U016 pointoutX, pointoutY;
    U032 pointinS, pointinT;
    U016 sizeoutW, sizeoutH;
    U032 dsdx, dtdy;

    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    // apply any panning deltas to the POINT_OUT data
    pointoutX = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_x +
        (S016)(pVideoHalInfo->PanOffsetDeltaX[pVideoHalInfo->Head] * -1);
    pointoutY = (S016)pOverlayHalObj->Overlay[buffNum].PointOut_y +
        (S016)(pVideoHalInfo->PanOffsetDeltaY[pVideoHalInfo->Head] * -1);

    pointinS = (S016)pOverlayHalObj->Overlay[buffNum].PointIn_s;
    // PointInT is 12.4 in the class def, but 12.3 in the hw
    pointinT = (S032)pOverlayHalObj->Overlay[buffNum].PointIn_t >> 1;
    sizeoutW = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_width;
    sizeoutH = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_height;

    // handle negative X
    if (pointoutX & 0x8000)
    {
        // redo POINT_IN_S
        dsdx = pOverlayHalObj->Overlay[buffNum].DsDx;
        pointinS +=(((((S016)pointoutX * -1) * dsdx) + (1 << 15)) >> (20 - 4));
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 DRF_NUM(_PVIDEO, _POINT_IN, _S, pointinS) |
                 DRF_NUM(_PVIDEO, _POINT_IN, _T, pointinT));

        // redo SIZE_OUT_WIDTH
        sizeoutW = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_width + (S016)pointoutX;
        if (sizeoutW & 0x8000)
            sizeoutW = 0;
        REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum),
                 DRF_NUM(_PVIDEO, _SIZE_OUT, _HEIGHT, sizeoutH)|
                 DRF_NUM(_PVIDEO, _SIZE_OUT, _WIDTH, sizeoutW));

        // now clip negative point out 0
        pointoutX = 0;
    }

    // handle negative Y
    if (pointoutY & 0x8000)
    {
        // redo POINT_IN_T
        dtdy = pOverlayHalObj->Overlay[buffNum].DtDy;
        pointinT += (((((S016)pointoutY * -1) * dtdy) + (1 << 15)) >> (20 - 3));
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 DRF_NUM(_PVIDEO, _POINT_IN, _S, pointinS) |
                 DRF_NUM(_PVIDEO, _POINT_IN, _T, pointinT));

        // redo SIZE_OUT_HEIGHT
        sizeoutH = (S016)pOverlayHalObj->Overlay[buffNum].SizeOut_height + (S016)pointoutY;
        if (sizeoutH & 0x8000)
            sizeoutH = 0;
        REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum),
                 DRF_NUM(_PVIDEO, _SIZE_OUT, _HEIGHT, sizeoutH)|
                 DRF_NUM(_PVIDEO, _SIZE_OUT, _WIDTH, sizeoutW));

        // now clip negative point out to 0
        pointoutY = 0;
    }

    // finally, write out new POINT_OUT value
    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum),
             DRF_NUM(_PVIDEO, _POINT_OUT, _X, pointoutX) |
             DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pointoutY));

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c04env10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04EMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV10(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV10(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}


#if 0
static VOID GetImageEvents(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV10(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv10.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c04fnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv10/mpnv10.c.
//
RM_STATUS class04FMethod_NV10(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV10(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV10(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv10/mpnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV10
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;

            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );

            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV10
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV10)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV10
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c63nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV10(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV10(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV10(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv10/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r"));
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM:     PVIDEO BUFFER: 0x%x\n", REG_RD32(NV_PVIDEO_BUFFER)));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV10
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV10(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV10(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0, start_buf0=0, start_buf1=0;
    U032 pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 0);
        videoAdjustScalarForTV_NV10(pHalHwInfo, 1);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63InitXfer\r\n"));

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV10(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV10;

    status = class63StartXfer_NV10(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV10
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63StartXfer\r\n"));

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv10.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        VIDEOCLASS_PRINTF((DBG_LEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n"));
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    videoAdjustScalarForTV_NV10(pHalHwInfo, buffNum);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV10(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c64nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv10.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV10(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv10\c65nv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv10.c.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV10(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c04env20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04EMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV20(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING) ) {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartRead couldn't reset interrupt!\n");
		DBG_BREAKPOINT();
    }
#endif

    //
    // Make sure the engine is configured correctly 
    //
    FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
	//
	// XXX for now we only support transfers out framebuffer memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT_SYSMEM, _DISABLED);
	if (Buffer == 0)
	{
		REG_WR32(NV_PME_FOUT_BUFF0_START, pDecompHalObj->ReadData[0].Offset
										+ (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
	} 
	else
	{
		REG_WR32(NV_PME_FOUT_BUFF1_START, pDecompHalObj->ReadData[1].Offset
										+ (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
										//- pDev->Mapping.PhysFbAddr
										+ pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

		// verify 4k!!
		REG_WR32(NV_PME_FOUT_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
	} 
							
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_FOUT_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_FOUT_SU_STATE, stateSU);
    }

	FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _ENABLED);

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            //
            // Stop the current data transfer immediately.
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _FOUT, _DISABLED);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;
            //
            // KICK IT OFF!!
            //
            class04EStartRead(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // NOT SUPPORTED!!
            //
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}


//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_FOUT_ME_STATE);
    stateSU = REG_RD32(NV_PME_FOUT_SU_STATE);
    stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

#if 0
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    //
    // Not supported!!!
    //
    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));

    return ;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING)))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _FOUT_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        //
        // Not supported!
        //if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
        //    GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        //else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_FOUT_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_FOUT_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_FOUT_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
        case CLASS04E_AUDIO_EVENT(1):
        case CLASS04E_IMAGE_EVENT(0):
        case CLASS04E_IMAGE_EVENT(1):
            //
            // These events aren't supported on nv20.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: class04EServiceEvent; bogus event type ", event);
            DBG_BREAKPOINT();
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c04dnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV20.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04DMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define Y_SCALE_INCR_PRECISION  10

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

#if 0
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
    	if (dwRealDivisor >= X_ScaleFactors[dwIndex])
    		*dwSpecialIndex = dwIndex;
    	dwIndex++;
    }	

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
    	{
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
    	*dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
    	}

    return (RM_OK);
}
#endif

// these are the weights supplied by Al Z
// they are derived from files located here:
// /home/al/proj/nv10/cmodel/video
// filb5_8.fil filc5_8.fil fild5_8.fil file5_8.fil
//  filb5_8.fil  corresponds to the b's section

static S032 VPFilterCos[5][8][5] = {
    { {0, 0, 128, 0, 0 },             // a's
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 },
      {0, 0, 128, 0, 0 }  },
      
    { {-14,  78,  78, -14,  0},      //  b's
      {-10,  50, 101, -20,  7},
      { -3,  25, 123, -22,  5},
      {  2,   4, 135, -19,  6},
      {  5, -11, 140, -11,  5},
      {  6, -19, 135,   4,   2},
      {  5, -22, 123,  25, -3},
      {  7, -20, 101,  50, -10} },
      
    { {-10, 74, 74, -10,  0 },     //c's
      {-13, 60, 86,  -7,  2 },
      {-11, 48, 96,   1, -6 },
      {-10, 33,101,  10, -6 },
      { -8, 20,104,  20, -8 },
      {-6,  10,101,  33, -10},
      {-6,   1, 96,  48, -11},
      {  2, -7, 86, 60, -13 }  },
      
    { { 5, 59, 59,  5,  0},       // d's
      { 4, 55, 66, 12, -9},
      {-1, 47, 68, 18, -4},
      {-3, 39, 72, 24, -4},
      {-4, 32, 72, 32, -4},
      {-4, 24, 72, 39, -3},
      {-4, 18, 68, 47, -1},
      {-9, 12, 66, 55,  4} },
      
    { {22, 42, 42, 22, 0 },    // e's
      {18, 39, 43, 24, 6 },
      {15, 37, 44, 26, 6 },
      {12, 35, 44, 29, 8 },
      {10, 32, 44, 32, 10},
      { 8, 29, 44, 35, 12},
      { 6, 26, 44, 37, 15},
      { 4, 24, 43, 39, 18}  }
   };
      
static RM_STATUS class04DProgramWeights(
    PHALHWINFO pHalHwInfo,
    U032 WidthIn,
    U032 WidthOut
)
{
    U032        scalefactor;
    U032        chunkIndex;
    U032        i;
    U032        ACos;
    U032        BCos;
    U008        dummy1;
    U008        dummy2;
    U008        dummy3;
 
    /*
     * hardware does not support upscaling
     */

    if ( WidthOut > WidthIn ) {
        return(RM_ERROR);
    }
    
    if(WidthIn == 0 ) {
        // WidthIn is used to indicate "empty" capture
        // so don't reprogram the weights...
        return (RM_OK);
    }
    
    if((WidthOut == 0) || (WidthIn == 0)) {
      scalefactor = 65536;
    } else {
      scalefactor = WidthIn * 65536 / WidthOut;
    }
    
    if( scalefactor > 163840 ) { // if( scalefactor > 2.5 * ( 1<< 16) ) 
        chunkIndex = 4;  //use e
    } 
    else if( scalefactor > 100270 ) { // else if( scalefactor > 1.53 * ( 1<< 16) ) 
        chunkIndex = 3;  //use d
    } 
    else if( scalefactor > 76677 ) { // else if( scalefactor > 1.17 * ( 1<< 16) )
        chunkIndex = 2;  //use c
    } 
    else if( scalefactor > 65536 ) { // else if( scalefactor > 1.0 * ( 1<< 16) ) 
        chunkIndex = 1;  //use b
    } 
    else {
        chunkIndex = 0;  //use a
    } 

    for(i=0;i<8;i++ ) {
        dummy1 = (U008)VPFilterCos[chunkIndex][i][0];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][1];
        dummy3 = (U008)VPFilterCos[chunkIndex][i][2];
        ACos = 
            ((((unsigned long) dummy3 ) << 16 ) & 0xFF0000 ) |
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );
        
        dummy1 = (U008)VPFilterCos[chunkIndex][i][3];
        dummy2 = (U008)VPFilterCos[chunkIndex][i][4];
        BCos = 
            ((((unsigned long) dummy2 ) << 8  ) & 0x00FF00 ) |
            ((((unsigned long) dummy1 ) << 0  ) & 0x0000FF );

        REG_WR32(NV_PME_HORIZ_WGHTS_A(i),ACos);
        REG_WR32(NV_PME_HORIZ_WGHTS_B(i),BCos);
    }

    return (RM_OK);
}
        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    //
    // Make sure the engine is configured correctly
    //
    FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _VBI2);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_ANC_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_ANC_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_ANC_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_ANC_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_ANC_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI_REGION, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    
    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_ANC_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_ANC_SU_STATE, stateSU);
    }

    
    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    V032        stateSU, stateME;
    U032        xscaleincr;
    U032        yscaleincr;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    //
    // Make sure the engine is configured correctly
    //
    if( pDecoderHalObj->lastImageStartLine == 99 ) {
      // program these up the first time through only
      FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
      FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _ENABLED);
      FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _ENABLED);
    }
    
    //
    // The hardware can only support dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    // only update scale weights if they change..
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) 
         || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
        status = class04DProgramWeights(pHalHwInfo,
                                        pDecoderHalObj->SetImage[0].WidthIn,
                                        pDecoderHalObj->SetImage[0].WidthOut);
      
      if (status)
          return (status);
    }  
                        
    //
    // Load up the buffer location and sizes
    //
    
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_TASKA_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
    }
    else
    {
        REG_WR32(NV_PME_TASKA_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

          REG_WR32(NV_PME_TASKA_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
          REG_WR32(NV_PME_TASKA_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
    } 
    
    //
    // turn on scaling
    //
    if((pDecoderHalObj->lastHeightIn != pDecoderHalObj->SetImage[0].HeightIn ) || (pDecoderHalObj->lastHeightOut != pDecoderHalObj->SetImage[0].HeightOut)) {
    
      yscaleincr = ((pDecoderHalObj->SetImage[0].HeightOut << Y_SCALE_INCR_PRECISION) - 1) / 
                 (pDecoderHalObj->SetImage[0].HeightIn - 1);
      REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, yscaleincr);
      // REG_WR_DRF_NUM(_PME, _TASKA_Y_SCALE, _INCR, (1 << 10));
    }
    if((pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) || (pDecoderHalObj->lastWidthOut != pDecoderHalObj->SetImage[0].WidthOut)) {
       
      xscaleincr = (65536 );
      if((pDecoderHalObj->SetImage[0].WidthOut != 0) && (pDecoderHalObj->SetImage[0].WidthIn != 0)) {
        // protection from  zero case
        xscaleincr = (65536 * pDecoderHalObj->SetImage[0].WidthIn) / pDecoderHalObj->SetImage[0].WidthOut;
      } 
      
      REG_WR_DRF_NUM(_PME, _TASKA_X_SCALE, _INCR, xscaleincr);
      FLD_WR_DRF_DEF(_PME, _TASKA_X_SCALE, _FILTER, _ENABLE);
    }

    //
    // program data width
    //

    if ( pDecoderHalObj->ImageDataWidth != (pDecoderHalObj->lastImageConfig & 0xFF) ) {
        if ( pDecoderHalObj->ImageDataWidth == 8 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _8);
        }
        else if ( pDecoderHalObj->ImageDataWidth == 16 ) {
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _VIDEO, _16);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFFFFFF00) | pDecoderHalObj->ImageDataWidth;
    }

    //
    // program null data checking
    //

    if ( pDecoderHalObj->NullData != ((pDecoderHalObj->lastImageConfig >> 12) & 0x3) ) {
        if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _DISABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        else if ( pDecoderHalObj->NullData == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED ) {
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _COMPARE, _ENABLED);
            FLD_WR_DRF_DEF(_PME, _NULL_DATA, _LINE_DETECT, _ENABLED);
            REG_WR_DRF_NUM(_PME, _NULL_DATA, _BYTE, pDecoderHalObj->ImageDataWidth);
        }
        pDecoderHalObj->lastImageConfig = (pDecoderHalObj->lastImageConfig & 0xFF) |
                                    ((pDecoderHalObj->Task & 0x1) << 8) |
                                    ((pDecoderHalObj->NullData & 0x3) << 12) |
                                    ((pDecoderHalObj->NullValue & 0x16) << 16);
    }

    //
    // Program the image startline
    //
    if(pDecoderHalObj->lastImageStartLine != pDecoderHalObj->ImageStartLine ) {
      REG_WR_DRF_NUM(_PME, _TASKA_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    }

    //
    // program maximum line length
    //
    if(pDecoderHalObj->lastWidthIn != pDecoderHalObj->SetImage[0].WidthIn ) {
      if( pDecoderHalObj->SetImage[Buffer].WidthOut == 0 ) {
        // write the smallest possible value of line length that is still valid
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0x4);
      } else {
        REG_WR32(NV_PME_TASKA_LINE_LENGTH, 2 * pDecoderHalObj->SetImage[0].WidthIn);
      }
    }
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_TASKA_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_TASKA_SU_STATE, stateSU);
    }
     
    pDecoderHalObj->lastWidthIn = pDecoderHalObj->SetImage[Buffer].WidthIn;
    pDecoderHalObj->lastWidthOut = pDecoderHalObj->SetImage[Buffer].WidthOut;
    pDecoderHalObj->lastHeightIn = pDecoderHalObj->SetImage[Buffer].HeightIn;
    pDecoderHalObj->lastHeightOut = pDecoderHalObj->SetImage[Buffer].HeightOut;
    pDecoderHalObj->lastImageStartLine = pDecoderHalObj->ImageStartLine;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage-end\r\n");

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV20(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _ANC_NOTIFY, _DISABLED);

            //
            // Stop the current vbi data transfer immediately
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _ANC_MODE, _DISABLED);

            //
            // return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // Disable interrupts
            // 
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKA_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _TASKB_NOTIFY, _DISABLED);

            //
            // Stop the current image data transfer immediately.
            //
            // XXX Is this enough?
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 0);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);
	 
            //
            // Return things to a known state...
            // even though a buffer may STILL be running
            //
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);

            //
            // Reset the checks.
            //
            pDecoderHalObj->lastWidthIn               = 0;
            pDecoderHalObj->lastWidthOut              = 0;
            pDecoderHalObj->lastHeightIn              = 0;
            pDecoderHalObj->lastHeightOut             = 0;
            //
            // this is used to indicate the first time around...
            // 99 with likely never be used at a startline value since it
            // should be something like 0 - 21  
            //
            pDecoderHalObj->lastImageStartLine        = 99;
            break;
        case NV04D_SET_IMAGE_CONFIG:
        {
            U032 tmp;

            //
            // Make sure all the fields are legal before saving them.
            //
            tmp = data & 0xFF;
            if ( (tmp == 8) || (tmp == 16) ) {
                pDecoderHalObj->ImageDataWidth = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 8) & 0x1;
            // only support TASK A for now
            if ( tmp == NV04D_SET_IMAGE_CONFIG_TASK_A ) {
                pDecoderHalObj->Task = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }

            tmp = (data >> 12) & 0x3;
            if ( (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_DISABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_BYTE_ENABLED) ||
                 (tmp == NV04D_SET_IMAGE_CONFIG_NULL_DATA_LINE_ENABLED) ) {
                pDecoderHalObj->NullData = tmp;
            }
            else {
                return NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pDecoderHalObj->NullValue = (data >> 16) & 0xFFFF;
            break;
        }
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware
            // until we actually need it.
            //
            if (data == 0)  data = 13;
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD_DRF(_PME, _ANC_CURRENT, _POS);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            //
            // Zero here is used to indicate we want a notify that a
            // field went by but no update.
            //
            if (pDecoderHalObj->SetImage[buffNum].HeightOut == 0)
                pDecoderHalObj->SetImage[buffNum].HeightOut = 1;
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD_DRF(_PME, _TASK_CURRENT, _POS);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_ANC_ME_STATE);
    stateSU = REG_RD32(NV_PME_ANC_SU_STATE);
    stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
    // clear the interrupt, in case another shows up!
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
	
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_TASKA_ME_STATE);
    stateSU = REG_RD32(NV_PME_TASKA_SU_STATE);
    stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0

    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF0_START );
                pDecoderHalObj->SetImage[0].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF0_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF0));
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_TASKA_BUFF1_START );
                pDecoderHalObj->SetImage[1].Info32 =
                    (REG_RD_DRF(_PME, _TASKA_ME_STATE, _BUFF1_ERROR_CODE) << 8 |
                    REG_RD_DRF(_PME, _TASKA_ME_STATE, _RP_FLAGS_BUFF1));
            }
        }
    }	

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _ANC_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _TASKA_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    if (event == CLASS04D_VBI_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_VBI_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_ANC_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_ANC_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_ANC_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(0))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF0_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else if (event == CLASS04D_IMAGE_EVENT(1))
    {
        stateRM = REG_RD32(NV_PME_TASKA_RM_STATE);
        stateRM ^= 1 << SF_SHIFT(NV_PME_TASKA_RM_STATE_BUFF1_INTR_NOTIFY);
        REG_WR32(NV_PME_TASKA_RM_STATE, stateRM);
    }
    else
    {
        status = RM_ERR_BAD_ARGUMENT;
    }

    //
    // XXX (scottl):
    //
    // Shouldn't this be #ifdef DEBUG???
    //
    if (event == CLASS04D_VBI_EVENT(0) || event == CLASS04D_VBI_EVENT(1))
    {
        U032 error;
        // and out the rest of the bits
        error = REG_RD32(NV_PME_ANC_ME_STATE) & 0x7E00;
        if (error) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: C04DNV20: errors detected in ME register\n");
        }
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c64nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleX = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScaleY = videoConvertScaleFactor_NV20(data);
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidScalerHalObj->xStart) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c047nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000);
     
//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
RM_STATUS class047Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047SizeIn Invalid Height!!\r\n"));
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047SizeIn Invalid Height!!\r\n"));
                return (NV047_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c07anv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: C07ANV20.C                                                        *
*   This module implements the NV10_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class07aMethod
//
// Process all class07a methods.
//
RM_STATUS class07aMethod_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV07A_STOP_OVERLAY(0):
        case NV07A_STOP_OVERLAY(1):
            videoStopOverlay_NV20(pHalHwInfo, pOverlayHalObj, data);
            break;
        case NV07A_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV07A_SET_CONTEXT_DMA_OVERLAY(0):
        case NV07A_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV07A_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE(0):
        case NV07A_SET_OVERLAY_LUMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_LUMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_LUMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE(0):
        case NV07A_SET_OVERLAY_CHROMINANCE(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_CHROMINANCE(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_CHROMINANCE(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_COLORKEY(0):
        case NV07A_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Only 1 ColorKey register in NV20 ... 
            REG_WR32(NV_PVIDEO_COLOR_KEY, data);

            break;
        }
        case NV07A_SET_OVERLAY_OFFSET(0):
        case NV07A_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_OFFSET(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_IN(0):
        case NV07A_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            // Check for overflow and limit if necessary
            if ((data & 0xFFFF) > 0x7fe) {
                VIDEOCLASS_PRINTF((DBG_LEVEL_WARNINGS, "NVRM: Overlay Warning! Width Overflow.\n\r"));
                data = (data & 0xffff0000) | 0x7fe;
            }
            if ((data >> 16) > 0x7fe) {
                VIDEOCLASS_PRINTF((DBG_LEVEL_WARNINGS, "NVRM: Overlay Warning! Height Overflow.\n\r"));
                data = (data & 0xffff) | 0x7fe0000;
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class07ASizeIn Invalid Height!!\r\n"));
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            //
            // Check to see that the height is > 0; if we program the hardware with zero (which is against the class def'n),
            // the hardware will most likely protection fault
            //
            if (((data >> DRF_SHIFT(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) & DRF_MASK(NV07A_SET_OVERLAY_SIZE_IN_HEIGHT)) == 0)
            {
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class07ASizeIn Invalid Height!!\r\n"));
                return (NV07A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT);
            }

            REG_WR32(NV_PVIDEO_SIZE_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_IN(0):
        case NV07A_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_IN(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DU_DX(0):
        case NV07A_SET_OVERLAY_DU_DX(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DU_DX(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DS_DX(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_DV_DY(0):
        case NV07A_SET_OVERLAY_DV_DY(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_DV_DY(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_DT_DY(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT(0):
        case NV07A_SET_OVERLAY_POINT_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_SIZE_OUT(0):
        case NV07A_SET_OVERLAY_SIZE_OUT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), data);

            break;
        }
        case NV07A_SET_OVERLAY_FORMAT(0):
        case NV07A_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV07A_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (videoHwOwnsBuffer_NV20(pHalHwInfo, buffNum, pOverlayHalObj))
                return NV07A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            data &= 0x7FFFFFFF;   // AND of the notify bit.
            REG_WR32(NV_PVIDEO_FORMAT(buffNum), data);

            switch (buffNum){
                case 0:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET);
                    break;
                case 1:
                    pOverlayHalObj->PvideoBufferCopy = DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET);
                    break;
            }
                
            // call the kickoff proc
			videoKickOffOverlay_NV20(pHalHwInfo, pOverlayHalObj, buffNum);
            break;
        }
        case NV07A_SET_OVERLAY_POINT_OUT_A:
        {
            REG_WR32(NV_PVIDEO_POINT_OUT(0), data);
            REG_WR32(NV_PVIDEO_POINT_OUT(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_LUMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_LUMINANCE(0), data);
            REG_WR32(NV_PVIDEO_LUMINANCE(1), data);
            break;
        }
        case NV07A_SET_OVERLAY_CHROMINANCE_A:
        {
            REG_WR32(NV_PVIDEO_CHROMINANCE(0), data);
            REG_WR32(NV_PVIDEO_CHROMINANCE(1), data);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV07A_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c63nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// We can't quite use the DRF macros due to how they concatenate strings
// to create field accesses and do some bit shifting ... these are only
// used for NV_PVIDEO_FORMAT updates
//
#define VIDEO_FORMAT_FLD_WR_DEF(buf, fld, def)                                                  \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                     \
                (DRF_MASK(NV_PVIDEO_FORMAT ## fld) << DRF_SHIFT(NV_PVIDEO_FORMAT ## fld))) |    \
                DRF_DEF(_PVIDEO, _FORMAT, fld, def))

#define VIDEO_FORMAT_FLD_WR_PITCH(buf, val)                                                       \
        REG_WR32(NV_PVIDEO_FORMAT(buf), (REG_RD32(NV_PVIDEO_FORMAT(buf)) &~                       \
                (DRF_MASK(NV_PVIDEO_FORMAT_PITCH) << DRF_SHIFT(NV_PVIDEO_FORMAT_PITCH))) | val)

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV20(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO, U032);

//
// Statics
//
static RM_STATUS class63StartXfer_NV20(PHALHWINFO, VOID *, U032);
static VOID class63DualSurface_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63ColorKey_NV20(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv20/vidnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
            {
                // activate a PVIDEO_STOP and disappear the window by
                // setting SIZE_OUT to 0
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63StopTransfer: set STOP_ACTIVE/IMMEDIATELY\n\r"));
                VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM:     PVIDEO BUFFER: 0x%x\n", REG_RD32(NV_PVIDEO_BUFFER)));
                REG_WR32(NV_PVIDEO_STOP,
                         DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                         DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            }
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

static VOID class63ColorKey_NV20
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_COLOR_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_COLOR_KEY, color);
                break; 
        }
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _COLOR_KEY_EQUAL);
    } 
    else
    {
        // XXX does this do it??
        REG_WR32(NV_PVIDEO_COLOR_KEY, NV_PVIDEO_COLOR_KEY_VALUE_DONT_CARE);
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _DISPLAY, _ALWAYS);
    }
}

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV20(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)

{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;
    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        // XXX for now we'll leave it at masking 12 bits
        step_x = (((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1)) & 0xfff;
        step_y = (((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1)) & 0xfff;
    }
    else
        return;


    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START, vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END, vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START, hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END, hbe);    

    // Video scalar
    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
    REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
    REG_WR32(NV_PVIDEO_DT_DY(1), step_y);
    //WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1

    VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);
    //WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0

    VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);
    //WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1

    // XXX I guess we'll set both??
    REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
    REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);
    //WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
}


//****************************************************************************************
//
//      Program the video scalar to scan out the framebuffer (desktop) to the TV encoder.
//      Or, turn off the video scalar for TV only or monitor.
VOID class63DualSurfaceDesktop_NV20(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff=0, setup=0, vbs=0, vbe=0, hbs=0, hbe=0;
    U032 start_buf0=0, start_buf1=0, pitch0=0, pitch1=0, xy_pos=0, hw=0;
    U032 step_x=0, step_y=0;
    U032 fifo0, fifo1, reg32;
    int dualSurface = 0;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;

        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY) >> 1; // 2:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY) >> 1; // 2:1
                //scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                step_x = DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY);      // 1:1
                step_y = DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY);      // 1:1
                //scale = 0x08000800;     // 1:1
            }
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // XXX idle everything??
        REG_WR32(NV_PVIDEO_BUFFER, 0);

        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    

        // Video scalar
        REG_WR32(NV_PVIDEO_DS_DX(0), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(0), step_y);
        REG_WR32(NV_PVIDEO_DS_DX(1), step_x);
        REG_WR32(NV_PVIDEO_DT_DY(1), step_y);

        VIDEO_FORMAT_FLD_WR_PITCH(0, pitch0);

        VIDEO_FORMAT_FLD_WR_PITCH(1, pitch1);

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_SIZE_OUT(0), hw);
        REG_WR32(NV_PVIDEO_SIZE_OUT(1), hw);

#if 0 
        // could set this, but for now lets just use the defaults
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_3, _WATER_MARK1, fifo0);
        FLD_WR_DRF_NUM(_PVIDEO, _DEBUG_2, _BURST1, fifo1);
        //WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        //WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
#endif

        // XXX I guess we'll set both??
        REG_WR32(NV_PVIDEO_POINT_OUT(0), xy_pos);
        REG_WR32(NV_PVIDEO_POINT_OUT(1), xy_pos);
        //WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)

        REG_WR32(NV_PVIDEO_OFFSET(0), start_buf0);
        //WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0

        REG_WR32(NV_PVIDEO_OFFSET(1), start_buf1);
        //WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1
            
        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE);  // enable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar

        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8); // set format
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
#if 0
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        //WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE
#endif
    }    
    else    // need to set up for either TV only or Monitor only
    {

        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        //reg32 = ReadPriv32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        //WritePriv32(setup, 0x680700);   // TV SETUP

        FLD_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);  // disable scalar
        //FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63InitXfer\r\n"));

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV20(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_CR8YB8CB8YA8);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        VIDEO_FORMAT_FLD_WR_DEF(0, _COLOR, _LE_YB8CR8YA8CB8);

    pVidFromMemHalObj->KickOffProc = class63StartXfer_NV20;

    status = class63StartXfer_NV20(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);

    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV20
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS status = RM_OK;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class63StartXfer\r\n"));

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv20.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        VIDEOCLASS_PRINTF((DBG_LEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n"));
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_CR8YB8CB8YA8);
    }
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
    {
        VIDEO_FORMAT_FLD_WR_DEF(buffNum, _COLOR, _LE_YB8CR8YA8CB8);
    }

    // Write the offset straight away (must be 64byte aligned). If any of the low order
    // 6 bits are set from ImageScan.offset, we'll divide by 2 to convert bytes to texels
    // and shift this value by 4 to get into the integer portion of POINT_IN_S.
    REG_WR32(NV_PVIDEO_OFFSET(buffNum), pVidFromMemHalObj->Buffer[buffNum].Start);
    REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
             (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_S) << DRF_SHIFT(NV_PVIDEO_POINT_IN_S))) |
             DRF_NUM(_PVIDEO, _POINT, _IN_S, ((pVidFromMemHalObj->Buffer[buffNum].Start & 0x3F) >> 1) << 4));

    // Set the pitch (must be 64byte aligned).
    // If the LSB's are 0x2 then we're doing a bob and POINT_IN_T needs to be -1/2.
    //
    VIDEO_FORMAT_FLD_WR_PITCH(buffNum, pVidFromMemHalObj->Buffer[buffNum].Pitch);
    if ((pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x3) == 0x2)
    {
        REG_WR32(NV_PVIDEO_POINT_IN(buffNum),
                 (REG_RD32(NV_PVIDEO_POINT_IN(buffNum)) & ~(DRF_MASK(NV_PVIDEO_POINT_IN_T) << DRF_SHIFT(NV_PVIDEO_POINT_IN_T))) |
                 DRF_NUM(_PVIDEO, _POINT, _IN_T, (0xFFF8 >> 1)));
    }

    REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    REG_WR32(NV_PVIDEO_SIZE_OUT(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_DS_DX(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleX);
    REG_WR32(NV_PVIDEO_DT_DY(buffNum), pVidFromMemHalObj->Buffer[buffNum].VideoScaleY);

    class63ColorKey_NV20(pHalHwInfo, pVidFromMemHalObj, buffNum);

    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    // HW now owns the buffer
    if (buffNum == 0)
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _SET);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _SET);

#ifdef DEBUG_TIMING
    if (buffNum == 0)
        vmmOutDebugString("\n0B");
    else
        vmmOutDebugString("\n1B");
#endif
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c04fnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: CLASS04F.C                                                        *
*   This module implements the NV_EXTERNAL_PARALLEL_BUS object              *
*   class and its corresponding methods.                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv20/mpnv20.c.
//
RM_STATUS class04FMethod_NV20(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV20(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV20(PMPSERVICEEVENTARG_000);

#define	VIPREG_TIMEOUT_CNT	1000		// XXX arbitrary

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv20/mpnv20.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV20
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04F_STOP_TRANSFER:
            //
            // Stop either read or write
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Write.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Write.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_WRITE_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
        {
            U032 vipCtrl, cnt;

            pPBusHalObj->Write.Data = data;
            
            //
            // Make sure there isn't a write pending
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_WRITE_DATA state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _PENDING) );
            
            //
            // Do the write now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Write.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Write.Address & 0x0000FFFF));
            REG_WR32(NV_PME_VIPREG_DATA, pPBusHalObj->Write.Data);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _START);
            break;
        }
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            if (pPBusHalObj->Read.DataSize > 4)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            if (pPBusHalObj->Read.AddressSize != 2)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad NV04F_READ_SIZE argument ", data);
                return NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT;
            }
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
        {
            U032 vipCtrl, cnt, data32;
            
            pPBusHalObj->Read.Notify = data;

            //
            // Make sure there isn't a read pending.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NV04F_READ_GET_DATA_NOTIFY state in use\r\n");
                    return NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                }
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            //
            // Do the read now.
            //
            REG_WR32(NV_PME_VIPREG_NBYTES, pPBusHalObj->Read.DataSize);
            REG_WR32(NV_PME_VIPREG_ADDR, (pPBusHalObj->Read.Address & 0x0000FFFF));
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _START);
            
            //
            // Wait for the read to complete.
            //
            cnt = 0;
            do {
                vipCtrl = REG_RD32(NV_PME_VIPREG_CTRL);
                if ( ++cnt > VIPREG_TIMEOUT_CNT )
                    return(RM_ERROR);
            } while ( vipCtrl & DRF_DEF(_PME, _VIPREG_CTRL, _READ, _PENDING) );
            
            data32 = REG_RD32(NV_PME_VIPREG_DATA);
            
            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        }
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV20
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    intr0 = REG_RD32(NV_PME_INTR_0);

    // XXX not final (need to finish porting class04F to NV20)

    //
    // Let RM know we've got a pbus event pending.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV20
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _REGTIMEOUT_NOTIFY, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _REGTIMEOUT_NOTIFY, _DISABLED);

    //
    // Clear state in exception data structure.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c04dnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: C04DNV04.C                                                        *
*   This module implements the chip-dependent portion of the                *
*   NV_EXTERNAL_VIDEO_DECODER object class and its corresponding methods.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04DMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04DGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04DServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04DFindNearestScaleFactor(
    U032 dwRealDivisor,
    U032 *dwSpecialIndex
)
{
    U032 dwIndex=0;
    U032 X_ScaleFactors[] = { 1,2,3,4,6,8,12,16,24, 0xFFFF };

    //
    // Converts dwRealDivisor into an index which will point to nearest best quality divisor,
    //  will always be greater than RealDivisor if not equal
    //
    *dwSpecialIndex = 0xFFFF;
    
    while (X_ScaleFactors[dwIndex] != 0xFFFF)
    {
        if (dwRealDivisor >= X_ScaleFactors[dwIndex])
                *dwSpecialIndex = dwIndex;
        dwIndex++;
    }   

    // this should never occur
    if (*dwSpecialIndex == 0xFFFF)
        {
        *dwSpecialIndex = 1; // could not find index so just do a verbatim copy
        return (RM_ERROR);
        }

    return (RM_OK);
}
    
static RM_STATUS class04DCalculateScaleIncrement(
    U032 WidthIn,
    U032 HeightIn,
    U032 WidthOut,
    U032 HeightOut,
    U032 *ScaleFactor
)
{
    U032        FittedX, FittedY;
    U032        NearestScaleFactor;
    U032        X_ScaleFactors[]  = { 1,2,3,4,6,8,12,16,24, 0xFFFF };
    U032        X_n0[]            = { 0<<5,1<<5,2<<5,2<<5,3<<5,3<<5,4<<5,4<<5,5<<5, 0xFFFF};
    U032        X_n1[]            = { 0<<8,1<<8,1<<8,2<<8,2<<8,3<<8,3<<8,4<<8,4<<8, 0xFFFF};
    RM_STATUS   status;

    if (WidthOut == 0)
        WidthOut = WidthIn; // if this is too big, should be caught on length boundary

    FittedX = WidthIn / WidthOut;

    if (FittedX > 24)
        FittedX = 24; // max out scale 

    status = class04DFindNearestScaleFactor(FittedX, &NearestScaleFactor);
    if (status)
        return (status);
        
    FittedX = X_ScaleFactors[ NearestScaleFactor ] | X_n0[ NearestScaleFactor ] 
                                | X_n1[ NearestScaleFactor ] ;

    if (HeightOut == 0)
        HeightOut = HeightIn;

    FittedY = ((HeightOut -1 ) << 10) / (HeightIn - 1) ;
                                        
    if (FittedY > 0x400)
        FittedY = 0x400; // check these values (2^11 - 1), bloody small picture!!               

    *ScaleFactor = (FittedY << 16) | FittedX;

    return (RM_OK);
}

        
static RM_STATUS class04DStartVbi
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032 stateSU, stateME;

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartVbi\r\n");

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old
    // class66 overwrites)
    //
    // only change the bus mode if there isn't a decompressor object
    // using the MPC
    //

    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _2);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);  // also need to enable image (from Joe Yeun)
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetVbi[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_VBI_BUFF0_START, pDecoderHalObj->SetVbi[0].Offset
                                       + (pDecoderHalObj->SetVbi[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF0_PITCH, pDecoderHalObj->SetVbi[0].Pitch);
        REG_WR32(NV_PME_VBI_BUFF0_LENGTH, pDecoderHalObj->SetVbi[0].Pitch * pDecoderHalObj->SetVbi[0].Height);
    } 
    else
    {
        REG_WR32(NV_PME_VBI_BUFF1_START, pDecoderHalObj->SetVbi[1].Offset
                                       + (pDecoderHalObj->SetVbi[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                       + pDecoderHalObj->SetVbi[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_VBI_BUFF1_PITCH, pDecoderHalObj->SetVbi[1].Pitch);
        REG_WR32(NV_PME_VBI_BUFF1_LENGTH, pDecoderHalObj->SetVbi[1].Pitch * pDecoderHalObj->SetVbi[1].Height);
    } 
    
    //
    // Program the global VBI settings
    //
    FLD_WR_DRF_NUM(_PME, _VBI, _START_LINE, pDecoderHalObj->SetVbi[1].FirstLine);
    FLD_WR_DRF_NUM(_PME, _VBI, _NUM_LINES, pDecoderHalObj->SetVbi[1].Height);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VBI_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[0].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetVbi[1].Field == NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_VBI_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VBI_SU_STATE, stateSU);
    }

    return(RM_OK);
}


static RM_STATUS class04DStartImage
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 Buffer
)
{
    PMPHALINFO_NV04 pMpHalPvtInfo;
    V032        stateSU, stateME;
    U032        ScaleFactor;
    RM_STATUS   status;
    
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04DStartImage\r\n");

    pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    if ( pMpHalPvtInfo->CurrentDecompressor == 0 )
        FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _CCIR656);

    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support vbi dma transfers to framebuffer
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    if (pDecoderHalObj->SetImage[Buffer].CtxDma->AddressSpace != ADDR_FBMEM)
        return (RM_ERROR);
    
    //
    // Calculate the scale factors given the in & out sizes
    //
    status = class04DCalculateScaleIncrement(
                pDecoderHalObj->SetImage[0].WidthIn,
                pDecoderHalObj->SetImage[0].HeightIn,
                pDecoderHalObj->SetImage[0].WidthOut,
                pDecoderHalObj->SetImage[0].HeightOut,
                &ScaleFactor);
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04DFindNearestScaleFactor, cannot find nearest scale factor !\r\n");
        return (status);
    }

    //
    // Load up the buffer location and sizes
    //
    if (Buffer == 0)
    {
        REG_WR32(NV_PME_IMAGE_BUFF0_START, pDecoderHalObj->SetImage[0].Offset
                                         + (pDecoderHalObj->SetImage[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[0].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecoderHalObj->SetImage[0].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, pDecoderHalObj->SetImage[0].Pitch * pDecoderHalObj->SetImage[0].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF0_SCALE_INCR, ScaleFactor);
    } 
    else
    {
        REG_WR32(NV_PME_IMAGE_BUFF1_START, pDecoderHalObj->SetImage[1].Offset
                                         + (pDecoderHalObj->SetImage[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                         + pDecoderHalObj->SetImage[1].CtxDma->PteAdjust);

        REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecoderHalObj->SetImage[1].Pitch);
        REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, pDecoderHalObj->SetImage[1].Pitch * pDecoderHalObj->SetImage[1].HeightOut);
        
        REG_WR32(NV_PME_IMAGE_BUFF1_SCALE_INCR, ScaleFactor);
    } 
    
    //
    // Program the global image settings
    //
    REG_WR_DRF_NUM(_PME, _IMAGE_Y_CROP, _STARTLINE, pDecoderHalObj->ImageStartLine);
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[0].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_FIELD));
            
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        //
        // Choose the capture field (progressive == even)
        //
        if ((pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE)
         || (pDecoderHalObj->SetImage[1].Field == NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD))
            stateSU |= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD);
        else            
            stateSU &= ~(1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_FIELD));
    
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }
    
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04DMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, buffNum;

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04D_STOP_TRANSFER_VBI:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes in
            // IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you can
            // choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VBI_MODE, _DISABLED);
    
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VBI_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            break;
        case NV04D_STOP_TRANSFER_IMAGE:
            //
            // As per Joe Yuen email comments 10/30/98
            // You can force termination immediately by writing CONFIG_0_IMAGE
            // to DISABLED and CONFIG_0_VBI_MODE to DISABLED. This will stop
            // capture, flush the internal FIFOs, and set the error codes
            // in IMAGE_ME_STATE and VBI_ME_STATE to DISABLED (which you
            // can choose to ignore).
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _IMAGE, _DISABLED);
         
            // silly us forgetting to disable interrupts before we should
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _IMAGE_NOTIFY, _DISABLED);
    
            // return things to a known state...
            // even though a buffer may STILL be running
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        case NV04D_SET_IMAGE_START_LINE:
            //
            // Load the local copy, but don't hit the hardware until
            // we actually need it
            //
            pDecoderHalObj->ImageStartLine = data;
            break;
        case NV04D_SET_VBI_SIZE(0):
        case NV04D_SET_VBI_SIZE(1):
            buffNum = (offset == NV04D_SET_VBI_SIZE(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].FirstLine = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Height    = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_VBI_OFFSET(0):
        case NV04D_SET_VBI_OFFSET(1):
            buffNum = (offset == NV04D_SET_VBI_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Offset = data;
            break;
        case NV04D_SET_VBI_FORMAT(0):
        case NV04D_SET_VBI_FORMAT(1):
            buffNum = (offset == NV04D_SET_VBI_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetVbi[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetVbi[buffNum].Notify = ((data >> 24) & 0xFF);
            //
            // Kick it off!!
            //
            class04DStartVbi(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_VBI_OFFSET_NOTIFY(0):
        case NV04D_GET_VBI_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_VBI_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetVbi[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        case NV04D_SET_IMAGE_SIZE_IN(0):
        case NV04D_SET_IMAGE_SIZE_IN(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_IN(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthIn  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightIn = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_SIZE_OUT(0):
        case NV04D_SET_IMAGE_SIZE_OUT(1):
            buffNum = (offset == NV04D_SET_IMAGE_SIZE_OUT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].WidthOut  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].HeightOut = ((data >> 16) & 0xFFFF);
            break;
        case NV04D_SET_IMAGE_OFFSET(0):
        case NV04D_SET_IMAGE_OFFSET(1):
            buffNum = (offset == NV04D_SET_IMAGE_OFFSET(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Offset = data;
            break;
        case NV04D_SET_IMAGE_FORMAT(0):
        case NV04D_SET_IMAGE_FORMAT(1):
            buffNum = (offset == NV04D_SET_IMAGE_FORMAT(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].Pitch  = (data & 0xFFFF);
            pDecoderHalObj->SetImage[buffNum].Field  = ((data >> 16) & 0xFF);
            pDecoderHalObj->SetImage[buffNum].Notify = ((data >> 24) & 0xFF);
            
            //
            // Kick it off
            //
            class04DStartImage(pHalHwInfo, pDecoderHalObj, buffNum);
            break;
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(0):
        case NV04D_GET_IMAGE_OFFSET_NOTIFY(1):
            //
            // The scan position is the same for both buffers.
            //
            buffNum = (offset == NV04D_GET_IMAGE_OFFSET_NOTIFY(0)) ? 0 : 1;
            pDecoderHalObj->SetImage[buffNum].GetOffsetData = REG_RD32(NV_PME_FIFO_CURRENT);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04D_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVbiEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VBI_ME_STATE);
    stateSU = REG_RD32(NV_PME_VBI_SU_STATE);
    stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_VBI_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_VBI_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_VBI_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_VBI_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVbiEvents\n");

    return;
}

static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECODERHALOBJECT pDecoderHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
    
        // clear the interrupt, in case another shows up!
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        
    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    // buffer 0
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(0))
    {
        pDecoderHalObj->SetImage[0].Info32 = 0;
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(0);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF0_START );
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04D_IMAGE_EVENT(1))
    {
        pDecoderHalObj->SetImage[1].Info32 = 0;
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04D_IMAGE_EVENT(1);
                //
                // Used for callback support
                //
                pHalHwInfo->pMpHalInfo->ImageBufferNumber = REG_RD32( NV_PME_IMAGE_BUFF1_START );
            }
        }
    }   

    *pEventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}

//
// class04DGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04DGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECODERHALOBJECT pDecoderHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending VBI/IMAGE events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // No current decoder object, so treat exception as spurious.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _RESET));
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        pMpGetEventStatusArg->events = 0;
        return (RM_ERROR);
    }

    pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VBI_NOTIFY, _PENDING))
            GetVbiEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_VBI_EVENT(0)|CLASS04D_VBI_EVENT(1));
    }
    if (eventsPending & (CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecoderHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04D_IMAGE_EVENT(0)|CLASS04D_IMAGE_EVENT(1));
    }

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04DServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04DServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04D_VBI_EVENT(0):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_VBI_EVENT(1):
            stateRM = REG_RD32(NV_PME_VBI_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VBI_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04D_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv20\c65nv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv20.c.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class65Method_NV20(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            if (data)
            {
                switch (pVidColorKeyHalObj->ColorFormat)
                {
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0x7FFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
                    case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
                    case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFF);
                        break;
                    case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
                    case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data & 0xFFFFFF);
                        break;
                    default:
                        REG_WR32(NV_PVIDEO_COLOR_KEY, data);
                        break;
                }
            }
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _POINT_OUT, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _POINT_OUT, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c04fnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************ Parallel Bus Manager ******************************\
*                                                                           *
* Module: C04FNV04.C                                                        *
*   This module implements the nv4-specific portions of the                 *
*   NV_EXTERNAL_PARALLEL_BUS class (methods, etc.).                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04FMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04FGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04FServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04FMethod_NV04
(
    PMPMETHODARG_000 pMpMethodArg
)
{
    PPARALLELBUSHALOBJECT pPBusHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data, data32;
    S032 saddr;

    pPBusHalObj = (PPARALLELBUSHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04F_WRITE_SIZE:
            pPBusHalObj->Write.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Write.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_WRITE_ADDRESS:
            pPBusHalObj->Write.Address = data;
            break;
        case NV04F_WRITE_DATA:
            pPBusHalObj->Write.Data = data;

            //
            // XXX allow for negative addresses to be passed in so we
            // can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Write.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Write.DataSize)
            {
                // 8bit access
                case 0x0001:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data);
                    break;

                    // 16bit access
                case 0x0002:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    break;

                    // 24bit access
                case 0x0003:
                    /* ???
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address)+0x200, pBus->Write.Data & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+1)+0x200, (pBus->Write.Data >> 8) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x200+pBus->Write.Address+2)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       */
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    break;

                    // 32bit access
                case 0x0004:
                    REG_WR32(NV_PME_EXTERNAL(saddr), pPBusHalObj->Write.Data & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+1), (pPBusHalObj->Write.Data >> 8) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+2), (pPBusHalObj->Write.Data >> 16) & 0xFF);
                    REG_WR32(NV_PME_EXTERNAL(saddr+3), (pPBusHalObj->Write.Data >> 24) & 0xFF);

                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Write.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Write.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Write.Address)       & 0xFF);
                    
                       REG_WR32(NV_PME_EXTERNAL(0x03)+0x200, (pBus->Write.Data >> 24) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x02)+0x200, (pBus->Write.Data >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x01)+0x200, (pBus->Write.Data >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x00)+0x200, (pBus->Write.Data)       & 0xFF);
                       */
                    
                    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ClassNV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY04F Write (index): ", pBus->Write.Address);
                    break;
            }
            
            //DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "w");
            
            // Impose a bit of a break
            //tmrDelay(100000);         // 500ns delay    
            break;
        case NV04F_READ_SIZE:
            pPBusHalObj->Read.DataSize = (U016)(data & 0x0000FFFF);
            pPBusHalObj->Read.AddressSize = (U016)((data >> 16) & 0x0000FFFF);
            break;
        case NV04F_READ_ADDRESS:
            pPBusHalObj->Read.Address = data;
            break;
        case NV04F_READ_GET_DATA_NOTIFY:
            pPBusHalObj->Read.Notify = data;

            //
            // XXX allow for negative addresses to be passed in so
            // we can access the MPC (temporary)
            //
            saddr = (S032)(pPBusHalObj->Read.Address) + 0x200;

            //
            // PME_EXTERNAL_BUS is an 8bit bus, so we must break
            // up larger transfers
            //
            switch (pPBusHalObj->Read.DataSize)
            {
                // 8bit access
                case 0x0001:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 16bit access
                case 0x0002:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 24bit access
                case 0x0003:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    break;

                    // 32bit access
                case 0x0004:
                    data32 = REG_RD32(NV_PME_EXTERNAL(saddr+3));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+2));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr+1));
                    data32 <<= 8;
                    data32 |= REG_RD32(NV_PME_EXTERNAL(saddr));
                    
                    /* stuff specific to CCube
                       REG_WR32(NV_PME_EXTERNAL(0x06)+0x200, (pBus->Read.Address >> 16) & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x05)+0x200, (pBus->Read.Address >> 8)  & 0xFF);
                       REG_WR32(NV_PME_EXTERNAL(0x04)+0x200, (pBus->Read.Address)       & 0xFF);
                    
                       data32 = REG_RD32(NV_PME_EXTERNAL(0x03)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x02)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x01)+0x200);
                       data32 <<= 8;
                       data32 |= REG_RD32(NV_PME_EXTERNAL(0x00)+0x200);
                       */

                    break;
            }

            //
            // Save data off so that RM can return it via the notify.
            //
            pPBusHalObj->Read.ReadData = data32;
            break;
        case NV04F_SET_INTERRUPT_NOTIFY:
            //
            // Make sure the interrupt is enabled
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _ENABLED);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04F_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

RM_STATUS class04FGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 intr0;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    intr0 = REG_RD32(NV_PME_INTR_0);

    //
    // If there's a VMI interrupt pending, then we need
    // to let the RM know so it can post notifies.
    //
    if (intr0 & DRF_DEF(_PME, _INTR_0, _VMI, _PENDING))
    {
        pMpGetEventStatusArg->events = CLASS04F_PBUS_EVENT;
    }
    else
    {
        pMpGetEventStatusArg->events = 0;
    }

    //
    // This value is given back in the service routine so we know
    // which exceptions we are to clear.
    //
    pMpGetEventStatusArg->intrStatus = intr0;

    return RM_OK;
}

RM_STATUS class04FServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The intrStatus value was saved off in GetEventStatus.
    //
    if (pMpServiceEventArg->event != CLASS04F_PBUS_EVENT)
    {
        pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
        return RM_ERR_BAD_ARGUMENT;
    }

    //
    // Clear the interrupt
    //
    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VMI, _RESET));

    //
    // This is a single-shot notify.  Disable the interrupt.
    //
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VMI, _DISABLED);

    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c047nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: class047.C                                                        *
*   This module implements the NV04_VIDEO_OVERLAY object class and          *
*   its corresponding methods.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class047InitXfer_NV04(PHALHWINFO, VOID *, U032);
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class047Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class047StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class047KickoffBuffer_NV04(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

RM_STATUS class047InitXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    RM_STATUS       status = RM_OK;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047InitXfer_NV04\r\n"));

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;
        
    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV04_VIDEO_OVERLAY);

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);    
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);    
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class047StartXfer_NV04(pHalHwInfo, pOverlayHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.
        if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
        {
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0);
        }
        else
        {
            // Kickoff buffer 1.
            class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1);
        }

        //
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing. Making sure to enable the video pipeline
        // from VBLANK (and not doing it here) fixes 19991220-082127.
        //
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;
        
        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pOverlayHalObj->KickOffProc = class047StartXfer_NV04;
    }

    return (status);
}

static VOID class047KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEO_OVERLAY_HAL_OBJECT   pOverlayHalObj,
    U032                        buffNum
)
{
    V032 stateSU;
    U032 data32;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047KickoffBuffer"));

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START,  pOverlayHalObj->Overlay[buffNum].OverlayStart);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH,  (pOverlayHalObj->Overlay[buffNum].Pitch & 0x00007FF0));
    }
        
    // this is an NV10 emulator
    // we don't have fractional bobbing abilities
    // we can do 0, -1/4 and -1/2.
    // since we want to keep the bobbing even and can't do -1/4 we'll
    // only use 0 and -1/2.
    // Therefor the system will be to check bit 3 of the 12.4 value
    // if bit 3 is set then we set the bob to -1/2 otherwise 
    if (buffNum == 0) {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, 0);
    } else {
        if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8)
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 2 );
        else
            FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, 0);
    }

    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);

    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pOverlayHalObj->Overlay[buffNum].WindowStart += NV4_TV_DAC_SHIFT; 
    }
    REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[buffNum].WindowStart);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pOverlayHalObj->Overlay[buffNum].ScaleFactor);
    REG_WR32(NV_PVIDEO_KEY, pOverlayHalObj->Overlay[buffNum].ColorKey);
    if((pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_FLAT_PANEL) &&
        (REG_RD32(NV_PRAMDAC_FP_DEBUG_3) != 0x10001000)) // DFP scaling?
    {
        data32 = pOverlayHalObj->Overlay[buffNum].WindowSize;
        if (data32 != 0) 
            data32 -= 0x00010000;   // subtract 1 from Y
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, data32);
    }
    else
        REG_WR32(NV_PVIDEO_WINDOW_SIZE, pOverlayHalObj->Overlay[buffNum].WindowSize);

    if (pOverlayHalObj->Overlay[buffNum].DisplayWhen == NV047_SET_OVERLAY_FORMAT_DISPLAY_ALWAYS)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);

    if (pOverlayHalObj->Overlay[buffNum].OverlayFormat == NV047_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8)
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);

    // Mark buffer as NOTIFY_PENDING.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;
    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

#ifdef DEBUG_TIMING
    vmmOutDebugString("0K");
#endif

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class047StartXfer_NV04
(
    PHALHWINFO  pHalHwInfo,
    VOID        *pHalObjInfo,
    U032        buffNum
)
{
    U032 overlayStartAddr;
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

    VIDEOCLASS_PRINTF((DBG_LEVEL_INFO, "NVRM: class047StartXfer_NV04\r\n"));

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pHalObjInfo;

    // Calculate the offset from the begining of frame buffer where the overlay engine should start
    // scanning out.
#if 0
    overlayStartAddr =
        pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase + 
        pOverlayHalObj->Overlay[buffNum].Offset +
        ((pOverlayHalObj->Overlay[buffNum].Pitch * pOverlayObject->Overlay[buffNum].PointIn_t) +
         (pOverlayHalObj->Overlay[buffNum].PointIn_s << 1));
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr - (U032)pHalHwInfo->fbBaseAddr;
#else
    // remember that the point in specs are in 12.4 fixed point... so shift right by 4
    // and remember that's in pixels so 2 bytes per pixel
    
    if ((pOverlayHalObj->Overlay[buffNum].PointIn_t >>4 ) == 0xFFF ) {
        // for when the offset is ACTUALLY zero or just  -1/2
        overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
            (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3);
    } else {
      if (pOverlayHalObj->Overlay[buffNum].PointIn_t & 0x8 ) {
          // there is a negative value in the bob, so add one to
          // the offset here
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
                         ((pOverlayHalObj->Overlay[buffNum].Pitch * ((pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4) + 1)) +
                          (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      } else {
          overlayStartAddr = pOverlayHalObj->Overlay[buffNum].Offset +
              ((pOverlayHalObj->Overlay[buffNum].Pitch * (pOverlayHalObj->Overlay[buffNum].PointIn_t >> 4)) +
               (pOverlayHalObj->Overlay[buffNum].PointIn_s >> 3));
      }
    }
    
    pOverlayHalObj->Overlay[buffNum].OverlayStart = overlayStartAddr;
#endif

    // Mark the buffer as BUSY. That is all we do here. The hardware registers are
    // programmed in videoService after the current buffer completion.
    pOverlayHalObj->Overlay[buffNum].State = OVERLAY_BUFFER_BUSY;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class047Method
//
// Process all class047 methods.
//
#define OVERLAY_BUFFER_IS_IDLE(obj,buffer) (obj->Overlay[buffer].State == OVERLAY_BUFFER_IDLE)

RM_STATUS class047Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV047_STOP_OVERLAY(0):
        case NV047_STOP_OVERLAY(1):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        case NV047_SET_CONTEXT_DMA_NOTIFIES:
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 0) ||
                !OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, 1))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        case NV047_SET_CONTEXT_DMA_OVERLAY(0):
        case NV047_SET_CONTEXT_DMA_OVERLAY(1):
        {
            buffNum = (offset == NV047_SET_CONTEXT_DMA_OVERLAY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            break;
        }
        case NV047_SET_OVERLAY_COLORKEY(0):
        case NV047_SET_OVERLAY_COLORKEY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_COLORKEY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].ColorKey = data;
            break;
        }
        case NV047_SET_OVERLAY_OFFSET(0):
        case NV047_SET_OVERLAY_OFFSET(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_OFFSET(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].Offset = data;
            break;
        }
        case NV047_SET_OVERLAY_SIZE_IN(0):
        case NV047_SET_OVERLAY_SIZE_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_SIZE_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].SizeIn_width  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_WIDTH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_WIDTH));
            pOverlayHalObj->Overlay[buffNum].SizeIn_height = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_IN_HEIGHT)) & 
                       DRF_MASK(NV047_SET_OVERLAY_SIZE_IN_HEIGHT));
            break;
        }
        case NV047_SET_OVERLAY_POINT_IN(0):
        case NV047_SET_OVERLAY_POINT_IN(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_POINT_IN(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].PointIn_s  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_S)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_S));
            pOverlayHalObj->Overlay[buffNum].PointIn_t = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_IN_T)) & 
                       DRF_MASK(NV047_SET_OVERLAY_POINT_IN_T));
            break;
        }
        case NV047_SET_OVERLAY_DS_DX(0):
        case NV047_SET_OVERLAY_DS_DX(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DS_DX(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
            pOverlayHalObj->Overlay[buffNum].DsDx = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));
            break;
        }
        case NV047_SET_OVERLAY_DT_DY(0):
        case NV047_SET_OVERLAY_DT_DY(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_DT_DY(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            pOverlayHalObj->Overlay[buffNum].DtDy = data;

            // Setup ScaleFactor.
            pOverlayHalObj->Overlay[buffNum].ScaleFactor = 
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DsDx))
                | DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pOverlayHalObj->Overlay[buffNum].DtDy));

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT(0):
        case NV047_SET_OVERLAY_POINT_OUT(1):
        {
            U032 x, y;

            buffNum = (offset == NV047_SET_OVERLAY_POINT_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);

            // Setup the window start. 
            pOverlayHalObj->Overlay[buffNum].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            break;
        }
        case NV047_SET_OVERLAY_SIZE_OUT(0):
        case NV047_SET_OVERLAY_SIZE_OUT(1):
        {
            U032 width, height;

            buffNum = (offset == NV047_SET_OVERLAY_SIZE_OUT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;

            width  = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_WIDTH)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_WIDTH);
            height = (data >> DRF_SHIFT(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT)) & 
                     DRF_MASK(NV047_SET_OVERLAY_SIZE_OUT_HEIGHT);

            // Setup the window size.
            pOverlayHalObj->Overlay[buffNum].WindowSize = 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, width) | 
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, height);

            break;
        }
        case NV047_SET_OVERLAY_FORMAT(0):
        case NV047_SET_OVERLAY_FORMAT(1):
        {
            buffNum = (offset == NV047_SET_OVERLAY_FORMAT(0)) ? 0 : 1;
            if (!OVERLAY_BUFFER_IS_IDLE(pOverlayHalObj, buffNum))
                return NV047_NOTIFICATION_STATUS_ERROR_STATE_IN_USE;
                
            pOverlayHalObj->Overlay[buffNum].Pitch  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_PITCH)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_PITCH));
                
            pOverlayHalObj->Overlay[buffNum].OverlayFormat = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_COLOR)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_COLOR));
            
            pOverlayHalObj->Overlay[buffNum].DisplayWhen  = 
                (U016)((data >> DRF_SHIFT(NV047_SET_OVERLAY_FORMAT_DISPLAY)) & 
                       DRF_MASK(NV047_SET_OVERLAY_FORMAT_DISPLAY));


            // call the kickoff proc
			pOverlayHalObj->KickOffProc(pHalHwInfo, pOverlayHalObj, buffNum);

            break;
        }
        case NV047_SET_OVERLAY_POINT_OUT_A:
        {
            U032 x, y;

            x = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_X)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_X);
            y = (data >> DRF_SHIFT(NV047_SET_OVERLAY_POINT_OUT_Y)) & 
                DRF_MASK(NV047_SET_OVERLAY_POINT_OUT_Y);
            // Setup the window start in both the overlay buffers. 
            pOverlayHalObj->Overlay[0].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 
            pOverlayHalObj->Overlay[1].WindowStart = 
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, x) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, y); 

            // Actually write these values to the hardware right away.
            // There will not be a  notify method to kick this off.
            REG_WR32(NV_PVIDEO_WINDOW_START, pOverlayHalObj->Overlay[0].WindowStart);
            break;
        }
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV047_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class047 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class047GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class047 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class047ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceEventArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceEventArg->events & (1 << 0))
                    pOverlayHalObj->Overlay[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  


                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceEventArg->events & (1 << 1))
                    pOverlayHalObj->Overlay[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoServiceEvent1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING                  

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pOverlayHalObj->Overlay[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pOverlayHalObj->Overlay[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class047KickoffBuffer_NV04(pHalHwInfo, pOverlayHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceEventArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c64nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDSCALR.C                                                        *
*   This module implements the NV_VIDEO_SCALER object class and its         *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class64Method
//
// This routine performs any chip-specific handling for all class64
// methods.
//
RM_STATUS class64Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOSCALERHALOBJECT pVidScalerHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF7_SET_DELTA_DU_DX(0):
            pVidScalerHalObj->DeltaDuDx = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_DELTA_DV_DY(0):
            pVidScalerHalObj->DeltaDvDy = data;
            pHalHwInfo->pVideoHalInfo->VideoScale =
                DRF_NUM(_PVIDEO, _STEP_SIZE, _X, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDuDx)) |
                DRF_NUM(_PVIDEO, _STEP_SIZE, _Y, videoConvertScaleFactor_NV04(pVidScalerHalObj->DeltaDvDy));
            break;
        case NVFF7_SET_POINT(0):
            pVidScalerHalObj->xStart = (data & 0xffff);
            pVidScalerHalObj->yStart = (data >> 16);
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidScalerHalObj->xStart)
                | DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidScalerHalObj->yStart);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c63nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDFRMEM.C                                                        *
*   This module implements the NV_VIDEO_FROM_MEMORY object class and its    *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DEBUG_TIMING

#define DBG_PRINT_TIME(s,v) DBG_PRINT_STRING_VALUE(0x10, s, v);
U032 time0hi=0, time0lo=0, time1hi=0, time1lo=0;

#endif // DEBUG_TIMING

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000);
RM_STATUS class63InitXfer_NV04(PHALHWINFO, VOID *, U032);
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO, U032);
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000);
RM_STATUS class63Service_NV04(PVIDEOSERVICEEVENTARG_000);

//
// Statics
//
static RM_STATUS class63StartXfer_NV04(PHALHWINFO, VOID *, U032);
static VOID class63KickoffBuffer_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);
static VOID class63DualSurface_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

static VOID class63ColorKey_NV04(PHALHWINFO, PVIDEOFROMMEMHALOBJECT, U032);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class63Method
//
// This routine performs any chip-specific handling for all class63
// methods.
//
RM_STATUS class63Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 buffNum, offset, data;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF8_STOP_TRANSFER(0):
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        case NVFF8_IMAGE_SCAN_NOTIFY(0,0):
        case NVFF8_IMAGE_SCAN_NOTIFY(0,1):
            buffNum = (offset == NVFF8_IMAGE_SCAN_NOTIFY(0,0)) ? 0 : 1;
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurface_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
            return pVidFromMemHalObj->KickOffProc(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------

//
//      Program the video scalar to scan out the video to the TV encoder.
//
static VOID class63DualSurface_NV04(PHALHWINFO pHalHwInfo, PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj, U032 buffNum)
{
    U032    pitch0, pitch1, vbs, vbe, hbs, hbe, scale, hw;
    U032    length, width, pitch, height;
    int     step_x, step_y;

    //
    // Class63 has set up the scalar to render into a window, but we'll
    // change it to render to the full TV screen.
    // This means getting the source buffer size and scaling up to the
    // current resolution.
    //
        
    // calculate scaling factors

    // get the width and height of the video object
    // height = length/width
    // step x = ((src_width -1) << 11) / (dest_width -1 )
    // step y = ((src_height -1) << 11) / (dest_height - 1)
    length = pVidFromMemHalObj->Buffer[buffNum].Length;
    pitch  = pVidFromMemHalObj->Buffer[buffNum].Pitch;
    width  = pVidFromMemHalObj->Buffer[buffNum].Width;

    if (width != 0) // we'll get objects with size 0
    {
        height = length/width;
        step_x = ((width - 1) << 11) / (pHalHwInfo->pFbHalInfo->HorizDisplayWidth - 1);
        step_y = ((height - 1) << 11) / (pHalHwInfo->pFbHalInfo->VertDisplayWidth - 1);
        scale = ((step_y & 0xfff) << 16) | (step_x & 0xfff);
    }
    else
        return;

    // We have a valid video object
                    
    // find screen size
    if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
    {
        // doubled modes
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
    }
    else                                                            
    {
        hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
    }
    pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;

    // set up timing default values (640x480)
    vbs   = 0x00000240;
    vbe   = 0x0000005c;
    hbs   = 0x00000300;
    hbe   = 0x00000050;
        
    // adjust horizontal and vertical position/size
    // low-res modes don't quite use the same timings as their doubles
    switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
    {
        case 200:     // 320x200x16
            hbs   = 0x00000308;
            hbe   = 0x00000068;
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 240:     // 320x240x16
            hbs   = 0x00000308;
            hbe   = 0x00000050;
            break;             
        case 300:     // 400x300x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003d0;
            hbe   = 0x00000088;
            break;             
        case 384:     // 512x384x16
            vbs   = 0x00000230;
            vbe   = 0x00000080;
            hbs   = 0x00000290;
            hbe   = 0x00000090;
            break;             
        case 400:     // 640x400x16
            vbs   = 0x000001ec;
            vbe   = 0x0000005c;
            break;             
        case 480:     // 640x480x16
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            break;
        case 600:     // 800x600x16
            vbs   = 0x000002b0;
            vbe   = 0x00000058;
            hbs   = 0x000003a8;
            hbe   = 0x00000088;
            break;
        default:
            break;
    }            
    vbe--;
        
    // Output timing
    REG_WR32(NV_PRAMDAC_TV_VBLANK_START ,vbs);   
    REG_WR32(NV_PRAMDAC_TV_VBLANK_END   ,vbe);    
    REG_WR32(NV_PRAMDAC_TV_HBLANK_START ,hbs);     
    REG_WR32(NV_PRAMDAC_TV_HBLANK_END   ,hbe);    
        
    // Video scalar
    REG_WR32(NV_PVIDEO_STEP_SIZE  ,scale);        // scale factor 1:1
    REG_WR32(NV_PVIDEO_BUFF0_PITCH,pitch0);     // pitch buffer 0
    REG_WR32(NV_PVIDEO_BUFF1_PITCH,pitch1);     // pitch buffer 1
    REG_WR32(NV_PVIDEO_WINDOW_SIZE,hw);         // h (26:16), w (10:0)
}

//
// Program the video scalar to scan out the framebuffer (desktop) to the
// TV encoder.
// Or, turn off the video scalar for TV only or monitor.
//
VOID class63DualSurfaceDesktop_NV04(PHALHWINFO pHalHwInfo, U032 mode)
{
    U032 coeff, setup, vbs, vbe, hbs, hbe, scale, start_buf0, start_buf1, pitch0, pitch1, xy_pos, hw, fifo0, fifo1, reg32;
    int dualSurface = 0;

    switch (mode)
    {
        case DISPLAY_TYPE_MONITOR:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
            break;
        case DISPLAY_TYPE_TV:
            setup = NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER;
            break;
        case DISPLAY_TYPE_DUALSURFACE:
            dualSurface = 1;
        
            start_buf0 = 0;     // desktop starts at 0
            start_buf1 = 0;
            if (pHalHwInfo->pFbHalInfo->HorizDisplayWidth < 512)
            {
                // doubled modes
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth*2 | (pHalHwInfo->pFbHalInfo->VertDisplayWidth*2 << 16);
                scale = 0x04000400;     // 2:1
            }
            else                                                            
            {
                hw = pHalHwInfo->pFbHalInfo->HorizDisplayWidth | (pHalHwInfo->pFbHalInfo->VertDisplayWidth << 16);
                scale = 0x08000800;     // 1:1
            }            
            pitch1 = pitch0 = pHalHwInfo->pFbHalInfo->HorizDisplayWidth * 2;
            // set up timing default values (640x480)
            coeff = 0x10700;
            setup = 0x00001111;     // 565 pixel data, use second surface
            vbs   = 0x00000240;
            vbe   = 0x0000005c;
            hbs   = 0x00000300;
            hbe   = 0x00000050;
            xy_pos = 0;
            fifo0 = 0x20;           // watermark
            fifo1 = 0x03;
                
            // adjust horizontal and vertical position/size
            // low-res modes don't quite use the same timings as their doubles
            switch (pHalHwInfo->pFbHalInfo->VertDisplayWidth)
            {
                case 200:     // 320x200x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000068;
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 240:     // 320x240x16
                    hbs   = 0x00000308;
                    hbe   = 0x00000050;
                    break;             
                case 300:     // 400x300x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003d0;
                    hbe   = 0x00000088;
                    break;             
                case 384:     // 512x384x16
                    vbs   = 0x00000230;
                    vbe   = 0x00000080;
                    hbs   = 0x00000290;
                    hbe   = 0x00000090;
                    break;             
                case 400:     // 640x400x16
                    vbs   = 0x000001ec;
                    vbe   = 0x0000005c;
                    break;             
                case 480:     // 640x480x16
                    vbs   = 0x00000240;
                    vbe   = 0x0000005c;
                    hbs   = 0x00000300;
                    hbe   = 0x00000050;
                    break;
                case 600:     // 800x600x16
                    vbs   = 0x000002b0;
                    vbe   = 0x00000058;
                    hbs   = 0x000003a8;
                    hbe   = 0x00000088;
                    break;
                default:
                    dualSurface = 0;
                    break;
            }            
            break;
    }

    if (dualSurface)    // DualSurface requested and its a valid mode
    {
        // put video scalar in idle state, pointing at buffer 1            
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        REG_WR32(NV_PVIDEO_OE_STATE, 0x01000000);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
        //WritePriv32(0x00110000, NV_PVIDEO_SU_STATE);             
#if 0 // we can get stuck if we are in VGA mode; we'll never reach HalInfo.VertDisplayWidth
        // wait end of screen
        reg32 = 0;
        while (reg32 < pHalHwInfo->pFbHalInfo->VertDisplayWidth)
        {
            reg32 = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
        }
#endif
        REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, coeff);   
        REG_WR32(NV_PRAMDAC_TV_SETUP        , setup);          
        REG_WR32(NV_PRAMDAC_TV_VBLANK_START , vbs);   
        REG_WR32(NV_PRAMDAC_TV_VBLANK_END   , vbe);    
        REG_WR32(NV_PRAMDAC_TV_HBLANK_START , hbs);     
        REG_WR32(NV_PRAMDAC_TV_HBLANK_END   , hbe);    
            
        ////WritePriv32(coeff, NV_PRAMDAC_PLL_COEFF_SELECT);   
        ////WritePriv32(setup, NV_PRAMDAC_TV_SETUP);          
        ////WritePriv32(vbs, NV_PRAMDAC_TV_VBLANK_START);   
        ////WritePriv32(vbe, NV_PRAMDAC_TV_VBLANK_END);    
        ////WritePriv32(hbs, NV_PRAMDAC_TV_HBLANK_START);     
        ////WritePriv32(hbe, NV_PRAMDAC_TV_HBLANK_END);    

        // Video scalar
        REG_WR32(NV_PVIDEO_STEP_SIZE   , scale);        // scale factor 1:1
        REG_WR32(NV_PVIDEO_BUFF0_PITCH , pitch0);     // pitch buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_PITCH , pitch1);     // pitch buffer 1
        REG_WR32(NV_PVIDEO_WINDOW_SIZE , hw);         // h (26:16), w (10:0)
        REG_WR32(NV_PVIDEO_FIFO_THRES  , fifo0);       // fifo fill threshold
        REG_WR32(NV_PVIDEO_FIFO_BURST  , fifo1);       // fifo burst length
        REG_WR32(NV_PVIDEO_WINDOW_START, xy_pos);    // x,y position within buffer (start display here)
        REG_WR32(NV_PVIDEO_BUFF0_START , start_buf0); // start address buffer 0
        REG_WR32(NV_PVIDEO_BUFF1_START , start_buf1); // start address buffer 1
            
        ////WritePriv32(scale, NV_PVIDEO_STEP_SIZE);        // scale factor 1:1
        ////WritePriv32(pitch0, NV_PVIDEO_BUFF0_PITCH);     // pitch buffer 0
        ////WritePriv32(pitch1, NV_PVIDEO_BUFF1_PITCH);     // pitch buffer 1
        ////WritePriv32(hw, NV_PVIDEO_WINDOW_SIZE);         // h (26:16), w (10:0)
        ////WritePriv32(fifo0, NV_PVIDEO_FIFO_THRES);       // fifo fill threshold
        ////WritePriv32(fifo1, NV_PVIDEO_FIFO_BURST);       // fifo burst length
        ////WritePriv32(xy_pos, NV_PVIDEO_WINDOW_START);    // x,y position within buffer (start display here)
        ////WritePriv32(start_buf0, NV_PVIDEO_BUFF0_START); // start address buffer 0
        ////WritePriv32(start_buf1, NV_PVIDEO_BUFF1_START); // start address buffer 1

        // 
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);  // enable scalar
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);  // set format

        // switch to buffer 0, which will force the scalar to load new values
        reg32 = REG_RD32(NV_PVIDEO_SU_STATE);
        ////reg32 = ReadPriv32(NV_PVIDEO_SU_STATE);
        reg32 &= ~0x00010000; // NV_PVIDEO_SU_STATE_BUFF0_IN_USE = 0
        REG_WR32(NV_PVIDEO_SU_STATE, reg32); // clear BUFF0_IN_USE
        ////WritePriv32(reg32, NV_PVIDEO_SU_STATE); // clear BUFF0_IN_USE

    }    
    else    // need to set up for either TV only or Monitor only
    {
        reg32 = REG_RD32(NV_PRAMDAC_TV_SETUP);
        reg32 &= NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE;
        reg32 |= setup;
        REG_WR32(0x680700, setup);   // TV SETUP
        ////WritePriv32(setup, 0x680700);   // TV SETUP
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);  // disable scalar
    }            
}

static VOID class63ColorKey_NV04
(
    PHALHWINFO pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj,
    U032 buffNum
)
{
    U032 color, colorFormat;

    color = pVidFromMemHalObj->Buffer[buffNum].VideoColor;
    colorFormat = pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat;

    //
    // Set the hardware to the specified color.
    //
    if (color)
    {
        switch (colorFormat)
        {
            case NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8:
            case NVFF6_SET_COLOR_FORMAT_LE_X24Y8:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFF);
                break;
            
            case NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            case NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5:
                REG_WR32(NV_PVIDEO_KEY, color & 0x7FFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5:
            case NVFF6_SET_COLOR_FORMAT_LE_A16Y16:
            case NVFF6_SET_COLOR_FORMAT_LE_X16Y16:
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFF);
                break;
                
            case NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8:
            case NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:                
                REG_WR32(NV_PVIDEO_KEY, color & 0xFFFFFF);
                break; 
                
            default:
                REG_WR32(NV_PVIDEO_KEY, color);
                break; 
        }
            
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _ON);
    } 
    else
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _KEY, _OFF);
}

//---------------------------------------------------------------------------
//
//  Buffer transfer routines.
//
//---------------------------------------------------------------------------

RM_STATUS class63InitXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    RM_STATUS       status = RM_OK;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    V032            stateSU;
    V032            stateOE;
    V032            stateOESU;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63InitXfer\r\n");

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // Since we're not context switching any of the video registers across channels yet, we
    // can't just initialize the values once on boot and assume they'll look ok.  Let's 
    // hack for now and init them every new buffer.
    // 
    videoInit_NV04(pHalHwInfo, NV_VIDEO_FROM_MEMORY);

    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)) /* YUYV, YUY2, YUV2 */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _YUY2);
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8)) /* UYVY, CCIR601    */
        FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _FORMAT, _CCIR);
        
    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
    if (buffNum == (stateOE >> 24))
    {
        // The current buffer in stateOE is same as the one we want to start.
        // If both buffers are idle in this state, we have to toggle the current
        // buffer to make the overlay engine look at the buffer we are about to
        // setup.
        stateOESU = stateOE ^ stateSU;
        if ((stateOESU & 0x00100000) &&  //buffer 1 is idle
            (stateOESU & 0x00010000))    //buffer 0 is idle
        {
            stateOE ^= 0x01000000;
            REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
        }
    }
        
    status = class63StartXfer_NV04(pHalHwInfo, (VOID *)pVidFromMemHalObj, buffNum);
    if (status == RM_OK)
    {
    	// Actually kickoff the buffer that was just marked busy by writing the registers.
        // After this, buffers are actually kicked off after we get the completion interrupt.

        if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0);
        }
        else
        {
            class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1);
        }
        
        // Set the enable bit in VBLANK. This is to prevent enabling the video in the middle of
        // the video window. That may cause only the "end window" processing to be done without
        // having done the "start window" processing.
        // FLD_WR_DRF_NUM(_PVIDEO, _OVERLAY, _VIDEO, pDev->Video.Enabled);
        pHalHwInfo->pVideoHalInfo->UpdateFlags |= UPDATE_HWINFO_VIDEO_ENABLE;

        //
        // This instance has been initialized.  Call StartXfer for the next
        // buffer updates.
        //
        pVidFromMemHalObj->KickOffProc = class63StartXfer_NV04;
    }
    return (status);
}

//
// Start the transfer from the DMA buffer.
//
static RM_STATUS class63StartXfer_NV04
(
    PHALHWINFO    pHalHwInfo,
    VOID          *pHalObj,
    U032          buffNum
)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    RM_STATUS       status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class63StartXfer\r\n");

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pHalObj;

    //
    // XXX (scottl):
    // I've made a *MAJOR* assumption here that we do not use the BBufferXfer
    // proc to handle RGB video.  In looking at the transfer method in 
    // in class63.c (formally c63nv04.c), it looks like it's entirely
    // vblank driven.  By making this assumption, I'm able to avoid having
    // vblank info in the HAL.
    //
#ifdef DEBUG
    if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5) ||
        ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class63StartXfer: format is RGB!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // VideoStart, VideoSize and VideoScale are not double buffered.
    // So copy the values into the Buff0 versions to simulate true
    // double buffering.
    //
    pVidFromMemHalObj->Buffer[buffNum].VideoStart = pHalHwInfo->pVideoHalInfo->VideoStart;
    pVidFromMemHalObj->Buffer[buffNum].VideoSize = pHalHwInfo->pVideoHalInfo->VideoSize;
    pVidFromMemHalObj->Buffer[buffNum].VideoScale = pHalHwInfo->pVideoHalInfo->VideoScale;
    pVidFromMemHalObj->Buffer[buffNum].VideoColorFormat = pHalHwInfo->pVideoHalInfo->VideoColorFormat;
    pVidFromMemHalObj->Buffer[buffNum].VideoColor = pHalHwInfo->pVideoHalInfo->VideoColor;

    //
    // Mark the buffer as BUSY. That is all we do here. The hardware
    // registers are programmed in videoService after the current buffer
    // completion.
    //
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_BUSY;
#ifdef DEBUG_TIMING
    vmmOutDebugString("\n0B");
#endif

    return (status);
}

static VOID class63KickoffBuffer_NV04
(
    PHALHWINFO                  pHalHwInfo,
    PVIDEOFROMMEMHALOBJECT      pVidFromMemHalObj,
    U032                        buffNum
)
{
    V032 stateSU;

    stateSU = REG_RD32(NV_PVIDEO_SU_STATE);

    if (buffNum == 0) {
        REG_WR32(NV_PVIDEO_BUFF0_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF0_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF0_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    } else {
        REG_WR32(NV_PVIDEO_BUFF1_START, pVidFromMemHalObj->Buffer[buffNum].Start);
        REG_WR32(NV_PVIDEO_BUFF1_PITCH, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 0x00007FF0));
        FLD_WR_DRF_NUM(_PVIDEO, _BUFF1_OFFSET, _Y, (pVidFromMemHalObj->Buffer[buffNum].Pitch & 3));
    }
            
    FLD_WR_DRF_DEF(_PVIDEO, _CONTROL_Y, _LINE, _HALF);
        
    if (IsNV4_NV04(pHalHwInfo->pMcHalInfo) && 
        (pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_NTSC ||
         pHalHwInfo->pDacHalInfo->CrtcInfo[0].MonitorType == MONITOR_TYPE_PAL))
    {
        // NV4 HW bug, shift position on TV
        pVidFromMemHalObj->Buffer[buffNum].VideoStart += NV4_TV_DAC_SHIFT;
    }

    REG_WR32(NV_PVIDEO_WINDOW_START, pVidFromMemHalObj->Buffer[buffNum].VideoStart);
    REG_WR32(NV_PVIDEO_WINDOW_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoSize);
    REG_WR32(NV_PVIDEO_STEP_SIZE, pVidFromMemHalObj->Buffer[buffNum].VideoScale);
 
    class63ColorKey_NV04(pHalHwInfo, pVidFromMemHalObj, buffNum);
        
    // Mark buffer 1 as NOTIFY_PENDING.
    pVidFromMemHalObj->Buffer[buffNum].State = OVERLAY_BUFFER_NOTIFY_PENDING;

    if (buffNum == 0)
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
    else
        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);

    REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
}

//---------------------------------------------------------------------------
//
//  Exception handling routines.
//
//---------------------------------------------------------------------------

//
// class63 exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
RM_STATUS class63GetEventStatus_NV04(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PHALHWINFO pHalHwInfo;
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoGetEventStatusArg->pHalObjInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoService handler.
    //    
    pVideoGetEventStatusArg->events = 0;

    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoGetEventStatusArg->intrStatus = intr0;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {

        // Reset the pending bit right away. This way, if another buffer completion becomes pending
        // while we are servicing the current buffer completion, it will not be lost. 
        // This is the best we can do to close this window.
        // We will return intr_notify_pending state so if another interrupt happened, 
        // we will be called again.
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif

        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 0 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 0);
            }
        }
        
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif
                // Mark buffer 1 pending if notify has been setup.
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_NOTIFY_PENDING)
                    pVideoGetEventStatusArg->events |= (1 << 1);
            }
        }
    }

    return RM_OK;
}

//
// class63 exception handler
//
// This interface relies on values setup by the nvHalVideoGetEventStatus
// interface (i.e. the PVIDEO_INTR_0 register contents).  We go to the
// hardware to get the rest of it.
//
RM_STATUS class63ServiceEvent_NV04(PVIDEOSERVICEEVENTARG_000 pVideoServiceArg)
{
    PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;
    PHALHWINFO pHalHwInfo;
    U032 intr0;
    V032 stateOE;
    V032 stateSU;
    V032 stateRM;
    V032 stateOESU;
    V032 stateOERM;

    pHalHwInfo = pVideoServiceArg->pHalHwInfo;

    pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoServiceArg->pHalObjInfo;

    //
    // The pending interrupt register value was saved off by the
    // GetEventStatus entry point.
    //
    intr0 = pVideoServiceArg->intrStatus;

    //
    // Pending notify (buffer completion) ?
    //
    if (intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING))
    {
        //
        // Grab the current states
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);
        stateOESU = stateOE ^ stateSU;
        stateOERM = stateOE ^ stateRM;

#ifdef DEBUG_TIMING
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif

        //
        // Buffer 0.
        //
        if ((stateOESU & 0x00010000))
        {
            if (stateOERM & 0x00000001)
            {
                if (pVideoServiceArg->events & (1 << 0))
                    pVidFromMemHalObj->Buffer[0].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService0: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 1 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                }
                else
                {
                    // Software buffer 1 is not ready.
                    // Program OE and SU so that the hardware flips to 0 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (0 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 0 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                    } // buffer 0 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 0 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF0_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("0R");
#endif
                    } // redisplay buffer 0 values
                } // Buffer 1 is not busy    
                        
                // Return the current interrupt pending state.
                // intr0 = REG_RD32(NV_PVIDEO_INTR_0);
                // return(intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING));
            } // Hardware says buffer 0 completed.
        }

        //
        // Buffer 1.
        //
        if ((stateOESU & 0x00100000))
        {
            if (stateOERM & 0x00000010)
            {
                if (pVideoServiceArg->events & (1 << 1))
                    pVidFromMemHalObj->Buffer[1].State = OVERLAY_BUFFER_IDLE;

#ifdef DEBUG_TIMING            
                DBG_PRINT_TIME("                                                   VideoService1: ",REG_RD32(NV_PTIMER_TIME_0) - time0lo);
                
                time0hi = REG_RD32(NV_PTIMER_TIME_1);
                time0lo = REG_RD32(NV_PTIMER_TIME_0);
#endif // DEBUG_TIMING

                stateRM ^= 1 << SF_SHIFT(NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY);
                REG_WR32(NV_PVIDEO_RM_STATE, stateRM);
                
                if (pVidFromMemHalObj->Buffer[0].State == OVERLAY_BUFFER_BUSY)
                {
                	// Software buffer 0 is ready. Kick it off.
                    class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 0 /* buffNum */);
                }
                else
                {
                    // Software buffer 0 is not ready.
                    // Program OE and SU so that the hardware flips to 1 again.
                    stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
                    if (1 == (stateOE >> 24))
                    {
                        stateOE ^= 0x01000000;
                        REG_WR32(NV_PVIDEO_OE_STATE, stateOE);
                    }

                    // If buffer 1 itself is busy again. Load the new values.
                    if (pVidFromMemHalObj->Buffer[1].State == OVERLAY_BUFFER_BUSY)
                    {
                        class63KickoffBuffer_NV04(pHalHwInfo, pVidFromMemHalObj, 1 /* buffNum */);
                    } // Buffer 1 has new values
                    else
                    { 
                        // We just need to redisplay the same buffer 1 values again.
                        // We don't have to load any hardware registers. 
                        // Flip SU_STATE_BUFF0_IN_USE
                        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
                        stateSU ^= 1 << SF_SHIFT(NV_PVIDEO_SU_STATE_BUFF1_IN_USE);
                        REG_WR32(NV_PVIDEO_SU_STATE, stateSU);
#ifdef DEBUG_TIMING
                        vmmOutDebugString("1R");
#endif
                    } // Redisplay buffer 1 values
                } // Buffer 0 is not busy    
            } // Hardware says buffer 1 completed.
        }

#ifdef DEBUG_TIMING
        // Grab the current states again and print it.
        //
        stateOE = REG_RD32(NV_PVIDEO_OE_STATE);
        stateSU = REG_RD32(NV_PVIDEO_SU_STATE);
        stateRM = REG_RD32(NV_PVIDEO_RM_STATE);

        VIDEOCLASS_PRINTF( (0x10, "                                                   stateOE = 0x%x\n",stateOE));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateSU = 0x%x\n",stateSU));
        VIDEOCLASS_PRINTF( (0x10, "                                                   stateRM = 0x%x\n",stateRM));
#endif
    }  // Notify was pending
    
    // Return the current interrupt pending state.
    intr0 = REG_RD32(NV_PVIDEO_INTR_0);
    pVideoServiceArg->intrStatus = intr0 & DRF_DEF(_PVIDEO, _INTR_0, _NOTIFY, _PENDING);

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c04env04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************************************************************\
*                                                                           *
* Module: CLASS04E.C                                                        *
*   This module implements the NV_EXTERNAL_VIDEO_DECOMPRESSOR object class  *
*   and its corresponding methods.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

#ifdef DO_INTERRUPT_TIMING
U032 timePrev = 0;
#endif

//
// The following routines are used by the HAL mediaport engine
// manager in kernel/mp/nv4/mpnv04.c.
//
RM_STATUS class04EMethod_NV04(PMPMETHODARG_000);
RM_STATUS class04EGetEventStatus_NV04(PMPGETEVENTSTATUSARG_000);
RM_STATUS class04EServiceEvent_NV04(PMPSERVICEEVENTARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by mp/mpobj.c and
// mp/nv4/mpnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------
    
static RM_STATUS class04EStartVidRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif
        
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartVidRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartVidRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _ENABLED);
    
    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
#if 0
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_SYSMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));

        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_SYS, pDecompHalObj->ReadData[0].Offset
                                               + (U032)pDecompHalObj->ReadData[0].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_SYS, pDecompHalObj->ReadData[1].Offset
                                               + (U032)pDecompHalObj->ReadData[1].CtxDma->BufferBase
                                               + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 

    }
    else if (pDecompHalObj->ContextDmaData[Buffer]->AddressSpace == ADDR_AGPMEM)
    {
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _SYS)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _AGP));
    }
    else
    {
#endif
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            // verify 4k!!
            REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
#if 0                                
    }
#endif    
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // we also need to enable Audio in order for Video to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_AUD_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 7);
    
    return(RM_OK);
}

static RM_STATUS class04EStartAudRead
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    V032 stateSU, stateME;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: class04EStartAudRead\r\n");

#ifdef DEBUG
    //
    // Make sure there isn't an interrupt pending
    //
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EStartAudRead detected unexpected interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //

    //
    // Spend some time to validate all data
    //

    //
    // Make sure the engine is configured correctly (in case the old class66 overwrites)
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x26); /* disable MPC polling */
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _BUS_MODE, _VMI);
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _ENABLED);
    FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _ENABLED);
    
    {
        // FB_MEM
        REG_WR32(NV_PME_CONFIG_1, DRF_DEF(_PME, _CONFIG_1, _BUFFS, _PNVM)
                                | DRF_DEF(_PME, _CONFIG_1, _HOST, _PCI));
                            
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                                                + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
        } 
        else
        {
            REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                                                + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                                                //- pDev->Mapping.PhysFbAddr
                                                + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);

            REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
        } 
                                
    }
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    //if (Buffer != (stateME >> 24))
    //    REG_WR32(NV_PME_VID_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_AUD_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_AUD_SU_STATE, stateSU);
    }

    //
    // we also need to enable Video in order for Audio to work (NV4 only)
    //
    if ( IsNV4_NV04(pHalHwInfo->pMcHalInfo) ) {
        REG_WR32(NV_PME_VID_ME_STATE, 0);
        stateSU = (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF0_IN_USE)) |
                  (1 << SF_SHIFT(NV_PME_VID_SU_STATE_BUFF1_IN_USE));
        REG_WR32(NV_PME_VID_SU_STATE, stateSU);
    }

    //
    // enable MPC polling
    //
    REG_WR32(NV_PME_EXTERNAL(2), 0x27);
    
    return(RM_OK);
}

static RM_STATUS class04EStartWrite
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 Buffer
)
{
    U032 stateSU, stateME;
    U032 size;

    //
    // For now, we're going to assume the given buffer maps directly
    // to the hardware buffer.  We can add virtualization later.
    //
    //
    // Spend some time to validate all data
    //

    //
    // The hardware can only support dma transfers from contiguous
    // addresses.  If this transfer is not completely contiguous,
    // we need to break the transfer up.
    //
    // For now, assume we are contiguous and in fb memory
    //
    if (pDecompHalObj->ReadData[Buffer].CtxDma->AddressSpace == ADDR_FBMEM)
    {
        if (Buffer == 0)
        {
            REG_WR32(NV_PME_IMAGE_BUFF0_START, (U032)(pDecompHalObj->WriteImage[0].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[0].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[0].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF0_PITCH, pDecompHalObj->WriteImage[0].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[0].Size & 0xFFFF) * (pDecompHalObj->WriteImage[0].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF0_LENGTH, size);
        } 
        else
        {
            REG_WR32(NV_PME_IMAGE_BUFF1_START, (U032)(pDecompHalObj->WriteImage[1].Offset
                                               // TO DO: this is a known truncation for IA64
                                             + (SIZE_PTR)pDecompHalObj->WriteImage[1].CtxDma->BufferBase
                                             + pDecompHalObj->WriteImage[1].CtxDma->PteAdjust));

            REG_WR32(NV_PME_IMAGE_BUFF1_PITCH, pDecompHalObj->WriteImage[1].FormatOut & 0xFFFF);

            size = (pDecompHalObj->WriteImage[1].Size & 0xFFFF) * (pDecompHalObj->WriteImage[1].Size >> 16);
            REG_WR32(NV_PME_IMAGE_BUFF1_LENGTH, size);
        } 

    }
    else 
        ;// NOT SUPPORTED!!!
    
    //
    // Start the transfer
    //
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    if (Buffer != (stateME >> 24))
        REG_WR32(NV_PME_IMAGE_ME_STATE, stateME ^ 0x01000000);

    if (Buffer == 0)
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    } 
    else // Buffer == 1
    {
        stateSU ^= 1 << SF_SHIFT(NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE);
        REG_WR32(NV_PME_IMAGE_SU_STATE, stateSU);
    }

    return(RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

RM_STATUS class04EMethod_NV04(PMPMETHODARG_000 pMpMethodArg)
{
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;
    U032 buffNum;

    pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpMethodArg->pHalObjInfo;
    offset = pMpMethodArg->offset;
    data = pMpMethodArg->data;
    pHalHwInfo = pMpMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NV04E_STOP_TRANSFER:
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _AUD_NOTIFY, _DISABLED);

            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
            REG_WR32(NV_PME_AUD_SU_STATE, 0);
            REG_WR32(NV_PME_AUD_ME_STATE, 0);
            REG_WR32(NV_PME_AUD_RM_STATE, 0);
            REG_WR32(NV_PME_AUD_CURRENT, 0);

            // XXX make sure the MPC's FIFO's are empty
            REG_WR32(NV_PME_EXTERNAL(2), 6);    /* disable MPC polling */
            break;
        case NV04E_SET_DATA_OFFSET(0):
        case NV04E_SET_DATA_OFFSET(1):
            buffNum = (offset == NV04E_SET_DATA_OFFSET(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Offset = data;
            //
            // Go ahead and write the start address .
            // (write both and aud and vid registers since we
            // don't know which one we'll use yet)
            // 
            if (buffNum == 0) {
                REG_WR32(NV_PME_VID_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF0_START_PNVM, pDecompHalObj->ReadData[0].Offset
                         + (pDecompHalObj->ReadData[0].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[0].CtxDma->PteAdjust);
            } 
            else {
                REG_WR32(NV_PME_VID_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
                REG_WR32(NV_PME_AUD_BUFF1_START_PNVM, pDecompHalObj->ReadData[1].Offset
                         + (pDecompHalObj->ReadData[1].CtxDma->PteArray[0] & 0xFFFFF000)
                         + pDecompHalObj->ReadData[1].CtxDma->PteAdjust);
            } 
            break;
        case NV04E_SET_DATA_LENGTH(0):
        case NV04E_SET_DATA_LENGTH(1):
            buffNum = (offset == NV04E_SET_DATA_LENGTH(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Size = data;
            //
            // go ahead and write the length
            // (use audio engine if size < 4K)
            // 
            if (buffNum == 0) {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF0_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF0_LENGTH, pDecompHalObj->ReadData[0].Size);
                }
            } 
            else {
                if ( data < 4096 ) {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, 0);
                }
                else {
                    REG_WR32(NV_PME_AUD_BUFF1_LENGTH, 0);
                    REG_WR32(NV_PME_VID_BUFF1_LENGTH, pDecompHalObj->ReadData[1].Size);
                }
            }
            break;
        case NV04E_SET_DATA_NOTIFY(0):
        case NV04E_SET_DATA_NOTIFY(1):
            buffNum = (offset == NV04E_SET_DATA_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->ReadData[buffNum].Notify = data;

            //
            // KICK IT OFF!!
            //
            if (pDecompHalObj->ReadData[buffNum].Size < 4096) {
                class04EStartAudRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            else {
                class04EStartVidRead(pHalHwInfo, pDecompHalObj, buffNum);
            }
            break;
        case NV04E_SET_IMAGE_FORMAT_IN(0):
        case NV04E_SET_IMAGE_FORMAT_IN(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_IN(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatIn = data;
            break;
        case NV04E_SET_IMAGE_SIZE(0):
        case NV04E_SET_IMAGE_SIZE(1):
            buffNum = (offset == NV04E_SET_IMAGE_SIZE(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Size = data;
            break;
        case NV04E_SET_IMAGE_OFFSET_OUT(0):
        case NV04E_SET_IMAGE_OFFSET_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_OFFSET_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Offset = data;
            break;
        case NV04E_SET_IMAGE_FORMAT_OUT(0):
        case NV04E_SET_IMAGE_FORMAT_OUT(1):
            buffNum = (offset == NV04E_SET_IMAGE_FORMAT_OUT(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].FormatOut = data;
            break;
        case NV04E_SET_IMAGE_NOTIFY(0):
        case NV04E_SET_IMAGE_NOTIFY(1):
            buffNum = (offset == NV04E_SET_IMAGE_NOTIFY(0)) ? 0 : 1;
            pDecompHalObj->WriteImage[buffNum].Notify = data;
            //
            // Kick it off
            //
            class04EStartWrite(pHalHwInfo, pDecompHalObj, buffNum);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }
    return NV04E_NOTIFICATION_STATUS_DONE_SUCCESS;
}

//---------------------------------------------------------------------------
//
//  Exception handling routines
//
//---------------------------------------------------------------------------

static VOID GetVideoEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_VID_ME_STATE);
    stateSU = REG_RD32(NV_PME_VID_SU_STATE);
    stateRM = REG_RD32(NV_PME_VID_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_VIDEO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_VIDEO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetVideoEvents\n");

    return;
}

static VOID GetAudioEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;
#ifdef DEBUG
    V032 stateINTR0;
#endif

    // pause any transfers that might be going
    FLD_WR_DRF_DEF(_PME, _CONFIG_0, _AUD_CD, _DISABLED);

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_AUD_ME_STATE);
    stateSU = REG_RD32(NV_PME_AUD_SU_STATE);
    stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _RESET));

#ifdef DEBUG
    stateINTR0 = REG_RD32(NV_PME_INTR_0);
    if ( stateINTR0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING) ) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: class04EVideoNotify couldn't reset interrupt!\r\n");
        DBG_BREAKPOINT();
    }
#endif

    // buffer 0
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_AUDIO_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_AUDIO_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetAudioEvents\n");

    return;
}

#ifdef NOTYET
static VOID GetImageEvents
(
    PHALHWINFO pHalHwInfo,
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj,
    U032 *pEventsPending
)
{
    U032 stateRM, stateSU, stateME, stateMESU, stateMERM;
    U032 eventsPending = 0;

    //
    // Check for spurious interrupt.
    //
    if (pDecompHalObj == NULL)
    {
        REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));
        *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
        return ;
    }

    //
    // Grab the current states
    //
    stateME = REG_RD32(NV_PME_IMAGE_ME_STATE);
    stateSU = REG_RD32(NV_PME_IMAGE_SU_STATE);
    stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
    stateMESU = stateME ^ stateSU;
    stateMERM = stateME ^ stateRM;

    REG_WR32(NV_PME_INTR_0, DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _RESET));

    // buffer 0
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(0))
    {
        if (!(stateMESU & 0x00010000))
        {
            if (stateMERM & 0x00000001)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(0);
            }
        }
    }

    // buffer 1
    if (*pEventsPending & CLASS04E_IMAGE_EVENT(1))
    {
        if (!(stateMESU & 0x00100000))
        {
            if (stateMERM & 0x00000010)
            {
                eventsPending |= CLASS04E_IMAGE_EVENT(1);
            }
        }
    }

    *pEventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    *pEventsPending |= eventsPending;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Leaving GetImageEvents\n");

    return;
}
#endif

//
// class04EGetEventStatus
//
// This call returns the status of the specified MP event(s).
//
RM_STATUS class04EGetEventStatus_NV04
(
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg
)
{
    PHALHWINFO pHalHwInfo;
    PVIDEODECOMPRESSORHALOBJECT pDecompHalObj;
    U032 intr0;
    U032 eventsPending;

    pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;

    //
    // Get current interrupt status and save off in exception frame.
    //
    intr0 = REG_RD32(NV_PME_INTR_0);
    pMpGetEventStatusArg->intrStatus = intr0;

    //
    // Check for pending events.
    //
    if (!(intr0 & (DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING) |
                   DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))))
    {
        pMpGetEventStatusArg->events = 0;
        return RM_OK;
    }

    //
    // Setup HAL object pointer.
    //
    if (pMpGetEventStatusArg->pHalObjInfo == NULL)
        pDecompHalObj = NULL;
    else
        pDecompHalObj = (PVIDEODECOMPRESSORHALOBJECT)pMpGetEventStatusArg->pHalObjInfo;

    //
    // The caller specifies a bit field of events for which it wishes
    // to get status.  If an event of interest isn't pending, then it's
    // bit is cleared.
    //
    eventsPending = pMpGetEventStatusArg->events;
    if (eventsPending & (CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _VID_NOTIFY, _PENDING))
            GetVideoEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_VIDEO_EVENT(0)|CLASS04E_VIDEO_EVENT(1));
    }
    if (eventsPending & (CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _AUD_NOTIFY, _PENDING))
            GetAudioEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_AUDIO_EVENT(0)|CLASS04E_AUDIO_EVENT(1));
    }

#ifdef NOTYET
    if (eventsPending & (CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1)))
    {
        if (intr0 & DRF_DEF(_PME, _INTR_0, _IMAGE_NOTIFY, _PENDING))
            GetImageEvents(pHalHwInfo, pDecompHalObj, &eventsPending);
        else
            eventsPending &= ~(CLASS04E_IMAGE_EVENT(0)|CLASS04E_IMAGE_EVENT(1));
    }
#endif

    //
    // Return set of events that are actually pending.
    //
    pMpGetEventStatusArg->events = eventsPending;

    return RM_OK;
}

//
// class04EServiceEvent
//
// Finish servicing specified event (i.e. reset buffer status).
//
RM_STATUS class04EServiceEvent_NV04
(
    PMPSERVICEEVENTARG_000 pMpServiceEventArg
)
{
    PHALHWINFO pHalHwInfo;
    U032 event, stateRM;
    RM_STATUS status = RM_OK;

    pHalHwInfo = pMpServiceEventArg->pHalHwInfo;

    //
    // The values were setup by the GetEventStatus interface.
    //
    event = pMpServiceEventArg->event;

    //
    // The eventsPending value should only specify a single
    // VBI *or* image buffer.
    //
    switch (event)
    {
        case CLASS04E_VIDEO_EVENT(0):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_VIDEO_EVENT(1):
            stateRM = REG_RD32(NV_PME_VID_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_VID_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(0):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
        case CLASS04E_AUDIO_EVENT(1):
            stateRM = REG_RD32(NV_PME_AUD_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_AUD_RM_STATE, stateRM);
            break;
#ifdef NOTYET
        case CLASS04E_IMAGE_EVENT(0):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
        case CLASS04E_IMAGE_EVENT(1):
            stateRM = REG_RD32(NV_PME_IMAGE_RM_STATE);
            stateRM ^= 1 << SF_SHIFT(NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY);
            REG_WR32(NV_PME_IMAGE_RM_STATE, stateRM);
            break;
#endif
        default:
            status = RM_ERR_BAD_ARGUMENT;
            break;
    }

    //
    // Return updated pending interrupt values.
    //
    pMpServiceEventArg->intrStatus = REG_RD32(NV_PME_INTR_0);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\modular\nv4\c65nv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: VIDCLRKY.C                                                        *
*   This module implements the NV_VIDEO_COLOR_KEY object class and its      *
*   corresponding methods.                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// The following routines are used by the HAL video engine
// manager in kernel/video/vidnv04.c.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000);

//---------------------------------------------------------------------------
//
//  Create/Destroy object routines.
//
//---------------------------------------------------------------------------

//
// Class instantiation/destruction is handled by video/videoobj.c and
// video/nv4/vidnv04.c.
//

//---------------------------------------------------------------------------
//
//  Miscellaneous class support routines.
//
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
//
//  Class method routines.
//
//---------------------------------------------------------------------------

//
// class65Method
//
// This routine performs any chip-specific handling for all class65
// methods.
//
RM_STATUS class65Method_NV04(PVIDEOMETHODARG_000 pVideoMethodArg)
{
    PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;
    PHALHWINFO pHalHwInfo;
    U032 offset, data;

    pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoMethodArg->pHalObjInfo;
    offset = pVideoMethodArg->offset;
    data = pVideoMethodArg->data;
    pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    switch (offset)
    {
        case NVFF6_SET_COLOR_FORMAT(0):
            pVidColorKeyHalObj->ColorFormat = data;
            pHalHwInfo->pVideoHalInfo->VideoColorFormat = data;
            break;
        case NVFF6_SET_COLOR_KEY(0):
            pVidColorKeyHalObj->Color = data;
            pHalHwInfo->pVideoHalInfo->VideoColor = data;
            break;
        case NVFF6_SET_POINT(0):
            pVidColorKeyHalObj->xClipMin = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMin = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoStart =
                DRF_NUM(_PVIDEO, _WINDOW_START, _X, pVidColorKeyHalObj->xClipMin) |
                DRF_NUM(_PVIDEO, _WINDOW_START, _Y, pVidColorKeyHalObj->yClipMin);
            break;
        case NVFF6_SET_SIZE(0):
            pVidColorKeyHalObj->xClipMax = data & 0x0000FFFF;
            pVidColorKeyHalObj->yClipMax = data >> 16;
            pHalHwInfo->pVideoHalInfo->VideoSize =
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _X, pVidColorKeyHalObj->xClipMax) |
                DRF_NUM(_PVIDEO, _WINDOW_SIZE, _Y, pVidColorKeyHalObj->yClipMax);
            break;
        default:
            // HAL doesn't have anything to do for this particular method
            ;
    }

    return NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv\mp.c ===
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include "nvhw.h"

//
// Forwards.
//
V032 mpService(PHWINFO);

//
// mpService
//
// Field MediaPort exceptions by invoking class-dependent handlers.
//
V032 mpService
(
    PHWINFO pDev
)
{
    V032 intrStatus = 0;

    //
    // Decompressor.
    //
    (void) class04EService(pDev);

    //
    // Decoder.
    //
    (void) class04DService(pDev);

    //
    // Parallel bus.
    // This is the interrupt status value we'll return.
    //
    intrStatus = class04FService(pDev);

    return intrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv\mpstate.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/******************************** MP Manager ********************************\
*                                                                           *
* Module: MPSTATE.C                                                         *
*   The MediaPort state is changed in this module.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <modular.h>
#include <mp.h>
#include <os.h>
#include "nvhw.h"

//
// Registry data.
//
extern char strDevNodeRM[];
char strDisableMPC[] = "DisableMPCDetect";

//
// Change MediaPort hardware state.
//
RM_STATUS stateMp
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalMpControl(pDev, MP_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalMpControl(pDev, MP_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalMpControl(pDev, MP_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            U032 data32;

            //
            // Check if MPC Detection has been disabled.
            // It would be nice if this were made into a chip-independent
            // registry setting.
            //
            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strDisableMPC, &data32) == RM_OK)
            {
                pDev->MediaPort.HalInfo.DetectEnable = 1;
            }
            else
            {
                pDev->MediaPort.HalInfo.DetectEnable = 0;
            }

            //
            // Set initial state to unused.
            //
            pDev->MediaPort.CurrentDecoder = NULL;
            pDev->MediaPort.CurrentDecompressor = NULL;
            pDev->MediaPort.CurrentParallelBusObj = NULL;
            nvHalMpControl(pDev, MP_CONTROL_INIT);
            break;
        }
        case STATE_DESTROY:
            nvHalMpControl(pDev, MP_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv\mpobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*************************** MP Engine Manager *****************************\
*                                                                           *
* Module: mpobj.c                                                           *
*   Media port engine objects are managed here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <mp.h>
#include <i2c.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV03_EXTERNAL_VIDEO_DECODER (class04d)
static RM_STATUS mpCreateDecoderObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecoderObj(PHWINFO, POBJECT);

// NV03_EXTERNAL_VIDEO_DECOMPRESSOR (class04e)
static RM_STATUS mpCreateDecompressorObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyDecompressorObj(PHWINFO, POBJECT);

// NV01_EXTERNAL_PARALLEL_BUS
static RM_STATUS mpCreateParallelBusObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS mpDestroyParallelBusObj(PHWINFO, POBJECT);

//
// Class lock macros (MediaPort class allocations are per-device).
//
#define MPCLASSLOCK_ISSET(pdev,bit)    (pDev->MediaPort.ClassLocks & (1 << bit))
#define MPCLASSLOCK_SET(pdev,bit)      (pDev->MediaPort.ClassLocks |= (1 << bit))
#define MPCLASSLOCK_CLEAR(pdev,bit)    (pDev->MediaPort.ClassLocks &= ~(1 << bit))

//
// mpCreateObj
//
// Top-level create routine for mediaport classes.
//
RM_STATUS mpCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateObj\r\n");

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (MPCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        MPCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpCreateDecoderObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpCreateDecompressorObj(pDev, ClassObject, Name, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpCreateParallelBusObj(pDev, ClassObject, Name, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Create(pDev, ClassObject, Name, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Create(pDev, ClassObject, Name, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            MPCLASSLOCK_CLEAR(pDev, lockBit);
        return (status);
    }

    return (RM_OK);
}

RM_STATUS mpDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(MPCLASSLOCK_ISSET(pDev, lockBit));
        MPCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = mpDestroyDecoderObj(pDev, Object);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = mpDestroyDecompressorObj(pDev, Object);
            break;
        case NV01_EXTERNAL_PARALLEL_BUS:
            status = mpDestroyParallelBusObj(pDev, Object);
            break;
        case NV03_EXTERNAL_MONITOR_BUS:
            status = class050Destroy(pDev, Object);
            break;
        case NV04_EXTERNAL_SERIAL_BUS:
            status = class051Destroy(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video decoder create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecoderObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECODEROBJECT         pDecoderObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecoderObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECODEROBJECT));
    if (status)
        return (status);
        
    pDecoderObject = (PVIDEODECODEROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecoderObject;
    for (i = 0; i < sizeof (VIDEODECODEROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, &pDecoderObject->HalObject);
    if (status)
        return (status);

    //
    // Initialize the event processing order.
    // We always start with VBI and buffer number 0. 
    // So assume the last event processed was an image and the
    // last buffer processed was 1.
    //
    pDecoderObject->LastEventProcessed = EVENT_PROCESSED_IMAGE;
    pDecoderObject->LastImageBufferProcessed = 1;
    pDecoderObject->LastVbiBufferProcessed = 1;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecoderObject->CBase, 
                                      pDecoderObject->CBase.ChID, 
                                      pDecoderObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, pClass->Type, (VOID *)&pDecoderObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecoder = (VOID_PTR)pDecoderObject;

    return (status);
}

static RM_STATUS mpDestroyDecoderObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECODEROBJECT         pDecoderObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecoderObj\r\n");

    pDecoderObject = (PVIDEODECODEROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecoderObject->CBase.ChID, pDecoderObject->CInstance, Object->ThisClass->Type, &pDecoderObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecoderObject->CBase, pDecoderObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecoder = NULL;

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video decompressor create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateDecompressorObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateDecompressorObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEODECOMPRESSOROBJECT));
    if (status)
        return (status);
        
    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pDecompressorObject;
    for (i = 0; i < sizeof (VIDEODECOMPRESSOROBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, &pDecompressorObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pDecompressorObject->CBase, 
                                      pDecompressorObject->CBase.ChID, 
                                      pDecompressorObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, pClass->Type, (VOID *)&pDecompressorObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentDecompressor = (VOID_PTR)pDecompressorObject;

    return (status);
}

static RM_STATUS mpDestroyDecompressorObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PVIDEODECOMPRESSOROBJECT    pDecompressorObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyDecompressorObj\r\n");

    pDecompressorObject = (PVIDEODECOMPRESSOROBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pDecompressorObject->CBase.ChID, pDecompressorObject->CInstance, Object->ThisClass->Type, &pDecompressorObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pDecompressorObject->CBase, pDecompressorObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentDecompressor = NULL;

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Parallel bus create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS mpCreateParallelBusObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS                   status = RM_OK;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PPARALLELBUSOBJECT          pParallelBusObject;
    U008                        *bytePtr;
    int                         i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpCreateParallelBusObj\r\n");

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (PARALLELBUSOBJECT));
    if (status)
        return (status);
        
    pParallelBusObject = (PPARALLELBUSOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pParallelBusObject;
    for (i = 0; i < sizeof (PARALLELBUSOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalMpAlloc(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, &pParallelBusObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pParallelBusObject->CBase, 
                                      pParallelBusObject->CBase.ChID, 
                                      pParallelBusObject->CInstance);
    if (status != RM_OK)
    {
        nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, pClass->Type, (VOID *)&pParallelBusObject->HalObject);
        osFreeMem(*Object);
    }

    //
    // Plug this object into the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = (VOID_PTR)pParallelBusObject;

    return (status);
}

static RM_STATUS mpDestroyParallelBusObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS                   status;
    PPARALLELBUSOBJECT          pParallelBusObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: mpDestroyParallelBusObj\r\n");

    pParallelBusObject = (PPARALLELBUSOBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalMpFree(pDev, pParallelBusObject->CBase.ChID, pParallelBusObject->CInstance, Object->ThisClass->Type, &pParallelBusObject->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pParallelBusObject->CBase, pParallelBusObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Remove this object from the device structure
    //
    pDev->MediaPort.CurrentParallelBusObj = NULL;


    return (osFreeMem(Object));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv10\nv10kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv\nvkernel.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv\makefile.inc ===
!IFDEF NVIA64
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\ia64
!ELSE
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386
!ENDIF

!IF "$(BUILD_DDK_VER)"!="nt5"
RMLIBDIR=$(RMLIBDIR)\$(DDKBUILDENV)
!ENDIF

$(RMLIBDIR)\nvkernel.lib:           \
        $(RMLIBDIR)\btree.lib       \
        $(RMLIBDIR)\class.lib       \
        $(RMLIBDIR)\dac.lib         \
        $(RMLIBDIR)\devinit.lib     \
        $(RMLIBDIR)\dma.lib         \
        $(RMLIBDIR)\fb.lib          \
        $(RMLIBDIR)\fifo.lib        \
        $(RMLIBDIR)\gr.lib          \
        $(RMLIBDIR)\hal.lib         \
        $(RMLIBDIR)\heap.lib        \
        $(RMLIBDIR)\mc.lib          \
        $(RMLIBDIR)\modular.lib     \
        $(RMLIBDIR)\mp.lib          \
        $(RMLIBDIR)\state.lib       \
        $(RMLIBDIR)\tmr.lib         \
        $(RMLIBDIR)\vblank.lib      \
        $(RMLIBDIR)\vid.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv4\mpnv04.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV04.C                                                          *
*   The NV04 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include <i2c.h>
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV04(VOID *);
RM_STATUS nvHalMpAlloc_NV04(VOID *);
RM_STATUS nvHalMpFree_NV04(VOID *);
RM_STATUS nvHalMpMethod_NV04(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV04(VOID *);
RM_STATUS nvHalMpServiceEvent_NV04(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV04(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO pMpHalInfo;
    PDACHALINFO pDacHalInfo;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalInfo = pHalHwInfo->pMpHalInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
        case MP_CONTROL_UNLOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U008 daddr, subaddr, data;
            U008 lock;

            pMpHalInfo->MPCPresent = 0;
            pMpHalInfo->MPCDeviceAddr = 0;

#ifdef IKOS
            return RM_OK;
#endif

            //
            // Allow registry setting to bypass MPC detection.
            //
            if (pMpHalInfo->DetectEnable == 0)
                return RM_OK;

            //
            // Attempt to detect the presence of the external MP ASIC.  If it is not present, don't
            // enable decompressor functionality or attempt to initialize the mediaport
            // registers.  If there's no external clock, we could lock the system.

            // Unlock CRTC extended regs
            CRTC_READ(NV_CIO_SR_LOCK_INDEX, lock);
            CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);
    
            // wayne's MPC detection algorithm
            // (for now only go up to chip addr 0x25, eventhough 0x26/0x27
            // should also be reserved for our use)
            for (daddr = 0x24; daddr <= 0x25; daddr++)
            {
                subaddr = 0x1;
                data = 0x8F;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                subaddr = 0x0;
                data = 0x80;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
        
                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) != 0xc0)
                    continue;

                subaddr = 0x0;
                data = 0x40;
                if (HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;

                if (HALRMI2CREAD(pHalHwInfo, NV_I2C_PORT_SECONDARY, daddr, 1, &subaddr, 1, &data) != RM_OK)
                    continue;
                if ((data & 0xc0) == 0x0)
                {
                    // Found the MediaPort (save addr for use in class51)
                    pMpHalInfo->MPCPresent = 1;
                    pMpHalInfo->MPCDeviceAddr = daddr;
                    break;
                }
            }
    
            //
            // Initialize the mp registers to a known state.  Only do this
            // if we know someone is out there.
            //
            if (pMpHalInfo->MPCPresent)
            {    
    
                //
                // Reset the MPC.
                //
                // MPC Enabled, Video Decoder Disable, TV Encoder Disable
                // Toggle the MPC Reset and DVD Reset low then high
                //
        
                //
                // Internal MPC I2C
                //
                subaddr = 1;    // index
                data = 0xFF;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
                subaddr = 0;    // data
                data = 0x07;
                HALRMI2CWRITE(pHalHwInfo, NV_I2C_PORT_SECONDARY, (U008)pMpHalInfo->MPCDeviceAddr, 1, &subaddr, 1, &data);
    
                //
                // Init the mediaport registers
                //
                // Initialize BUS_MODE to be disabled.  It will be initialized by either 
                // class04d (external decoder) or class04e (external decompressor) - JSUN
                //
                REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _VMI));
                REG_WR32(NV_PME_VID_ME_STATE, 0);
                REG_WR32(NV_PME_VID_SU_STATE, 0);
                REG_WR32(NV_PME_VID_RM_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_RM_STATE, 0);
                REG_WR32(NV_PME_VBI_ME_STATE, 0);
                REG_WR32(NV_PME_VBI_SU_STATE, 0);
                REG_WR32(NV_PME_VBI_RM_STATE, 0);
                REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
                REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
                REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
        
                REG_WR_DRF_DEF(_PME, _DEBUG_0, _DET_FIELD_SWITCH, _DISABLED);
                REG_WR32(NV_PME_DEBUG_1, DRF_DEF(_PME, _DEBUG_1, _SEL, _VIPCLK)
                         | DRF_DEF(_PME, _DEBUG_1, _VIPCLK_SEL, _DEFAULT)
                         | DRF_DEF(_PME, _DEBUG_1, _MCLK_SEL, _DEFAULT));
                                       
                //
                // enable MPC display data delivery
                //
                REG_WR32(NV_PME_EXTERNAL(2), 2);
    	
            }                               
            else
            {
                //
                // Default legacy state.  This is currently set manually when the old class66.c
                // is initialized and started.  When that class is retired and replaced with the
                // newer ExternalDecoder class, put this back in.
                //
                //REG_WR32(NV_PME_CONFIG_0, DRF_DEF( _PME, _CONFIG_0, _BUS_MODE, _CCIR656));
            }
            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV04(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo =  pMpAllocArg->pHalHwInfo;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;
            pMpHalPvtInfo = (PMPHALINFO_NV04)pMpAllocArg->pHalHwInfo->pMpHalPvtInfo;
#ifdef COMMENT
            //
            // Disable the MPC if there are no decompressor objects
            // using the MPC.
            //
            if ( pMpHalInfo->CurrentDecompressor == NULL ) {
                if ( pMpHalInfo->MPCPresent ) {
                    subaddr = 1;
                    data = 0x0f;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                    subaddr = 0;
                    data = 0x08;
                    HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
                }
            }
#endif
            //
            // Make sure to clear the h/w state
            //
            REG_WR32(NV_PME_VBI_ME_STATE, 0);
            REG_WR32(NV_PME_VBI_SU_STATE, 0);
            REG_WR32(NV_PME_VBI_RM_STATE, 0);
            REG_WR32(NV_PME_IMAGE_ME_STATE, 0);
            REG_WR32(NV_PME_IMAGE_SU_STATE, 0);
            REG_WR32(NV_PME_IMAGE_RM_STATE, 0);
            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
            PMPHALINFO_NV04 pMpHalPvtInfo;

            pMpHalPvtInfo = (PMPHALINFO_NV04)pHalHwInfo->pMpHalPvtInfo;

            //
            // MPC initialization
            //
            REG_WR32(NV_PME_EXTERNAL(3), 0x60);		// set wait states to 3
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _CONFIG_0, _VID_CD, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _VID_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_VID_ME_STATE, 0);
            REG_WR32(NV_PME_VID_SU_STATE, 0);
            REG_WR32(NV_PME_VID_RM_STATE, 0);
            REG_WR32(NV_PME_VID_CURRENT, 0);
    
            //
            // we also need to make sure Audio is not enabled (NV4 only)
            //
            if (IsNV4_NV04(pMpAllocArg->pHalHwInfo->pMcHalInfo))
            {
                REG_WR32(NV_PME_AUD_SU_STATE, 0);
                REG_WR32(NV_PME_AUD_ME_STATE, 0);
            }

            pMpHalPvtInfo->CurrentDecompressor = pMpAllocArg->pHalObjInfo;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV04(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;
    PMPHALINFO_NV04 pMpHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pMpHalPvtInfo = (PMPHALINFO_NV04)pMpFreeArg->pHalHwInfo->pMpHalPvtInfo;
    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
        {
#ifdef DISABLE_FOR_NOW
            //
            // disable the MPC 
            //
            subaddr = 1;
            data = 0x0f;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
            subaddr = 0;
            data = 0x08;
            HALRMI2CWRITE(pHalHwInfo, (U008)(pMpHalPvtInfo->MPCDeviceAddr), 1, &subaddr, 1, &data);
#endif
            pMpHalPvtInfo = 0;
            break;
        }
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV04(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV04(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV04(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV04(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV04(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV04(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV04(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV04(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV04(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv10\mpnv10.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV10.C                                                          *
*   The NV10 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV10(VOID *);
RM_STATUS nvHalMpAlloc_NV10(VOID *);
RM_STATUS nvHalMpFree_NV10(VOID *);
RM_STATUS nvHalMpMethod_NV10(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV10(VOID *);
RM_STATUS nvHalMpServiceEvent_NV10(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV10(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV10 pMpHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV10)pHalHwInfo->pMpHalPvtInfo;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
        case MP_CONTROL_UNLOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            if (IsNV10orBetter_NV10(pHalHwInfo->pMcHalInfo)) {
                return (RM_OK);
            }
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV10(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV10(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV10(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV10(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV10(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV10(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV10(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV10(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV10(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV10(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV10(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv20\nv20kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv4\nv04kern.c ===
static void NullFct(){}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\mp\nv20\mpnv20.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997-2000. All rights reserved.
//
/****************************** MediaPort Manager ***************************\
*                                                                           *
* Module: MPNV20.C                                                          *
*   The NV20 HAL MediaPort engine is managed in this module.                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

//
// HAL entry points.
//
RM_STATUS nvHalMpControl_NV20(VOID *);
RM_STATUS nvHalMpAlloc_NV20(VOID *);
RM_STATUS nvHalMpFree_NV20(VOID *);
RM_STATUS nvHalMpMethod_NV20(VOID *);
RM_STATUS nvHalMpGetEventStatus_NV20(VOID *);
RM_STATUS nvHalMpServiceEvent_NV20(VOID *);

//
// nvHalMpControl
//
RM_STATUS
nvHalMpControl_NV20(VOID *arg)
{
    PMPCONTROLARG_000 pMpControlArg = (PMPCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpControlArg->pHalHwInfo;
    PMPHALINFO_NV20 pMpHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pMpControlArg->id != MP_CONTROL_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpControl bad revision ", pMpControlArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpControlArg->pHalHwInfo;
    pMpHalPvtInfo = (PMPHALINFO_NV20)pHalHwInfo->pMpHalPvtInfo;

    switch (pMpControlArg->cmd)
    {
        case MP_CONTROL_UPDATE:
        case MP_CONTROL_LOAD:
        case MP_CONTROL_UNLOAD:
            break;
        case MP_CONTROL_INIT:
        {
            U032 hostConfig;

#ifdef IKOS
            //
            // Don't check for VIP slave (IKOS Temporary)
            //
            return (RM_OK);
#endif

            pMpHalPvtInfo->VIPSlavePresent = 0;
            hostConfig = REG_RD32(NV_PME_HOST_CONFIG);
            if ((hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_DETECTED, _TRUE)) &&
                (hostConfig & DRF_DEF(_PME, _HOST_CONFIG, _SLAVE_NOTDETECTED, _FALSE)) ) {
                pMpHalPvtInfo->VIPSlavePresent = 1;
            }

            //
            // Initialize media engine's config
            //

            REG_WR32(NV_PME_INTR_EN_0, 0);      // make sure all the media engine interrupts are disabled

            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _FIFOMAXTX, 32);
            FLD_WR_DRF_DEF(_PME, _HOST_CONFIG, _CLOCK_SELECT, _PCI);
            FLD_WR_DRF_NUM(_PME, _HOST_CONFIG, _TIMEOUT, 7);	// just in case

            //
            // Initialize media engine's various DMA engines
            //

            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);

            //
            // Clear 656_CONFIG
            //

            REG_WR32(NV_PME_656_CONFIG, 0);

            //
            // initialize FOUT_ADDR and FIN_ADDR to something on our VIP test card
            //
            // XXX need a method to set these addresses though!  (class04E has no address method)
            //
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _FIFO, 4);		// FIFO A
            FLD_WR_DRF_NUM(_PME, _FOUT_ADDR, _DEVICE, 0);

            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _FIFO, 5);		// FIFO B
            FLD_WR_DRF_NUM(_PME, _FIN_ADDR, _DEVICE, 0);

            break;
        }
        case MP_CONTROL_DESTROY:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

//
// nvHalMpAlloc
//
RM_STATUS
nvHalMpAlloc_NV20(VOID *arg)
{
    PMPALLOCARG_000 pMpAllocArg = (PMPALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pMpAllocArg->id != MP_ALLOC_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpAlloc bad revision ", pMpAllocArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpAllocArg->pHalHwInfo;

    switch (pMpAllocArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
        {
            PVIDEODECODERHALOBJECT pDecoderHalObj;

            pDecoderHalObj = (PVIDEODECODERHALOBJECT)pMpAllocArg->pHalObjInfo;

            pDecoderHalObj->lastWidthIn     = 0;
            pDecoderHalObj->lastWidthOut    = 0;
            pDecoderHalObj->lastHeightIn    = 0;
            pDecoderHalObj->lastHeightOut   = 0;

            pDecoderHalObj->lastImageConfig = 0xFFFFFFFF;
            //
            // To force initialization of the registers
            // this is used to indicate the first time around... 99
            // will likely never be used at a startline value since it
            // should be something like 0 - 21.
            //
            pDecoderHalObj->lastImageStartLine  = 99;     

            //
            // Clear the various DMA controls 
            //
            REG_WR32(NV_PME_ANC_ME_STATE, 0);
            REG_WR32(NV_PME_ANC_SU_STATE, 0);
            REG_WR32(NV_PME_ANC_RM_STATE, 0);
            REG_WR32(NV_PME_TASKA_ME_STATE, 0);
            REG_WR32(NV_PME_TASKA_SU_STATE, 0);
            REG_WR32(NV_PME_TASKA_RM_STATE, 0);
            REG_WR32(NV_PME_TASKB_ME_STATE, 0);
            REG_WR32(NV_PME_TASKB_SU_STATE, 0);
            REG_WR32(NV_PME_TASKB_RM_STATE, 0);

            //
            // Initialize 656 config
            // (For now we only handle TASKA streams.)
            //
            FLD_WR_DRF_NUM(_PME, _656_CONFIG, _TASKA_ENABLE, 1);
            FLD_WR_DRF_DEF(_PME, _656_CONFIG, _TASKA_ONLY, _DISABLED);

            //
            // initialize maximum line length
            //
            REG_WR32(NV_PME_TASKA_LINE_LENGTH, 0xfffff0);
            REG_WR32(NV_PME_TASKB_LINE_LENGTH, 0xfffff0);

            break;
        }
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // initialize the media engine
            //
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FOUT_NOTIFY, _DISABLED);
            FLD_WR_DRF_DEF(_PME, _INTR_EN_0, _FIN_NOTIFY, _DISABLED);
    
            REG_WR32(NV_PME_FOUT_ME_STATE, 0);
            REG_WR32(NV_PME_FOUT_SU_STATE, 0);
            REG_WR32(NV_PME_FOUT_RM_STATE, 0);
            REG_WR32(NV_PME_FOUT_CURRENT, 0);
            REG_WR32(NV_PME_FIN_ME_STATE, 0);
            REG_WR32(NV_PME_FIN_SU_STATE, 0);
            REG_WR32(NV_PME_FIN_RM_STATE, 0);
            REG_WR32(NV_PME_FIN_CURRENT, 0);

            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Nothing interesting for this class.
            //
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpFree
//
RM_STATUS
nvHalMpFree_NV20(VOID *arg)
{
    PMPFREEARG_000 pMpFreeArg = (PMPFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpFreeArg->id != MP_FREE_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpFree bad revision ", pMpFreeArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pMpFreeArg->pHalHwInfo;

    switch (pMpFreeArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            //
            // Nothing interesting for this class.
            //
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            //
            // Let's be forceful and stop either read/write if any in progress.
            //
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _READ, _NOT_PENDING);
            FLD_WR_DRF_DEF(_PME, _VIPREG_CTRL, _WRITE, _NOT_PENDING);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpMethod
//
RM_STATUS
nvHalMpMethod_NV20(VOID *arg)
{
    PMPMETHODARG_000 pMpMethodArg = (PMPMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pMpMethodArg->id != MP_METHOD_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpMethod bad revision ", pMpMethodArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpMethodArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            pMpMethodArg->mthdStatus = class04DMethod_NV20(pMpMethodArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            pMpMethodArg->mthdStatus = class04EMethod_NV20(pMpMethodArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            pMpMethodArg->mthdStatus = class04FMethod_NV20(pMpMethodArg);
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalMpGetEventStatus
//
// This interface accepts a bit mask of events for which
// the RM wishes to obtain pending status.  If an event bit
// bit is set, this routine will leave it set if it's pending,
// or clear it if it is not.
//
RM_STATUS
nvHalMpGetEventStatus_NV20(VOID *arg)
{
    PMPGETEVENTSTATUSARG_000 pMpGetEventStatusArg = (PMPGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpGetEventStatusArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpGetEventStatusArg->id != MP_GET_EVENT_STATUS_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpGetEventStatus bad revision ", pMpGetEventStatusArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpGetEventStatusArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FGetEventStatus_NV20(pMpGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalMpServiceEvent
//
// This interface completes event processing (e.g. resets
// buffer status).
//
RM_STATUS
nvHalMpServiceEvent_NV20(VOID *arg)
{
    PMPSERVICEEVENTARG_000 pMpServiceEventArg = (PMPSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pMpServiceEventArg->pHalHwInfo;
    RM_STATUS status;

    //
    // Verify interface revision.
    //
    if (pMpServiceEventArg->id != MP_SERVICE_EVENT_000)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: nvHalMpServiceEvent bad revision ", pMpServiceEventArg->id);
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pMpServiceEventArg->classNum)
    {
        case NV03_EXTERNAL_VIDEO_DECODER:
            status = class04DServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV03_EXTERNAL_VIDEO_DECOMPRESSOR:
            status = class04EServiceEvent_NV20(pMpServiceEventArg);
            break;
        case NV1_EXTERNAL_PARALLEL_BUS:
            status = class04FServiceEvent_NV20(pMpServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv10\makefile.inc ===
!IFDEF NVIA64
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\ia64
!ELSE
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386
!ENDIF

!IF "$(BUILD_DDK_VER)"!="nt5"
RMLIBDIR=$(RMLIBDIR)\$(DDKBUILDENV)
!ENDIF

$(RMLIBDIR)\nv10kern.lib:           \
        $(RMLIBDIR)\dacnv10.lib     \
        $(RMLIBDIR)\dmanv10.lib     \
        $(RMLIBDIR)\fbnv10.lib      \
        $(RMLIBDIR)\fifonv10.lib    \
        $(RMLIBDIR)\grnv10.lib      \
        $(RMLIBDIR)\halnv10.lib     \
        $(RMLIBDIR)\mcnv10.lib      \
        $(RMLIBDIR)\modnv10.lib     \
        $(RMLIBDIR)\mpnv10.lib      \
        $(RMLIBDIR)\vidnv10.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv20\makefile.inc ===
!IFDEF NVIA64
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\ia64
!ELSE
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386
!ENDIF

!IF "$(BUILD_DDK_VER)"!="nt5"
RMLIBDIR=$(RMLIBDIR)\$(DDKBUILDENV)
!ENDIF

$(RMLIBDIR)\nv20kern.lib:           \
        $(RMLIBDIR)\dacnv20.lib     \
        $(RMLIBDIR)\dmanv20.lib     \
        $(RMLIBDIR)\fbnv20.lib      \
        $(RMLIBDIR)\fifonv20.lib    \
        $(RMLIBDIR)\grnv20.lib      \
        $(RMLIBDIR)\halnv20.lib     \
        $(RMLIBDIR)\mcnv20.lib      \
        $(RMLIBDIR)\modnv20.lib     \
        $(RMLIBDIR)\mpnv20.lib      \
        $(RMLIBDIR)\vidnv20.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\tmr\nv\tmrinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TMRINIT.C                                                         *
*   Time state is initialized here.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
//  Initialize timer.
//
RM_STATUS  initTmr
(
    PHWINFO pDev
)
{
    RM_STATUS status;
    S032      num;
    S032      den;
    U032      i;

    //
    // Save previous values.
    //
    pDev->Timer.tmrSave[0] = REG_RD32(NV_PTIMER_NUMERATOR);
    pDev->Timer.tmrSave[1] = REG_RD32(NV_PTIMER_DENOMINATOR);
    //
    // Init timer callback list.
    //
    pDev->DBtmrCallbackList = NULL;
    status = osAllocMem((VOID **)&pDev->DBtmrCallbackTable, sizeof(TIMERCALLBACK) * NUM_TIMERCALLBACKS);
    if (status)
        return (status);
    pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackTable;
    for (i = 0; i < NUM_TIMERCALLBACKS - 1; i++)
    {
        pDev->DBtmrCallbackFreeList[i].Next = &(pDev->DBtmrCallbackFreeList[i + 1]);
    }
    pDev->DBtmrCallbackFreeList[i].Next = NULL;
    //
    // Calc numerator and denomenator from DAC NVCLK parameters.
    // From Curtis.
    //
    // num = pDev->Dac.MClk; // The manual says MClk. That is wrong.
    num = pDev->Dac.HalInfo.NVClk;
    den = 31250000;
    while ((num % 2 == 0) && (den % 2 == 0))
    {
        num /= 2;
        den /= 2;
    }
    while ((num % 5 == 0) && (den % 5 == 0))
    {
        num /= 5;
        den /= 5;
    }
    while ((num > 2 * DRF_MASK(NV_PTIMER_NUMERATOR_VALUE))
        || (den > 2 * DRF_MASK(NV_PTIMER_DENOMINATOR_VALUE)))
    {
        num /= 2;
        den /= 2;
    }
    num = (num + 1) / 2;
    den = (den + 1) / 2;
    pDev->Timer.Numerator   = num;
    pDev->Timer.Denominator = den;
    
    REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
    REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
    REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
#ifdef RM_STATS
    //
    // Init performance timer to come in every second.
    //
    pDev->Statistics.UpdateLo = 1000000000;
    pDev->Statistics.UpdateHi = 0;
    
    //
    // Zero exception and service counts.
    //
    pDev->Statistics.FifoExceptionCount        = 0;
    pDev->Statistics.FramebufferExceptionCount = 0;
    pDev->Statistics.GraphicsExceptionCount    = 0;
    pDev->Statistics.TotalExceptionCount       = 0;
    pDev->Fifo.ServiceCount                    = 0;
    pDev->Framebuffer.ServiceCount             = 0;
    pDev->Graphics.ServiceCount                = 0;
    pDev->Chip.ServiceCount                    = 0;
    pDev->MediaPort.ServiceCount               = 0;
    pDev->Video.ServiceCount                   = 0;
#endif
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\tmr\nv\tmrstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Timer Module ********************************\
*                                                                           *
* Module: TMRSTATE.C                                                        *
*   The Timer cntrol state is maintained in this module.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <tmr.h>
#include <os.h>
#include "nvhw.h"


//
// Month to days conversion.
//
U032 tmrMonthDays[12] =
{
    31, 28, 31, 30,
    31, 30, 31, 31,
    30, 31, 30, 31
};

//
// Change Master Control hardware state.
//
RM_STATUS stateTmr
(
    PHWINFO pDev,
    U032    msg
)
{
    RM_STATUS status;
#if defined(UNIX) || defined(MACOS)
    U032      seconds;
    U032      useconds;
    long long mseconds;			// U064 is a struct, not long long
#else    
    U032      year;
    U032      month;
    U032      day;
    U032      hour;
    U032      min;
    U032      sec;
    U032      msec;
    U032      days;
#endif
    U032      sec5;
    
    switch (msg)
    {
        case STATE_UPDATE:
            break;
        case STATE_LOAD:
            //
            // Set timer values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);
            REG_WR32(NV_PTIMER_ALARM_0,     0xFFFFFFFF);
            //
            // Get current time from operating system.
            //
            
#if defined(UNIX) || defined(MACOS)
            // On UNIX, we get the time in seconds since 1970.
            // From within the unix kernel it is actually hard to get
            //   real time of day.  We don't really need it anyway.
            osGetCurrentTime(&seconds, &useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Time = ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, seconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " seconds, ");
			DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, useconds);
			DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " useconds.\n");
            mseconds = seconds * 1000 + (useconds / 1000);
            sec5 = mseconds / 4295;
#else
            osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "NVRM: Date = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, month);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, day);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "/");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, year);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, " ");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, hour);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, min);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, sec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, ":");
            DBG_PRINT_VALUE(DEBUGLEVEL_SETUPINFO, msec);
            DBG_PRINT_STRING(DEBUGLEVEL_SETUPINFO, "\n");

            //
            // Perform a quick error check of the time
            //
            if (month > 12)
                    month = 12;
            if (day > 31)
                    day = 20;
            if (hour > 24)
                    hour = 12;
            if (min > 59)
                    min = 59;
            if (sec > 59)
                    sec = 59;

            //
            // Get days so far.
            //
            if (year > 1990)
                year -= 1990;
            days = year * 365 + (year + 1) / 4;
            //
            // If this is a current leap year, check the month.
            //
            if (!((year + 2) & 3) && (month > 2))
                days++;
            while (--month)
                days += tmrMonthDays[month];
            days += day;
            sec5 = days * 20117 + hour * 838 + (min * 257698 + sec * 4295) / 1000;

            //
            // Add number of 4.295 sec increments between 1970 and 1990 to the 
            // accumulated time.
            //
            sec5 += 146951526;
#endif

            //
            // Since the internal timer is only accurate to about 5 sec/day,
            // that is about the accuracy of the upper 32 bits of the nsec timer.
            // To initialize, just calculate the current time to the nearest 4.295 sec.
            //
            REG_WR32(NV_PTIMER_TIME_0, 0);
            REG_WR32(NV_PTIMER_TIME_1, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: TIMER = ");
            DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO, sec5);
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ":0x00000000\n");

            if (!pDev->Vga.Enabled) // interrupts wake up from standby on some motherboards
            {
                //
                // Enable Timer interrupt.
                //
                REG_WR32(NV_PTIMER_INTR_0,    0xFFFFFFFF);
                REG_WR32(NV_PTIMER_INTR_EN_0, 0xFFFFFFFF);
            }            
#ifdef RM_STATS
            /*
            For now, no perf timer needed!!
            
            //
            // Schedule performance timer.
            //
            tmrScheduleCallbackRel(tmrStatTimer,
                                   (POBJECT)0x69,
                                   pDev->Statistics.UpdateHi,
                                   pDev->Statistics.UpdateLo);
            */
#endif
            break;
        case STATE_UNLOAD:
            //
            // Disable Timer interrupt.
            //
            REG_WR32(NV_PTIMER_INTR_EN_0, 0);
            //
            // Cancel performance timer.
            //
            tmrCancelCallback(pDev, (POBJECT)0x69);
            break;
        case STATE_INIT:
            status = initTmr(pDev);
            break;
        case STATE_DESTROY:
            //
            // Restore previous values.
            //
            REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.tmrSave[0]);
            REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.tmrSave[1]);
            osFreeMem((VOID *)pDev->DBtmrCallbackTable);
            break;
    }    
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\tmr\nv\time.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** Time Manager *****************************\
*                                                                           *
* Module: TIME.C                                                            *
*   Time objects are managed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <state.h>
#include <dma.h>
#include <tmr.h>
#include <os.h>
#include <nv32.h>
#include <smp.h>
#include "nvhw.h"

//
// Object creation/deletion.
//
RM_STATUS tmrCreateTimer
(
    VOID*      pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *TimeObject,
    VOID*        pCreateParms
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS status;
    
    RM_ASSERT(ClassObject->Base.Name == NV1_TIMER);

    //
    // Try to allocate the timer object
    //
    status = osAllocMem((VOID **)TimeObject, sizeof(TIMEROBJECT));

    if (status == RM_OK)
    {

//      ((PTIMEROBJECT)*TimeObject)->NotifyXlate  = NULL;
//      ((PTIMEROBJECT)*TimeObject)->NotifyAction = 0;
        ((PTIMEROBJECT)*TimeObject)->State        = BUFFER_IDLE;
        ((PTIMEROBJECT)*TimeObject)->AlarmLo      = 0;
        ((PTIMEROBJECT)*TimeObject)->AlarmHi      = 0;

        //
        // Init common (software) state.
        //
        classInitCommonObject(*TimeObject, ClassObject, UserName);

        //
        // Try to build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                         &((PTIMEROBJECT)*TimeObject)->CBase,
                                          ((PTIMEROBJECT)*TimeObject)->CBase.ChID,
                                          ((PTIMEROBJECT)*TimeObject)->CInstance);

        if (status != RM_OK)
        {
            //
            // Free the timer object and NULL the object pointer
            //
            osFreeMem(*TimeObject);
            *TimeObject = NULL;
        }
    }
    return (status);
}

RM_STATUS tmrDeleteContextTime
(
    POBJECT TimeObject
)
{
    return (osFreeMem(TimeObject));
}

RM_STATUS tmrDeleteTimer
(
    VOID*   pDevHandle,
    POBJECT TimeObject
)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;

    //
    // Check for valid timer object
    //
    if (TimeObject != NULL)
    {
        //
        // Clear the subChannel ptrs for this object 
        //
        osEnterCriticalCode(pDev);
        fifoDeleteSubchannelContextEntry(pDev, TimeObject);
        osExitCriticalCode(pDev);

        //
        // Cancel any outstanding callbacks before deleting object.
        //
        tmrCancelCallback(pDev, TimeObject);
        osFreeMem(TimeObject);
    }
    return (RM_OK);
}

//
// Methods.
//
RM_STATUS mthdSetTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;
    U032      TimeCheck;
    U032      TimeLo;
    U032      TimeHi;
    
    status = RM_OK;
    if (Offset == Method->Low)
    {
        ((PTIMEOBJECT)Object)->TimeLo = Data;
    }
    else
    {
        //
        // Treat time values less than 4.29 sec as relative.
        //
        if (!Data)
        {
            do
            {
                TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
                TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
                TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != TimeHi);
            ((PTIMEOBJECT)Object)->TimeLo += TimeLo;
            //
            // Handle carry.
            //
            if (((PTIMEOBJECT)Object)->TimeLo < TimeLo)
                Data = 1;
            Data += TimeHi;    
        }
        ((PTIMEOBJECT)Object)->TimeHi = Data;
        //
        // Reflect new time to all attached objects.
        //
        if (((PTIMEOBJECT)Object)->TimeProc)
            status = ((PTIMEOBJECT)Object)->TimeProc(pDev, ((PTIMEOBJECT)Object)->TimeChange);
    }
    return (status);
}

RM_STATUS mthdSetAlarmNotifyCtxDma
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }

    //
    // Connect to dma buffer.
    //    
    status = dmaValidateObjectName(pDev, Data,
                                   Object->ChID,
                                   &((Object)->NotifyXlate));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    //
    // Make sure the context dma is large enough (2 notifiers)
    //    
    status = dmaValidateXlate(Object->NotifyXlate, 0, (2 * 0x0010));
    if (status)
    {
        (Object)->NotifyXlate = NULL;
        return (status);
    }

    return (status);
}

RM_STATUS mthdSetAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    RM_STATUS     status;

    //
    // Check for busy buffer.
    //
    if (((PTIMEROBJECT)Object)->State == BUFFER_BUSY)
    {
        osError(Object, Offset, Data, RM_ERROR);
        return (RM_ERR_DMA_IN_USE);
    }
    (Object)->NotifyAction = Data;
    //
    // Validate notification parameters.
    //    
    status = dmaValidateXlate((Object)->NotifyXlate, 0, 0x000F);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	/* KJK
    status = dmaBeginXfer(((PTIMEROBJECT)Object)->NotifyXlate, NULL);
    if (status)
    {
        osError(Object, Offset, Data, status);
        return (status);
    }
	*/
    //
    // Schedule the alarm.
    //
    ((PTIMEROBJECT)Object)->State = BUFFER_BUSY;
    return (tmrScheduleCallbackAbs(pDev,
                                   tmrAlarmNotify,
                                   Object,
                                   ((PTIMEROBJECT)Object)->AlarmHi,
                                   ((PTIMEROBJECT)Object)->AlarmLo));
}

RM_STATUS mthdSetAlarmTime
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = Data;

    return RM_OK;
}

RM_STATUS mthdSetAlarmTimeRelative
(
	PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    U032    TimeCheck;
    U032    CurrentTimeLo;
    U032    CurrentTimeHi;

    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if (Offset == Method->Low) {
        // set AlarmHigh, in case AlarmLo is the only method sent
        ((PTIMEROBJECT)Object)->AlarmLo = CurrentTimeLo + Data;
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi;

         // if AlarmLo rolled over, increment AlarmHi
         if (((PTIMEROBJECT)Object)->AlarmLo < CurrentTimeLo)
            ((PTIMEROBJECT)Object)->AlarmHi++;
    } else
        ((PTIMEROBJECT)Object)->AlarmHi = CurrentTimeHi + Data;

    return RM_OK;
}

//
// Alarm callback.
//
RM_STATUS tmrAlarmNotify
(
	PHWINFO pDev,
    POBJECT Object
)
{
    notifyFillNotifierArray(pDev, (Object)->NotifyXlate, 0, 0, RM_OK,
                            NV004_NOTIFIERS_SET_ALARM_NOTIFY);

    if ((Object)->NotifyAction)
    {
        //
        // Do any OS specified action related to this notification.
        //
        osNotifyEvent(pDev, Object, 
                      1,	  // NV004_NOTIFIERS_SET_ALARM_NOTIFY
                      0, 
                      1, 
                      RM_OK, 
                      (Object)->NotifyAction);
    }

    ((PTIMEROBJECT)Object)->State = BUFFER_IDLE;

    return (RM_OK);
}

RM_STATUS tmrStopTransfer
(
	PHWINFO pDev,
	POBJECT Object, 
	PMETHOD Method, 
	U032    Offset,
	V032	Data
)
{

	return (RM_OK);

}

//
// NV_PTIMER_TIME_0 rolls over approx every 4 secs. For delays
// less than 1/4 of that time just compare against TIME_0
//
#define MAX_SMALLNS_TMRDELAY (0xFFFFFFFF >> 2)

//
// Timer related functions.
//
RM_STATUS tmrDelay
(
    PHWINFO pDev,
    U032 nsec
)
{
    U032 TimeHi;
    U032 TimeLo;
    U032 TimeCheck;
    U032 IsPllSlowed = 0;  // some compilers think its uninitialized otherwise
    static U032 TimeStart;
    //
    // Check to see if NVCLK is currently being dynamically slowed
    // If so, temporarily disable so we can get a true time delay
    //
    // KJK: I wonder if this should be halified?
    //
    if (IsNV11(pDev))
    {
        S032      num;
        S032      den;

        IsPllSlowed = REG_RD_DRF(_PBUS, _DEBUG_1, _CORE_SLOWDWN);
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, 0);

        //
        // Recalculate the ratio in case nvclk has changed
        //
        // Calc numerator and denomenator from DAC NVCLK parameters.
        // From Curtis.
        //
        num = pDev->Dac.HalInfo.NVClk;
        den = 31250000;
        while ((num % 2 == 0) && (den % 2 == 0))
        {
            num /= 2;
            den /= 2;
        }
        while ((num % 5 == 0) && (den % 5 == 0))
        {
            num /= 5;
            den /= 5;
        }
        while ((num > 2 * DRF_MASK(NV_PTIMER_NUMERATOR_VALUE))
            || (den > 2 * DRF_MASK(NV_PTIMER_DENOMINATOR_VALUE)))
        {
            num /= 2;
            den /= 2;
        }
        num = (num + 1) / 2;
        den = (den + 1) / 2;
        pDev->Timer.Numerator   = num;
        pDev->Timer.Denominator = den;

        REG_WR32(NV_PTIMER_NUMERATOR,   pDev->Timer.Numerator);
        REG_WR32(NV_PTIMER_DENOMINATOR, pDev->Timer.Denominator);

    }

    //
    // For small delays which can only wrap PTIMER_TIME_0 once, doing 2's
    // comp math on TIME_0 is enough and means we don't have to sync TIME_1
    //
    if (nsec < MAX_SMALLNS_TMRDELAY)
    {
	TimeStart = REG_RD32(NV_PTIMER_TIME_0);
	while (nsec > ((volatile U032)REG_RD32(NV_PTIMER_TIME_0) - TimeStart))
	    ;

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

	return (RM_OK);
    }

    //
    // Get current time.
    //
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        TimeLo    = REG_RD32(NV_PTIMER_TIME_0);
        TimeHi    = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != TimeHi);
    //
    // Add nanosecond delay.
    //
    TimeLo += nsec;
    if (TimeLo < nsec)
        TimeHi++;
    //
    // Wait until time catches up.
    //
    while (TimeHi > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1)))
	    ;
#if 0
    //
    // There's a potential hang event (or extremely long delay) that can
    // occur here under special circumstances.
    //
    while (TimeLo > (volatile U032)REG_RD32(NV_PTIMER_TIME_0));
#else
    //
    // Try to avoid infinite delay.
    //
    while ((TimeLo > (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_0))) &&
           (TimeHi == (U032)((volatile U032)REG_RD32(NV_PTIMER_TIME_1))))
		       ;
#endif

    //
    // Restore PLL slowdown setting
    //
    if (IsNV11(pDev))
        FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _CORE_SLOWDWN, IsPllSlowed);

    return (RM_OK);
}
RM_STATUS tmrGetCurrentTime
(
	PHWINFO pDev,
    U032 *TimeHi,
    U032 *TimeLo
)
{
    U032 TimeCheck;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        *TimeLo   = REG_RD32(NV_PTIMER_TIME_0);
        *TimeHi   = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != *TimeHi);
    return (RM_OK);
}

RM_STATUS tmrScheduleCallbackRel
(
	PHWINFO pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     RelTimeHi,
    U032     RelTimeLo
)
{
    U032 TimeCheck;
    U032 AbsTimeHi;
    U032 AbsTimeLo;
    
    do
    {
        TimeCheck = REG_RD32(NV_PTIMER_TIME_1);
        AbsTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        AbsTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != AbsTimeHi);

    AbsTimeLo += RelTimeLo;
    if (AbsTimeLo < RelTimeLo)
        AbsTimeHi++;
    AbsTimeHi += RelTimeHi;

    return (tmrScheduleCallbackAbs(pDev, Proc, Object, AbsTimeHi, AbsTimeLo));
}

RM_STATUS tmrScheduleCallbackAbs
(
	PHWINFO  pDev,
    TIMEPROC Proc,
    POBJECT  Object,
    U032     TimeHi,
    U032     TimeLo
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrInsert;
    PTIMERCALLBACK tmrScan;
    
    do
    {
        TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
        CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
        CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
    } while (TimeCheck != CurrentTimeHi);

    if ((TimeHi <  CurrentTimeHi)
    || ((TimeHi == CurrentTimeHi) && (TimeLo <= CurrentTimeLo)))
    {
        //
        // Call immediately if time passed.
        //
        Proc(pDev, Object);
    }
    else
    {
        //
        // Schedule callback at appropriate time.
        //
        tmrInsert = pDev->DBtmrCallbackFreeList;
        if (tmrInsert == NULL)
        {
            //
            // Uh-ho.  Out of callback headers.  Call the proc anyway.
            //
            Proc(pDev, Object);
            return (RM_ERR_OUT_OF_TIMER_CALLBACKS);
        }
        pDev->DBtmrCallbackFreeList = pDev->DBtmrCallbackFreeList->Next;
        tmrInsert->Callback = Proc;
        tmrInsert->Object   = Object;
        tmrInsert->TimeLo   = TimeLo;
        tmrInsert->TimeHi   = TimeHi;
        tmrInsert->Next     = NULL;
        if (pDev->DBtmrCallbackList == NULL)
        {
            //
            // Insert this immediatelly.
            //
            pDev->DBtmrCallbackList = tmrInsert;
            REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
        }
        else
        {
            //
            // Scan looking for insert place.
            //
            if ((TimeHi <  pDev->DBtmrCallbackList->TimeHi)
            || ((TimeHi == pDev->DBtmrCallbackList->TimeHi) && (TimeLo <= pDev->DBtmrCallbackList->TimeLo)))
            {
                tmrInsert->Next = pDev->DBtmrCallbackList;
                pDev->DBtmrCallbackList = tmrInsert;
                REG_WR32(NV_PTIMER_ALARM_0, TimeLo);
            }
            else
            {
                tmrScan = pDev->DBtmrCallbackList;
                while (tmrScan->Next)
                {
                    if ((TimeHi <  tmrScan->Next->TimeHi)
                    || ((TimeHi == tmrScan->Next->TimeHi) && (TimeLo <= tmrScan->Next->TimeLo)))
                    {
                        tmrInsert->Next = tmrScan->Next;
                        tmrScan->Next   = tmrInsert;
                        return (RM_OK);
                    }
                    tmrScan = tmrScan->Next;
                }
                tmrScan->Next = tmrInsert;
            }
        }
    }

    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

RM_STATUS tmrCancelCallback
(
	PHWINFO  pDev,
    POBJECT  Object
)
{
    PTIMERCALLBACK tmrDelete;
    PTIMERCALLBACK tmrScan;
    
    if (pDev->DBtmrCallbackList)
    {
        while (pDev->DBtmrCallbackList->Object == Object)
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            if (pDev->DBtmrCallbackList)
                REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            else
                return (RM_OK);
        }
        tmrScan = pDev->DBtmrCallbackList;
        while (tmrScan->Next)
        {
            //
            // Scan list looking for matchs.
            //
            if (tmrScan->Next->Object == Object)
            {
                tmrDelete           = tmrScan->Next;
                tmrScan->Next       = tmrScan->Next->Next;
                tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
                pDev->DBtmrCallbackFreeList = tmrDelete;
            }
            else
            {
                tmrScan = tmrScan->Next;
            }
        }
    }
    //
    // Call service routine to catch any timing window.
    //
    tmrService(pDev);
    return (RM_OK);
}

#ifdef RM_STATS
RM_STATUS tmrStatTimer
(
    PHWINFO pDev,
    POBJECT dummy
)
{
    //
    // Move current service counts to exception counts .
    //
    pDev->Statistics.FifoExceptionCount        = pDev->Fifo.ServiceCount;
    pDev->Statistics.FramebufferExceptionCount = pDev->Framebuffer.ServiceCount;
    pDev->Statistics.GraphicsExceptionCount    = pDev->Graphics.ServiceCount;
    pDev->Statistics.TimerExceptionCount       = pDev->Timer.ServiceCount;
    pDev->Statistics.TotalExceptionCount       = pDev->Chip.ServiceCount;
    pDev->Statistics.ExecTimeLo                = pDev->Chip.ServiceTimeLo;
    pDev->Statistics.ExecTimeHi                = pDev->Chip.ServiceTimeHi;
    pDev->Statistics.IntTimeLo                 = pDev->Chip.ExceptionTimeLo;
    pDev->Statistics.IntTimeHi                 = pDev->Chip.ExceptionTimeHi;
    //
    // Zero service counts.
    //
    pDev->Fifo.ServiceCount        = 0;
    pDev->Framebuffer.ServiceCount = 0;
    pDev->Graphics.ServiceCount    = 0;
    pDev->Timer.ServiceCount       = 0;
    pDev->Video.ServiceCount       = 0;
    pDev->MediaPort.ServiceCount   = 0;
    pDev->Chip.ServiceCount        = 0;
    pDev->Chip.ServiceTimeLo       = 0;
    pDev->Chip.ServiceTimeHi       = 0;
    pDev->Chip.ExceptionTimeLo     = 0;
    pDev->Chip.ExceptionTimeHi     = 0;
    //
    // Schedule next interval.
    //
    tmrScheduleCallbackRel(pDev,
                           tmrStatTimer,
                           (POBJECT)0x69,
                           pDev->Statistics.UpdateHi,
                           pDev->Statistics.UpdateLo);
    return (RM_OK);
}
#endif

//
// Timer alarm service.
//
V032 tmrService
(
    PHWINFO pDev
)
{
    U032           TimeCheck;
    U032           CurrentTimeLo;
    U032           CurrentTimeHi;
    PTIMERCALLBACK tmrDelete;
    
    REG_WR_DRF_DEF(_PTIMER, _INTR_0, _ALARM, _RESET);
    //
    // Call all callbacks that have expired.
    //
    if (pDev->DBtmrCallbackList)
    {
        do
        {
            TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
            CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
            CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
        } while (TimeCheck != CurrentTimeHi);

        //
        // Check for expired time.
        //
        while ((pDev->DBtmrCallbackList->TimeHi <  CurrentTimeHi)
           || ((pDev->DBtmrCallbackList->TimeHi == CurrentTimeHi) && (pDev->DBtmrCallbackList->TimeLo <= CurrentTimeLo)))
        {
            //
            // Pull from head of list.
            //
            tmrDelete           = pDev->DBtmrCallbackList;
            pDev->DBtmrCallbackList     = pDev->DBtmrCallbackList->Next;
            tmrDelete->Next     = pDev->DBtmrCallbackFreeList;
            pDev->DBtmrCallbackFreeList = tmrDelete;
            //
            // Call callback.  This could insert a new callback into the list.
            //
            tmrDelete->Callback(pDev, tmrDelete->Object);
            if (!pDev->DBtmrCallbackList)
                break;
            REG_WR32(NV_PTIMER_ALARM_0, pDev->DBtmrCallbackList->TimeLo);
            do
            {
                TimeCheck     = REG_RD32(NV_PTIMER_TIME_1);
                CurrentTimeLo = REG_RD32(NV_PTIMER_TIME_0);
                CurrentTimeHi = REG_RD32(NV_PTIMER_TIME_1);
            } while (TimeCheck != CurrentTimeHi);
        }
    }    
    return (REG_RD32(NV_PTIMER_INTR_0));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\video\nv\video.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: video.c                                                           *
*   The video engine is managed here.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include "nvhw.h"

#define DEBUGLEVEL_TRACEINFO_SCOTTL DBG_LEVEL_ERRORS

//
// Change Video hardware state.
//
RM_STATUS stateVideo
(
    PHWINFO pDev,
    U032    msg
)
{
    switch (msg)
    {
        case STATE_UPDATE:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UPDATE);
            break;
        case STATE_LOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_LOAD);
            break;
        case STATE_UNLOAD:
            nvHalVideoControl(pDev, VIDEO_CONTROL_UNLOAD);
            break;
        case STATE_INIT:
        {
            U032 i;
            extern char strDevNodeRM[];
            U032 data32;

            if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FlipOnHsync", &data32) == RM_OK)
                pDev->Video.FlipOnHsync = data32;
            else
                pDev->Video.FlipOnHsync = 0x0;
            nvHalVideoControl(pDev, VIDEO_CONTROL_INIT);
            pDev->Video.HalInfo.Enabled = 0;
            for (i = 0; i < MAX_CRTCS; i++)
            {
                pDev->Video.HalInfo.PanOffsetDeltaX[i] = 0;
                pDev->Video.HalInfo.PanOffsetDeltaY[i] = 0;
            }
            break;
        }
        case STATE_DESTROY:
            nvHalVideoControl(pDev, VIDEO_CONTROL_DESTROY);
            break;
    }
    return (RM_OK);
}

//
// Top-level video engine service handler.
V032 videoService
(
    PHWINFO pDev
)
{
    //
    // Even when pDev->ActiveVideoOverlayObject is NULL, don't opt out early, still
    // give the underlying chip specific ISR a chance to quiesce the video HW.
    //
    return pDev->pOverlayServiceHandler(pDev, (POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\nvkernel\nv4\makefile.inc ===
!IFDEF NVIA64
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\ia64
!ELSE
RMLIBDIR=$(BUILD_TREE)\drivers\resman\arch\nvalloc\winnt4\lib\nv4\i386
!ENDIF

!IF "$(BUILD_DDK_VER)"!="nt5"
RMLIBDIR=$(RMLIBDIR)\$(DDKBUILDENV)
!ENDIF

$(RMLIBDIR)\nv04kern.lib:           \
        $(RMLIBDIR)\dacnv04.lib     \
        $(RMLIBDIR)\dmanv04.lib     \
        $(RMLIBDIR)\fbnv04.lib      \
        $(RMLIBDIR)\fifonv04.lib    \
        $(RMLIBDIR)\grnv04.lib      \
        $(RMLIBDIR)\halnv04.lib     \
        $(RMLIBDIR)\mcnv04.lib      \
        $(RMLIBDIR)\modnv04.lib     \
        $(RMLIBDIR)\mpnv04.lib      \
        $(RMLIBDIR)\vidnv04.lib
                $(LIBRARIAN) $**
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\state\nv\state.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/
 
/***************************** HW State Rotuines ***************************\
*                                                                           *
* Module: STATE.C                                                           *
*       Hardware State is managed in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vga.h>
#include <os.h>
#include "nvhw.h"
#include "nvcm.h"
#include "nvcmrsvd.h"
#include "dac.h"
#include "edid.h"
#include "mvision.h"
#include <dload.h>

// this is defined in nvarch.h, but I'm not sure its ok to include that here 
// on all platforms
#ifndef RM_SUCCESS
#define RM_SUCCESS(status)  ((status) == RM_OK)
#endif

#define IsAGPCapable(pdev)  (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)

//
// Master state structure.
//
// HWINFO  nvInfo;
//
// State functions. Notice that LOAD/UNLOAD are treated as a pair.
// When an UNLOAD request arrives, the semaphore won't be released
// until a matching LOAD arrives.
//
RM_STATUS stateNv
(
    PHWINFO pDev, // Pointer to an nv device
    U032    msg
)
{
    RM_STATUS status;

    status = RM_OK;
    switch (msg)
    {
        case STATE_INIT:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);  // init timer before fb so we can do I2C
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            break;
        case STATE_UPDATE:

        case STATE_LOAD:
            if (!status) status = stateMc(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateMp(pDev, msg);
            break;
        case STATE_UNLOAD:

        case STATE_DESTROY:
            if (!status) status = stateMp(pDev, msg);
            if (!status) status = stateFifo(pDev, msg);
            if (!status) status = stateGr(pDev, msg);
            if (!status) status = stateDma(pDev, msg);
            if (!status) status = stateFb(pDev, msg);
            if (!status) status = stateTmr(pDev, msg);
            if (!status) status = stateVideo(pDev, msg);
            if (!status) status = stateDac(pDev, msg);
            if (!status) status = stateMc(pDev, msg);
            break;
    }
    return (status);
}

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode_DacClassStyle
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    stateMc(pDev, STATE_UNLOAD);
    stateFb(pDev, STATE_UNLOAD);
    stateVideo(pDev,STATE_UNLOAD);
    stateDac(pDev,STATE_UNLOAD);
    stateTmr(pDev,STATE_UNLOAD);
    stateDma(pDev,STATE_UNLOAD);
    stateGr(pDev, STATE_UNLOAD);
    stateMp(pDev, STATE_UNLOAD);
    
    stateMp(pDev, STATE_LOAD);
    stateGr(pDev, STATE_LOAD);
    stateDma(pDev,STATE_LOAD);
    stateFb(pDev, STATE_LOAD);
    stateTmr(pDev,STATE_LOAD);
    stateDac(pDev,STATE_LOAD);
    stateVideo(pDev,STATE_LOAD);
    stateMc(pDev, STATE_LOAD);

    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetMode
(
    PHWINFO pDev
)
{
    // Tell the driver to unload state if necessary.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    // Unload the current state.
    stateNv(pDev, STATE_UNLOAD);

    // Load the new state.
    stateNv(pDev, STATE_LOAD);

    // tell the driver to load state.
    // We should really be calling the callback function with STATE_LOAD at this time. However,
    // the display driver has worked around this bug. So don't change it till the display
    // driver can deal with us calling it with STATE_LOAD.
    osDisplayModeHook(pDev, STATE_UNLOAD);

    return RM_OK;
} // end of stateSetMode

// 
// This function is used to change from one hires mode to another. It is called 
// by the VIDEO_LUT_CURSOR_DAC classes to set a new mode.
// It is assumed that all the crtc timing values are in the pDev.
//
RM_STATUS stateSetModeMultiHead
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pDac
)
{
    // no state changes are necessary
    dacSetModeMulti(pDev, pDac);

    return RM_OK;
} // end of stateSetMode

//---------------------------------------------------------------------------
//
//  Nv device state information.
//
//---------------------------------------------------------------------------

//
// DDK Entries to get/set system parameters
//
RM_STATUS stateConfigGet(
    PHWINFO pDev,
    U032    index,
    U032*   pValue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result;
   
    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to view
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        lock = UnlockCRTC(pDev, 0);
        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);
        
        RestoreLock(pDev, 0, lock);
    
        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // These values actually look at hardware, not NvInfo.
            //
            case NV_CFG_VBLANK_STATUS:
                {
                static U032 VblankDummy = 0;
                U032 Value, monitorType, FlatPanelIsDisabled=1, FlatPanelState;
                //
                // Microsoft requested that we twiddle the state of the returned vblank status
                // because if the monitor is off, some DX apps might lockup, waiting for the
                // vblank status to change.  Instead of changing it in the HAL, they asked
                // us to make the driver handle this case.  So if the monitor is off, we
                // twiddle the vblank status bit. Do this ONLY for Win2k.  For any other OS,
                // just behave as if the monitor is always on, since this only seems
                // to be an issue for Win2k.                   
                //

                Value = 0;                                      // Default monitor to always being on
                
#if (_WIN32_WINNT >= 0x0500)
                // Minor Hack - Call back to the miniport to get the 
                // last DPMS state of the monitor
                Value = GetCurrentDPMSState(pDev->DBmpDeviceExtension);
                Value &= 0xC0;
#endif

                // Check for Flat Panel power state
                monitorType = GETMONITORTYPE(pDev, 0);
                if (monitorType==MONITOR_TYPE_FLAT_PANEL)
                {
                    FlatPanelState= REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _DISPEN);     
                    if (FlatPanelState == NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE)
                        FlatPanelIsDisabled = 1;                // Flat panel is off/disabled
                    else
                        FlatPanelIsDisabled = 0;                // Flat panel is on/active                                           
                }
                
                if ( ((monitorType!=MONITOR_TYPE_FLAT_PANEL) && (Value)) || 
                     ((monitorType==MONITOR_TYPE_FLAT_PANEL) && (FlatPanelIsDisabled)) ) // In power saving mode if either is set
                    Value = (VblankDummy ^= 1);                 // just toggle, so we are sure to get both states
                else
                {
                    Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    if (Value == 0) // make sure we don't have false count. NV3 seems to have glitch during display period.
                    {
                        Value = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                    }

                    if (Value == 0)
                        Value = 1;                              // In VBLANK
                    else
                        { // raster count is nonzero

                        if (Value >= (pDev->Framebuffer.HalInfo.VertDisplayWidth-1))
                            Value = 1;                          // In VBLANK
                        else    
                            Value = 0;                          // NOT in VBLANK
                        }
                

                    } // if in power saving mode            

                result = Value;                                // Return state of vblank

                }
                
                break;

            case NV_CFG_GE_STATUS:
                result = REG_RD32(NV_PGRAPH_STATUS);
                break;

            case NV_CFG_CURRENT_SCANLINE:
                result = REG_RD_DRF(_PCRTC, _RASTER, _POSITION);
                break;

            case NV_CFG_BIOS_DEFAULT_TV_TYPE:
                {
                  U032 biostvdefault;
                  dacGetBiosDefaultTVType(pDev,&biostvdefault);
                  result = biostvdefault;
                }
                break;

            //
            // Fields in NvInfo.
            //
            case NV_CFG_MANUFACTURER:
                result = pDev->Chip.HalInfo.Manufacturer;
                break;
            case NV_CFG_ARCHITECTURE:
                result = pDev->Chip.HalInfo.Architecture;
                break;
            case NV_CFG_REVISION:
                result = pDev->Chip.HalInfo.MaskRevision;
                break;
            case NV_CFG_BIOS_REVISION:
                result = pDev->Chip.BiosRevision;
                break;
            case NV_CFG_IMPLEMENTATION:
                result = pDev->Chip.HalInfo.Implementation;
                break;
            case NV_CFG_BUS_TYPE:
                result = pDev->Chip.Bus;
                break;
            case NV_CFG_CRYSTAL_FREQ:
                result = pDev->Chip.HalInfo.CrystalFreq;
                break;
            case NV_CFG_BIOS_OEM_REVISION:
                result = pDev->Chip.BiosOEMRevision;
                break;
#if !defined(_M_IA64) && !defined(__ia64)
            case NV_CFG_ADDRESS_NVADDR:
                result = (U032) nvAddr;
                break;
#endif
            case NV_CFG_ADDRESS:
                result = pDev->Mapping.PhysAddr;
                break;
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                break;
            case NV_CFG_IO_NEEDED:
                result = pDev->Mapping.doIOToFlushCache;
                break;
            case NV_CFG_DEVICE_INSTANCE:
                result = devInstance;
                break;
#if defined(WIN32) && !defined(NTRM)
            case NV_CFG_DEVICE_HANDLE:
                {   
                    PWIN9XHWINFO    pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
                    result = pOsHwInfo->osDeviceHandle;
                }
                break;
#endif
            case NV_CFG_PCI_ID:
                result = pDev->Chip.HalInfo.PCIDeviceID;
                break;            
            case NV_CFG_PCI_SUB_ID:
                result = pDev->Chip.HalInfo.PCISubDeviceID;
                break;            
            case NV_CFG_PROCESSOR_TYPE:
                result = pRmInfo->Processor.Type;
                break;
            case NV_CFG_PROCESSOR_SPEED:
                result = pRmInfo->Processor.Clock;
                break;
            case NV_CFG_GRAPHICS_CAPS:
                result = pDev->Graphics.Capabilities;
                break;
            case NV_CFG_INSTANCE_TOTAL:
                result = pDev->Pram.HalInfo.TotalInstSize;
                break;
            case NV_CFG_INSTANCE_SIZE:
                result = pDev->Pram.FreeInstSize;
                break;
            case NV_CFG_FIFO_COUNT:
                result = pDev->Fifo.HalInfo.Count;
                break;
            case NV_CFG_FIFO_USE_COUNT:
                result = pDev->Fifo.HalInfo.AllocateCount;
                break;
            case NV_CFG_RAM_SIZE_MB:
                result = pDev->Framebuffer.HalInfo.RamSizeMb;
                break;
            case NV_CFG_RAM_SIZE:
                result = pDev->Framebuffer.HalInfo.RamSize;
                break;
            case NV_CFG_RAM_TYPE:
                result = pDev->Framebuffer.HalInfo.RamType;
                break;
            case NV_CFG_AGP_PHYS_BASE:
            {
                if (IsAGPCapable(pDev))        
                    result = pRmInfo->AGP.AGPPhysStart;
                else
                    result = 0;
                break;
            }
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
            {
                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLinearStart;
                else
                    result = 0;
                break;
            }
#endif
            case NV_CFG_AGP_LIMIT:
            {
                // Before returning the AGP limit, update our boot time value
                osUpdateAGPLimit(pDev);

                if (IsAGPCapable(pDev))    
                    result = pRmInfo->AGP.AGPLimit;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_HEAP_FREE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPHeapFree;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FW_ENABLE:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFWEnable;
                else
                    result = 0;
                break;
            }
            case NV_CFG_AGP_FULLSPEED_FW:
            {
                if (IsAGPCapable(pDev))  
                    result = pRmInfo->AGP.AGPFullSpeedFW;
                else
                    result = 0;
                break;
            }
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                break;
            case NV_CFG_PRIMARY_SURFACE_PITCH:
                result = pDev->Dac.DisplayPitch;
                break;
            case NV_CFG_SCREEN_MAX_WIDTH:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1920;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 800;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 800;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxX;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_SCREEN_MAX_HEIGHT:
                {
                    // This value depends on the display type.
                    // We really should read the EDID of the display device to get the max.
                    // For now hard code the values.
                    switch (GETMONITORTYPE(pDev, 0))
                    {
                        case MONITOR_TYPE_VGA:
                            result = 1200;
                            break;
                        case MONITOR_TYPE_NTSC:
                            result = 600;
                            break;
                        case MONITOR_TYPE_PAL:
                            result = 600;
                            break;
                        case MONITOR_TYPE_FLAT_PANEL:
                            {
                                U032 fpMode, fpMaxX, fpMaxY;
                                BOOL fpConnect;
                                BOOL fpNativeSupported;
                                dacGetFlatPanelInfo(pDev,
                                                    0,
                                                    &fpMode, &fpMaxX, &fpMaxY,
                                                    &fpConnect,
                                                    &fpNativeSupported, 
                                                    FALSE /* not from registry */);
                                result = fpMaxY;
                            }
                            break;
                        default:
                            result = 0;
                            rmStatus = RM_ERROR;
                            break;
                    } // switch on MonitorType
                }
                break;
            case NV_CFG_VIDEO_ENCODER_TYPE:
                result = pDev->Dac.EncoderType;
                break;
            case NV_CFG_VIDEO_ENCODER_ID:
                result = pDev->Dac.EncoderID;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                break;
            case NV_CFG_VIDEO_TV_FORMAT:
                result = pDev->Dac.TVStandard;
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                break;
            case NV_CFG_VIDEO_OVERLAY_ALLOWED:
                result = pDev->Video.HalInfo.OverlayAllowed;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_768:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_768;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1280:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1280;
                break;
            case NV_CFG_VIDEO_DOWNSCALE_RATIO_1920:
                result = pDev->Video.HalInfo.OverlayMaxDownscale_1920;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                break;
            case NV_CFG_VBLANK_COUNTER:
                // Assume head 0 for now...
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                break;
            case NV_CFG_PRAM_CURRENT_SIZE:
                result = pDev->Pram.HalInfo.CurrentSize;
                break;
            case NV_CFG_DAC_INPUT_WIDTH:
                result = pDev->Dac.HalInfo.InputWidth;
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.VClk;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                break;
            case NV_CFG_DAC_VPLL_M:
                result = pDev->Dac.HalInfo.VPllM;
                break;
            case NV_CFG_DAC_VPLL_N:
                result = pDev->Dac.HalInfo.VPllN;
                break;
            case NV_CFG_DAC_VPLL_O:
                result = pDev->Dac.HalInfo.VPllO;
                break;
            case NV_CFG_DAC_VPLL_P:
                result = pDev->Dac.HalInfo.VPllP;
                break;
            case NV_CFG_DAC_MPLL_M:
                result = pDev->Dac.HalInfo.MPllM;
                break;
            case NV_CFG_DAC_MPLL_N:
                result = pDev->Dac.HalInfo.MPllN;
                break;
            case NV_CFG_DAC_MPLL_O:
                result = pDev->Dac.HalInfo.MPllO;
                break;
            case NV_CFG_DAC_MPLL_P:
                result = pDev->Dac.HalInfo.MPllP;
                break;
            case NV_CFG_DAC_PCLK_LIMIT_8BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit8bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_16BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit16bpp);
                break;            
            case NV_CFG_DAC_PCLK_LIMIT_32BPP:
                result = GETCRTCHALINFO(pDev, 0, PCLKLimit32bpp);
                break;            
            case NV_CFG_FLAT_PANEL_DITHER_MODE:
            {
                result = 0;
                // indicate there's flat panel dither support and if it's enabled
                if (IsNV11(pDev) && (pDev->Chip.HalInfo.MaskRevision >= MC_MASK_REVISION_B1))
                {
                    result |= NV_CFG_FLAT_PANEL_DITHER_MODE_CAPABLE;

                    // for NV11 B1, dithering only works if the FP is off of head 1
                    if (pDev->Dac.HalInfo.CrtcInfo[1].fpMode == NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER)
                        result |= NV_CFG_FLAT_PANEL_DITHER_MODE_ENABLED;
                }
                break;
            }
#ifdef _WIN32
            case NV_CFG_MAPPING_BUSDEVICEFUNC:
                result = (pDev->Mapping.nvBusDeviceFunc << 8) | REG_RD32(NV_PBUS_PCI_NV_0);
                break;
#endif
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                rmStatus = dacReadTVOutFromRegistry(pDev, Head, &result);
                break;
            }
            case NV_CFG_NUMBER_OF_HEADS:
                result = pDev->Dac.HalInfo.NumCrtcs;
                break;

            case NV_CFG_NUMBER_OF_ACTIVE_HEADS:
            {
                U032 i;
                for (i = 0, result = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                    if (pDev->Dac.CrtcInfo[i].pVidLutCurDac)
                        result++;
                break;
            }
            case NV_CFG_INITIAL_BOOT_HEAD:
                result = pDev->Dac.HalInfo.InitialBootHead;
                break;

            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                *pValue = pDev->Chip.IntrEn0;
                break;

            case NV_CFG_ENABLE_HOTKEY_HANDLING:
                result = pDev->HotKeys.enabled;
                break;
#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to read current debug
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                break;
            }
#endif

            case NV_CFG_GET_ALL_DEVICES:
                result = pDev->Dac.DevicesBitMap;
                break;

            case NV_CFG_GET_BOOT_DEVICES:
                dacDetectDevices(pDev, FALSE, FALSE);
                result = pDev->Dac.BootDevicesBitMap;
                break;
            
            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    // save the result
    *pValue = result;

    return rmStatus;
}

void ActivateInterlacedStereo(
            PHWINFO pDev // Pointer to an nv device
            )
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U008      shadow, cr11, data08;
    U016      LineCompare;
    U032      Head;
    U032      VerticalVisible;
    U032      VerticalBlankStart;
    U032      VerticalRetraceStart;
    U032      VerticalRetraceEnd;
    U032      VerticalBlankEnd;
    U032      VerticalTotal;
    U032      DoubleScannedMode;
    U032      logicalwidth;

    Head = 0;
    LineCompare = 0;
    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    CRTC_RD(NV_CIO_CR_VRE_INDEX, cr11, Head);
    data08 = cr11 & ~0x80;
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08, Head);    // unlock CR0-7
    
    CRTC_RD(0x21, shadow, Head);      // read shadow lock
    data08 = shadow | 0xfa;     // enable HDE, VDE, and 8/9 dot chars too, for NV5.
    CRTC_WR(0x21, data08, Head);

    pVidLutCurDac             = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
    VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                 pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight) - 1;
    VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                 pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;

    VerticalBlankStart        = VerticalVisible;
    VerticalBlankEnd          = VerticalTotal;

    CRTC_WR(NV_CIO_CRE_ILACE__INDEX, (U008)(pVidLutCurDac->HalObject.Dac[0].TotalWidth >> 4), Head);

    VerticalVisible          *= 2;
    VerticalBlankStart       *= 2;
    VerticalRetraceStart     *= 2;
    VerticalRetraceEnd       *= 2;
    VerticalBlankEnd         *= 2;
    VerticalTotal            *= 2;
    VerticalTotal            += 1;

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);

    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LineCompare & BIT(8))              ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LineCompare & BIT(9))              ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 

    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pVidLutCurDac->Image[0].Pitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LineCompare & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_RD(NV_CIO_CRE_RPC0_INDEX, data08, Head);
    data08 = data08 & 0x1F;
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5) | data08, Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);        // grab the current sync status
    data08 = data08 & 0xC0;
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 2048) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 1280)) ? (0x3c | data08) : (0x38 | data08), Head);

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, data08, Head);
    data08 = data08 & 0xF0;
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, data08
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // Restore CR0-7 protection in CR11
    CRTC_WR(NV_CIO_CR_VRE_INDEX, cr11, Head);    
    // Restore shadow lock
    CRTC_WR(0x21, shadow, Head);
    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);
}

void DeactivateInterlacedStereo(
            PHWINFO pDev // Pointer to an nv device
            )
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U008      shadow, cr11, data08;
    U016      LineCompare;
    U032      Head;
    U032      VerticalVisible;
    U032      VerticalBlankStart;
    U032      VerticalRetraceStart;
    U032      VerticalRetraceEnd;
    U032      VerticalBlankEnd;
    U032      VerticalTotal;
    U032      DoubleScannedMode;
    U032      logicalwidth;

    Head = 0;
    LineCompare = 0x377;
    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    CRTC_RD(NV_CIO_CR_VRE_INDEX, cr11, Head);
    data08 = cr11 & ~0x80;
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08, Head);    // unlock CR0-7
    
    CRTC_RD(0x21, shadow, Head);      // read shadow lock
    data08 = shadow | 0xfa;     // enable HDE, VDE, and 8/9 dot chars too, for NV5.
    CRTC_WR(0x21, data08, Head);

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
    VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                 pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight) - 1;
    VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                 pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;

    VerticalBlankStart        = VerticalVisible;
    VerticalBlankEnd          = VerticalTotal;

    CRTC_WR(NV_CIO_CRE_ILACE__INDEX, 0xFF, Head);

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);

    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LineCompare & BIT(8))              ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LineCompare & BIT(9))              ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 

    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pVidLutCurDac->Image[0].Pitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LineCompare & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_RD(NV_CIO_CRE_RPC0_INDEX, data08, Head);
    data08 = data08 & 0x1F;
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5) | data08, Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);        // grab the current sync status
    data08 = data08 & 0xC0;
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 1280)) ? (0x3c | data08) : (0x38 | data08), Head);

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, data08, Head);
    data08 = data08 & 0xF0;
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, data08
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // Restore CR0-7 protection in CR11
    CRTC_WR(NV_CIO_CR_VRE_INDEX, cr11, Head);    
    // Restore shadow lock
    CRTC_WR(0x21, shadow, Head);
    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);
}

//
// Returns the original value
//
RM_STATUS stateConfigSet(
    PHWINFO pDev, // Pointer to an nv device
    U032    index,
    U032    newvalue,
    U032*   pOldvalue
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    RM_STATUS rmStatus = RM_OK;
    U032 result = 0;
    U032 count;

    // 
    // Special case the CRTC access since we're using the lower byte of
    // the index to denote the register we want to modify
    //
    if ((index & 0xF00) == NV_CFG_CRTC)
    {
        U008 lock, crtc_index;
        
        //
        // Save the current CRTC index
        //
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

        lock = UnlockCRTC(pDev, 0);
    
        //
        // Get the register value.
        //
        CRTC_RD((index & 0xFF), result, 0);

        //
        // Update the new value
        //
        CRTC_WR((index & 0xFF), newvalue, 0);
        
        // Relock extended regs
        RestoreLock(pDev, 0, lock);

        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index
    }
    else
    {
        switch (index)
        {
            //
            // Fields in NvInfo.
            //
            case NV_CFG_AGP_PHYS_BASE:
                result = pRmInfo->AGP.AGPPhysStart;
                pRmInfo->AGP.AGPPhysStart = newvalue;
                break;
#ifndef IA64
            case NV_CFG_AGP_LINEAR_BASE:
                result = pRmInfo->AGP.AGPLinearStart;
                pRmInfo->AGP.AGPLinearStart = newvalue;
                break;
#endif
            case NV_CFG_AGP_LIMIT:
                result = pRmInfo->AGP.AGPLimit;
                pRmInfo->AGP.AGPLimit = newvalue;
                break;
            case NV_CFG_SCREEN_WIDTH:
                result = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
                pDev->Framebuffer.HalInfo.HorizDisplayWidth = newvalue;
                break;
            case NV_CFG_SCREEN_HEIGHT:
                result = pDev->Framebuffer.HalInfo.VertDisplayWidth;
                pDev->Framebuffer.HalInfo.VertDisplayWidth = newvalue;
                break;
            case NV_CFG_PIXEL_DEPTH:
                result = pDev->Dac.HalInfo.Depth;
                pDev->Dac.HalInfo.Depth = newvalue;
                break;
            case NV_CFG_VIDEO_DISPLAY_TYPE:
                result = GETDISPLAYTYPE(pDev, 0);
                SETDISPLAYTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_MONITOR_TYPE:
                result = GETMONITORTYPE(pDev, 0);
                SETMONITORTYPE(pDev, 0, newvalue);
                break;
            case NV_CFG_VIDEO_REFRESH_RATE:
                result = pDev->Framebuffer.HalInfo.RefreshRate;
                pDev->Framebuffer.HalInfo.RefreshRate = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_X:
                result = pDev->Framebuffer.Underscan_x;
                pDev->Framebuffer.Underscan_x = newvalue;
                break;
            case NV_CFG_FRAMEBUFFER_UNDERSCAN_Y:
                result = pDev->Framebuffer.Underscan_y;
                pDev->Framebuffer.Underscan_y = newvalue;
                break;
            case NV_CFG_VBLANK_TOGGLE:
                result = pDev->Dac.CrtcInfo[0].VBlankToggle;
                pDev->Dac.CrtcInfo[0].VBlankToggle = newvalue;
                break;
            case NV_CFG_VBLANK_COUNTER:
                result = pDev->Dac.CrtcInfo[0].VBlankCounter;
                pDev->Dac.CrtcInfo[0].VBlankCounter = newvalue;
                break;
            case NV_CFG_DISPLAY_CHANGE_CONFIG:
                rmStatus = dacSetSpanning(pDev, newvalue);
                break;
            case NV_CFG_DISPLAY_CHANGE_START:
                rmStatus = dacSetModeStart(pDev, newvalue);
                break;
            case NV_CFG_DISPLAY_CHANGE_END:
                rmStatus = dacSetModeEnd(pDev, newvalue);
                break;
            case NV_CFG_DAC_PIXEL_CLOCK:
                result = pDev->Dac.HalInfo.PixelClock;
                pDev->Dac.HalInfo.PixelClock = newvalue;
                break;
            case NV_CFG_DAC_MEMORY_CLOCK:
                result = pDev->Dac.HalInfo.MClk;
                pDev->Dac.HalInfo.MClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_MPLL;
                break;
            case NV_CFG_DAC_GRAPHICS_CLOCK:
                result = pDev->Dac.HalInfo.NVClk;
                pDev->Dac.HalInfo.NVClk = newvalue;
                pDev->Dac.UpdateFlags  |= UPDATE_HWINFO_DAC_NVPLL;
                break;
            case NV_CFG_VIDEO_OUTPUT_FORMAT:
            {
                U032 Head = 0;
                dacWriteTVOutToRegistry(pDev, Head, newvalue);
                break;
            }
            case NV_CFG_IRQ:
                result = pDev->Mapping.IntLine;
                pDev->Mapping.IntLine = newvalue; 
                break;
#if !defined(_M_IA64) && !defined(__ia64)
            case NV_CFG_STEREO_CONFIG:
            {
                LPNV_CFG_STEREO_PARAMS pNewStereoSetting = (LPNV_CFG_STEREO_PARAMS)newvalue;
                RM_STATUS              status            = RM_OK;
                // 1. switch stereo on
                // 2. switch stereo off
                result = (U032)pDev->pStereoParams;

                if (pNewStereoSetting && pNewStereoSetting->Flags & (STEREOCFG_EXIT_ADJACENT|STEREOCFG_ENTER_ADJACENT))
                {
                    // Special case for handling interlaced stereo pitch setting
                    if (pNewStereoSetting->Flags == STEREOCFG_ENTER_ADJACENT)
                        pDev->StereoFlags |= STEREO_ADJACENT_EYES;
                    else
                        pDev->StereoFlags &= ~STEREO_ADJACENT_EYES;
                    break;
                } 

                if( pDev->pStereoParams )
                {
                    if(   (pNewStereoSetting)
                        &&(pNewStereoSetting->Flags & STEREOCFG_WS_OGL_API_STEREO)
                       )
                    {

                        if(pNewStereoSetting->Flags & STEREOCFG_STEREO_DISABLE)
                        {
                            VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
                            U032                            PrimaryOffset; 

                            PrimaryOffset = pDev->pStereoParams->FlipOffsets[3][0];

                            // if we run into race conditions along with pageflipping, check code below:
                            // tell interrupt- routine to free pDev->pStereoParams's memory to avoid race condition
                            // pDev->pStereoParams->Flags |= STEREOCFG_FREE_MEMORY 
                            //                            |  STEREOCFG_STEREO_DISABLE;
                            //
                            // wait until vblank - interrupt - routine has free the memory
                            // while( pDev->pStereoParams );
                            osFreeMem(pDev->pStereoParams);
                            pDev->pStereoParams = NULL;

                            //sure we are flipped to the primary left eye.
                            //pDev->pStereoParams->FlipOffsets[3][0] is supposed
                            //to point us to the primary surface offset.
                            vidLutCurDacHalObj.Head = 0;
                            nvHalDacSetStartAddr(pDev, PrimaryOffset, &vidLutCurDacHalObj);
                        }
                        else
                        {
                            // do nothing, because glasses are switched on
                            RM_ASSERT(FALSE);
                        }
                    }
                    else//D3D part:
                    {
                        if(pDev->pStereoParams->Flags & STEREOCFG_STEREO_DISABLE && 
                           pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
                        {
                            if (pDev->pStereoParams->Flags & STEREOCFG_INTERLACED)
                            {
                                //Turning off ASUS stereo
                                DeactivateInterlacedStereo(pDev);
                            } else
                            {
                                VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
                                //Stereo was previously activated. We want to make
                                //sure we are flipped to the primary left eye.
                                //pDev->pStereoParams->FlipOffsets[3][0] is supposed
                                //to point us to the primary surface offset.
                                vidLutCurDacHalObj.Head = 0;
                                nvHalDacSetStartAddr(pDev, pDev->pStereoParams->FlipOffsets[3][0], &vidLutCurDacHalObj);
                            }
                        }
                        pDev->pStereoParams->Flags = pDev->pStereoParams->Flags & ~(STEREOCFG_STEREO_DISABLE 
                                                     | STEREOCFG_STEREOACTIVATED);
                        if ((pDev->pStereoParams = (LPNV_CFG_STEREO_PARAMS)newvalue))
                            goto CheckIfStereoActivation;
                    }
                }
                else
                {
                    // activate stereo glasses if desired
                    if(   (pNewStereoSetting)
                        &&(pNewStereoSetting->Flags & STEREOCFG_WS_OGL_API_STEREO)
                        )
                    {
                        if(pNewStereoSetting->Flags & STEREOCFG_STEREO_INITIALIZE)
                        {
                            LPNV_CFG_STEREO_PARAMS pNewAllocatedStereoSetting;

                            status = osAllocMem( (VOID **)&pNewAllocatedStereoSetting, sizeof(NV_CFG_STEREO_PARAMS) );

                            if(RM_SUCCESS(status))
                            {
                                osMemCopy((U008*)pNewAllocatedStereoSetting, (U008*)newvalue, sizeof(NV_CFG_STEREO_PARAMS)); 
                                pNewAllocatedStereoSetting->Flags |= STEREOCFG_STEREOACTIVATED;

                                if( pNewAllocatedStereoSetting->Flags & STEREOCFG_WS_OGL_API_STEREO )
                                {
                                    // trigger flipping between buffer [1][0] and [1][1]
                                    pNewAllocatedStereoSetting->FlipOffsets[3][0] = pNewAllocatedStereoSetting->FlipOffsets[1][0];
                                }

                                // let vblank-switchroutine access stereoparams
                                pDev->pStereoParams = pNewAllocatedStereoSetting;
                            }
                        }
                        else
                        {
                            // do nothing here: glasses are disabled, so only initialize make sense
                            RM_ASSERT(FALSE);
                        }
                    }
                    else// old code(D3D)
                    {
                        pDev->pStereoParams = (LPNV_CFG_STEREO_PARAMS)newvalue;
CheckIfStereoActivation:
                        if (pDev->pStereoParams->Flags & STEREOCFG_INTERLACED)
                        {
                            if (pDev->pStereoParams->Flags & STEREOCFG_STEREO_INITIALIZE)
                                ActivateInterlacedStereo(pDev);
                        }
                        if (pDev->pStereoParams->Flags & STEREOCFG_STEREO_INITIALIZE)
                        {
                            pDev->pStereoParams->Flags = (pDev->pStereoParams->Flags & ~STEREOCFG_STEREO_INITIALIZE)
                                                         | STEREOCFG_STEREOACTIVATED;
                        } else
                        {
                            pDev->pStereoParams->Flags = pDev->pStereoParams->Flags & ~STEREOCFG_STEREOACTIVATED; 
                        }
                    }
                }
                break;
            }
#endif

            case NV_CFG_INTERRUPTS_ENABLED_STATE:
                result = pDev->Chip.IntrEn0;
                pDev->Chip.IntrEn0 = newvalue;
                RmEnableInterrupts(pDev);           // will just slam in IntrEn0
                break;

            case NV_CFG_ENABLE_HOTKEY_HANDLING:
                result = pDev->HotKeys.enabled;
                if (pDev->Power.MobileOperation) {
                    if (newvalue)
                        EnableMobileHotkeyHandling(pDev);  // 1 == resman handles hotkeys
                    else
                        DisableMobileHotkeyHandling(pDev); // 0 == bios handles hotkeys
                }
                break;
                
            case NV_CFG_ENABLE_VGA_MODE:
                result = pDev->Vga.Enabled;
                pDev->Vga.Enabled = newvalue; 
                break;
                
            //workaround for P51 limitations    
            case NV_CFG_TURNON_FLAT_PANEL:
                for(count=0;count<pDev->Dac.HalInfo.NumCrtcs;count++)
                {
                    if(GETDISPLAYTYPE(pDev,count)==DISPLAY_TYPE_FLAT_PANEL)
                    {
                        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE,count);
                    }
                }
                break;
                
            case NV_CFG_SHUTOFF_FLAT_PANEL:
                for(count=0;count<pDev->Dac.HalInfo.NumCrtcs;count++)
                {
                    if(GETDISPLAYTYPE(pDev,count)==DISPLAY_TYPE_FLAT_PANEL)
                    {
                        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK,count);
                    }
                }
                break;

#ifdef RM_STATS
            case NV_STAT_INTERVAL_NSEC_LO:
                result = pDev->Statistics.UpdateLo;
                pDev->Statistics.UpdateLo = newvalue;
                break;
            case NV_STAT_INTERVAL_NSEC_HI:
                result = pDev->Statistics.UpdateHi;
                pDev->Statistics.UpdateHi = newvalue;
                break;
            case NV_STAT_FIFO_EXCEPTIONS:
                result = pDev->Statistics.FifoExceptionCount;
                pDev->Statistics.FifoExceptionCount = newvalue;
                break;
            case NV_STAT_FRAMEBUFFER_EXCEPTIONS:
                result = pDev->Statistics.FramebufferExceptionCount;
                pDev->Statistics.FramebufferExceptionCount = newvalue;
                break;
            case NV_STAT_GRAPHICS_EXCEPTIONS:
                result = pDev->Statistics.GraphicsExceptionCount;
                pDev->Statistics.GraphicsExceptionCount = newvalue;
                break;
            case NV_STAT_TIMER_EXCEPTIONS:
                result = pDev->Statistics.TimerExceptionCount;
                pDev->Statistics.TimerExceptionCount = newvalue;
                break;
            case NV_STAT_CHIP_EXCEPTIONS:
                result = pDev->Statistics.TotalExceptionCount;
                pDev->Statistics.TotalExceptionCount = newvalue;
                break;
            case NV_STAT_MEM_ALLOCATED:
                result = pDev->Statistics.MemAlloced;
                pDev->Statistics.MemAlloced = newvalue;
                break;
            case NV_STAT_MEM_LOCKED:
                result = pDev->Statistics.MemLocked;
                pDev->Statistics.MemLocked = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_LO:
                result = pDev->Statistics.ExecTimeLo;
                pDev->Statistics.ExecTimeLo = newvalue;
                break;
            case NV_STAT_EXEC_NSEC_HI:
                result = pDev->Statistics.ExecTimeHi;
                pDev->Statistics.ExecTimeHi = newvalue;
                break;
            case NV_STAT_INT_NSEC_LO:
                result = pDev->Statistics.IntTimeLo;
                pDev->Statistics.IntTimeLo = newvalue;
                break;
            case NV_STAT_INT_NSEC_HI:
                result = pDev->Statistics.IntTimeHi;
                pDev->Statistics.IntTimeHi = newvalue;
                break;
#endif

#if defined(DEBUG) && ( defined(UNIX) || defined(MACOS) )
            // debug only hack to set current debug level
            case NV_CFG_DEBUG_LEVEL:
            {
                extern int cur_debuglevel;
                result = cur_debuglevel;
                cur_debuglevel = newvalue;
                break;
            }
#endif

            default:
                result = 0;
                rmStatus = RM_ERROR;
                break;
        }
    }

    *pOldvalue = result;

    return rmStatus; 
}


//
// These macros do common error checking for the config items
//

#define VERIFY_PARAM_SIZE(pDev, index, structsize, paramsize) \
    do {                                                \
        if ((paramsize) < (structsize))                 \
        { \
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: bad size in cfg call ", (paramsize)); \
            status = CONFIG_GETEX_BAD_PARAM;            \
            goto done;                                  \
        }                                               \
    } while (0)

#define VERIFY_HEAD(pDev, Head) \
    do {                                                \
        if ((Head) >= DACHALINFO(pDev, NumCrtcs))         \
        {                                               \
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, "NVRM: bad head# in cfg call ", (Head)); \
            status = CONFIG_GETEX_BAD_PARAM;            \
            goto done;                                  \
        }                                               \
    } while(0)

RM_STATUS stateConfigGetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: getEx index ", index);

    switch (index)
    {
        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;  // for legacy compatibility, there is no parameter passed 
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            if (Params->GetDefault)
            {
                dacGetMonitorDefaultPosition(pDev, 
                                             Head,
                                             &Params->HBlankStart, &Params->HBlankEnd,
                                             &Params->VBlankStart, &Params->VBlankEnd,
                                             &Params->HRetraceStart, &Params->HRetraceEnd,
                                             &Params->VRetraceStart, &Params->VRetraceEnd);
                status = RM_OK;
            }
            else
            {
                U032 cbLen;
                // Get the H & V Blank start and end. These values do not change after
                // modeset. The H & V retrace start and end may have been changed.
                // But get the default values first.
                dacGetMonitorDefaultPosition(pDev,
                                             Head,
                                             &Params->HBlankStart, &Params->HBlankEnd,
                                             &Params->VBlankStart, &Params->VBlankEnd,
                                             &Params->HRetraceStart, &Params->HRetraceEnd,
                                             &Params->VRetraceStart, &Params->VRetraceEnd);
                // Read the registry to get any updates to the default H & V retrace
                // start and end.
                cbLen = 4 * sizeof(U032);
                status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                            TRUE,  // isMonitor
                                                            (U008 *) &(Params->HRetraceStart),
                                                            &cbLen);
                // If there is an error, we don't have to do anything. The default values have already been 
                // saved in Params.
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV:
        {
            U032 Head = 0;
            U032 cbLen;
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;
                
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            // if default, get position from tables, else get from registry
            if (Params->Default)
            {
                dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
            }
            else
            {
                NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;

                //
                // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
                // params struct format that lives in the registry (currently, you can have a
                // MULTI or a non-MULTI version, which is a problem).
                //
                // Until we remove the non-MULTI versions of these calls, independent of how
                // we're called we'll read/write the registry with the MULTI version of struct.
                // Which means (temporarily), we need to perform a cast in the non-MULTI case.

                // Read the registry to get any updates to the default H & V offset
                cbLen = sizeof(MultiParams);
                status = dacReadTVDesktopPositionFromRegistry(pDev, Head,
                                                        (U008 *) &MultiParams,
                                                        &cbLen);

                // Make sure data is valid for the current encoder.
                if (MultiParams.Encoder_ID != pDev->Dac.EncoderType)
                    status = RM_ERROR;                  
                if (status) // if reg read failed, return defaults
                    dacGetDefaultTVPosition(pDev, Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                else {
                    // succeeded, convert MULTI to non-MULTI version
                    osMemCopy((U008*)Params, (U008*)&MultiParams.Encoder_ID, paramSize);
                }

                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO:
        {
            NV_CFGEX_TV_ENCODER_PARAMS *Params;

            Params = (NV_CFGEX_TV_ENCODER_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            Params->EncoderType = pDev->Dac.EncoderType;
            Params->EncoderID = pDev->Dac.EncoderID;
            if (dacTVConnectStatus(pDev, 0))
                Params->TVConnected = TV_CONNECTED;
            else
                Params->TVConnected = TV_NOT_CONNECTED;
            status = RM_OK;
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *Params;
            U032 Head = 0;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            if(!IsNV5orBetter(pDev))
                Params->FlatPanelConnected = FALSE;
            else
                status = dacGetFlatPanelInfo(pDev, Head,
                                             &Params->FlatPanelMode,
                                             &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                             &Params->FlatPanelConnected,
                                             &Params->FlatPanelNativeSupported,
                                             FALSE /* not from registry */);
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
        	NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
        	Params=(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	if(paramSize!=sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		status=CONFIG_GETEX_BAD_PARAM;
        	}
        	else
        	{
        		status = dacGetFlatPanelBrightness(pDev, Params->Head, &(Params->PercentRelativeBrightness),&(Params->PWMControllerEnable),&(Params->InverterCurrentMode));
        	}
        }
        break;

        case NV_CFGEX_POWER_MIZER:
        {
            NV_CFGEX_POWER_MIZER_PARAMS *Params;
        	Params = (NV_CFGEX_POWER_MIZER_PARAMS *)paramStructPtr;

        	if (paramSize != sizeof(NV_CFGEX_POWER_MIZER_PARAMS))
        	{
        		status = CONFIG_GETEX_BAD_PARAM;
        	}
        	else
        	{
                if (pDev->Power.MobileOperation) {
                    Params->Current = pDev->Power.PowerMizerLevel;
                    Params->Default = pDev->Power.PowerMizerDefault;
        		    status = CONFIG_GETEX_OK;
                } else {
            		status = CONFIG_GETEX_BAD_PARAM;
                }
        	}
            
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO:
        {
            NV_CFGEX_GET_MONITOR_INFO_PARAMS *Params;
            U032 Head = 0;

            Params = (NV_CFGEX_GET_MONITOR_INFO_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            status = dacGetMonitorInfo(pDev, Head, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_GET_EDID:
        {
#ifndef IKOS
            NV_CFGEX_GET_EDID_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            U032 Head = 0;
            Params = (NV_CFGEX_GET_EDID_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            REG_WR08(NV_PRMCIO_CRX__COLOR, 0x571F & 0xFF); 
            REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x571F >> 8) & 0xFF);
            ////OEMEnableExtensions();          // Unlock the registers before DDC
            status = EDIDRead(pDev, Head, Params->displayType);
            REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
            REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
            ////OEMDisableExtensions();         // Lock the registers
            if ( status == RM_OK ) {
                // status = EDIDCopy(pDev, Params->edidBuffer, Params->bufferLength, (U032) 0);
                if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                    RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                    RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, Head)) &&
                    RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                    RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                {
                    // all done 
                }
                if (edidBuffer)
                    osFreeMem(edidBuffer);
            }
            else {
                status = CONFIG_GETEX_BAD_READ;
            }
#else
            // just for IKOS builds return quickly
            status = CONFIG_GETEX_BAD_READ;
#endif
        }
        break;
        
        case NV_CFGEX_GET_LOGICAL_DEV_EDID_BLOCK:
        {
            NV_CFGEX_GET_LOGICAL_DEV_EDID_BLOCK_PARAMS * Params;
            unsigned char * TemporaryEdidBuffer;
            
            Params = (NV_CFGEX_GET_LOGICAL_DEV_EDID_BLOCK_PARAMS *)paramStructPtr;
            
            if(paramSize!=sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_BLOCK_PARAMS))
            {
                status=CONFIG_GETEX_BAD_PARAM;
            }
            else
            {               
                //allocate a edid buffer of proper size
                status = osAllocMem((VOID **) &TemporaryEdidBuffer, (U032) 128);
                
                if(RM_SUCCESS(status))
                {
                    //do the block read
                    status = ReadAnyEdidBlock(pDev, Params->Head, Params->DisplayType, Params->ByteAddress, TemporaryEdidBuffer);
                }
                
                if(RM_SUCCESS(status))
                {
                    //copy the buffer back into user space
                    //we truncate here in case user didn't specify a long enough buffer for the entire block they requested
                    status = osCopyOut((U008*) TemporaryEdidBuffer, (U008*) Params->EdidBuffer, 128);
                }
                
                //wipe out temp buffer
                if (TemporaryEdidBuffer)
                {
			        osFreeMem(TemporaryEdidBuffer);
			    }
            }
                
        }
        
        break;

        case NV_CFGEX_GET_BIOS:
        {
            NV_CFGEX_GET_BIOS_PARAMS *Params;
            U008  *biosBuffer = (U008 *)NULL;
            U032 bufferLength;

            Params = (NV_CFGEX_GET_BIOS_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            // Get the size we need to recover
            osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032));
            status = osAllocMem((VOID **)&biosBuffer, (U032)bufferLength);
            if (RM_SUCCESS(status))
            {
                U032 i;
                // Pull the image byte-by-byte from the ghosted instance copy
                for (i=0; i<bufferLength;i++)
                    biosBuffer[i] = (U008)BIOS_RD08(i);
                
                // Copy the buffers back into the param structures (user buffer)
                osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032));
                osCopyOut((U008*) biosBuffer, (U008*) Params->biosBuffer, (U032) bufferLength);
            }
            
            if (biosBuffer)
                osFreeMem(biosBuffer);
            
            if (RM_SUCCESS(status))
                status = CONFIG_GETEX_OK;
            else
                status = CONFIG_GETEX_BAD_READ;
            
        }
        break;

        case NV_CFGEX_GET_SURFACE_PITCH:
        {
            NV_CFGEX_GET_SURFACE_PITCH_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_PITCH_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            nvHalFbGetSurfacePitch(pDev, Params->Width, Params->Depth, &Params->Pitch);

            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_GET_SURFACE_DIMENSIONS:
        {
            NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *Params;
            Params = (NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            nvHalFbGetSurfaceDimensions(pDev,
                                        Params->Width,
                                        Params->Height,
                                        Params->Depth,
                                        &Params->Pitch,
                                        &Params->Size);
            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_GET_SUPPORTED_CLASSES:
        {
            NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *Params;
            Params = (NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            //
            // Return numClasses, if the classBuffer pointer is NULL. Otherwise, fill in
            // the classBuffer if it's big enough to hold all the values.
            //
            if (Params->classBuffer == NULL) {
                Params->numClasses = pDev->classDB.numClasses;
                status = CONFIG_GETEX_OK;
            } else {
                if (Params->numClasses != pDev->classDB.numClasses)
                    status = CONFIG_GETEX_BAD_PARAM;
                else {
                    U032 i;
                    PCLASS classDB = (PCLASS)pDev->classDB.pClasses;
                    //
                    // Fill in classBuffer with the supported (common/chip specific) classes.
                    for (i = 0; i < pDev->classDB.numClasses; i++)
                        osCopyOut((U008*) &classDB[i].Type, (U008*) &Params->classBuffer[i], sizeof(U032));
                    
                    status = CONFIG_GETEX_OK;
                }
            }
        }
        break;

        //
        // The following is a 32/64 bit neutral version of the above call.
        // This will eventually supercede the above but unfortunately using
        // this globally mysteriously causes screen corruption with D3D apps.
        //
        case NV_CFGEX_GET_SUPPORTED_CLASSES64:
        {
            NV_CFGEX_GET_SUPPORTED_CLASSES64_PARAMS *Params;
            Params = (NV_CFGEX_GET_SUPPORTED_CLASSES64_PARAMS *)paramStructPtr;
            if (paramSize < sizeof(NV_CFGEX_GET_SUPPORTED_CLASSES64_PARAMS))
                // Wrong param size.
                status = CONFIG_GETEX_BAD_PARAM;
            else {
                //
                // Return numClasses, if the classBuffer pointer is NULL. Otherwise, fill in
                // the classBuffer if it's big enough to hold all the values.
                //
                if (NvP64_VALUE(Params->classBuffer) == (NvP64_VALUE_T)NULL) {
                    Params->numClasses = pDev->classDB.numClasses;
                    status = CONFIG_GETEX_OK;
                } else {
                    if (Params->numClasses != pDev->classDB.numClasses)
                        status = CONFIG_GETEX_BAD_PARAM;
                    else {
                        U032 i;
                        U032 *cbp;
                        PCLASS classDB = (PCLASS)pDev->classDB.pClasses;
                        //
                        // Fill in classBuffer with the supported (common/chip specific) classes.

                        cbp = (U032*)NvP64_VALUE(Params->classBuffer);
                        for (i = 0; i < pDev->classDB.numClasses; i++)
                            osCopyOut((U008*) &classDB[i].Type, (U008*) cbp++, sizeof(U032));
                        status = CONFIG_GETEX_OK;
                    }
                }
            }
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE:
        {
            U032 Head = 0;
            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_PARAMS *)paramStructPtr;
            
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            Params->Type = GETDISPLAYTYPE(pDev, Head);
            if (Params->Type == DISPLAY_TYPE_TV)
                Params->TVType = pDev->Dac.TVStandard;
            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_GET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;
            
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            Params->Type = GETDISPLAYTYPE(pDev, Params->Head);
            if (Params->Type == DISPLAY_TYPE_TV)
                Params->TVType = pDev->Dac.TVStandard;
            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_GET_REFRESH_INFO:
        {
            NV_CFGEX_GET_REFRESH_INFO_PARAMS *Params;
            Params = (NV_CFGEX_GET_REFRESH_INFO_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            if (pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac == NULL) {
                Params->ulRefreshRate = 0;
                status = RM_OK;
            } else {
                PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
                pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac;
                Params->ulRefreshRate = pVidLutCurDac->RefreshRate;
                status = RM_OK;
            }

            // Params->ulState = pDev->Framebuffer.RefreshRateType;
        }
        break;

        case NV_CFGEX_GET_AGP_CONFIGURATION:
        {
            PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;
            VOID *handle;
            NV_CFGEX_GET_AGP_CONFIGURATION_PARAMS *Params;
            Params = (NV_CFGEX_GET_AGP_CONFIGURATION_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            // don't have enough info about the Northbridge device
            if ((pRmInfo->AGP.NBAddr.valid == FALSE) || !pRmInfo->AGP.AGPCapPtr) {
                Params->NB_VendorID = Params->NB_DeviceID = 0xFFFF;
                break;
            }

            handle = osPciInitHandle(pRmInfo->AGP.NBAddr.bus,
                                     pRmInfo->AGP.NBAddr.device,
                                     pRmInfo->AGP.NBAddr.func,
                                     &Params->NB_VendorID,
                                     &Params->NB_DeviceID);
            if (!handle) {
                Params->NB_VendorID = Params->NB_DeviceID = 0xFFFF;
                break;
            }

            // get AGP status/command for the Northbridge device
            Params->u_NB_Status.As_ULong  = osPciReadDword(handle, pRmInfo->AGP.AGPCapPtr+4);
            Params->u_NB_Command.As_ULong = osPciReadDword(handle, pRmInfo->AGP.AGPCapPtr+8);

            // set AGP status/command for the NV device
            Params->u_NV_Status.As_ULong  = REG_RD32(NV_PBUS_PCI_NV_18);
            Params->u_NV_Command.As_ULong = REG_RD32(NV_PBUS_PCI_NV_19);
        }
        break;

        case NV_CFGEX_GET_AGP_OFFSET:
        {
            NV_CFGEX_GET_AGP_OFFSET_PARAMS *Params;
            Params = (NV_CFGEX_GET_AGP_OFFSET_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            Params->offset = 0xFFFFFFFF;        // init to unsigned -1

            status = osVirtualToPhysicalAddr(Params->linaddr, &Params->physaddr);
            if (status == RM_OK)
            {
                // check if it's in the AGP aperture, if so, return the offset
                if (
                    Params->physaddr >= (VOID*)((NV_UINTPTR_T)(pRmInfo->AGP.AGPPhysStart)) &&
                    (U008*)Params->physaddr <= (U008*)((NV_UINTPTR_T)(pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit))
            )
                {
                    Params->offset = (U032)((U008*)Params->physaddr - (U008*)((NV_UINTPTR_T)pRmInfo->AGP.AGPPhysStart));
                    status = RM_OK;
                }
                else
                    status = CONFIG_GETEX_BAD_PARAM;        // not an AGP aperture address
            }
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            Params->linaddr = (void *)pRmInfo->AGP.AGPLinearStart;
            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_ADDRESS_NVADDR:
        {
            NV_CFGEX_ADDRESS_NVADDR_PARAMS *Params;
            Params = (NV_CFGEX_ADDRESS_NVADDR_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            Params->nvaddr = nvAddr;
            status = CONFIG_GETEX_OK;
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[1]   = {0};
            U032                         Out[1]  = {0};

            // Copy the data in (1 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 1*sizeof(U032));

            // Get the data.
            status = CONFIG_GETEX_BAD_PARAM;

            if (paramSize == sizeof(NV_CFGEX_RESERVED_PROPERTY))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_RD08:
                        Out[0] = REG_RD08(In[0]);
                        break;

                    case PROPERTY_REG_RD16:
                        Out[0] = REG_RD16(In[0]);
                        break;

                    case PROPERTY_REG_RD32:
                        Out[0] = REG_RD32(In[0]);
                        break;

                    case PROPERTY_FB_RD08:
                        Out[0] = FB_RD08(In[0]);
                        break;

                    case PROPERTY_FB_RD16:
                        Out[0] = FB_RD16(In[0]);
                        break;

                    case PROPERTY_FB_RD32:
                        Out[0] = FB_RD32(In[0]);
                        break;

                    default:
                        status = CONFIG_GETEX_BAD_PARAM;
                        break;
                }
            }

            // Copy the data out (1 parameter).
            osCopyOut((U008*)Out, (U008*)pParams->Out, 1*sizeof(U032));
        }
        break;

#if 1 
        case NV_CFGEX_GET_LOGICAL_DEV_EDID:
        {
            U008 lock;        
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *Params;
            U032 Head, edidversion, edidrevision;
            //U032 bufferLength, i;
            Params = (NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            status = dacGetDisplayInfo(pDev, Params->displayMap, &Head, 0, 0, 0);
            if (status != RM_OK)
            {
                status = CONFIG_GETEX_BAD_READ;
                break;
            }

            lock = UnlockCRTC(pDev, Head);
            status = edidReadDevEDID(pDev, Params->displayMap, Params->edidBuffer);
            RestoreLock(pDev, Head, lock);

            if (status != RM_OK)
            {
                status = CONFIG_GETEX_BAD_READ;
                break;
            }

            status = edidLogicalEDIDIsValid(&Params->edidBuffer, &edidversion, &edidrevision);

            if (status != TRUE)
            {
                status = CONFIG_GETEX_BAD_READ;
                break;
            }
            else 
            {
                status = RM_OK;
            }
            
            if (edidversion == 1)
            {
                *Params->bufferLength = EDID_V1_SIZE;
            }
            else if (edidversion == 2)
            {
                *Params->bufferLength = EDID_V2_SIZE;
            }
            break;
        }

        //
        // Multi-Head Info. These take logical Head number as a parameter
        //
        case NV_CFGEX_GET_EDID_MULTI:
        {
            U008 lock;        
            NV_CFGEX_GET_EDID_MULTI_PARAMS *Params;
            VOID  *edidBuffer = (VOID *) 0;
            U032 bufferLength;
            Params = (NV_CFGEX_GET_EDID_MULTI_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            lock = UnlockCRTC(pDev, Params->Head);
            status = EDIDRead(pDev, Params->Head, Params->displayType);
            RestoreLock(pDev, Params->Head, lock);
            if ( status == RM_OK )
            {
                if (RM_SUCCESS(status = osCopyIn((U008*) Params->bufferLength, (U008*) &bufferLength, sizeof(U032))) &&
                    RM_SUCCESS(status = osAllocMem((VOID **) &edidBuffer, (U032) bufferLength)) &&
                    RM_SUCCESS(status = EDIDCopy(pDev, edidBuffer, &bufferLength, (U032) Params->Head)) &&
                    RM_SUCCESS(status = osCopyOut((U008*) &bufferLength, (U008*) Params->bufferLength, sizeof(U032))) &&
                    RM_SUCCESS(status = osCopyOut((U008*) edidBuffer, (U008*) Params->edidBuffer, (U032) bufferLength)))
                {
                    // all done 
                    if (edidBuffer)
                        osFreeMem(edidBuffer);
                }
            }
            else {
                status = CONFIG_GETEX_BAD_READ;
            }
        }
        break;
        
        case NV_CFGEX_VIDEO_ENCODER_TYPE:
        {
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS *)paramStructPtr;
            
            Params->EncoderType = pDev->Dac.EncoderType;
        }
        break;
        case NV_CFGEX_VIDEO_ENCODER_ID:
        {
            NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *Params;
            Params = (NV_CFGEX_VIDEO_ENCODER_ID_PARAMS *)paramStructPtr;

            Params->EncoderID = pDev->Dac.EncoderID;
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_8BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            VERIFY_HEAD(pDev, Params->Head);
            Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit8bpp);    
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_16BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            VERIFY_HEAD(pDev, Params->Head);
            Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit16bpp);   
        }
        break;
        case NV_CFGEX_DAC_PCLK_LIMIT_32BPP:
        {
            NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *Params;
            Params = (NV_CFGEX_DAC_PCLK_LIMIT_PARAMS *)paramStructPtr;
            
            VERIFY_HEAD(pDev, Params->Head);
            Params->pclkLimit = GETCRTCHALINFO(pDev, Params->Head, PCLKLimit32bpp);   
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            if (Params->GetDefault)
            {
                dacGetMonitorDefaultPosition(pDev, 
                                             Params->Head,
                                             &Params->HBlankStart, &Params->HBlankEnd,
                                             &Params->VBlankStart, &Params->VBlankEnd,
                                             &Params->HRetraceStart, &Params->HRetraceEnd,
                                             &Params->VRetraceStart, &Params->VRetraceEnd);
                status = RM_OK;
            }
            else
            {
                U032 cbLen;
                // Get the H & V Blank start and end. These values do not change after
                // modeset. The H & V retrace start and end may have been changed.
                // But get the default values first.
                dacGetMonitorDefaultPosition(pDev,
                                             Params->Head,
                                             &Params->HBlankStart, &Params->HBlankEnd,
                                             &Params->VBlankStart, &Params->VBlankEnd,
                                             &Params->HRetraceStart, &Params->HRetraceEnd,
                                             &Params->VRetraceStart, &Params->VRetraceEnd);
                // Read the registry to get any updates to the default H & V retrace
                // start and end.
                cbLen = 4 * sizeof(U032);
                status = dacReadDesktopPositionFromRegistry(pDev, Params->Head,
                                                            TRUE,  // isMonitor
                                                            (U008 *) &(Params->HRetraceStart),
                                                            &cbLen);
                // If there is an error, we don't have to do anything. The default values have already been 
                // saved in Params.
            }
        }
        break;

        case NV_CFGEX_GET_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;
            U032 cbLen;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

                
            // if default, get position from tables, else get from registry
            if (Params->Default)
            {
                dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
            }
            else
            {
                // Read the registry to get any updates to the default H & V offset
                cbLen = sizeof(*Params);
                status = dacReadTVDesktopPositionFromRegistry(pDev, Params->Head,
                                                              (U008 *) Params,
                                                              &cbLen);
                // Make sure data is valid for the current encoder.
                if (Params->Encoder_ID != pDev->Dac.EncoderType)
                    status = RM_ERROR;                  
                if (status) // if reg read failed, return defaults
                    dacGetDefaultTVPosition(pDev, Params->Head, Params->Encoder_ID, Params->Default, (U032 *)&Params->u);
                status = RM_OK;
                }
        }
        break;

        case NV_CFGEX_GET_TV_ENCODER_INFO_MULTI:
        {
            NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            Params->EncoderType = pDev->Dac.EncoderType;
            Params->EncoderID = pDev->Dac.EncoderID;
            if (dacTVConnectStatus(pDev, Params->Head))
                Params->TVConnected = TV_CONNECTED;
            else
                Params->TVConnected = TV_NOT_CONNECTED;
            status = RM_OK;
        }
        break;

        case NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);
            if(!IsNV5orBetter(pDev))
                Params->FlatPanelConnected = FALSE;
            else
            {
                //
                // CONTROL PANEL WORKAROUND FOR MOBILE
                //
                // On mobile the control panel will be expecting the DFP to be on the
                // virtual primary head (0), yet in reality the physical head is always 1.
                // He might call in asking about head0, so route it to head1.
                //
                if (pDev->Power.MobileOperation)
                    Params->Head = 1;
                status = dacGetFlatPanelInfo(pDev, Params->Head, &Params->FlatPanelMode,
                                             &Params->FlatPanelSizeX, &Params->FlatPanelSizeY,
                                             &Params->FlatPanelConnected,
                                             &Params->FlatPanelNativeSupported,
                                             FALSE /* not from registry */);
            }
        }
        break;

        case NV_CFGEX_GET_MONITOR_INFO_MULTI:
        {
            NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacGetMonitorInfo(pDev, Params->Head, &Params->MonitorConnected);
        }
        break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacGetColorSaturationBoost(pDev, Params->Head, &Params->boostValue);
        }
        break;

        case NV_CFGEX_CRTC_TIMING_MULTI:
        {
            NV_CFGEX_CRTC_TIMING_PARAMS *Params;
            Params = (NV_CFGEX_CRTC_TIMING_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacGetCRTCTiming(pDev, Params->Head, Params);
        }
        break;

#endif  // multi-head      

        case NV_CFGEX_CURRENT_SCANLINE_MULTI:
        {
            NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            Params->RasterPosition = DAC_REG_RD_DRF(_PCRTC, _RASTER, _POSITION, Params->Head);
        }
        break;

        case NV_CFGEX_VBLANK_COUNTER_MULTI:
        {
            NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_VBLANK_COUNTER_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            Params->VBlankCounter = pDev->Dac.CrtcInfo[Params->Head].VBlankCounter;
        }
        break;

        case NV_CFGEX_VBLANK_ENABLED:
        {
            NV_CFGEX_VBLANK_ENABLED_PARAMS *Params;
            Params = (NV_CFGEX_VBLANK_ENABLED_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            Params->Enabled = (pDev->Dac.CrtcInfo[Params->Head].StateFlags &
                                   DAC_CRTCINFO_VBLANK_ENABLED) != 0;
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            dacGetSyncState(pDev, Params->Head, &Params->Hsync, &Params->Vsync);
            // paper over a bit of ambiguity :-)
            Params->oldHsync = Params->Hsync;
            Params->oldVsync = Params->Vsync;
        }
        break;

        case NV_CFGEX_PRIMARY_INFO:
        {
            NV_CFGEX_PRIMARY_INFO_PARAMS *Params;
            Params = (NV_CFGEX_PRIMARY_INFO_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            if ( ! pDev->Framebuffer.PrimarySurfaceAlloced)
            {
                status = CONFIG_GETEX_BAD_READ;
            }
            else
            {  
                Params->Pitch = pDev->Dac.DisplayPitch;
                Params->Offset = pDev->Framebuffer.HalInfo.Start[Params->Head];
            }
        }
        break;

        //Interface for control panel to read pending mobile hotkey (Fn+x) events.
        case NV_CFGEX_GET_HOTKEY_EVENT:
        {
            NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *Params;
            Params = (NV_CFGEX_GET_HOTKEY_EVENT_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            if (!pDev->Power.MobileOperation) {
                //If there are no hotkeys to support...
                Params->event = NV_HOTKEY_EVENT_NOT_SUPPORTED;
                Params->status = 0;
            } else if (pDev->HotKeys.queueHead == pDev->HotKeys.queueTail) {
                //If no hotkey events are pending...
                Params->event = NV_HOTKEY_EVENT_NONE_PENDING;
                Params->status = 0;
            } else {
                //If there are events in the queue, report the next one...
                Params->event = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].event;
                Params->status = pDev->HotKeys.Queue[pDev->HotKeys.queueTail].status;
                pDev->HotKeys.queueTail = (pDev->HotKeys.queueTail + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;
            }
        }
        break;

        case NV_CFGEX_GET_DEVICE_MAPPINGS:
        {
            NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *Params;

            //
            // This call is for use by the NVDE debugger.
            //
            if (paramSize < sizeof(NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS))
                // Wrong param size.
                status = CONFIG_SETEX_BAD_PARAM;
            else
            {
                Params = (NV_CFGEX_GET_DEVICE_MAPPINGS_PARAMS *) paramStructPtr;
                Params->nvVirtAddr = (void *)pDev->DBnvAddr;
                Params->fbVirtAddr = (void *)pDev->DBfbAddr;
                Params->nvPhysAddr = (void *)((NV_UINTPTR_T)pDev->Mapping.PhysAddr);
                Params->fbPhysAddr = (void *)((NV_UINTPTR_T)pDev->Mapping.PhysFbAddr);

                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_CHECK_CONNECTED_DEVICES:
        {
            U032        *pDevBitMap = (U032 *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!*pDevBitMap ||
                ((*pDevBitMap ^ pDev->Dac.DevicesBitMap) & *pDevBitMap)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            dacDevicesConnectStatus(pDev, pDevBitMap, pDev->Dac.DevicesNoCheck);

            break;
        }

        case NV_CFGEX_GET_DEVICES_CONFIGURATION:
        {
            NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS   *param;

            param = (NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS *)paramStructPtr;

            // make sure it's a subset of all available devices.
            if (!param->DevicesConfig ||
                ((param->DevicesConfig ^ pDev->Dac.DevicesBitMap) & param->DevicesConfig)) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }

            if (dacFindDevicesConfiguration(pDev,
                                            param->DevicesConfig,
                                            &param->DevicesAllocationMap,
                                            param->OldDevicesConfig,
                                            param->OldDevicesAllocationMap) != RM_OK)
                status = CONFIG_GETEX_BAD_PARAM;

            break;
        }

        case NV_CFGEX_GET_VIDEO_TV_STANDARD:
        {
            NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS   *param;
            U032 i, numEncoders = 0;

            param = (NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS *)paramStructPtr;

            // Check that one and only one encoder is specified
            for (i = TV_ENCODER_0; i <= TV_ENCODER_7; i <<=1) {
                if (i & param->DevicesConfig) {
                    numEncoders++;
                }
            }
            if (numEncoders != 1) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            // Only one encoder for now. In future, we may need to expand the data structure.
            if (param->DevicesConfig & TV_ENCODER_0) {
                param->TVStandard = pDev->Dac.TVStandard;
            }
            else
                status = CONFIG_GETEX_BAD_PARAM;
            break;
        }
        case NV_CFGEX_VALIDATE_BANDWIDTH:
        {
            NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS   *Params;
            BANDWIDTH_CALC_PARAMS head0, head1;

            Params = (NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            head0.Enable = Params->HeadActive0;
            head0.TotalWidth = Params->TotalWidth0;
            head0.VisibleWidth = Params->VisibleWidth0;
            head0.TotalHeight = Params->TotalHeight0;
            head0.VisibleHeight = Params->VisibleHeight0;
            head0.PixelDepth = Params->PixelDepth0;
            head0.PixelClock = Params->PixelClock0;
            head1.Enable = Params->HeadActive1;
            head1.TotalWidth = Params->TotalWidth1;
            head1.VisibleWidth = Params->VisibleWidth1;
            head1.TotalHeight = Params->TotalHeight1;
            head1.VisibleHeight = Params->VisibleHeight1;
            head1.PixelDepth = Params->PixelDepth1;
            head1.PixelClock = Params->PixelClock1;

            if (nvHalDacValidateBandwidth(pDev,
                                    Params->VidScalerHead,
                                    &head0,
                                    &head1) != RM_OK)
                status = CONFIG_GETEX_BAD_PARAM;

            break;
        }

        case NV_CFGEX_GET_DAC_CRC_VALUES:
        {
            NV_CFGEX_GET_DAC_CRC_VALUES_PARAMS * Params;
            Params = (NV_CFGEX_GET_DAC_CRC_VALUES_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);
            
            status = dacGetCrcValues(pDev,
                                     Params->Head,
                                     &Params->RedCrc,
                                     &Params->GreenCrc,
                                     &Params->BlueCrc);
        }
        break;

#if defined(_WIN32) && !defined(_WIN64)
        case NV_CFGEX_MAP_USER_SPACE:
        {
            NV_CFGEX_MAP_USER_SPACE_PARAMS *pParams;

            // extract parameters from the command struct
            pParams = (NV_CFGEX_MAP_USER_SPACE_PARAMS *) paramStructPtr;

            // create the user mapping
            pParams->uAddr = osMapUserSpace(pParams->kAddr, pParams->ppMDL, pParams->mSize, NULL);
            
            status = RM_OK;
        }
        break;

        case NV_CFGEX_UNMAP_USER_SPACE:
        {
            NV_CFGEX_UNMAP_USER_SPACE_PARAMS *pParams;

            // extract parameters from the command struct
            pParams = (NV_CFGEX_UNMAP_USER_SPACE_PARAMS *) paramStructPtr;

            // map the kernel address into user space
            osUnmapUserSpace(pParams->uAddr, pParams->pMDL);

            status = RM_OK;
        }
        break;

        case NV_CFGEX_MEM_INFO:
        {
            NV_CFGEX_MEM_INFO_PARAMS *pParams;
            unsigned long i, _edx, _eax;

            // extract parameters from the command struct
            pParams = (NV_CFGEX_MEM_INFO_PARAMS *) paramStructPtr;

            _asm {
                mov eax, 1
                _emit 0x0f // CPUID
                _emit 0xa2
                mov [_edx], edx
            }

            if ((_edx & 0x1020) == 0x1020) {
                _asm {
                    mov ecx, 0x277; // PAT
                    _emit 0x0f; // RDMSR
                    _emit 0x32;
                    mov [_edx], edx;
                    mov [_eax], eax;
                }
                pParams->uPATHigh = _edx;
                pParams->uPATLow  = _eax;
                for (i = 0; i < 8; i++) {
                    unsigned int MTRRPhysBase = 512 + (i << 1);
                    unsigned int MTRRPhysMask = 513 + (i << 1);
                    _asm {
                        mov ecx, [MTRRPhysBase];
                        _emit 0x0f; // RDMSR
                        _emit 0x32;
                        mov [_edx], edx;
                        mov [_eax], eax;
                    }
                    pParams->uMTRRphysBaseHigh[i] = _edx;
                    pParams->uMTRRphysBaseLow[i]  = _eax;
                    _asm {
                        mov ecx, [MTRRPhysMask];
                        _emit 0x0f; // RDMSR
                        _emit 0x32;
                        mov [_edx], edx;
                        mov [_eax], eax;
                    }
                    pParams->uMTRRphysMaskHigh[i] = _edx;
                    pParams->uMTRRphysMaskLow[i]  = _eax;
                }
                status = RM_OK;
            } else {
                // cpu has no PAT or RDMSR support
                status = CONFIG_GETEX_BAD_PARAM;
            }
        }
        break;
#endif  // !WIN32

        case NV_CFGEX_LOW_FP_REFRESH_RATES:
        {
            NV_CFGEX_LOW_FP_REFRESH_RATES_PARAMS   *Params;
            U032      rEAX, rEBX, rECX, rEDX;

            Params = (NV_CFGEX_LOW_FP_REFRESH_RATES_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            //Call through VBIOS to SBIOS to get extra-low refresh rates
            // supported.  As of this writing (June/2001) this is a requested
            // feature for IBM mobile systems.  May be expanded to others later.
            rEAX = 0x4F14;
            rEBX = 0x068F;
            rECX = 0;
            rEDX = 0;
            status = osCallVideoBIOS(pDev, &rEAX, &rEBX, &rECX, &rEDX, NULL);
            if (status != RM_OK)
                status = CONFIG_GETEX_BAD_PARAM;  //Call is not supported by VBIOS or SBIOS

            Params->fpDefaultHz = rECX & 0xFF;
            Params->fpLowHz1 = (rECX >> 8) & 0xFF;
            Params->fpLowHz2 = (rECX >> 16) & 0xFF;

            break;
        }

        case NV_CFGEX_GET_MACROVISION_MODE:
        {
            NV_CFGEX_GET_MACROVISION_MODE_PARAMS *Params;
            RM_MACROVISION_CONTROL mvCtrl;

            Params = (NV_CFGEX_GET_MACROVISION_MODE_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            if ( GetMacrovisionMode(pDev, Params->head, &mvCtrl) ) {
                status = CONFIG_GETEX_BAD_PARAM;
            }
            else {
                Params->mode        = mvCtrl.mode;
                Params->resx        = mvCtrl.resx;
                Params->resy        = mvCtrl.resy;
                Params->devAddr     = mvCtrl.devAddr;
                Params->port        = mvCtrl.port;
                Params->encoderType = mvCtrl.encoderType;
                Params->tvStandard  = mvCtrl.tvStandard;
                status = RM_OK;
            }
            break;
        }

        default:
            status = CONFIG_GETEX_BAD_INDEX;
            break;
    } // switch on index

 done:
    return status;

} // end of stateConfigGetEx

RM_STATUS stateConfigSetEx(
    PHWINFO pDev,
    U032    index,
    VOID    *paramStructPtr,
    U032    paramSize
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    RM_STATUS status = RM_OK;
    switch (index)
    {
        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR:
        {
            U032 Head = 0;
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS *)paramStructPtr;
            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            status = dacSetMonitorPosition(pDev, 
                                           Head,
                                           Params->HRetraceStart, Params->HRetraceEnd,
                                           Params->VRetraceStart, Params->VRetraceEnd);
            if (!status && Params->CommitChanges)
            {
                // Write the the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Head,
                                                           TRUE, // isMonitor
                                                           (U008 *) &(Params->HRetraceStart),
                                                           4 * sizeof(U032));
            }
        }
        break;

        case NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI:
        {
            NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacSetMonitorPosition(pDev, 
                                           Params->Head,
                                           Params->HRetraceStart, Params->HRetraceEnd,
                                           Params->VRetraceStart, Params->VRetraceEnd);
            if ((status == RM_OK) && Params->CommitChanges)
            {
                // Write the the passed values into the registry.
                status = dacWriteDesktopPositionToRegistry(pDev,
                                                           Params->Head,
                                                           TRUE, // isMonitor
                                                           (U008 *) &(Params->HRetraceStart),
                                                           4 * sizeof(U032));
            }
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *Params;
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS MultiParams;
            U032 Head = 0;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            //
            // For dacSetTVPosition to work, we need to standardize on one POSITION_TV
            // params struct format that lives in the registry (currently, you can have a
            // MULTI or a non-MULTI version, which is a problem).
            //
            // Until we remove the non-MULTI versions of these calls, independent of how
            // we're called we'll read/write the registry with the MULTI version of struct.
            // Which means (temporarily), we need to perform a cast in the non-MULTI case.
            
            MultiParams.Head = Head;
            osMemCopy((U008*)&MultiParams.Encoder_ID, (U008*)Params, paramSize);

            // Write the passed values into the registry.
            status = dacWriteDesktopPositionToRegistry(pDev,
                                                       Head,
                                                       FALSE, // not Monitor
                                                       (U008 *) &MultiParams,
                                                       sizeof(MultiParams));
        }
        break;

        case NV_CFGEX_COMMIT_DESKTOP_POSITION_TV_MULTI:
        {
            NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            // Write the the passed values into the registry.
            status = dacWriteDesktopPositionToRegistry(pDev,
                                                       Params->Head,
                                                       FALSE, // not Monitor
                                                       (U008 *) Params,
                                                       sizeof(*Params));
        }
        break;

        case NV_CFGEX_SET_DESKTOP_POSITION_MULTI:
        {
            NV_CFGEX_SET_DESKTOP_POSITION_MULTI_PARAMS *Params;

            Params = (NV_CFGEX_SET_DESKTOP_POSITION_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            // Position the display (CRT or TV), or commit the position to the registry.
            status = dacSetDesktopPosition(pDev, Params->DeviceMap, Params->Position);
        }
        break;

        case NV_CFGEX_CRTC_TIMING_MULTI:
        {
            NV_CFGEX_CRTC_TIMING_PARAMS *Params;
            Params = (NV_CFGEX_CRTC_TIMING_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacSetCRTCTiming(pDev, Params->Head, Params);
        }
        break;

        case NV_CFGEX_ENABLE_TETRIS_TILING:
        {
            // Automatic tiling will be enabled at the next modeset.
            // The tiling mode will be selected based on the new mode.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_ENABLE);
        }
        break;

        case NV_CFGEX_DISABLE_TETRIS_TILING:
        {
            // Automatic tiling will be disabled at the next modeset. It will remain disabled till
            // it is enabled by calling ConfigSetEx with NV_CFGEX_ENABLE_TETRIS_TILING.
            status = nvHalFbControl(pDev, FB_CONTROL_TILING_DISABLE);
        }
        break;

        case NV_CFGEX_SET_FLAT_PANEL_INFO:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *Params;
            U032 Head = 0;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            RM_ASSERT(pDev->Dac.CrtcInfo[0].pVidLutCurDac);
            status = dacSetFlatPanelScalingCMOS(pDev, Head, Params->FlatPanelMode, Params->CommitChanges);
            status = dacSetFlatPanelMode(pDev, 0,
                                         (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac,
                                         Params->FlatPanelMode, Params->CommitChanges);
        }
        break;
    case NV_CFGEX_SET_FLAT_PANEL_SCALING:
    {   
        NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *Params;
        Params = (NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;

        VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
        VERIFY_HEAD(pDev, Params->Head);
        if (Params->FlatPanelMode <= 2) 
        {
            status = dacSetFlatPanelScaling(pDev, Params->Head, Params->FlatPanelMode, Params->CommitChanges);
        }
    }
    break;


        case NV_CFGEX_SET_FLAT_PANEL_INFO_MULTI:
        {
            NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            RM_ASSERT(pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac);
            status = dacSetFlatPanelScalingCMOS(pDev, Params->Head, Params->FlatPanelMode, Params->CommitChanges);
            status = dacSetFlatPanelMode(pDev, Params->Head,
                                         (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Params->Head].pVidLutCurDac,
                                         Params->FlatPanelMode, Params->CommitChanges);
        }
        break;
        
        case NV_CFGEX_FLAT_PANEL_BRIGHTNESS:
        {
            NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS * Params;
            Params = (NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS *)paramStructPtr;
        	
        	if(paramSize<sizeof(NV_CFGEX_FLATPANEL_BRIGHTNESS_PARAMS))
        	{
        		//wrong parameter size
        		status=CONFIG_SETEX_BAD_PARAM;
        	}
        	else
        	{
        		status=dacSetFlatPanelBrightness(pDev, Params->Head,
        									Params->PercentRelativeBrightness,
                							Params->FlatPanelBrightnessControlFrequency,
                							Params->PercentMaximumPWMDutyCycle,
                							Params->PercentMinimumPWMDutyCycle,
                							Params->PWMControllerEnable,
                							Params->InverterCurrentMode);
            }
        }
        break;

        case NV_CFGEX_POWER_MIZER:
        {
            NV_CFGEX_POWER_MIZER_PARAMS *Params;
        	Params = (NV_CFGEX_POWER_MIZER_PARAMS *)paramStructPtr;

        	if (paramSize != sizeof(NV_CFGEX_POWER_MIZER_PARAMS))
        	{
        		status = CONFIG_SETEX_BAD_PARAM;
        	}
        	else
        	{
                if (//Params->Current >= POWER_MIZER_MIN && //Removed because the IA64 Win2K compile flags this as unneeded, then upgrades it to an error and dies...
                    Params->Current <= POWER_MIZER_MAX &&
                    pDev->Power.MobileOperation) 
                {
                    mcSetPowerMizerLevel(pDev, Params->Current);
                    mcPowerStateTrigger(pDev);
                    status = CONFIG_SETEX_OK;        
                } 
                else 
                {
                    status = CONFIG_SETEX_BAD_PARAM;
                }
        	}
            
        }
        break;

        case NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST:
        {
            NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *Params;
            Params = (NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            status = dacSetColorSaturationBoost(pDev, Params->Head, Params->boostValue);
        }
        break;

        //
        // XXXscottl
        //
        // These SET_DISPLAY_TYPE calls need to be removed.
        // All programming of the display/monitor/tv types
        // should be done via the dac classes from now on.
        //

        case NV_CFGEX_SET_DISPLAY_TYPE:
        {
            U032 Head = 0;

            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            SETDISPLAYTYPE(pDev, Head, Params->Type);
            if ((Params->Type == DISPLAY_TYPE_TV) && (Params->TVType <= KNOWN_TV_FORMATS))
                pDev->Dac.TVStandard = Params->TVType;
            status = CONFIG_SETEX_OK;
        }
        break;

        case NV_CFGEX_SET_DISPLAY_TYPE_MULTI:
        {
            NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *Params;
            Params = (NV_CFGEX_SET_DISPLAY_TYPE_MULTI_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            SETDISPLAYTYPE(pDev, Params->Head, Params->Type);
            if ((Params->Type == DISPLAY_TYPE_TV) && (Params->TVType <= KNOWN_TV_FORMATS))
                pDev->Dac.TVStandard = Params->TVType;
            status = CONFIG_SETEX_OK;
        }
        break;

        case NV_CFGEX_DISPLAY_CHANGE_START:
        {
            NV_CFGEX_DISPLAY_CHANGE_START_PARAMS *Params;
            Params = (NV_CFGEX_DISPLAY_CHANGE_START_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            status = dacSetModeStartEx(pDev, Params->NewDevices, Params->Properties);
        }
        break;

        case NV_CFGEX_DISPLAY_CHANGE_END:
        {
            NV_CFGEX_DISPLAY_CHANGE_END_PARAMS *Params;
            Params = (NV_CFGEX_DISPLAY_CHANGE_END_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            status = dacSetModeEndEx(pDev, Params->NewDevices, Params->Properties);
        }
        break;

        case NV_CFGEX_AGP_LINEAR_BASE:
        {
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS *Params;
            VOID_PTR oldValue;

            Params = (NV_CFGEX_AGP_LINEAR_BASE_PARAMS *)paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);

            oldValue = pRmInfo->AGP.AGPLinearStart;
            pRmInfo->AGP.AGPLinearStart = (VOID_PTR)Params->linaddr;
            Params->linaddr = (void *)oldValue;
            status = CONFIG_SETEX_OK;
        }
        break;

        case NV_CFGEX_SYNC_STATE:
        {
            NV_CFGEX_SYNC_STATE_PARAMS *Params;
            Params = (NV_CFGEX_SYNC_STATE_PARAMS *) paramStructPtr;

            VERIFY_PARAM_SIZE(pDev, index, sizeof(*Params), paramSize);
            VERIFY_HEAD(pDev, Params->Head);

            dacGetSyncState(pDev, Params->Head, &Params->oldHsync, &Params->oldVsync);
            dacSetSyncState(pDev, Params->Head, Params->Hsync, Params->Vsync);
        }
        break;

        case NV_CFGEX_RESERVED:
        {
            // Refer to nvcmrsvd.h for supported properties.
            NV_CFGEX_RESERVED_PROPERTY * pParams = (NV_CFGEX_RESERVED_PROPERTY*)paramStructPtr;
            U032                         In[2]   = {0};

            // Copy the data in (2 parameter).
            osCopyIn((U008*)pParams->In, (U008*)In, 2*sizeof(U032));

            // Set the data.
            status = CONFIG_SETEX_BAD_PARAM;
            if (paramSize == sizeof(*pParams))
            {
                status = RM_OK;
                switch (pParams->Property)
                {
                    case PROPERTY_REG_WR08:
                        REG_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR16:
                        REG_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_REG_WR32:
                        REG_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR08:
                        FB_WR08(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR16:
                        FB_WR16(In[0], In[1]);
                        break;

                    case PROPERTY_FB_WR32:
                        FB_WR32(In[0], In[1]);
                        break;

                    case PROPERTY_SET_GRAPHICS_CLOCK:
                        pDev->Dac.HalInfo.NVClk = In[0];
                        if (dacProgramNVClk(pDev) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_MEMORY_CLOCK:
                        pDev->Dac.HalInfo.MClk = In[0];
                        if (dacProgramMClk(pDev, 0) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;

                        break;

                    case PROPERTY_SET_PIXEL_CLOCK:
                    {
                        // dacProgramPClk takes frequency in MHz * 100.
                        U032 Head      = In[0];
                        U032 Frequency = In[1] / 10000;

                        VERIFY_HEAD(pDev, Head);

                        if (dacProgramPClk(pDev, Head, Frequency) != RM_OK)
                            status = CONFIG_SETEX_BAD_WRITE;
                        break;
                    }

                    default:
                        status = CONFIG_SETEX_BAD_PARAM;
                        break;
                }
            }
        }
        break;

        case NV_CFGEX_SET_MACROVISION_MODE:
        {
            NV_CFGEX_SET_MACROVISION_MODE_PARAMS *Params;
            RM_MACROVISION_CONTROL mvCtrl;

            // extract parameters from the command struct
            Params = (NV_CFGEX_SET_MACROVISION_MODE_PARAMS *) paramStructPtr;
            mvCtrl.mode = Params->mode;
            mvCtrl.resx = Params->resx;
            mvCtrl.resy = Params->resy;

            // extract parameters that the RM maintains
            mvCtrl.devAddr = pDev->Dac.EncoderID;
            mvCtrl.encoderType = pDev->Dac.EncoderType;
            mvCtrl.tvStandard = pDev->Dac.TVStandard;
            mvCtrl.port = pDev->Dac.TVOutPortID;

            VERIFY_HEAD(pDev, Params->head);

            if ( SetMacrovisionMode(pDev, Params->head, &mvCtrl) ) {
                status = CONFIG_SETEX_BAD_PARAM;
            }
            else {
                status = RM_OK;
            }
        }
        break;

        case NV_CFGEX_SET_VIDEO_TV_STANDARD:
        {
            NV_CFGEX_SET_VIDEO_TV_STANDARD_PARAMS   *param;
            U032 i, numEncoders = 0;

            param = (NV_CFGEX_SET_VIDEO_TV_STANDARD_PARAMS *)paramStructPtr;

            // Check that one and only one encoder is specified
            for (i = TV_ENCODER_0; i <= TV_ENCODER_7; i <<=1) {
                if (i & param->DevicesConfig) {
                    numEncoders++;
                }
            }
            if (numEncoders != 1) {
                status = CONFIG_GETEX_BAD_PARAM;
                break;
            }
            // Only one encoder for now. In future, we may need to expand the data structure.
            if (param->DevicesConfig & TV_ENCODER_0) {
                pDev->Dac.TVStandard = param->TVStandard;
            }
            else
                status = CONFIG_GETEX_BAD_PARAM;
        }
        break;

#ifdef DEBUG
        case NV_CFGEX_DLOAD_MODULE:
        {
    	    extern RM_STATUS dloadHalModule(PHWINFO pDev,VOID *pFileImage);
            NV_CFGEX_DLOAD_MODULE_PARAMS *Params;
            
            void *pFile;
            
    	    Params = (NV_CFGEX_DLOAD_MODULE_PARAMS*)paramStructPtr;
            
            pFile = (void*)NvP64_VALUE(Params->MappedModule);
            
            status = DldLoadModule(pDev,pFile);
	    
    	}
        break;
#endif

        default:
            status = CONFIG_SETEX_BAD_INDEX;
            break;
    }

 done:
    return status;
} // end of stateConfigSetEx
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\vblank\nv\vblank.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/**************************** Interrupt Routine ****************************\
*                                                                           *
* Module: VBLANK.C                                                          *
*   Vertibal blank interrupt servicing is handled here.  This is a true     *
*   interrupt time call so no os services are available.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <vblank.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h
#include <nv10_ref.h>    // for PCRTC_CURSOR_CONFIG def and mobile FP dithering 



// Const strings for accessing the registry
extern char strFpMode[];

// external interfaces
VOID VBlankAddCallback(PHWINFO, U032, PVBLANKCALLBACK);
VOID VBlankDeleteCallback(PHWINFO, U032, PVBLANKCALLBACK);
U032 VBlankPending(PHWINFO);
VOID VBlankUpdateDither(PHWINFO,U032 Head);


RM_STATUS mthdColormapDirtyNotify(PHWINFO, RM_STATUS);

static VOID VBlankProcessCallbacks
(
    PHWINFO pDev,
    U032 Head
)
{
    PVBLANKCALLBACK Callback;
    PVBLANKCALLBACK NextCallback;
    PVBLANKCALLBACK *PrevCallback;
    PDACCRTCINFO pDacCrtcInfo;


    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    Callback     = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;
    PrevCallback = (PVBLANKCALLBACK *)&pDacCrtcInfo->VBlankCallbackList;

    while (Callback) {
        NextCallback   = Callback->Next;
        Callback->Next = NULL;

        // Execute this on a particular VBlankCount?
        if ((Callback->Flags & CALLBACK_FLAG_SPECIFIED_VBLANK_COUNT) &&
            (Callback->VBlankCount != pDacCrtcInfo->VBlankCounter)) {
            PrevCallback = &Callback->Next;     // skip it
        } else {
            // Call the function now
            if (Callback->Proc) {
                Callback->Proc(pDev,
                               Callback->Object,
                               Callback->Param1,
                               Callback->Param2,
                               Callback->Status);
            }
            *PrevCallback = NextCallback;       // unlink it
        }
        Callback = NextCallback;
    }
}


VOID VBlankAddCallback
(
    PHWINFO         pDev, 
    U032            Head,
    PVBLANKCALLBACK Callback
)
{
    RM_ASSERT(Head <= MAX_CRTCS);

    //
    // There are two conditions we need to guard against here:
    //
    //   [1] This head doesn't have a valid mode.  This can happen
    //       if we get here after dacDestroyObj.
    //   [2] Vblank interrupts have been disabled.  This can happen
    //       if we get here after dacDisableDac via some power mgmt.
    //
    // In both of these cases, we need to handle the callback immediately
    // rather than queue it up since there won't be a vblank intr.
    //
    // To test for [1], we check for an active dac object.  This will
    // tell us if this head has seen a modeset.
    //
    // To test for [2], we check the VBLANK_ENABLED flag.
    //
    // Neither is the cleanest thing, but should be OK for now.
    //
    if (pDev->Dac.CrtcInfo[Head].pVidLutCurDac &&
        (pDev->Dac.CrtcInfo[Head].StateFlags & DAC_CRTCINFO_VBLANK_ENABLED))
    {
        // queue it
        Callback->Next = (PVBLANKCALLBACK)pDev->Dac.CrtcInfo[Head].VBlankCallbackList;
        pDev->Dac.CrtcInfo[Head].VBlankCallbackList = (VOID_PTR)Callback;
    }
    else
    {
        // call it now
        if (Callback->Proc) {
            // Force it to appear to be on the correct VBlankCount
            Callback->VBlankCount = pDev->Dac.CrtcInfo[Head].VBlankCounter;
            Callback->Proc(pDev,
                           Callback->Object,
                           Callback->Param1,
                           Callback->Param2,
                           Callback->Status);
        }
    }
}


//
// This routine can be called from an API entry point.
//
// For winnt4/win2k the necessary locking is already preventing a conflict
// with the VBlank handler running concurrently. For win9x, make sure the
// interrupt is disable before pulling callbacks off the list.
//
VOID VBlankDeleteCallback
(
    PHWINFO         pDev,
    U032            Head,
    PVBLANKCALLBACK Callback
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 enable;

    RM_ASSERT(Head <= MAX_CRTCS);
    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // Disable VBlank while we scan/process the callback list

    enable = DAC_REG_RD_DRF(_PCRTC, _INTR_EN_0, _VBLANK, Head);
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _DISABLED, Head);

    // Search the list and remove this Callback entry
    if (pDacCrtcInfo->VBlankCallbackList == (VOID_PTR)Callback) {
        //
        // Found it.
        // Should the callback be executed as part of the object destroy
        // (safe to do, since we already hold the necessary lock).
        //
        if (Callback->Proc && 
            (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
            // Force it to appear to be on the correct VBlankCount
            Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
            Callback->Proc(pDev,
                           Callback->Object,
                           Callback->Param1,
                           Callback->Param2,
                           Callback->Status);
        }
        pDacCrtcInfo->VBlankCallbackList = (VOID_PTR)Callback->Next;
    } else {
        PVBLANKCALLBACK PrevCallback = (PVBLANKCALLBACK)pDacCrtcInfo->VBlankCallbackList;

        while (PrevCallback) {
            if (PrevCallback->Next == Callback) {
                //
                // Found it.
                // Should the callback be executed as part of the object destroy
                // (safe to do, since we already hold the necessary lock).
                //
                if (Callback->Proc && 
                    (Callback->Flags & CALLBACK_FLAG_COMPLETE_ON_OBJECT_CLEANUP)) {
                    // Force it to appear to be on the correct VBlankCount
                    Callback->VBlankCount = pDacCrtcInfo->VBlankCounter;
                    Callback->Proc(pDev,
                                   Callback->Object,
                                   Callback->Param1,
                                   Callback->Param2,
                                   Callback->Status);
                }
                PrevCallback->Next = Callback->Next;
                break;
            }
            PrevCallback = PrevCallback->Next;
        }
    }
    Callback->Next = NULL;

    // Restore VBlank enable
    DAC_FLD_WR_DRF_NUM(_PCRTC, _INTR_EN_0, _VBLANK, enable, Head);
}

//
// VBlankUpdateFlip
//
static U032 VBlankUpdateFlip
(
    PHWINFO         pDev,
    U032            Head
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U008 Cr07, Cr25;
    U008 lock;
    U016 DisplayEnd, Scanline;
    U032 rmFinish = FALSE;
#ifdef NTRM
    U008 crtc_color, crtc_index;
#endif

    //
    // Initialize logical head so that the HAL will know which
    // crtc to program up.
    //
    vidLutCurDacHalObj.Head = Head;

#ifdef NTRM
    // XXX temporarily NT only (this needs to be made common)
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);
#endif

    // Unlock CRTC extended regs
    lock = UnlockCRTC(pDev, Head);

    //
    // Update framebuffer address?
    //
    if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_BUFFER_FLIP)
    {
        pDev->Framebuffer.FlipFrom = pDev->Framebuffer.Current;
        pDev->Framebuffer.Current  = pDev->Framebuffer.FlipTo;
        if (!pDev->Vga.Enabled)
        {
            //
            // Make sure we're really in blank
            //
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
                    ;
            else // !? Easy way isn't working with flat panel. Use scanline counter instead.
            {
                // Compare scanline count to display end
                CRTC_RD(NV_CIO_CR_VDE_INDEX, DisplayEnd, Head);
                CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
                CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
                if (Cr07 & 2) DisplayEnd |= 0x100;
                if (Cr07 & 0x40) DisplayEnd |= 0x200;
                if (Cr25 & 2) DisplayEnd |= 0x400;                    

                nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                while (Scanline < DisplayEnd)
                {
                    nvHalDacGetRasterPosition(pDev, &Scanline, (VOID*) &vidLutCurDacHalObj);
                }
            }

            //
            // Program the new start address; this will latch at the end of blank
            //
            if (!pDev->pStereoParams || !(pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED))
                nvHalDacSetStartAddr(pDev, pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current], &vidLutCurDacHalObj);
            else
                RM_ASSERT(FALSE);

        }
        pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_BUFFER_FLIP;       
        pDev->Framebuffer.FinishFlags |=  FINISH_HWINFO_BUFFER_FLIP;
        rmFinish = TRUE;
    }

    if (pDev->pStereoParams &&
       (pDev->pStereoParams->Flags & (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED)) == STEREOCFG_STEREOACTIVATED &&
        pDev->pStereoParams->FlipOffsets[3][0] != 0xFFFFFFFF)
    {
        unsigned long *pBufferOffset;
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[0][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[0][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[1][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[1][0];
        else
        if (pDev->pStereoParams->FlipOffsets[3][0] == pDev->pStereoParams->FlipOffsets[2][0])
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[2][0];
        else
        {
            pDev->pStereoParams->FlipOffsets[3][1] = pDev->pStereoParams->FlipOffsets[3][0];
            pBufferOffset = &pDev->pStereoParams->FlipOffsets[3][0];
            //The only explanation that the last flip offset doesn't match one of ours is
            //that it happened upon someone else request. This is most likely a video mode
            //restore taking place when an application ends. The safest strategy here would
            //be to force stereo off.
            pDev->pStereoParams->Flags = 0;
        }
        pDev->pStereoParams->EyeDisplayed ^= 1;
        nvHalDacSetStartAddr(pDev, pBufferOffset[pDev->pStereoParams->EyeDisplayed], &vidLutCurDacHalObj);
        if (pDev->pStereoParams->Flags & STEREOCFG_ELSADDC)
        {
            U008 DDCVal;
            U008 DDCOwner = 0;         // avoid unused compile warning
            if (IsNV11(pDev))
            {
                //Make sure we own the DDC.
                DDCOwner = REG_RD08(NV_CIO_CRE_ENGINE_CTRL);
                AssocDDC(pDev, Head);
            }
            DDCVal = pDev->pStereoParams->EyeDisplayed ? 0x1 : 0x11;
            CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, DDCVal, Head);
            if (IsNV11(pDev))
            {
                REG_WR08(NV_CIO_CRE_ENGINE_CTRL, DDCOwner);
            }
        }
    }

    // Relock CRTC extended regs
    RestoreLock(pDev, Head, lock);

#ifdef NTRM
    //
    // Restore crtc index register
    //
    if (crtc_color)
        REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
    else
        REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
#endif

    return rmFinish;
}

//
// VBlankUpdatePalette
//
static VOID VBlankUpdatePalette
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 i, j, k;
    U016 Width, Height;
    U016  color;
    U008  test, mask;
    U032  color32;
    U008  color8;
    U008  *lpColorMask;

#define   COLOR_OFFSET    32*4    // offset of XOR mask from start of buffer (= size of and mask)

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_COLORMAP)
    {
        if (!pDev->Vga.Enabled)
        {
            if (pDev->Dac.HalInfo.Depth == 8)
                dacProgramLUT(pDev, Head, &pDev->Dac.Palette[0], 256);
            else
                dacProgramLUT(pDev, Head, &pDev->Dac.Gamma[0], 256);

            // JJV- Update the cursor to the new DAC values.
            // Read the saved DAC indices from nvinfo ... the cursor
            // indices are saved after each update.
            // Generate a cursor image update to force a restore on
            // the cursor palette. 
            if ( (pDev->Dac.HalInfo.Depth == 8)  && 
                 (pDev->Dac.CursorBitDepth == 8) &&
                 (pDev->Dac.CrtcInfo[Head].CursorType == DAC_CURSOR_FULL_COLOR_XOR) )
            {
                lpColorMask = pDev->Dac.SavedCursor + COLOR_OFFSET;
                Width=Height=32;
                for (i = 0; i < Height; i++)
                {
                    for (j = 0; j < (U032)Width/8; j++)
                    {
                        mask = pDev->Dac.SavedCursor[i * sizeof(U032) + j]; // get 8 AND bits                                
                        test = 0x80;
                        for (k = 0; k < 8; k++, test >>=1)  // get 8 pixels and write 8 words
                        {
                            color8 = lpColorMask[i*32+j*8+k];   // get 8 bits of color
                            color32 = pDev->Dac.Palette[color8];     // look up color (24 bits)
                            // pack 8-8-8 into 5-5-5, using most sig bits 
                            color =  (U016)((color32 >> 9) & 0x7c00);   // red
                            color |= (color32 >> 6) & 0x03e0;           // green
                            color |= (color32 >> 3) & 0x001f;           // blue
                            if (!(test & mask))
                                color |= 0x8000;                            
                            pDev->Dac.CursorColorImage[i][j*8+k] = color;
                        }
                    }
                }    
                pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;
            }
                
            // We have just updated the colormap. Notify the object.
            mthdColormapDirtyNotify(pDev, RM_OK);
            pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_COLORMAP;
        }
    }
}

//
// VBlankUpdateVideoScaler
//
static U032 VBlankUpdateVideoScaler
(
    PHWINFO         pDev,
    U032            Head
)
{
    U032 rmFinish = FALSE;

    //
    // Update the video scaler settings
    //
    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_DUALSURFACE)   // if we are using the scalar for dual surface, don't change it
    {
        if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)
        {
            if (pDev->Video.HalInfo.Enabled)
                nvHalVideoControl(pDev, VIDEO_CONTROL_ENABLE);
            else
                nvHalVideoControl(pDev, VIDEO_CONTROL_DISABLE);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
        }
    } // dualsurface    
    else
    {
        if (pDev->Video.HalInfo.UpdateFlags & UPDATE_HWINFO_VIDEO_ENABLE)   // if dual surf, set TV for YUV
        {
            if (pDev->Video.HalInfo.Enabled)
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _YUV);
            else
                FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _VS_PIXFMT, _565);
            pDev->Video.HalInfo.UpdateFlags &= ~UPDATE_HWINFO_VIDEO_ENABLE;
            pDev->Video.HalInfo.FinishFlags |=  FINISH_HWINFO_VIDEO_ENABLE;
            rmFinish = TRUE;
        }                
    }

    return rmFinish;
}

//
// VBlankUpdateCursor
//
// Handle win9x cursor updates.
//
static VOID VBlankUpdateCursor
(
    PHWINFO         pDev,
    U032            Head
)
{
    U008 crtc_color, crtc_index;
    PDACCRTCINFO pDacCrtcInfo;
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;

    VidLutCurDac.Head = Head;

    //
    // Save away the current CRTC index values.
    //
    // This should be in VBlank common to all callbacks, but placing it there
    // caused problems at boot time (which are still a mystery). For now, make
    // the save/restore local to the cursor update callback.
    //
    crtc_color = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01);    // color or mono?
    if (crtc_color)
        crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);
    else
        crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];

    // position cursor?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_POS)
    {
        dacProgramCursorPosition(pDev, Head,
                                 pDacCrtcInfo->CursorPosX,
                                 pDacCrtcInfo->CursorPosY);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_POS;
    }

#ifdef WIN31    // This is the old way of updating the cursor image

    // update glyph?
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE)
    {
        U032 i, j;

        // The image was copied into the pDev->structure in the API call.
        // We need to copy into the Instance memory, where the DAC can find it.

        // The 2k image has been formatted by the OS module NVSYS.C, 
        // The buffer is a 32x32 array of words. Each word represents a pixel.
        for (i = 0; i < 32; i++)    
            for (j = 0; j < 32; j+=2)
            {
                U032 data;
                // grab two words at a time and stuff them in instance mem
                data = pDacCrtcInfo->CursorColorImage[i][j+1];
                data = (data << 16) | pDacCrtcInfo->CursorColorImage[i][j];
                INST_WR32(pDacCrtcInfo->CursorImageInstance, i*64+j*2, data);
            }
    }
#else
    // The display driver massages the image and hands us a pointer (to image in framebuffer).
    // This is the new way of manipulating the cursor image. 
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW)
    {
        nvHalDacProgramCursorImage(pDev,
                              pDacCrtcInfo->CursorOffset, 
                              DAC_ASI_FRAMEBUFFER, 
                              pDacCrtcInfo->CursorWidth, pDacCrtcInfo->CursorHeight,
                              pDacCrtcInfo->CursorColorFormat,
                              (VOID*) &VidLutCurDac);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_IMAGE_NEW;
    }
#endif
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_ENABLE)
    {
        // Enable the cursor.
        dacEnableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_ENABLE;
    }

    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_CURSOR_DISABLE)
    {
        // Disable the cursor.
        dacDisableCursor(pDev, Head);
        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_CURSOR_DISABLE;
    }

    //
    // Restore crtc index register
    //
    if (crtc_color)
        REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);
    else
        REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);
}

//
// VBlankUpdateImageOffsetFormat
//
// Handle win9x panning start address updates. This could be made to be
// a generalized backdoor taking method offsets and data.
//
static VOID VBlankUpdateImageOffsetFormat
(
    PHWINFO         pDev,
    U032            Head
)
{
    PDACCRTCINFO pDacCrtcInfo;
    RM_STATUS status;

    pDacCrtcInfo = &pDev->Dac.CrtcInfo[Head];
    if (pDacCrtcInfo->UpdateFlags & UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT)
    {
        POBJECT Object;

        // Given the object handle, find the POBJECT pointer
        status = fifoSearchObject(pDev,
                                  pDacCrtcInfo->ObjectHandle,
                                  pDacCrtcInfo->ChID,
                                  &Object);
        if (status != RM_OK) {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,
                                   "NVRM: VBlankUpdateImageOffsetFormat: bad object handle ",
                                    pDacCrtcInfo->ObjectHandle);
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }

        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_PAN_OFFSET == NV049_SET_PAN_OFFSET) &&
                  (NV049_SET_PAN_OFFSET == NV067_SET_PAN_OFFSET) &&
                  (NV067_SET_PAN_OFFSET == NV07C_SET_PAN_OFFSET));

        // Call the SET_IMAGE_OFFSET method
        status = classSoftwareMethod(pDev, Object,
                                     NV07C_SET_PAN_OFFSET, 
                                     pDacCrtcInfo->ImageOffset);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }

        // Verify the method offsets are the same for these VIDEO_LUT_CURSOR_DAC classes.
        RM_ASSERT((NV046_SET_IMAGE_FORMAT(0) == NV049_SET_IMAGE_FORMAT(0)) &&
                  (NV049_SET_IMAGE_FORMAT(0) == NV067_SET_IMAGE_FORMAT(0)) &&
                  (NV067_SET_IMAGE_FORMAT(0) == NV07C_SET_IMAGE_FORMAT(0)));

        // Call the SET_IMAGE_FORMAT method
        status = classSoftwareMethod(pDev, Object,
                                     NV046_SET_IMAGE_FORMAT(0),    
                                     pDacCrtcInfo->ImageFormat);
        if (status != RM_OK) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: VBlankUpdateImageOffsetFormat: method failed");
            DBG_BREAKPOINT();
            pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
            return;
        }

        pDacCrtcInfo->UpdateFlags &= ~UPDATE_HWINFO_DAC_IMAGE_OFFSET_FORMAT;
    }
}


//Check for special reasons we may wish to suppress calls to hotkeyAddEvent.
// Returns FALSE if the event should be discarded.
// Intention is for a passed event or status value of '0' to potentially be special,
// meaning that info is not available or not applicable.
BOOL hotkeyValidateEvent(PHWINFO pDev, U032 event, U032 status)
{

    switch (event) {
    case NV_HOTKEY_EVENT_DISPLAY_ENABLE:
        if (pDev->Dac.DeviceProperties.Spanning) {
            if (pDev->Power.MobileOperation && (pDev->Power.MobileOperation != 1)) { //For any laptop OEM other than Dell
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Suppressing event due to extended mode.\n\r");
                return FALSE;
            }
        }
//Fall through to default case.
    default:
        return TRUE;
        break;
    }
}


//Called to place an event into the queue polled by QuickTweak/NVSVC.  These events
// currently include only requests for display changes and notifications of BIOS
// changes to the flat panel center/scaling state.  This display change mechanism,
// first put in place for hotkeys, is also used to spoof a hotkey-like transition
// when a low level event requires a device change (e.g., a laptop set to use the
// CRT resumes from hibernation without the CRT connected).
VOID hotkeyAddEvent(PHWINFO pDev, U032 event, U032 status)
{
    U032 temp;

    // Don't add another event if we're still in a modeset.
    // Added to fix bug 32596.
    if (pDev->Dac.DisplayChangeInProgress)
        return;

    //Reformat the status parameter for a display switch to reflect
    // which is primary.  The current rule, specified by Toshiba and
    // hopefully accepted by Dell, is that if the LCD is among the
    // devices, it's always the primary.
    //The format is byte0 = primary device, byte1 = secondary, etc., up to 4 devices.
    if (event == NV_HOTKEY_EVENT_DISPLAY_ENABLE) {
        U032 oldstat, i;
        U032 prioritylist[] = {
            NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV,    //lowest priority to be primary
            NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP,
            NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT,
            NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD    //highest priority to be primary
        };

        oldstat = status;
        status = 0;
        for (i = 0; i < 4; i++) {
            if (oldstat & prioritylist[i]) {
                status <<= 8;
                status |= prioritylist[i];
            }
        }
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Adding event:", event);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent:       status:", status);

    if (!hotkeyValidateEvent(pDev, event, status)) return;

    temp = (pDev->HotKeys.queueHead + 1) % NV_HOTKEY_EVENT_QUEUE_SIZE;

    //Don't wrap past tail if there's a backlog.  It may actually
    // be better to keep the newer events rather than the older ones,
    // but that raises queue access coherency issues.  This is a
    // safe way to handle an event that should never happen anyway.
    if (temp == pDev->HotKeys.queueTail) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: hotkeyAddEvent: Queue is full.\n\r");
        return;
    }

    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].event = event;
    pDev->HotKeys.Queue[pDev->HotKeys.queueHead].status = status;
    pDev->HotKeys.queueHead = temp;

#if (defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x500) && defined(NTRM)) || defined(LINUX)
    //Send a notification that an event was added.  Currently only implemented for NT4
    //and linux.
    RmSignalHotKeyEvent();
#endif
}


//Mobile system feature: look for bits in our CR registers that indicate
// a keyboard Fn + key event has occured.  If so, we queue up the event
// so it can be serviced later.
VOID VBlankCheckHotKeys(PHWINFO pDev)
{
    U008 temp, newEvents, stateReg; //, stateChanges;
    U008 lock, head;
    U032 centering;

    //Workaround: loop over both heads.
    for (head = 0; head <= 1; head++) 
    {

    lock = UnlockCRTC(pDev, head);
    
    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    newEvents = temp & (NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);    //Only handle events we know about.

    CRTC_RD(NV_CIO_CRE_SCRATCH7__INDEX, stateReg, head);

    //DEBUG
    if (newEvents) {

        //Leave this printf for current debug purposes -- hotkeys are young yet.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Head:", head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4A register is now:", temp);
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4B register is now:", temp);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR4C register is now:", stateReg);
        CRTC_RD(0x3B, temp, head);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B register is now:", temp);
//        CRTC_RD(0x3B, temp, head^1);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Other CR3B register is now:", temp);

//        CRTC_RD(0x3B, temp, 1);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register is now:", temp);
    }
    //DEBUG

    //Check if anything has changed:
    //Pressing a key may generate more than one event (e.g., disabling one display and enabling another)

    if (newEvents & NV_MOBILE_FLAG_DISPLAY_MASK) {

        temp = 0;
        if (stateReg & NV_MOBILE_DISPLAY_LCD_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
        }
        if (stateReg & NV_MOBILE_DISPLAY_CRT_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
        }
        if (stateReg & NV_MOBILE_DISPLAY_TV_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
        }
        if (stateReg & NV_MOBILE_DISPLAY_DFP_MASK) {
            temp |= NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
        }

        //LPL: I'm seeing some problems with the screen never unblanking
        // with the code below enabled.  There are probably other causes,
        // but in general I'm not comfortable with the idea of blanking the
        // display here because we don't know whether Quicktweak will actually
        // choose to perform the requested action.  If it doesn't, we'll
        // be stuck with the display off.  Unfortunately, not blanking here
        // does allow us to see the backlight turn on and off during the
        // display switch.
#if 0//!defined(MACOS) && !defined(NTRM) 
        // 
        // If we're transitioning to the LCD, turnoff the backlight. This is
        // not included for NT, since these VideoPort calls can't be made from
        // an ISR.
        //
        if (temp & NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD)
        {
            dacBacklightOffMobilePanel(pDev);
        }
#endif

//            if (stateChanges & (NV_MOBILE_DISPLAY_LCD_MASK | NV_MOBILE_DISPLAY_CRT_MASK
//                | NV_MOBILE_DISPLAY_TV_MASK | NV_MOBILE_DISPLAY_DFP_MASK )) {
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_ENABLE, temp);
//            }
    }

    if (newEvents & NV_MOBILE_FLAG_SCALE_MASK) {
//            if (stateChanges & NV_MOBILE_DISPLAY_SCALE_MASK) {
        centering = REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _MODE);
        if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE) temp = NV_HOTKEY_STATUS_DISPLAY_SCALED;
        else if (centering == NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER) temp = NV_HOTKEY_STATUS_DISPLAY_CENTERED;
        else temp = NV_HOTKEY_STATUS_DISPLAY_NATIVE;
//                hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, (stateReg & NV_MOBILE_DISPLAY_SCALE_MASK)?1:0);
        hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_CENTERING, temp);
//            }

        if (temp == NV_HOTKEY_STATUS_DISPLAY_SCALED) temp = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;
        else if (temp == NV_HOTKEY_STATUS_DISPLAY_CENTERED) temp = NV_CFGEX_GET_FLATPANEL_INFO_CENTERED;
        else if (temp == NV_HOTKEY_STATUS_DISPLAY_NATIVE) temp = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
        //
        // XXXscottl:
        // The following is a no-no on win2k (can't use the underlying
        // RtlWriteRegistryValue at raised irql).  The current feeling is
        // that we really don't need to update the registry for this any
        // longer anyway, so we'll comment this out.
        //
        //osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, temp);
    }

        //Now reset the event flags we've handled.  We do this after we've actually handled
        // the events (not explicitly required at this point, but seems cleanest) and in the
        // smallest possible amount of time between re-reading the register and writing it.
    if (newEvents) {
//            pDev->HotKeys.reg4CShadow = (U032)stateReg;            //Update our shadow register

        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
        temp &= ~newEvents;    //Reset the events we will handle.
            // LPL: possible race here -- another SSF bit gets set during our read-mod-write window,
            // and is cleared by us unintentionally (that's why this window is made intentionally
            // as small as possible by re-reading the register)
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, temp, head);
    }

    // Restore lock state
    RestoreLock(pDev, head, lock);

    }   //workaround: loop over both heads

}

//
// Service vertical blank interrupt.
//
VOID VBlank
(
    PHWINFO pDev
)
{
    PDACCRTCINFO pDacCrtcInfo;
    U032 pmc, pending;
    U032 head;
    U032 rmFinish;
    U008 CrtcIndex, CrtcIndex2 = 0;
    U032 MirrorEnabled = 0;

#ifdef RM_STATS
    pDev->Framebuffer.ServiceCount++;
#endif
    rmFinish = FALSE;

    NVRM_TRACE('VBLK');

    //
    // Save the CRTC index reg, since we may have interrupted someone doing
    // an access (CR44 could be pointing at either head, so save both heads).
    //
    CrtcIndex  = DAC_REG_RD08(NV_PRMCIO_CRX__COLOR, 0);
    CrtcIndex2 = 0;
    if (pDev->Dac.HalInfo.NumCrtcs == 2)
        CrtcIndex2 = DAC_REG_RD08(NV_PRMCIO_CRX__COLOR, 1);

    //
    // Disable I/O broadcast mode.  There are bugs in NV11's use of broadcast
    // mode where we can't reach HeadB through privSpace with this enabled.
    // It's possible that we've gotten an Int10 interrupt that enables
    // Broadcast mode before we've gotten the rmEnableVGA call.  We need
    // to disable this when servicing the interrupts, because these functions
    // need to access both Head A and Head B through privSpace.
    // We disable this also in mcService, but since VBlank gets called outside
    // of mcService as well, I decided to correct this one individually as well.
    //
    // Chips after NV11 have this fixed.
    //
    if (IsNV11(pDev) && !pDev->Vga.Enabled)
    {
        // store broadcast support
        MirrorEnabled = REG_RD_DRF(_PBUS, _DEBUG_1, _DISP_MIRROR);

        // disable broadcast support
        FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _DISABLE);
    }

    //
    // We're here because at least one of the PCRTC bits is pending.
    // Read the NV_PMC_INTR_0 register to figure out which one(s).
    //
    pending = 0;
    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    for (head = 0; head < MAX_CRTCS; head++)
    {
        // Move on if this crtc's interrupt isn't pending...
        if ((pending & (1 <<  head)) == 0)
            continue;

        // Scanout address updates...
        //
        // Since class07c's SET_IMAGE_FORMAT queues a VBlank callback (which we'll
        // handle "immediately" in VBlankProcessCallbacks below) and has an ASSERT
        // on the VBlankCounter value, we'll handle this update before the counter
        // is incremented.
        //
        VBlankUpdateImageOffsetFormat(pDev, head);

        // This head needs servicing...
        pDacCrtcInfo = &pDev->Dac.CrtcInfo[head];

        pDacCrtcInfo->VBlankToggle = 0;
        pDacCrtcInfo->VBlankCounter++;
        pDacCrtcInfo->IsVBlank = TRUE;

        //
        // Head 0 still gets unique treatment for things driven
        // by the older NV_VIDE0_FROM_MEMORY class and family.
        //
        if (head == 0)
        {
            rmFinish |= VBlankUpdateFlip(pDev, head);
            class63VBlank(pDev);
            VBlankUpdatePalette(pDev, head);
            rmFinish |= VBlankUpdateVideoScaler(pDev, head);
        }
#ifdef KDA_BUFFER_ENABLED
    //LPL: narrow this to just around cursor, if possible (was: bail on whole vblank routine)
    //Check if the VBIOS is overriding the HW cursor.  If not,
    // try to take the buffer semaphore to lock out the VBIOS
    // while we perform cursor updates.  Note that the flag being
    // checked here is first the general KDA semaphore, then the one specific
    // to the cursor area.  See fb.c for more detail on the KDA buffer.
        if ((fbKDATakeBufferSemaphore(pDev, 0) == RM_OK) && (pDev->DBfbKDASharedMem)) {
            U032 cellOffset = 0;
            if (fbKDAFindCursorCellOffset(pDev, head, &cellOffset) == RM_OK) {
                if (fbKDATakeCursorCellSemaphore(pDev, cellOffset, 0) == RM_OK) {
                // Cursor updates...
//                    if (pDev->DBfbKDACursorOverride) {
//                        SignalIconEndEvent();
//                        pDev->DBfbKDACursorOverride = FALSE;
//                    }
                    VBlankUpdateCursor(pDev, head);
                    fbKDAReleaseCursorCellSemaphore(pDev, cellOffset);
                } else {
//                    if (!pDev->DBfbKDACursorOverride) {
//                        SignalIconBeginEvent();
//                        pDev->DBfbKDACursorOverride = TRUE;
//                    }
                }
            } else {
                VBlankUpdateCursor(pDev, head);
            }
            fbKDAReleaseBufferSemaphore(pDev);
        } else {
            VBlankUpdateCursor(pDev, head);
        }
#else   //#ifdef KDA_BUFFER_ENABLED
        // Cursor updates...
        VBlankUpdateCursor(pDev, head);
#endif  //#ifdef KDA_BUFFER_ENABLED... else

        // Callback list...
        VBlankProcessCallbacks(pDev, head);

        pDacCrtcInfo->IsVBlank = FALSE;
        
        //
        // update the dither pattern if needed
        //
        if (pDev->Dac.HalInfo.CrtcInfo[head].fpMode == NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER)
        {    
            VBlankUpdateDither(pDev,head);
        }
    }

    if (pDev->Power.MobileOperation && pDev->HotKeys.enabled)
        VBlankCheckHotKeys(pDev);

    //
    // Update service count if no RM processing required (RM will increment this in mcService).
    //
    if (!rmFinish)
    {
#ifdef RM_STATS                    
        pDev->Chip.ServiceCount++;
#endif
        // reset the VBlank intrs we've handled
        if (pending & 0x1)
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);

        if (pending & 0x2)
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 1);
    }

    // Restore Broadcast support if needed
    if (IsNV11(pDev) && !(pDev->Vga.Enabled) && MirrorEnabled)
    {
        FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _ENABLE);
    }
    
    // restore crtc index for both heads
    DAC_REG_WR08(NV_PRMCIO_CRX__COLOR, CrtcIndex, 0);
    // Don't restore Head B if broadcast is enabled, since this doesn't work
    if ((pDev->Dac.HalInfo.NumCrtcs == 2) && (!MirrorEnabled))
        DAC_REG_WR08(NV_PRMCIO_CRX__COLOR, CrtcIndex2, 1);

    
    NVRM_TRACE('vblk');
}

//
// Return bitmask representing heads with pending
// vblank interrupts.
//
U032
VBlankPending
(
    PHWINFO pDev
)
{
    U032 pending = 0;

    //
    // TODO: call into HAL to get these.
    //
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)))
        pending |= 0x1;
    if (REG_RD32(NV_PMC_INTR_0) & (DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING)))
        pending |= 0x2;

    return pending;
}

void VBlankUpdateDither
(
    PHWINFO pDev,
    U032 Head
)
{
    U032 CurrentDitherPattern;
    U032 CurrentPLLCompatReg;
       
    // need to enable the dithering?
    // We wait 60 ticks before enabling to reduce change of weird visual
    // effects during startup.

    pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter++;

    if (pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter == 60)
    {
        // make sure we're in the correct HW cursor state for dithering
        DAC_FLD_WR_DRF_DEF(_PCRTC, _CURSOR_CONFIG, _CUR_BPP,   _32,   Head);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _CURSOR_CONFIG, _CUR_BLEND, _ROP,  Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIPE, _LONG, Head);

        //In the case where we are using a sw cursor the CrtcInfo structure
        //will not have been initialized. Thus things like cursor color 
        //format and cursor width/height will still be zero'd out. 
        //Incorrect color format can cause screen color corruption when
        //dithering is turned on.
        pDev->Dac.CrtcInfo[Head].CursorColorFormat = NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8;

        // enable dithering
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _ON,     Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_RB, _NORMAL, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_G, _NORMAL,  Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_Y, _NORMAL,  Head);
        
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Enabled dithering at vblank.\n");
    }
    else if (pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter > 60)
    {
#ifdef MACOS
        // we have next pattern, need to save it (quicky value lookup courtesy tb :-)
        CurrentDitherPattern = "\001\002\005\006"[(pDev->Dac.CrtcInfo[Head].VBlankCounter)&3];
#else
        // we have next pattern, need to save it (quicky value lookup courtesy tb :-)
        CurrentDitherPattern = "\002\002\002\002"[(pDev->Dac.CrtcInfo[Head].VBlankCounter)&3];
#endif
        
        // get current dither pattern.
        CurrentPLLCompatReg = DAC_REG_RD32(NV_PRAMDAC_PLL_COMPAT, Head);

        //clear the current bit pattern in PLL reg value
        // DITHER_RB bit is the beginning of 3 bit dither pattern
        CurrentPLLCompatReg = (~(0x7 << (0?NV_PRAMDAC_PLL_COMPAT_DITHER_RB))) &
                                 CurrentPLLCompatReg;

        //OR in the pattern
        CurrentPLLCompatReg = CurrentPLLCompatReg |
                                 (CurrentDitherPattern << (0?NV_PRAMDAC_PLL_COMPAT_DITHER_RB));

        //write pattern
        DAC_REG_WR32(NV_PRAMDAC_PLL_COMPAT, CurrentPLLCompatReg, Head);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\video\nv\videoobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* Video Manager *****************************\
*                                                                           *
* Module: videoobj.c                                                        *
*   Video engine objects are managed here.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <smp.h>
#include "nvhw.h"

//
// Forwards.
//

// NV_PATCHCORD_VIDEO (class60)
static RM_STATUS videoCreatePatchcordObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyPatchcordObj(PHWINFO, POBJECT);

// NV_VIDEO_SINK (class61)
static RM_STATUS videoCreateSinkObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroySinkObj(PHWINFO, POBJECT);

// NV_VIDEO_COLORMAP (class62)
static RM_STATUS videoCreateColormapObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColormapObj(PHWINFO, POBJECT);

// NV_VIDEO_FROM_MEMORY (class63)
static RM_STATUS videoCreateFromMemoryObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyFromMemoryObj(PHWINFO, POBJECT);

// NV_VIDEO_SCALER (class64)
static RM_STATUS videoCreateScalerObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyScalerObj(PHWINFO, POBJECT);

// NV_VIDEO_COLOR_KEY (class65)
static RM_STATUS videoCreateColorKeyObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *);
static RM_STATUS videoDestroyColorKeyObj(PHWINFO, POBJECT);

// NVXX_VIDEO_OVERLAY
static RM_STATUS videoCreateOverlayObj(PHWINFO, PCLASSOBJECT, U032, POBJECT *, VOID *);
static RM_STATUS videoDestroyOverlayObj(PHWINFO, POBJECT);

//
// Class lock macros (video engine allocations are per-device).
//
#define VIDEOCLASSLOCK_ISSET(pdev,bit)  (pDev->Video.ClassLocks & (1 << bit))
#define VIDEOCLASSLOCK_SET(pdev,bit)    (pDev->Video.ClassLocks |= (1 << bit))
#define VIDEOCLASSLOCK_CLEAR(pdev,bit)  (pDev->Video.ClassLocks &= ~(1 << bit))

//
// videoCreateObj
//
// Top-level create routine for video engine classes.
//
RM_STATUS videoCreateObj
(
    VOID*   pDevHandle,
    PCLASSOBJECT ClassObject,
    U032    Name,
    POBJECT *Object,
    VOID*   pCreateParms
)
{
    PHWINFO         pDev = (PHWINFO) pDevHandle;
    RM_STATUS       status = RM_OK;
    PCLASS          pClass = ClassObject->Base.ThisClass;
    U032            lockBit;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateObj\r\n"));

    //
    // Check allocation restrictions.
    //
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        if (VIDEOCLASSLOCK_ISSET(pDev, lockBit))
            return (RM_ERR_ILLEGAL_OBJECT);
        VIDEOCLASSLOCK_SET(pDev, lockBit);
    }

    //
    // Invoke class-specific create routine.    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoCreatePatchcordObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoCreateSinkObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoCreateColormapObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoCreateFromMemoryObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoCreateScalerObj(pDev, ClassObject, Name, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoCreateColorKeyObj(pDev, ClassObject, Name, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoCreateOverlayObj(pDev, ClassObject, Name, Object, pCreateParms);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    if (status != RM_OK)
    {
        if (lockBit != NO_LOCK)
            VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
        return (status); 
    }

    return (RM_OK);
}

RM_STATUS videoDestroyObj
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    PHWINFO             pDev = (PHWINFO) pDevHandle;
    RM_STATUS           status = RM_OK;
    PCOMMONOBJECT       pCommonObject;
    PCLASS              pClass;
    U032                lockBit;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyObj\r\n"));

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // A nice cast to make the code more readable.
    //
    pCommonObject = (PCOMMONOBJECT)Object;

    //
    // Clear per-device allocation lock bit if applicable.
    //
    pClass = Object->ThisClass;
    lockBit = CLASSDECL_FIELD(*pClass->ClassDecl, _LOCK);
    if (lockBit != NO_LOCK)
    {
        // ASSERT(VIDEOCLASSLOCK_ISSET(pDev, lockBit));
        VIDEOCLASSLOCK_CLEAR(pDev, lockBit);
    }

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // And finally delete the object itself    
    //
    switch (pClass->Type)
    {
        case NV_PATCHCORD_VIDEO:
            status = videoDestroyPatchcordObj(pDev, Object);
            break;
        case NV_VIDEO_SINK:
            status = videoDestroySinkObj(pDev, Object);
            break;
        case NV_VIDEO_COLORMAP:
            status = videoDestroyColormapObj(pDev, Object);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = videoDestroyFromMemoryObj(pDev, Object);
            break;
        case NV_VIDEO_SCALER:
            status = videoDestroyScalerObj(pDev, Object);
            break;
        case NV_VIDEO_COLOR_KEY:
            status = videoDestroyColorKeyObj(pDev, Object);
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoDestroyOverlayObj(pDev, Object);
            break;
        default:
            //
            // Should *never* happen because this create entry point was
            // already bound to this class type in class.c.
            //
            status = RM_ERR_ILLEGAL_OBJECT;
    }
    return (status);
}

//----------------------------------------------------------------------
// Video patchcord create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreatePatchcordObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    RM_STATUS status;
    U032 i;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreatePatchcordObj\r\n"));

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOPATCHCORD));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOPATCHCORD)*Object)->FanOut      = 0;
    ((PVIDEOPATCHCORD)*Object)->Source      = NULL;
    for (i = 0; i < MAX_GRPATCH_FANOUT; i++)
        ((PVIDEOPATCHCORD)*Object)->Destination[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOPATCHCORD)*Object)->CBase, 
                                      ((PVIDEOPATCHCORD)*Object)->CBase.ChID, 
                                      ((PVIDEOPATCHCORD)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyPatchcordObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyPatchcordObj\r\n"));

    //
    // NV_PATCHCORD_VIDEO requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video sink create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateSinkObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateSinkObj\r\n"));

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSINKOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    for (i = 0; i < MAX_GRPATCH_INPUT; i++)
        ((PVIDEOSINKOBJECT)*Object)->VideoInput[i] = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOSINKOBJECT)*Object)->CBase, 
                                      ((PVIDEOSINKOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOSINKOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroySinkObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroySinkObj\r\n"));

    //
    // NV_VIDEO_SINK requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video colormap create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColormapObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object
)
{
    U032 i;
    RM_STATUS status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateColormapObj\r\n"));

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORMAPOBJECT));
    if (status)
        return (status);

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoInput  = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->VideoOutput = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->ColorFormat = INVALID_COLOR_FORMAT;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Xlate       = NULL;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Start       = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->Length      = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyStart  = 0;
    ((PVIDEOCOLORMAPOBJECT)*Object)->DirtyLength = 0;
    for (i = 0; i < 256; i++)
        ((PVIDEOCOLORMAPOBJECT)*Object)->ColorMap[i] = (i << 16) | (i << 8) | i;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &((PVIDEOCOLORMAPOBJECT)*Object)->CBase, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CBase.ChID, 
                                      ((PVIDEOCOLORMAPOBJECT)*Object)->CInstance);
    if (status != RM_OK)
        osFreeMem(*Object);

    return (status);
}

static RM_STATUS videoDestroyColormapObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    RM_STATUS status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyColormapObj\r\n"));

    //
    // NV_VIDEO_COLORMAP requires no HAL support.
    //

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, Object, Object->ChID);
    if (status)
        return (status);
    
    // null out the color map object cached in pDev upon destruction
    if ((POBJECT)pDev->colormapObjectToNotify == Object)
    {
        pDev->colormapObjectToNotify = NULL;
    }

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video from memory create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateFromMemoryObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    RM_STATUS           status;
    PCLASS              pClass = ClassObject->Base.ThisClass;
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U008                *bytePtr;
    U032                i;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateFromMemoryObj\r\n"));

    //
    // Create the NV_VIDEO_FROM_MEMORY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOFROMMEMOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidFromMem;
    for (i = 0; i < sizeof (VIDEOFROMMEMOBJECT); i++)
       *bytePtr++ = 0;

    //
    // Setup any specific initialization values.
    //
    pVidFromMem->InitState               = 0;
    pVidFromMem->BBuffer[0].State        = BUFFER_IDLE;
    pVidFromMem->BBuffer[1].State        = BUFFER_IDLE;
    pVidFromMem->VBlankNotify[0].Pending = FALSE;
    pVidFromMem->VBlankNotify[1].Pending = FALSE;

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidFromMem->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, pClass->Type, &pVidFromMem->HalObject);
    if (status)
        return (status);

    //
    // HACK (scottl): There are several places in the RM that assume
    // the struct _def_common_object is at the head of class-specific
    // data structures like struct _def_video_from_memory_object
    // (most notably the call to fifoAddObject after we return from
    // here).  In order to allow these to continue to work, we do
    // the following completely bogus initialization.
    //
    (*Object)->Name          = UserName;
    (*Object)->Class         = ClassObject->Base.ThisClass;
    (*Object)->ThisClass     = ClassObject->Base.ThisClass;
    (*Object)->ChID          = ClassObject->Base.ChID;
    (*Object)->NotifyXlate   = NULL;
    (*Object)->NotifyAction  = 0;
    (*Object)->NotifyTrigger = FALSE;
    (*Object)->NotifyEvent   = NULL;

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidFromMem->CBase, 
                                      pVidFromMem->CBase.ChID, 
                                      pVidFromMem->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyFromMemoryObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOFROMMEMOBJECT pVidFromMem;
    U032                i;
    RM_STATUS           status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyFromMemoryObj\r\n"));

    //
    // A nice cast to make the code more readable.
    //
    pVidFromMem = (PVIDEOFROMMEMOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_FROM_MEMORY object.
    //

    //
    // Halt transfers.
    //
    class63StopTransfer(pDev, Object, 0, 0, 0);

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidFromMem->CBase.ChID, pVidFromMem->CInstance, Object->ThisClass->Type, &pVidFromMem->HalObject);

    //
    // Be sure to clear pending vblank notifies
    //
    for (i=0;i<2;i++)
    {
        pDev->Video.class63VBlankCount[i] = 0;
        pDev->DBclass63VBlankList[i] = NULL;
    }

    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pVidFromMem)
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidFromMem->CBase, pVidFromMem->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video scaler create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateScalerObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS              pClass = ClassObject->Base.ThisClass;
    RM_STATUS           status;
    PVIDEOSCALEROBJECT  pVidScaler;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateScalerObj\r\n"));

    //
    // Create the NV_VIDEO_SCALER object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOSCALEROBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidScaler->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, pClass->Type, &pVidScaler->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidScaler->CBase, 
                                      pVidScaler->CBase.ChID, 
                                      pVidScaler->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyScalerObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOSCALEROBJECT  pVidScaler;
    RM_STATUS           status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyScalerObj\r\n"));

    //
    // A nice cast to make the code more readable.
    //
    pVidScaler = (PVIDEOSCALEROBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_SCALER object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidScaler->CBase.ChID, pVidScaler->CInstance, Object->ThisClass->Type, &pVidScaler->HalObject);

    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidScaler->CBase, pVidScaler->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}


//----------------------------------------------------------------------
// Video colorkey create/destroy routines.
//----------------------------------------------------------------------
static RM_STATUS videoCreateColorKeyObj
(
    PHWINFO      pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *Object
)
{
    PCLASS                  pClass = ClassObject->Base.ThisClass;
    RM_STATUS               status;
    PVIDEOCOLORKEYOBJECT    pVidColorKey;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateColorKeyObj\r\n"));

    //
    // Create the NV_VIDEO_COLOR_KEY object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEOCOLORKEYOBJECT));
    if (status)
        return (status);

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)*Object;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidColorKey->CBase, ClassObject, UserName);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, pClass->Type, &pVidColorKey->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pVidColorKey->CBase, 
                                      pVidColorKey->CBase.ChID, 
                                      pVidColorKey->CInstance);
    if (status)
        return (status); 
        
    return (RM_OK);
}

static RM_STATUS videoDestroyColorKeyObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    PVIDEOCOLORKEYOBJECT    pVidColorKey;
    RM_STATUS               status;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyColorKeyObj\r\n"));

    //
    // A nice cast to make the code more readable.
    //
    pVidColorKey = (PVIDEOCOLORKEYOBJECT)Object;
    
    //
    // Destroy the NV_VIDEO_COLOR_KEY object.
    //

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pVidColorKey->CBase.ChID, pVidColorKey->CInstance, Object->ThisClass->Type, &pVidColorKey->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidColorKey->CBase, pVidColorKey->CBase.ChID); 
    if (status)
        return (status);

    return (osFreeMem(Object));
}

//----------------------------------------------------------------------
// Video overlay create/destroy routines.
//----------------------------------------------------------------------

//
// Return head number specified in alloc request.
//
static U032 videoGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
	RM_STATUS	status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;
        
    switch (pClass->Type)
    {
        case NV10_VIDEO_OVERLAY:
        {
			NV07C_ALLOCATION_PARAMETERS Class07cParams;
			status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
			if (status != RM_OK)
				return 0;

			Head = Class07cParams.logicalHeadId;
            break;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

static RM_STATUS videoCreateOverlayObj
(
    PHWINFO pDev,
    PCLASSOBJECT ClassObject,
    U032 Name,
    POBJECT *Object,
    VOID* pCreateParms
)
{
    RM_STATUS                   status;
    PCLASS                      pClass = ClassObject->Base.ThisClass;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;
    U008                        *bytePtr;
    int                         i;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoCreateOverlayObj\r\n"));

    //
    // Allocate space for the overlay object.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_OVERLAY_OBJECT));
    if (status)
        return (status);
        
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)*Object;

    //
    // Associate the head for the Video Scalar
    //
    pDev->Video.HalInfo.Head = videoGetHead(pClass, pCreateParms);
    if (pDev->Video.HalInfo.Head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: videoCreateOverlayObj: invalid logical head number: 0x%x\n", pDev->Video.HalInfo.Head));
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }


    if (IsNV11(pDev)) {
        AssocVideoScalar(pDev, pDev->Video.HalInfo.Head);
    }

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pOverlayObject;
    for (i = 0; i < sizeof (VIDEO_OVERLAY_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(*Object, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    status = nvHalVideoAlloc(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, &pOverlayObject->HalObject);
    if (status)
        return (status);

    //
    // Build a FIFO/Hash context for this object
    //
    status = fifoUpdateObjectInstance(pDev,
                                      &pOverlayObject->CBase, 
                                      pOverlayObject->CBase.ChID, 
                                      pOverlayObject->CInstance);
    if (status != RM_OK)
    {
        nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, pClass->Type, (VOID *)&pOverlayObject->HalObject);
        osFreeMem(*Object);
    }

    return (status);
}

static RM_STATUS videoDestroyOverlayObj
(
    PHWINFO pDev,
    POBJECT Object
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
    RM_STATUS                    status;
    PVIDEO_OVERLAY_OBJECT        pOverlayObject;

    VIDEO_PRINTF((DBG_LEVEL_INFO, "NVRM: videoDestroyOverlayObj\r\n"));

    VidLutCurDac.Head = pDev->Video.HalInfo.Head;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    nvHalVideoFree(pDev, pOverlayObject->CBase.ChID, pOverlayObject->CInstance, Object->ThisClass->Type, &pOverlayObject->HalObject);

    //
    // Video has been disabled, so refresh arb settings.
    //
    nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac);

    //
    // Clear active overlay object field is applicable.
    //
    if ((POBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject == (POBJECT) pOverlayObject)
    {
        pDev->Video.HalInfo.ActiveVideoOverlayObject = NULL;
        pDev->Video.HalInfo.Enabled = 0;
    }

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pOverlayObject->CBase, pOverlayObject->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks if chip requires it.
    //
    if (!IsNV10orBetter(pDev)) {
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[0].OverlayCallback));
        VBlankDeleteCallback(pDev, 0, &(pOverlayObject->Overlay[1].OverlayCallback));
    }

    return (osFreeMem(Object));
}

//-----------------------------------------------------------------------
// Video exception handling.
//-----------------------------------------------------------------------

//
// Service exception on class63 (NV_VIDEO_FROM_MEMORY) object transfer.
//
V032 videoFromMemService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEOFROMMEMOBJECT pVidFromMemObj;
    VOID *pVidHalObj;
    U032 buffsPending;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pVidFromMemObj = (PVIDEOFROMMEMOBJECT)pObject;
    if (pVidFromMemObj)
        pVidHalObj = (VOID *)&pVidFromMemObj->HalObject;
    else
        pVidHalObj = NULL;

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer 0 completed. 
            notifyFillNotifierArray( pDev, pVidFromMemObj->BufferObj.Base.NotifyXlate, 
                                     0, 
                                     0, 
                                     0, 
                                     NVFF8_NOTIFIERS_IMAGE_SCAN(i) );
                    
#ifdef DEBUG_TIMING            
            VIDEO_PRINTF((DEBUGLEVEL_WARNINGS, "Buffer 0 Completed. \n"));
            vmmOutDebugString("0N");
#endif // DEBUG_TIMING                
                    
            //
            // Do any OS specified action related to this notification.
            //
            if (pVidFromMemObj->BBuffer[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pVidFromMemObj,
                              NVFF8_NOTIFIERS_IMAGE_SCAN(i),
                              0, 
                              1, 
                              RM_OK, 
                              pVidFromMemObj->BBuffer[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, NV_VIDEO_FROM_MEMORY, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Service exceptions on class0XX (NVXX_VIDEO_OVERLAY) object transfers.
//
V032 videoOverlayService
(
    PHWINFO pDev,
    POBJECT pObject
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    VOID *pVidHalObj;
    U032 buffsPending, class;
    V032 intrStatus = 0;
    U032 i;

    //
    // Allow HAL chance to quiesce the video HW even if we don't
    // have an active overlay object.
    //
    pOverlayObject = (PVIDEO_OVERLAY_OBJECT)pObject;
    if (pOverlayObject)
    {
        class = pObject->ThisClass->Type;
        pVidHalObj = (VOID *)&pOverlayObject->HalObject;
    }
    else
    {
        //
        // If there is no active video object, the class will
        // be ignored anyway.   
        //
        class = 0;
        pVidHalObj = NULL;
    }

    //
    // Get buffer status first.
    //
    (void) nvHalVideoGetEventStatus(pDev, class, pVidHalObj, &buffsPending, &intrStatus);

    //
    // If video isn't enabled, then this interrupt was spurious.
    //
    if (!pDev->Video.HalInfo.Enabled)
        return intrStatus;

    //
    // Handle notify requests if a buffer needs servicing.
    //
    for (i = 0; i < MAX_OVERLAY_BUFFERS; i++)
    {
        if (buffsPending & (1 << i))
        {
            // Hardware buffer completed. 
            notifyFillNotifierArray(pDev, pOverlayObject->Common.Base.NotifyXlate, 
                                    0, // info32
                                    0, // info16
                                    RM_OK, 
                                    NV047_NOTIFIERS_SET_OVERLAY(i));

#ifdef DEBUG_TIMING            
            VIDEO_PRINTF((DBG_LEVEL_INFO, "Buffer Completed. \n"));
            vmmOutDebugString("1N");
#endif // DEBUG_TIMING

            //
            // Do any OS specified action related to this notification.
            //
            if (pOverlayObject->Overlay[i].NotifyAction)
            {
                osNotifyEvent(pDev, (POBJECT)pOverlayObject,
                              NV047_NOTIFIERS_SET_OVERLAY(i),
                              0, // Method
                              0, // Data
                              RM_OK, 
                              pOverlayObject->Overlay[i].NotifyAction);
            }
        }
    }

    //
    // Now call into HAL to finish processing exception (in this case,
    // queue up next buffer for processing).
    //
    (void) nvHalVideoServiceEvent(pDev, class, pVidHalObj, buffsPending, &intrStatus);

    return intrStatus;
}

//
// Update the POINT_OUT on behalf DDraw when panning the desktop
//
VOID videoUpdateWindowStart
(
    PHWINFO pDev,
    S016 deltaX,
    S016 deltaY
)
{
    PVIDEO_OVERLAY_OBJECT pOverlayObject;
    U016 pointoutX, pointoutY;
    U032 Data;
    RM_STATUS status;

    pOverlayObject = (PVIDEO_OVERLAY_OBJECT) pDev->Video.HalInfo.ActiveVideoOverlayObject;

    if (pOverlayObject->CBase.ThisClass->Type != NV10_VIDEO_OVERLAY)
        return;    // only applicable to class07a

    if (!deltaX && !deltaY)
        return;    // no delta to apply

    //
    // Resend the current Point Out data (class07a will adjust with
    // the new delta).
    //
    pointoutX = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_x;
    pointoutY = (S016)pOverlayObject->HalObject.Overlay[0].PointOut_y;

    Data = DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _X, pointoutX) |
           DRF_NUM(07A, _SET_OVERLAY_POINT_OUT, _Y, pointoutY);

    //
    // This method doesn't wait for the buffer to be released by the HW
    // and updates both POINT_OUT(0) and POINT_OUT(1) to the same value.
    //
    (VOID) nvHalVideoMethod(pDev,
                            NV10_VIDEO_OVERLAY,
                            (VOID *)&pOverlayObject->HalObject,
                            NV07A_SET_OVERLAY_POINT_OUT_A,
                            Data,
                            &status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BArray.h ===
#ifndef _BARRAY_H
#define _BARRAY_H

//////////////////////////////////////////////////////////////////////////////
// Array
//
template<class T,class R,const unsigned cuGrowSize = 16> class BArray
{
    //
    // members
    //
protected:
    T        *m_pData;
    unsigned  m_uCount;
    unsigned  m_uMax;

    //
    // methods
    //
protected:
    inline void grow (unsigned uMax)
    {
        uMax = (uMax + cuGrowSize - 1) & ~(cuGrowSize - 1);
        if (uMax > m_uMax)
        {
            T* pTemp = new T[uMax];
            if (m_pData)
            {
                for (unsigned u = 0; u < m_uCount; u++) pTemp[u] = m_pData[u];
                delete[] m_pData;
            }
            m_pData = pTemp;
            m_uMax = uMax;
        }
    }
    inline void init (void)
    {
        m_uCount = m_uMax = 0;
        m_pData = NULL;
    }
    inline void kill (void)
    {
        delete[] m_pData;
        init();
    }

public:
    inline R operator[] (unsigned u) const { return m_pData[u]; }

public:
    inline void setAt (unsigned uIndex,R data)       { if (uIndex >= m_uMax) grow (uIndex + 1); if (uIndex >= m_uCount) m_uCount = uIndex + 1; m_pData[uIndex] = data; }
    inline R    getAt (unsigned uIndex)        const { return m_pData[uIndex]; }
    
    inline int      isEmpty  (void) const { return m_uCount == 0; }
    inline unsigned getCount (void) const { return m_uCount; }

    inline void append (R data) { if (m_uCount >= m_uMax) grow (m_uCount + 1); m_pData[m_uCount++] = data; }

    inline void removeAll (void) { kill(); }

	inline BArray & operator=(const BArray &arr) { 
		init(); 
		grow(arr.m_uCount); 
		m_uCount = arr.m_uCount;
		for (unsigned i=0; i<arr.m_uCount; i++) {
			m_pData[i] = arr.m_pData[i];
		}

		return *this;
	}

    //
    // construction
    //
public:
    inline  BArray (void) { init(); }
    inline  BArray (const BArray &arr) { 
		init(); 
		grow(arr.m_uCount); 
		m_uCount = arr.m_uCount;
		for (unsigned i=0; i<m_uCount; i++) {
			m_pData[i] = arr.m_pData[i];
		}
	}
    inline ~BArray (void) { kill(); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\video\nv4\vidnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV04.c                                                         *
*   The NV4 specific HAL VIDEO routines reside in this file.                *
*   Class specific routines are contained in the corresponding modular      *
*   directory file.
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV04(VOID *);
RM_STATUS nvHalVideoAlloc_NV04(VOID *);
RM_STATUS nvHalVideoFree_NV04(VOID *);
RM_STATUS nvHalVideoMethod_NV04(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV04(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV04(VOID *);

// Exports needed by class-dependent files in modular/nv4.
RM_STATUS videoInit_NV04(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV04(S012d020);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV04(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;
    PHWINFO pDev;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision: 0x%x\n", pVideoControlArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pDev = (PHWINFO)pHalHwInfo->pDeviceId;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            //
            // For NV4 overlay, we need to be absolutely certain we start the pipeline
            // outside of active display, otherwise we can hang it during the kickoff.
            // Eventhough called from vblank, spin to guarantee we kickoff in blank.
            //
            if (DAC_REG_RD_DRF(_PCRTC, _INTR_EN_0, _VBLANK, 0))
            {
                while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x8)
                    // while in vertical blank, wait for active display
                    ;
                while ((REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x8) == 0x0)
                    // while in active display, wait for vertical blank
                    ;
            }

            // Now, we should definitely be in vertical blank
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _OFF);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV04(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision: 0x%x\n", pVideoAllocArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;

    //
    // Connect class-dependent kick off routine.
    //
    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV04;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoAllocArg->pHalObjInfo;
            pOverlayHalObj->KickOffProc = class047InitXfer_NV04;
            break;
        }
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV04(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision: 0x%x\n", pVideoFreeArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)   // if the desktop is using the scalar, don't shut off
                    REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV04(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE)
                REG_WR32(NV_PVIDEO_OVERLAY, 0);     // quick shutoff
            pHalHwInfo->pVideoHalInfo->Enabled = 0;
            pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
            pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            break;
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }

    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision: 0x%x\n", pVideoMethodArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV04(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV04(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV04(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision: 0x%x\n", pVideoGetEventStatusArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
    {
        //
        // Ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        //
        REG_WR32(NV_PVIDEO_INTR_0, NV_PVIDEO_INTR_0_NOTIFY_RESET);
        pVideoGetEventStatusArg->intrStatus = 0;
        return RM_OK;
    }

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63GetEventStatus_NV04(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV04(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision: 0x%x\n", pVideoServiceEventArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV04_VIDEO_OVERLAY:
            status = class047ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        case NV_VIDEO_FROM_MEMORY:
            status = class63ServiceEvent_NV04(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV04
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV04
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    // Force the hardware to be reset if this routine is called at all.
    // We need to revisit this fix for our modeset problems to see if there is
    // a better solution (JSUN).
    // 

    if (classNum == NV_VIDEO_FROM_MEMORY)
        if (pHalHwInfo->pVideoHalInfo->Enabled)
            return (RM_OK);
        
    REG_WR32(NV_PVIDEO_CONTROL_Y, DRF_DEF(_PVIDEO, _CONTROL_Y, _BLUR, _ON));
    REG_WR32(NV_PVIDEO_CONTROL_X, DRF_DEF(_PVIDEO, _CONTROL_X, _SMOOTHING, _ON)
                                | DRF_DEF(_PVIDEO, _CONTROL_X, _SHARPENING, _ON));

    REG_WR32(NV_PVIDEO_BUFF0_OFFSET, 0);
    REG_WR32(NV_PVIDEO_BUFF1_OFFSET, 0);

    REG_WR32(NV_PVIDEO_OE_STATE, 0);
    REG_WR_DRF_DEF(_PVIDEO, _OE_STATE, _CURRENT_BUFFER, _1);
    REG_WR32(NV_PVIDEO_SU_STATE, DRF_NUM(_PVIDEO, _SU_STATE, _BUFF0_IN_USE, 1)
                               | DRF_NUM(_PVIDEO, _SU_STATE, _BUFF1_IN_USE, 1));
    REG_WR32(NV_PVIDEO_RM_STATE, 0);

    REG_WR_DRF_DEF(_PVIDEO, _INTR_EN_0, _NOTIFY, _ENABLED);

    //
    // Initialize default conversion values
    // These value are per the NV3/4 manual as the default
    // offsets for YUV conversion
    //
    REG_WR32(NV_PVIDEO_CSC_ADJUST, 0x10000);
    REG_WR32(NV_PVIDEO_RED_CSC, 105);
    REG_WR32(NV_PVIDEO_GREEN_CSC, 62);
    REG_WR32(NV_PVIDEO_BLUE_CSC, 137);

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\video\nv10\vidnv10.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV10.c                                                         *
*   The NV10 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <nv10_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV10(VOID *);
RM_STATUS nvHalVideoAlloc_NV10(VOID *);
RM_STATUS nvHalVideoFree_NV10(VOID *);
RM_STATUS nvHalVideoMethod_NV10(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV10(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV10(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV10(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV10(S012d020);
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoAdjustScalarForTV_NV10(PHALHWINFO, U032);
VOID videoKickOffOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV10(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV10(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision: 0x%x\n", pVideoControlArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV10 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV10(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision: 0x%x\n", pVideoAllocArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV10;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV10(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision: 0x%x\n", pVideoFreeArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV10(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV10(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision: 0x%x\n", pVideoMethodArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV10(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV10(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV10(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV10(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision: 0x%x\n", pVideoGetEventStatusArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV10(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV10(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision: 0x%x\n", pVideoServiceEventArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV10(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV10_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV10(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    U032 data;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV10(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    //
    // We can't rely on our PvideoBufferCopy to tell us if the
    // hardware is still using a given buffer because we're getting
    // out of sync (somehow).
    // Go to the hardware directly to make sure we reclaim buffer
    // via stop when we need to.
#if 0
    if ((videoHwOwnsBuffer_NV10(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV10(pHalHwInfo, 1, pOverlayHalObj))) {
#endif
    if (REG_RD32(NV_PVIDEO_BUFFER))
    {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV10(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV10(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV10 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Adjust the video overlay position if running on TV.
//
//---------------------------------------------------------------------------

//	Because of the way the video scalar syncs with the CRTC, we need to adjust both CRTC timing
//  and make overlay adjustments differently for different devices. NV4 had this problem, NV5
//	was "fixed", and in NV10 the problem is back. NV12 and later device may or may not need
//	special adjustments.
VOID videoAdjustScalarForTV_NV10(PHALHWINFO pHalHwInfo, U032 buffNum)
{
    U032 head = pHalHwInfo->pVideoHalInfo->Head;
    U032 data;

    //
    // This isn't a problem on nv11 and later chips.
    //
    if (IsNV11orBetter_NV10(pHalHwInfo->pMcHalInfo))
        return ;

    if (pHalHwInfo->pDacHalInfo->CrtcInfo[head].DisplayType == DISPLAY_TYPE_TV)
    {
        data = REG_RD32(NV_PVIDEO_POINT_OUT(buffNum));
        REG_WR32(NV_PVIDEO_POINT_OUT(buffNum), data + NV10_VSCALAR_TV_ADJUST);
    }
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV10
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV10
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV10 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BConsole.h ===
#ifndef _BCONSOLE_H
#define _BCONSOLE_H

#define MAP_MESSAGE(msg,handler)        case msg: return handler(uMsg,wParam,lParam);
#define DECL_MESSAGE(handler)           LRESULT handler (UINT uMsg,WPARAM wParam,LPARAM lParam);

//////////////////////////////////////////////////////////////////////////////
// constants
//
#define WM_MUSTCLOSE        (WM_USER + 0)
#define WM_MOUSEWHEEL       0x020A

//////////////////////////////////////////////////////////////////////////////
// screen
//
class BScreen
{
    //
    // constants
    //
public:
    struct MESSAGE
    {
        HWND   hWnd;
        UINT   uMessage;
        WPARAM wParam;
        LPARAM lParam;
    };
    enum PMRESULT
    {
        consumed,
        buffer      // ask screen to buffer this message (retrieve with getMessage later)
    };

protected:
    typedef PMRESULT (*PROCESSMESSAGEFUNCTION)(void *pContext,UINT uMsg,WPARAM wParam,LPARAM lParam);

    enum THREAD_STATUS // order sensitive
    {
        threadStarting,
        threadRunning,
        threadStopped,
        threadAbnormalTermination
    };
    enum
    {
        flagCaretCreated = 1,
        flagCaretEnabled = 2,
        flagCaretOn      = 4,
    };

    //
    // members
    //
protected:
    SIZE      m_sizeBuffer;
    SIZE      m_sizeCell;
    WORD     *m_pawScreen;
    POINT     m_ptTopLeft;
    HINSTANCE m_hInstance;
    HWND      m_hWindow;
    INT      *m_paiSpacing;
    COLORREF  m_acolPalette[16];

    HFONT     m_hFont;
    BString   m_strFontName;
    HBITMAP   m_hbmpFontMap;     // if not empty then we have user defined
    SIZE      m_sizeFont;
    SIZE      m_sizeCellOrganization;   // user font only

    DWORD     m_dwFlags;
    DWORD     m_dwCaretCount;
    int       m_iCaretWidth;
    POINT     m_ptCursor;
    DWORD     m_dwCurrentColor;

    HANDLE           m_hThread;
    DWORD            m_dwThreadID;
    THREAD_STATUS    m_enumThreadStatus;    // current thread status
    CRITICAL_SECTION m_csThread;            // thread status interlock

    BLinkedList<MESSAGE,const MESSAGE&>  m_listMessage;
    PROCESSMESSAGEFUNCTION               m_pfnHandler;
    void                                *m_pMHContext;

protected:
    friend LRESULT CALLBACK __BScreen_windowProc   (HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend DWORD   WINAPI   __BScreen_createScreen (LPVOID lpContext);

    //
    // window interface
    //
protected:
    LRESULT windowProc (HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
    {
        switch (uMsg)
        {
            MAP_MESSAGE (WM_GETMINMAXINFO,  getMinMaxInfo)
            MAP_MESSAGE (WM_HSCROLL,        hScroll)
            MAP_MESSAGE (WM_VSCROLL,        vScroll)
            MAP_MESSAGE (WM_MOUSEWHEEL,     mouseWheel)
            MAP_MESSAGE (WM_PAINT,          paint)
            MAP_MESSAGE (WM_MUSTCLOSE,      mustClose)
            MAP_MESSAGE (WM_SETFOCUS,       setFocus)
            MAP_MESSAGE (WM_KILLFOCUS,      killFocus)

            MAP_MESSAGE (WM_CLOSE,          queueMessage)
            MAP_MESSAGE (WM_MOUSEMOVE,      queueMessage)
            MAP_MESSAGE (WM_LBUTTONDOWN,    queueMessage)
            MAP_MESSAGE (WM_LBUTTONUP,      queueMessage)
            MAP_MESSAGE (WM_RBUTTONDOWN,    queueMessage)
            MAP_MESSAGE (WM_RBUTTONUP,      queueMessage)
            MAP_MESSAGE (WM_KEYDOWN,        queueMessage)
            MAP_MESSAGE (WM_KEYUP,          queueMessage)
            MAP_MESSAGE (WM_CHAR,           queueMessage)
        }
        return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }

    DECL_MESSAGE (getMinMaxInfo);
    DECL_MESSAGE (hScroll);
    DECL_MESSAGE (vScroll);
    DECL_MESSAGE (mouseWheel);
    DECL_MESSAGE (paint);
    DECL_MESSAGE (mustClose);
    DECL_MESSAGE (setFocus);
    DECL_MESSAGE (killFocus);

    DECL_MESSAGE (queueMessage);

    //
    // methods
    //
protected:
    int  createFont    (void);
    void destroyFont   (void);
    int  createScreen  (void);
    void destroyScreen (void);
    void drawText      (HDC hdc,HDC hFontMap,const POINT *pt,const char *psz,DWORD dwCharCount,DWORD dwColor);
    
    void caretOff      (void);
    void caretOn       (void);
    void updateCaret   (BOOL bForceRecreate = FALSE);
    void scrollToCaret (void);

    void getMutex     (void) { EnterCriticalSection (&m_csThread); }
    void releaseMutex (void) { LeaveCriticalSection (&m_csThread); }

    void scrollBuffer (void);

    void forceProperSize (void)
    {
        RECT r;
        GetWindowRect (m_hWindow,&r);
        SetWindowPos  (m_hWindow,NULL,0,0,r.right - r.left,r.bottom - r.top,SWP_NOZORDER | SWP_NOMOVE);
    }

public:
    // messaging
    int  getMessage               (MESSAGE *pMessage); // only stores messages if no handler is installed, or when handler rejects
    void registerMessageHandler   (PROCESSMESSAGEFUNCTION pfn,void* pContext) { getMutex(); m_pfnHandler = pfn; m_pMHContext = pContext; releaseMutex(); }
    void unregisterMessageHandler (void)                                      { getMutex(); m_pfnHandler = NULL; releaseMutex(); }

    // sizes
    int setFont (const BString& strFont,int iRecommendedFontHeight = 0);
    int setFont (HBITMAP hbmpFont,unsigned uCellsInWidth,unsigned uCellsInHeight,unsigned uCellWidth,unsigned uCellHeight);

    // window
    void setCaption    (const BString& str)       { SetWindowText (m_hWindow,(const char*)str); }
    void setWindowPos  (int iX,int iY)            { SetWindowPos (m_hWindow,NULL,iX,iY,0,0,SWP_NOSIZE | SWP_NOZORDER); }
    void getWindowPos  (SIZE *pSize)        const { RECT r; GetWindowRect (m_hWindow,&r); pSize->cx = r.left; pSize->cy = r.top; }
    void setWindowSize (int iX,int iY)            { SetWindowPos (m_hWindow,NULL,0,0,iX,iY,SWP_NOMOVE | SWP_NOZORDER); }
    void getWindowSize (SIZE *pSize)        const { RECT r; GetWindowRect (m_hWindow,&r); pSize->cx = r.right - r.left; pSize->cy = r.bottom - r.top; }

    void hideWindow      (void)       { ShowWindow (m_hWindow,SW_MINIMIZE); ShowWindow (m_hWindow,SW_HIDE); }
    void showWindow      (void)       { ShowWindow (m_hWindow,SW_SHOW); ShowWindow (m_hWindow,SW_RESTORE); }
    int  isWindowVisible (void) const { return IsWindowVisible(m_hWindow); }

    // buffer
    void setCell   (int iX,int iY,WORD wValue)       { getMutex(); m_pawScreen[iY * m_sizeBuffer.cx + iX] = wValue; InvalidateRect (m_hWindow,NULL,FALSE); releaseMutex(); }
    WORD getCell   (int iX,int iY)             const { return m_pawScreen[iY * m_sizeBuffer.cx + iX]; }
    void fillCells (int iX,int iY,int iWidth,int iHeight,WORD wValue)
    {
        getMutex();
        WORD *line = &m_pawScreen[iY * m_sizeBuffer.cx + iX];
        for (int y = iY,cy = iHeight; cy; y++,cy--)
        {
            fillWord (line,wValue,iWidth);
            line += m_sizeBuffer.cx;
        }
        InvalidateRect (m_hWindow,NULL,FALSE);
        releaseMutex();
    }

    // palettes
    void setPalette (const COLORREF *pacolPalette) { getMutex(); memcpy (m_acolPalette,pacolPalette,sizeof(m_acolPalette)); InvalidateRect (m_hWindow,NULL,TRUE); releaseMutex(); }
    void getPalette (COLORREF *pacolPalette) const { memcpy (pacolPalette,m_acolPalette,sizeof(m_acolPalette)); }

    // print
    void  setColor   (DWORD dwIndex)                { m_dwCurrentColor = dwIndex; }
    DWORD getColor   (void)                         { return m_dwCurrentColor; }
    void  print      (const BString& str);
    void  clear2EOL  (void);

    // cursor
    int  gotoXY    (int iX,int iY)
    { 
        if ((iX < 0) 
         || (iY < 0) 
         || (iX >= m_sizeBuffer.cx) 
         || (iY >= m_sizeBuffer.cy)) return 0; 
        getMutex(); 
        caretOff(); 
        m_ptCursor.x = iX; 
        m_ptCursor.y = iY; 
        caretOn(); 
        releaseMutex(); 
        return 1; 
    }
    int  gotoXY    (const POINT &pt)         { return gotoXY(pt.x,pt.y); }
    void getXY     (POINT *pPt)        const { *pPt = m_ptCursor; }
    void getXY     (int *piX,int *piY) const { *piX = m_ptCursor.x; *piY = m_ptCursor.y; }
    void showCaret (void)                    
    { 
        getMutex(); 
        if (!m_dwCaretCount // do not allow below zero
         || !(--m_dwCaretCount))
        {
            m_dwFlags |=  flagCaretEnabled; 
            updateCaret();
        }
        releaseMutex(); 
    }
    void hideCaret (void)
    { 
        getMutex(); 
        if (++m_dwCaretCount)
        {
            m_dwFlags &= ~flagCaretEnabled; 
            updateCaret(); 
        }
        releaseMutex(); 
    }
    void setCaretWidth (int iWidth)
    {
        getMutex(); 
        iWidth        = max(iWidth,2);
        m_iCaretWidth = min(iWidth,m_sizeCell.cx);
        updateCaret (TRUE);
        releaseMutex();
    }

public:
    BOOL create  (HINSTANCE hInstance,int iBufferWidth = 80,int iBufferHeight = 25);
    BOOL destroy (void);

public:
    BScreen (void);
    ~BScreen (void);
};

//////////////////////////////////////////////////////////////////////////////
// console
//
class BConsole
{
    //
    // constants
    //
public:
    enum READRESULT
    {
        closed,
        success,

        user = 10000,
    };
protected:
    enum
    {
        flagScreenClosed   = 1,
        flagOverwrite      = 2,
        flagHistory        = 4, // command history is enabled
        flagNameCompletion = 8, // complete names when TAB is pressed

        flagResetCmdLine   = 0x80000000,
    };

    //
    // types
    //
public:
    typedef READRESULT (*READIDLEFUNC)(void *pContext);

    //
    // members
    //
protected:
    BScreen m_Screen;
    SIZE    m_sizeBuffer;
    DWORD   m_dwFlags;
    DWORD   m_dwHistoryCount;

    BLinkedList<BString,const BString&> m_listHistory;
    BLinkedList<BString,const BString&> m_listName;

    //
    // methods
    //
protected:
    void showLine (const BString& strLine,const POINT& ptStart,DWORD dwCrsr);
    int  findName (const BString& strMatch,BString *pstrResult,BOOL bList);

public:
    // con in and out
    void       reset       (void); // move current command line to cursor
    void       print       (const char *pszFormat,...);
    READRESULT read        (const BString& strPrompt,BString *pstrText,READIDLEFUNC pfnIdleFunc = NULL,void *pContext = NULL);
    
    void       clear2EOL   (void) { m_Screen.clear2EOL(); }

    // state
    void enableCommandHistory  (void) { m_dwFlags |=  flagHistory; }
    void disableCommandHistory (void) { m_dwFlags &= ~flagHistory; } // disable command history
    void enableNameCompletion  (void) { m_dwFlags |=  flagNameCompletion; }
    void disableNameCompletion (void) { m_dwFlags &= ~flagNameCompletion; }

    // UI
    void setCaption    (const BString& str) { m_Screen.setCaption (str); }
    void setWindowPos  (int iX,int iY)      { m_Screen.setWindowPos (iX,iY); }
    void setWindowSize (int iX,int iY)      { m_Screen.setWindowSize (iX,iY); }

    void hideWindow      (void)       { m_Screen.hideWindow(); }
    void showWindow      (void)       { m_Screen.showWindow(); }
    int  isWindowVisible (void) const { return m_Screen.isWindowVisible(); }

    // name completion
    void ncAdd       (const BString& str) { m_listName.addHead (str); }
    void ncRemove    (const BString& str) { BPosition pos = m_listName.findForward(str,m_listName.getHeadPosition()); if (pos) { m_listName.removeAt (pos); } }
    void ncRemoveAll (void)               { m_listName.removeAll(); }

public:
    BOOL create  (HINSTANCE hInstance,int iBufferWidth = 80,int iBufferHeight = 25);
    BOOL destroy (void);

public:
    BConsole (void);
    ~BConsole (void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BException.h ===
#ifndef _BEXCEPTION_H
#define _BEXCEPTION_H

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// exception
//
class BException
{
public:
    //
    // codes
    //
    enum EXCEPTIONCODE
    {
        outOfMemory = 0x80000000,
    };

protected:
    EXCEPTIONCODE m_ecErrorCode;

public:
    BException (EXCEPTIONCODE ecErrorCode) { m_ecErrorCode = ecErrorCode; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\resman\kernel\video\nv20\vidnv20.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*********************** Chip Specific HAL VIDEO Routines ******************\
*                                                                           *
* Module: VIDNV20.c                                                         *
*   The NV20 specific HAL VIDEO routines reside in this file.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <stddef.h>    // for size_t
#include <nv_ref.h>
#include <nv20_ref.h>
#include <nvrm.h>
#include <nv20_hal.h>
#include "nvhw.h"
#include "nvhalcpp.h"

// HAL interface forwards.
RM_STATUS nvHalVideoControl_NV20(VOID *);
RM_STATUS nvHalVideoAlloc_NV20(VOID *);
RM_STATUS nvHalVideoFree_NV20(VOID *);
RM_STATUS nvHalVideoMethod_NV20(VOID *);
RM_STATUS nvHalVideoGetEventStatus_NV20(VOID *);
RM_STATUS nvHalVideoServiceEvent_NV20(VOID *);

// Exports needed by class-dependent files in modular/nv10.
RM_STATUS videoInit_NV20(PHALHWINFO, U032);
U016 videoConvertScaleFactor_NV20(S012d020);
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO, U032, PVIDEO_OVERLAY_HAL_OBJECT);
VOID videoKickOffOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);
VOID videoStopOverlay_NV20(PHALHWINFO, PVIDEO_OVERLAY_HAL_OBJECT, U032);

// Exception handling routines.
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000);
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000);

//
// nvHalVideoControl
//
RM_STATUS
nvHalVideoControl_NV20(VOID *arg)
{
    PVIDEOCONTROLARG_000 pVideoControlArg = (PVIDEOCONTROLARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoControlArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoControlArg->id != VIDEO_CONTROL_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoControl bad revision: 0x%x\n", pVideoControlArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoControlArg->pHalHwInfo;
    switch (pVideoControlArg->cmd)
    {
        case VIDEO_CONTROL_UPDATE:
        case VIDEO_CONTROL_LOAD:
            break;
        case VIDEO_CONTROL_INIT:
        {
            U032 i;

            pVideoControlArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;

            //
            // Establish default register settings since we
            // don't use the videoInit_NV10 routine when doing
            // buffer kickoffs for these classes.
            //
            for (i = 0; i < 2; i++)
            {
                REG_WR32(NV_PVIDEO_LUMINANCE(i),
                         DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
                         DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
                REG_WR32(NV_PVIDEO_CHROMINANCE(i),
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
                         DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
                REG_WR32(NV_PVIDEO_DS_DX(i),
                         DRF_DEF(_PVIDEO, _DS_DX, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_DT_DY(i),
                         DRF_DEF(_PVIDEO, _DT_DY, _RATIO, _UNITY));
                REG_WR32(NV_PVIDEO_POINT_IN(i), 0);
                REG_WR32(NV_PVIDEO_SIZE_IN(i), 0xFFFFFFFF);
            }
            break;
        }
        case VIDEO_CONTROL_DESTROY:
        case VIDEO_CONTROL_ENABLE:
            break;
        case VIDEO_CONTROL_UNLOAD:
        case VIDEO_CONTROL_DISABLE:
            //
            // make the NV20 overlay window disappear by setting the
            // SIZE_OUT register to zero ... to reenable, the old/new
            // overlay classes will need to come in again and hit the methods
            //
            REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
            REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }
    return (RM_OK);
}

//
// nvHalVideoAlloc
//
RM_STATUS
nvHalVideoAlloc_NV20(VOID *arg)
{
    PVIDEOALLOCARG_000 pVideoAllocArg = (PVIDEOALLOCARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoAllocArg->pHalHwInfo;
    RM_STATUS status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pVideoAllocArg->id != VIDEO_ALLOC_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoAlloc bad revision: 0x%x\n", pVideoAllocArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    pHalHwInfo = pVideoAllocArg->pHalHwInfo;

    switch (pVideoAllocArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidFromMemHalObj->KickOffProc = class63InitXfer_NV20;
            break;
        }
        case NV_VIDEO_SCALER:
        {
            PVIDEOSCALERHALOBJECT pVidScalerHalObj;

            pVidScalerHalObj = (PVIDEOSCALERHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidScalerHalObj->DeltaDuDx = 0;
            pVidScalerHalObj->DeltaDvDy = 0;
            pVidScalerHalObj->xStart = 0;
            pVidScalerHalObj->yStart = 0;
            break;
        }
        case NV_VIDEO_COLOR_KEY:
        {
            PVIDEOCOLORKEYHALOBJECT pVidColorKeyHalObj;

            pVidColorKeyHalObj = (PVIDEOCOLORKEYHALOBJECT)pVideoAllocArg->pHalObjInfo;
            pVidColorKeyHalObj->ColorFormat = 0;
            pVidColorKeyHalObj->Color = 0;
            pVidColorKeyHalObj->xClipMin = 0;
            pVidColorKeyHalObj->xClipMax = 0;
            pVidColorKeyHalObj->yClipMin = 0;
            pVidColorKeyHalObj->yClipMax = 0;
            break;
        }
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }

    return (status);
}

//
// nvHalVideoFree
//
RM_STATUS
nvHalVideoFree_NV20(VOID *arg)
{
    PVIDEOFREEARG_000 pVideoFreeArg = (PVIDEOFREEARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoFreeArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoFreeArg->id != VIDEO_FREE_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoFree bad revision: 0x%x\n", pVideoFreeArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoFreeArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        {
            PHALHWINFO pHalHwInfo;
            PVIDEOFROMMEMHALOBJECT pVidFromMemHalObj;

            pHalHwInfo = pVideoFreeArg->pHalHwInfo;
            pVidFromMemHalObj = (PVIDEOFROMMEMHALOBJECT)pVideoFreeArg->pHalObjInfo;
            //
            // Just to be sure, shut down the overlay.  Need to verify this is YUV.
            //
            if (((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8)
                || ((pVidFromMemHalObj->Format & 0x0FFFFFFF) == NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8))
            {
                // if the desktop is using the scalar, don't shut off
                if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType != DISPLAY_TYPE_DUALSURFACE) {
                    // activate a PVIDEO_STOP and disappear the window by
                    // setting SIZE_OUT to 0
                    REG_WR32(NV_PVIDEO_STOP,
                             DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                             DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
                    
                    REG_WR32(NV_PVIDEO_SIZE_OUT(0), 0);
                    REG_WR32(NV_PVIDEO_SIZE_OUT(1), 0);
                }
                pHalHwInfo->pVideoHalInfo->Enabled = 0;
                pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 0;
                pHalHwInfo->pVideoHalInfo->ScaleFactor = 0;
            }

            // return the TV to desktop if we are in dual surface mode
            if (pHalHwInfo->pDacHalInfo->CrtcInfo[0].DisplayType == DISPLAY_TYPE_DUALSURFACE)
                class63DualSurfaceDesktop_NV20(pHalHwInfo, DISPLAY_TYPE_DUALSURFACE);
            break;
        }
        case NV_VIDEO_SCALER:
        case NV_VIDEO_COLOR_KEY:
            break;
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
        {
            PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;

            pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoFreeArg->pHalObjInfo;
            videoStopOverlay_NV20(pVideoFreeArg->pHalHwInfo, pOverlayHalObj, 0);
            pVideoFreeArg->pHalHwInfo->pVideoHalInfo->Enabled = 0;
            break;
        }
        default:
            return RM_ERR_ILLEGAL_OBJECT;
    }
    
    return (RM_OK);
}

//
// nvHalVideoMethod
//
// This entry point directs video engine object methods
// to the correct class-dependent handler.
//
RM_STATUS
nvHalVideoMethod_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOMETHODARG_000 pVideoMethodArg = (PVIDEOMETHODARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoMethodArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoMethodArg->id != VIDEO_METHOD_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoMethod bad revision: 0x%x\n", pVideoMethodArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoMethodArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
            pVideoMethodArg->mthdStatus = class63Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_SCALER:
            pVideoMethodArg->mthdStatus = class64Method_NV20(pVideoMethodArg);
            break;
        case NV_VIDEO_COLOR_KEY:
            pVideoMethodArg->mthdStatus = class65Method_NV20(pVideoMethodArg);
            break;
        case NV04_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class047Method_NV20(pVideoMethodArg);
            break;
        case NV10_VIDEO_OVERLAY:
            pVideoMethodArg->mthdStatus = class07aMethod_NV20(pVideoMethodArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoGetEventStatus
//
// This entry point fetches video buffer status.
//
RM_STATUS
nvHalVideoGetEventStatus_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg = (PVIDEOGETEVENTSTATUSARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoGetEventStatusArg->id != VIDEO_GET_EVENT_STATUS_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoGetEventStatus bad revision: 0x%x\n", pVideoGetEventStatusArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    //
    // Make sure video is enabled
    //
    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;
    if (!pHalHwInfo->pVideoHalInfo->Enabled)
	{
        // ignore this interrupt because we do not care
        // what caused it because the enable has not been set
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);

#if 0
        //
        // XXX (scottl):
        //
        // I'm going to ignore the NV_VIDEO_FROM_MEMORY class in 
        // this case because it makes things easier.
        //

        //
        // We deviate here between classes.  This is probably unnecessary,
        // but I don't want to mess around.
        //
        if (pVideoGetEventStatusArg->classNum == NV_VIDEO_FROM_MEMORY)
        {
            // Return the current interrupt pending state. We could be here because of a
            // STOP_ACTIVE ... reading NV_PVIDEO_INTR one more time ensures the writes
            // were flushed (seen on IKOS, but in general shouldn't hurt.

            intr0 = REG_RD32(NV_PVIDEO_INTR);
            pVideoGetEventStatusArg->intrStatus =
                (intr0 & (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
                          (DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING))));
        }
        else
        {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
#endif

        //
        // If we're here, it means a video's classDestroy has come in before this STOP
        // or buffer completion intr ... this means 2 things:
        //
        //      - we can't use the pOverlayObject state, since it's already been freed
        //      - based on register state only we need to allow a STOP to still reclaim
        //          all buffers, otherwise we may leave the last buffer visible
        //
        if (REG_RD32(NV_PVIDEO_BUFFER) == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                           DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING))) {
            // clear a pending stop (destroy method can beat a STOP intr coming in)
            REG_WR_DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE);
        }
        pVideoGetEventStatusArg->intrStatus = 0;
        pVideoGetEventStatusArg->events = 0;
        return RM_OK;
	}

    switch (pVideoGetEventStatusArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoGetEventStatus_NV20(pVideoGetEventStatusArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//
// nvHalVideoServiceEvent
//
// This entry point handles video engine exceptions.
//
RM_STATUS
nvHalVideoServiceEvent_NV20(VOID *arg)
{
    RM_STATUS status = RM_OK;
    PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg = (PVIDEOSERVICEEVENTARG_000)arg;
    PHALHWINFO pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pVideoServiceEventArg->id != VIDEO_SERVICE_EVENT_000)
    {
        VIDEO_PRINTF((DBG_LEVEL_ERRORS, "NVRM: nvHalVideoServiceEvent bad revision: 0x%x\n", pVideoServiceEventArg->id));
        DBG_BREAKPOINT();
        return (RM_ERR_VERSION_MISMATCH);
    }

    switch (pVideoServiceEventArg->classNum)
    {
        case NV_VIDEO_FROM_MEMORY:
        case NV04_VIDEO_OVERLAY:
        case NV10_VIDEO_OVERLAY:
            status = videoServiceEvent_NV20(pVideoServiceEventArg);
            break;
        default:
            status = RM_ERR_ILLEGAL_OBJECT;
            break;
    }
    
    return (status);
}

//--------------------------------------------------------------------
// NV20_VIDEO_OVERLAY implementation (class07a)
//--------------------------------------------------------------------


//--------------------------------------------------------------------
// Utility routines
//--------------------------------------------------------------------
BOOL videoHwOwnsBuffer_NV20(PHALHWINFO pHalHwInfo, U032 buffer_number, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj)
{
    // Check if stop is active.
    if (pOverlayHalObj->PvideoStopActive)
        return TRUE;

    switch (buffer_number){
        case 0:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_PENDING))
            return TRUE;
          break;
        case 1:
          if (pOverlayHalObj->PvideoBufferCopy & DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_PENDING))
            return TRUE;
          break;
    }
    return FALSE;
}

VOID videoKickOffOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 buffNum)
{
    U032 data;

    // Enable the overlay
    pHalHwInfo->pVideoHalInfo->Enabled = 1;

    // Enable the interrupt for the overlay. 
    data = REG_RD32(NV_PVIDEO_INTR_EN);
    if (buffNum == 0)
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_0, NV_PVIDEO_INTR_EN_BUFFER_0_ENABLED));
    else
        REG_WR32(NV_PVIDEO_INTR_EN, data | DRF_NUM(_PVIDEO, _INTR_EN, _BUFFER_1, NV_PVIDEO_INTR_EN_BUFFER_1_ENABLED));

    // BufferBase is an offset value here
    data = (U032)((size_t)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferBase);
    REG_WR32(NV_PVIDEO_BASE(buffNum), data);
    
    data = (U032)pOverlayHalObj->Overlay[buffNum].OverlayCtxDma->BufferSize;
    REG_WR32(NV_PVIDEO_LIMIT(buffNum), data-1);

    if (pOverlayHalObj->PvideoStopActive == 0) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }

    // Kick Off the buffer to Hardware.
    REG_WR32(NV_PVIDEO_BUFFER, pOverlayHalObj->PvideoBufferCopy);
}

//
// videoStopOverlay
//
// Handle StopOverlay method for both classes.
//
VOID videoStopOverlay_NV20(PHALHWINFO pHalHwInfo, PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj, U032 data)
{
    //
    // We can't rely on our PvideoBufferCopy to tell us if the
    // hardware is still using a given buffer because we're getting
    // out of sync (somehow).
    // Go to the hardware directly to make sure we reclaim buffer
    // via stop when we need to.
#if 0
    if ((videoHwOwnsBuffer_NV10(pHalHwInfo, 0, pOverlayHalObj)) ||
        (videoHwOwnsBuffer_NV10(pHalHwInfo, 1, pOverlayHalObj))) {
#endif
    if (REG_RD32(NV_PVIDEO_BUFFER)) {
        pOverlayHalObj->PvideoStopActive = 1;
        if (data) { //NV_PVIDEO_STOP_METHOD_NORMALLY 
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _NORMALLY));
        } else {
            REG_WR32(NV_PVIDEO_STOP,
                     DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _ACTIVE) |
                     DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        }
    }
    else {
        pOverlayHalObj->PvideoStopActive = FALSE;
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
    }
}

//
// Exception data fetcher
//
// Let's RM know which buffer (if any) needs servicing.
//
static RM_STATUS videoGetEventStatus_NV20(PVIDEOGETEVENTSTATUSARG_000 pVideoGetEventStatusArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    U032 intr0;
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pVideoGetEventStatusArg->pHalHwInfo;

    //
    // Default is that none of the buffers needs servicing.  So tell
    // RM to bypass the nvHalVideoServiceEvent handler.
    //    
    pVideoGetEventStatusArg->events = 0;
    
    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoGetEventStatusArg->pHalObjInfo;
    pVideoGetEventStatusArg->intrStatus = 0;

    //
    // Find out which buffer(s) are pending.
    //
    intr0 = REG_RD32(NV_PVIDEO_INTR);
    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_0, NV_PVIDEO_INTR_BUFFER_0_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _0_USE, NV_PVIDEO_BUFFER_0_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 0);
    }

    if (intr0 & DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_PENDING)) {
        REG_WR_DRF_NUM(_PVIDEO, _INTR, _BUFFER_1, NV_PVIDEO_INTR_BUFFER_1_RESET);
        pOverlayHalObj->PvideoBufferCopy &= ~(DRF_NUM(_PVIDEO, _BUFFER, _1_USE, NV_PVIDEO_BUFFER_1_USE_SET));
        pVideoGetEventStatusArg->events |= (1 << 1);
    }

    return RM_OK;
}

//
// video exception handler
//
static RM_STATUS videoServiceEvent_NV20(PVIDEOSERVICEEVENTARG_000 pVideoServiceEventArg)
{
    PVIDEO_OVERLAY_HAL_OBJECT pOverlayHalObj;
    PHALHWINFO pHalHwInfo;

    pHalHwInfo = pVideoServiceEventArg->pHalHwInfo;

    pOverlayHalObj = (PVIDEO_OVERLAY_HAL_OBJECT)pVideoServiceEventArg->pHalObjInfo;

    //
    // We shouldn't be in here if we don't have a valid overlay
    // object, but make sure it's non-null just the same...
    //
    if (pOverlayHalObj && pOverlayHalObj->PvideoStopActive &&
        (pOverlayHalObj->PvideoBufferCopy == (DRF_DEF(_PVIDEO, _BUFFER, _0_USE, _NOT_PENDING) |
                                              DRF_DEF(_PVIDEO, _BUFFER, _1_USE, _NOT_PENDING)))) {
        REG_WR32(NV_PVIDEO_STOP,
                 DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE) |
                 DRF_DEF(_PVIDEO, _STOP, _METHOD, _IMMEDIATELY));
        pOverlayHalObj->PvideoStopActive = 0;
    }

    //
    // On NV20 it doesn't look like we return our current NV_PVDEO_INTR
    // value for the overlay classes.
    //
    if (pVideoServiceEventArg->classNum == NV_VIDEO_FROM_MEMORY)
        pVideoServiceEventArg->intrStatus =
            (REG_RD32(NV_PVIDEO_INTR) &
             (DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _PENDING) |
              DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _PENDING)));
    else
        pVideoServiceEventArg->intrStatus = 0;

    return RM_OK;
}

//
// Convert the ds/dX or dt/dY architectural scale factor (in 12.20) into the 
// hardware's step factor (in 1.11).
//
// Basically, 1 / (ds/dX) = hardware step, considering format conversions
//
U016 videoConvertScaleFactor_NV20
(
    S012d020 scale
)
{
    //
    // First convert the 12.20 into 32.0 and divide it out of 1.  To have it
    // result in a 1.11, premultiply the equation by 0x800.
    //
    // Note that we're making an important assumption that scale will always be
    // greater than 1.0!!
    //
    if (scale > 0x100000)
        scale = 0x100000;

    return( (U016)((scale * 0x800) / 0x100000) );
}

//
// videoInit
//
// Generic video engine initialization.
//
RM_STATUS videoInit_NV20
(
    PHALHWINFO pHalHwInfo,
    U032 classNum
)
{
    if (pHalHwInfo->pVideoHalInfo->Enabled)
        return (RM_OK);
        
    REG_WR32(NV_PVIDEO_OFFSET(0), 0);
    REG_WR32(NV_PVIDEO_OFFSET(1), 0);

    // Make sure we're in a known idle state.
    // Wait for any HW owned buffers to complete (IN_USE bits go to 0).
    while (REG_RD32(NV_PVIDEO_BUFFER))
        ;

    // Next, complete an active StopOverlay and reset PGRAPH_INTR
    REG_WR32(NV_PVIDEO_STOP, DRF_DEF(_PVIDEO, _STOP, _OVERLAY, _INACTIVE));
    REG_WR32(NV_PVIDEO_INTR, DRF_DEF(_PVIDEO, _INTR, _BUFFER_0, _RESET) |
                               DRF_DEF(_PVIDEO, _INTR, _BUFFER_1, _RESET));

    REG_WR32(NV_PVIDEO_INTR_EN, DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_0, _ENABLED) |
                                DRF_DEF(_PVIDEO, _INTR_EN, _BUFFER_1, _ENABLED));

    // set SIZE_IN to infinite values (ImageScan.size isn't correct for NV20 HW)
    REG_WR32(NV_PVIDEO_SIZE_IN(0), 0xFFFFFFFF);
    REG_WR32(NV_PVIDEO_SIZE_IN(1), 0xFFFFFFFF);

    // cleanup any previous values
    REG_WR32(NV_PVIDEO_POINT_IN(0), 0);
    REG_WR32(NV_PVIDEO_POINT_IN(1), 0);

    REG_WR32(NV_PVIDEO_BASE(0), 0);
    REG_WR32(NV_PVIDEO_BASE(1), 0);

    REG_WR32(NV_PVIDEO_LIMIT(0), pHalHwInfo->pFbHalInfo->Limit[0]);
    REG_WR32(NV_PVIDEO_LIMIT(1), pHalHwInfo->pFbHalInfo->Limit[0]);

    REG_WR32(NV_PVIDEO_LUMINANCE(0), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));
    REG_WR32(NV_PVIDEO_LUMINANCE(1), DRF_DEF(_PVIDEO, _LUMINANCE, _CONTRAST, _UNITY) |
             DRF_DEF(_PVIDEO, _LUMINANCE, _BRIGHTNESS, _UNITY));

    REG_WR32(NV_PVIDEO_CHROMINANCE(0), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));
    REG_WR32(NV_PVIDEO_CHROMINANCE(1), DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_COS, _UNITY) |
             DRF_DEF(_PVIDEO, _CHROMINANCE, _SAT_SIN, _UNITY));

    //
    // Initialize default arbitration settings
    //
    pHalHwInfo->pVideoHalInfo->Enabled = 1;
    pHalHwInfo->pVideoHalInfo->ColorKeyEnabled = 1;
    pHalHwInfo->pVideoHalInfo->ScaleFactor = 1;

    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BList.h ===
#ifndef _BLIST_H
#define _BLIST_H

//////////////////////////////////////////////////////////////////////////////
// Double Linked List
//
template<class T,class R,BOOL ts = FALSE> class BLinkedList
{
    //
    // private structures
    //
protected:
    struct ENTRY
    {
        ENTRY *m_pNext;
        ENTRY *m_pPrev;
        T      m_Data;
    };

    //
    // members
    //
protected:
    ENTRY *m_pHead;
    ENTRY *m_pTail;
protected:
    CRITICAL_SECTION m_csThread;

    //
    // methods
    //
public:
    inline void addHead (R data); // require operator=
    inline void addTail (R data); // require operator=
    inline void addHead (const BLinkedList<T,R,ts>& data); // require operator=
    inline void addTail (const BLinkedList<T,R,ts>& data); // require operator=

    inline void removeHead (void);
    inline void removeTail (void);
    inline void removeAll  (void);
    inline void removeAt   (BPosition pos);

    inline R         getHead             (void) const;
    inline R         getTail             (void) const;
    inline BPosition getHeadPosition     (void) const;
    inline BPosition getTailPosition     (void) const;
    inline R         getNextPosition     (BPosition& pos) const;
    inline R         getPreviousPosition (BPosition& pos) const;

    inline BPosition getIndexPosition (int index)     const; // order n since this is not an array
    inline R         getData          (BPosition pos) const;

    inline BPosition findForward  (R match,BPosition posStartFrom) const; // require operator==
    inline BPosition findBackward (R match,BPosition posStartFrom) const; // require operator==

    inline int isEmpty (void) const { return m_pHead == NULL; }

    inline const BLinkedList<T,R,ts>& operator= (const BLinkedList<T,R,ts>& c)
    {
        addTail (c);
        return *this;
    }

    //
    // construction
    //
public:
    inline  BLinkedList (void) 
    { 
        m_pHead = m_pTail = NULL; 
        if (ts) InitializeCriticalSection (&m_csThread);
    }
    inline ~BLinkedList (void) 
    { 
        removeAll(); 
        if (ts) DeleteCriticalSection (&m_csThread);
    }
};

//
// implementation
//
template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::addHead (R data)
{
    if (ts) EnterCriticalSection (&m_csThread);
    ENTRY *pEntry = new ENTRY;
    if (!pEntry) throw BException(BException::outOfMemory);
    pEntry->m_pNext = m_pHead;
    pEntry->m_pPrev = NULL;
    pEntry->m_Data  = data;
    if (m_pHead) m_pHead->m_pPrev = pEntry;
            else m_pTail          = pEntry;
    m_pHead = pEntry;
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::addTail (R data)
{
    if (ts) EnterCriticalSection (&m_csThread);
    ENTRY *pEntry = new ENTRY;
    if (!pEntry) throw BException(BException::outOfMemory);
    pEntry->m_pNext = NULL;
    pEntry->m_pPrev = m_pTail;
    pEntry->m_Data  = data;
    if (m_pTail) m_pTail->m_pNext = pEntry;
            else m_pHead          = pEntry;
    m_pTail = pEntry;
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::addHead (const BLinkedList<T,R,ts>& data)
{
    if (ts) EnterCriticalSection (&m_csThread);
    ENTRY *pEntry = (ENTRY*)data.m_pTail;
    while (pEntry)
    {
        addHead (pEntry->m_Data);
        pEntry = pEntry->m_pPrev;
    }
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::addTail (const BLinkedList<T,R,ts>& data)
{
    if (ts) EnterCriticalSection (&m_csThread);
    ENTRY *pEntry = (ENTRY*)data.m_pHead;
    while (pEntry)
    {
        addTail (pEntry->m_Data);
        pEntry = pEntry->m_pNext;
    }
    if (ts) LeaveCriticalSection (&m_csThread);
}
 
template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::removeHead (void)
{
    if (ts) EnterCriticalSection (&m_csThread);
    if (m_pHead)
    {
        removeAt (BPosition(m_pHead));
    }
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::removeTail (void)
{
    if (ts) EnterCriticalSection (&m_csThread);
    if (m_pTail)
    {
        removeAt (BPosition(m_pTail));
    }
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::removeAll (void)
{
    if (ts) EnterCriticalSection (&m_csThread);
    while (m_pHead) removeHead();
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> void BLinkedList<T,R,ts>::removeAt (BPosition pos)
{
    if (ts) EnterCriticalSection (&m_csThread);
    assert (pos);
    ENTRY *pEntry = (ENTRY*)pos;
    if (pEntry->m_pNext) pEntry->m_pNext->m_pPrev = pEntry->m_pPrev;
                    else m_pTail                  = pEntry->m_pPrev;
    if (pEntry->m_pPrev) pEntry->m_pPrev->m_pNext = pEntry->m_pNext;
                    else m_pHead                  = pEntry->m_pNext;
    delete pEntry;
    if (ts) LeaveCriticalSection (&m_csThread);
}

template<class T,class R,BOOL ts> R BLinkedList<T,R,ts>::getHead (void) const
{
    assert (m_pHead);
    return m_pHead->m_Data;
}

template<class T,class R,BOOL ts> R BLinkedList<T,R,ts>::getTail (void) const
{
    assert (m_pTail);
    return m_pTail->m_Data;
}

template<class T,class R,BOOL ts> BPosition BLinkedList<T,R,ts>::getHeadPosition (void) const
{
    return BPosition(m_pHead);
}

template<class T,class R,BOOL ts> BPosition BLinkedList<T,R,ts>::getTailPosition (void) const
{
    return BPosition(m_pTail);
}

template<class T,class R,BOOL ts> R BLinkedList<T,R,ts>::getNextPosition (BPosition& pos) const
{
    assert (pos);
    ENTRY *pEntry = (ENTRY*)pos;
    pos = BPosition(pEntry->m_pNext);
    return pEntry->m_Data;
}

template<class T,class R,BOOL ts> R BLinkedList<T,R,ts>::getPreviousPosition (BPosition& pos) const
{
    assert (pos);
    ENTRY *pEntry = (ENTRY*)pos;
    pos = BPosition(pEntry->m_pPrev);
    return pEntry->m_Data;
}

template<class T,class R,BOOL ts> BPosition BLinkedList<T,R,ts>::getIndexPosition (int index) const // order n since this is not an array
{
    ENTRY *pEntry = m_pHead;
    while (pEntry && index)
    {
        index  --;
        pEntry = pEntry->m_pNext;
    }
    // done
    return BPosition(pEntry);
}

template<class T,class R,BOOL ts> R BLinkedList<T,R,ts>::getData (BPosition pos) const
{
    assert (pos);
    return ((ENTRY*)pos)->m_Data;
}

template<class T,class R,BOOL ts> BPosition BLinkedList<T,R,ts>::findForward (R match,BPosition posStartFrom) const
{
    ENTRY *pEntry = (ENTRY*)posStartFrom;
    while (pEntry)
    {
        if (pEntry->m_Data == match) return BPosition(pEntry);
        pEntry = pEntry->m_pNext;
    }
    // not found
    return BPosition(NULL);
}

template<class T,class R,BOOL ts> BPosition BLinkedList<T,R,ts>::findBackward (R match,BPosition posStartFrom) const
{
    ENTRY *pEntry = (ENTRY*)posStartFrom;
    while (pEntry)
    {
        if (pEntry->m_Data == match) return BPosition(pEntry);
        pEntry = pEntry->m_pPrev;
    }
    // not found
    return BPosition(NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BLib.h ===
#ifndef _BLIB_H
#define _BLIB_H

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// macros
//
#ifndef NULL
#define NULL        (0)
#endif

//////////////////////////////////////////////////////////////////////////////
// types
//
typedef void* BPosition;

//////////////////////////////////////////////////////////////////////////////
// helpers
//
inline void fillByte  (void *ptr,unsigned data,unsigned count) { unsigned char  *pch = (unsigned char*)ptr; while (count) { *pch = (unsigned char)data; pch++; count--; } }
inline void fillWord  (void *ptr,unsigned data,unsigned count) { unsigned short *pch = (unsigned short*)ptr; while (count) { *pch = (unsigned short)data; pch++; count--; } }
inline void fillDWord (void *ptr,unsigned data,unsigned count) { unsigned long  *pch = (unsigned long*)ptr; while (count) { *pch = (unsigned long)data; pch++; count--; } }

template<class T> T bmin (T a,T b) { return (a < b) ? a : b; }
template<class T> T bmax (T a,T b) { return (a > b) ? a : b; }

//////////////////////////////////////////////////////////////////////////////
// dependencies
//
#include <assert.h>
#include <windows.h>
#include <stdio.h>

#include "BException.h"
#include "BString.h"
#include "BArray.h"
#include "BList.h"
#include "BConsole.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BTree.h ===
#ifndef _BTREE_H
#define _BTREE_H

//////////////////////////////////////////////////////////////////////////////
// 
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\samples\console\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by console.rc
//
#define IDB_FONT                        101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\samples\LinkedList\main.cpp ===
#include <stdio.h>
#pragma hdrstop
#include "\BLib\inc\BLib.h"

void main (void)
{
    //
    // create linked list of integers
    //
    BLinkedList<int,int> list1;

    //
    // add some data (0,1,2,3,4)
    //
    list1.addTail (2);
    list1.addHead (1);
    list1.addTail (3);
    list1.addTail (4);
    list1.addHead (0);

    //
    // remove at endpoints
    //
    list1.removeHead();
    list1.removeTail();

    //
    // front to back traversal
    //
    BPosition pos;
    pos = list1.getHeadPosition();
    while (pos)
    {
        int i = list1.getNextPosition(pos);
        printf ("%d ",i);
    }
    printf ("\n");

    //
    // back to front traversal
    //
    pos = list1.getTailPosition();
    while (pos)
    {
        int i = list1.getPreviousPosition(pos);
        printf ("%d ",i);
    }
    printf ("\n");

    //
    // add more data
    //
    list1.addTail (2);
    list1.addHead (1);

    //
    // find entries from front of list
    //
    pos = list1.findForward(2,list1.getHeadPosition());
    while (pos)
    {
        // have to extract data so 'pos' can advance to next element
        int i = list1.getNextPosition(pos);
        printf ("%d ",i);
        // find next match
        pos = list1.findForward(2,pos);
    }
    printf ("\n");

    //
    // find entries from back of list
    //
    pos = list1.findBackward(1,list1.getTailPosition());
    while (pos)
    {
        // have to extract data so 'pos' can advance to next element
        int i = list1.getPreviousPosition(pos);
        printf ("%d ",i);
        // find next match
        pos = list1.findBackward(1,pos);
    }
    printf ("\n");

    //
    // remove all '2's
    //
    pos = list1.findForward(2,list1.getHeadPosition());
    while (pos)
    {
        list1.removeAt (pos);
        printf ("* ");
        // find next match
        pos = list1.findForward(2,list1.getHeadPosition());
    }
    printf ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\samples\console\main.cpp ===
#include <windows.h>
#pragma hdrstop
#include "..\..\inc\BLib.h"
#include "resource.h"

int WINAPI WinMain
(
  HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  LPSTR     lpCmdLine,
  int       nCmdShow
)
{
    //
    // make simple screen
    //
    if (1) 
    {
        BScreen screen;

        screen.create (hInstance);

        //screen.setFont ("Arial",20);
        //screen.setFont ("FixedSys");
        screen.showCaret();
        screen.gotoXY(10,10);
        screen.print ("Hello\nthere");

        BScreen::MESSAGE msg;
        for (BOOL bQuit = FALSE; !bQuit;)
        {
            if (screen.getMessage(&msg))
            {
                switch (msg.uMessage)
                {
                    case WM_CHAR: if (msg.wParam == 27) bQuit = TRUE;
                                  break;
                    case WM_CLOSE: bQuit = TRUE;
                                   break;
                }
            }
            else
            {
                // idle
                Sleep (10); // NOTE: waiting a bit on idle makes the screen update must more responsive
                //screen.setCell (5,5,screen.getCell(5,5) + 1);
            }
        }
        screen.destroy ();
    }

    //
    // make screen with user defined font
    //
    if (0) 
    {
        BScreen screen;

        screen.create (hInstance,80,25);

        // screen takes ownership and will call DeleteObject for you
        HBITMAP hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_FONT));
        screen.setFont (hBitmap,
                        16,16,  // there are 16 x 16 cells (to logically grow, make this 16x17, 16x18, ...)
                        16,16); // each cell has 16 x 16 pixels

        screen.fillCells (0,0,80,25,0);
        screen.setCell   (1,1,0x0001);
        screen.setCell   (2,1,0x0101);
        screen.setCell   (2,2,0x0002);
        screen.setCell   (3,3,0x0003);

        BScreen::MESSAGE msg;
        for (BOOL bQuit = FALSE; !bQuit;)
        {
            if (screen.getMessage(&msg))
            {
                switch (msg.uMessage)
                {
                    case WM_CHAR: if (msg.wParam == 27) bQuit = TRUE;
                                  break;
                    case WM_CLOSE: bQuit = TRUE;
                                   break;
                }
            }
            else
            {
                // idle
                Sleep (10); // NOTE: waiting a bit on idle makes the screen update must more responsive
                //screen.setCell (5,5,screen.getCell(5,5) + 1);
            }
        }
        screen.destroy ();
    }

    //
    // make simple console
    //
    if (0)
    {
        BConsole console;

        console.create (hInstance,80,120);
        console.enableCommandHistory();
        console.enableNameCompletion();

        console.ncAdd ("aaabbb1");
        console.ncAdd ("aaabbb2");
        console.ncAdd ("abcdde");
        console.ncAdd ("abcd2");
        console.ncAdd ("dcb");
        console.ncAdd ("dce");

        for (int i = 0; i < 1000; i++)
        {
            console.print ("%d\r\n",i);
        }

        console.print (">");
        for (BOOL bQuit = FALSE; !bQuit;)
        {
            BString sz;
            switch (console.read(&sz))
            {
                case BConsole::closed: // user has issued a WM_CLOSE
                {
                    bQuit = 1; 
                    break;
                }
                case BConsole::success:
                {
                    console.print ("text \"%s\"\r\n",(const char*)sz);
                    console.print (">");
                    break;
                }
            }
        }

        console.destroy();
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\dx8\d3d8.h ===
/*==========================================================================;
 *
 *
 *  File:   d3d8.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D8_H_
#define _D3D8_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)


/* This identifier is passed to Direct3DCreate8 in order to ensure that an
 * application was built against the correct header files. This number is
 * incremented whenever a header (or other) change would require applications
 * to be rebuilt. If the version doesn't match, Direct3DCreate8 will fail.
 * (The number itself has no meaning.)*/

#define D3D_SDK_VERSION 120


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <windows.h>

#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
    #define HMONITOR_DECLARED
    DECLARE_HANDLE(HMONITOR);
#endif

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

/* IID_IDirect3D8 */
/* {1DD9E8DA-1C77-4d40-B0CF-98FEFDFF9512} */
DEFINE_GUID(IID_IDirect3D8, 0x1dd9e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);

/* IID_IDirect3DDevice8 */
/* {7385E5DF-8FE8-41D5-86B6-D7B48547B6CF} */
DEFINE_GUID(IID_IDirect3DDevice8, 0x7385e5df, 0x8fe8, 0x41d5, 0x86, 0xb6, 0xd7, 0xb4, 0x85, 0x47, 0xb6, 0xcf);

/* IID_IDirect3DResource8 */
/* {1B36BB7B-09B7-410a-B445-7D1430D7B33F} */
DEFINE_GUID(IID_IDirect3DResource8, 0x1b36bb7b, 0x9b7, 0x410a, 0xb4, 0x45, 0x7d, 0x14, 0x30, 0xd7, 0xb3, 0x3f);

/* IID_IDirect3DBaseTexture8 */
/* {B4211CFA-51B9-4a9f-AB78-DB99B2BB678E} */
DEFINE_GUID(IID_IDirect3DBaseTexture8, 0xb4211cfa, 0x51b9, 0x4a9f, 0xab, 0x78, 0xdb, 0x99, 0xb2, 0xbb, 0x67, 0x8e);

/* IID_IDirect3DTexture8 */
/* {E4CDD575-2866-4f01-B12E-7EECE1EC9358} */
DEFINE_GUID(IID_IDirect3DTexture8, 0xe4cdd575, 0x2866, 0x4f01, 0xb1, 0x2e, 0x7e, 0xec, 0xe1, 0xec, 0x93, 0x58);

/* IID_IDirect3DCubeTexture8 */
/* {3EE5B968-2ACA-4c34-8BB5-7E0C3D19B750} */
DEFINE_GUID(IID_IDirect3DCubeTexture8, 0x3ee5b968, 0x2aca, 0x4c34, 0x8b, 0xb5, 0x7e, 0x0c, 0x3d, 0x19, 0xb7, 0x50);

/* IID_IDirect3DVolumeTexture8 */
/* {4B8AAAFA-140F-42ba-9131-597EAFAA2EAD} */
DEFINE_GUID(IID_IDirect3DVolumeTexture8, 0x4b8aaafa, 0x140f, 0x42ba, 0x91, 0x31, 0x59, 0x7e, 0xaf, 0xaa, 0x2e, 0xad);

/* IID_IDirect3DVertexBuffer8 */
/* {8AEEEAC7-05F9-44d4-B591-000B0DF1CB95} */
DEFINE_GUID(IID_IDirect3DVertexBuffer8, 0x8aeeeac7, 0x05f9, 0x44d4, 0xb5, 0x91, 0x00, 0x0b, 0x0d, 0xf1, 0xcb, 0x95);

/* IID_IDirect3DIndexBuffer8 */
/* {0E689C9A-053D-44a0-9D92-DB0E3D750F86} */
DEFINE_GUID(IID_IDirect3DIndexBuffer8, 0x0e689c9a, 0x053d, 0x44a0, 0x9d, 0x92, 0xdb, 0x0e, 0x3d, 0x75, 0x0f, 0x86);

/* IID_IDirect3DSurface8 */
/* {B96EEBCA-B326-4ea5-882F-2FF5BAE021DD} */
DEFINE_GUID(IID_IDirect3DSurface8, 0xb96eebca, 0xb326, 0x4ea5, 0x88, 0x2f, 0x2f, 0xf5, 0xba, 0xe0, 0x21, 0xdd);

/* IID_IDirect3DVolume8 */
/* {BD7349F5-14F1-42e4-9C79-972380DB40C0} */
DEFINE_GUID(IID_IDirect3DVolume8, 0xbd7349f5, 0x14f1, 0x42e4, 0x9c, 0x79, 0x97, 0x23, 0x80, 0xdb, 0x40, 0xc0);

/* IID_IDirect3DSwapChain8 */
/* {928C088B-76B9-4C6B-A536-A590853876CD} */
DEFINE_GUID(IID_IDirect3DSwapChain8, 0x928c088b, 0x76b9, 0x4c6b, 0xa5, 0x36, 0xa5, 0x90, 0x85, 0x38, 0x76, 0xcd);

#endif

#ifdef __cplusplus

interface IDirect3D8;
interface IDirect3DDevice8;

interface IDirect3DResource8;
interface IDirect3DBaseTexture8;
interface IDirect3DTexture8;
interface IDirect3DVolumeTexture8;
interface IDirect3DCubeTexture8;

interface IDirect3DVertexBuffer8;
interface IDirect3DIndexBuffer8;

interface IDirect3DSurface8;
interface IDirect3DVolume8;

interface IDirect3DSwapChain8;

#endif


typedef interface IDirect3D8                IDirect3D8;
typedef interface IDirect3DDevice8          IDirect3DDevice8;
typedef interface IDirect3DResource8        IDirect3DResource8;
typedef interface IDirect3DBaseTexture8     IDirect3DBaseTexture8;
typedef interface IDirect3DTexture8         IDirect3DTexture8;
typedef interface IDirect3DVolumeTexture8   IDirect3DVolumeTexture8;
typedef interface IDirect3DCubeTexture8     IDirect3DCubeTexture8;
typedef interface IDirect3DVertexBuffer8    IDirect3DVertexBuffer8;
typedef interface IDirect3DIndexBuffer8     IDirect3DIndexBuffer8;
typedef interface IDirect3DSurface8         IDirect3DSurface8;
typedef interface IDirect3DVolume8          IDirect3DVolume8;
typedef interface IDirect3DSwapChain8       IDirect3DSwapChain8;

#include "d3d8types.h"
#include "d3d8caps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * DLL Function for creating a Direct3D8 object. This object supports
 * enumeration and allows the creation of Direct3DDevice8 objects.
 * Pass the value of the constant D3D_SDK_VERSION to this function, so
 * that the run-time can validate that your application was compiled
 * against the right headers.
 */

IDirect3D8 * WINAPI Direct3DCreate8(UINT SDKVersion);


/*
 * Direct3D interfaces
 */






#undef INTERFACE
#define INTERFACE IDirect3D8

DECLARE_INTERFACE_(IDirect3D8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D8 methods ***/
    STDMETHOD(RegisterSoftwareDevice)(THIS_ void* pInitializeFunction) PURE;
    STDMETHOD_(UINT, GetAdapterCount)(THIS) PURE;
    STDMETHOD(GetAdapterIdentifier)(THIS_ UINT Adapter,DWORD Flags,D3DADAPTER_IDENTIFIER8* pIdentifier) PURE;
    STDMETHOD_(UINT, GetAdapterModeCount)(THIS_ UINT Adapter) PURE;
    STDMETHOD(EnumAdapterModes)(THIS_ UINT Adapter,UINT Mode,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetAdapterDisplayMode)(THIS_ UINT Adapter,D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(CheckDeviceType)(THIS_ UINT Adapter,D3DDEVTYPE CheckType,D3DFORMAT DisplayFormat,D3DFORMAT BackBufferFormat,BOOL Windowed) PURE;
    STDMETHOD(CheckDeviceFormat)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,DWORD Usage,D3DRESOURCETYPE RType,D3DFORMAT CheckFormat) PURE;
    STDMETHOD(CheckDeviceMultiSampleType)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT SurfaceFormat,BOOL Windowed,D3DMULTISAMPLE_TYPE MultiSampleType) PURE;
    STDMETHOD(CheckDepthStencilMatch)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DFORMAT AdapterFormat,D3DFORMAT RenderTargetFormat,D3DFORMAT DepthStencilFormat) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,D3DCAPS8* pCaps) PURE;
    STDMETHOD_(HMONITOR, GetAdapterMonitor)(THIS_ UINT Adapter) PURE;
    STDMETHOD(CreateDevice)(THIS_ UINT Adapter,D3DDEVTYPE DeviceType,HWND hFocusWindow,DWORD BehaviorFlags,D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DDevice8** ppReturnedDeviceInterface) PURE;
};

typedef struct IDirect3D8 *LPDIRECT3D8, *PDIRECT3D8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->lpVtbl->RegisterSoftwareDevice(p,a)
#define IDirect3D8_GetAdapterCount(p) (p)->lpVtbl->GetAdapterCount(p)
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->lpVtbl->GetAdapterIdentifier(p,a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->lpVtbl->GetAdapterModeCount(p,a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->lpVtbl->EnumAdapterModes(p,a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->lpVtbl->GetAdapterDisplayMode(p,a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceType(p,a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->lpVtbl->CheckDeviceFormat(p,a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->lpVtbl->CheckDeviceMultiSampleType(p,a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->lpVtbl->CheckDepthStencilMatch(p,a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->lpVtbl->GetDeviceCaps(p,a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->lpVtbl->GetAdapterMonitor(p,a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->lpVtbl->CreateDevice(p,a,b,c,d,e,f)
#else
#define IDirect3D8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D8_AddRef(p) (p)->AddRef()
#define IDirect3D8_Release(p) (p)->Release()
#define IDirect3D8_RegisterSoftwareDevice(p,a) (p)->RegisterSoftwareDevice(a)
#define IDirect3D8_GetAdapterCount(p) (p)->GetAdapterCount()
#define IDirect3D8_GetAdapterIdentifier(p,a,b,c) (p)->GetAdapterIdentifier(a,b,c)
#define IDirect3D8_GetAdapterModeCount(p,a) (p)->GetAdapterModeCount(a)
#define IDirect3D8_EnumAdapterModes(p,a,b,c) (p)->EnumAdapterModes(a,b,c)
#define IDirect3D8_GetAdapterDisplayMode(p,a,b) (p)->GetAdapterDisplayMode(a,b)
#define IDirect3D8_CheckDeviceType(p,a,b,c,d,e) (p)->CheckDeviceType(a,b,c,d,e)
#define IDirect3D8_CheckDeviceFormat(p,a,b,c,d,e,f) (p)->CheckDeviceFormat(a,b,c,d,e,f)
#define IDirect3D8_CheckDeviceMultiSampleType(p,a,b,c,d,e) (p)->CheckDeviceMultiSampleType(a,b,c,d,e)
#define IDirect3D8_CheckDepthStencilMatch(p,a,b,c,d,e) (p)->CheckDepthStencilMatch(a,b,c,d,e)
#define IDirect3D8_GetDeviceCaps(p,a,b,c) (p)->GetDeviceCaps(a,b,c)
#define IDirect3D8_GetAdapterMonitor(p,a) (p)->GetAdapterMonitor(a)
#define IDirect3D8_CreateDevice(p,a,b,c,d,e,f) (p)->CreateDevice(a,b,c,d,e,f)
#endif



















#undef INTERFACE
#define INTERFACE IDirect3DDevice8

DECLARE_INTERFACE_(IDirect3DDevice8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice8 methods ***/
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD_(UINT, GetAvailableTextureMem)(THIS) PURE;
    STDMETHOD(ResourceManagerDiscardBytes)(THIS_ DWORD Bytes) PURE;
    STDMETHOD(GetDirect3D)(THIS_ IDirect3D8** ppD3D8) PURE;
    STDMETHOD(GetDeviceCaps)(THIS_ D3DCAPS8* pCaps) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ D3DDISPLAYMODE* pMode) PURE;
    STDMETHOD(GetCreationParameters)(THIS_ D3DDEVICE_CREATION_PARAMETERS *pParameters) PURE;
    STDMETHOD(SetCursorProperties)(THIS_ UINT XHotSpot,UINT YHotSpot,IDirect3DSurface8* pCursorBitmap) PURE;
    STDMETHOD_(void, SetCursorPosition)(THIS_ UINT XScreenSpace,UINT YScreenSpace,DWORD Flags) PURE;
    STDMETHOD_(BOOL, ShowCursor)(THIS_ BOOL bShow) PURE;
    STDMETHOD(CreateAdditionalSwapChain)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters,IDirect3DSwapChain8** pSwapChain) PURE;
    STDMETHOD(Reset)(THIS_ D3DPRESENT_PARAMETERS* pPresentationParameters) PURE;
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
    STDMETHOD(GetRasterStatus)(THIS_ D3DRASTER_STATUS* pRasterStatus) PURE;
    STDMETHOD_(void, SetGammaRamp)(THIS_ DWORD Flags,CONST D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD_(void, GetGammaRamp)(THIS_ D3DGAMMARAMP* pRamp) PURE;
    STDMETHOD(CreateTexture)(THIS_ UINT Width,UINT Height,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DTexture8** ppTexture) PURE;
    STDMETHOD(CreateVolumeTexture)(THIS_ UINT Width,UINT Height,UINT Depth,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DVolumeTexture8** ppVolumeTexture) PURE;
    STDMETHOD(CreateCubeTexture)(THIS_ UINT EdgeLength,UINT Levels,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DCubeTexture8** ppCubeTexture) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ UINT Length,DWORD Usage,DWORD FVF,D3DPOOL Pool,IDirect3DVertexBuffer8** ppVertexBuffer) PURE;
    STDMETHOD(CreateIndexBuffer)(THIS_ UINT Length,DWORD Usage,D3DFORMAT Format,D3DPOOL Pool,IDirect3DIndexBuffer8** ppIndexBuffer) PURE;
    STDMETHOD(CreateRenderTarget)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,BOOL Lockable,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateDepthStencilSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,D3DMULTISAMPLE_TYPE MultiSample,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CreateImageSurface)(THIS_ UINT Width,UINT Height,D3DFORMAT Format,IDirect3DSurface8** ppSurface) PURE;
    STDMETHOD(CopyRects)(THIS_ IDirect3DSurface8* pSourceSurface,CONST RECT* pSourceRectsArray,UINT cRects,IDirect3DSurface8* pDestinationSurface,CONST POINT* pDestPointsArray) PURE;
    STDMETHOD(UpdateTexture)(THIS_ IDirect3DBaseTexture8* pSourceTexture,IDirect3DBaseTexture8* pDestinationTexture) PURE;
    STDMETHOD(GetFrontBuffer)(THIS_ IDirect3DSurface8* pDestSurface) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ IDirect3DSurface8* pRenderTarget,IDirect3DSurface8* pNewZStencil) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ IDirect3DSurface8** ppRenderTarget) PURE;
    STDMETHOD(GetDepthStencilSurface)(THIS_ IDirect3DSurface8** ppZStencilSurface) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(Clear)(THIS_ DWORD Count,CONST D3DRECT* pRects,DWORD Flags,D3DCOLOR Color,float Z,DWORD Stencil) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,CONST D3DMATRIX* pMatrix) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE State,D3DMATRIX* pMatrix) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,CONST D3DMATRIX*) PURE;
    STDMETHOD(SetViewport)(THIS_ CONST D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(GetViewport)(THIS_ D3DVIEWPORT8* pViewport) PURE;
    STDMETHOD(SetMaterial)(THIS_ CONST D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(GetMaterial)(THIS_ D3DMATERIAL8* pMaterial) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD Index,CONST D3DLIGHT8*) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD Index,D3DLIGHT8*) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD Index,BOOL Enable) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD Index,BOOL* pEnable) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD Index,CONST float* pPlane) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD Index,float* pPlane) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD Value) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE State,DWORD* pValue) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ DWORD* pToken) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD Token) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE Type,DWORD* pToken) PURE;
    STDMETHOD(SetClipStatus)(THIS_ CONST D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetClipStatus)(THIS_ D3DCLIPSTATUS8* pClipStatus) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8** ppTexture) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD Stage,IDirect3DBaseTexture8* pTexture) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD* pValue) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD Stage,D3DTEXTURESTAGESTATETYPE Type,DWORD Value) PURE;
    STDMETHOD(ValidateDevice)(THIS_ DWORD* pNumPasses) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD DevInfoID,void* pDevInfoStruct,DWORD DevInfoStructSize) PURE;
    STDMETHOD(SetPaletteEntries)(THIS_ UINT PaletteNumber,CONST PALETTEENTRY* pEntries) PURE;
    STDMETHOD(GetPaletteEntries)(THIS_ UINT PaletteNumber,PALETTEENTRY* pEntries) PURE;
    STDMETHOD(SetCurrentTexturePalette)(THIS_ UINT PaletteNumber) PURE;
    STDMETHOD(GetCurrentTexturePalette)(THIS_ UINT *PaletteNumber) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT StartVertex,UINT PrimitiveCount) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,UINT minIndex,UINT NumIndices,UINT startIndex,UINT primCount) PURE;
    STDMETHOD(DrawPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT PrimitiveCount,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(DrawIndexedPrimitiveUP)(THIS_ D3DPRIMITIVETYPE PrimitiveType,UINT MinVertexIndex,UINT NumVertexIndices,UINT PrimitiveCount,CONST void* pIndexData,D3DFORMAT IndexDataFormat,CONST void* pVertexStreamZeroData,UINT VertexStreamZeroStride) PURE;
    STDMETHOD(ProcessVertices)(THIS_ UINT SrcStartIndex,UINT DestIndex,UINT VertexCount,IDirect3DVertexBuffer8* pDestBuffer,DWORD Flags) PURE;
    STDMETHOD(CreateVertexShader)(THIS_ CONST DWORD* pDeclaration,CONST DWORD* pFunction,DWORD* pHandle,DWORD Usage) PURE;
    STDMETHOD(SetVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetVertexShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeleteVertexShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetVertexShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetVertexShaderDeclaration)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(GetVertexShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(SetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8* pStreamData,UINT Stride) PURE;
    STDMETHOD(GetStreamSource)(THIS_ UINT StreamNumber,IDirect3DVertexBuffer8** ppStreamData,UINT* pStride) PURE;
    STDMETHOD(SetIndices)(THIS_ IDirect3DIndexBuffer8* pIndexData,UINT BaseVertexIndex) PURE;
    STDMETHOD(GetIndices)(THIS_ IDirect3DIndexBuffer8** ppIndexData,UINT* pBaseVertexIndex) PURE;
    STDMETHOD(CreatePixelShader)(THIS_ CONST DWORD* pFunction,DWORD* pHandle) PURE;
    STDMETHOD(SetPixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(GetPixelShader)(THIS_ DWORD* pHandle) PURE;
    STDMETHOD(DeletePixelShader)(THIS_ DWORD Handle) PURE;
    STDMETHOD(SetPixelShaderConstant)(THIS_ DWORD Register,CONST void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderConstant)(THIS_ DWORD Register,void* pConstantData,DWORD ConstantCount) PURE;
    STDMETHOD(GetPixelShaderFunction)(THIS_ DWORD Handle,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(DrawRectPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DRECTPATCH_INFO* pRectPatchInfo) PURE;
    STDMETHOD(DrawTriPatch)(THIS_ UINT Handle,CONST float* pNumSegs,CONST D3DTRIPATCH_INFO* pTriPatchInfo) PURE;
    STDMETHOD(DeletePatch)(THIS_ UINT Handle) PURE;
};

typedef struct IDirect3DDevice8 *LPDIRECT3DDEVICE8, *PDIRECT3DDEVICE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->lpVtbl->GetAvailableTextureMem(p)
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->lpVtbl->ResourceManagerDiscardBytes(p,a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->lpVtbl->GetDeviceCaps(p,a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->lpVtbl->GetDisplayMode(p,a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->lpVtbl->GetCreationParameters(p,a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->lpVtbl->SetCursorProperties(p,a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->lpVtbl->SetCursorPosition(p,a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->lpVtbl->ShowCursor(p,a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->lpVtbl->CreateAdditionalSwapChain(p,a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->lpVtbl->Reset(p,a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->lpVtbl->GetRasterStatus(p,a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->lpVtbl->SetGammaRamp(p,a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->lpVtbl->GetGammaRamp(p,a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->lpVtbl->CreateTexture(p,a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->CreateVolumeTexture(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->lpVtbl->CreateCubeTexture(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->lpVtbl->CreateIndexBuffer(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->lpVtbl->CreateRenderTarget(p,a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->lpVtbl->CreateDepthStencilSurface(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->lpVtbl->CreateImageSurface(p,a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->lpVtbl->CopyRects(p,a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->lpVtbl->UpdateTexture(p,a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->lpVtbl->GetFrontBuffer(p,a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->lpVtbl->GetDepthStencilSurface(p,a)
#define IDirect3DDevice8_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice8_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->lpVtbl->SetPaletteEntries(p,a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->lpVtbl->GetPaletteEntries(p,a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->lpVtbl->SetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->lpVtbl->GetCurrentTexturePalette(p,a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->lpVtbl->DrawPrimitive(p,a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->lpVtbl->DrawPrimitiveUP(p,a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->lpVtbl->DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->lpVtbl->CreateVertexShader(p,a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->lpVtbl->SetVertexShader(p,a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->lpVtbl->GetVertexShader(p,a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->lpVtbl->DeleteVertexShader(p,a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->SetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->lpVtbl->GetVertexShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->lpVtbl->GetVertexShaderDeclaration(p,a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->lpVtbl->GetVertexShaderFunction(p,a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->lpVtbl->SetStreamSource(p,a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->lpVtbl->GetStreamSource(p,a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->lpVtbl->SetIndices(p,a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->lpVtbl->GetIndices(p,a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->lpVtbl->CreatePixelShader(p,a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->lpVtbl->SetPixelShader(p,a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->lpVtbl->GetPixelShader(p,a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->lpVtbl->DeletePixelShader(p,a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->SetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->lpVtbl->GetPixelShaderConstant(p,a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->lpVtbl->GetPixelShaderFunction(p,a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->lpVtbl->DrawRectPatch(p,a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->lpVtbl->DrawTriPatch(p,a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->lpVtbl->DeletePatch(p,a)
#else
#define IDirect3DDevice8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice8_AddRef(p) (p)->AddRef()
#define IDirect3DDevice8_Release(p) (p)->Release()
#define IDirect3DDevice8_TestCooperativeLevel(p) (p)->TestCooperativeLevel()
#define IDirect3DDevice8_GetAvailableTextureMem(p) (p)->GetAvailableTextureMem()
#define IDirect3DDevice8_ResourceManagerDiscardBytes(p,a) (p)->ResourceManagerDiscardBytes(a)
#define IDirect3DDevice8_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice8_GetDeviceCaps(p,a) (p)->GetDeviceCaps(a)
#define IDirect3DDevice8_GetDisplayMode(p,a) (p)->GetDisplayMode(a)
#define IDirect3DDevice8_GetCreationParameters(p,a) (p)->GetCreationParameters(a)
#define IDirect3DDevice8_SetCursorProperties(p,a,b,c) (p)->SetCursorProperties(a,b,c)
#define IDirect3DDevice8_SetCursorPosition(p,a,b,c) (p)->SetCursorPosition(a,b,c)
#define IDirect3DDevice8_ShowCursor(p,a) (p)->ShowCursor(a)
#define IDirect3DDevice8_CreateAdditionalSwapChain(p,a,b) (p)->CreateAdditionalSwapChain(a,b)
#define IDirect3DDevice8_Reset(p,a) (p)->Reset(a)
#define IDirect3DDevice8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DDevice8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#define IDirect3DDevice8_GetRasterStatus(p,a) (p)->GetRasterStatus(a)
#define IDirect3DDevice8_SetGammaRamp(p,a,b) (p)->SetGammaRamp(a,b)
#define IDirect3DDevice8_GetGammaRamp(p,a) (p)->GetGammaRamp(a)
#define IDirect3DDevice8_CreateTexture(p,a,b,c,d,e,f,g) (p)->CreateTexture(a,b,c,d,e,f,g)
#define IDirect3DDevice8_CreateVolumeTexture(p,a,b,c,d,e,f,g,h) (p)->CreateVolumeTexture(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_CreateCubeTexture(p,a,b,c,d,e,f) (p)->CreateCubeTexture(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateVertexBuffer(p,a,b,c,d,e) (p)->CreateVertexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateIndexBuffer(p,a,b,c,d,e) (p)->CreateIndexBuffer(a,b,c,d,e)
#define IDirect3DDevice8_CreateRenderTarget(p,a,b,c,d,e,f) (p)->CreateRenderTarget(a,b,c,d,e,f)
#define IDirect3DDevice8_CreateDepthStencilSurface(p,a,b,c,d,e) (p)->CreateDepthStencilSurface(a,b,c,d,e)
#define IDirect3DDevice8_CreateImageSurface(p,a,b,c,d) (p)->CreateImageSurface(a,b,c,d)
#define IDirect3DDevice8_CopyRects(p,a,b,c,d,e) (p)->CopyRects(a,b,c,d,e)
#define IDirect3DDevice8_UpdateTexture(p,a,b) (p)->UpdateTexture(a,b)
#define IDirect3DDevice8_GetFrontBuffer(p,a) (p)->GetFrontBuffer(a)
#define IDirect3DDevice8_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice8_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice8_GetDepthStencilSurface(p,a) (p)->GetDepthStencilSurface(a)
#define IDirect3DDevice8_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice8_EndScene(p) (p)->EndScene()
#define IDirect3DDevice8_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice8_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice8_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice8_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice8_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice8_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice8_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice8_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice8_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice8_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice8_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice8_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice8_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice8_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice8_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice8_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice8_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice8_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice8_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice8_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice8_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice8_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice8_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice8_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice8_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice8_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice8_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice8_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice8_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice8_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#define IDirect3DDevice8_SetPaletteEntries(p,a,b) (p)->SetPaletteEntries(a,b)
#define IDirect3DDevice8_GetPaletteEntries(p,a,b) (p)->GetPaletteEntries(a,b)
#define IDirect3DDevice8_SetCurrentTexturePalette(p,a) (p)->SetCurrentTexturePalette(a)
#define IDirect3DDevice8_GetCurrentTexturePalette(p,a) (p)->GetCurrentTexturePalette(a)
#define IDirect3DDevice8_DrawPrimitive(p,a,b,c) (p)->DrawPrimitive(a,b,c)
#define IDirect3DDevice8_DrawIndexedPrimitive(p,a,b,c,d,e) (p)->DrawIndexedPrimitive(a,b,c,d,e)
#define IDirect3DDevice8_DrawPrimitiveUP(p,a,b,c,d) (p)->DrawPrimitiveUP(a,b,c,d)
#define IDirect3DDevice8_DrawIndexedPrimitiveUP(p,a,b,c,d,e,f,g,h) (p)->DrawIndexedPrimitiveUP(a,b,c,d,e,f,g,h)
#define IDirect3DDevice8_ProcessVertices(p,a,b,c,d,e) (p)->ProcessVertices(a,b,c,d,e)
#define IDirect3DDevice8_CreateVertexShader(p,a,b,c,d) (p)->CreateVertexShader(a,b,c,d)
#define IDirect3DDevice8_SetVertexShader(p,a) (p)->SetVertexShader(a)
#define IDirect3DDevice8_GetVertexShader(p,a) (p)->GetVertexShader(a)
#define IDirect3DDevice8_DeleteVertexShader(p,a) (p)->DeleteVertexShader(a)
#define IDirect3DDevice8_SetVertexShaderConstant(p,a,b,c) (p)->SetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderConstant(p,a,b,c) (p)->GetVertexShaderConstant(a,b,c)
#define IDirect3DDevice8_GetVertexShaderDeclaration(p,a,b,c) (p)->GetVertexShaderDeclaration(a,b,c)
#define IDirect3DDevice8_GetVertexShaderFunction(p,a,b,c) (p)->GetVertexShaderFunction(a,b,c)
#define IDirect3DDevice8_SetStreamSource(p,a,b,c) (p)->SetStreamSource(a,b,c)
#define IDirect3DDevice8_GetStreamSource(p,a,b,c) (p)->GetStreamSource(a,b,c)
#define IDirect3DDevice8_SetIndices(p,a,b) (p)->SetIndices(a,b)
#define IDirect3DDevice8_GetIndices(p,a,b) (p)->GetIndices(a,b)
#define IDirect3DDevice8_CreatePixelShader(p,a,b) (p)->CreatePixelShader(a,b)
#define IDirect3DDevice8_SetPixelShader(p,a) (p)->SetPixelShader(a)
#define IDirect3DDevice8_GetPixelShader(p,a) (p)->GetPixelShader(a)
#define IDirect3DDevice8_DeletePixelShader(p,a) (p)->DeletePixelShader(a)
#define IDirect3DDevice8_SetPixelShaderConstant(p,a,b,c) (p)->SetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderConstant(p,a,b,c) (p)->GetPixelShaderConstant(a,b,c)
#define IDirect3DDevice8_GetPixelShaderFunction(p,a,b,c) (p)->GetPixelShaderFunction(a,b,c)
#define IDirect3DDevice8_DrawRectPatch(p,a,b,c) (p)->DrawRectPatch(a,b,c)
#define IDirect3DDevice8_DrawTriPatch(p,a,b,c) (p)->DrawTriPatch(a,b,c)
#define IDirect3DDevice8_DeletePatch(p,a) (p)->DeletePatch(a)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DSwapChain8

DECLARE_INTERFACE_(IDirect3DSwapChain8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSwapChain8 methods ***/
    STDMETHOD(Present)(THIS_ CONST RECT* pSourceRect,CONST RECT* pDestRect,HWND hDestWindowOverride,CONST RGNDATA* pDirtyRegion) PURE;
    STDMETHOD(GetBackBuffer)(THIS_ UINT BackBuffer,D3DBACKBUFFER_TYPE Type,IDirect3DSurface8** ppBackBuffer) PURE;
};

typedef struct IDirect3DSwapChain8 *LPDIRECT3DSWAPCHAIN8, *PDIRECT3DSWAPCHAIN8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSwapChain8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->lpVtbl->Present(p,a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->lpVtbl->GetBackBuffer(p,a,b,c)
#else
#define IDirect3DSwapChain8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSwapChain8_AddRef(p) (p)->AddRef()
#define IDirect3DSwapChain8_Release(p) (p)->Release()
#define IDirect3DSwapChain8_Present(p,a,b,c,d) (p)->Present(a,b,c,d)
#define IDirect3DSwapChain8_GetBackBuffer(p,a,b,c) (p)->GetBackBuffer(a,b,c)
#endif



#undef INTERFACE
#define INTERFACE IDirect3DResource8

DECLARE_INTERFACE_(IDirect3DResource8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
};

typedef struct IDirect3DResource8 *LPDIRECT3DRESOURCE8, *PDIRECT3DRESOURCE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DResource8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DResource8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DResource8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DResource8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DResource8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DResource8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DResource8_GetType(p) (p)->lpVtbl->GetType(p)
#else
#define IDirect3DResource8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DResource8_AddRef(p) (p)->AddRef()
#define IDirect3DResource8_Release(p) (p)->Release()
#define IDirect3DResource8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DResource8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DResource8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DResource8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DResource8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DResource8_GetPriority(p) (p)->GetPriority()
#define IDirect3DResource8_PreLoad(p) (p)->PreLoad()
#define IDirect3DResource8_GetType(p) (p)->GetType()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DBaseTexture8

DECLARE_INTERFACE_(IDirect3DBaseTexture8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
};

typedef struct IDirect3DBaseTexture8 *LPDIRECT3DBASETEXTURE8, *PDIRECT3DBASETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DBaseTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DBaseTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DBaseTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#else
#define IDirect3DBaseTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DBaseTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DBaseTexture8_Release(p) (p)->Release()
#define IDirect3DBaseTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DBaseTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DBaseTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DBaseTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DBaseTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DBaseTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DBaseTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DBaseTexture8_GetType(p) (p)->GetType()
#define IDirect3DBaseTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DBaseTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DBaseTexture8_GetLevelCount(p) (p)->GetLevelCount()
#endif





#undef INTERFACE
#define INTERFACE IDirect3DTexture8

DECLARE_INTERFACE_(IDirect3DTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetSurfaceLevel)(THIS_ UINT Level,IDirect3DSurface8** ppSurfaceLevel) PURE;
    STDMETHOD(LockRect)(THIS_ UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DTexture8 *LPDIRECT3DTEXTURE8, *PDIRECT3DTEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->lpVtbl->GetSurfaceLevel(p,a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->lpVtbl->LockRect(p,a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->lpVtbl->UnlockRect(p,a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->lpVtbl->AddDirtyRect(p,a)
#else
#define IDirect3DTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DTexture8_Release(p) (p)->Release()
#define IDirect3DTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DTexture8_GetType(p) (p)->GetType()
#define IDirect3DTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DTexture8_GetSurfaceLevel(p,a,b) (p)->GetSurfaceLevel(a,b)
#define IDirect3DTexture8_LockRect(p,a,b,c,d) (p)->LockRect(a,b,c,d)
#define IDirect3DTexture8_UnlockRect(p,a) (p)->UnlockRect(a)
#define IDirect3DTexture8_AddDirtyRect(p,a) (p)->AddDirtyRect(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DVolumeTexture8

DECLARE_INTERFACE_(IDirect3DVolumeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(GetVolumeLevel)(THIS_ UINT Level,IDirect3DVolume8** ppVolumeLevel) PURE;
    STDMETHOD(LockBox)(THIS_ UINT Level,D3DLOCKED_BOX* pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS_ UINT Level) PURE;
    STDMETHOD(AddDirtyBox)(THIS_ CONST D3DBOX* pDirtyBox) PURE;
};

typedef struct IDirect3DVolumeTexture8 *LPDIRECT3DVOLUMETEXTURE8, *PDIRECT3DVOLUMETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolumeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVolumeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->lpVtbl->GetVolumeLevel(p,a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->lpVtbl->LockBox(p,a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->lpVtbl->UnlockBox(p,a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->lpVtbl->AddDirtyBox(p,a)
#else
#define IDirect3DVolumeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolumeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DVolumeTexture8_Release(p) (p)->Release()
#define IDirect3DVolumeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolumeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolumeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolumeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolumeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVolumeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVolumeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVolumeTexture8_GetType(p) (p)->GetType()
#define IDirect3DVolumeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DVolumeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DVolumeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DVolumeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DVolumeTexture8_GetVolumeLevel(p,a,b) (p)->GetVolumeLevel(a,b)
#define IDirect3DVolumeTexture8_LockBox(p,a,b,c,d) (p)->LockBox(a,b,c,d)
#define IDirect3DVolumeTexture8_UnlockBox(p,a) (p)->UnlockBox(a)
#define IDirect3DVolumeTexture8_AddDirtyBox(p,a) (p)->AddDirtyBox(a)
#endif





#undef INTERFACE
#define INTERFACE IDirect3DCubeTexture8

DECLARE_INTERFACE_(IDirect3DCubeTexture8, IDirect3DBaseTexture8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DBaseTexture8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD_(DWORD, SetLOD)(THIS_ DWORD LODNew) PURE;
    STDMETHOD_(DWORD, GetLOD)(THIS) PURE;
    STDMETHOD_(DWORD, GetLevelCount)(THIS) PURE;
    STDMETHOD(GetLevelDesc)(THIS_ UINT Level,D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(GetCubeMapSurface)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,IDirect3DSurface8** ppCubeMapSurface) PURE;
    STDMETHOD(LockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level,D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS_ D3DCUBEMAP_FACES FaceType,UINT Level) PURE;
    STDMETHOD(AddDirtyRect)(THIS_ D3DCUBEMAP_FACES FaceType,CONST RECT* pDirtyRect) PURE;
};

typedef struct IDirect3DCubeTexture8 *LPDIRECT3DCUBETEXTURE8, *PDIRECT3DCUBETEXTURE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DCubeTexture8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DCubeTexture8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DCubeTexture8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->lpVtbl->SetLOD(p,a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->lpVtbl->GetLOD(p)
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->lpVtbl->GetLevelCount(p)
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->lpVtbl->GetLevelDesc(p,a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->lpVtbl->GetCubeMapSurface(p,a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->lpVtbl->LockRect(p,a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->lpVtbl->UnlockRect(p,a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->lpVtbl->AddDirtyRect(p,a,b)
#else
#define IDirect3DCubeTexture8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DCubeTexture8_AddRef(p) (p)->AddRef()
#define IDirect3DCubeTexture8_Release(p) (p)->Release()
#define IDirect3DCubeTexture8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DCubeTexture8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DCubeTexture8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DCubeTexture8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DCubeTexture8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DCubeTexture8_GetPriority(p) (p)->GetPriority()
#define IDirect3DCubeTexture8_PreLoad(p) (p)->PreLoad()
#define IDirect3DCubeTexture8_GetType(p) (p)->GetType()
#define IDirect3DCubeTexture8_SetLOD(p,a) (p)->SetLOD(a)
#define IDirect3DCubeTexture8_GetLOD(p) (p)->GetLOD()
#define IDirect3DCubeTexture8_GetLevelCount(p) (p)->GetLevelCount()
#define IDirect3DCubeTexture8_GetLevelDesc(p,a,b) (p)->GetLevelDesc(a,b)
#define IDirect3DCubeTexture8_GetCubeMapSurface(p,a,b,c) (p)->GetCubeMapSurface(a,b,c)
#define IDirect3DCubeTexture8_LockRect(p,a,b,c,d,e) (p)->LockRect(a,b,c,d,e)
#define IDirect3DCubeTexture8_UnlockRect(p,a,b) (p)->UnlockRect(a,b)
#define IDirect3DCubeTexture8_AddDirtyRect(p,a,b) (p)->AddDirtyRect(a,b)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer8

DECLARE_INTERFACE_(IDirect3DVertexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVERTEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DVertexBuffer8 *LPDIRECT3DVERTEXBUFFER8, *PDIRECT3DVERTEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DVertexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DVertexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer8_Release(p) (p)->Release()
#define IDirect3DVertexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVertexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVertexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVertexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVertexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DVertexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DVertexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DVertexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DVertexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DVertexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DIndexBuffer8

DECLARE_INTERFACE_(IDirect3DIndexBuffer8, IDirect3DResource8)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DResource8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD_(DWORD, SetPriority)(THIS_ DWORD PriorityNew) PURE;
    STDMETHOD_(DWORD, GetPriority)(THIS) PURE;
    STDMETHOD_(void, PreLoad)(THIS) PURE;
    STDMETHOD_(D3DRESOURCETYPE, GetType)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ UINT OffsetToLock,UINT SizeToLock,BYTE** ppbData,DWORD Flags) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DINDEXBUFFER_DESC *pDesc) PURE;
};

typedef struct IDirect3DIndexBuffer8 *LPDIRECT3DINDEXBUFFER8, *PDIRECT3DINDEXBUFFER8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DIndexBuffer8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->lpVtbl->SetPriority(p,a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->lpVtbl->GetPriority(p)
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->lpVtbl->PreLoad(p)
#define IDirect3DIndexBuffer8_GetType(p) (p)->lpVtbl->GetType(p)
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#else
#define IDirect3DIndexBuffer8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DIndexBuffer8_AddRef(p) (p)->AddRef()
#define IDirect3DIndexBuffer8_Release(p) (p)->Release()
#define IDirect3DIndexBuffer8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DIndexBuffer8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DIndexBuffer8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DIndexBuffer8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DIndexBuffer8_SetPriority(p,a) (p)->SetPriority(a)
#define IDirect3DIndexBuffer8_GetPriority(p) (p)->GetPriority()
#define IDirect3DIndexBuffer8_PreLoad(p) (p)->PreLoad()
#define IDirect3DIndexBuffer8_GetType(p) (p)->GetType()
#define IDirect3DIndexBuffer8_Lock(p,a,b,c,d) (p)->Lock(a,b,c,d)
#define IDirect3DIndexBuffer8_Unlock(p) (p)->Unlock()
#define IDirect3DIndexBuffer8_GetDesc(p,a) (p)->GetDesc(a)
#endif




#undef INTERFACE
#define INTERFACE IDirect3DSurface8

DECLARE_INTERFACE_(IDirect3DSurface8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DSurface8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DSURFACE_DESC *pDesc) PURE;
    STDMETHOD(LockRect)(THIS_ D3DLOCKED_RECT* pLockedRect,CONST RECT* pRect,DWORD Flags) PURE;
    STDMETHOD(UnlockRect)(THIS) PURE;
};

typedef struct IDirect3DSurface8 *LPDIRECT3DSURFACE8, *PDIRECT3DSURFACE8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DSurface8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DSurface8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DSurface8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->lpVtbl->LockRect(p,a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->lpVtbl->UnlockRect(p)
#else
#define IDirect3DSurface8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DSurface8_AddRef(p) (p)->AddRef()
#define IDirect3DSurface8_Release(p) (p)->Release()
#define IDirect3DSurface8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DSurface8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DSurface8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DSurface8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DSurface8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DSurface8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DSurface8_LockRect(p,a,b,c) (p)->LockRect(a,b,c)
#define IDirect3DSurface8_UnlockRect(p) (p)->UnlockRect()
#endif




#undef INTERFACE
#define INTERFACE IDirect3DVolume8

DECLARE_INTERFACE_(IDirect3DVolume8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVolume8 methods ***/
    STDMETHOD(GetDevice)(THIS_ IDirect3DDevice8** ppDevice) PURE;
    STDMETHOD(SetPrivateData)(THIS_ REFGUID refguid,CONST void* pData,DWORD SizeOfData,DWORD Flags) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID refguid,void* pData,DWORD* pSizeOfData) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID refguid) PURE;
    STDMETHOD(GetContainer)(THIS_ REFIID riid,void** ppContainer) PURE;
    STDMETHOD(GetDesc)(THIS_ D3DVOLUME_DESC *pDesc) PURE;
    STDMETHOD(LockBox)(THIS_ D3DLOCKED_BOX * pLockedVolume,CONST D3DBOX* pBox,DWORD Flags) PURE;
    STDMETHOD(UnlockBox)(THIS) PURE;
};

typedef struct IDirect3DVolume8 *LPDIRECT3DVOLUME8, *PDIRECT3DVOLUME8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVolume8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVolume8_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVolume8_GetDevice(p,a) (p)->lpVtbl->GetDevice(p,a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->lpVtbl->FreePrivateData(p,a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->lpVtbl->GetContainer(p,a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->lpVtbl->GetDesc(p,a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->lpVtbl->LockBox(p,a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->lpVtbl->UnlockBox(p)
#else
#define IDirect3DVolume8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVolume8_AddRef(p) (p)->AddRef()
#define IDirect3DVolume8_Release(p) (p)->Release()
#define IDirect3DVolume8_GetDevice(p,a) (p)->GetDevice(a)
#define IDirect3DVolume8_SetPrivateData(p,a,b,c,d) (p)->SetPrivateData(a,b,c,d)
#define IDirect3DVolume8_GetPrivateData(p,a,b,c) (p)->GetPrivateData(a,b,c)
#define IDirect3DVolume8_FreePrivateData(p,a) (p)->FreePrivateData(a)
#define IDirect3DVolume8_GetContainer(p,a,b) (p)->GetContainer(a,b)
#define IDirect3DVolume8_GetDesc(p,a) (p)->GetDesc(a)
#define IDirect3DVolume8_LockBox(p,a,b,c) (p)->LockBox(a,b,c)
#define IDirect3DVolume8_UnlockBox(p) (p)->UnlockBox()
#endif

/****************************************************************************
 * Flags for SetPrivateData method on all D3D8 interfaces
 *
 * The passed pointer is an IUnknown ptr. The SizeOfData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). Direct3D will call AddRef through this
 * pointer and Release when the private data is destroyed. The data will be
 * destroyed when another SetPrivateData with the same GUID is set, when
 * FreePrivateData is called, or when the D3D8 object is freed.
 ****************************************************************************/
#define D3DSPD_IUNKNOWN                         0x00000001L

/****************************************************************************
 *
 * Parameter for IDirect3D8 Enum and GetCaps8 functions to get the info for
 * the current mode only.
 *
 ****************************************************************************/

#define D3DCURRENT_DISPLAY_MODE                 0x00EFFFFFL

/****************************************************************************
 *
 * Flags for IDirect3D8::CreateDevice's BehaviorFlags
 *
 ****************************************************************************/

#define D3DCREATE_FPU_PRESERVE                  0x00000002L
#define D3DCREATE_MULTITHREADED                 0x00000004L

#define D3DCREATE_PUREDEVICE                    0x00000010L
#define D3DCREATE_SOFTWARE_VERTEXPROCESSING     0x00000020L
#define D3DCREATE_HARDWARE_VERTEXPROCESSING     0x00000040L
#define D3DCREATE_MIXED_VERTEXPROCESSING        0x00000080L


/****************************************************************************
 *
 * Parameter for IDirect3D8::CreateDevice's iAdapter
 *
 ****************************************************************************/

#define D3DADAPTER_DEFAULT                     0

/****************************************************************************
 *
 * Flags for IDirect3D8::EnumAdapters
 *
 ****************************************************************************/

#define D3DENUM_NO_WHQL_LEVEL                   0x00000002L

/****************************************************************************
 *
 * Maximum number of back-buffers supported in DX8
 *
 ****************************************************************************/

#define D3DPRESENT_BACK_BUFFERS_MAX             3L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetGammaRamp
 *
 ****************************************************************************/

#define D3DSGR_NO_CALIBRATION                  0x00000000L
#define D3DSGR_CALIBRATE                       0x00000001L

/****************************************************************************
 *
 * Flags for IDirect3DDevice8::SetCursorPosition
 *
 ****************************************************************************/

#define D3DCURSOR_IMMEDIATE_UPDATE             0x00000001L

/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/


/*
 *  DirectDraw error codes
 */
#define _FACD3D  0x876
#define MAKE_D3DHRESULT( code )  MAKE_HRESULT( 1, _FACD3D, code )

/*
 * Direct3D Errors
 */
#define D3D_OK                              S_OK

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_D3DHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_D3DHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_D3DHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_D3DHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_D3DHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_D3DHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_D3DHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_D3DHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_D3DHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_D3DHRESULT(2082)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_D3DHRESULT(2086)
#define D3DERR_DRIVERINTERNALERROR              MAKE_D3DHRESULT(2087)

#define D3DERR_NOTFOUND                         MAKE_D3DHRESULT(2150)
#define D3DERR_MOREDATA                         MAKE_D3DHRESULT(2151)
#define D3DERR_DEVICELOST                       MAKE_D3DHRESULT(2152)
#define D3DERR_DEVICENOTRESET                   MAKE_D3DHRESULT(2153)
#define D3DERR_NOTAVAILABLE                     MAKE_D3DHRESULT(2154)
#define D3DERR_OUTOFVIDEOMEMORY                 MAKE_D3DHRESULT(380)
#define D3DERR_INVALIDDEVICE                    MAKE_D3DHRESULT(2155)
#define D3DERR_INVALIDCALL                      MAKE_D3DHRESULT(2156)
#define D3DERR_DRIVERINVALIDCALL                MAKE_D3DHRESULT(2157)

#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\dx8\d3d8sddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8sddi.h
 *  Content:    Defines the interface between the ddi thunk layer
 *              and the refrast/RGB HEL layer..
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8SW_INCLUDED__
#define __D3D8SW_INCLUDED__

// Surface types
#define SWSURF_SURFACE                     0x00000001
#define SWSURF_VOLUME                      0x00000002
#define SWSURF_MIPMAP                      0x00000004
#define SWSURF_MIPVOLUME                   0x00000008
#define SWSURF_CUBEMAP                     0x00000010
#define SWSURF_VERTEXBUFFER                0x00000020
#define SWSURF_OPTIMIZERVERTEXBUFFER       0x00000040
#define SWSURF_INDEXBUFFER                 0x00000080
#define SWSURF_COMMANDBUFFER               0x00000100

// Flags
#define SWFLAG_D3DEXENDEDCAPS              0x00000001
#define SWFLAG_D3DGLOBALDRIVERDATA         0x00000002
#define SWFLAG_D3DCAPS8                    0x00000004



typedef struct _D3D8_SWCALLBACKS
{
    // From Callbacks
    LPD3DHAL_CONTEXTCREATECB                CreateContext;
    LPD3DHAL_CONTEXTDESTROYCB               ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB            ContextDestroyAll;
    LPD3DHAL_SCENECAPTURECB                 SceneCapture;
    LPD3DHAL_RENDERSTATECB                  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB              RenderPrimitive;
    LPD3DHAL_TEXTURECREATECB                TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB               TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB                  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB               TextureGetSurf;
    LPD3DHAL_GETSTATECB                     GetState;

    // From Callbacks2
    LPD3DHAL_SETRENDERTARGETCB              SetRenderTarget;
    LPD3DHAL_CLEARCB                        Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB             DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB      DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB               DrawPrimitives;

    // From Callbacks3
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;

    // From MiscCallbacks in DDraw
    LPDDHAL_GETDRIVERSTATE                  GetDriverState;
    LPDDHAL_CREATESURFACEEX                 CreateSurfaceEx;

    // DDraw Callbacks
    LPDDHAL_CREATESURFACE                   CreateSurface;
    LPDDHALSURFCB_DESTROYSURFACE            DestroySurface;
    LPDDHALSURFCB_LOCK                      Lock;
    LPDDHALSURFCB_UNLOCK                    Unlock;

} D3D8_SWCALLBACKS, * PD3D8_SWCALLBACKS;


#ifdef __cplusplus
extern "C" {
#endif

HRESULT APIENTRY D3D8GetSWInfo(
    D3DCAPS8*           pCaps,
    PD3D8_SWCALLBACKS   pCallbacks,
    DWORD*              pNumTextures,
    DDSURFACEDESC**     ppTexList
    );

#ifdef __cplusplus
}
#endif


// Prototypes required to hook the DDI layer (used by RefRast and the HEL

#define D3D8_REFRASTNAME            "D3DREF8.DLL"

#define D3D8HOOK_GETSWINFOPROCNAME  "D3D8GetSWInfo"

typedef HRESULT (WINAPI * PD3D8GetSWInfo)(D3DCAPS8*          pCaps,
                                          PD3D8_SWCALLBACKS  pCallbacks,
                                          DWORD*             pNumTextures,
                                          DDSURFACEDESC**    ppTexList
                                          );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\dx8\d3d8caps.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3d8caps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3D8CAPS_H
#define _D3D8CAPS_H

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0800
#endif  //DIRECT3D_VERSION

// include this file content only if compiling for DX8 interfaces
#if(DIRECT3D_VERSION >= 0x0800)

#pragma pack(4)

typedef struct _D3DCAPS8
{
    /* Device Info */
    D3DDEVTYPE  DeviceType;
    UINT    AdapterOrdinal;

    /* Caps from DX7 Draw */
    DWORD   Caps;
    DWORD   Caps2;
    DWORD   Caps3;
    DWORD   PresentationIntervals;

    /* Cursor Caps */
    DWORD   CursorCaps;

    /* 3D Device Caps */
    DWORD   DevCaps;

    DWORD   PrimitiveMiscCaps;
    DWORD   RasterCaps;
    DWORD   ZCmpCaps;
    DWORD   SrcBlendCaps;
    DWORD   DestBlendCaps;
    DWORD   AlphaCmpCaps;
    DWORD   ShadeCaps;
    DWORD   TextureCaps;
    DWORD   TextureFilterCaps;          // D3DPTFILTERCAPS for IDirect3DTexture8's
    DWORD   CubeTextureFilterCaps;      // D3DPTFILTERCAPS for IDirect3DCubeTexture8's
    DWORD   VolumeTextureFilterCaps;    // D3DPTFILTERCAPS for IDirect3DVolumeTexture8's
    DWORD   TextureAddressCaps;         // D3DPTADDRESSCAPS for IDirect3DTexture8's
    DWORD   VolumeTextureAddressCaps;   // D3DPTADDRESSCAPS for IDirect3DVolumeTexture8's

    DWORD   LineCaps;                   // D3DLINECAPS

    DWORD   MaxTextureWidth, MaxTextureHeight;
    DWORD   MaxVolumeExtent;

    DWORD   MaxTextureRepeat;
    DWORD   MaxTextureAspectRatio;
    DWORD   MaxAnisotropy;
    float   MaxVertexW;

    float   GuardBandLeft;
    float   GuardBandTop;
    float   GuardBandRight;
    float   GuardBandBottom;

    float   ExtentsAdjust;
    DWORD   StencilCaps;

    DWORD   FVFCaps;
    DWORD   TextureOpCaps;
    DWORD   MaxTextureBlendStages;
    DWORD   MaxSimultaneousTextures;

    DWORD   VertexProcessingCaps;
    DWORD   MaxActiveLights;
    DWORD   MaxUserClipPlanes;
    DWORD   MaxVertexBlendMatrices;
    DWORD   MaxVertexBlendMatrixIndex;

    float   MaxPointSize;

    DWORD   MaxPrimitiveCount;          // max number of primitives per DrawPrimitive call
    DWORD   MaxVertexIndex;
    DWORD   MaxStreams;
    DWORD   MaxStreamStride;            // max stride for SetStreamSource

    DWORD   VertexShaderVersion;
    DWORD   MaxVertexShaderConst;       // number of vertex shader constant registers

    DWORD   PixelShaderVersion;
    float   MaxPixelShaderValue;        // max value of pixel shader arithmetic component

} D3DCAPS8;

//
// BIT DEFINES FOR D3DCAPS8 DWORD MEMBERS
//

//
// Caps
//
#define D3DCAPS_READ_SCANLINE           0x00020000L

//
// Caps2
//
#define D3DCAPS2_NO2DDURING3DSCENE      0x00000002L
#define D3DCAPS2_FULLSCREENGAMMA        0x00020000L
#define D3DCAPS2_CANRENDERWINDOWED      0x00080000L
#define D3DCAPS2_CANCALIBRATEGAMMA      0x00100000L
#define D3DCAPS2_RESERVED               0x02000000L

//
// Caps3
//
#define D3DCAPS3_RESERVED               0x8000001fL

//
// PresentationIntervals
//
#define D3DPRESENT_INTERVAL_DEFAULT     0x00000000L
#define D3DPRESENT_INTERVAL_ONE         0x00000001L
#define D3DPRESENT_INTERVAL_TWO         0x00000002L
#define D3DPRESENT_INTERVAL_THREE       0x00000004L
#define D3DPRESENT_INTERVAL_FOUR        0x00000008L
#define D3DPRESENT_INTERVAL_IMMEDIATE   0x80000000L

//
// CursorCaps
//
// Driver supports HW color cursor in at least hi-res modes(height >=400)
#define D3DCURSORCAPS_COLOR             0x00000001L
// Driver supports HW cursor also in low-res modes(height < 400)
#define D3DCURSORCAPS_LOWRES            0x00000002L

//
// DevCaps
//
#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#define D3DDEVCAPS_DRAWPRIMITIVES2      0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREMEMORIES 0x00004000L /* Device is texturing from separate memory pools */
#define D3DDEVCAPS_DRAWPRIMITIVES2EX    0x00008000L /* Device can support Extended DrawPrimitives2 i.e. DX7 compliant driver*/
#define D3DDEVCAPS_HWTRANSFORMANDLIGHT  0x00010000L /* Device can support transformation and lighting in hardware and DRAWPRIMITIVES2EX must be also */
#define D3DDEVCAPS_CANBLTSYSTONONLOCAL  0x00020000L /* Device supports a Tex Blt from system memory to non-local vidmem */
#define D3DDEVCAPS_HWRASTERIZATION      0x00080000L /* Device has HW acceleration for rasterization */
#define D3DDEVCAPS_PUREDEVICE           0x00100000L /* Device supports D3DCREATE_PUREDEVICE */
#define D3DDEVCAPS_QUINTICRTPATCHES     0x00200000L /* Device supports quintic Beziers and BSplines */
#define D3DDEVCAPS_RTPATCHES            0x00400000L /* Device supports Rect and Tri patches */
#define D3DDEVCAPS_RTPATCHHANDLEZERO    0x00800000L /* Indicates that RT Patches may be drawn efficiently using handle 0 */
#define D3DDEVCAPS_NPATCHES             0x01000000L /* Device supports N-Patches */

//
// PrimitiveMiscCaps
//
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L
#define D3DPMISCCAPS_COLORWRITEENABLE   0x00000080L
#define D3DPMISCCAPS_CLIPPLANESCALEDPOINTS 0x00000100L /* Device correctly clips scaled points to clip planes */
#define D3DPMISCCAPS_CLIPTLVERTS        0x00000200L /* device will clip post-transformed vertex primitives */
#define D3DPMISCCAPS_TSSARGTEMP         0x00000400L /* device supports D3DTA_TEMP for temporary register */
#define D3DPMISCCAPS_BLENDOP            0x00000800L /* device supports D3DRS_BLENDOP */

//
// LineCaps
//
#define D3DLINECAPS_TEXTURE             0x00000001L
#define D3DLINECAPS_ZTEST               0x00000002L
#define D3DLINECAPS_BLEND               0x00000004L
#define D3DLINECAPS_ALPHACMP            0x00000008L
#define D3DLINECAPS_FOG                 0x00000010L

//
// RasterCaps
//
#define D3DPRASTERCAPS_DITHER           0x00000001L
#define D3DPRASTERCAPS_PAT              0x00000008L
#define D3DPRASTERCAPS_ZTEST            0x00000010L
#define D3DPRASTERCAPS_FOGVERTEX        0x00000080L
#define D3DPRASTERCAPS_FOGTABLE         0x00000100L
#define D3DPRASTERCAPS_ANTIALIASEDGES   0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS    0x00002000L
#define D3DPRASTERCAPS_ZBIAS            0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR   0x00008000L
#define D3DPRASTERCAPS_FOGRANGE         0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY       0x00020000L
#define D3DPRASTERCAPS_WBUFFER          0x00040000L
#define D3DPRASTERCAPS_WFOG             0x00100000L
#define D3DPRASTERCAPS_ZFOG             0x00200000L
#define D3DPRASTERCAPS_COLORPERSPECTIVE 0x00400000L /* Device iterates colors perspective correct */
#define D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  0x00800000L

//
// ZCmpCaps, AlphaCmpCaps
//
#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

//
// SourceBlendCaps, DestBlendCaps
//
#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

//
// ShadeCaps
//
#define D3DPSHADECAPS_COLORGOURAUDRGB       0x00000008L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB    0x00000200L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND     0x00004000L
#define D3DPSHADECAPS_FOGGOURAUD            0x00080000L

//
// TextureCaps
//
#define D3DPTEXTURECAPS_PERSPECTIVE         0x00000001L /* Perspective-correct texturing is supported */
#define D3DPTEXTURECAPS_POW2                0x00000002L /* Power-of-2 texture dimensions are required - applies to non-Cube/Volume textures only. */
#define D3DPTEXTURECAPS_ALPHA               0x00000004L /* Alpha in texture pixels is supported */
#define D3DPTEXTURECAPS_SQUAREONLY          0x00000020L /* Only square textures are supported */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L /* Texture indices are not scaled by the texture size prior to interpolation */
#define D3DPTEXTURECAPS_ALPHAPALETTE        0x00000080L /* Device can draw alpha from texture palettes */
// Device can use non-POW2 textures if:
//  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
//  2) D3DRS_WRAP(N) is zero for this texture's coordinates
//  3) mip mapping is not enabled (use magnification filter only)
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L
#define D3DPTEXTURECAPS_PROJECTED           0x00000400L /* Device can do D3DTTFF_PROJECTED */
#define D3DPTEXTURECAPS_CUBEMAP             0x00000800L /* Device can do cubemap textures */
#define D3DPTEXTURECAPS_VOLUMEMAP           0x00002000L /* Device can do volume textures */
#define D3DPTEXTURECAPS_MIPMAP              0x00004000L /* Device can do mipmapped textures */
#define D3DPTEXTURECAPS_MIPVOLUMEMAP        0x00008000L /* Device can do mipmapped volume textures */
#define D3DPTEXTURECAPS_MIPCUBEMAP          0x00010000L /* Device can do mipmapped cube maps */
#define D3DPTEXTURECAPS_CUBEMAP_POW2        0x00020000L /* Device requires that cubemaps be power-of-2 dimension */
#define D3DPTEXTURECAPS_VOLUMEMAP_POW2      0x00040000L /* Device requires that volume maps be power-of-2 dimension */

//
// TextureFilterCaps
//
#define D3DPTFILTERCAPS_MINFPOINT           0x00000100L /* Min Filter */
#define D3DPTFILTERCAPS_MINFLINEAR          0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC     0x00000400L
#define D3DPTFILTERCAPS_MIPFPOINT           0x00010000L /* Mip Filter */
#define D3DPTFILTERCAPS_MIPFLINEAR          0x00020000L
#define D3DPTFILTERCAPS_MAGFPOINT           0x01000000L /* Mag Filter */
#define D3DPTFILTERCAPS_MAGFLINEAR          0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC     0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC      0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC   0x10000000L

//
// TextureAddressCaps
//
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#define D3DPTADDRESSCAPS_MIRRORONCE     0x00000020L

//
// StencilCaps
//
#define D3DSTENCILCAPS_KEEP             0x00000001L
#define D3DSTENCILCAPS_ZERO             0x00000002L
#define D3DSTENCILCAPS_REPLACE          0x00000004L
#define D3DSTENCILCAPS_INCRSAT          0x00000008L
#define D3DSTENCILCAPS_DECRSAT          0x00000010L
#define D3DSTENCILCAPS_INVERT           0x00000020L
#define D3DSTENCILCAPS_INCR             0x00000040L
#define D3DSTENCILCAPS_DECR             0x00000080L

//
// TextureOpCaps
//
#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L
#define D3DTEXOPCAPS_MULTIPLYADD                0x01000000L
#define D3DTEXOPCAPS_LERP                       0x02000000L

//
// FVFCaps
//
#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */
#define D3DFVFCAPS_PSIZE                0x00100000L /* Device can receive point size */

//
// VertexProcessingCaps
//
#define D3DVTXPCAPS_TEXGEN              0x00000001L /* device can do texgen */
#define D3DVTXPCAPS_MATERIALSOURCE7     0x00000002L /* device can do DX7-level colormaterialsource ops */
#define D3DVTXPCAPS_DIRECTIONALLIGHTS   0x00000008L /* device can do directional lights */
#define D3DVTXPCAPS_POSITIONALLIGHTS    0x00000010L /* device can do positional lights (includes point and spot) */
#define D3DVTXPCAPS_LOCALVIEWER         0x00000020L /* device can do local viewer */
#define D3DVTXPCAPS_TWEENING            0x00000040L /* device can do vertex tweening */
#define D3DVTXPCAPS_NO_VSDT_UBYTE4      0x00000080L /* device does not support D3DVSDT_UBYTE4 */

#pragma pack()

#endif /* (DIRECT3D_VERSION >= 0x0800) */
#endif /* _D3D8CAPS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\inc\BString.h ===
#ifndef _BSTRING_H
#define _BSTRING_H

//////////////////////////////////////////////////////////////////////////////
// string
//
class BString
{
    //
    // members
    //
protected:
    char *m_pszData;
    int   m_iMax;

    //
    // methods
    //
protected:
    void grow (int iNewMax,int bCopy)
    {
        iNewMax = max(iNewMax,4);
        iNewMax = (iNewMax + 127) & ~127;
        if (iNewMax && (iNewMax != m_iMax))
        {
            char *pszTemp = new char[iNewMax];
            if (!pszTemp) throw new BException(BException::outOfMemory);
            if (m_pszData && bCopy) strcpy (pszTemp,m_pszData);
            delete[] m_pszData;
            m_pszData = pszTemp;
            m_iMax    = iNewMax;
        }
    }
    void kill (void)
    {
        delete[] m_pszData;
        m_pszData = NULL; m_iMax = 0;
    }

    //
    // helpers
    //
public:
    inline int length (void) const { return m_pszData ? strlen(m_pszData) : 0; }

    inline void prepareForSize (int iCount) { grow (iCount,TRUE); }

    inline void place  (int pos,const BString& str)
    { 
        assert ((pos >= 0) && (pos <= length())); 
        int l1 = length();
        int l2 = str.length();
        grow (l1 + l2 + 1,1); 
        memcpy (m_pszData + pos,(const char*)str,l2); 
        if ((pos + l2) > l1) m_pszData[pos + l2] = 0;
    }
    inline void insert (int pos,const BString& str)
    { 
        assert ((pos >= 0) && (pos <= length())); 
        int l1 = length();
        int l2 = str.length();
        grow (l1 + l2 + 1,1); 
        memmove (m_pszData + pos + l2,m_pszData + pos,l1 - pos + 1); 
        memcpy (m_pszData + pos,(const char*)str,l2);
        m_pszData[l1 + l2] = 0;
    }
    inline void remove (int pos,int count = 1)
    {
        assert ((pos >= 0) && (pos < length()));
        strcpy (m_pszData + pos,m_pszData + pos + count);
        grow (length(),1); // shrink buffer
    }
    inline BString left (int count) const
    {
        BString str = *this;
        if (count < str.length()) str.m_pszData[count] = 0;
        return str;
    }
    inline BString right (int count) const
    {
        BString str = *this;
        int     len = str.length();
        if (count < len)
        {
            memmove (str.m_pszData,str.m_pszData + len - count,count + 1);
        }
        return str;
    }
    inline BString mid (int index,int count = 0x7fffffff) const
    {
        BString str = *this;
        int     len = str.length();
        if (index < len)
        {
            count = min(len - index,count);
            memmove (str.m_pszData,str.m_pszData + index,count);
            str.m_pszData[count] = 0;
        }
        else
        {
            str.m_pszData[0] = 0;
        }
        return str;
    }

    inline int find (const BString& sub) const
    {
        if (m_pszData && sub.m_pszData)
        {
            char *c = strstr(m_pszData,sub.m_pszData);
            return c ? (c - m_pszData) : -1;
        }
        return -1;
    }

    inline void format (const char *szFormat,...)
    {
        char sz[1024];
        vsprintf (sz,szFormat,(char*)(unsigned(&szFormat) + 4));
        *this = sz;
    }

    inline BString makeUpper (void) { BString str = *this; strupr ((char*)(const char*)str); return str; }
    inline BString makeLower (void) { BString str = *this; strlwr ((char*)(const char*)str); return str; }

    //
    // operators
    //
public:
    inline operator const char* (void) const { return (const char*)(m_pszData ? m_pszData : ""); }

    inline const BString& operator=  (const char* psz)    { grow(strlen(psz),0); strcpy (m_pszData,psz); return *this; }
    inline const BString& operator+= (const char *sz)     { grow(length() + strlen(sz) + 1,1); strcat (m_pszData,sz); return *this; }

    inline const BString& operator=  (const BString& str) { *this  = (const char*)str; return *this; }
    inline const BString& operator+= (const BString& str) { *this += (const char*)str; return *this; }

    //inline const int operator== (const BString& str) { return !strcmp(m_pszData ? m_pszData : "",str.m_pszData ? str.m_pszData : ""); }
    friend inline int operator== (const BString& s1,const BString& s2);

    //
    // construction
    //
public:
    inline  BString (const char* psz)    { m_pszData = NULL; m_iMax = 0; *this = psz; }
    inline  BString (const BString& str) { m_pszData = NULL; m_iMax = 0; *this = str; }
    inline  BString (void)               { m_pszData = NULL; m_iMax = 0; }
    inline ~BString (void)               { kill(); }
};


inline int operator== (const BString& s1,const BString& s2) { return !strcmp(s1.m_pszData ? s1.m_pszData : "",s2.m_pszData ? s2.m_pszData : ""); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\dx8\d3d.h ===
/*==========================================================================;
 *
 *
 *  File:   d3d.h
 *  Content:    Direct3D include file
 *
 ****************************************************************************/

#ifndef _D3D_H_
#define _D3D_H_

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

// include this file content only if compiling for <=DX7 interfaces
#if(DIRECT3D_VERSION < 0x0800)


#include <stdlib.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define D3DAPI WINAPI

/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)
DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3D7,            0xf5049e77,0x4861,0x11d2,0xa4,0x7,0x0,0xa0,0xc9,0x6,0x29,0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DTnLHalDevice, 0xf5049e78, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Internal Guid to distinguish requested MMX from MMX being used as an RGB rasterizer
 */

DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DDevice7,  0xf5049e79, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */

DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */

DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );

DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
#endif /* DIRECT3D_VERSION >= 0x0600 */

DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#if(DIRECT3D_VERSION >= 0x0500)
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0600)
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);
#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)
DEFINE_GUID( IID_IDirect3DVertexBuffer7, 0xf5049e7d, 0x4861, 0x11d2, 0xa4, 0x7, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
#endif /* DIRECT3D_VERSION >= 0x0700 */
#endif

#ifdef __cplusplus
struct IDirect3D;
struct IDirect3DDevice;
struct IDirect3DLight;
struct IDirect3DMaterial;
struct IDirect3DExecuteBuffer;
struct IDirect3DTexture;
struct IDirect3DViewport;
typedef struct IDirect3D            *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
struct IDirect3D2;
struct IDirect3DDevice2;
struct IDirect3DMaterial2;
struct IDirect3DTexture2;
struct IDirect3DViewport2;
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
struct IDirect3D3;
struct IDirect3DDevice3;
struct IDirect3DMaterial3;
struct IDirect3DViewport3;
struct IDirect3DVertexBuffer;
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
struct IDirect3D7;
struct IDirect3DDevice7;
struct IDirect3DVertexBuffer7;
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#else

typedef struct IDirect3D        *LPDIRECT3D;
typedef struct IDirect3DDevice      *LPDIRECT3DDEVICE;
typedef struct IDirect3DExecuteBuffer   *LPDIRECT3DEXECUTEBUFFER;
typedef struct IDirect3DLight       *LPDIRECT3DLIGHT;
typedef struct IDirect3DMaterial    *LPDIRECT3DMATERIAL;
typedef struct IDirect3DTexture     *LPDIRECT3DTEXTURE;
typedef struct IDirect3DViewport    *LPDIRECT3DVIEWPORT;

#if(DIRECT3D_VERSION >= 0x0500)
typedef struct IDirect3D2           *LPDIRECT3D2;
typedef struct IDirect3DDevice2     *LPDIRECT3DDEVICE2;
typedef struct IDirect3DMaterial2   *LPDIRECT3DMATERIAL2;
typedef struct IDirect3DTexture2    *LPDIRECT3DTEXTURE2;
typedef struct IDirect3DViewport2   *LPDIRECT3DVIEWPORT2;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
typedef struct IDirect3D3            *LPDIRECT3D3;
typedef struct IDirect3DDevice3      *LPDIRECT3DDEVICE3;
typedef struct IDirect3DMaterial3    *LPDIRECT3DMATERIAL3;
typedef struct IDirect3DViewport3    *LPDIRECT3DVIEWPORT3;
typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct IDirect3D7             *LPDIRECT3D7;
typedef struct IDirect3DDevice7       *LPDIRECT3DDEVICE7;
typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#endif

#include "d3dtypes.h"
#include "d3dcaps.h"


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Direct3D interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3D

DECLARE_INTERFACE_(IDirect3D, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D methods ***/
    STDMETHOD(Initialize)(THIS_ REFCLSID) PURE;
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
};

typedef struct IDirect3D *LPDIRECT3D;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3D_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#else
#define IDirect3D_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D_AddRef(p) (p)->AddRef()
#define IDirect3D_Release(p) (p)->Release()
#define IDirect3D_Initialize(p,a) (p)->Initialize(a)
#define IDirect3D_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D_FindDevice(p,a,b) (p)->FindDevice(a,b)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3D2

DECLARE_INTERFACE_(IDirect3D2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D2 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,IUnknown*) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL2*,IUnknown*) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT2*,IUnknown*) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE,LPDIRECT3DDEVICE2*) PURE;
};

typedef struct IDirect3D2 *LPDIRECT3D2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D2_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#else
#define IDirect3D2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D2_AddRef(p) (p)->AddRef()
#define IDirect3D2_Release(p) (p)->Release()
#define IDirect3D2_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D2_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D2_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D2_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D2_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3D3

DECLARE_INTERFACE_(IDirect3D3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D3 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateLight)(THIS_ LPDIRECT3DLIGHT*,LPUNKNOWN) PURE;
    STDMETHOD(CreateMaterial)(THIS_ LPDIRECT3DMATERIAL3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateViewport)(THIS_ LPDIRECT3DVIEWPORT3*,LPUNKNOWN) PURE;
    STDMETHOD(FindDevice)(THIS_ LPD3DFINDDEVICESEARCH,LPD3DFINDDEVICERESULT) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE4,LPDIRECT3DDEVICE3*,LPUNKNOWN) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER*,DWORD,LPUNKNOWN) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D3 *LPDIRECT3D3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D3_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->lpVtbl->CreateLight(p,a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->lpVtbl->CreateMaterial(p,a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->lpVtbl->CreateViewport(p,a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->lpVtbl->FindDevice(p,a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D3_AddRef(p) (p)->AddRef()
#define IDirect3D3_Release(p) (p)->Release()
#define IDirect3D3_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D3_CreateLight(p,a,b) (p)->CreateLight(a,b)
#define IDirect3D3_CreateMaterial(p,a,b) (p)->CreateMaterial(a,b)
#define IDirect3D3_CreateViewport(p,a,b) (p)->CreateViewport(a,b)
#define IDirect3D3_FindDevice(p,a,b) (p)->FindDevice(a,b)
#define IDirect3D3_CreateDevice(p,a,b,c,d) (p)->CreateDevice(a,b,c,d)
#define IDirect3D3_CreateVertexBuffer(p,a,b,c,d) (p)->CreateVertexBuffer(a,b,c,d)
#define IDirect3D3_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D3_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3D7

DECLARE_INTERFACE_(IDirect3D7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3D7 methods ***/
    STDMETHOD(EnumDevices)(THIS_ LPD3DENUMDEVICESCALLBACK7,LPVOID) PURE;
    STDMETHOD(CreateDevice)(THIS_ REFCLSID,LPDIRECTDRAWSURFACE7,LPDIRECT3DDEVICE7*) PURE;
    STDMETHOD(CreateVertexBuffer)(THIS_ LPD3DVERTEXBUFFERDESC,LPDIRECT3DVERTEXBUFFER7*,DWORD) PURE;
    STDMETHOD(EnumZBufferFormats)(THIS_ REFCLSID,LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(EvictManagedTextures)(THIS) PURE;
};

typedef struct IDirect3D7 *LPDIRECT3D7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3D7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3D7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3D7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3D7_EnumDevices(p,a,b) (p)->lpVtbl->EnumDevices(p,a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->lpVtbl->CreateVertexBuffer(p,a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->lpVtbl->EnumZBufferFormats(p,a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->lpVtbl->EvictManagedTextures(p)
#else
#define IDirect3D7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3D7_AddRef(p) (p)->AddRef()
#define IDirect3D7_Release(p) (p)->Release()
#define IDirect3D7_EnumDevices(p,a,b) (p)->EnumDevices(a,b)
#define IDirect3D7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirect3D7_CreateVertexBuffer(p,a,b,c) (p)->CreateVertexBuffer(a,b,c)
#define IDirect3D7_EnumZBufferFormats(p,a,b,c) (p)->EnumZBufferFormats(a,b,c)
#define IDirect3D7_EvictManagedTextures(p) (p)->EvictManagedTextures()
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */
/*
 * Direct3D Device interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DDevice

DECLARE_INTERFACE_(IDirect3DDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D,LPGUID,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE,LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(CreateExecuteBuffer)(THIS_ LPD3DEXECUTEBUFFERDESC,LPDIRECT3DEXECUTEBUFFER*,IUnknown*) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(Execute)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT,LPDIRECT3DVIEWPORT*,DWORD) PURE;
    STDMETHOD(Pick)(THIS_ LPDIRECT3DEXECUTEBUFFER,LPDIRECT3DVIEWPORT,DWORD,LPD3DRECT) PURE;
    STDMETHOD(GetPickRecords)(THIS_ LPDWORD,LPD3DPICKRECORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(CreateMatrix)(THIS_ LPD3DMATRIXHANDLE) PURE;
    STDMETHOD(SetMatrix)(THIS_ D3DMATRIXHANDLE,const LPD3DMATRIX) PURE;
    STDMETHOD(GetMatrix)(THIS_ D3DMATRIXHANDLE,LPD3DMATRIX) PURE;
    STDMETHOD(DeleteMatrix)(THIS_ D3DMATRIXHANDLE) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D*) PURE;
};

typedef struct IDirect3DDevice *LPDIRECT3DDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->lpVtbl->CreateExecuteBuffer(p,a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->lpVtbl->Execute(p,a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->lpVtbl->Pick(p,a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->lpVtbl->GetPickRecords(p,a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->lpVtbl->CreateMatrix(p,a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->lpVtbl->SetMatrix(p,a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->lpVtbl->GetMatrix(p,a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->lpVtbl->DeleteMatrix(p,a)
#define IDirect3DDevice_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#else
#define IDirect3DDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice_AddRef(p) (p)->AddRef()
#define IDirect3DDevice_Release(p) (p)->Release()
#define IDirect3DDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirect3DDevice_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice_CreateExecuteBuffer(p,a,b,c) (p)->CreateExecuteBuffer(a,b,c)
#define IDirect3DDevice_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice_Execute(p,a,b,c) (p)->Execute(a,b,c)
#define IDirect3DDevice_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice_Pick(p,a,b,c,d) (p)->Pick(a,b,c,d)
#define IDirect3DDevice_GetPickRecords(p,a,b) (p)->GetPickRecords(a,b)
#define IDirect3DDevice_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice_CreateMatrix(p,a) (p)->CreateMatrix(a)
#define IDirect3DDevice_SetMatrix(p,a,b) (p)->SetMatrix(a,b)
#define IDirect3DDevice_GetMatrix(p,a,b) (p)->GetMatrix(a,b)
#define IDirect3DDevice_DeleteMatrix(p,a) (p)->DeleteMatrix(a)
#define IDirect3DDevice_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice_EndScene(p) (p)->EndScene()
#define IDirect3DDevice_GetDirect3D(p,a) (p)->GetDirect3D(a)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DDevice2

DECLARE_INTERFACE_(IDirect3DDevice2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice2 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(SwapTextureHandles)(THIS_ LPDIRECT3DTEXTURE2,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT2,LPDIRECT3DVIEWPORT2*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMTEXTUREFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D2*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT2 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,D3DVERTEXTYPE,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
};

typedef struct IDirect3DDevice2 *LPDIRECT3DDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->lpVtbl->SwapTextureHandles(p,a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice2_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice2_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice2_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#else
#define IDirect3DDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice2_AddRef(p) (p)->AddRef()
#define IDirect3DDevice2_Release(p) (p)->Release()
#define IDirect3DDevice2_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice2_SwapTextureHandles(p,a,b) (p)->SwapTextureHandles(a,b)
#define IDirect3DDevice2_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice2_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice2_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice2_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice2_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice2_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice2_EndScene(p) (p)->EndScene()
#define IDirect3DDevice2_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice2_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice2_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice2_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice2_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice2_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice2_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice2_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice2_Index(p,a) (p)->Index(a)
#define IDirect3DDevice2_End(p,a) (p)->End(a)
#define IDirect3DDevice2_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice2_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice2_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice2_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice2_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice2_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice2_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice2_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice2_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice2_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice2_GetClipStatus(p,a) (p)->GetClipStatus(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DDevice3

DECLARE_INTERFACE_(IDirect3DDevice3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice3 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC,LPD3DDEVICEDESC) PURE;
    STDMETHOD(GetStats)(THIS_ LPD3DSTATS) PURE;
    STDMETHOD(AddViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(DeleteViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(NextViewport)(THIS_ LPDIRECT3DVIEWPORT3,LPDIRECT3DVIEWPORT3*,DWORD) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D3*) PURE;
    STDMETHOD(SetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3) PURE;
    STDMETHOD(GetCurrentViewport)(THIS_ LPDIRECT3DVIEWPORT3 *) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(Begin)(THIS_ D3DPRIMITIVETYPE,DWORD,DWORD) PURE;
    STDMETHOD(BeginIndexed)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(Vertex)(THIS_ LPVOID) PURE;
    STDMETHOD(Index)(THIS_ WORD) PURE;
    STDMETHOD(End)(THIS_ DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetLightState)(THIS_ D3DLIGHTSTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetLightState)(THIS_ D3DLIGHTSTATETYPE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECT3DTEXTURE2) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
};

typedef struct IDirect3DDevice3 *LPDIRECT3DDEVICE3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->lpVtbl->GetCaps(p,a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->lpVtbl->GetStats(p,a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->lpVtbl->AddViewport(p,a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->lpVtbl->DeleteViewport(p,a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->lpVtbl->NextViewport(p,a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice3_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->lpVtbl->SetCurrentViewport(p,a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->lpVtbl->GetCurrentViewport(p,a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->lpVtbl->Begin(p,a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->lpVtbl->BeginIndexed(p,a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->lpVtbl->Vertex(p,a)
#define IDirect3DDevice3_Index(p,a) (p)->lpVtbl->Index(p,a)
#define IDirect3DDevice3_End(p,a) (p)->lpVtbl->End(p,a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->lpVtbl->GetLightState(p,a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->lpVtbl->SetLightState(p,a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#else
#define IDirect3DDevice3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice3_AddRef(p) (p)->AddRef()
#define IDirect3DDevice3_Release(p) (p)->Release()
#define IDirect3DDevice3_GetCaps(p,a,b) (p)->GetCaps(a,b)
#define IDirect3DDevice3_GetStats(p,a) (p)->GetStats(a)
#define IDirect3DDevice3_AddViewport(p,a) (p)->AddViewport(a)
#define IDirect3DDevice3_DeleteViewport(p,a) (p)->DeleteViewport(a)
#define IDirect3DDevice3_NextViewport(p,a,b,c) (p)->NextViewport(a,b,c)
#define IDirect3DDevice3_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice3_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice3_EndScene(p) (p)->EndScene()
#define IDirect3DDevice3_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice3_SetCurrentViewport(p,a) (p)->SetCurrentViewport(a)
#define IDirect3DDevice3_GetCurrentViewport(p,a) (p)->GetCurrentViewport(a)
#define IDirect3DDevice3_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice3_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice3_Begin(p,a,b,c) (p)->Begin(a,b,c)
#define IDirect3DDevice3_BeginIndexed(p,a,b,c,d,e) (p)->BeginIndexed(a,b,c,d,e)
#define IDirect3DDevice3_Vertex(p,a) (p)->Vertex(a)
#define IDirect3DDevice3_Index(p,a) (p)->Index(a)
#define IDirect3DDevice3_End(p,a) (p)->End(a)
#define IDirect3DDevice3_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice3_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice3_GetLightState(p,a,b) (p)->GetLightState(a,b)
#define IDirect3DDevice3_SetLightState(p,a,b) (p)->SetLightState(a,b)
#define IDirect3DDevice3_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice3_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice3_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice3_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice3_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice3_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice3_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice3_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_DrawIndexedPrimitiveVB(p,a,b,c,d,e) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice3_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice3_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice3_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice3_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice3_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice3_ValidateDevice(p,a) (p)->ValidateDevice(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DDevice7

DECLARE_INTERFACE_(IDirect3DDevice7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDevice7 methods ***/
    STDMETHOD(GetCaps)(THIS_ LPD3DDEVICEDESC7) PURE;
    STDMETHOD(EnumTextureFormats)(THIS_ LPD3DENUMPIXELFORMATSCALLBACK,LPVOID) PURE;
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;
    STDMETHOD(GetDirect3D)(THIS_ LPDIRECT3D7*) PURE;
    STDMETHOD(SetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7,DWORD) PURE;
    STDMETHOD(GetRenderTarget)(THIS_ LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
    STDMETHOD(SetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(MultiplyTransform)(THIS_ D3DTRANSFORMSTATETYPE,LPD3DMATRIX) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT7) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL7) PURE;
    STDMETHOD(SetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(GetLight)(THIS_ DWORD,LPD3DLIGHT7) PURE;
    STDMETHOD(SetRenderState)(THIS_ D3DRENDERSTATETYPE,DWORD) PURE;
    STDMETHOD(GetRenderState)(THIS_ D3DRENDERSTATETYPE,LPDWORD) PURE;
    STDMETHOD(BeginStateBlock)(THIS) PURE;
    STDMETHOD(EndStateBlock)(THIS_ LPDWORD) PURE;
    STDMETHOD(PreLoad)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(DrawPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitive)(THIS_ D3DPRIMITIVETYPE,DWORD,LPVOID,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(SetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(GetClipStatus)(THIS_ LPD3DCLIPSTATUS) PURE;
    STDMETHOD(DrawPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveStrided)(THIS_ D3DPRIMITIVETYPE,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(DrawIndexedPrimitiveVB)(THIS_ D3DPRIMITIVETYPE,LPDIRECT3DVERTEXBUFFER7,DWORD,DWORD,LPWORD,DWORD,DWORD) PURE;
    STDMETHOD(ComputeSphereVisibility)(THIS_ LPD3DVECTOR,LPD3DVALUE,DWORD,DWORD,LPDWORD) PURE;
    STDMETHOD(GetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(SetTexture)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(GetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,LPDWORD) PURE;
    STDMETHOD(SetTextureStageState)(THIS_ DWORD,D3DTEXTURESTAGESTATETYPE,DWORD) PURE;
    STDMETHOD(ValidateDevice)(THIS_ LPDWORD) PURE;
    STDMETHOD(ApplyStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CaptureStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(DeleteStateBlock)(THIS_ DWORD) PURE;
    STDMETHOD(CreateStateBlock)(THIS_ D3DSTATEBLOCKTYPE,LPDWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECTDRAWSURFACE7,LPPOINT,LPDIRECTDRAWSURFACE7,LPRECT,DWORD) PURE;
    STDMETHOD(LightEnable)(THIS_ DWORD,BOOL) PURE;
    STDMETHOD(GetLightEnable)(THIS_ DWORD,BOOL*) PURE;
    STDMETHOD(SetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetClipPlane)(THIS_ DWORD,D3DVALUE*) PURE;
    STDMETHOD(GetInfo)(THIS_ DWORD,LPVOID,DWORD) PURE;
};

typedef struct IDirect3DDevice7 *LPDIRECT3DDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DDevice7_GetCaps(p,a) (p)->lpVtbl->GetCaps(p,a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->lpVtbl->EnumTextureFormats(p,a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->lpVtbl->BeginScene(p)
#define IDirect3DDevice7_EndScene(p) (p)->lpVtbl->EndScene(p)
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->lpVtbl->GetDirect3D(p,a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->lpVtbl->SetRenderTarget(p,a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->lpVtbl->GetRenderTarget(p,a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->lpVtbl->Clear(p,a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->lpVtbl->SetTransform(p,a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->lpVtbl->GetTransform(p,a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->lpVtbl->MultiplyTransform(p,a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->lpVtbl->SetLight(p,a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->lpVtbl->GetLight(p,a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->lpVtbl->SetRenderState(p,a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->lpVtbl->GetRenderState(p,a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->lpVtbl->BeginStateBlock(p)
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->lpVtbl->EndStateBlock(p,a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->lpVtbl->PreLoad(p,a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitive(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitive(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->lpVtbl->SetClipStatus(p,a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->lpVtbl->GetClipStatus(p,a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveStrided(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->lpVtbl->DrawPrimitiveVB(p,a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->lpVtbl->DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->lpVtbl->ComputeSphereVisibility(p,a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->lpVtbl->GetTexture(p,a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->lpVtbl->SetTexture(p,a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->lpVtbl->GetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->lpVtbl->SetTextureStageState(p,a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->lpVtbl->ValidateDevice(p,a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->lpVtbl->ApplyStateBlock(p,a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->lpVtbl->CaptureStateBlock(p,a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->lpVtbl->DeleteStateBlock(p,a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->lpVtbl->CreateStateBlock(p,a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->lpVtbl->Load(p,a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->lpVtbl->LightEnable(p,a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->lpVtbl->GetLightEnable(p,a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->lpVtbl->SetClipPlane(p,a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->lpVtbl->GetClipPlane(p,a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->lpVtbl->GetInfo(p,a,b,c)
#else
#define IDirect3DDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DDevice7_AddRef(p) (p)->AddRef()
#define IDirect3DDevice7_Release(p) (p)->Release()
#define IDirect3DDevice7_GetCaps(p,a) (p)->GetCaps(a)
#define IDirect3DDevice7_EnumTextureFormats(p,a,b) (p)->EnumTextureFormats(a,b)
#define IDirect3DDevice7_BeginScene(p) (p)->BeginScene()
#define IDirect3DDevice7_EndScene(p) (p)->EndScene()
#define IDirect3DDevice7_GetDirect3D(p,a) (p)->GetDirect3D(a)
#define IDirect3DDevice7_SetRenderTarget(p,a,b) (p)->SetRenderTarget(a,b)
#define IDirect3DDevice7_GetRenderTarget(p,a) (p)->GetRenderTarget(a)
#define IDirect3DDevice7_Clear(p,a,b,c,d,e,f) (p)->Clear(a,b,c,d,e,f)
#define IDirect3DDevice7_SetTransform(p,a,b) (p)->SetTransform(a,b)
#define IDirect3DDevice7_GetTransform(p,a,b) (p)->GetTransform(a,b)
#define IDirect3DDevice7_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DDevice7_MultiplyTransform(p,a,b) (p)->MultiplyTransform(a,b)
#define IDirect3DDevice7_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DDevice7_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DDevice7_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DDevice7_SetLight(p,a,b) (p)->SetLight(a,b)
#define IDirect3DDevice7_GetLight(p,a,b) (p)->GetLight(a,b)
#define IDirect3DDevice7_SetRenderState(p,a,b) (p)->SetRenderState(a,b)
#define IDirect3DDevice7_GetRenderState(p,a,b) (p)->GetRenderState(a,b)
#define IDirect3DDevice7_BeginStateBlock(p) (p)->BeginStateBlock()
#define IDirect3DDevice7_EndStateBlock(p,a) (p)->EndStateBlock(a)
#define IDirect3DDevice7_PreLoad(p,a) (p)->PreLoad(a)
#define IDirect3DDevice7_DrawPrimitive(p,a,b,c,d,e) (p)->DrawPrimitive(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitive(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitive(a,b,c,d,e,f,g)
#define IDirect3DDevice7_SetClipStatus(p,a) (p)->SetClipStatus(a)
#define IDirect3DDevice7_GetClipStatus(p,a) (p)->GetClipStatus(a)
#define IDirect3DDevice7_DrawPrimitiveStrided(p,a,b,c,d,e) (p)->DrawPrimitiveStrided(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveStrided(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveStrided(a,b,c,d,e,f,g)
#define IDirect3DDevice7_DrawPrimitiveVB(p,a,b,c,d,e) (p)->DrawPrimitiveVB(a,b,c,d,e)
#define IDirect3DDevice7_DrawIndexedPrimitiveVB(p,a,b,c,d,e,f,g) (p)->DrawIndexedPrimitiveVB(a,b,c,d,e,f,g)
#define IDirect3DDevice7_ComputeSphereVisibility(p,a,b,c,d,e) (p)->ComputeSphereVisibility(a,b,c,d,e)
#define IDirect3DDevice7_GetTexture(p,a,b) (p)->GetTexture(a,b)
#define IDirect3DDevice7_SetTexture(p,a,b) (p)->SetTexture(a,b)
#define IDirect3DDevice7_GetTextureStageState(p,a,b,c) (p)->GetTextureStageState(a,b,c)
#define IDirect3DDevice7_SetTextureStageState(p,a,b,c) (p)->SetTextureStageState(a,b,c)
#define IDirect3DDevice7_ValidateDevice(p,a) (p)->ValidateDevice(a)
#define IDirect3DDevice7_ApplyStateBlock(p,a) (p)->ApplyStateBlock(a)
#define IDirect3DDevice7_CaptureStateBlock(p,a) (p)->CaptureStateBlock(a)
#define IDirect3DDevice7_DeleteStateBlock(p,a) (p)->DeleteStateBlock(a)
#define IDirect3DDevice7_CreateStateBlock(p,a,b) (p)->CreateStateBlock(a,b)
#define IDirect3DDevice7_Load(p,a,b,c,d,e) (p)->Load(a,b,c,d,e)
#define IDirect3DDevice7_LightEnable(p,a,b) (p)->LightEnable(a,b)
#define IDirect3DDevice7_GetLightEnable(p,a,b) (p)->GetLightEnable(a,b)
#define IDirect3DDevice7_SetClipPlane(p,a,b) (p)->SetClipPlane(a,b)
#define IDirect3DDevice7_GetClipPlane(p,a,b) (p)->GetClipPlane(a,b)
#define IDirect3DDevice7_GetInfo(p,a,b,c) (p)->GetInfo(a,b,c)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

/*
 * Execute Buffer interface
 */
#undef INTERFACE
#define INTERFACE IDirect3DExecuteBuffer

DECLARE_INTERFACE_(IDirect3DExecuteBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DExecuteBuffer methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Lock)(THIS_ LPD3DEXECUTEBUFFERDESC) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(SetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(GetExecuteData)(THIS_ LPD3DEXECUTEDATA) PURE;
    STDMETHOD(Validate)(THIS_ LPDWORD,LPD3DVALIDATECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD) PURE;
};

typedef struct IDirect3DExecuteBuffer *LPDIRECT3DEXECUTEBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DExecuteBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->lpVtbl->Lock(p,a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->lpVtbl->SetExecuteData(p,a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->lpVtbl->GetExecuteData(p,a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->lpVtbl->Validate(p,a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->lpVtbl->Optimize(p,a)
#else
#define IDirect3DExecuteBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DExecuteBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DExecuteBuffer_Release(p) (p)->Release()
#define IDirect3DExecuteBuffer_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DExecuteBuffer_Lock(p,a) (p)->Lock(a)
#define IDirect3DExecuteBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DExecuteBuffer_SetExecuteData(p,a) (p)->SetExecuteData(a)
#define IDirect3DExecuteBuffer_GetExecuteData(p,a) (p)->GetExecuteData(a)
#define IDirect3DExecuteBuffer_Validate(p,a,b,c,d) (p)->Validate(a,b,c,d)
#define IDirect3DExecuteBuffer_Optimize(p,a) (p)->Optimize(a)
#endif

/*
 * Light interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DLight

DECLARE_INTERFACE_(IDirect3DLight, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DLight methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetLight)(THIS_ LPD3DLIGHT) PURE;
    STDMETHOD(GetLight)(THIS_ LPD3DLIGHT) PURE;
};

typedef struct IDirect3DLight *LPDIRECT3DLIGHT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DLight_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DLight_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DLight_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DLight_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DLight_SetLight(p,a) (p)->lpVtbl->SetLight(p,a)
#define IDirect3DLight_GetLight(p,a) (p)->lpVtbl->GetLight(p,a)
#else
#define IDirect3DLight_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DLight_AddRef(p) (p)->AddRef()
#define IDirect3DLight_Release(p) (p)->Release()
#define IDirect3DLight_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DLight_SetLight(p,a) (p)->SetLight(a)
#define IDirect3DLight_GetLight(p,a) (p)->GetLight(a)
#endif

/*
 * Material interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DMaterial

DECLARE_INTERFACE_(IDirect3DMaterial, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DMATERIALHANDLE) PURE;
    STDMETHOD(Reserve)(THIS) PURE;
    STDMETHOD(Unreserve)(THIS) PURE;
};

typedef struct IDirect3DMaterial *LPDIRECT3DMATERIAL;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DMaterial_Reserve(p) (p)->lpVtbl->Reserve(p)
#define IDirect3DMaterial_Unreserve(p) (p)->lpVtbl->Unreserve(p)
#else
#define IDirect3DMaterial_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial_Release(p) (p)->Release()
#define IDirect3DMaterial_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DMaterial_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DMaterial_Reserve(p) (p)->Reserve()
#define IDirect3DMaterial_Unreserve(p) (p)->Unreserve()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial2

DECLARE_INTERFACE_(IDirect3DMaterial2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial2 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial2 *LPDIRECT3DMATERIAL2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial2_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial2_Release(p) (p)->Release()
#define IDirect3DMaterial2_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial2_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DMaterial3

DECLARE_INTERFACE_(IDirect3DMaterial3, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DMaterial3 methods ***/
    STDMETHOD(SetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetMaterial)(THIS_ LPD3DMATERIAL) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE3,LPD3DMATERIALHANDLE) PURE;
};

typedef struct IDirect3DMaterial3 *LPDIRECT3DMATERIAL3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DMaterial3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->lpVtbl->SetMaterial(p,a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->lpVtbl->GetMaterial(p,a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#else
#define IDirect3DMaterial3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DMaterial3_AddRef(p) (p)->AddRef()
#define IDirect3DMaterial3_Release(p) (p)->Release()
#define IDirect3DMaterial3_SetMaterial(p,a) (p)->SetMaterial(a)
#define IDirect3DMaterial3_GetMaterial(p,a) (p)->GetMaterial(a)
#define IDirect3DMaterial3_GetHandle(p,a,b) (p)->GetHandle(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Texture interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DTexture

DECLARE_INTERFACE_(IDirect3DTexture, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DDEVICE,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE) PURE;
    STDMETHOD(Unload)(THIS) PURE;
};

typedef struct IDirect3DTexture *LPDIRECT3DTEXTURE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture_Load(p,a) (p)->lpVtbl->Load(p,a)
#define IDirect3DTexture_Unload(p) (p)->lpVtbl->Unload(p)
#else
#define IDirect3DTexture_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture_AddRef(p) (p)->AddRef()
#define IDirect3DTexture_Release(p) (p)->Release()
#define IDirect3DTexture_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirect3DTexture_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture_Load(p,a) (p)->Load(a)
#define IDirect3DTexture_Unload(p) (p)->Unload()
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DTexture2

DECLARE_INTERFACE_(IDirect3DTexture2, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DTexture2 methods ***/
    STDMETHOD(GetHandle)(THIS_ LPDIRECT3DDEVICE2,LPD3DTEXTUREHANDLE) PURE;
    STDMETHOD(PaletteChanged)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Load)(THIS_ LPDIRECT3DTEXTURE2) PURE;
};

typedef struct IDirect3DTexture2 *LPDIRECT3DTEXTURE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DTexture2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DTexture2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->lpVtbl->GetHandle(p,a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->lpVtbl->PaletteChanged(p,a,b)
#define IDirect3DTexture2_Load(p,a) (p)->lpVtbl->Load(p,a)
#else
#define IDirect3DTexture2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DTexture2_AddRef(p) (p)->AddRef()
#define IDirect3DTexture2_Release(p) (p)->Release()
#define IDirect3DTexture2_GetHandle(p,a,b) (p)->GetHandle(a,b)
#define IDirect3DTexture2_PaletteChanged(p,a,b) (p)->PaletteChanged(a,b)
#define IDirect3DTexture2_Load(p,a) (p)->Load(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

/*
 * Viewport interfaces
 */
#undef INTERFACE
#define INTERFACE IDirect3DViewport

DECLARE_INTERFACE_(IDirect3DViewport, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
};

typedef struct IDirect3DViewport *LPDIRECT3DVIEWPORT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#else
#define IDirect3DViewport_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport_AddRef(p) (p)->AddRef()
#define IDirect3DViewport_Release(p) (p)->Release()
#define IDirect3DViewport_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#endif

#if(DIRECT3D_VERSION >= 0x0500)
#undef INTERFACE
#define INTERFACE IDirect3DViewport2

DECLARE_INTERFACE_(IDirect3DViewport2, IDirect3DViewport)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
};

typedef struct IDirect3DViewport2 *LPDIRECT3DVIEWPORT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport2_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport2_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#else
#define IDirect3DViewport2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport2_AddRef(p) (p)->AddRef()
#define IDirect3DViewport2_Release(p) (p)->Release()
#define IDirect3DViewport2_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport2_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport2_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport2_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport2_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport2_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport2_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport2_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport2_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport2_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport2_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport2_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport2_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport2_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport2_SetViewport2(p,a) (p)->SetViewport2(a)
#endif
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

#undef INTERFACE
#define INTERFACE IDirect3DViewport3

DECLARE_INTERFACE_(IDirect3DViewport3, IDirect3DViewport2)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DViewport2 methods ***/
    STDMETHOD(Initialize)(THIS_ LPDIRECT3D) PURE;
    STDMETHOD(GetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(SetViewport)(THIS_ LPD3DVIEWPORT) PURE;
    STDMETHOD(TransformVertices)(THIS_ DWORD,LPD3DTRANSFORMDATA,DWORD,LPDWORD) PURE;
    STDMETHOD(LightElements)(THIS_ DWORD,LPD3DLIGHTDATA) PURE;
    STDMETHOD(SetBackground)(THIS_ D3DMATERIALHANDLE) PURE;
    STDMETHOD(GetBackground)(THIS_ LPD3DMATERIALHANDLE,LPBOOL) PURE;
    STDMETHOD(SetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE*,LPBOOL) PURE;
    STDMETHOD(Clear)(THIS_ DWORD,LPD3DRECT,DWORD) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DLIGHT) PURE;
    STDMETHOD(NextLight)(THIS_ LPDIRECT3DLIGHT,LPDIRECT3DLIGHT*,DWORD) PURE;
    STDMETHOD(GetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetViewport2)(THIS_ LPD3DVIEWPORT2) PURE;
    STDMETHOD(SetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(GetBackgroundDepth2)(THIS_ LPDIRECTDRAWSURFACE4*,LPBOOL) PURE;
    STDMETHOD(Clear2)(THIS_ DWORD,LPD3DRECT,DWORD,D3DCOLOR,D3DVALUE,DWORD) PURE;
};

typedef struct IDirect3DViewport3 *LPDIRECT3DVIEWPORT3;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DViewport3_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DViewport3_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DViewport3_Initialize(p,a) (p)->lpVtbl->Initialize(p,a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->lpVtbl->GetViewport(p,a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->lpVtbl->SetViewport(p,a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->lpVtbl->TransformVertices(p,a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->lpVtbl->LightElements(p,a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->lpVtbl->SetBackground(p,a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->lpVtbl->GetBackground(p,a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->lpVtbl->SetBackgroundDepth(p,a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->lpVtbl->GetBackgroundDepth(p,a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->lpVtbl->Clear(p,a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->lpVtbl->AddLight(p,a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->lpVtbl->DeleteLight(p,a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->lpVtbl->NextLight(p,a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->lpVtbl->GetViewport2(p,a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->lpVtbl->SetViewport2(p,a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->lpVtbl->SetBackgroundDepth2(p,a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->lpVtbl->GetBackgroundDepth2(p,a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->lpVtbl->Clear2(p,a,b,c,d,e,f)
#else
#define IDirect3DViewport3_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DViewport3_AddRef(p) (p)->AddRef()
#define IDirect3DViewport3_Release(p) (p)->Release()
#define IDirect3DViewport3_Initialize(p,a) (p)->Initialize(a)
#define IDirect3DViewport3_GetViewport(p,a) (p)->GetViewport(a)
#define IDirect3DViewport3_SetViewport(p,a) (p)->SetViewport(a)
#define IDirect3DViewport3_TransformVertices(p,a,b,c,d) (p)->TransformVertices(a,b,c,d)
#define IDirect3DViewport3_LightElements(p,a,b) (p)->LightElements(a,b)
#define IDirect3DViewport3_SetBackground(p,a) (p)->SetBackground(a)
#define IDirect3DViewport3_GetBackground(p,a,b) (p)->GetBackground(a,b)
#define IDirect3DViewport3_SetBackgroundDepth(p,a) (p)->SetBackgroundDepth(a)
#define IDirect3DViewport3_GetBackgroundDepth(p,a,b) (p)->GetBackgroundDepth(a,b)
#define IDirect3DViewport3_Clear(p,a,b,c) (p)->Clear(a,b,c)
#define IDirect3DViewport3_AddLight(p,a) (p)->AddLight(a)
#define IDirect3DViewport3_DeleteLight(p,a) (p)->DeleteLight(a)
#define IDirect3DViewport3_NextLight(p,a,b,c) (p)->NextLight(a,b,c)
#define IDirect3DViewport3_GetViewport2(p,a) (p)->GetViewport2(a)
#define IDirect3DViewport3_SetViewport2(p,a) (p)->SetViewport2(a)
#define IDirect3DViewport3_SetBackgroundDepth2(p,a) (p)->SetBackgroundDepth2(a)
#define IDirect3DViewport3_GetBackgroundDepth2(p,a,b) (p)->GetBackgroundDepth2(a,b)
#define IDirect3DViewport3_Clear2(p,a,b,c,d,e,f) (p)->Clear2(a,b,c,d,e,f)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0600)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer

DECLARE_INTERFACE_(IDirect3DVertexBuffer, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER,DWORD,LPDIRECT3DDEVICE3,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE3,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#else
#define IDirect3DVertexBuffer_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer_Release(p) (p)->Release()
#define IDirect3DVertexBuffer_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer_Optimize(p,a,b) (p)->Optimize(a,b)
#endif
#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#undef INTERFACE
#define INTERFACE IDirect3DVertexBuffer7

DECLARE_INTERFACE_(IDirect3DVertexBuffer7, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVertexBuffer7 methods ***/
    STDMETHOD(Lock)(THIS_ DWORD,LPVOID*,LPDWORD) PURE;
    STDMETHOD(Unlock)(THIS) PURE;
    STDMETHOD(ProcessVertices)(THIS_ DWORD,DWORD,DWORD,LPDIRECT3DVERTEXBUFFER7,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(GetVertexBufferDesc)(THIS_ LPD3DVERTEXBUFFERDESC) PURE;
    STDMETHOD(Optimize)(THIS_ LPDIRECT3DDEVICE7,DWORD) PURE;
    STDMETHOD(ProcessVerticesStrided)(THIS_ DWORD,DWORD,DWORD,LPD3DDRAWPRIMITIVESTRIDEDDATA,DWORD,LPDIRECT3DDEVICE7,DWORD) PURE;
};

typedef struct IDirect3DVertexBuffer7 *LPDIRECT3DVERTEXBUFFER7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirect3DVertexBuffer7_Release(p) (p)->lpVtbl->Release(p)
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->lpVtbl->Lock(p,a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->lpVtbl->Unlock(p)
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVertices(p,a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->lpVtbl->GetVertexBufferDesc(p,a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->lpVtbl->Optimize(p,a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->lpVtbl->ProcessVerticesStrided(p,a,b,c,d,e,f,g)
#else
#define IDirect3DVertexBuffer7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirect3DVertexBuffer7_AddRef(p) (p)->AddRef()
#define IDirect3DVertexBuffer7_Release(p) (p)->Release()
#define IDirect3DVertexBuffer7_Lock(p,a,b,c) (p)->Lock(a,b,c)
#define IDirect3DVertexBuffer7_Unlock(p) (p)->Unlock()
#define IDirect3DVertexBuffer7_ProcessVertices(p,a,b,c,d,e,f,g) (p)->ProcessVertices(a,b,c,d,e,f,g)
#define IDirect3DVertexBuffer7_GetVertexBufferDesc(p,a) (p)->GetVertexBufferDesc(a)
#define IDirect3DVertexBuffer7_Optimize(p,a,b) (p)->Optimize(a,b)
#define IDirect3DVertexBuffer7_ProcessVerticesStrided(p,a,b,c,d,e,f,g) (p)->ProcessVerticesStrided(a,b,c,d,e,f,g)
#endif
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0500)
/****************************************************************************
 *
 * Flags for IDirect3DDevice::NextViewport
 *
 ****************************************************************************/

/*
 * Return the next viewport
 */
#define D3DNEXT_NEXT    0x00000001l

/*
 * Return the first viewport
 */
#define D3DNEXT_HEAD    0x00000002l

/*
 * Return the last viewport
 */
#define D3DNEXT_TAIL    0x00000004l


/****************************************************************************
 *
 * Flags for DrawPrimitive/DrawIndexedPrimitive
 *   Also valid for Begin/BeginIndexed
 *   Also valid for VertexBuffer::CreateVertexBuffer
 ****************************************************************************/

/*
 * Wait until the device is ready to draw the primitive
 * This will cause DP to not return DDERR_WASSTILLDRAWING
 */
#define D3DDP_WAIT                  0x00000001l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if (DIRECT3D_VERSION == 0x0500)
/*
 * Hint that it is acceptable to render the primitive out of order.
 */
#define D3DDP_OUTOFORDER            0x00000002l
#endif


#if(DIRECT3D_VERSION >= 0x0500)
/*
 * Hint that the primitives have been clipped by the application.
 */
#define D3DDP_DONOTCLIP             0x00000004l

/*
 * Hint that the extents need not be updated.
 */
#define D3DDP_DONOTUPDATEEXTENTS    0x00000008l
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/*
 * Hint that the lighting should not be applied on vertices.
 */

#define D3DDP_DONOTLIGHT            0x00000010l

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Direct3D Errors
 * DirectDraw error codes are used when errors not specified here.
 */
#define D3D_OK              DD_OK
#define D3DERR_BADMAJORVERSION      MAKE_DDHRESULT(700)
#define D3DERR_BADMINORVERSION      MAKE_DDHRESULT(701)

#if(DIRECT3D_VERSION >= 0x0500)
/*
 * An invalid device was requested by the application.
 */
#define D3DERR_INVALID_DEVICE   MAKE_DDHRESULT(705)
#define D3DERR_INITFAILED       MAKE_DDHRESULT(706)

/*
 * SetRenderTarget attempted on a device that was
 * QI'd off the render target.
 */
#define D3DERR_DEVICEAGGREGATED MAKE_DDHRESULT(707)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_EXECUTE_CREATE_FAILED    MAKE_DDHRESULT(710)
#define D3DERR_EXECUTE_DESTROY_FAILED   MAKE_DDHRESULT(711)
#define D3DERR_EXECUTE_LOCK_FAILED  MAKE_DDHRESULT(712)
#define D3DERR_EXECUTE_UNLOCK_FAILED    MAKE_DDHRESULT(713)
#define D3DERR_EXECUTE_LOCKED       MAKE_DDHRESULT(714)
#define D3DERR_EXECUTE_NOT_LOCKED   MAKE_DDHRESULT(715)

#define D3DERR_EXECUTE_FAILED       MAKE_DDHRESULT(716)
#define D3DERR_EXECUTE_CLIPPED_FAILED   MAKE_DDHRESULT(717)

#define D3DERR_TEXTURE_NO_SUPPORT   MAKE_DDHRESULT(720)
#define D3DERR_TEXTURE_CREATE_FAILED    MAKE_DDHRESULT(721)
#define D3DERR_TEXTURE_DESTROY_FAILED   MAKE_DDHRESULT(722)
#define D3DERR_TEXTURE_LOCK_FAILED  MAKE_DDHRESULT(723)
#define D3DERR_TEXTURE_UNLOCK_FAILED    MAKE_DDHRESULT(724)
#define D3DERR_TEXTURE_LOAD_FAILED  MAKE_DDHRESULT(725)
#define D3DERR_TEXTURE_SWAP_FAILED  MAKE_DDHRESULT(726)
#define D3DERR_TEXTURE_LOCKED       MAKE_DDHRESULT(727)
#define D3DERR_TEXTURE_NOT_LOCKED   MAKE_DDHRESULT(728)
#define D3DERR_TEXTURE_GETSURF_FAILED   MAKE_DDHRESULT(729)

#define D3DERR_MATRIX_CREATE_FAILED MAKE_DDHRESULT(730)
#define D3DERR_MATRIX_DESTROY_FAILED    MAKE_DDHRESULT(731)
#define D3DERR_MATRIX_SETDATA_FAILED    MAKE_DDHRESULT(732)
#define D3DERR_MATRIX_GETDATA_FAILED    MAKE_DDHRESULT(733)
#define D3DERR_SETVIEWPORTDATA_FAILED   MAKE_DDHRESULT(734)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDCURRENTVIEWPORT   MAKE_DDHRESULT(735)
#define D3DERR_INVALIDPRIMITIVETYPE     MAKE_DDHRESULT(736)
#define D3DERR_INVALIDVERTEXTYPE        MAKE_DDHRESULT(737)
#define D3DERR_TEXTURE_BADSIZE          MAKE_DDHRESULT(738)
#define D3DERR_INVALIDRAMPTEXTURE       MAKE_DDHRESULT(739)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_MATERIAL_CREATE_FAILED   MAKE_DDHRESULT(740)
#define D3DERR_MATERIAL_DESTROY_FAILED  MAKE_DDHRESULT(741)
#define D3DERR_MATERIAL_SETDATA_FAILED  MAKE_DDHRESULT(742)
#define D3DERR_MATERIAL_GETDATA_FAILED  MAKE_DDHRESULT(743)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INVALIDPALETTE           MAKE_DDHRESULT(744)

#define D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY MAKE_DDHRESULT(745)
#define D3DERR_ZBUFF_NEEDS_VIDEOMEMORY  MAKE_DDHRESULT(746)
#define D3DERR_SURFACENOTINVIDMEM       MAKE_DDHRESULT(747)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_LIGHT_SET_FAILED     MAKE_DDHRESULT(750)
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_LIGHTHASVIEWPORT     MAKE_DDHRESULT(751)
#define D3DERR_LIGHTNOTINTHISVIEWPORT           MAKE_DDHRESULT(752)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#define D3DERR_SCENE_IN_SCENE       MAKE_DDHRESULT(760)
#define D3DERR_SCENE_NOT_IN_SCENE   MAKE_DDHRESULT(761)
#define D3DERR_SCENE_BEGIN_FAILED   MAKE_DDHRESULT(762)
#define D3DERR_SCENE_END_FAILED     MAKE_DDHRESULT(763)

#if(DIRECT3D_VERSION >= 0x0500)
#define D3DERR_INBEGIN                  MAKE_DDHRESULT(770)
#define D3DERR_NOTINBEGIN               MAKE_DDHRESULT(771)
#define D3DERR_NOVIEWPORTS              MAKE_DDHRESULT(772)
#define D3DERR_VIEWPORTDATANOTSET       MAKE_DDHRESULT(773)
#define D3DERR_VIEWPORTHASNODEVICE      MAKE_DDHRESULT(774)
#define D3DERR_NOCURRENTVIEWPORT        MAKE_DDHRESULT(775)
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
#define D3DERR_INVALIDVERTEXFORMAT              MAKE_DDHRESULT(2048)

/*
 * Attempted to CreateTexture on a surface that had a color key
 */
#define D3DERR_COLORKEYATTACHED                 MAKE_DDHRESULT(2050)

#define D3DERR_VERTEXBUFFEROPTIMIZED            MAKE_DDHRESULT(2060)
#define D3DERR_VBUF_CREATE_FAILED               MAKE_DDHRESULT(2061)
#define D3DERR_VERTEXBUFFERLOCKED               MAKE_DDHRESULT(2062)
#define D3DERR_VERTEXBUFFERUNLOCKFAILED         MAKE_DDHRESULT(2063)

#define D3DERR_ZBUFFER_NOTPRESENT               MAKE_DDHRESULT(2070)
#define D3DERR_STENCILBUFFER_NOTPRESENT         MAKE_DDHRESULT(2071)

#define D3DERR_WRONGTEXTUREFORMAT               MAKE_DDHRESULT(2072)
#define D3DERR_UNSUPPORTEDCOLOROPERATION        MAKE_DDHRESULT(2073)
#define D3DERR_UNSUPPORTEDCOLORARG              MAKE_DDHRESULT(2074)
#define D3DERR_UNSUPPORTEDALPHAOPERATION        MAKE_DDHRESULT(2075)
#define D3DERR_UNSUPPORTEDALPHAARG              MAKE_DDHRESULT(2076)
#define D3DERR_TOOMANYOPERATIONS                MAKE_DDHRESULT(2077)
#define D3DERR_CONFLICTINGTEXTUREFILTER         MAKE_DDHRESULT(2078)
#define D3DERR_UNSUPPORTEDFACTORVALUE           MAKE_DDHRESULT(2079)
#define D3DERR_CONFLICTINGRENDERSTATE           MAKE_DDHRESULT(2081)
#define D3DERR_UNSUPPORTEDTEXTUREFILTER         MAKE_DDHRESULT(2082)
#define D3DERR_TOOMANYPRIMITIVES                MAKE_DDHRESULT(2083)
#define D3DERR_INVALIDMATRIX                    MAKE_DDHRESULT(2084)
#define D3DERR_TOOMANYVERTICES                  MAKE_DDHRESULT(2085)
#define D3DERR_CONFLICTINGTEXTUREPALETTE        MAKE_DDHRESULT(2086)

#endif /* DIRECT3D_VERSION >= 0x0600 */

#if(DIRECT3D_VERSION >= 0x0700)
#define D3DERR_INVALIDSTATEBLOCK        MAKE_DDHRESULT(2100)
#define D3DERR_INBEGINSTATEBLOCK        MAKE_DDHRESULT(2101)
#define D3DERR_NOTINBEGINSTATEBLOCK     MAKE_DDHRESULT(2102)
#endif /* DIRECT3D_VERSION >= 0x0700 */


#ifdef __cplusplus
};
#endif

#endif /* (DIRECT3D_VERSION < 0x0800) */
#endif /* _D3D_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\BLib\src\BConsole.cpp ===
#include <windows.h>
#include <stdio.h>
#pragma hdrstop
#include "..\inc\blib.h"

//////////////////////////////////////////////////////////////////////////////
// BScreen::close
//
LRESULT BScreen::queueMessage
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    if (m_pfnHandler)
    {
        if (m_pfnHandler(m_pMHContext,uMsg,wParam,lParam) == consumed)
        {
            return 0; // done
        }
        // we have to buffer this event since the handler refused to handle it right away.
    }

    EnterCriticalSection (&m_csThread);
    MESSAGE msg;
    msg.hWnd     = m_hWindow;
    msg.uMessage = uMsg;
    msg.wParam   = wParam;
    msg.lParam   = lParam;
    m_listMessage.addTail (msg);
    LeaveCriticalSection (&m_csThread);

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::mustClose
//
LRESULT BScreen::mustClose
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    PostQuitMessage (0);
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::setFocus
//
LRESULT BScreen::setFocus
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    updateCaret();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::killFocus
//
LRESULT BScreen::killFocus
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    updateCaret();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::getMinMaxInfo
//
LRESULT BScreen::getMinMaxInfo
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    int iMaxX = m_sizeBuffer.cx * m_sizeCell.cx
              + GetSystemMetrics(SM_CXSIZEFRAME) * 2
              + GetSystemMetrics(SM_CXVSCROLL);
    int iMaxY = m_sizeBuffer.cy * m_sizeCell.cy
              + GetSystemMetrics(SM_CYSIZEFRAME) * 2
              + GetSystemMetrics(SM_CYHSCROLL)
              + GetSystemMetrics(SM_CYCAPTION);

    LPMINMAXINFO lpInfo      = (LPMINMAXINFO)lParam;
    lpInfo->ptMaxSize.x      = min(iMaxX,GetSystemMetrics(SM_CXSCREEN));
    lpInfo->ptMaxSize.y      = min(iMaxY,GetSystemMetrics(SM_CYSCREEN));
    lpInfo->ptMaxTrackSize   = lpInfo->ptMaxSize;
    lpInfo->ptMinTrackSize.x = 5 * m_sizeCell.cx;
    lpInfo->ptMinTrackSize.y = 5 * m_sizeCell.cy;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::hScroll
//
LRESULT BScreen::hScroll
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    // read info
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_ALL;
    GetScrollInfo (m_hWindow,SB_HORZ,&si);

    // act
    int iMax    = m_sizeBuffer.cx * m_sizeCell.cx;
    int iOldPos = m_ptTopLeft.x;
    switch (wParam & 0xffff)
    {
        case SB_BOTTOM:        m_ptTopLeft.x  = iMax;          break;
        case SB_TOP:           m_ptTopLeft.x  = 0;             break;
        case SB_LINEUP:        m_ptTopLeft.x -= m_sizeCell.cx; break;
        case SB_LINEDOWN:      m_ptTopLeft.x += m_sizeCell.cx; break;
        case SB_PAGEUP:        m_ptTopLeft.x -= si.nPage;      break;
        case SB_PAGEDOWN:      m_ptTopLeft.x += si.nPage;      break;
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: m_ptTopLeft.x  = wParam >> 16;  break;
    }
    if (m_ptTopLeft.x < 0)    m_ptTopLeft.x = 0;
    if (m_ptTopLeft.x > iMax) m_ptTopLeft.x = iMax;

    // set
    if (iOldPos != m_ptTopLeft.x)
    {
        InvalidateRect (m_hWindow,NULL,TRUE);
    }

    // done
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::vScroll
//
LRESULT BScreen::vScroll
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    // read info
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_ALL;
    GetScrollInfo (m_hWindow,SB_VERT,&si);

    // act
    int iMax    = m_sizeBuffer.cy * m_sizeCell.cy;
    int iOldPos = m_ptTopLeft.y;
    switch (wParam & 0xffff)
    {
        case SB_BOTTOM:        m_ptTopLeft.y  = iMax;          break;
        case SB_TOP:           m_ptTopLeft.y  = 0;             break;
        case SB_LINEUP:        m_ptTopLeft.y -= m_sizeCell.cy; break;
        case SB_LINEDOWN:      m_ptTopLeft.y += m_sizeCell.cy; break;
        case SB_PAGEUP:        m_ptTopLeft.y -= si.nPage;      break;
        case SB_PAGEDOWN:      m_ptTopLeft.y += si.nPage;      break;
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION: m_ptTopLeft.y  = wParam >> 16;  break;
    }
    if (m_ptTopLeft.y < 0)    m_ptTopLeft.y = 0;
    if (m_ptTopLeft.y > iMax) m_ptTopLeft.y = iMax;

    // set
    if (iOldPos != m_ptTopLeft.y)
    {
        InvalidateRect (m_hWindow,NULL,TRUE);
    }

    // done
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::mouseWheel
//
LRESULT BScreen::mouseWheel
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    // read info
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_ALL;
    GetScrollInfo (m_hWindow,SB_VERT,&si);

    // act
    int iMax       = m_sizeBuffer.cy * m_sizeCell.cy;
    int iOldPos    = m_ptTopLeft.y;
    m_ptTopLeft.y -= int((short int)(wParam >> 14)) / m_sizeCell.cy;
    if (m_ptTopLeft.y < 0)    m_ptTopLeft.y = 0;
    if (m_ptTopLeft.y > iMax) m_ptTopLeft.y = iMax;

    // set
    if (iOldPos != m_ptTopLeft.y)
    {
        InvalidateRect (m_hWindow,NULL,TRUE);
    }

    // done
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::paint
//
LRESULT BScreen::paint
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    //
    // prepare to draw
    //
    getMutex();
    caretOff();

    //
    // init
    //
    RECT rectDirty;
    GetUpdateRect (m_hWindow,&rectDirty,FALSE);
    RECT rectClient;
    GetClientRect (m_hWindow,&rectClient);

    //
    // condition buffer such that we do not draw over allowed limits
    //
    int iMaxX = m_sizeBuffer.cx * m_sizeCell.cx;
    int iMaxY = m_sizeBuffer.cy * m_sizeCell.cy;
    if (int(m_ptTopLeft.x + rectClient.right - rectClient.left) > iMaxX)
    {
        m_ptTopLeft.x = iMaxX - (rectClient.right - rectClient.left);
    }
    if (int(m_ptTopLeft.y + rectClient.bottom - rectClient.top) > iMaxY)
    {
        m_ptTopLeft.y = iMaxY - (rectClient.bottom - rectClient.top);
    }

    //
    // update scroll bars
    //    SB has a bug where thumb is n-1 for max-min set to n
    //
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask  = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.nMin   = 0;
    si.nMax   = iMaxX;
    si.nPage  = rectClient.right - rectClient.left;
    si.nPos   = m_ptTopLeft.x;
    SetScrollInfo (m_hWindow,SB_HORZ,&si,TRUE);
    si.nMin   = 0;
    si.nMax   = iMaxY;
    si.nPage  = rectClient.bottom - rectClient.top; 
    si.nPos   = m_ptTopLeft.y;
    SetScrollInfo (m_hWindow,SB_VERT,&si,TRUE);


    //
    // start drawing
    //
    PAINTSTRUCT ps;
    BeginPaint (m_hWindow,&ps);
    assert (m_hbmpFontMap || m_hFont); // one of these MUST be defined

    //
    // select default drawing objects
    //
    HFONT hOldFont = NULL;
    HDC   hFontMap = NULL;
    if (m_hbmpFontMap)
    {
        hFontMap = CreateCompatibleDC(ps.hdc);
        SelectObject (hFontMap,m_hbmpFontMap);
    }
    else
    {
        hOldFont = (HFONT)SelectObject(ps.hdc,m_hFont);
    }

    //
    // draw visible text (will fail if window exceeds buffer)
    //
    char  *pszAccBuffer  = new char[m_sizeBuffer.cx];
    POINT  ptTopLeftChar = { m_ptTopLeft.x / m_sizeCell.cx, m_ptTopLeft.y / m_sizeCell.cy }; // topleft char in buffer
    POINT  ptTopLeftCell = { -(m_ptTopLeft.x % m_sizeCell.cx), -(m_ptTopLeft.y % m_sizeCell.cy) };
    POINT  ptChar;   // current cell in buffer
    RECT   rectCell; // current cell on screen that corresponds to ptChar;
    rectCell.top    = ptTopLeftCell.y;
    rectCell.bottom = rectCell.top + m_sizeCell.cy;
    ptChar.y        = ptTopLeftChar.y;
    for (DWORD y = m_ptTopLeft.y; rectCell.top < rectClient.bottom; y++)
    {
        // trivial reject full lines if possible
        RECT rect,rect2;
        rect.left   = rectClient.left;
        rect.right  = rectClient.right;
        rect.top    = rectCell.top;
        rect.bottom = rectCell.bottom;
        if (IntersectRect(&rect2,&rect,&rectDirty)) // line in region?
        {
            // init span optimizer
            DWORD  dwColor = m_pawScreen[ptChar.y * m_sizeBuffer.cx + ptTopLeftChar.x] & 0xff00;
            char  *pch     = pszAccBuffer;
            LONG   lStartX = ptTopLeftCell.x;

            // for all x
            rectCell.left  = ptTopLeftCell.x;
            rectCell.right = rectCell.left + m_sizeCell.cx;
            ptChar.x       = ptTopLeftChar.x;
            for (DWORD x = m_ptTopLeft.x; rectCell.left < rectClient.right; x++)
            {
                // collect text
                DWORD dwChar = m_pawScreen[ptChar.y * m_sizeBuffer.cx + ptChar.x];
                if ((dwChar & 0xff00) == dwColor)
                {
                    // color match, keep
                    *pch = (char)dwChar;
                    pch++;
                }
                else
                {
                    // color change - dump string and start new
                    if (pch != pszAccBuffer)
                    {
                        POINT pt = { lStartX, rectCell.top };
                        drawText (ps.hdc,
                                  hFontMap,
                                  &pt,
                                  pszAccBuffer,
                                  pch - pszAccBuffer,
                                  dwColor >> 8);
                    }

                    // start new
                    pch     = pszAccBuffer;
                    lStartX = rectCell.left;
                    dwColor = dwChar & 0xff00;

                    // add first
                    *pch = (char)dwChar;
                    pch++;
                }

                // next x
                rectCell.left  += m_sizeCell.cx;
                rectCell.right += m_sizeCell.cx;
                ptChar.x       ++;
            }
            // draw last, if any
            if (pch != pszAccBuffer)
            {
                POINT pt = { lStartX, rectCell.top };
                drawText (ps.hdc,
                          hFontMap,
                          &pt,
                          pszAccBuffer,
                          pch - pszAccBuffer,
                          dwColor >> 8);
            }
        }

        // next y
        rectCell.top    += m_sizeCell.cy;
        rectCell.bottom += m_sizeCell.cy;
        ptChar.y        ++;
    }
    delete[] pszAccBuffer;

    //
    // reset drawing objects
    //
    if (m_hbmpFontMap)
    {
        DeleteDC (hFontMap);
    }
    else
    {
        SelectObject (ps.hdc,hOldFont);
    }

    //
    // end drawing
    //
    EndPaint (m_hWindow,&ps);
    caretOn();
    releaseMutex();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::windowProc
//
LRESULT CALLBACK __BScreen_windowProc
(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    BScreen *pThis = (BScreen*)GetWindowLong(hWnd,0);
    if (!pThis)
    {
        return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }
    
    return pThis->windowProc(hWnd,uMsg,wParam,lParam);
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::createFont
//
int BScreen::createFont
(
    void
)
{
    if (!m_hbmpFontMap) // user font, do not create GDI font
    {
        //
        // create font
        //
        m_hFont = CreateFont(m_sizeFont.cy,0,0,0,0,0,0,0,0,0,0,0,0,m_strFontName);
        if (!m_hFont)
        {
            destroyScreen();
            EnterCriticalSection (&m_csThread);
            m_enumThreadStatus = threadAbnormalTermination;
            LeaveCriticalSection (&m_csThread);
            return 0;
        }

        //
        // compute cell sizes
        //
        HDC hdc = GetDC(NULL);
        HFONT hOldFont = (HFONT)SelectObject(hdc,m_hFont);
        SIZE size;
        GetTextExtentPoint32 (hdc,"MWqgchiL",8,&size);
        m_sizeFont.cx = size.cx / 8;
        m_sizeFont.cy = size.cy;
        SelectObject (hdc,hOldFont);
        ReleaseDC (NULL,hdc);

        //
        // create spacing array
        //
        delete[] m_paiSpacing;
        m_paiSpacing = new INT[m_sizeBuffer.cx + 1];
        fillDWord (m_paiSpacing,m_sizeCell.cx,m_sizeBuffer.cx + 1);
    }

    m_sizeCell.cx = m_sizeFont.cx + 0;
    m_sizeCell.cy = m_sizeFont.cy + 0;

    // done
    return 1;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::destroyFont
//
void BScreen::destroyFont
(
    void
)
{
    delete[] m_paiSpacing;
    m_paiSpacing = NULL;

    if (m_hFont)
    {
        DeleteObject (m_hFont);
        m_hFont = NULL;
    }
    if (m_hbmpFontMap)
    {
        DeleteObject (m_hbmpFontMap);
        m_hbmpFontMap = NULL;
    }
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::createScreen
//
int BScreen::createScreen
(
    void
)
{
    //
    // setup font
    //
    if (!createFont()) return 0;

    //
    // create buffer
    //
    m_pawScreen = new WORD[m_sizeBuffer.cy * m_sizeBuffer.cx];
    if (!m_pawScreen)
    {
        destroyScreen();
        EnterCriticalSection (&m_csThread);
        m_enumThreadStatus = threadAbnormalTermination;
        LeaveCriticalSection (&m_csThread);
        return 0;
    }
    fillWord (m_pawScreen,0x0820,m_sizeBuffer.cy * m_sizeBuffer.cx);

    //
    // register class
    //
    WNDCLASS wndClass;
    memset (&wndClass,0,sizeof(wndClass));
    wndClass.cbWndExtra    = 4;
    wndClass.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wndClass.hIcon         = LoadIcon(NULL,IDI_APPLICATION);
    wndClass.hInstance     = m_hInstance;
    wndClass.lpfnWndProc   = __BScreen_windowProc;
    wndClass.lpszClassName = "BScreenClass";
    wndClass.style         = CS_HREDRAW | CS_VREDRAW;
    if (!RegisterClass(&wndClass))
    {
        destroyScreen();
        EnterCriticalSection (&m_csThread);
        m_enumThreadStatus = threadAbnormalTermination;
        LeaveCriticalSection (&m_csThread);
        return 0;
    }

    //
    // create window
    //
    m_hWindow = CreateWindow("BScreenClass",
                             "BScreen::Caption",
                             WS_HSCROLL | WS_VSCROLL | WS_THICKFRAME | WS_CAPTION | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_SYSMENU,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             0,
                             0,
                             NULL,
                             NULL,
                             m_hInstance,
                             this);
    if (!m_hWindow)
    {
        destroyScreen();
        EnterCriticalSection (&m_csThread);
        m_enumThreadStatus = threadAbnormalTermination;
        LeaveCriticalSection (&m_csThread);
        return 0;
    }
    SetWindowLong (m_hWindow,0,(LONG)this);
    SetWindowPos (m_hWindow,NULL,0,0,GetSystemMetrics(SM_CXSCREEN) / 2,GetSystemMetrics(SM_CYSCREEN) / 2,SWP_NOZORDER | SWP_NOMOVE); // force window as large as possible, but using minmax info
    ShowWindow (m_hWindow,SW_NORMAL);
    UpdateWindow (m_hWindow);

    // on win 98 this is needed otherwise nothing show up - not sure why
    destroyFont();
    createFont();

    //
    // message pump
    //
    EnterCriticalSection (&m_csThread);
    m_enumThreadStatus = threadRunning;
    LeaveCriticalSection (&m_csThread);
    
    MSG msg;
    for (;;)
    {
        if (PeekMessage(&msg,NULL,0,0,PM_NOREMOVE))
        {
            if (GetMessage(&msg,NULL,0,0))
            {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            }
            else
            {
                break;
            }
        }
        else
        {
            Sleep (10);
        }
    }

    //
    // done
    //
    destroyScreen();
    EnterCriticalSection (&m_csThread);
    m_enumThreadStatus = threadStopped;
    LeaveCriticalSection (&m_csThread);
    return 1;
}

DWORD WINAPI __BScreen_createScreen
(
    LPVOID lpContext
)
{
    return ((BScreen*)lpContext)->createScreen();
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::destroyScreen
//
void BScreen::destroyScreen
(
    void
)
{
    //
    // clean up
    //
    delete[] m_pawScreen;
    m_pawScreen = NULL;

    destroyFont();

    DestroyCaret();
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::drawText
//
void BScreen::drawText
(
          HDC       hdc,
          HDC       hFontMap,
    const POINT    *pt,
    const char     *psz,
          DWORD     dwCharCount,
          DWORD     dwColor
)
{
    // draw text/user
    if (m_hbmpFontMap)
    {
        if (!dwCharCount) return;
        POINT ptd = *pt;
        // for all chars
        for (; dwCharCount; psz++, dwCharCount--)
        {
            POINT pts;
            DWORD dwChar = (dwColor << 8) | DWORD((unsigned char)psz[0]);
            pts.x = (dwChar % m_sizeCellOrganization.cx) * m_sizeFont.cx;
            pts.y = (dwChar / m_sizeCellOrganization.cx) * m_sizeFont.cy;
            // draw cell
            BitBlt (hdc,ptd.x,ptd.y,m_sizeFont.cx,m_sizeFont.cy,
                    hFontMap,pts.x,pts.y,
                    SRCCOPY);
            // next
            ptd.x += m_sizeFont.cx;
        }
    }
    else
    {
        // compute bounding rect
        RECT rect = { pt->x, pt->y, pt->x + dwCharCount * m_sizeCell.cx, pt->y + m_sizeCell.cy };
        // set up colors
        SetTextColor (hdc,m_acolPalette[(dwColor >> 0) & 15]);
        SetBkColor   (hdc,m_acolPalette[(dwColor >> 4) & 15]);
        // draw
        ExtTextOut (hdc,rect.left,rect.top,ETO_OPAQUE | ETO_CLIPPED,&rect,psz,dwCharCount,m_paiSpacing);
    }
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::caretOff
//
void BScreen::caretOff
(
    void
)
{
    m_dwFlags &= ~flagCaretOn;
    updateCaret();
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::caretOn
//
void BScreen::caretOn
(
    void
)
{
    m_dwFlags |= flagCaretOn;
    updateCaret();
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::updateCaret
//
void BScreen::updateCaret
(
    BOOL bForceRecreate
)
{
    //
    // show
    //
    if (!bForceRecreate &&
        (GetFocus() == m_hWindow))
    {
        if (m_dwFlags & flagCaretEnabled)
        {
            if (!(m_dwFlags & flagCaretCreated))
            {
                CreateCaret (m_hWindow,NULL,m_iCaretWidth,m_sizeCell.cy);
                m_dwFlags |= flagCaretCreated;
            }
            int x = m_ptCursor.x * m_sizeCell.cx - m_ptTopLeft.x;
            int y = m_ptCursor.y * m_sizeCell.cy - m_ptTopLeft.y;
            SetCaretPos (x,y);
            ShowCaret (m_hWindow);
            m_dwFlags |= flagCaretOn;
            return;
        }
    }

    //
    // hide
    //
    if (m_dwFlags & flagCaretCreated)
    {
        if (m_dwFlags & flagCaretOn)
        {
            HideCaret (m_hWindow);
        }
        DestroyCaret();
        m_dwFlags &= ~(flagCaretOn | flagCaretCreated);
    }

    if (bForceRecreate)
    {
        updateCaret(); // recreate
        InvalidateRect (m_hWindow,NULL,FALSE); // for some reason the caret needs a paint job when recreated - win32 bug
    }
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::scrollToCaret
//
void BScreen::scrollToCaret
(
    void
)
{
    assert (m_ptCursor.x >= 0);
    assert (m_ptCursor.x < m_sizeBuffer.cx);
    assert (m_ptCursor.y >= 0);
    assert (m_ptCursor.y < m_sizeBuffer.cy);

    BOOL b = FALSE;
    int  x[2] = { m_ptCursor.x * m_sizeCell.cx - m_ptTopLeft.x, x[0] + m_sizeCell.cx };
    int  y[2] = { m_ptCursor.y * m_sizeCell.cy - m_ptTopLeft.y, y[0] + m_sizeCell.cy };
    RECT r;
    GetClientRect (m_hWindow,&r);

    if (x[0] < r.left)
    {
        m_ptTopLeft.x += x[0];
        b = TRUE;
    }
    if (y[0] < r.top)
    {
        m_ptTopLeft.y += y[0];
        b = TRUE;
    }
    if (x[1] >= r.right)
    {
        m_ptTopLeft.x += x[1] - r.right + m_sizeCell.cx;
        b = TRUE;
    }
    if (y[1] >= r.bottom)
    {
        m_ptTopLeft.y += y[1] - r.bottom  + m_sizeCell.cy;
        b = TRUE;
    }
    if (b)
    {
        InvalidateRect (m_hWindow,NULL,TRUE);
    }
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::scrollBuffer
//
void BScreen::scrollBuffer
(
    void
)
{
    memmove (m_pawScreen,m_pawScreen + m_sizeBuffer.cx,m_sizeBuffer.cx * (m_sizeBuffer.cy - 1) * sizeof(WORD));
    fillWord (m_pawScreen + m_sizeBuffer.cx * (m_sizeBuffer.cy - 1),(m_dwCurrentColor << 8) | 0x20,m_sizeBuffer.cx);
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::getMessage
//
int BScreen::getMessage
(
    MESSAGE *pMsg
)
{
    EnterCriticalSection (&m_csThread);
    if (m_listMessage.isEmpty()) 
    {
        LeaveCriticalSection (&m_csThread);
        return 0;
    }
    *pMsg = m_listMessage.getHead();
    m_listMessage.removeHead();
    LeaveCriticalSection (&m_csThread);
    return 1;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::setFont
//
int BScreen::setFont
(
    const BString& strFont,
    int            iRecommendedFontHeight
)
{
    EnterCriticalSection (&m_csThread);
    destroyFont();

    m_strFontName = strFont;
    m_sizeFont.cy = iRecommendedFontHeight;

    createFont();
    forceProperSize();
    InvalidateRect (m_hWindow,NULL,TRUE);
    LeaveCriticalSection (&m_csThread);
    return 1;
}

int BScreen::setFont
(
    HBITMAP  hbmpFont,
    unsigned uCellsInWidth,
    unsigned uCellsInHeight,
    unsigned uCellWidth,
    unsigned uCellHeight
)
{
    EnterCriticalSection (&m_csThread);
    destroyFont();
    
    m_hbmpFontMap             = hbmpFont;
    m_sizeFont.cx             = uCellWidth;
    m_sizeFont.cy             = uCellHeight;
    m_sizeCellOrganization.cx = uCellsInWidth;
    m_sizeCellOrganization.cy = uCellsInHeight;

    createFont(); // if new bitmap is NULL then we recreate the last GDI font selected (but default size)
    forceProperSize();
    InvalidateRect (m_hWindow,NULL,TRUE);
    LeaveCriticalSection (&m_csThread);
    return 1;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::print
//
void BScreen::print
(
    const BString& str
)
{
    getMutex();

    DWORD dwColor = (m_dwCurrentColor << 8) & 0xff00;
    for (const char *psz = str; psz[0]; psz++)
    {
        switch (psz[0])
        {
            case '\n':   m_ptCursor.y++;                         break;
            case '\r':   m_ptCursor.x = 0;                       break;
            case '\t':   m_ptCursor.x = (m_ptCursor.x + 4) & ~3; break;
            case '\x01': clear2EOL(); break;
            default:
            {
                m_pawScreen[m_ptCursor.y * m_sizeBuffer.cx + m_ptCursor.x] = WORD(dwColor) | WORD(psz[0]);
                m_ptCursor.x++;
                break;
            }
        }

        if (m_ptCursor.x >= m_sizeBuffer.cx)
        {
            m_ptCursor.x = 0;
            m_ptCursor.y++;
        }
        assert (m_ptCursor.x < m_sizeBuffer.cx);
        if (m_ptCursor.y >= m_sizeBuffer.cy)
        {
            m_ptCursor.y--;
            scrollBuffer();
        }
        assert (m_ptCursor.y < m_sizeBuffer.cy);
    }

    scrollToCaret(); 
    releaseMutex();
    InvalidateRect (m_hWindow,NULL,FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::clear2EOL
//
void BScreen::clear2EOL
(
    void
)
{
    for (int x = m_ptCursor.x; x < m_sizeBuffer.cx; x++)
    {
        m_pawScreen[m_ptCursor.y * m_sizeBuffer.cx + x] = WORD(m_dwCurrentColor << 8) | WORD(0x20);
    }
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::create
//
BOOL BScreen::create
(
    HINSTANCE hInstance,
    int       iBufferWidth,
    int       iBufferHeight
)
{
    //
    // fail to create an already existing window
    //
    if (m_hThread)
    {
        return FALSE;
    }

    //
    // init
    //
    m_hInstance     = hInstance;
    m_sizeBuffer.cx = iBufferWidth;
    m_sizeBuffer.cy = iBufferHeight;
    m_ptTopLeft.x   = 0;
    m_ptTopLeft.y   = 0;
    m_sizeCell.cx   = 0; // will be set by font 
    m_sizeCell.cy   = 0; // will be set by font 
    m_sizeFont.cx   = 0; // will be set by font 
    m_sizeFont.cy   = 0; // desired - OS may adjust
    m_strFontName   = "FixedSys";

    m_ptCursor.x     = 0;
    m_ptCursor.y     = 0;
    m_dwCurrentColor = 0x08;
    m_iCaretWidth    = 2;

    //
    // default palette
    //
    m_acolPalette[ 0] = RGB(0x00,0x00,0x00);
    m_acolPalette[ 1] = RGB(0x00,0x00,0x80);
    m_acolPalette[ 2] = RGB(0x00,0x80,0x00);
    m_acolPalette[ 3] = RGB(0x00,0x80,0x80);
    m_acolPalette[ 4] = RGB(0x80,0x00,0x00);
    m_acolPalette[ 5] = RGB(0x80,0x00,0x80);
    m_acolPalette[ 6] = RGB(0x80,0x80,0x00);
    m_acolPalette[ 7] = RGB(0x80,0x80,0x80);
    m_acolPalette[ 8] = RGB(0x80,0x80,0xf0);
    m_acolPalette[ 9] = RGB(0x00,0x00,0xff);
    m_acolPalette[10] = RGB(0x00,0xff,0x00);
    m_acolPalette[11] = RGB(0x00,0xff,0xff);
    m_acolPalette[12] = RGB(0xff,0x00,0x00);
    m_acolPalette[13] = RGB(0xff,0x00,0xff);
    m_acolPalette[14] = RGB(0xff,0xff,0x00);
    m_acolPalette[15] = RGB(0xff,0xff,0xff);


    //
    // create worker thread
    //
    m_enumThreadStatus = threadStarting;
    m_hThread          = CreateThread(NULL,0,__BScreen_createScreen,this,0,&m_dwThreadID);
    if (!m_hThread)
    {
        destroy();
        return FALSE;
    }

    //
    // wait for thread to signal creation success
    //
    THREAD_STATUS status;
    do
    {
        Sleep (1);
        EnterCriticalSection (&m_csThread);
        status = m_enumThreadStatus;
        LeaveCriticalSection (&m_csThread);
    } while (status == threadStarting);
    if (status == threadAbnormalTermination)
    {
        // window creation failed
        destroy();
        return FALSE;
    }

    //
    // done
    //
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::destroy
//
BOOL BScreen::destroy
(
    void
)
{
    //
    // kill worker thread
    //
    if (m_hThread)
    {
        THREAD_STATUS status;
        SendMessage (m_hWindow,WM_MUSTCLOSE,0,0L);
        
        // try to shut down for 100ms (works around a bug where the OS wont let
        //  the window die while you are trying to use it (resize/scroll/capture), even though you post WM_CLOSE)
        for (int i = 0; i < 100; i++)
        {
            Sleep (1);
            EnterCriticalSection (&m_csThread);
            status = m_enumThreadStatus;
            LeaveCriticalSection (&m_csThread);

            if (status > threadRunning)
            {
                break;
            }

            SendMessage (m_hWindow,WM_MUSTCLOSE,0,0L);
        } 

        CloseHandle (m_hThread);
        m_hThread = NULL;
    }

    //
    // done
    //
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::BScreen
//
BScreen::BScreen (void)
{
    //
    // init
    //
    InitializeCriticalSection (&m_csThread);
    m_hThread      = NULL;
    m_pawScreen    = NULL;
    m_hFont        = NULL;
    m_paiSpacing   = NULL;
    m_dwFlags      = 0;
    m_dwCaretCount = 1;
    m_pfnHandler   = NULL;
    m_hbmpFontMap  = NULL;
}

//////////////////////////////////////////////////////////////////////////////
// BScreen::~BScreen
//
BScreen::~BScreen (void)
{
    //
    // clean up
    //
    destroy();
    DeleteCriticalSection (&m_csThread);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// console
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BConsole::showLine
//
void BConsole::showLine
(
    const BString& strLine,
    const POINT&   ptStart,
          DWORD    dwCrsr
)
{
    m_Screen.gotoXY (ptStart);
    m_Screen.print  (strLine);
    m_Screen.clear2EOL();
    m_Screen.gotoXY ((ptStart.x + dwCrsr) % m_sizeBuffer.cx,
                     (ptStart.x + dwCrsr) / m_sizeBuffer.cx + ptStart.y);
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::findName
//
int BConsole::findName
(
    const BString&  strMatch,
          BString  *pstrResult,
          BOOL      bList
)
{
    // any work?
    if (m_listName.isEmpty()) return 0;

    // create a list of sub-matches
    BLinkedList<BString,const BString&> list;
    BPosition pos = m_listName.getHeadPosition();
    while (pos)
    {
        BString str = m_listName.getNextPosition(pos);
        if (!strncmp(str,strMatch,strMatch.length()))
        {
            list.addHead (str);
        }
    }
    if (list.isEmpty()) return 0;

    // find the longest string all words have in common
    if (bList) print ("\r\n");
    DWORD dwCommonLen = ~0;
    pos = list.getHeadPosition();
    while (pos)
    {
        BString   s1 = list.getNextPosition(pos);
        dwCommonLen  = bmin(dwCommonLen,(DWORD)s1.length());
        BPosition p2 = pos;
        while (p2)
        {
            BString s2  = list.getNextPosition(p2);
            dwCommonLen = bmin(dwCommonLen,(DWORD)s2.length());

            const char  *c1 = s1;
            const char  *c2 = s2;
                  DWORD  dw = dwCommonLen;
            while (c1[0] && dw && (*c1 == *c2)) c1++,c2++,dw--;
            if (dw) dwCommonLen -= dw;
        }
        if (bList) print ("%s\t",(const char*)s1);
    }
    if (bList) print ("\r\n");

    // prepare to return
    *pstrResult = BString(list.getHead()).left(dwCommonLen);
    return 1;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::reset
//
void BConsole::reset
(
    void
)
{
    m_dwFlags |= flagResetCmdLine;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::print
//
void BConsole::print
(
    const char *pszFormat,
    ...
)
{
    //
    // compose
    //
    char szBuffer[8192];
    vsprintf (szBuffer,pszFormat,(char*)(DWORD(&pszFormat) + 4));

    //
    // print
    //
    m_Screen.print (szBuffer);
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::read
//
BConsole::READRESULT BConsole::read
(
    const BString&  strPrompt,
    BString        *pstrText,
    READIDLEFUNC    pfnIdleFunc,
    void           *pContext
)
{
    //
    // start new input
    //
    BString   strLine       = "";
    DWORD     dwCrsr        = 0;
    DWORD     dwHistoryPos  = 0; // zero means current line
    DWORD     dwLastTab     = 0;
    DWORD     dwLastTabCrsr = ~0;
    POINT     ptStart;

    // prompt
    print ("%s",(const char*)strPrompt);
    m_Screen.getXY (&ptStart);

    //
    // process messages
    //
    READRESULT res;
    for (BOOL bQuit = FALSE; !bQuit; )
    {
        if (m_dwFlags & flagResetCmdLine)
        {
            print ("%s",(const char*)strPrompt);
            m_Screen.getXY (&ptStart);
            showLine (strLine,ptStart,dwCrsr);
            m_dwFlags &= ~flagResetCmdLine;
        }

        BScreen::MESSAGE msg;
        if (m_Screen.getMessage(&msg))
        {
            switch (msg.uMessage)
            {
                case WM_KEYDOWN:
                {
                    switch (msg.wParam)
                    {
                        case VK_HOME:
                        {
                            dwCrsr = 0;
                            showLine (strLine,ptStart,dwCrsr);
                            break;
                        }
                        case VK_END:
                        {
                            dwCrsr = strLine.length();
                            showLine (strLine,ptStart,dwCrsr);
                            break;
                        }
                        case VK_LEFT:
                        {
                            if (dwCrsr) dwCrsr--;
                            showLine (strLine,ptStart,dwCrsr);
                            break;
                        }
                        case VK_RIGHT:
                        {
                            if (dwCrsr < (DWORD)strLine.length()) dwCrsr++;
                            showLine (strLine,ptStart,dwCrsr);
                            break;
                        }
                        case VK_INSERT:
                        {
                            m_dwFlags ^= flagOverwrite;
                            m_Screen.setCaretWidth ((m_dwFlags & flagOverwrite) ? 1000 : 0); // full width or most narrow
                            break;
                        }
                        case VK_DELETE:
                        {
                            if (dwCrsr < (DWORD)strLine.length())
                            {
                                strLine.remove (dwCrsr);
                                showLine (strLine,ptStart,dwCrsr);
                            }
                            break;
                        }
                        case VK_DOWN:
                        {
                            if (m_dwFlags & flagHistory)
                            {
                                if (dwHistoryPos)
                                {
                                    dwHistoryPos--;
                                    if (dwHistoryPos)
                                    {
                                        BPosition pos = m_listHistory.getIndexPosition(dwHistoryPos - 1);
                                        strLine = pos ? m_listHistory.getData(pos) : "";
                                    }
                                    else
                                    {
                                        strLine = "";
                                    }
                                    dwCrsr  = strLine.length();
                                    showLine (strLine,ptStart,dwCrsr);
                                }
                            }
                            break;
                        }
                        case VK_UP:
                        {
                            if (m_dwFlags & flagHistory)
                            {
                                if (dwHistoryPos < m_dwHistoryCount)
                                {
                                    dwHistoryPos++;
                                    BPosition pos = m_listHistory.getIndexPosition(dwHistoryPos - 1);
                                    strLine = pos ? m_listHistory.getData(pos) : "";
                                    dwCrsr  = strLine.length();
                                    showLine (strLine,ptStart,dwCrsr);
                                }
                            }
                            break;
                        }
                    }
                    break;
                }
                case WM_CHAR:
                {
                    switch (msg.wParam)
                    {
                        case '\t':
                        {
                            // name completion
                            if ((m_dwFlags & flagNameCompletion)     // enabled
                             && (dwCrsr == (DWORD)strLine.length())) // crsr must be at EOL
                            {
                                // get time to see if we have a double-tab
                                DWORD dwNow = GetTickCount();
                                BOOL  bList = ((dwNow - dwLastTab) < 500)
                                           && ((dwCrsr == dwLastTabCrsr));
                                dwLastTab     = dwNow;
                                dwLastTabCrsr = dwCrsr;
                                // get current word
                                const char *sz = strLine;
                                const char *ch = sz + strlen(sz);
                                while ((ch > sz) && (!isspace(ch[-1]))) ch--;
                                // find best match
                                BString strMatch;
                                if (ch[0] 
                                 && findName(BString(ch),&strMatch,bList))
                                {
                                    if (bList) m_Screen.getXY (&ptStart);
                                    strLine.place (ch - sz,strMatch);
                                    dwCrsr = strLine.length();
                                }
                                else
                                {
                                    //if (bList) m_Screen.getXY (&ptStart);
                                }
                                showLine (strLine,ptStart,dwCrsr);
                            }
                            break;
                        }
                        case 13:
                        {
                            if (m_dwFlags & flagHistory)
                            {
                                m_listHistory.addHead (strLine);
                                m_dwHistoryCount ++;
                                if (m_dwHistoryCount > 5000)
                                {
                                    m_listHistory.removeTail();
                                    m_dwHistoryCount--;
                                }
                            }

                            m_Screen.print ("\r\n");
                            *pstrText = strLine;
                            res       = success;
                            bQuit     = TRUE;
                            break;
                        }
                        case 8:
                        {
                            if (dwCrsr
                             && strLine.length())
                            {
                                dwCrsr--;
                                strLine.remove (dwCrsr);
                                showLine (strLine,ptStart,dwCrsr);
                            }
                            break;
                        }
                        default:
                        {
                            if (msg.wParam >= 32)
                            {
                                char sz[2] = { char(msg.wParam),0 };
                                if (m_dwFlags & flagOverwrite) strLine.place  (dwCrsr,sz);
                                                          else strLine.insert (dwCrsr,sz);
                                dwCrsr++;
                                showLine (strLine,ptStart,dwCrsr);
                            }
                            break;
                        }
                    }
                    break;
                }
                case WM_CLOSE:
                {
                    m_dwFlags |= flagScreenClosed;
                    res        = closed;
                    bQuit      = TRUE;
                    break;
                }
            }
        }
        else
        {
            if (pfnIdleFunc) 
            {
                res = pfnIdleFunc(pContext);
                if (res != success) bQuit = TRUE; // caller asked for termination
            }
            Sleep (10);
        }
    }

    //
    // done
    //
    return res;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::create
//
BOOL BConsole::create
(
    HINSTANCE hInstance,
    int       iBufferWidth,
    int       iBufferHeight
)
{
    //
    // create screen
    //
    if (!m_Screen.create(hInstance,iBufferWidth,iBufferHeight))
    {
        return FALSE;
    }
    m_sizeBuffer.cx = iBufferWidth;
    m_sizeBuffer.cy = iBufferHeight;

    //
    // init
    //
    m_dwFlags        = 0;
    m_dwHistoryCount = 0;
    m_listHistory.removeAll();

    //
    // prepare for console mode
    //
    m_Screen.setCaretWidth ((m_dwFlags & flagOverwrite) ? 1000 : 0); // full width or most narrow
    m_Screen.showCaret();

    //
    // done
    //
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::destroy
//
BOOL BConsole::destroy
(
    void
)
{
    //
    // destroy screen
    //
    m_Screen.destroy();

    //
    // clean up
    //
    m_dwFlags |= flagScreenClosed;

    //
    // done
    //
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::BConsole
//
BConsole::BConsole
(
    void
)
{
    //
    // init
    //
    m_dwFlags |= flagScreenClosed;
}

//////////////////////////////////////////////////////////////////////////////
// BConsole::~BConsole
//
BConsole::~BConsole
(
    void
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\sdk\nvidia\dx8\d3dcaps.h ===
/*==========================================================================;
 *
 *
 *  File:       d3dcaps.h
 *  Content:    Direct3D capabilities include file
 *
 ***************************************************************************/

#ifndef _D3DCAPS_H
#define _D3DCAPS_H

/*
 *  Pull in DirectDraw include file automatically:
 */
#include "ddraw.h"

#ifndef DIRECT3D_VERSION
#define DIRECT3D_VERSION         0x0700
#endif

#pragma pack(4)

/* Description of capabilities of transform */

typedef struct _D3DTRANSFORMCAPS {
    DWORD dwSize;
    DWORD dwCaps;
} D3DTRANSFORMCAPS, *LPD3DTRANSFORMCAPS;

#define D3DTRANSFORMCAPS_CLIP           0x00000001L /* Will clip whilst transforming */

/* Description of capabilities of lighting */

typedef struct _D3DLIGHTINGCAPS {
    DWORD dwSize;
    DWORD dwCaps;                   /* Lighting caps */
    DWORD dwLightingModel;          /* Lighting model - RGB or mono */
    DWORD dwNumLights;              /* Number of lights that can be handled */
} D3DLIGHTINGCAPS, *LPD3DLIGHTINGCAPS;

#define D3DLIGHTINGMODEL_RGB            0x00000001L
#define D3DLIGHTINGMODEL_MONO           0x00000002L

#define D3DLIGHTCAPS_POINT              0x00000001L /* Point lights supported */
#define D3DLIGHTCAPS_SPOT               0x00000002L /* Spot lights supported */
#define D3DLIGHTCAPS_DIRECTIONAL        0x00000004L /* Directional lights supported */
#if(DIRECT3D_VERSION < 0x700)
#define D3DLIGHTCAPS_PARALLELPOINT      0x00000008L /* Parallel point lights supported */
#endif
#if(DIRECT3D_VERSION < 0x500)
#define D3DLIGHTCAPS_GLSPOT             0x00000010L /* GL syle spot lights supported */
#endif

/* Description of capabilities for each primitive type */

typedef struct _D3DPrimCaps {
    DWORD dwSize;
    DWORD dwMiscCaps;                 /* Capability flags */
    DWORD dwRasterCaps;
    DWORD dwZCmpCaps;
    DWORD dwSrcBlendCaps;
    DWORD dwDestBlendCaps;
    DWORD dwAlphaCmpCaps;
    DWORD dwShadeCaps;
    DWORD dwTextureCaps;
    DWORD dwTextureFilterCaps;
    DWORD dwTextureBlendCaps;
    DWORD dwTextureAddressCaps;
    DWORD dwStippleWidth;             /* maximum width and height of */
    DWORD dwStippleHeight;            /* of supported stipple (up to 32x32) */
} D3DPRIMCAPS, *LPD3DPRIMCAPS;

/* D3DPRIMCAPS dwMiscCaps */

#define D3DPMISCCAPS_MASKPLANES         0x00000001L
#define D3DPMISCCAPS_MASKZ              0x00000002L
#define D3DPMISCCAPS_LINEPATTERNREP     0x00000004L
#define D3DPMISCCAPS_CONFORMANT         0x00000008L
#define D3DPMISCCAPS_CULLNONE           0x00000010L
#define D3DPMISCCAPS_CULLCW             0x00000020L
#define D3DPMISCCAPS_CULLCCW            0x00000040L

/* D3DPRIMCAPS dwRasterCaps */

#define D3DPRASTERCAPS_DITHER                   0x00000001L
#define D3DPRASTERCAPS_ROP2                     0x00000002L
#define D3DPRASTERCAPS_XOR                      0x00000004L
#define D3DPRASTERCAPS_PAT                      0x00000008L
#define D3DPRASTERCAPS_ZTEST                    0x00000010L
#define D3DPRASTERCAPS_SUBPIXEL                 0x00000020L
#define D3DPRASTERCAPS_SUBPIXELX                0x00000040L
#define D3DPRASTERCAPS_FOGVERTEX                0x00000080L
#define D3DPRASTERCAPS_FOGTABLE                 0x00000100L
#define D3DPRASTERCAPS_STIPPLE                  0x00000200L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   0x00000400L
#define D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT 0x00000800L
#define D3DPRASTERCAPS_ANTIALIASEDGES           0x00001000L
#define D3DPRASTERCAPS_MIPMAPLODBIAS            0x00002000L
#define D3DPRASTERCAPS_ZBIAS                    0x00004000L
#define D3DPRASTERCAPS_ZBUFFERLESSHSR           0x00008000L
#define D3DPRASTERCAPS_FOGRANGE                 0x00010000L
#define D3DPRASTERCAPS_ANISOTROPY               0x00020000L
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DPRASTERCAPS_WBUFFER                      0x00040000L
#define D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT   0x00080000L
#define D3DPRASTERCAPS_WFOG                         0x00100000L
#define D3DPRASTERCAPS_ZFOG                         0x00200000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwZCmpCaps, dwAlphaCmpCaps */

#define D3DPCMPCAPS_NEVER               0x00000001L
#define D3DPCMPCAPS_LESS                0x00000002L
#define D3DPCMPCAPS_EQUAL               0x00000004L
#define D3DPCMPCAPS_LESSEQUAL           0x00000008L
#define D3DPCMPCAPS_GREATER             0x00000010L
#define D3DPCMPCAPS_NOTEQUAL            0x00000020L
#define D3DPCMPCAPS_GREATEREQUAL        0x00000040L
#define D3DPCMPCAPS_ALWAYS              0x00000080L

/* D3DPRIMCAPS dwSourceBlendCaps, dwDestBlendCaps */

#define D3DPBLENDCAPS_ZERO              0x00000001L
#define D3DPBLENDCAPS_ONE               0x00000002L
#define D3DPBLENDCAPS_SRCCOLOR          0x00000004L
#define D3DPBLENDCAPS_INVSRCCOLOR       0x00000008L
#define D3DPBLENDCAPS_SRCALPHA          0x00000010L
#define D3DPBLENDCAPS_INVSRCALPHA       0x00000020L
#define D3DPBLENDCAPS_DESTALPHA         0x00000040L
#define D3DPBLENDCAPS_INVDESTALPHA      0x00000080L
#define D3DPBLENDCAPS_DESTCOLOR         0x00000100L
#define D3DPBLENDCAPS_INVDESTCOLOR      0x00000200L
#define D3DPBLENDCAPS_SRCALPHASAT       0x00000400L
#define D3DPBLENDCAPS_BOTHSRCALPHA      0x00000800L
#define D3DPBLENDCAPS_BOTHINVSRCALPHA   0x00001000L

/* D3DPRIMCAPS dwShadeCaps */

#define D3DPSHADECAPS_COLORFLATMONO             0x00000001L
#define D3DPSHADECAPS_COLORFLATRGB              0x00000002L
#define D3DPSHADECAPS_COLORGOURAUDMONO          0x00000004L
#define D3DPSHADECAPS_COLORGOURAUDRGB           0x00000008L
#define D3DPSHADECAPS_COLORPHONGMONO            0x00000010L
#define D3DPSHADECAPS_COLORPHONGRGB             0x00000020L

#define D3DPSHADECAPS_SPECULARFLATMONO          0x00000040L
#define D3DPSHADECAPS_SPECULARFLATRGB           0x00000080L
#define D3DPSHADECAPS_SPECULARGOURAUDMONO       0x00000100L
#define D3DPSHADECAPS_SPECULARGOURAUDRGB        0x00000200L
#define D3DPSHADECAPS_SPECULARPHONGMONO         0x00000400L
#define D3DPSHADECAPS_SPECULARPHONGRGB          0x00000800L

#define D3DPSHADECAPS_ALPHAFLATBLEND            0x00001000L
#define D3DPSHADECAPS_ALPHAFLATSTIPPLED         0x00002000L
#define D3DPSHADECAPS_ALPHAGOURAUDBLEND         0x00004000L
#define D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED      0x00008000L
#define D3DPSHADECAPS_ALPHAPHONGBLEND           0x00010000L
#define D3DPSHADECAPS_ALPHAPHONGSTIPPLED        0x00020000L

#define D3DPSHADECAPS_FOGFLAT                   0x00040000L
#define D3DPSHADECAPS_FOGGOURAUD                0x00080000L
#define D3DPSHADECAPS_FOGPHONG                  0x00100000L

/* D3DPRIMCAPS dwTextureCaps */

/*
 * Perspective-correct texturing is supported
 */
#define D3DPTEXTURECAPS_PERSPECTIVE     0x00000001L

/*
 * Power-of-2 texture dimensions are required
 */
#define D3DPTEXTURECAPS_POW2            0x00000002L

/*
 * Alpha in texture pixels is supported
 */
#define D3DPTEXTURECAPS_ALPHA           0x00000004L

/*
 * Color-keyed textures are supported
 */
#define D3DPTEXTURECAPS_TRANSPARENCY    0x00000008L

/*
 * obsolete, see D3DPTADDRESSCAPS_BORDER
 */
#define D3DPTEXTURECAPS_BORDER          0x00000010L

/*
 * Only square textures are supported
 */
#define D3DPTEXTURECAPS_SQUAREONLY      0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/*
 * Texture indices are not scaled by the texture size prior
 * to interpolation.
 */
#define D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE 0x00000040L

/*
 * Device can draw alpha from texture palettes
 */
#define D3DPTEXTURECAPS_ALPHAPALETTE    0x00000080L

/*
 * Device can use non-POW2 textures if:
 *  1) D3DTEXTURE_ADDRESS is set to CLAMP for this texture's stage
 *  2) D3DRS_WRAP(N) is zero for this texture's coordinates
 *  3) mip mapping is not enabled (use magnification filter only)
 */
#define D3DPTEXTURECAPS_NONPOW2CONDITIONAL  0x00000100L

#endif /* DIRECT3D_VERSION >= 0x0600 */
#if(DIRECT3D_VERSION >= 0x0700)

// 0x00000200L unused

/*
 * Device can divide transformed texture coordinates by the
 * COUNTth texture coordinate (can do D3DTTFF_PROJECTED)
 */
#define D3DPTEXTURECAPS_PROJECTED  0x00000400L

/*
 * Device can do cubemap textures
 */
#define D3DPTEXTURECAPS_CUBEMAP           0x00000800L

#define D3DPTEXTURECAPS_COLORKEYBLEND     0x00001000L
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DPRIMCAPS dwTextureFilterCaps */

#define D3DPTFILTERCAPS_NEAREST         0x00000001L
#define D3DPTFILTERCAPS_LINEAR          0x00000002L
#define D3DPTFILTERCAPS_MIPNEAREST      0x00000004L
#define D3DPTFILTERCAPS_MIPLINEAR       0x00000008L
#define D3DPTFILTERCAPS_LINEARMIPNEAREST 0x00000010L
#define D3DPTFILTERCAPS_LINEARMIPLINEAR 0x00000020L

#if(DIRECT3D_VERSION >= 0x0600)
/* Device3 Min Filter */
#define D3DPTFILTERCAPS_MINFPOINT       0x00000100L
#define D3DPTFILTERCAPS_MINFLINEAR      0x00000200L
#define D3DPTFILTERCAPS_MINFANISOTROPIC 0x00000400L

/* Device3 Mip Filter */
#define D3DPTFILTERCAPS_MIPFPOINT       0x00010000L
#define D3DPTFILTERCAPS_MIPFLINEAR      0x00020000L

/* Device3 Mag Filter */
#define D3DPTFILTERCAPS_MAGFPOINT         0x01000000L
#define D3DPTFILTERCAPS_MAGFLINEAR        0x02000000L
#define D3DPTFILTERCAPS_MAGFANISOTROPIC   0x04000000L
#define D3DPTFILTERCAPS_MAGFAFLATCUBIC    0x08000000L
#define D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC 0x10000000L
#endif /* DIRECT3D_VERSION >= 0x0600 */

/* D3DPRIMCAPS dwTextureBlendCaps */

#define D3DPTBLENDCAPS_DECAL            0x00000001L
#define D3DPTBLENDCAPS_MODULATE         0x00000002L
#define D3DPTBLENDCAPS_DECALALPHA       0x00000004L
#define D3DPTBLENDCAPS_MODULATEALPHA    0x00000008L
#define D3DPTBLENDCAPS_DECALMASK        0x00000010L
#define D3DPTBLENDCAPS_MODULATEMASK     0x00000020L
#define D3DPTBLENDCAPS_COPY             0x00000040L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTBLENDCAPS_ADD              0x00000080L
#endif /* DIRECT3D_VERSION >= 0x0500 */

/* D3DPRIMCAPS dwTextureAddressCaps */
#define D3DPTADDRESSCAPS_WRAP           0x00000001L
#define D3DPTADDRESSCAPS_MIRROR         0x00000002L
#define D3DPTADDRESSCAPS_CLAMP          0x00000004L
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DPTADDRESSCAPS_BORDER         0x00000008L
#define D3DPTADDRESSCAPS_INDEPENDENTUV  0x00000010L
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)

/* D3DDEVICEDESC dwStencilCaps */

#define D3DSTENCILCAPS_KEEP     0x00000001L
#define D3DSTENCILCAPS_ZERO     0x00000002L
#define D3DSTENCILCAPS_REPLACE  0x00000004L
#define D3DSTENCILCAPS_INCRSAT  0x00000008L
#define D3DSTENCILCAPS_DECRSAT  0x00000010L
#define D3DSTENCILCAPS_INVERT   0x00000020L
#define D3DSTENCILCAPS_INCR     0x00000040L
#define D3DSTENCILCAPS_DECR     0x00000080L

/* D3DDEVICEDESC dwTextureOpCaps */

#define D3DTEXOPCAPS_DISABLE                    0x00000001L
#define D3DTEXOPCAPS_SELECTARG1                 0x00000002L
#define D3DTEXOPCAPS_SELECTARG2                 0x00000004L
#define D3DTEXOPCAPS_MODULATE                   0x00000008L
#define D3DTEXOPCAPS_MODULATE2X                 0x00000010L
#define D3DTEXOPCAPS_MODULATE4X                 0x00000020L
#define D3DTEXOPCAPS_ADD                        0x00000040L
#define D3DTEXOPCAPS_ADDSIGNED                  0x00000080L
#define D3DTEXOPCAPS_ADDSIGNED2X                0x00000100L
#define D3DTEXOPCAPS_SUBTRACT                   0x00000200L
#define D3DTEXOPCAPS_ADDSMOOTH                  0x00000400L
#define D3DTEXOPCAPS_BLENDDIFFUSEALPHA          0x00000800L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHA          0x00001000L
#define D3DTEXOPCAPS_BLENDFACTORALPHA           0x00002000L
#define D3DTEXOPCAPS_BLENDTEXTUREALPHAPM        0x00004000L
#define D3DTEXOPCAPS_BLENDCURRENTALPHA          0x00008000L
#define D3DTEXOPCAPS_PREMODULATE                0x00010000L
#define D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR     0x00020000L
#define D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA     0x00040000L
#define D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR  0x00080000L
#define D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA  0x00100000L
#define D3DTEXOPCAPS_BUMPENVMAP                 0x00200000L
#define D3DTEXOPCAPS_BUMPENVMAPLUMINANCE        0x00400000L
#define D3DTEXOPCAPS_DOTPRODUCT3                0x00800000L

/* D3DDEVICEDESC dwFVFCaps flags */

#define D3DFVFCAPS_TEXCOORDCOUNTMASK    0x0000ffffL /* mask for texture coordinate count field */
#define D3DFVFCAPS_DONOTSTRIPELEMENTS   0x00080000L /* Device prefers that vertex elements not be stripped */

#endif /* DIRECT3D_VERSION >= 0x0600 */

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 */
typedef struct _D3DDeviceDesc {
    DWORD            dwSize;                 /* Size of D3DDEVICEDESC structure */
    DWORD            dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;          /* Color model of device */
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL             bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD            dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD            dwMaxVertexCount;       /* Maximum vertex count */
#if(DIRECT3D_VERSION >= 0x0500)
    // *** New fields for DX5 *** //

    // Width and height caps are 0 for legacy HALs.
    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;
#endif /* DIRECT3D_VERSION >= 0x0500 */

#if(DIRECT3D_VERSION >= 0x0600)
    // New fields for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    // Guard band that the rasterizer can accommodate
    // Screen-space vertices inside this space but outside the viewport
    // will get clipped properly.
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#endif /* DIRECT3D_VERSION >= 0x0600 */
} D3DDEVICEDESC, *LPD3DDEVICEDESC;

#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DDeviceDesc7 {
    DWORD            dwDevCaps;              /* Capabilities of device */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBB_8, 16, etc.. */
    DWORD            dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */

    DWORD       dwMinTextureWidth, dwMinTextureHeight;
    DWORD       dwMaxTextureWidth, dwMaxTextureHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;

    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;

    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;

    DWORD       dwFVFCaps;
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;
    GUID        deviceGUID;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
} D3DDEVICEDESC7, *LPD3DDEVICEDESC7;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#define D3DDEVICEDESCSIZE (sizeof(D3DDEVICEDESC))
#define D3DDEVICEDESC7SIZE (sizeof(D3DDEVICEDESC7))

typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK)(GUID FAR *lpGuid, LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC, LPD3DDEVICEDESC, LPVOID);

#if(DIRECT3D_VERSION >= 0x0700)
typedef HRESULT (CALLBACK * LPD3DENUMDEVICESCALLBACK7)(LPSTR lpDeviceDescription, LPSTR lpDeviceName, LPD3DDEVICEDESC7, LPVOID);
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* D3DDEVICEDESC dwFlags indicating valid fields */

#define D3DDD_COLORMODEL            0x00000001L /* dcmColorModel is valid */
#define D3DDD_DEVCAPS               0x00000002L /* dwDevCaps is valid */
#define D3DDD_TRANSFORMCAPS         0x00000004L /* dtcTransformCaps is valid */
#define D3DDD_LIGHTINGCAPS          0x00000008L /* dlcLightingCaps is valid */
#define D3DDD_BCLIPPING             0x00000010L /* bClipping is valid */
#define D3DDD_LINECAPS              0x00000020L /* dpcLineCaps is valid */
#define D3DDD_TRICAPS               0x00000040L /* dpcTriCaps is valid */
#define D3DDD_DEVICERENDERBITDEPTH  0x00000080L /* dwDeviceRenderBitDepth is valid */
#define D3DDD_DEVICEZBUFFERBITDEPTH 0x00000100L /* dwDeviceZBufferBitDepth is valid */
#define D3DDD_MAXBUFFERSIZE         0x00000200L /* dwMaxBufferSize is valid */
#define D3DDD_MAXVERTEXCOUNT        0x00000400L /* dwMaxVertexCount is valid */

/* D3DDEVICEDESC dwDevCaps flags */

#define D3DDEVCAPS_FLOATTLVERTEX        0x00000001L /* Device accepts floating point */
                                                    /* for post-transform vertex data */
#define D3DDEVCAPS_SORTINCREASINGZ      0x00000002L /* Device needs data sorted for increasing Z */
#define D3DDEVCAPS_SORTDECREASINGZ      0X00000004L /* Device needs data sorted for decreasing Z */
#define D3DDEVCAPS_SORTEXACT            0x00000008L /* Device needs data sorted exactly */

#define D3DDEVCAPS_EXECUTESYSTEMMEMORY  0x00000010L /* Device can use execute buffers from system memory */
#define D3DDEVCAPS_EXECUTEVIDEOMEMORY   0x00000020L /* Device can use execute buffers from video memory */
#define D3DDEVCAPS_TLVERTEXSYSTEMMEMORY 0x00000040L /* Device can use TL buffers from system memory */
#define D3DDEVCAPS_TLVERTEXVIDEOMEMORY  0x00000080L /* Device can use TL buffers from video memory */
#define D3DDEVCAPS_TEXTURESYSTEMMEMORY  0x00000100L /* Device can texture from system memory */
#define D3DDEVCAPS_TEXTUREVIDEOMEMORY   0x00000200L /* Device can texture from device memory */
#if(DIRECT3D_VERSION >= 0x0500)
#define D3DDEVCAPS_DRAWPRIMTLVERTEX     0x00000400L /* Device can draw TLVERTEX primitives */
#define D3DDEVCAPS_CANRENDERAFTERFLIP   0x00000800L /* Device can render without waiting for flip to complete */
#define D3DDEVCAPS_TEXTURENONLOCALVIDMEM 0x00001000L /* Device can texture from nonlocal video memory */
#endif /* DIRECT3D_VERSION >= 0x0500 */
#if(DIRECT3D_VERSION >= 0x0600)
#define D3DDEVCAPS_DRAWPRIMITIVES2         0x00002000L /* Device can support DrawPrimitives2 */
#define D3DDEVCAPS_SEPARATETEXTUREM